Project Path: arc_ryanjon2040_UnrealNetworkProfiler_wqr2vqh1

Source Tree:

```txt
arc_ryanjon2040_UnrealNetworkProfiler_wqr2vqh1
├── LICENSE
├── NetworkProfiler.png
├── Profiler.gif
├── README.md
├── UE4 Network Profiler
│   ├── App.config
│   ├── App.xaml
│   ├── App.xaml.cs
│   ├── Classes
│   │   ├── BinaryReaderBigEndian.cs
│   │   ├── ChartParser.cs
│   │   ├── NetworkStream.cs
│   │   ├── PartialNetworkStream.cs
│   │   ├── StreamHeader.cs
│   │   ├── StreamParser.cs
│   │   └── Tokens.cs
│   ├── MainWindow.xaml
│   ├── MainWindow.xaml.cs
│   ├── Properties
│   │   ├── AssemblyInfo.cs
│   │   ├── Resources.Designer.cs
│   │   ├── Resources.resx
│   │   ├── Settings.Designer.cs
│   │   └── Settings.settings
│   ├── UE4 Network Profiler.csproj
│   ├── UserControls
│   │   ├── AboutDialog.xaml
│   │   └── AboutDialog.xaml.cs
│   └── packages.config
└── UE4 Network Profiler.sln

```

`LICENSE`:

```
MIT License

Copyright (c) 2021 Satheesh (ryanjon2040)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
Unreal Engine Network Profiler
======================

![GIF](Profiler.gif)

<a href="https://www.buymeacoffee.com/ryanjon2040" target="_blank"><img src="https://www.buymeacoffee.com/assets/img/custom_images/yellow_img.png" alt="Buy Me A Coffee" style="height: 41px !important;width: 174px !important;box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;" ></a>

This is a WPF rewrite of Network Profiler by Epic Games. Check out the original program at [Unreal Engine Repository](https://github.com/EpicGames/UnrealEngine/tree/master/Engine/Source/Programs/NetworkProfiler).

![https://twitter.com/ryanjon2040](https://img.shields.io/twitter/follow/ryanjon2040.svg?style=popout)

![](https://img.shields.io/github/last-commit/ryanjon2040/UnrealNetworkProfiler.svg?style=popout) 
![](https://img.shields.io/github/license/ryanjon2040/UnrealNetworkProfiler.svg?style=popout) ![](https://img.shields.io/github/downloads/ryanjon2040/UnrealNetworkProfiler/total.svg?style=popout) 

![](https://img.shields.io/github/languages/code-size/ryanjon2040/UnrealNetworkProfiler.svg?style=flat) ![](https://img.shields.io/github/repo-size/ryanjon2040/UnrealNetworkProfiler.svg?style=flat)

Limitations
===================

* Clicking on graph to view data for single frame is not supported.

* Selecting a range from the graph is not supported.

* List view sorting is not supported.

Dependencies
===================

[HandyControl](https://github.com/HandyOrg/HandyControl)

[ScottPlot](https://github.com/ScottPlot/ScottPlot)

[GameAnalytics](https://github.com/GameAnalytics/GA-SDK-C-SHARP)

```

`UE4 Network Profiler.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31005.135
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "UE4 Network Profiler", "UE4 Network Profiler\UE4 Network Profiler.csproj", "{1466DE04-14E6-482D-9285-C6359C79EB19}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{1466DE04-14E6-482D-9285-C6359C79EB19}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{1466DE04-14E6-482D-9285-C6359C79EB19}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{1466DE04-14E6-482D-9285-C6359C79EB19}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{1466DE04-14E6-482D-9285-C6359C79EB19}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {E814D7E3-C849-40F8-8AD3-CB964A088CB0}
	EndGlobalSection
EndGlobal

```

`UE4 Network Profiler/App.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.7.2"/>
    </startup>
</configuration>

```

`UE4 Network Profiler/App.xaml`:

```xaml
<Application x:Class="UE4_Network_Profiler.App"
			 xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
			 xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
			 xmlns:hc="https://handyorg.github.io/handycontrol"
			 xmlns:local="clr-namespace:UE4_Network_Profiler"
			 StartupUri="MainWindow.xaml">
	<Application.Resources>
		<ResourceDictionary>
			<ResourceDictionary.MergedDictionaries>
				<ResourceDictionary Source="pack://application:,,,/HandyControl;component/Themes/SkinDark.xaml"/>
				<ResourceDictionary Source="pack://application:,,,/HandyControl;component/Themes/Theme.xaml"/>
			</ResourceDictionary.MergedDictionaries>
		</ResourceDictionary>
	</Application.Resources>
</Application>

```

`UE4 Network Profiler/App.xaml.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;

namespace UE4_Network_Profiler
{
	/// <summary>
	/// Interaction logic for App.xaml
	/// </summary>
	public partial class App : Application
	{
	}
}

```

`UE4 Network Profiler/Classes/BinaryReaderBigEndian.cs`:

```cs
// Copyright Epic Games, Inc. All Rights Reserved.


using System;
using System.IO;

namespace NetworkProfiler
{
    /**
     * Big endian version of binary reader.
     */
    public class BinaryReaderBigEndian : BinaryReader
    {
        byte[] SwappedBytes = new byte[8];

        /**
         * Constructor, passing arguments to base class.
         */
        public BinaryReaderBigEndian(Stream Input)
            : base(Input, System.Text.Encoding.ASCII)
        {
        }

        /**
         * Reads & swaps bytes array of size count.
         */
        private byte[] ReadSwappedBytes(int Count)
        {
            for (int i = Count - 1; i >= 0; i--)
            {
                SwappedBytes[i] = ReadByte();
            }
            return SwappedBytes;
        }

        /**
         * Reads an UInt16 from stream and returns it.
         */
        public override ushort ReadUInt16()
        {
            return BitConverter.ToUInt16(ReadSwappedBytes(2), 0);
        }

        /**
         * Reads an Int16 from stream and returns it.
         */
        public override short ReadInt16()
        {
            return BitConverter.ToInt16(ReadSwappedBytes(2), 0);
        }

        /**
         * Reads an UInt32 from stream and returns it.
         */
        public override int ReadInt32()
        {
            return BitConverter.ToInt32(ReadSwappedBytes(4), 0);
        }

        /**
         * Reads an Int32 from stream and returns it.
         */
        public override uint ReadUInt32()
        {
            return BitConverter.ToUInt32(ReadSwappedBytes(4), 0);
        }

        /**
         * Reads an UInt64 from stream and returns it.
         */
        public override long ReadInt64()
        {
            return BitConverter.ToInt64(ReadSwappedBytes(8), 0);
        }

        /**
         * Reads an Int64 from stream and returns it.
         */
        public override ulong ReadUInt64()
        {
            return BitConverter.ToUInt64(ReadSwappedBytes(8), 0);
        }

        /**
         * Reads a float from stream and returns it.
         */
        public override float ReadSingle()
        {
            return BitConverter.ToSingle(ReadSwappedBytes(4), 0);
        }
    }
}
```

`UE4 Network Profiler/Classes/ChartParser.cs`:

```cs
/************************************************************************/
/* 
 * This is a WPF rewrite of Network Profiler by Epic Games.
 * Original repository can be found here: https://github.com/EpicGames/UnrealEngine/tree/master/Engine/Source/Programs/NetworkProfiler 
 * 
 * Pull requests are welcome. 
 * =============================================
 * 
 * Written in WPF by Satheesh (ryanjon2040) 
 * Github :		https://github.com/ryanjon2040 
 * Twitter:		https://twitter.com/ryanjon2040
 * Facebook:	https://facebook.com/ryanjon2040
 * Discord:		ryanjon2040#5319
 */
/************************************************************************/

using System;
using ScottPlot;

namespace NetworkProfiler
{
	class ChartParser
	{
		public static void ParseStreamIntoChart(MainWindow InMainWindow, NetworkStream InStream, WpfPlot NetworkChart, FilterValues InFilterValues)
		{
			var StartTime = DateTime.UtcNow;

			InMainWindow.ShowProgress(true);
			NetworkChart.Plot.Clear();

			for (int i = 0; i < InMainWindow.DefaultSeriesTypes.Count; i++)
			{
				float Percent = (float)i / (float)InMainWindow.DefaultSeriesTypes.Count;
				InMainWindow.UpdateProgress((int)(Percent * 100));
				InMainWindow.DefaultSeriesTypes[i].Reset();
			}

			int FrameCounter = 0;
			foreach (PartialNetworkStream RawFrame in InStream.Frames)
			{
				if (FrameCounter % 1000 == 0)
				{
					float Percent = (float)FrameCounter / (float)InStream.Frames.Count;
					InMainWindow.UpdateProgress((int)(Percent * 100));
				}

				PartialNetworkStream Frame = RawFrame.Filter(InFilterValues);
				if (Frame.EndTime == Frame.StartTime)
				{
					throw new InvalidOperationException("End time and Start time cannot be same.");
				}

				float OneOverDeltaTime = 1 / (Frame.EndTime - Frame.StartTime);
				int OutgoingBandwidth = Frame.UnrealSocketSize + Frame.OtherSocketSize + NetworkStream.PacketOverhead * (Frame.UnrealSocketCount + Frame.OtherSocketCount);

				InMainWindow.AddChartPoint(SeriesType.OutgoingBandwidthSize, FrameCounter, OutgoingBandwidth);
				InMainWindow.AddChartPoint(SeriesType.OutgoingBandwidthSizeSec, FrameCounter, OutgoingBandwidth * OneOverDeltaTime);
				InMainWindow.AddChartPoint(SeriesType.ActorCount, FrameCounter, Frame.ActorCount);
				InMainWindow.AddChartPoint(SeriesType.PropertySize, FrameCounter, Frame.ReplicatedSizeBits / 8);
				InMainWindow.AddChartPoint(SeriesType.PropertySizeSec, FrameCounter, Frame.ReplicatedSizeBits / 8 * OneOverDeltaTime);
				InMainWindow.AddChartPoint(SeriesType.RPCSize, FrameCounter, Frame.RPCSizeBits / 8);
				InMainWindow.AddChartPoint(SeriesType.RPCSizeSec, FrameCounter, Frame.RPCSizeBits / 8 * OneOverDeltaTime);

#if true
				InMainWindow.AddChartPoint(SeriesType.ActorCountSec, FrameCounter, Frame.ActorCount * OneOverDeltaTime);
				InMainWindow.AddChartPoint(SeriesType.PropertyCount, FrameCounter, Frame.PropertyCount);
				InMainWindow.AddChartPoint(SeriesType.PropertyCountSec, FrameCounter, Frame.PropertyCount * OneOverDeltaTime);
				InMainWindow.AddChartPoint(SeriesType.RPCCount, FrameCounter, Frame.RPCCount);
				InMainWindow.AddChartPoint(SeriesType.RPCCountSec, FrameCounter, Frame.RPCCount * OneOverDeltaTime);
				InMainWindow.AddChartPoint(SeriesType.ExportBunchCount, FrameCounter, Frame.ExportBunchCount);
				InMainWindow.AddChartPoint(SeriesType.ExportBunchSize, FrameCounter, Frame.ExportBunchSizeBits / 8);
				InMainWindow.AddChartPoint(SeriesType.MustBeMappedGuidsCount, FrameCounter, Frame.MustBeMappedGuidCount / 8);
				InMainWindow.AddChartPoint(SeriesType.MustBeMappedGuidsSize, FrameCounter, Frame.MustBeMappedGuidSizeBits / 8);
				InMainWindow.AddChartPoint(SeriesType.SendAckCount, FrameCounter, Frame.SendAckCount);
				InMainWindow.AddChartPoint(SeriesType.SendAckCountSec, FrameCounter, Frame.SendAckCount * OneOverDeltaTime);
				InMainWindow.AddChartPoint(SeriesType.SendAckSize, FrameCounter, Frame.SendAckSizeBits / 8);
				InMainWindow.AddChartPoint(SeriesType.SendAckSizeSec, FrameCounter, Frame.SendAckSizeBits / 8 * OneOverDeltaTime);
				InMainWindow.AddChartPoint(SeriesType.ContentBlockHeaderSize, FrameCounter, Frame.ContentBlockHeaderSizeBits / 8);
				InMainWindow.AddChartPoint(SeriesType.ContentBlockFooterSize, FrameCounter, Frame.ContentBlockFooterSizeBits / 8);
				InMainWindow.AddChartPoint(SeriesType.PropertyHandleSize, FrameCounter, Frame.PropertyHandleSizeBits / 8);
				InMainWindow.AddChartPoint(SeriesType.SendBunchCount, FrameCounter, Frame.SendBunchCount);
				InMainWindow.AddChartPoint(SeriesType.SendBunchCountSec, FrameCounter, Frame.SendBunchCount * OneOverDeltaTime);
				InMainWindow.AddChartPoint(SeriesType.SendBunchSize, FrameCounter, Frame.SendBunchSizeBits / 8);
				InMainWindow.AddChartPoint(SeriesType.SendBunchSizeSec, FrameCounter, Frame.SendBunchSizeBits / 8 * OneOverDeltaTime);
				InMainWindow.AddChartPoint(SeriesType.SendBunchHeaderSize, FrameCounter, Frame.SendBunchHeaderSizeBits / 8);
				InMainWindow.AddChartPoint(SeriesType.GameSocketSendSize, FrameCounter, Frame.UnrealSocketSize);
				InMainWindow.AddChartPoint(SeriesType.GameSocketSendSizeSec, FrameCounter, Frame.UnrealSocketSize * OneOverDeltaTime);
				InMainWindow.AddChartPoint(SeriesType.GameSocketSendCount, FrameCounter, Frame.UnrealSocketCount);
				InMainWindow.AddChartPoint(SeriesType.GameSocketSendCountSec, FrameCounter, Frame.UnrealSocketCount * OneOverDeltaTime);
				InMainWindow.AddChartPoint(SeriesType.ActorReplicateTimeInMS, FrameCounter, Frame.ActorReplicateTimeInMS);
#endif

#if false
				InMainWindow.AddChartPoint( SeriesType.MiscSocketSendSize,			FrameCounter, Frame.OtherSocketSize );
				InMainWindow.AddChartPoint( SeriesType.MiscSocketSendSizeSec,		FrameCounter, Frame.OtherSocketSize * OneOverDeltaTime );
				InMainWindow.AddChartPoint( SeriesType.MiscSocketSendCount,			FrameCounter, Frame.OtherSocketCount );
				InMainWindow.AddChartPoint( SeriesType.MiscSocketSendCountSec,		FrameCounter, Frame.OtherSocketCount * OneOverDeltaTime );								
#endif

				if (Frame.NumEvents > 0)
				{
					InMainWindow.AddChartPoint(SeriesType.Events, FrameCounter, 0);
				}

				FrameCounter++;
			}

			InMainWindow.ShowProgress(false);
			Console.WriteLine("Adding data to chart took {0} seconds", (DateTime.UtcNow - StartTime).TotalSeconds);
			InMainWindow.Dispatcher.Invoke(new Action(() => InMainWindow.UpdateNetworkChart()));
		}
	}
}

```

`UE4 Network Profiler/Classes/NetworkStream.cs`:

```cs
/************************************************************************/
/* 
 * This is a WPF rewrite of Network Profiler by Epic Games.
 * Original repository can be found here: https://github.com/EpicGames/UnrealEngine/tree/master/Engine/Source/Programs/NetworkProfiler 
 * 
 * Pull requests are welcome. 
 * =============================================
 * 
 * Written in WPF by Satheesh (ryanjon2040) 
 * Github :		https://github.com/ryanjon2040 
 * Twitter:		https://twitter.com/ryanjon2040
 * Facebook:	https://facebook.com/ryanjon2040
 * Discord:		ryanjon2040#5319
 */
/************************************************************************/


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;

namespace NetworkProfiler
{
	/**
	 * Encapsulates entire network stream, split into frames. Also contains name table
	 * used to convert indices back into strings.
	 */
	public class NetworkStream
	{
		/** Per packet overhead to take into account for total outgoing bandwidth. */
		//public static int PacketOverhead = 48;
		public static int PacketOverhead = 28;

		/** Array of unique names. Code has fixed indexes into it.					*/
		public List<string> NameArray = new List<string>();

		/** Array of unique addresses. Code has fixed indexes into it.				*/
		public List<UInt64> AddressArray = new List<UInt64>();
		// Used for new storage method.
		public List<string> StringAddressArray = new List<string>();

		/** Last address index parsed from token stream								*/
		public int CurrentConnectionIndex = 0;

		/** Internal dictionary from class name to index in name array, used by GetClassNameIndex. */
		private Dictionary<string, int> ClassNameToNameIndex = new Dictionary<string, int>();

		/** Index of "Unreal" name in name array.									*/
		public int NameIndexUnreal = -1;

		/** At the highest level, the entire stream is a series of frames.			*/
		public List<PartialNetworkStream> Frames = new List<PartialNetworkStream>();

		/** Mapping from property name to summary */
		public Dictionary<int, TypeSummary> PropertyNameToSummary = new Dictionary<int, TypeSummary>();
		/** Mapping from actor name to summary */
		public Dictionary<int, TypeSummary> ActorNameToSummary = new Dictionary<int, TypeSummary>();
		/** Mapping from RPC name to summary */
		public Dictionary<int, TypeSummary> RPCNameToSummary = new Dictionary<int, TypeSummary>();

		public Dictionary<int, ObjectReplicationSummary> ObjectNameToReplicationSummary = new Dictionary<int, ObjectReplicationSummary>();

		public StreamHeader Header;

		/**
		 * Returns the name associated with the passed in index.
		 * 
		 * @param	Index	Index in name table
		 * @return	Name associated with name table index
		 */
		public string GetName(int Index)
		{
			return NameArray[Index];
		}

		/**
		 * Returns the ip address string associated with the passed in connection index.
		 * 
		 * @param	ConnectionIndex	Index in address table
		 * @param	NetworkVersion the version of this network profiler, determines if we need to do extra parsing with the string
		 * @return	Ip string associated with address table index
		 */
		public string GetIpString(int ConnectionIndex, uint NetworkVersion)
		{
			if (NetworkVersion < 12)
			{
				UInt64 Addr = AddressArray[ConnectionIndex];
				UInt32 IP = (UInt32)(Addr >> 32);
				UInt32 Port = (UInt32)(Addr & (((UInt64)1 << 32) - 1));

				byte ip0 = (byte)((IP >> 24) & 255);
				byte ip1 = (byte)((IP >> 16) & 255);
				byte ip2 = (byte)((IP >> 8) & 255);
				byte ip3 = (byte)((IP >> 0) & 255);
				return string.Format("{0}.{1}.{2}.{3}: {4}", ip0, ip1, ip2, ip3, Port);
			}
			else
			{
				return StringAddressArray[ConnectionIndex];
			}
		}

		/**
		 * Returns the class name index for the passed in actor name index
		 * 
		 * @param	ActorNameIndex	Name table entry of actor
		 * @return	Class name table index of actor's class
		 */
		public int GetClassNameIndex(int ActorNameIndex)
		{

			int ClassNameIndex = 0;
			try
			{
				// Class name is actor name with the trailing _XXX cut off.
				string ActorName = GetName(ActorNameIndex);
				string ClassName = ActorName;


				int CharIndex = ActorName.LastIndexOf('_');
				if (CharIndex >= 0)
				{
					ClassName = ActorName.Substring(0, CharIndex);
				}



				// Find class name index in name array.

				if (ClassNameToNameIndex.ContainsKey(ClassName))
				{
					// Found.
					ClassNameIndex = ClassNameToNameIndex[ClassName];
				}
				// Not found, add to name array and then also dictionary.
				else
				{
					ClassNameIndex = NameArray.Count;
					NameArray.Add(ClassName);
					ClassNameToNameIndex.Add(ClassName, ClassNameIndex);
				}
			}
			catch (System.Exception e)
			{
				System.Console.WriteLine("Error Parsing ClassName for Actor: " + ActorNameIndex + e.ToString());
			}

			return ClassNameIndex;
		}

		/**
		 * Returns the class name index for the passed in actor name
		 * 
		 * @param	ClassName	Name table entry of actor
		 * @return	Class name table index of actor's class
		 */
		public int GetIndexFromClassName(string ClassName)
		{
			if (ClassNameToNameIndex.ContainsKey(ClassName))
			{
				return ClassNameToNameIndex[ClassName];
			}

			return -1;
		}

		/**
		 * Updates the passed in summary dictionary with information of new event.
		 * 
		 * @param	Summaries	Summaries dictionary to update (usually ref to ones contained in this class)
		 * @param	NameIndex	Index of object in name table (e.g. property, actor, RPC)
		 * @param	SizeBits	Size in bits associated with object occurence
		 */
		public void UpdateSummary(ref Dictionary<int, TypeSummary> Summaries, int NameIndex, int SizeBits, float TimeInMS)
		{
			if (Summaries.ContainsKey(NameIndex))
			{
				var Summary = Summaries[NameIndex];
				Summary.Count++;
				Summary.SizeBits += SizeBits;
				Summary.TimeInMS += TimeInMS;
			}
			else
			{
				Summaries.Add(NameIndex, new TypeSummary(SizeBits, TimeInMS));
			}
		}

		public UInt32 GetVersion()
		{
			return Header.Version;
		}

		public string GetChannelTypeName(int ChannelTypeIndex)
		{
			UInt32 Version = GetVersion();

			if (Version < 11)
			{
				return Enum.GetName(typeof(EChannelTypes), ChannelTypeIndex);
			}
			else
			{
				return GetName(ChannelTypeIndex);
			}
		}
	}

	/** Type agnostic summary for property & actor replication and RPCs. */
	public class TypeSummary
	{
		/** Number of times property was replicated or RPC was called, ... */
		public long Count = 1;
		/** Total size in bits. */
		public long SizeBits;
		/** Total ms */
		public float TimeInMS;

		/** Constructor */
		public TypeSummary(long InSizeBits, float InTimeInMS)
		{
			SizeBits = InSizeBits;
			TimeInMS = InTimeInMS;
		}
	}

	public class ObjectReplicationSummary
	{
		public ObjectReplicationSummary(int InObjectNameIndex, List<int> PropertyNameIndices)
		{
			ObjectNameIndex = InObjectNameIndex;
			PropertiesPrivate = new List<PropertyReplicationSummary>();
			for (int i = 0; i < PropertyNameIndices.Count; i++)
			{
				PropertiesPrivate.Add(new PropertyReplicationSummary(PropertyNameIndices[i]));
			}
		}

		public readonly int ObjectNameIndex;
		public int LastReplicatedFrame = -1;
		public int LastReplicateFrameWithData = -1;

		public int NumberOfComparisons = 0;
		public int NumberOfReplications = 0;
		public int NumberOfReplicationsWithData = 0;

		public int NumberOfFramesReplicated = 0;
		public int NumberOfFramesReplicatedWithData = 0;

		public float TimeSpentComparingProperties = 0;

		private List<PropertyReplicationSummary> PropertiesPrivate;
		public ReadOnlyCollection<PropertyReplicationSummary> Properties
		{
			get { return PropertiesPrivate.AsReadOnly(); }
		}

	}

	public class PropertyReplicationSummary
	{
		public PropertyReplicationSummary(int InPropertyNameIndex)
		{
			PropertyNameIndex = InPropertyNameIndex;
		}

		public readonly int PropertyNameIndex;
		public int LastReplicatedFrame = -1;
		public int LastComparedFrame = -1;
		public int LastChangedFrame = -1;

		public int NumberOfComparisons = 0;
		public int NumberOfChanges = 0;
		public int NumberOfReplications = 0;

		public int NumberOfFramesReplicated = 0;
		public int NumberOfFramesCompared = 0;
		public int NumberOfFramesChanged = 0;
	}
}

```

`UE4 Network Profiler/Classes/PartialNetworkStream.cs`:

```cs
/************************************************************************/
/* 
 * This is a WPF rewrite of Network Profiler by Epic Games.
 * Original repository can be found here: https://github.com/EpicGames/UnrealEngine/tree/master/Engine/Source/Programs/NetworkProfiler 
 * 
 * Pull requests are welcome. 
 * =============================================
 * 
 * Written in WPF by Satheesh (ryanjon2040) 
 * Github :		https://github.com/ryanjon2040 
 * Twitter:		https://twitter.com/ryanjon2040
 * Facebook:	https://facebook.com/ryanjon2040
 * Discord:		ryanjon2040#5319
 */
/************************************************************************/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Windows.Controls;

namespace NetworkProfiler
{
	/**
	 * Encapsulates one or more frames worth of tokens together with a summary.
	 */
	public class PartialNetworkStream
	{
		// Time/ frames

		/** Normalized start time of partial stream. */
		public float StartTime = -1;
		/** Normalized end time of partial stream. */
		public float EndTime = 0;
		/** Number of frames this summary covers. */
		public int NumFrames = 0;
		/** Number of events in this frame. */
		public int NumEvents = 0;

		// Actor/ Property replication

		/** Number of actors in this partial stream. 
		*/
		public int ActorCount = 0;

		/** Number of replicated actors in this partial stream. 
		*/
		public int ReplicatedActorCount = 0;

		/** Total actor replication time in ms. */
		public float ActorReplicateTimeInMS = 0.0f;

		/** Number of properties replicated. */
		public int PropertyCount = 0;
		/** Total size of properties replicated. */
		public int ReplicatedSizeBits = 0;

		// RPC

		/** Number of RPCs replicated. */
		public int RPCCount = 0;
		/** Total size of RPC replication. */
		public int RPCSizeBits = 0;

		// SendBunch

		/** Number of times SendBunch was called. */
		public int SendBunchCount = 0;
		/** Total size of bytes sent. */
		public int SendBunchSizeBits = 0;
		/** Total size of bunch headers sent. */
		public int SendBunchHeaderSizeBits = 0;

		/** Call count per channel type. */
		public Dictionary<int, int> SendBunchCountPerChannel = new Dictionary<int, int>();
		/** Size per channel type */
		public Dictionary<int, int> SendBunchSizeBitsPerChannel = new Dictionary<int, int>();
		/** Size of bunch headers per channel type */
		public Dictionary<int, int> SendBunchHeaderSizeBitsPerChannel = new Dictionary<int, int>();
		/** Size of bunch payloads per channel type */
		public Dictionary<int, int> SendBunchPayloadSizeBitsPerChannel = new Dictionary<int, int>();

		// Low level socket

		/** Number of low level socket sends on "Unreal" socket type. */
		public int UnrealSocketCount = 0;
		/** Total size of bytes sent on "Unreal" socket type. */
		public int UnrealSocketSize = 0;
		/** Number of low level socket sends on non-"Unreal" socket types. */
		public int OtherSocketCount = 0;
		/** Total size of bytes sent on non-"Unreal" socket type. */
		public int OtherSocketSize = 0;

		// Acks

		/** Number of acks sent. */
		public int SendAckCount = 0;
		/** Total size of acks sent. */
		public int SendAckSizeBits = 0;

		// Exported GUIDs

		/** Number of GUID export bunches sent. */
		public int ExportBunchCount = 0;
		/** Total size of exported GUIDs sent. */
		public int ExportBunchSizeBits = 0;

		// Must be mapped GUIDs

		/** Number of must be mapped GUIDs. */
		public int MustBeMappedGuidCount = 0;
		/** Total size of exported GUIDs sent. */
		public int MustBeMappedGuidSizeBits = 0;

		// Content blocks

		/** Number of content block headers. */
		public int ContentBlockHeaderCount = 0;
		/** Total size of content block headers. */
		public int ContentBlockHeaderSizeBits = 0;
		/** Number of content block footers. */
		public int ContentBlockFooterCount = 0;
		/** Total size of content block footers. */
		public int ContentBlockFooterSizeBits = 0;

		// Property handles

		/** Number of property handles. */
		public int PropertyHandleCount = 0;
		/** Total size of property handles. */
		public int PropertyHandleSizeBits = 0;

		// Detailed information.

		/** List of all tokens in this substream. */
		List<TokenBase> Tokens = new List<TokenBase>();

		/** List of all all unique actors in this substream. */
		UniqueItemTracker<UniqueActor, TokenReplicateActor> UniqueActors = new UniqueItemTracker<UniqueActor, TokenReplicateActor>();

		// Cached internal data.

		/** Delta time of first frame. Passed to constructor as we can't calculate it. */
		float FirstFrameDeltaTime = 0;
		/** Index of "Unreal" name in network stream name table. */
		int NameIndexUnreal = -1;

		/**
		 * Constructor, initializing this substream based on network tokens. 
		 * 
		 * @param	InTokens			Tokens to build partial stream from
		 * @param	InNameIndexUnreal	Index of "Unreal" name, used as optimization
		 * @param	InDeltaTime			DeltaTime of first frame as we can't calculate it
		 */
		public PartialNetworkStream(List<TokenBase> InTokens, int InNameIndexUnreal, float InDeltaTime)
		{
			NameIndexUnreal = InNameIndexUnreal;
			FirstFrameDeltaTime = InDeltaTime;

			// Populate tokens array, weeding out unwanted ones.
			foreach (TokenBase Token in InTokens)
			{
#if false
				// Don't add tokens that don't have any replicated properties.
				// NOTE - We now allow properties that didn't replicate anything so we can show performance stats
				if ( ( Token.TokenType == ETokenTypes.ReplicateActor ) && ( ( ( TokenReplicateActor )Token ).Properties.Count == 0 ) )
				{
					continue;
				}
#endif
				Tokens.Add(Token);
			}

			CreateSummary(NameIndexUnreal, FirstFrameDeltaTime, new FilterValues());
		}

		/**
		 * Constructor, duplicating the passed in stream while applying the passed in filters.
		 * 
		 * @param	InStream		Stream to duplicate
		 * @param	ActorFilter		Actor filter to match against
		 * @param	PropertyFilter	Property filter to match against
		 * @param	RPCFilter		RPC filter to match against
		 */
		public PartialNetworkStream(PartialNetworkStream InStream, FilterValues InFilterValues)
		{
			NameIndexUnreal = InStream.NameIndexUnreal;
			FirstFrameDeltaTime = InStream.FirstFrameDeltaTime;

			// Merge tokens from passed in stream based on filter criteria.
			foreach (var Token in InStream.Tokens)
			{
				if (Token.MatchesFilters(InFilterValues))
				{
					Tokens.Add(Token);
				}
			}
			CreateSummary(NameIndexUnreal, FirstFrameDeltaTime, InFilterValues);
		}

		public PartialNetworkStream(MainWindow InMainWindow, List<PartialNetworkStream> InStreams, int InStartFrame, int InEndFrame, int InNameIndexUnreal, FilterValues InFilterValues, float InDeltaTime)
		{
			NameIndexUnreal = InNameIndexUnreal;
			FirstFrameDeltaTime = InDeltaTime;

			InMainWindow.ShowProgress(true);
			InMainWindow.UpdateProgress(0);

			// Merge tokens from passed in streams.
			for (int i = InStartFrame; i < InEndFrame; i++)
			{
				PartialNetworkStream Stream = InStreams[i];

				if (i % 10 == 0)
				{
					float Percent = (float)(i - InStartFrame) / (float)(InEndFrame - InStartFrame);
					InMainWindow.UpdateProgress((int)(Percent * 100));
				}

				// Merge tokens from passed in stream based on filter criteria.
				foreach (var Token in Stream.Tokens)
				{
					if (Token.MatchesFilters(InFilterValues))
					{
						Tokens.Add(Token);
						UpdateSummary(Token, InFilterValues);
					}
				}
			}

			InMainWindow.ShowProgress(false);

			EndTime += InDeltaTime;
		}

		public PartialNetworkStream(int InNameIndexUnreal, float InDeltaTime)
		{
			NameIndexUnreal = InNameIndexUnreal;
			FirstFrameDeltaTime = InDeltaTime;
		}

		public void AddStream(PartialNetworkStream InStream)
		{
			// Merge tokens from passed in stream based on filter criteria.
			foreach (var Token in InStream.Tokens)
			{
				Tokens.Add(Token);
				UpdateSummary(Token, new FilterValues());
			}
		}

		/**
		 * Filters based on the passed in filters and returns a new partial network stream.
		 * 
		 * @param	ActorFilter		Actor filter to match against
		 * @param	PropertyFilter	Property filter to match against
		 * @param	RPCFilter		RPC filter to match against
		 * 
		 * @return	new filtered network stream
		 */
		public PartialNetworkStream Filter(FilterValues InFilterValues)
		{
			return new PartialNetworkStream(this, InFilterValues);
		}

		protected void UpdateSummary(TokenBase Token, FilterValues InFilterValues)
		{
			switch (Token.TokenType)
			{
				case ETokenTypes.FrameMarker:
					var TokenFrameMarker = (TokenFrameMarker)Token;
					if (StartTime < 0)
					{
						StartTime = TokenFrameMarker.RelativeTime;
						EndTime = TokenFrameMarker.RelativeTime;
					}
					else
					{
						EndTime = TokenFrameMarker.RelativeTime;
					}
					NumFrames++;
					break;
				case ETokenTypes.SocketSendTo:
					var TokenSocketSendTo = (TokenSocketSendTo)Token;
					// Unreal game socket
					if (TokenSocketSendTo.SocketNameIndex == NameIndexUnreal)
					{
						UnrealSocketCount++;
						UnrealSocketSize += TokenSocketSendTo.BytesSent;
					}
					else
					{
						OtherSocketCount++;
						OtherSocketSize += TokenSocketSendTo.BytesSent;
					}
					break;
				case ETokenTypes.SendBunch:
					var TokenSendBunch = (TokenSendBunch)Token;
					SendBunchCount++;
					SendBunchSizeBits += TokenSendBunch.GetNumTotalBits();
					SendBunchHeaderSizeBits += TokenSendBunch.NumHeaderBits;

					int ChannelTypeIndex = TokenSendBunch.GetChannelTypeIndex();

					if (SendBunchCountPerChannel.ContainsKey(ChannelTypeIndex))
					{
						SendBunchCountPerChannel[ChannelTypeIndex]++;
						SendBunchSizeBitsPerChannel[ChannelTypeIndex] += TokenSendBunch.GetNumTotalBits();
						SendBunchHeaderSizeBitsPerChannel[ChannelTypeIndex] += TokenSendBunch.NumHeaderBits;
						SendBunchPayloadSizeBitsPerChannel[ChannelTypeIndex] += TokenSendBunch.NumPayloadBits;
					}
					else
					{
						SendBunchCountPerChannel.Add(ChannelTypeIndex, 1);
						SendBunchSizeBitsPerChannel.Add(ChannelTypeIndex, TokenSendBunch.GetNumTotalBits());
						SendBunchHeaderSizeBitsPerChannel.Add(ChannelTypeIndex, TokenSendBunch.NumHeaderBits);
						SendBunchPayloadSizeBitsPerChannel.Add(ChannelTypeIndex, TokenSendBunch.NumPayloadBits);
					}

					break;
				case ETokenTypes.SendRPC:
					var TokenSendRPC = (TokenSendRPC)Token;
					RPCCount++;
					RPCSizeBits += TokenSendRPC.GetNumTotalBits();
					break;
				case ETokenTypes.ReplicateActor:
					var TokenReplicateActor = (TokenReplicateActor)Token;
					ActorCount++;

					if (TokenReplicateActor.Properties.Count > 0)
					{
						ReplicatedActorCount++;
					}

					ActorReplicateTimeInMS += TokenReplicateActor.TimeInMS;

					foreach (var Property in TokenReplicateActor.Properties)
					{
						if (Property.MatchesFilters(InFilterValues))
						{
							PropertyCount++;
							ReplicatedSizeBits += Property.NumBits;
						}
					}

					foreach (var PropertyHeader in TokenReplicateActor.PropertyHeaders)
					{
						if (PropertyHeader.MatchesFilters(InFilterValues))
						{
							ReplicatedSizeBits += PropertyHeader.NumBits;
						}
					}

					UniqueActors.AddItem(TokenReplicateActor, TokenReplicateActor.GetClassNameIndex());

					break;
				case ETokenTypes.Event:
					NumEvents++;
					break;
				case ETokenTypes.RawSocketData:
					break;
				case ETokenTypes.SendAck:
					var TokenSendAck = (TokenSendAck)Token;
					SendAckCount++;
					SendAckSizeBits += TokenSendAck.NumBits;
					break;
				case ETokenTypes.ExportBunch:
					var TokenExportBunch = (TokenExportBunch)Token;
					ExportBunchCount++;
					ExportBunchSizeBits += TokenExportBunch.NumBits;
					break;
				case ETokenTypes.MustBeMappedGuids:
					var TokenMustBeMappedGuids = (TokenMustBeMappedGuids)Token;
					MustBeMappedGuidCount += TokenMustBeMappedGuids.NumGuids;
					MustBeMappedGuidSizeBits += TokenMustBeMappedGuids.NumBits;
					break;
				case ETokenTypes.BeginContentBlock:
					var TokenBeginContentBlock = (TokenBeginContentBlock)Token;
					ContentBlockHeaderCount++;
					ContentBlockHeaderSizeBits += TokenBeginContentBlock.NumBits;
					break;
				case ETokenTypes.EndContentBlock:
					var TokenEndContentBlock = (TokenEndContentBlock)Token;
					ContentBlockFooterCount++;
					ContentBlockFooterSizeBits += TokenEndContentBlock.NumBits;
					break;
				case ETokenTypes.WritePropertyHandle:
					var TokenWritePropertyHandle = (TokenWritePropertyHandle)Token;
					PropertyHandleCount++;
					PropertyHandleSizeBits += TokenWritePropertyHandle.NumBits;
					break;
				default:
					throw new System.IO.InvalidDataException();
			}
		}

		/**
		 * Parses tokens to create summary.	
		 */
		protected void CreateSummary(int NameIndexUnreal, float DeltaTime, FilterValues InFilterValues)
		{
			foreach (TokenBase Token in Tokens)
			{
				UpdateSummary(Token, InFilterValues);
			}

			EndTime += DeltaTime;
		}

		public void ToDetailedTreeView(ItemCollection Nodes, FilterValues InFilterValues)
		{
			Nodes.Clear();

			foreach (TokenBase Token in Tokens)
			{
				Token.ToDetailedTreeView(Nodes, InFilterValues);
			}
		}

		private TreeViewItem AddNode(ItemCollection Nodes, int Index, String Value)
		{
			if (Nodes.Count <= Index)
			{
				TreeViewItem NewNode = new TreeViewItem();
				NewNode.Header = Value;
				Nodes.Add(NewNode);
				return NewNode;
			}

			((TreeViewItem)Nodes[Index]).Header = Value;
			return (TreeViewItem)Nodes[Index];
		}

		public void ToActorSummaryView(NetworkStream NetworkStream, TreeView TreeView)
		{
			bool FirstTree = TreeView.Items.Count == 0;

			TreeViewItem Parent = AddNode(TreeView.Items, 0, "Summary");

			AddNode(Parent.Items, 0, "Frames             :" + ConvertToCountString(NumFrames, false));
			AddNode(Parent.Items, 1, "Seconds            :" + ConvertToCountString(EndTime - StartTime, false));

			for (int i = 0; i < 2; i++)
			{
				bool bPerSecond = i == 0 ? true : false;

				float OneOverDeltaTime = i == 1 ? 1.0f : 1 / (EndTime - StartTime);

				// New parent
				Parent = AddNode(TreeView.Items, i + 1, i == 1 ? "Details (TOTAL)" : "Details (PER SECOND)");

				TreeViewItem Child = null;

				AddNode(Parent.Items, 0, "Outgoing bandwidth :" + ConvertToSizeString((UnrealSocketSize + OtherSocketSize + NetworkStream.PacketOverhead * (UnrealSocketCount + OtherSocketCount)) * OneOverDeltaTime, bPerSecond));
				AddNode(Parent.Items, 1, "SocketSend Count   :" + ConvertToCountString(UnrealSocketCount * OneOverDeltaTime, bPerSecond));
				AddNode(Parent.Items, 2, "SocketSend Size    :" + ConvertToSizeString(UnrealSocketSize * OneOverDeltaTime, bPerSecond));

				Child = AddNode(Parent.Items, 3, "SendBunchCount     :" + ConvertToCountString(SendBunchCount * OneOverDeltaTime, bPerSecond));
				Child.Items.Clear();

				int ChildIndex = 0;
				foreach (KeyValuePair<int, int> Pair in SendBunchCountPerChannel)
				{
					AddNode(Child.Items, ChildIndex++, NetworkStream.GetChannelTypeName(Pair.Key).PadRight(16) + ":" + ConvertToCountString(Pair.Value * OneOverDeltaTime, bPerSecond));
				}

				Child = AddNode(Parent.Items, 4, "SendBunchSize      :" + ConvertToSizeString(SendBunchSizeBits / 8.0f * OneOverDeltaTime, bPerSecond));
				Child.Items.Clear();

				ChildIndex = 0;
				foreach (KeyValuePair<int, int> Pair in SendBunchSizeBitsPerChannel)
				{
					AddNode(Child.Items, ChildIndex++, NetworkStream.GetChannelTypeName(Pair.Key).PadRight(16) + ":" + ConvertToCountString(Pair.Value / 8.0f * OneOverDeltaTime, bPerSecond));
				}

				AddNode(Parent.Items, 5, "Actor Count        :" + ConvertToCountString(ActorCount * OneOverDeltaTime, bPerSecond));
				AddNode(Parent.Items, 6, "Replicated Actors  :" + ConvertToCountString(ReplicatedActorCount * OneOverDeltaTime, bPerSecond));
				AddNode(Parent.Items, 7, "Property Count     :" + ConvertToCountString(PropertyCount * OneOverDeltaTime, bPerSecond));
				AddNode(Parent.Items, 8, "Property Size      :" + ConvertToSizeString(ReplicatedSizeBits / 8.0f * OneOverDeltaTime, bPerSecond));

				AddNode(Parent.Items, 9, "RPC Count          :" + ConvertToCountString(RPCCount, bPerSecond));
				AddNode(Parent.Items, 10, "RPC Size           :" + ConvertToSizeString(RPCSizeBits / 8.0f * OneOverDeltaTime, bPerSecond));

				AddNode(Parent.Items, 11, "Ack Count          :" + ConvertToCountString(SendAckCount, bPerSecond));
				AddNode(Parent.Items, 12, "Ack Size           :" + ConvertToSizeString(SendAckSizeBits / 8.0f * OneOverDeltaTime, bPerSecond));

				Child = AddNode(Parent.Items, 13, "Bunch Overhead     :" + ConvertToSizeString(GetTotalBunchOverheadSizeBits() / 8.0f * OneOverDeltaTime, bPerSecond));

				AddNode(Child.Items, 0, "Bunch Headers        :" + ConvertToSizeString(SendBunchHeaderSizeBits / 8.0f * OneOverDeltaTime, bPerSecond));
				AddNode(Child.Items, 1, "ContentBlock Headers :" + ConvertToSizeString(ContentBlockHeaderSizeBits / 8.0f * OneOverDeltaTime, bPerSecond));
				AddNode(Child.Items, 2, "ContentBlock Footers :" + ConvertToSizeString(ContentBlockFooterSizeBits / 8.0f * OneOverDeltaTime, bPerSecond));
				AddNode(Child.Items, 3, "Handles              :" + ConvertToSizeString(PropertyHandleSizeBits / 8.0f * OneOverDeltaTime, bPerSecond));
				AddNode(Child.Items, 4, "Export GUIDS         :" + ConvertToSizeString(ExportBunchSizeBits / 8.0f * OneOverDeltaTime, bPerSecond));
				AddNode(Child.Items, 5, "MustBeMapped GUIDS   :" + ConvertToSizeString(MustBeMappedGuidSizeBits / 8.0f * OneOverDeltaTime, bPerSecond));
			}

			// First time through, expand default Items we want to show
			if (FirstTree)
			{
				((TreeViewItem)TreeView.Items[0]).ExpandSubtree();
				((TreeViewItem)TreeView.Items[1]).ExpandSubtree();
			}
		}

		/**
		 * Dumps actor tokens into a list view for viewing performance/bandwidth
		 */
		public void ToActorPerformanceView(NetworkStream NetworkStream, ListView ListView, ListView PropertyListView, FilterValues InFilterValues)
		{
			var ActorDetailList = UniqueActors.UniqueItems.OrderByDescending(s => s.Value.TimeInMS).ToList();

			bool bFirstView = ListView.Items.Count == 0;

			ListView.Items.Clear();

			float OneOverDeltaTime = 1 / (EndTime - StartTime);

			string[] Columns = new string[8];
			foreach (var UniqueActor in ActorDetailList)
			{
				long NumActorBytes = (UniqueActor.Value.SizeBits + 7) / 8;

				Columns[0] = NetworkStream.GetName(UniqueActor.Key);
				Columns[1] = UniqueActor.Value.TimeInMS.ToString("0.00");
				Columns[2] = (NumActorBytes * OneOverDeltaTime / 1024.0f).ToString("0.00");
				Columns[3] = NumActorBytes.ToString();
				Columns[4] = UniqueActor.Value.Count.ToString();
				Columns[5] = (UniqueActor.Value.Count * OneOverDeltaTime).ToString("0.00");
				Columns[6] = (UniqueActor.Value.ReplicatedCount * OneOverDeltaTime).ToString("0.00");
				Columns[7] = UniqueActor.Value.Count > 0 ? (100.0f - ((float)UniqueActor.Value.ReplicatedCount / (float)UniqueActor.Value.Count * 100.0f)).ToString("0.00") : "0";

				ListView.Items.Add(new NetworkListViewItem { Header1 = Columns[0], Header2 = Columns[1], Header3 = Columns[2], Header4 = Columns[3], Header5 = Columns[4], Header6 = Columns[5], Header7 = Columns[6], Header8 = Columns[7] });
			}

			if (bFirstView)
			{
				//ListView.AutoResizeColumns(ColumnHeaderAutoResizeStyle.ColumnContent);
				//ListView.AutoResizeColumns(ColumnHeaderAutoResizeStyle.HeaderSize);
			}

			/*
			if ( ListView.Items.Count > 0 )
			{
				ToPropertyPerformanceView( NetworkStream, ListView.Items[0].Text, PropertyListView, InFilterValues );
			}
			*/
		}

		/**
		 * Dumps property tokens into a list view for viewing performance/bandwidth
		 */
		public void ToPropertyPerformanceView(NetworkStream NetworkStream, string ActorClassName, ListView ListView, FilterValues InFilterValues)
		{
			ListView.Items.Clear();

			UniqueActor Actor;

			int Index = NetworkStream.GetIndexFromClassName(ActorClassName);

			if (Index != -1 && UniqueActors.UniqueItems.TryGetValue(Index, out Actor))
			{
				var Columns = new string[3];

				foreach (var Property in Actor.Properties.UniqueItems)
				{
					Columns[0] = NetworkStream.GetName(Property.Key);
					Columns[1] = ((Property.Value.SizeBits + 7) / 8).ToString();
					Columns[2] = Property.Value.Count.ToString();

					ListView.Items.Add(new NetworkListViewItem { Header1 = Columns[0], Header2 = Columns[1], Header3 = Columns[2] });
				}
			}
		}

		/**
		 * Converts the passed in number of bytes to a string formatted as Bytes, KByte, MByte depending
		 * on magnitude.
		 * 
		 * @param	SizeInBytes		Size in bytes to convert to formatted string
		 * 
		 * @return string representation of value, either Bytes, KByte or MByte
		 */
		public string ConvertToSizeString(float SizeInBytes, bool bPerSecond)
		{
			// Format as MByte if size > 1 MByte.
			if (SizeInBytes > 1024 * 1024)
			{
				string Extra = bPerSecond ? " MB/s" : " MBytes";
				return (SizeInBytes / 1024 / 1024).ToString("0.0").PadLeft(8) + Extra;
			}
			// Format as KByte if size is > 1 KByte and <= 1 MByte
			else if (SizeInBytes > 1024)
			{
				string Extra = bPerSecond ? " KB/s" : " KBytes";
				return (SizeInBytes / 1024).ToString("0.0").PadLeft(8) + Extra;
			}
			// Format as Byte if size is <= 1 KByte
			else
			{
				string Extra = bPerSecond ? " Bytes/s" : " Bytes";
				return SizeInBytes.ToString("0.0").PadLeft(8) + Extra;
			}
		}

		/**
		 * Converts passed in value to string with appropriate formatting and padding
		 * 
		 * @param	Count	Value to convert
		 * @return	string representation with sufficient padding
		 */
		public string ConvertToCountString(float Count, bool bPerSecond)
		{
			string Extra = bPerSecond ? " hz" : "";
			return Count.ToString("0.0").PadLeft(8) + Extra;
		}

		/**
		 * Returns the total number of bits used for bunch format protocol information.
		 * This includes bunch headers, content block headers and footers, property handles,
		 * exported GUIDs, and "must be mapped" GUIDs.
		 */
		public int GetTotalBunchOverheadSizeBits()
		{
			return SendBunchHeaderSizeBits +
					ContentBlockHeaderSizeBits +
					ContentBlockFooterSizeBits +
					PropertyHandleSizeBits +
					ExportBunchSizeBits +
					MustBeMappedGuidSizeBits;
		}
	}

	/**
	 * UniqueItem
	 * Abstract base class for items stored in a UniqueItemTracker class
	 * Holds a unique item, and tracks references to the non unique items that are of the same type
	*/
	class UniqueItem<T> where T : class
	{
		public int Count = 0;       // Number of non unique items
		public T FirstItem = null;

		public virtual void OnItemAdded(T Item)
		{
			if (FirstItem == null)
			{
				FirstItem = Item;
			}
			Count++;
		}
	}

	/**
	 * UniqueItemTracker
	 * Helps consolidate a list of items into a unique list
	 * UniqueItems track reference to the non unique items of the same type
	*/
	class UniqueItemTracker<UniqueT, ItemT>
		where ItemT : class
		where UniqueT : UniqueItem<ItemT>, new()
	{
		public Dictionary<int, UniqueT> UniqueItems = new Dictionary<int, UniqueT>();

		public void AddItem(ItemT Item, int Key)
		{
			if (!UniqueItems.ContainsKey(Key))
			{
				UniqueItems.Add(Key, new UniqueT());
			}

			UniqueItems[Key].OnItemAdded(Item);
		}
	}

	/**
	 * UniqueProperty
	 * Tracks all the unique properties of the same type
	*/
	class UniqueProperty : UniqueItem<TokenReplicateProperty>
	{
		public long SizeBits = 0;

		override public void OnItemAdded(TokenReplicateProperty Item)
		{
			base.OnItemAdded(Item);
			SizeBits += Item.NumBits;
		}
	}

	/**
	 * UniquePropertyHeader
	 * Tracks all the unique property headers of the same type
	*/
	class UniquePropertyHeader : UniqueItem<TokenWritePropertyHeader>
	{
		public long SizeBits = 0;

		override public void OnItemAdded(TokenWritePropertyHeader Item)
		{
			base.OnItemAdded(Item);
			SizeBits += Item.NumBits;
		}
	}

	/**
	 * UniqueActor
	 * Tracks all the unique actors of the same type
	*/
	class UniqueActor : UniqueItem<TokenReplicateActor>
	{
		public long SizeBits = 0;
		public float TimeInMS = 0;
		public int ReplicatedCount = 0;

		public UniqueItemTracker<UniqueProperty, TokenReplicateProperty> Properties = new UniqueItemTracker<UniqueProperty, TokenReplicateProperty>();

		override public void OnItemAdded(TokenReplicateActor Item)
		{
			base.OnItemAdded(Item);

			if (Item.Properties.Count > 0)
			{
				ReplicatedCount++;
			}

			TimeInMS += Item.TimeInMS;

			foreach (var Property in Item.Properties)
			{
				SizeBits += Property.NumBits;
				Properties.AddItem(Property, Property.PropertyNameIndex);
			}

			foreach (var PropertyHeader in Item.PropertyHeaders)
			{
				SizeBits += PropertyHeader.NumBits;
			}
		}
	}
}

```

`UE4 Network Profiler/Classes/StreamHeader.cs`:

```cs
/************************************************************************/
/* 
 * This is a WPF rewrite of Network Profiler by Epic Games.
 * Original repository can be found here: https://github.com/EpicGames/UnrealEngine/tree/master/Engine/Source/Programs/NetworkProfiler 
 * 
 * Pull requests are welcome. 
 * =============================================
 * 
 * Written in WPF by Satheesh (ryanjon2040) 
 * Github :		https://github.com/ryanjon2040 
 * Twitter:		https://twitter.com/ryanjon2040
 * Facebook:	https://facebook.com/ryanjon2040
 * Discord:		ryanjon2040#5319
 */
/************************************************************************/


using System;
using System.IO;

namespace NetworkProfiler
{
	/**
	 * Header written by capture tool
	 */
	public class StreamHeader
	{
		/** Magic number at beginning of data file.					*/
		public const UInt32 ExpectedMagic = 0x1DBF348C;

		/** We expect this version, or we can't proceed.			*/
		public const UInt32 MinSupportedVersion = 10;

		/** Magic to ensure we're opening the right file.			*/
		public UInt32 Magic;
		/** Version number to detect version mismatches.			*/
		public UInt32 Version;

		/** Tag, set via -networkprofiler=TAG						*/
		public string Tag;
		/** Game name, e.g. Example									*/
		public string GameName;
		/** URL used to open/ browse to the map.					*/
		public string URL;

		/**
		 * Reads the header information from the passed in stream and returns it. It also returns
		 * a BinaryReader that is endian-appropriate for the data stream. 
		 *
		 * @param	ParserStream		source stream of data to read from
		 * @param	BinaryStream [out]	binary reader used for reading from stream
		 * @return	serialized header
		 */
		public static StreamHeader ReadHeader(Stream ParserStream, out BinaryReader BinaryStream)
		{
			// Create a binary stream for data, we might toss this later for are an endian swapping one.
			BinaryStream = new BinaryReader(ParserStream, System.Text.Encoding.ASCII);

			// Serialize header.
			StreamHeader Header = new StreamHeader(BinaryStream);

			// Determine whether read file has magic header. If no, try again byte swapped.
			if (Header.Magic != StreamHeader.ExpectedMagic)
			{
				// Seek back to beginning of stream before we retry.
				ParserStream.Seek(0, SeekOrigin.Begin);

				// Use big endian reader. It transparently endian swaps data on read.
				BinaryStream = new BinaryReaderBigEndian(ParserStream);

				// Serialize header a second time.
				Header = new StreamHeader(BinaryStream);
			}

			// At this point we should have a valid header. If no, throw an exception.
			if (Header.Magic != StreamHeader.ExpectedMagic)
			{
				HandyControl.Controls.MessageBox.Fatal("Unrecognized file", "Error");
				throw new InvalidDataException();
			}

			if (Header.Version < StreamHeader.MinSupportedVersion)
			{
				HandyControl.Controls.MessageBox.Fatal("Unrecognized file", "Invalid version");
				throw new InvalidDataException();
			}

			return Header;
		}

		/**
		 * Constructor, serializing header from passed in stream.
		 * 
		 * @param	BinaryStream	Stream to serialize header from.
		 */
		public StreamHeader(BinaryReader BinaryStream)
		{
			// Serialize the file format magic first.
			Magic = BinaryStream.ReadUInt32();

			// Stop serializing data if magic number doesn't match. Most likely endian issue.
			if (Magic != ExpectedMagic)
			{
				return;
			}

			// Version info for backward compatible serialization.
			Version = BinaryStream.ReadUInt32();

			// Stop serializing data if version number doesn't match
			if (Version < MinSupportedVersion)
			{
				return;
			}

			// Serialize various dynamically-sized strings.
			Tag = SerializeAnsiString(BinaryStream);
			GameName = SerializeAnsiString(BinaryStream);
			URL = SerializeAnsiString(BinaryStream);
		}

		/**
		 * Serialize a string from the header.
		 * 
		 * @param	BinaryStream	stream to read from
		 * @return	string being read
		 */
		private string SerializeAnsiString(BinaryReader BinaryStream)
		{
			UInt32 SerializedLength = BinaryStream.ReadUInt32();
			return new string(BinaryStream.ReadChars((int)SerializedLength));
		}
	}
}

```

`UE4 Network Profiler/Classes/StreamParser.cs`:

```cs
/************************************************************************/
/* 
 * This is a WPF rewrite of Network Profiler by Epic Games.
 * Original repository can be found here: https://github.com/EpicGames/UnrealEngine/tree/master/Engine/Source/Programs/NetworkProfiler 
 * 
 * Pull requests are welcome. 
 * =============================================
 * 
 * Written in WPF by Satheesh (ryanjon2040) 
 * Github :		https://github.com/ryanjon2040 
 * Twitter:		https://twitter.com/ryanjon2040
 * Facebook:	https://facebook.com/ryanjon2040
 * Discord:		ryanjon2040#5319
 */
/************************************************************************/


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.IO;
using System.Diagnostics;
using System.Windows.Controls;

namespace NetworkProfiler
{
	class StreamParser
	{
		public static NetworkStream NetworkStream = new NetworkStream();

		/**
		 * Helper function for handling updating actor summaries as they require a bit more work.
		 * 
		 * @param	NetworkStream			NetworkStream associated with token
		 * @param	TokenReplicateActor		Actor token
		 */
		private static void HandleActorSummary(NetworkStream NetworkStream, TokenReplicateActor TokenReplicateActor)
		{
			if (TokenReplicateActor != null)
			{
				int ClassNameIndex = NetworkStream.GetClassNameIndex(TokenReplicateActor.ActorNameIndex);
				NetworkStream.UpdateSummary(ref NetworkStream.ActorNameToSummary, ClassNameIndex, TokenReplicateActor.GetNumReplicatedBits(new FilterValues()), TokenReplicateActor.TimeInMS);
			}
		}

		/**
		 * Helper function for handling housekeeping that needs to happen when we parse a new actor
		 * We used to emit actors before properties, but now we emit properties before actors
		 * So when we are about to parse a new actor, we need to copy the properties up to that point to this new actor
		 * 
		 * @param	TokenReplicateActor		Actor token
		 * @param	LastProperties			Properties to be copied to the actor
		 */
		private static void FinishActorProperties(TokenReplicateActor TokenReplicateActor, List<TokenReplicateProperty> LastProperties, List<TokenWritePropertyHeader> LastPropertyHeaders)
		{
			for (int i = 0; i < LastProperties.Count; i++)
			{
				TokenReplicateActor.Properties.Add(LastProperties[i]);
			}
			LastProperties.Clear();

			for (int i = 0; i < LastPropertyHeaders.Count; i++)
			{
				TokenReplicateActor.PropertyHeaders.Add(LastPropertyHeaders[i]);
			}
			LastPropertyHeaders.Clear();
		}

		/**
		 * Parses passed in data stream into a network stream container class
		 * 
		 * @param	ParserStream	Raw data stream, needs to support seeking
		 * @return	NetworkStream data was parsed into
		 */
		public static NetworkStream Parse(MainWindow InMainWindow, Stream ParserStream)
		{
			var StartTime = DateTime.UtcNow;

			// Network stream the file is parsed into.
			NetworkStream = new NetworkStream();

			// Serialize the header. This will also return an endian-appropriate binary reader to
			// be used for reading the data. 
			BinaryReader BinaryStream = null;
			NetworkStream.Header = StreamHeader.ReadHeader(ParserStream, out BinaryStream);

			// Scratch variables used for building stream. Required as we emit information in reverse
			// order needed for parsing.
			var CurrentFrameTokens = new List<TokenBase>();
			TokenReplicateActor LastActorToken = null;
			List<TokenReplicateProperty> LastProperties = new List<TokenReplicateProperty>();
			List<TokenWritePropertyHeader> LastPropertyHeaders = new List<TokenWritePropertyHeader>();

			Dictionary<int, TokenPropertyComparison> ObjectNamesToPropertyComparisons = new Dictionary<int, TokenPropertyComparison>();

			TokenFrameMarker LastFrameMarker = null;

			InMainWindow.ShowProgress(true);

			int Count = 0;

			var AllFrames = new PartialNetworkStream(NetworkStream.NameIndexUnreal, 1.0f / 30.0f);

			int EarlyOutMinutes = InMainWindow.GetMaxProfileMinutes();

			// Parse stream till we reach the end, marked by special token.
			bool bHasReachedEndOfStream = false;

			List<TokenBase> TokenList = new List<TokenBase>();

			float FrameStartTime = -1.0f;
			float FrameEndTime = -1.0f;

			while (bHasReachedEndOfStream == false)
			{
				if (Count++ % 1000 == 0)
				{
					float Percent = (float)ParserStream.Position / (float)ParserStream.Length;
					InMainWindow.UpdateProgress((int)(Percent * 100));
				}

				if (ParserStream.Position == ParserStream.Length)
				{
					// We reached stream early (must not have been finalized properly, but we can still read it)
					break;
				}

				TokenBase Token = null;

				try
				{
					Token = TokenBase.ReadNextToken(BinaryStream, NetworkStream);
				}
				catch (System.IO.EndOfStreamException)
				{
					// We reached stream early (must not have been finalized properly, but we can still read it)
					break;
				}

				if (Token.TokenType == ETokenTypes.NameReference)
				{
					NetworkStream.NameArray.Add((Token as TokenNameReference).Name);

					// Find "Unreal" name index used for misc socket parsing optimizations.
					if (NetworkStream.NameArray[NetworkStream.NameArray.Count - 1] == "Unreal")
					{
						NetworkStream.NameIndexUnreal = NetworkStream.NameArray.Count - 1;
					}
					continue;
				}

				if (Token.TokenType == ETokenTypes.ConnectionReference)
				{
					if (NetworkStream.GetVersion() < 12)
					{
						NetworkStream.AddressArray.Add((Token as TokenConnectionReference).Address);
					}
					else
					{
						NetworkStream.StringAddressArray.Add((Token as TokenConnectionStringReference).Address);
					}

					continue;
				}

				if (Token.TokenType == ETokenTypes.ConnectionChange)
				{
					// We need to setup CurrentConnectionIndex, since it's used in ReadNextToken
					NetworkStream.CurrentConnectionIndex = (Token as TokenConnectionChanged).AddressIndex;
					continue;
				}

				TokenList.Add(Token);

				// Track frame start/end times manually so we can bail out when we hit the amount of time we want to load
				if (Token.TokenType == ETokenTypes.FrameMarker)
				{
					var TokenFrameMarker = (TokenFrameMarker)Token;

					if (FrameStartTime < 0)
					{
						FrameStartTime = TokenFrameMarker.RelativeTime;
						FrameEndTime = TokenFrameMarker.RelativeTime;
					}
					else
					{
						FrameEndTime = TokenFrameMarker.RelativeTime;
					}
				}

				if (EarlyOutMinutes > 0 && ((FrameEndTime - FrameStartTime) > 60 * EarlyOutMinutes))
				{
					break;
				}
			}

			for (int i = 0; i < TokenList.Count; i++)
			{
				if (i % 1000 == 0)
				{
					float Percent = (float)(i + 1) / (float)(TokenList.Count);
					InMainWindow.UpdateProgress((int)(Percent * 100));
				}

				TokenBase Token = TokenList[i];

				// Convert current tokens to frame if we reach a frame boundary or the end of the stream.
				if (((Token.TokenType == ETokenTypes.FrameMarker) || (Token.TokenType == ETokenTypes.EndOfStreamMarker))
				// Nothing to do if we don't have any tokens, e.g. first frame.
				&& (CurrentFrameTokens.Count > 0))
				{
					// Figure out delta time of previous frame. Needed as partial network stream lacks relative
					// information for last frame. We assume 30Hz for last frame and for the first frame in case
					// we receive network traffic before the first frame marker.
					float DeltaTime = 1 / 30.0f;
					if (Token.TokenType == ETokenTypes.FrameMarker && LastFrameMarker != null)
					{
						DeltaTime = ((TokenFrameMarker)Token).RelativeTime - LastFrameMarker.RelativeTime;
					}

					// Create per frame partial stream and add it to the full stream.
					var FrameStream = new PartialNetworkStream(CurrentFrameTokens, NetworkStream.NameIndexUnreal, DeltaTime);

					AllFrames.AddStream(FrameStream);

					NetworkStream.Frames.Add(FrameStream);
					CurrentFrameTokens.Clear();

					Debug.Assert(LastProperties.Count == 0);        // We shouldn't have any properties now
					Debug.Assert(LastPropertyHeaders.Count == 0);   // We shouldn't have any property headers now either

					// Finish up actor summary of last pending actor before switching frames.
					HandleActorSummary(NetworkStream, LastActorToken);
					LastActorToken = null;
				}
				// Keep track of last frame marker.
				if (Token.TokenType == ETokenTypes.FrameMarker)
				{
					LastFrameMarker = (TokenFrameMarker)Token;
					ObjectNamesToPropertyComparisons = new Dictionary<int, TokenPropertyComparison>();

					//Console.Out.WriteLine("EndOfFrame: " + NetworkStream.Frames.Count.ToString("0"));
				}

				// Bail out if we hit the end. We already flushed tokens above.
				if (Token.TokenType == ETokenTypes.EndOfStreamMarker)
				{
					Debug.Assert(LastProperties.Count == 0);        // We shouldn't have any properties now
					Debug.Assert(LastPropertyHeaders.Count == 0);   // We shouldn't have any property headers now either
					bHasReachedEndOfStream = true;
					// Finish up actor summary of last pending actor at end of stream
					HandleActorSummary(NetworkStream, LastActorToken);
				}
				// Keep track of per frame tokens.
				else
				{
					// Keep track of last actor context for property replication.
					if (Token.TokenType == ETokenTypes.ReplicateActor)
					{
						// Encountered a new actor so we can finish up existing one for summary.
						FinishActorProperties(Token as TokenReplicateActor, LastProperties, LastPropertyHeaders);
						Debug.Assert(LastProperties.Count == 0);        // We shouldn't have any properties now
						Debug.Assert(LastPropertyHeaders.Count == 0);   // We shouldn't have any property headers now either
						HandleActorSummary(NetworkStream, LastActorToken);
						LastActorToken = Token as TokenReplicateActor;
					}
					// Keep track of RPC summary
					else if (Token.TokenType == ETokenTypes.SendRPC)
					{
						var TokenSendRPC = Token as TokenSendRPC;
						NetworkStream.UpdateSummary(ref NetworkStream.RPCNameToSummary, TokenSendRPC.FunctionNameIndex, TokenSendRPC.GetNumTotalBits(), 0.0f);
					}

					// Add properties to the actor token instead of network stream and keep track of summary.
					if (Token.TokenType == ETokenTypes.ReplicateProperty)
					{
						var TokenReplicateProperty = Token as TokenReplicateProperty;
						NetworkStream.UpdateSummary(ref NetworkStream.PropertyNameToSummary, TokenReplicateProperty.PropertyNameIndex, TokenReplicateProperty.NumBits, 0);
						//LastActorToken.Properties.Add(TokenReplicateProperty);
						LastProperties.Add(TokenReplicateProperty);
					}
					else if (Token.TokenType == ETokenTypes.WritePropertyHeader)
					{
						var TokenWritePropertyHeader = Token as TokenWritePropertyHeader;
						LastPropertyHeaders.Add(TokenWritePropertyHeader);
					}
					else if (Token.TokenType == ETokenTypes.PropertyComparison)
					{
						var TokenPropertyComparison = Token as TokenPropertyComparison;
						ObjectNamesToPropertyComparisons[TokenPropertyComparison.ObjectNameIndex] = TokenPropertyComparison;
						HandleObjectComparison(NetworkStream, TokenPropertyComparison);
					}
					else if (Token.TokenType == ETokenTypes.ReplicatePropertiesMetaData)
					{
						var TokenReplicatePropertiesMetaData = Token as TokenReplicatePropertiesMetaData;
						TokenPropertyComparison Comparison = null;
						if (ObjectNamesToPropertyComparisons.TryGetValue(TokenReplicatePropertiesMetaData.ObjectNameIndex, out Comparison))
						{
							HandleObjectReplication(NetworkStream, Comparison, TokenReplicatePropertiesMetaData);
						}
						else
						{
							Console.Out.WriteLine(NetworkStream.GetName(TokenReplicatePropertiesMetaData.ObjectNameIndex));
						}
					}
					else
					{
						CurrentFrameTokens.Add(Token);
					}
				}
			}

			InMainWindow.SetCurrentStreamSelection(NetworkStream, AllFrames, false);

			InMainWindow.ShowProgress(false);

			// Stats for profiling.
			double ParseTime = (DateTime.UtcNow - StartTime).TotalSeconds;
			Console.WriteLine("Parsing {0} MBytes in stream took {1} seconds", ParserStream.Length / 1024 / 1024, ParseTime);

			// Empty stream will have 0 frames and proper name table. Shouldn't happen as we only
			// write out stream in engine if there are any events.
			return NetworkStream;
		}

		/**
		 * Parses summaries into a list view using the network stream for name lookup.
		 * 
		 * @param	NetworkStream	Network stream used for name lookup
		 * @param	Summaries		Summaries to parse into list view
		 * @param	ListView		List view to parse data into
		 */
		public static void ParseStreamIntoListView(NetworkStream NetworkStream, Dictionary<int, TypeSummary> Summaries, ListView ListView)
		{
			ListView.BeginInit();
			ListView.Items.Clear();

			// Columns are total size KByte, count, avg size in bytes, avg size in bits and associated name.
			var Columns = new string[7];
			foreach (var SummaryEntry in Summaries)
			{
				Columns[0] = ((float)SummaryEntry.Value.SizeBits / 8 / 1024).ToString("0.0");
				Columns[1] = SummaryEntry.Value.Count.ToString();
				Columns[2] = ((float)SummaryEntry.Value.SizeBits / 8 / SummaryEntry.Value.Count).ToString("0.0");
				Columns[3] = ((float)SummaryEntry.Value.SizeBits / SummaryEntry.Value.Count).ToString("0.0");
				Columns[4] = SummaryEntry.Value.TimeInMS.ToString("0.00");
				Columns[5] = (SummaryEntry.Value.TimeInMS / SummaryEntry.Value.Count).ToString("0.0000");
				Columns[6] = NetworkStream.GetName(SummaryEntry.Key);

				ListView.Items.Add(new NetworkListViewItem { Header1 = Columns[0], Header2 = Columns[1], Header3 = Columns[2], Header4 = Columns[3], Header5 = Columns[4], Header6 = Columns[5], Header7 = Columns[6] });
				//ListView.ItemsSource = Columns;
			}

			//ListView.AutoResizeColumns(ColumnHeaderAutoResizeStyle.HeaderSize);
			ListView.EndInit();
		}

		private static void HandleObjectComparison(NetworkStream NetworkStream, TokenPropertyComparison ObjectComparison)
		{
			// We're guaranteed that before any Replication takes place (at least in a single frame), a comparison will also take place.
			// So, if this is the very first comparison for a given object class, we'll also need to set up our summary.

			ObjectReplicationSummary ObjectSummary = null;
			if (!NetworkStream.ObjectNameToReplicationSummary.TryGetValue(ObjectComparison.ObjectNameIndex, out ObjectSummary))
			{
				// If we don't have a comparison token the first time we see this object, something is broken in the stream.
				Debug.Assert(ObjectComparison.ExportedPropertyNames != null);

				ObjectSummary = new ObjectReplicationSummary(ObjectComparison.ObjectNameIndex, ObjectComparison.ExportedPropertyNames);
				NetworkStream.ObjectNameToReplicationSummary.Add(ObjectSummary.ObjectNameIndex, ObjectSummary);
			}

			ObjectSummary.NumberOfComparisons++;
			ObjectSummary.TimeSpentComparingProperties += ObjectComparison.TimeSpentComparing;

			ReadOnlyCollection<PropertyReplicationSummary> ObjectProperties = ObjectSummary.Properties;
			BitArray PropertiesCompared = ObjectComparison.ComparedProperties;
			BitArray PropertiesChanged = ObjectComparison.ChangedProperties;

			Debug.Assert(PropertiesChanged.Count == ObjectProperties.Count);
			Debug.Assert(PropertiesCompared.Count == ObjectProperties.Count);

			int FrameNum = NetworkStream.Frames.Count;

			for (int i = 0; i < ObjectProperties.Count; i++)
			{
				if (PropertiesCompared[i])
				{
					PropertyReplicationSummary ObjectProperty = ObjectProperties[i];
					ObjectProperty.NumberOfComparisons++;

					if (ObjectProperty.LastComparedFrame != FrameNum)
					{
						ObjectProperty.LastComparedFrame++;
						ObjectProperty.NumberOfFramesCompared++;
					}

					if (PropertiesChanged[i])
					{
						ObjectProperty.NumberOfChanges++;
						if (ObjectProperty.LastChangedFrame != FrameNum)
						{
							ObjectProperty.LastChangedFrame = FrameNum;
							ObjectProperty.NumberOfFramesChanged++;
						}
					}
				}
			}
		}

		private static void HandleObjectReplication(NetworkStream NetworkStream, TokenPropertyComparison ObjectComparison, TokenReplicatePropertiesMetaData ObjectReplication)
		{
			// TODO: We may be able to move this data into the Per Frame data so we can display it when selecting a range.
			//			For now, we're just going to show a summary for the entire profile.


			// If we're replicating this object, we're guaranteed that it was compared before
			// so this should be valid.
			ObjectReplicationSummary ObjectSummary = NetworkStream.ObjectNameToReplicationSummary[ObjectReplication.ObjectNameIndex];

			int FrameNum = NetworkStream.Frames.Count;

			ReadOnlyCollection<PropertyReplicationSummary> ObjectProperties = ObjectSummary.Properties;
			BitArray PropertiesCompared = ObjectComparison.ComparedProperties;
			BitArray PropertiesChanged = ObjectComparison.ChangedProperties;
			BitArray PropertiesFiltered = ObjectReplication.FilteredProperties;

			// At this point, our object summary should be up to date so we can move on to property summaries.
			// We will do that by comparing the bit fields sent 
			Debug.Assert(PropertiesChanged.Count == ObjectProperties.Count);
			Debug.Assert(PropertiesCompared.Count == ObjectProperties.Count);
			Debug.Assert(PropertiesFiltered.Count == ObjectProperties.Count);

			ObjectSummary.NumberOfReplications++;
			if (ObjectSummary.LastReplicatedFrame != FrameNum)
			{
				// If this is the first replication for an object on a given frame, we better have compared its properties.
				ObjectSummary.LastReplicatedFrame = FrameNum;
				ObjectSummary.NumberOfFramesReplicated++;
			}

			for (int i = 0; i < ObjectProperties.Count; i++)
			{
				if (PropertiesCompared[i] && PropertiesChanged[i] && !PropertiesFiltered[i])
				{
					PropertyReplicationSummary ObjectProperty = ObjectProperties[i];

					// The property was compared, changed, and wasn't filtered, that means it was replicated.
					// Note, we ignore the WasNewObjectComparison here because we may legitimately replicate this
					// property multiple times in the same frame to multiple connections and individual connections
					// can have different filters applied to them.
					ObjectProperty.NumberOfReplications++;
					if (ObjectProperty.LastReplicatedFrame != FrameNum)
					{
						ObjectProperty.LastReplicatedFrame = FrameNum;
						ObjectProperty.NumberOfFramesReplicated++;
					}
				}
			}
		}

		public static void ParseStreamIntoReplicationListView(NetworkStream NetworkStream, Dictionary<int, ObjectReplicationSummary> Summaries, ListView ListView)
		{
			ListView.BeginInit();
			ListView.Items.Clear();

			// Columns are "Object Class", "# Comparisons", "# Replications", "Comparison Time", "Avg. Time Per Compare"
			var Columns = new string[5];
			foreach (var SummaryEntry in Summaries)
			{
				Columns[0] = NetworkStream.GetName(SummaryEntry.Key);
				Columns[1] = (SummaryEntry.Value.NumberOfComparisons).ToString("0");
				Columns[2] = (SummaryEntry.Value.NumberOfReplications).ToString("0");
				Columns[3] = (SummaryEntry.Value.TimeSpentComparingProperties).ToString("0.0");
				Columns[4] = ((float)SummaryEntry.Value.TimeSpentComparingProperties / (float)SummaryEntry.Value.NumberOfComparisons).ToString("0.000");

				GridView gridView = new GridView();
				ListView.View = gridView;

				foreach (string S in Columns)
				{
					gridView.Columns.Add(new GridViewColumn { Header = S });
				}
			}

			//ListView.AutoResizeColumns(ColumnHeaderAutoResizeStyle.HeaderSize);
			ListView.EndInit();
		}

		public static void ParseStreamIntoPropertyReplicationListView(NetworkStream NetworkStream, ReadOnlyCollection<PropertyReplicationSummary> Summaries, ListView ListView)
		{
			ListView.BeginInit();
			ListView.Items.Clear();

			if (Summaries != null)
			{
				// Columns are "Property", "# Comparisons", "# Times Changed", "# Replications"
				var Columns = new string[4];
				foreach (var Summary in Summaries)
				{
					Columns[0] = NetworkStream.GetName(Summary.PropertyNameIndex);
					Columns[1] = (Summary.NumberOfComparisons).ToString("0");
					Columns[2] = (Summary.NumberOfChanges).ToString("0");
					Columns[3] = (Summary.NumberOfReplications).ToString("0");

					GridView gridView = new GridView();
					ListView.View = gridView;

					foreach (string S in Columns)
					{
						gridView.Columns.Add(new GridViewColumn { Header = S });
					}
				}
			}

			//ListView.AutoResizeColumns(ColumnHeaderAutoResizeStyle.HeaderSize);
			ListView.EndInit();
		}
	}

	public class NetworkListViewItem
	{
		public string Header1 { get; set; }
		public string Header2 { get; set; }
		public string Header3 { get; set; }
		public string Header4 { get; set; }
		public string Header5 { get; set; }
		public string Header6 { get; set; }
		public string Header7 { get; set; }
		public string Header8 { get; set; }
	}
}

```

`UE4 Network Profiler/Classes/Tokens.cs`:

```cs
/************************************************************************/
/* 
 * This is a WPF rewrite of Network Profiler by Epic Games.
 * Original repository can be found here: https://github.com/EpicGames/UnrealEngine/tree/master/Engine/Source/Programs/NetworkProfiler 
 * 
 * Pull requests are welcome. 
 * =============================================
 * 
 * Written in WPF by Satheesh (ryanjon2040) 
 * Github :		https://github.com/ryanjon2040 
 * Twitter:		https://twitter.com/ryanjon2040
 * Facebook:	https://facebook.com/ryanjon2040
 * Discord:		ryanjon2040#5319
 */
/************************************************************************/


using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.IO;
using System.Windows.Controls;

namespace NetworkProfiler
{
	/** Enum values need to be in sync with UE3 */
	public enum ETokenTypes
	{
		FrameMarker = 0,        // Frame marker, signaling beginning of frame.	
		SocketSendTo,                   // FSocket::SendTo
		SendBunch,                      // UChannel::SendBunch
		SendRPC,                        // Sending RPC
		ReplicateActor,                 // Replicated object	
		ReplicateProperty,              // Property being replicated.
		EndOfStreamMarker,              // End of stream marker		
		Event,                          // Event
		RawSocketData,                  // Raw socket data being sent
		SendAck,                        // Ack being sent
		WritePropertyHeader,            // Property header being written
		ExportBunch,                    // Exported GUIDs
		MustBeMappedGuids,              // Must be mapped GUIDs
		BeginContentBlock,              // Content block headers
		EndContentBlock,                // Content block footers
		WritePropertyHandle,            // Property handles
		ConnectionChange,               // Connection changed
		NameReference,                  // Reference to name
		ConnectionReference,            // Reference to connection
		PropertyComparison,             // Data about property comparions.
		ReplicatePropertiesMetaData,    // Data about properties that were filtered out during replication.
		MaxAndInvalid,                  // Invalid token, also used as the max token index
	}

	/** Enum values need to be in sync with UE3 */
	public enum EChannelTypes
	{
		Invalid = 0,    // Invalid type.
		Control,                    // Connection control.
		Actor,                      // Actor-update channel.
		File,                       // Binary file transfer.
		Voice,                      // Voice channel
		Max,
	}

	/**
	 * Base class of network token/ events
	 */
	public class TokenBase
	{
		/** Type of token. */
		public ETokenTypes TokenType = ETokenTypes.MaxAndInvalid;

		/** Connection this token belongs to */
		public int ConnectionIndex = 0;

		/** Stats about token types being serialized. */
		public static int[] TokenTypeStats = Enumerable.Repeat(0, (int)ETokenTypes.MaxAndInvalid).ToArray();

		/**
		 * Reads the next token from the stream and returns it.
		 * 
		 * @param	BinaryStream	Stream used to serialize from
		 * @param	InNetworkStream	Network stream this token belongs to
		 * @return	Token serialized
		 */
		public static TokenBase ReadNextToken(BinaryReader BinaryStream, NetworkStream InNetworkStream)
		{
			TokenBase SerializedToken = null;

			ETokenTypes TokenType = (ETokenTypes)BinaryStream.ReadByte();
			// Handle token specific serialization.
			switch (TokenType)
			{
				case ETokenTypes.FrameMarker:
					SerializedToken = new TokenFrameMarker(BinaryStream);
					break;
				case ETokenTypes.SocketSendTo:
					SerializedToken = new TokenSocketSendTo(BinaryStream);
					break;
				case ETokenTypes.SendBunch:
					SerializedToken = new TokenSendBunch(BinaryStream, InNetworkStream.GetVersion());
					break;
				case ETokenTypes.SendRPC:
					SerializedToken = new TokenSendRPC(BinaryStream, InNetworkStream.GetVersion());
					break;
				case ETokenTypes.ReplicateActor:
					SerializedToken = new TokenReplicateActor(BinaryStream);
					break;
				case ETokenTypes.ReplicateProperty:
					SerializedToken = new TokenReplicateProperty(BinaryStream);
					break;
				case ETokenTypes.EndOfStreamMarker:
					SerializedToken = new TokenEndOfStreamMarker();
					break;
				case ETokenTypes.Event:
					SerializedToken = new TokenEvent(BinaryStream);
					break;
				case ETokenTypes.RawSocketData:
					SerializedToken = new TokenRawSocketData(BinaryStream);
					break;
				case ETokenTypes.SendAck:
					SerializedToken = new TokenSendAck(BinaryStream);
					break;
				case ETokenTypes.WritePropertyHeader:
					SerializedToken = new TokenWritePropertyHeader(BinaryStream);
					break;
				case ETokenTypes.ExportBunch:
					SerializedToken = new TokenExportBunch(BinaryStream);
					break;
				case ETokenTypes.MustBeMappedGuids:
					SerializedToken = new TokenMustBeMappedGuids(BinaryStream);
					break;
				case ETokenTypes.BeginContentBlock:
					SerializedToken = new TokenBeginContentBlock(BinaryStream);
					break;
				case ETokenTypes.EndContentBlock:
					SerializedToken = new TokenEndContentBlock(BinaryStream);
					break;
				case ETokenTypes.WritePropertyHandle:
					SerializedToken = new TokenWritePropertyHandle(BinaryStream);
					break;
				case ETokenTypes.NameReference:
					SerializedToken = new TokenNameReference(BinaryStream);
					break;
				case ETokenTypes.ConnectionReference:
					{
						if (InNetworkStream.GetVersion() < 12)
						{
							SerializedToken = new TokenConnectionReference(BinaryStream);
						}
						else
						{
							SerializedToken = new TokenConnectionStringReference(BinaryStream);
						}
					}
					break;
				case ETokenTypes.ConnectionChange:
					SerializedToken = new TokenConnectionChanged(BinaryStream);
					break;

				case ETokenTypes.PropertyComparison:
					SerializedToken = new TokenPropertyComparison(BinaryStream);
					break;

				case ETokenTypes.ReplicatePropertiesMetaData:
					SerializedToken = new TokenReplicatePropertiesMetaData(BinaryStream);
					break;

				default:
					throw new InvalidDataException();
			}

			TokenTypeStats[(int)TokenType]++;
			SerializedToken.TokenType = TokenType;

			SerializedToken.ConnectionIndex = InNetworkStream.CurrentConnectionIndex;
			return SerializedToken;
		}

		public virtual void ToDetailedTreeView(ItemCollection List, FilterValues InFilterValues)
		{

		}

		/**
		 * Returns whether the token matches/ passes based on the passed in filters.
		 * 
		 * @param	ActorFilter		Actor filter to match against
		 * @param	PropertyFilter	Property filter to match against
		 * @param	RPCFilter		RPC filter to match against
		 */
		public virtual bool MatchesFilters(FilterValues InFilterValues)
		{
			if (TokenType == ETokenTypes.FrameMarker || TokenType == ETokenTypes.EndOfStreamMarker)
			{
				return true;
			}

			return InFilterValues.ConnectionMask == null || InFilterValues.ConnectionMask.Contains(ConnectionIndex);
		}
	}

	/**
	 * End of stream token.
	 */
	class TokenEndOfStreamMarker : TokenBase
	{
	}

	/**
	 * Frame marker token.
	 */
	class TokenFrameMarker : TokenBase
	{
		/** Relative time of frame since start of engine. */
		public float RelativeTime;

		/** Constructor, serializing members from passed in stream. */
		public TokenFrameMarker(BinaryReader BinaryStream)
		{
			RelativeTime = BinaryStream.ReadSingle();
		}

		public override void ToDetailedTreeView(ItemCollection Tree, FilterValues InFilterValues)
		{
			TreeViewItem Child = TokenHelper.AddNode(Tree, "Frame Markers");

			Child.Items.Add("Absolute time : " + RelativeTime);
		}
	}

	/**
	 * FSocket::SendTo token. A special address of 0.0.0.0 is used for ::Send
	 */
	class TokenSocketSendTo : TokenBase
	{
		/** Socket debug description name index. "Unreal" is special name for game traffic. */
		public int SocketNameIndex;
		/** Bytes actually sent by low level code. */
		public UInt16 BytesSent;
		/** Number of bits representing the packet id */
		public UInt16 NumPacketIdBits;
		/** Number of bits representing bunches */
		public UInt16 NumBunchBits;
		/** Number of bits representing packs */
		public UInt16 NumAckBits;
		/** Number of bits used for padding */
		public UInt16 NumPaddingBits;

		/** Constructor, serializing members from passed in stream. */
		public TokenSocketSendTo(BinaryReader BinaryStream)
		{
			SocketNameIndex = TokenHelper.LoadPackedInt(BinaryStream);
			BytesSent = BinaryStream.ReadUInt16();
			NumPacketIdBits = BinaryStream.ReadUInt16();
			NumBunchBits = BinaryStream.ReadUInt16();
			NumAckBits = BinaryStream.ReadUInt16();
			NumPaddingBits = BinaryStream.ReadUInt16();
		}

		public override void ToDetailedTreeView(ItemCollection Tree, FilterValues InFilterValues)
		{
			TreeViewItem Child = TokenHelper.AddNode(Tree, "Socket SendTo");
			TreeViewItem GrandChild = new TreeViewItem();
			GrandChild.Header = "Destination : " + StreamParser.NetworkStream.GetIpString(ConnectionIndex, StreamParser.NetworkStream.GetVersion());
			Child.Items.Add(GrandChild);
			Child = GrandChild;

			Child.Items.Add("SocketName          : " + StreamParser.NetworkStream.GetName(SocketNameIndex));
			Child.Items.Add("DesiredBytesSent    : " + (NumPacketIdBits + NumBunchBits + NumAckBits + NumPaddingBits) / 8.0f);
			Child.Items.Add("   NumPacketIdBits  : " + NumPacketIdBits);
			Child.Items.Add("   NumBunchBits     : " + NumBunchBits);
			Child.Items.Add("   NumAckBits       : " + NumAckBits);
			Child.Items.Add("   NumPaddingBits   : " + NumPaddingBits);
			Child.Items.Add("BytesSent           : " + BytesSent);
		}

		public override bool MatchesFilters(FilterValues InFilterValues)
		{
			return base.MatchesFilters(InFilterValues);
		}
	}

	/**
	 * UChannel::SendBunch token, NOTE that this is NOT SendRawBunch	
	 */
	class TokenSendBunch : TokenBase
	{
		/** Channel index. */
		public UInt16 ChannelIndex;
		/** Channel type. */
		protected byte ChannelType;
		/** Channel type name index. */
		protected int ChannelTypeNameIndex;
		/** Number of header bits serialized/sent. */
		public UInt16 NumHeaderBits;
		/** Number of non-header bits serialized/sent. */
		public UInt16 NumPayloadBits;

		/** Constructor, serializing members from passed in stream. */
		public TokenSendBunch(BinaryReader BinaryStream, UInt32 Version)
		{
			ChannelIndex = BinaryStream.ReadUInt16();
			if (Version < 11)
			{
				ChannelType = BinaryStream.ReadByte();
				ChannelTypeNameIndex = -1;
			}
			else
			{
				ChannelType = 0;
				ChannelTypeNameIndex = TokenHelper.LoadPackedInt(BinaryStream);
			}

			NumHeaderBits = BinaryStream.ReadUInt16();
			NumPayloadBits = BinaryStream.ReadUInt16();
		}

		public int GetChannelTypeIndex()
		{
			if (ChannelTypeNameIndex != -1)
			{
				return ChannelTypeNameIndex;
			}
			else
			{
				return ChannelType;
			}
		}

		/**
		 * Gets the total number of bits serialized for the bunch.
		 */
		public int GetNumTotalBits()
		{
			return NumHeaderBits + NumPayloadBits;
		}

		public override void ToDetailedTreeView(ItemCollection Tree, FilterValues InFilterValues)
		{
			TreeViewItem Child = TokenHelper.AddNode(Tree, "Send Bunch");
			TreeViewItem GrandChild = new TreeViewItem();
			GrandChild.Header = "Channel Type  : " + StreamParser.NetworkStream.GetChannelTypeName(GetChannelTypeIndex());
			Child.Items.Add(GrandChild);

			Child = GrandChild;
			Child.Items.Add("Channel Index    : " + ChannelIndex);
			Child.Items.Add("NumTotalBits     : " + GetNumTotalBits());
			Child.Items.Add("   NumHeaderBits : " + NumHeaderBits);
			Child.Items.Add("   NumPayloadBits: " + NumPayloadBits);
			Child.Items.Add("NumTotalBytes    : " + GetNumTotalBits() / 8.0f);
		}
	}

	/**
	 * Token for RPC replication
	 */
	class TokenSendRPC : TokenBase
	{
		/** Name table index of actor name. */
		public int ActorNameIndex;
		/** Name table index of function name. */
		public int FunctionNameIndex;
		/** Number of bits serialized/sent for the header. */
		public int NumHeaderBits;
		/** Number of bits serialized/sent for the parameters. */
		public int NumParameterBits;
		/** Number of bits serialized/sent for the footer. */
		public int NumFooterBits;

		/** Constructor, serializing members from passed in stream. */
		public TokenSendRPC(BinaryReader BinaryStream, UInt32 Version)
		{
			ActorNameIndex = TokenHelper.LoadPackedInt(BinaryStream);
			FunctionNameIndex = TokenHelper.LoadPackedInt(BinaryStream);

			if (Version < 13)
			{
				NumHeaderBits = BinaryStream.ReadUInt16();
				NumParameterBits = BinaryStream.ReadUInt16();
				NumFooterBits = BinaryStream.ReadUInt16();
			}
			else
			{
				NumHeaderBits = TokenHelper.LoadPackedInt(BinaryStream);
				NumParameterBits = TokenHelper.LoadPackedInt(BinaryStream);
				NumFooterBits = TokenHelper.LoadPackedInt(BinaryStream);
			}
		}

		/**
		 * Gets the total number of bits serialized for the RPC.
		 */
		public int GetNumTotalBits()
		{
			return NumHeaderBits + NumParameterBits + NumFooterBits;
		}

		public override void ToDetailedTreeView(ItemCollection Tree, FilterValues InFilterValues)
		{
			TreeViewItem Child = TokenHelper.AddNode(Tree, "RPCs");
			TreeViewItem GrandChild = new TreeViewItem();
			GrandChild.Header = StreamParser.NetworkStream.GetName(FunctionNameIndex);
			Child.Items.Add(GrandChild);

			Child = GrandChild;
			Child.Items.Add("Actor               : " + StreamParser.NetworkStream.GetName(ActorNameIndex));
			Child.Items.Add("NumTotalBits        : " + GetNumTotalBits());
			Child.Items.Add("   NumHeaderBits    : " + NumHeaderBits);
			Child.Items.Add("   NumParameterBits : " + NumParameterBits);
			Child.Items.Add("   NumFooterBits    : " + NumFooterBits);
			Child.Items.Add("NumTotalBytes       : " + GetNumTotalBits() / 8.0f);
		}

		/**
		 * Returns whether the token matches/ passes based on the passed in filters.
		 * 
		 * @param	ActorFilter		Actor filter to match against
		 * @param	PropertyFilter	Property filter to match against
		 * @param	RPCFilter		RPC filter to match against
		 * 
		 * @return true if it matches, false otherwise
		 */
		public override bool MatchesFilters(FilterValues InFilterValues)
		{
			return base.MatchesFilters(InFilterValues) && (InFilterValues.ActorFilter.Length == 0 || StreamParser.NetworkStream.GetName(ActorNameIndex).ToUpperInvariant().Contains(InFilterValues.ActorFilter.ToUpperInvariant()))
			&& (InFilterValues.RPCFilter.Length == 0 || StreamParser.NetworkStream.GetName(FunctionNameIndex).ToUpperInvariant().Contains(InFilterValues.RPCFilter.ToUpperInvariant()));
		}
	}

	/**
	 * Actor replication token. Like the frame marker, this doesn't actually correlate
	 * with any data transfered but is status information for parsing. Properties are 
	 * removed from stream after parsing and moved into actors.
	 */
	class TokenReplicateActor : TokenBase
	{
		public enum ENetFlags
		{
			Dirty = 1,
			Initial = 2,
			Owner = 4
		}
		/** Whether bNetDirty, bnetInitial, or bNetOwner was set on Actor. */
		public byte NetFlags;
		/** Name table index of actor name */
		public int ActorNameIndex;
		/** Time in ms to replicate this actor */
		public float TimeInMS;

		/** List of property tokens that were serialized for this actor. */
		public List<TokenReplicateProperty> Properties;

		/** List of property header tokens that were serialized for this actor. */
		public List<TokenWritePropertyHeader> PropertyHeaders;

		/** Constructor, serializing members from passed in stream. */
		public TokenReplicateActor(BinaryReader BinaryStream)
		{
			NetFlags = BinaryStream.ReadByte();
			ActorNameIndex = TokenHelper.LoadPackedInt(BinaryStream);
			TimeInMS = BinaryStream.ReadSingle();
			Properties = new List<TokenReplicateProperty>();
			PropertyHeaders = new List<TokenWritePropertyHeader>();
		}

		/**
		 * Returns the number of bits for this replicated actor while taking filters into account.
		 * 
		 * @param	ActorFilter		Filter for actor name
		 * @param	PropertyFilter	Filter for property name
		 * @param	RPCFilter		Unused
		 */
		public int GetNumReplicatedBits(FilterValues InFilterValues)
		{
			int NumReplicatedBits = 0;
			foreach (var Property in Properties)
			{
				if (Property.MatchesFilters(InFilterValues))
				{
					NumReplicatedBits += Property.NumBits;
				}
			}

			foreach (var PropertyHeader in PropertyHeaders)
			{
				if (PropertyHeader.MatchesFilters(InFilterValues))
				{
					NumReplicatedBits += PropertyHeader.NumBits;
				}
			}

			return NumReplicatedBits;
		}

		/**
		 * Fills tree view with description of this token
		 * 
		 * @param	Tree			Tree to fill in 
		 * @param	ActorFilter		Filter for actor name
		 * @param	PropertyFilter	Filter for property name
		 * @param	RPCFilter		Unused
		 */
		public override void ToDetailedTreeView(ItemCollection Tree, FilterValues InFilterValues)
		{
			TreeViewItem Child = TokenHelper.AddNode(Tree, "Replicated Actors");

			int NumReplicatedBits = GetNumReplicatedBits(InFilterValues);

			string Flags = ((NetFlags & (byte)ENetFlags.Dirty) == 1 ? "bNetDirty " : "") + ((NetFlags & (byte)ENetFlags.Initial) == 1 ? "bNetInitial" : "") + ((NetFlags & (byte)ENetFlags.Owner) == 1 ? "bNetOwner" : "");
			TreeViewItem GrandChild = new TreeViewItem();
			GrandChild.Header = string.Format("{0,-32} : {1:0.00} ({2:000}) ", StreamParser.NetworkStream.GetName(ActorNameIndex), TimeInMS, NumReplicatedBits / 8) + Flags;
			Child.Items.Add(GrandChild);
			Child = GrandChild;

			if (Properties.Count > 0)
			{
				TreeViewItem NewChild = new TreeViewItem();
				NewChild.Header = "Properties";
				Child.Items.Add(NewChild);
				foreach (var Property in Properties)
				{
					if (Property.MatchesFilters(InFilterValues))
					{
						NewChild.Items.Add(string.Format("{0,-25} : {1:000}", StreamParser.NetworkStream.GetName(Property.PropertyNameIndex), Property.NumBits / 8.0f));
					}
				}
			}

			if (PropertyHeaders.Count > 0)
			{
				TreeViewItem NewChild = new TreeViewItem();
				NewChild.Header = "Property Headers";
				Child.Items.Add(NewChild);
				foreach (var PropertyHeader in PropertyHeaders)
				{
					if (PropertyHeader.MatchesFilters(InFilterValues))
					{
						NewChild.Items.Add(string.Format("{0,-25} : {1:000}", StreamParser.NetworkStream.GetName(PropertyHeader.PropertyNameIndex), PropertyHeader.NumBits / 8.0f));
					}
				}
			}
		}

		/**
		 * Returns whether the token matches/ passes based on the passed in filters.
		 * 
		 * @param	ActorFilter		Actor filter to match against
		 * @param	PropertyFilter	Property filter to match against
		 * @param	RPCFilter		RPC filter to match against
		 * 
		 * @return true if it matches, false otherwise
		 */
		public override bool MatchesFilters(FilterValues InFilterValues)
		{
			bool ContainsMatchingProperty = false || (Properties.Count == 0 && InFilterValues.PropertyFilter.Length == 0);
			foreach (var Property in Properties)
			{
				if (Property.MatchesFilters(InFilterValues))
				{
					ContainsMatchingProperty = true;
					break;
				}
			}
			return base.MatchesFilters(InFilterValues) && (InFilterValues.ActorFilter.Length == 0 || StreamParser.NetworkStream.GetName(ActorNameIndex).ToUpperInvariant().Contains(InFilterValues.ActorFilter.ToUpperInvariant())) && ContainsMatchingProperty;
		}

		public int GetClassNameIndex()
		{
			return StreamParser.NetworkStream.GetClassNameIndex(ActorNameIndex);
		}
	}

	/**
	 * Token for property replication. Context determines which actor this belongs to.
	 */
	class TokenReplicateProperty : TokenBase
	{
		/** Name table index of property name. */
		public int PropertyNameIndex;
		/** Number of bits serialized/ sent. */
		public UInt16 NumBits;

		/** Constructor, serializing members from passed in stream. */
		public TokenReplicateProperty(BinaryReader BinaryStream)
		{
			PropertyNameIndex = TokenHelper.LoadPackedInt(BinaryStream);
			NumBits = BinaryStream.ReadUInt16();
		}

		/**
		 * Returns whether the token matches/ passes based on the passed in filters.
		 * 
		 * @param	ActorFilter		Actor filter to match against
		 * @param	PropertyFilter	Property filter to match against
		 * @param	RPCFilter		RPC filter to match against
		 * 
		 * @return true if it matches, false otherwise
		 */
		public override bool MatchesFilters(FilterValues InFilterValues)
		{
			return base.MatchesFilters(InFilterValues) && (InFilterValues.PropertyFilter.Length == 0 || StreamParser.NetworkStream.GetName(PropertyNameIndex).ToUpperInvariant().Contains(InFilterValues.PropertyFilter.ToUpperInvariant()));
		}
	}

	/**
	 * Token for property header replication. Context determines which actor this belongs to.
	 */
	class TokenWritePropertyHeader : TokenBase
	{
		/** Name table index of property name. */
		public int PropertyNameIndex;
		/** Number of bits serialized/ sent. */
		public UInt16 NumBits;

		/** Constructor, serializing members from passed in stream. */
		public TokenWritePropertyHeader(BinaryReader BinaryStream)
		{
			PropertyNameIndex = TokenHelper.LoadPackedInt(BinaryStream);
			NumBits = BinaryStream.ReadUInt16();
		}

		/**
		 * Returns whether the token matches/ passes based on the passed in filters.
		 * 
		 * @param	ActorFilter		Actor filter to match against
		 * @param	PropertyFilter	Property filter to match against
		 * @param	RPCFilter		RPC filter to match against
		 * 
		 * @return true if it matches, false otherwise
		 */
		public override bool MatchesFilters(FilterValues InFilterValues)
		{
			return base.MatchesFilters(InFilterValues) && (InFilterValues.PropertyFilter.Length == 0 || StreamParser.NetworkStream.GetName(PropertyNameIndex).ToUpperInvariant().Contains(InFilterValues.PropertyFilter.ToUpperInvariant()));
		}
	}

	/**
	 * Token for exported GUID bunches.
	 */
	class TokenExportBunch : TokenBase
	{
		/** Number of bits serialized/ sent. */
		public UInt16 NumBits;

		/** Constructor, serializing members from passed in stream. */
		public TokenExportBunch(BinaryReader BinaryStream)
		{
			NumBits = BinaryStream.ReadUInt16();
		}

		public override void ToDetailedTreeView(ItemCollection Tree, FilterValues InFilterValues)
		{
			TreeViewItem Child = TokenHelper.AddNode(Tree, "GUID's");

			Child.Items.Add("NumBytes         : " + NumBits / 8.0f);
		}
	}

	/**
	 * Token for must be mapped GUIDs.
	 */
	class TokenMustBeMappedGuids : TokenBase
	{
		/** Number of GUIDs serialized/sent. */
		public UInt16 NumGuids;

		/** Number of bits serialized/sent. */
		public UInt16 NumBits;

		/** Constructor, serializing members from passed in stream. */
		public TokenMustBeMappedGuids(BinaryReader BinaryStream)
		{
			NumGuids = BinaryStream.ReadUInt16();
			NumBits = BinaryStream.ReadUInt16();
		}

		public override void ToDetailedTreeView(ItemCollection Tree, FilterValues InFilterValues)
		{
			TreeViewItem Child = TokenHelper.AddNode(Tree, "Must Be Mapped GUID's");

			Child.Items.Add("NumGuids         : " + NumGuids);
			Child.Items.Add("NumBytes         : " + NumBits / 8.0f);
		}
	}

	/**
	 * Token for content block headers.
	 */
	class TokenBeginContentBlock : TokenBase
	{
		/** Name table index of property name. */
		public int ObjectNameIndex;
		/** Number of bits serialized/ sent. */
		public UInt16 NumBits;

		/** Constructor, serializing members from passed in stream. */
		public TokenBeginContentBlock(BinaryReader BinaryStream)
		{
			ObjectNameIndex = TokenHelper.LoadPackedInt(BinaryStream);
			NumBits = BinaryStream.ReadUInt16();
		}

		/**
		 * Returns whether the token matches/ passes based on the passed in filters.
		 * 
		 * @param	ActorFilter		Actor filter to match against
		 * @param	PropertyFilter	Property filter to match against
		 * @param	RPCFilter		RPC filter to match against
		 * 
		 * @return true if it matches, false otherwise
		 */
		public override bool MatchesFilters(FilterValues InFilterValues)
		{
			return base.MatchesFilters(InFilterValues) && (InFilterValues.ActorFilter.Length == 0 || StreamParser.NetworkStream.GetName(ObjectNameIndex).ToUpperInvariant().Contains(InFilterValues.ActorFilter.ToUpperInvariant()));
		}
	}

	/**
	 * Token for property header replication. Context determines which actor this belongs to.
	 */
	class TokenEndContentBlock : TokenBase
	{
		/** Name table index of property name. */
		public int ObjectNameIndex;
		/** Number of bits serialized/ sent. */
		public UInt16 NumBits;

		/** Constructor, serializing members from passed in stream. */
		public TokenEndContentBlock(BinaryReader BinaryStream)
		{
			ObjectNameIndex = TokenHelper.LoadPackedInt(BinaryStream);
			NumBits = BinaryStream.ReadUInt16();
		}

		/**
		 * Returns whether the token matches/ passes based on the passed in filters.
		 * 
		 * @param	ActorFilter		Actor filter to match against
		 * @param	PropertyFilter	Property filter to match against
		 * @param	RPCFilter		RPC filter to match against
		 * 
		 * @return true if it matches, false otherwise
		 */
		public override bool MatchesFilters(FilterValues InFilterValues)
		{
			return base.MatchesFilters(InFilterValues) && (InFilterValues.ActorFilter.Length == 0 || StreamParser.NetworkStream.GetName(ObjectNameIndex).ToUpperInvariant().Contains(InFilterValues.ActorFilter.ToUpperInvariant()));
		}
	}

	/**
	 * Token for property handle replication. Context determines which actor this belongs to.
	 */
	class TokenWritePropertyHandle : TokenBase
	{
		/** Number of bits serialized/ sent. */
		public UInt16 NumBits;

		/** Constructor, serializing members from passed in stream. */
		public TokenWritePropertyHandle(BinaryReader BinaryStream)
		{
			NumBits = BinaryStream.ReadUInt16();
		}
	}

	/**
	 * Token for connection change event
	 */
	class TokenConnectionChanged : TokenBase
	{
		/** Number of bits serialized/ sent. */
		public Int32 AddressIndex;

		/** Constructor, serializing members from passed in stream. */
		public TokenConnectionChanged(BinaryReader BinaryStream)
		{
			AddressIndex = TokenHelper.LoadPackedInt(BinaryStream);
		}
	}

	/**
	 * Token for connection reference event
	 */
	class TokenNameReference : TokenBase
	{
		/** Address of connection */
		public string Name = null;

		/** Constructor, serializing members from passed in stream. */
		public TokenNameReference(BinaryReader BinaryStream)
		{
			UInt32 Length = BinaryStream.ReadUInt32();
			Name = new string(BinaryStream.ReadChars((int)Length));
		}
	}

	/**
	 * Token for connection reference event
	 */
	class TokenConnectionReference : TokenBase
	{
		/** Address of connection */
		public UInt64 Address;

		/** Constructor, serializing members from passed in stream. */
		public TokenConnectionReference(BinaryReader BinaryStream)
		{
			Address = BinaryStream.ReadUInt64();
		}
	}

	/**
	 * Token for connection reference as a string.
	 * This allows for support for different address formats without having to do any additional work.
	 * Addresses are pushed in via the ToString(true) call on an FInternetAddr
	 */
	class TokenConnectionStringReference : TokenBase
	{
		/** Address of connection */
		public string Address = null;

		/** Constructor, serializing members from passed in stream. */
		public TokenConnectionStringReference(BinaryReader BinaryStream)
		{
			int StrLength = Math.Abs(BinaryStream.ReadInt32());
			Address = new string(BinaryStream.ReadChars(StrLength));
		}
	}

	/**
	 * Token for events.
	 */
	class TokenEvent : TokenBase
	{
		/** Name table index of event name. */
		public int EventNameNameIndex;
		/** Name table index of event description. */
		public int EventDescriptionNameIndex;

		/** Constructor, serializing members from passedin stream. */
		public TokenEvent(BinaryReader BinaryStream)
		{
			EventNameNameIndex = TokenHelper.LoadPackedInt(BinaryStream);
			EventDescriptionNameIndex = TokenHelper.LoadPackedInt(BinaryStream);
		}

		/**
		 * Fills tree view with description of this token
		 * 
		 * @param	Tree			Tree to fill in 
		 * @param	ActorFilter		Filter for actor name
		 * @param	PropertyFilter	Filter for property name
		 * @param	RPCFilter		Unused
		 */
		public override void ToDetailedTreeView(ItemCollection Tree, FilterValues InFilterValues)
		{
			TreeViewItem Child = TokenHelper.AddNode(Tree, "Events");

			Child.Items.Add("Type          : " + StreamParser.NetworkStream.GetName(EventNameNameIndex));
			Child.Items.Add("Description   : " + StreamParser.NetworkStream.GetName(EventDescriptionNameIndex));
		}
	}

	/**
	 * Token for raw socket data. Not captured by default in UE3.
	 */
	class TokenRawSocketData : TokenBase
	{
		/** Raw data. */
		public byte[] RawData;

		/** Constructor, serializing members from passed in stream. */
		public TokenRawSocketData(BinaryReader BinaryStream)
		{
			int Size = BinaryStream.ReadUInt16();
			RawData = BinaryStream.ReadBytes(Size);
		}
	}

	/**
	 * Token for sent acks.
	 */
	class TokenSendAck : TokenBase
	{
		/** Number of bits serialized/sent. */
		public UInt16 NumBits;

		/** Constructor, serializing members from passed in stream. */
		public TokenSendAck(BinaryReader BinaryStream)
		{
			NumBits = BinaryStream.ReadUInt16();
		}

		public override void ToDetailedTreeView(ItemCollection Tree, FilterValues InFilterValues)
		{
			TreeViewItem Child = TokenHelper.AddNode(Tree, "Send Acks");

			Child.Items.Add("NumBytes : " + NumBits / 8.0f);
		}
	}

	/**
	 * Token that tracks information about property comparisons for objects.
	 */
	class TokenPropertyComparison : TokenBase
	{
		/** Index to the Name of the object whose properties we were comparing. */
		public int ObjectNameIndex;

		/** The amount of time we spent comparing the properties. */
		public float TimeSpentComparing;

		/**
		 * A BitArray describing which of the top level properties of the object were actually compared.
		 * The number of bits will always match the number of top level properties in the class.
		 */
		public BitArray ComparedProperties;

		/**
		 * A BitArray describing which of the top level properties of the object were found to have changed
		 * after we compared them.
		 * The number of bits will always match the number of top level properties in the class.
		 */
		public BitArray ChangedProperties;

		public List<int> ExportedPropertyNames;

		public TokenPropertyComparison(BinaryReader BinaryStream)
		{
			ObjectNameIndex = TokenHelper.LoadPackedInt(BinaryStream);
			TimeSpentComparing = BinaryStream.ReadSingle();
			TokenHelper.ReadBitArray(BinaryStream, ref ComparedProperties);
			TokenHelper.ReadBitArray(BinaryStream, ref ChangedProperties);

			int NumExportedPropertyNames = TokenHelper.LoadPackedInt(BinaryStream);
			if (NumExportedPropertyNames > 0)
			{
				ExportedPropertyNames = new List<int>(NumExportedPropertyNames);
				for (int i = 0; i < NumExportedPropertyNames; ++i)
				{
					ExportedPropertyNames.Add(TokenHelper.LoadPackedInt(BinaryStream));
				}
			}
		}
	}

	/**
	 * Token that tracks basic metadata about replication for objects.
	 */
	class TokenReplicatePropertiesMetaData : TokenBase
	{
		/** Index to the Name of the object whose properties we were replicating. */
		public int ObjectNameIndex;

		/**
		 * Whether or not we resent our entire history.
		 * This is used to indicate we were resending everything for replay recording (checkpoints).
		 * Note, properties that were filtered for the connection or that were inactive won't have
		 * been sent, so using FilteredProperties is still required to see what was actually sent.
		 */
		public bool bSentAllChangedProperties;

		/**
		 * A BitArray describing which of the top level properties of the object were inactive (would not
		 * be replicated) during a call to ReplicateProperties.
		 * The number of bits will always match the number of top level properties in the class,
		 * unless bWasAnythingSent is false (in which case it will be null).
		 */
		public BitArray FilteredProperties;

		public TokenReplicatePropertiesMetaData(BinaryReader BinaryStream)
		{
			ObjectNameIndex = TokenHelper.LoadPackedInt(BinaryStream);

			byte Flags = BinaryStream.ReadByte();
			bSentAllChangedProperties = (Flags & 0x1) != 0;
			TokenHelper.ReadBitArray(BinaryStream, ref FilteredProperties);
		}
	}


	public class TokenHelper
	{
		public const int NumBitsPerDWord = 32;
		public const int NumBitsPerDWordLog2 = 5;

		static public TreeViewItem AddNode(ItemCollection Tree, string Text)
		{
			List<TreeViewItem> Childs = null;
			TreeViewItem Child = null;

			foreach (TreeViewItem C in Tree)
			{
				if ((string)C.Header == Text)
				{
					Childs.Add(C);
				}
			}

			if (Childs == null || Childs.Count == 0)
			{
				Child = new TreeViewItem();
				Child.Header = Text;				
				Child.Name = Text;
				Tree.Add(Child);
			}
			else
			{
				Child = Childs[0];
			}

			return Child;
		}

		public static int LoadPackedInt(BinaryReader BinaryStream)
		{
			UInt32 Value = 0;
			byte cnt = 0;
			bool more = true;
			while (more)
			{
				UInt32 NextByte = BinaryStream.ReadByte();

				more = (NextByte & 1) != 0;     // Check 1 bit to see if theres more after this
				NextByte = NextByte >> 1;           // Shift to get actual 7 bit value
				Value += NextByte << (7 * cnt++);   // Add to total value
			}

			return (int)Value;
		}

		public static void ReadBitArray(BinaryReader BinaryStream, ref BitArray OutBitArray)
		{
			// TODO: Verify Endianness
			int NumBits = LoadPackedInt(BinaryStream);
			int NumInts = ((NumBits + NumBitsPerDWord - 1) >> NumBitsPerDWordLog2);
			int[] ReadValues = new int[NumInts];

			for (Int32 Idx = 0; Idx < NumInts; Idx++)
			{
				ReadValues[Idx] = LoadPackedInt(BinaryStream);
			}

			OutBitArray = new BitArray(ReadValues);
			OutBitArray.Length = NumBits;
		}
	}
}
```

`UE4 Network Profiler/MainWindow.xaml`:

```xaml
<hc:GlowWindow x:Name="UnrealNetworkProfilerMainWindow"
		xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
		xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
		xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
		xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
		xmlns:hc="https://handyorg.github.io/handycontrol"
		x:Class="NetworkProfiler.MainWindow"
		mc:Ignorable="d"
		Title="Unreal Engine Network Profiler" Height="720" Width="1280" Closing="UnrealNetworkProfilerMainWindow_Closing">
	<hc:GlowWindow.NonClientAreaContent>
		<StackPanel VerticalAlignment="Stretch" Orientation="Horizontal">
			<Separator Width="10" VerticalAlignment="Center" HorizontalAlignment="Center" Margin="10,0,0,0"/>
			<Button x:Name="AboutBtn" Content="About" Style="{StaticResource ButtonBaseStyle}" Click="AboutBtn_Click"/>
		</StackPanel>
	</hc:GlowWindow.NonClientAreaContent>
	<Grid>
		<DockPanel>
			<StackPanel DockPanel.Dock="Top">
				<Button x:Name="OpenNetworkProfileBtn" Content="Open Network Profile" Margin="10" hc:BorderElement.CornerRadius="5" HorizontalAlignment="Stretch" Click="OpenNetworkProfileBtn_Click"/>
				<DockPanel>
					<TextBlock x:Name="EarlyOutLabel" Text="Max Profile Minutes:" Margin="10" VerticalAlignment="Center" />
					<TextBox x:Name="MaxProfileMinutesTextBox" Margin="0 10 0 10" Width="60" TextChanged="MaxProfileMinutesTextBox_TextChanged" />
					<ProgressBar x:Name="CurrentProgress" Margin="10 0 10 0"  />
				</DockPanel>
			</StackPanel>

			<hc:TabControl ShowCloseButton="False" IsAnimationEnabled="True" IsDraggable="True" ShowContextMenu="False">
				<hc:TabItem Header="Charts, Filters, Details" IsSelected="True">
					<Grid>
						<Grid.RowDefinitions>
							<RowDefinition Height="*" />
							<RowDefinition Height="10" />
							<RowDefinition Height="300" />
						</Grid.RowDefinitions>
						<Grid Grid.Row="0">
							<Grid.ColumnDefinitions>
								<ColumnDefinition Width="*" />
								<ColumnDefinition Width="10" />
								<ColumnDefinition Width="400" />
							</Grid.ColumnDefinitions>
							<WpfPlot x:Name="NetworkChart" Margin="0 0 10 0"/>
							<GridSplitter Grid.Column="1" HorizontalAlignment="Stretch" Background="#0CF0F0F0" Margin="0 10 0 10" />
							<DockPanel LastChildFill="True" Grid.Column="2">
								<StackPanel DockPanel.Dock="Top" Orientation="Horizontal" HorizontalAlignment="Stretch" >
									<hc:ComboBox x:Name="PlotStyleSelector" Margin="10 0 5 0" SelectedIndex="2"  SelectionChanged="PlotStyleSelector_SelectionChanged" HorizontalAlignment="Stretch">
										<ComboBoxItem Content="Default"/>
										<ComboBoxItem Content="Control"/>
										<ComboBoxItem Content="Blue1"/>
										<ComboBoxItem Content="Blue2"/>
										<ComboBoxItem Content="Blue3"/>
										<ComboBoxItem Content="Light1"/>
										<ComboBoxItem Content="Light2"/>
										<ComboBoxItem Content="Gray1"/>
										<ComboBoxItem Content="Gray2"/>
										<ComboBoxItem Content="Black"/>
										<ComboBoxItem Content="Seaborn"/>
									</hc:ComboBox>
									<CheckBox x:Name="ChartShowLegendCheckBox" Content="Show Legend" IsChecked="True" Checked="ChartShowLegendCheckBox_Checked" Unchecked="ChartShowLegendCheckBox_Unchecked" HorizontalAlignment="Right"/>
								</StackPanel>
								<ListBox x:Name="ChartListBox" Margin="10 5 10 0"/>
							</DockPanel>
						</Grid>

						<GridSplitter Grid.Row="1" HorizontalAlignment="Stretch" Background="#0CF0F0F0" Margin="10 5 5 0" />

						<Grid Grid.Row="2" Margin="0 5 0 0">
							<Grid.ColumnDefinitions>
								<ColumnDefinition Width="*" />
								<ColumnDefinition Width="10" />
								<ColumnDefinition Width="400" />
							</Grid.ColumnDefinitions>
							<hc:TabControl x:Name="Details" Grid.Column="0" IsAnimationEnabled="True" IsDraggable="True" ShowContextMenu="False" >
								<hc:TabItem Header="Summary">
									<TreeView x:Name="ActorSummaryView"/>
								</hc:TabItem>
								<hc:TabItem Header="Actors">
									<Grid>
										<Grid.ColumnDefinitions>
											<ColumnDefinition Width="*" />
											<ColumnDefinition Width="10" />
											<ColumnDefinition Width="250" />
										</Grid.ColumnDefinitions>
										<ListView x:Name="ActorPerfPropsListView" Grid.Column="0" SelectionChanged="ActorPerfPropsListView_SelectionChanged">
											<ListView.View>
												<GridView>
													<GridViewColumn Header="Actor" Width="Auto" DisplayMemberBinding="{Binding Header1}" />
													<GridViewColumn Header="MS" Width="Auto" DisplayMemberBinding="{Binding Header2}" />
													<GridViewColumn Header="KB/s" Width="Auto" DisplayMemberBinding="{Binding Header3}" />
													<GridViewColumn Header="Bytes" Width="Auto" DisplayMemberBinding="{Binding Header4}" />
													<GridViewColumn Header="Count" Width="Auto" DisplayMemberBinding="{Binding Header5}" />
													<GridViewColumn Header="Update HZ" Width="Auto" DisplayMemberBinding="{Binding Header6}" />
													<GridViewColumn Header="Rep HZ" Width="Auto" DisplayMemberBinding="{Binding Header7}" />
													<GridViewColumn Header="Waste" Width="Auto" DisplayMemberBinding="{Binding Header8}" />
												</GridView>
											</ListView.View>
										</ListView>
										<GridSplitter Grid.Column="1" HorizontalAlignment="Stretch" Background="#0CF0F0F0" Margin="1 10 1 10" />
										<ListView x:Name="ActorPerfPropsDetailsListView" Grid.Column="2">
											<ListView.View>
												<GridView>
													<GridViewColumn Header="Property" Width="Auto" DisplayMemberBinding="{Binding Header1}" />
													<GridViewColumn Header="Bytes" Width="Auto" DisplayMemberBinding="{Binding Header2}" />
													<GridViewColumn Header="Count" Width="Auto" DisplayMemberBinding="{Binding Header3}" />
												</GridView>
											</ListView.View>
										</ListView>
									</Grid>
								</hc:TabItem>
								<hc:TabItem Header="Token Details">
									<TreeView x:Name="TokenDetailsView"/>
								</hc:TabItem>
							</hc:TabControl>
							<GridSplitter Grid.Column="1" HorizontalAlignment="Stretch" Background="#0CF0F0F0" Margin="2" />
							<DockPanel Grid.Column="2">
								<CheckBox x:Name="CheckAllConnectionsCheckBox" Content="Enable All" DockPanel.Dock="Top" HorizontalAlignment="Left" Margin="10 10 0 0" Checked="CheckAllConnectionsCheckBox_Checked" Unchecked="CheckAllConnectionsCheckBox_Unchecked" IsChecked="True"/>
								<Grid>
									<Grid.RowDefinitions>
										<RowDefinition Height="110" />
										<RowDefinition Height="*" />
										<RowDefinition Height="60" />
									</Grid.RowDefinitions>
									<ListBox x:Name="ConnectionListBox" Margin="10" Grid.Row="0"/>
									<StackPanel Grid.Row="1">
										<DockPanel>
											<TextBlock Text="Actor Filter" Margin="10"/>
											<hc:ComboBox x:Name="ActorFilterBox" Margin="16,0,10,0"/>
										</DockPanel>
										<DockPanel>
											<TextBlock Text="Property Filter" Margin="10"/>
											<hc:ComboBox x:Name="PropertyFilterBox" Margin="0,0,10,0"/>
										</DockPanel>
										<DockPanel>
											<TextBlock Text="RPC Filter" Margin="10"/>
											<hc:ComboBox x:Name="RPCFilterBox" Margin="24,0,10,0"/>
										</DockPanel>
									</StackPanel>
									<StackPanel Grid.Row="2" Orientation="Horizontal" HorizontalAlignment="Center" >
										<Button x:Name="ResetFiltersButton" Content="Reset Filters" Margin="0 0 5 0" Width="180" Click="ResetFiltersButton_Click" />
										<Button x:Name="ApplyFiltersButton" Content="Apply Filters" HorizontalAlignment="Stretch" Margin="5 0 0 0" Click="ApplyFiltersButton_Click" Width="180"/>
									</StackPanel>
								</Grid>
							</DockPanel>
						</Grid>
					</Grid>
				</hc:TabItem>

				<hc:TabItem Header="All Actors">
					<ListView x:Name="ActorListView">
						<ListView.View>
							<GridView>
								<GridViewColumn Header="Total Size (K/Bytes)" Width="Auto" DisplayMemberBinding="{Binding Header1}" />
								<GridViewColumn Header="Count" Width="Auto" DisplayMemberBinding="{Binding Header2}" />
								<GridViewColumn Header="Average Size (Bytes)" Width="Auto" DisplayMemberBinding="{Binding Header3}" />
								<GridViewColumn Header="Average Size (Bits)" Width="Auto" DisplayMemberBinding="{Binding Header4}" />
								<GridViewColumn Header="Time (ms)" Width="Auto" DisplayMemberBinding="{Binding Header5}" />
								<GridViewColumn Header="Average Time (ms)" Width="Auto" DisplayMemberBinding="{Binding Header6}" />
								<GridViewColumn Header="Actor Class" Width="Auto" DisplayMemberBinding="{Binding Header7}" />
							</GridView>
						</ListView.View>
					</ListView>
				</hc:TabItem>

				<hc:TabItem Header="All Properties">
					<ListView x:Name="PropertyListView">
						<ListView.View>
							<GridView>
								<GridViewColumn Header="Total Size (K/Bytes)" Width="Auto" DisplayMemberBinding="{Binding Header1}" />
								<GridViewColumn Header="Count" Width="Auto" DisplayMemberBinding="{Binding Header2}" />
								<GridViewColumn Header="Average Size (Bytes)" Width="Auto" DisplayMemberBinding="{Binding Header3}" />
								<GridViewColumn Header="Average Size (Bits)" Width="Auto" DisplayMemberBinding="{Binding Header4}" />
								<GridViewColumn Header="Time (ms)" Width="Auto" DisplayMemberBinding="{Binding Header5}" />
								<GridViewColumn Header="Average Time (ms)" Width="Auto" DisplayMemberBinding="{Binding Header6}" />
								<GridViewColumn Header="Property" Width="Auto" DisplayMemberBinding="{Binding Header7}" />
							</GridView>
						</ListView.View>
					</ListView>
				</hc:TabItem>

				<hc:TabItem Header="All RPCs">
					<ListView x:Name="RPCListView">
						<ListView.View>
							<GridView>
								<GridViewColumn Header="Total Size (K/Bytes)" Width="Auto" DisplayMemberBinding="{Binding Header1}" />
								<GridViewColumn Header="Count" Width="Auto" DisplayMemberBinding="{Binding Header2}" />
								<GridViewColumn Header="Average Size (Bytes)" Width="Auto" DisplayMemberBinding="{Binding Header3}" />
								<GridViewColumn Header="Average Size (Bits)" Width="Auto" DisplayMemberBinding="{Binding Header4}" />
								<GridViewColumn Header="Time (ms)" Width="Auto" DisplayMemberBinding="{Binding Header5}" />
								<GridViewColumn Header="Average Time (ms)" Width="Auto" DisplayMemberBinding="{Binding Header6}" />
								<GridViewColumn Header="RPC" Width="Auto" DisplayMemberBinding="{Binding Header7}" />
							</GridView>
						</ListView.View>
					</ListView>
				</hc:TabItem>

				<hc:TabItem Header="All Objects">
					<Grid>
						<Grid.ColumnDefinitions>
							<ColumnDefinition Width="*" />
							<ColumnDefinition Width="10" />
							<ColumnDefinition Width="450" />
						</Grid.ColumnDefinitions>
						<ListView x:Name="ObjectReplicationListView" Grid.Column="0">
							<ListView.View>
								<GridView>
									<GridViewColumn Header="Object Class" Width="Auto" />
									<GridViewColumn Header="# Comparisons" Width="Auto" />
									<GridViewColumn Header="# Replications" Width="Auto" />
									<GridViewColumn Header="Comparison Time" Width="Auto" />
									<GridViewColumn Header="Avg. Time Per Comparison" Width="Auto" />
								</GridView>
							</ListView.View>
						</ListView>
						<GridSplitter Grid.Column="1" HorizontalAlignment="Stretch" Background="#0CF0F0F0" Margin="2" />
						<ListView x:Name="ObjectPropertyReplicationListView" Grid.Column="2">
							<ListView.View>
								<GridView>
									<GridViewColumn Header="Property" Width="Auto" />
									<GridViewColumn Header="Comparisons" Width="Auto" />
									<GridViewColumn Header="# Times Changed" Width="Auto" />
								</GridView>
							</ListView.View>
						</ListView>
					</Grid>
				</hc:TabItem>

			</hc:TabControl>
		</DockPanel>
	</Grid>
</hc:GlowWindow>

```

`UE4 Network Profiler/MainWindow.xaml.cs`:

```cs
/************************************************************************/
/* 
 * This is a WPF rewrite of Network Profiler by Epic Games.
 * Original repository can be found here: https://github.com/EpicGames/UnrealEngine/tree/master/Engine/Source/Programs/NetworkProfiler 
 * 
 * Pull requests are welcome. 
 * =============================================
 * 
 * Written in WPF by Satheesh (ryanjon2040) 
 * Github :		https://github.com/ryanjon2040 
 * Twitter:		https://twitter.com/ryanjon2040
 * Facebook:	https://facebook.com/ryanjon2040
 * Discord:		ryanjon2040#5319
 */
/************************************************************************/

#define ENABLE_EXTRAS
#undef ENABLE_EXTRAS

using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using System.Windows.Controls;
using System.Windows.Threading;
using Microsoft.Win32;
using System.Windows;
using ScottPlot.Plottable;
using GameAnalyticsSDK.Net;
using System.Reflection;
using UE4_Network_Profiler.UserControls;
using HandyControl.Controls;

namespace NetworkProfiler
{
	public enum SeriesType : int
	{
		OutgoingBandwidthSize = 0,
		OutgoingBandwidthSizeSec,
		OutgoingBandwidthSizeAvgSec,
		ActorCount,
		PropertySize,
		PropertySizeSec,
		RPCSize,
		RPCSizeSec,
		Events,
		ActorCountSec,
		PropertyCount,
		PropertyCountSec,
		RPCCount,
		RPCCountSec,
		ExportBunchCount,
		ExportBunchSize,
		MustBeMappedGuidsCount,
		MustBeMappedGuidsSize,
		SendAckCount,
		SendAckCountSec,
		SendAckSize,
		SendAckSizeSec,
		ContentBlockHeaderSize,
		ContentBlockFooterSize,
		PropertyHandleSize,
		SendBunchCount,
		SendBunchCountSec,
		SendBunchSize,
		SendBunchSizeSec,
		SendBunchHeaderSize,
		GameSocketSendSize,
		GameSocketSendSizeSec,
		GameSocketSendCount,
		GameSocketSendCountSec,
		ActorReplicateTimeInMS,
#if ENABLE_EXTRAS
		MiscSocketSendSize,
		MiscSocketSendSizeSec,
		MiscSocketSendCount,
		MiscSocketSendCountSec,
#endif
	};

	public partial class MainWindow
	{
		// Please DO NOT change this. If you don't want Analytics, set both GAME_KEY and SECRET_KEY to null ///////////////////
		private static readonly string GAME_KEY = "81ebb126baf40ca75b9ce26e2f3e7ad2"; // null
		private static readonly string SECRET_KEY = "18f49fbf8da84dadaff7ca0ad76ab01f78771725"; // null
		///////////////////////////////////////////////////////////////////////////////////////////////

		/** Currently selected frame on chart			*/
		//int CurrentFrame = 0;

		///** Marks last selected range on chart			*/
		//int RangeSelectStart = -1;
		//int RangeSelectEnd = -1;

		/** Current network stream.						*/
		NetworkStream CurrentNetworkStream = null;

		PartialNetworkStream CurrentStreamSelection = null;

		FilterValues CurrentFilterValues = new FilterValues();

		Thread LoadThread = null;
		Thread SelectRangeThread = null;

		private Dialog aboutDialog = null;

		/** If non 0, we will early out of loading in this many minutes worth of profile time */
		int MaxProfileMinutes = 0;

		public Dictionary<int, SeriesTypeValues> DefaultSeriesTypes = new Dictionary<int, SeriesTypeValues>();

		public MainWindow()
		{
			InitializeComponent();
			SetDefaultLineView();
			NetworkChart.Plot.Legend(true, ScottPlot.Alignment.UpperLeft);
			DataContext = this;
			Title = $"Unreal Engine Network Profiler v{GetProductVersionString()}";

			if (GAME_KEY != null && SECRET_KEY != null)
			{
				GameAnalytics.ConfigureBuild($"Unreal Network Profiler v{GetProductVersionString()}");
				GameAnalytics.Initialize(GAME_KEY, SECRET_KEY);

#if DEBUG
				GameAnalytics.AddDesignEvent("Program:Start:Debug");
#else
				GameAnalytics.AddDesignEvent("Program:Start:Release");
#endif
			}
		}

		private static string GetProductVersionString()
		{
			Version ProductVersion = Assembly.GetEntryAssembly().GetName().Version;
			string ReturnValue = $"{ProductVersion.Major}.{ProductVersion.Minor}";

			if (ProductVersion.Build > 0)
			{
				ReturnValue += $".{ProductVersion.Build}";
			}

			if (ProductVersion.Revision > 0)
			{
				ReturnValue += $".{ProductVersion.Revision}";
			}

			return ReturnValue;
		}

		private void SetDefaultLineView()
		{
			NetworkChart.Plot.Clear();
			ChartListBox.Items.Clear();
			DefaultSeriesTypes.Clear();

			RegisterChartSeries(SeriesType.OutgoingBandwidthSize, "Outgoing Bandwidth Bytes", false);
			RegisterChartSeries(SeriesType.OutgoingBandwidthSizeSec, "Outgoing Bandwidth Bytes/s", true);
			RegisterChartSeries(SeriesType.OutgoingBandwidthSizeAvgSec, "Outgoing Bandwidth Avg/s", true);
			RegisterChartSeries(SeriesType.ActorCount, "Actor Count", false);
			RegisterChartSeries(SeriesType.PropertySize, "Property Bytes", false);
			RegisterChartSeries(SeriesType.PropertySizeSec, "Property Bytes/s", true);
			RegisterChartSeries(SeriesType.RPCSize, "RPC Bytes", false);
			RegisterChartSeries(SeriesType.RPCSizeSec, "RPC Bytes/s", true);
			RegisterChartSeries(SeriesType.Events, "Events", false);

			RegisterChartSeries(SeriesType.ActorCountSec, "Actor Count/s", false);
			RegisterChartSeries(SeriesType.PropertyCount, "Property Count", false);
			RegisterChartSeries(SeriesType.PropertyCountSec, "Property Count/s", false);
			RegisterChartSeries(SeriesType.RPCCount, "RPC Count", false);
			RegisterChartSeries(SeriesType.RPCCountSec, "RPC Count/s", false);
			RegisterChartSeries(SeriesType.ExportBunchCount, "Export Bunch Count", false);
			RegisterChartSeries(SeriesType.ExportBunchSize, "Export Bunch Count/s", false);
			RegisterChartSeries(SeriesType.MustBeMappedGuidsCount, "Must Be Mapped Guid Count", false);
			RegisterChartSeries(SeriesType.MustBeMappedGuidsSize, "Must Be Mapped Guid Bytes", false);
			RegisterChartSeries(SeriesType.SendAckCount, "Send Ack Count", false);
			RegisterChartSeries(SeriesType.SendAckCountSec, "Send Ack Count/s", false);
			RegisterChartSeries(SeriesType.SendAckSize, "Send Ack Bytes", false);
			RegisterChartSeries(SeriesType.SendAckSizeSec, "Send Ack Bytes/s", false);
			RegisterChartSeries(SeriesType.ContentBlockHeaderSize, "Content Block Header Bytes", false);
			RegisterChartSeries(SeriesType.ContentBlockFooterSize, "Content Block Footer Bytes", false);
			RegisterChartSeries(SeriesType.PropertyHandleSize, "Property Handle Bytes", false);
			RegisterChartSeries(SeriesType.SendBunchCount, "Send Bunch Count", false);
			RegisterChartSeries(SeriesType.SendBunchCountSec, "Send Bunch Count/s", false);
			RegisterChartSeries(SeriesType.SendBunchSize, "Send Bunch Bytes", false);
			RegisterChartSeries(SeriesType.SendBunchSizeSec, "Send Bunch Bytes/s", false);
			RegisterChartSeries(SeriesType.SendBunchHeaderSize, "Send Bunch Header Bytes", false);
			RegisterChartSeries(SeriesType.GameSocketSendSize, "Game Socket Send Bytes", false);
			RegisterChartSeries(SeriesType.GameSocketSendSizeSec, "Game Socket Send Bytes/s", false);
			RegisterChartSeries(SeriesType.GameSocketSendCount, "Game Socket Send Count", false);
			RegisterChartSeries(SeriesType.GameSocketSendCountSec, "Game Socket Send Count/s", false);
			RegisterChartSeries(SeriesType.ActorReplicateTimeInMS, "Actor Replicate Time In MS", false);

#if ENABLE_EXTRAS
			RegisterChartSeries(SeriesType.MiscSocketSendSize, "Misc Socket Send Bytes", false);
			RegisterChartSeries(SeriesType.MiscSocketSendSizeSec, "Misc Socket Send Bytes/s", false);
			RegisterChartSeries(SeriesType.MiscSocketSendCount, "Misc Socket Send Count", false);
			RegisterChartSeries(SeriesType.MiscSocketSendCountSec, "Misc Socket Send Count/s", false);
#endif
		}

		protected void RegisterChartSeries(SeriesType Type, string FriendlyName, bool bEnabled)
		{
			CheckBox ChartListBoxItemCheckbox = new CheckBox();
			ChartListBoxItemCheckbox.Content = FriendlyName;
			ChartListBoxItemCheckbox.IsChecked = bEnabled;
			ChartListBoxItemCheckbox.Checked += ChartListBoxItemChecked;
			ChartListBoxItemCheckbox.Unchecked += ChartListBoxItemUnChecked;
			ChartListBox.Items.Add(ChartListBoxItemCheckbox);

			DefaultSeriesTypes.Add((int)Type, new SeriesTypeValues(Type, 0, 0, bEnabled));
		}
		
		private void ChartListBoxItemChecked(object sender, RoutedEventArgs e)
		{
			ChartListBoxItemToggle(true);
		}

		private void ChartListBoxItemUnChecked(object sender, RoutedEventArgs e)
		{
			ChartListBoxItemToggle(false);
		}

		private void ChartListBoxItemToggle(bool bCheck)
		{
			IPlottable[] Plots = NetworkChart.Plot.GetPlottables();

			for (int i = 0; i < ChartListBox.Items.Count; i++)
			{				
				DefaultSeriesTypes[i].bVisible = (bool)((CheckBox)ChartListBox.Items[i]).IsChecked;
				Plots[i].IsVisible = DefaultSeriesTypes[i].bVisible;
			}

			NetworkChart.Render();
		}

		public void AddChartPoint(SeriesType Type, double X, double Y)
		{
			DefaultSeriesTypes[(int)Type].Add(X, Y);
		}

		public void UpdateNetworkChart()
		{
			foreach (var T in DefaultSeriesTypes)
			{
				SignalPlotXY plotXY = NetworkChart.Plot.AddSignalXY(T.Value.GetArrayX(), T.Value.GetArrayY(), null, T.Value.ToString());
				plotXY.IsVisible = T.Value.bVisible;
			}
		}

		public void UpdateProgress(int Value)
		{
			if (Dispatcher.CheckAccess())
			{
				CurrentProgress.Value = Math.Max(0, Math.Min(100, Value));
				return;
			}

			Dispatcher.Invoke(new Action(() => UpdateProgress(Value)));
		}

		public void ShowProgress(bool bShow)
		{
			if (Dispatcher.CheckAccess())
			{
				CurrentProgress.Visibility = bShow ? System.Windows.Visibility.Visible : System.Windows.Visibility.Collapsed;
				CurrentProgress.Value = 0;
				return;
			}

			Dispatcher.Invoke(new Action(() => ShowProgress(bShow)));
		}

		private void ChangeNetworkStreamWorker(string Filename)
		{
			using (FileStream ParserStream = File.OpenRead(Filename))
			{
				try
				{
					CurrentNetworkStream = StreamParser.Parse(this, ParserStream);
					ParseStreamForListViews();
					ChartParser.ParseStreamIntoChart(this, CurrentNetworkStream, NetworkChart, CurrentFilterValues);
				}
				catch (System.Threading.ThreadAbortException)
				{

				}
				catch (System.Exception se)
				{
					Console.Out.WriteLine(se.StackTrace);
					ClearStreamAndChart();
				}
			}

			LoadThread = null;
		}

		private void CancelLoadThread()
		{
			if (LoadThread != null)
			{
				LoadThread.Abort();				
				LoadThread = null;
			}
		}

		private void ChangeNetworkStream(string Filename)
		{
			CancelLoadThread();

			LoadThread = new Thread(() => ChangeNetworkStreamWorker(Filename));
			LoadThread.Start();
		}

		public void ClearStreamAndChart()
		{
			if (Dispatcher.CheckAccess())
			{
				CurrentNetworkStream = null;
				NetworkChart.Plot.Clear();
				return;
			}

			Dispatcher.Invoke(new Action(() => ClearStreamAndChart()));
		}

		public void ParseStreamForListViews()
		{
			if (Dispatcher.CheckAccess() == false)
			{
				Dispatcher.Invoke(new Action(() => ParseStreamForListViews()));
				return;
			}

			StreamParser.ParseStreamIntoListView(CurrentNetworkStream, CurrentNetworkStream.ActorNameToSummary, ActorListView);
			StreamParser.ParseStreamIntoListView(CurrentNetworkStream, CurrentNetworkStream.PropertyNameToSummary, PropertyListView);
			StreamParser.ParseStreamIntoListView(CurrentNetworkStream, CurrentNetworkStream.RPCNameToSummary, RPCListView);
			StreamParser.ParseStreamIntoReplicationListView(CurrentNetworkStream, CurrentNetworkStream.ObjectNameToReplicationSummary, ObjectReplicationListView);

			ActorFilterBox.Items.Clear();
			ActorFilterBox.Items.Add("");

			PropertyFilterBox.Items.Clear();
			PropertyFilterBox.Items.Add("");

			RPCFilterBox.Items.Clear();
			RPCFilterBox.Items.Add("");

			foreach (var SummaryEntry in CurrentNetworkStream.ActorNameToSummary)
			{
				ActorFilterBox.Items.Add(CurrentNetworkStream.GetName(SummaryEntry.Key));
			}

			foreach (var SummaryEntry in CurrentNetworkStream.PropertyNameToSummary)
			{
				PropertyFilterBox.Items.Add(CurrentNetworkStream.GetName(SummaryEntry.Key));
			}

			foreach (var SummaryEntry in CurrentNetworkStream.RPCNameToSummary)
			{
				RPCFilterBox.Items.Add(CurrentNetworkStream.GetName(SummaryEntry.Key));
			}

			ConnectionListBox.Items.Clear();

			int NumberOfAddresses = (CurrentNetworkStream.GetVersion() < 12) ? CurrentNetworkStream.AddressArray.Count : CurrentNetworkStream.StringAddressArray.Count;
			for (int i = 0; i < NumberOfAddresses; i++)
			{
				CheckBox ConnectionCheckbox = new CheckBox();
				ConnectionCheckbox.Content = CurrentNetworkStream.GetIpString(i, CurrentNetworkStream.GetVersion());
				ConnectionCheckbox.IsChecked = true;
				ConnectionCheckbox.Checked += ConnectionListBoxItemChecked;
				ConnectionCheckbox.Unchecked += ConnectionListBoxItemUnChecked;
				ConnectionListBox.Items.Add(ConnectionCheckbox);
			}
		}

		private void ConnectionListBoxItemChecked(object sender, RoutedEventArgs e)
		{
			UpdateConnectionFilter();
		}

		private void ConnectionListBoxItemUnChecked(object sender, RoutedEventArgs e)
		{
			UpdateConnectionFilter();
		}

		private void OpenNetworkProfileBtn_Click(object sender, System.Windows.RoutedEventArgs e)
		{
			// Create a file open dialog for selecting the .nprof file.
			OpenFileDialog OpenDialog = new OpenFileDialog();
			OpenDialog.Title = "Open the profile data file from the game's 'Profiling' folder";
			OpenDialog.Filter = "Profiling Data (*.nprof)|*.nprof";
			OpenDialog.RestoreDirectory = false;			
			
			// Parse it if user didn't cancel.
			if (OpenDialog.ShowDialog() == true)
			{
				// Create binary reader and file info object from filename.
				ChangeNetworkStream(OpenDialog.FileName);
			}
		}

		public void SetCurrentStreamSelection(NetworkStream NetworkStream, PartialNetworkStream Selection, bool bSingleSelect)
		{
			if (Dispatcher.CheckAccess() == false)
			{
				Dispatcher.Invoke(new Action(() => SetCurrentStreamSelection(NetworkStream, Selection, bSingleSelect)));
				return;
			}

			ActorPerfPropsDetailsListView.Items.Clear();

			Selection.ToActorSummaryView(NetworkStream, ActorSummaryView);
			Selection.ToActorPerformanceView(NetworkStream, ActorPerfPropsListView, ActorPerfPropsDetailsListView, CurrentFilterValues);

			// Below is way too slow for range select right now, so we just do this for single frame selection
			if (bSingleSelect)
			{
				Selection.ToDetailedTreeView(TokenDetailsView.Items, CurrentFilterValues);
			}

			CurrentStreamSelection = Selection;
		}

		public int GetMaxProfileMinutes()
		{
			return MaxProfileMinutes;
		}

		public static void WriteToConsole(string Msg)
		{
			Console.WriteLine(Msg);
		}

		private void ReloadChartWorker()
		{
			ChartParser.ParseStreamIntoChart(this, CurrentNetworkStream, NetworkChart, CurrentFilterValues);
			CancelSelectRangeThread();
			SelectRangeThread = new Thread(() => SelectRangeWorker(0, CurrentNetworkStream.Frames.Count));
			SelectRangeThread.Start();
			LoadThread = null;
		}
		private void ResetFiltersButton_Click(object sender, System.Windows.RoutedEventArgs e)
		{
			CurrentFilterValues.ActorFilter = "";
			CurrentFilterValues.PropertyFilter = "";
			CurrentFilterValues.RPCFilter = "";

			ActorFilterBox.Text = PropertyFilterBox.Text = RPCFilterBox.Text = null;
		}

		private void ApplyFiltersButton_Click(object sender, System.Windows.RoutedEventArgs e)
		{
			CurrentFilterValues.ActorFilter = ActorFilterBox.Text != null ? ActorFilterBox.Text : "";
			CurrentFilterValues.PropertyFilter = PropertyFilterBox.Text != null ? PropertyFilterBox.Text : "";
			CurrentFilterValues.RPCFilter = RPCFilterBox.Text != null ? RPCFilterBox.Text : "";

			UpdateConnectionFilter();

			CancelLoadThread();

			LoadThread = new Thread(() => ReloadChartWorker());
			LoadThread.Start();
		}

		private void SelectRangeWorker(int SelectionStart, int SelectionEnd)
		{
			// Create a partial network stream with the new selection to get the summary.
			PartialNetworkStream Selection = new PartialNetworkStream(
													this,
													CurrentNetworkStream.Frames,
													SelectionStart,
													SelectionEnd,
													CurrentNetworkStream.NameIndexUnreal,
													CurrentFilterValues,
													1 / 30.0f
												);

			SetCurrentStreamSelection(CurrentNetworkStream, Selection, false);
			SelectRangeThread = null;
		}

		private void CancelSelectRangeThread()
		{
			if (SelectRangeThread != null)
			{
				SelectRangeThread.Abort();
				SelectRangeThread = null;
			}
		}

		private void UpdateConnectionFilter()
		{
			CurrentFilterValues.ConnectionMask = new HashSet<int>();

			for (int i = 0; i < ConnectionListBox.Items.Count; i++)
			{
				if (((CheckBox)ConnectionListBox.Items[i]).IsChecked == true)
				{
					CurrentFilterValues.ConnectionMask.Add(i);
				}
			}
		}

		private void PlotStyleSelector_SelectionChanged(object sender, SelectionChangedEventArgs e)
		{
			NetworkChart.Plot.Style((ScottPlot.Style)PlotStyleSelector.SelectedIndex);
			NetworkChart.Render();
		}

		private void CheckAllConnectionsCheckBox_Checked(object sender, RoutedEventArgs e)
		{
			CheckAllConnectionsCheckBoxToggle(true);
		}

		private void CheckAllConnectionsCheckBox_Unchecked(object sender, RoutedEventArgs e)
		{
			CheckAllConnectionsCheckBoxToggle(false);
		}

		private void CheckAllConnectionsCheckBoxToggle(bool bCheck)
		{
			if (ConnectionListBox != null)
			{
				for (int i = 0; i < ConnectionListBox.Items.Count; i++)
				{
					((CheckBox)ConnectionListBox.Items[i]).IsChecked = bCheck;
				}
			}
		}

		private void ChartShowLegendCheckBox_Checked(object sender, RoutedEventArgs e)
		{
			NetworkChart.Plot.Legend(true, ScottPlot.Alignment.UpperLeft);
			NetworkChart.Render();
		}

		private void ChartShowLegendCheckBox_Unchecked(object sender, RoutedEventArgs e)
		{
			NetworkChart.Plot.Legend(false);
			NetworkChart.Render();
		}

		private void ActorPerfPropsListView_SelectionChanged(object sender, SelectionChangedEventArgs e)
		{
			ActorPerfPropsDetailsListView.Items.Clear();

			if (LoadThread != null || SelectRangeThread != null || CurrentStreamSelection == null || ActorPerfPropsListView.SelectedItems.Count == 0)
			{
				return;
			}

			NetworkListViewItem networkListViewItem = (NetworkListViewItem)ActorPerfPropsListView.SelectedItems[0];
			CurrentStreamSelection.ToPropertyPerformanceView(CurrentNetworkStream, networkListViewItem.Header1, ActorPerfPropsDetailsListView, CurrentFilterValues);
		}

		private void MaxProfileMinutesTextBox_TextChanged(object sender, TextChangedEventArgs e)
		{
			if (MaxProfileMinutesTextBox.Text == "")
			{
				MaxProfileMinutes = 0;
			}
			else try
			{
				MaxProfileMinutes = int.Parse(MaxProfileMinutesTextBox.Text);
			}
			catch
			{
				MaxProfileMinutes = 0;
				MaxProfileMinutesTextBox.Text = "";
			}
		}

		private void UnrealNetworkProfilerMainWindow_Closing(object sender, System.ComponentModel.CancelEventArgs e)
		{
			GameAnalytics.EndSession();
		}
		private void AboutBtn_Click(object sender, RoutedEventArgs e)
		{
			GameAnalytics.AddDesignEvent("AboutDialogOpen");
			aboutDialog = Dialog.Show(new AboutDialog(this));
		}

		public void CloseAboutDialog()
		{
			GameAnalytics.AddDesignEvent("AboutDialogClose");
			aboutDialog.Close();
		}
	}

	public class FilterValues
	{
		public string ActorFilter = "";
		public string PropertyFilter = "";
		public string RPCFilter = "";

		public HashSet<int> ConnectionMask = null;
	}

	public class SeriesTypeValues
	{
		SeriesType Type;
		List<double> ValuesX = new List<double>();
		List<double> ValuesY = new List<double>();
		public bool bVisible = false;

		public SeriesTypeValues(SeriesType InType, double X, double Y, bool bInVisible)
		{
			Type = InType;
			ValuesX.Add(X);
			ValuesY.Add(Y);
			bVisible = bInVisible;
		}

		public void Add(double X, double Y)
		{
			ValuesX.Add(X);
			ValuesY.Add(Y);
		}

		public void Reset()
		{
			ValuesX.Clear();
			ValuesY.Clear();
		}

		public double[] GetArrayX()
		{
			if (ValuesX.Count == 0)
			{
				ValuesX.Add(0);
			}
			
			return ValuesX.ToArray();
		}

		public double[] GetArrayY()
		{
			if (ValuesY.Count == 0)
			{
				ValuesY.Add(0);
			}

			return ValuesY.ToArray();
		}

		public override string ToString()
		{
			return Type.ToString();
		}
	}
}

```

`UE4 Network Profiler/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Resources;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Windows;

// General Information about an assembly is controlled through the following
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Unreal Engine Network Profiler")]
[assembly: AssemblyDescription("WPF rewrite of WinForm based Network Profiler by Epic Games.")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Satheesh (ryanjon2040)")]
[assembly: AssemblyProduct("UE4 Network Profiler")]
[assembly: AssemblyCopyright("Copyright ©  2021")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

//In order to begin building localizable applications, set
//<UICulture>CultureYouAreCodingWith</UICulture> in your .csproj file
//inside a <PropertyGroup>.  For example, if you are using US english
//in your source files, set the <UICulture> to en-US.  Then uncomment
//the NeutralResourceLanguage attribute below.  Update the "en-US" in
//the line below to match the UICulture setting in the project file.

//[assembly: NeutralResourcesLanguage("en-US", UltimateResourceFallbackLocation.Satellite)]


[assembly: ThemeInfo(
	ResourceDictionaryLocation.None, //where theme specific resource dictionaries are located
									 //(used if a resource is not found in the page,
									 // or application resource dictionaries)
	ResourceDictionaryLocation.SourceAssembly //where the generic resource dictionary is located
											  //(used if a resource is not found in the page,
											  // app, or any theme specific resource dictionaries)
)]


// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.1.0.0")]
[assembly: AssemblyFileVersion("1.1.0.0")]

```

`UE4 Network Profiler/Properties/Resources.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace UE4_Network_Profiler.Properties {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("UE4_Network_Profiler.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
    }
}

```

`UE4 Network Profiler/Properties/Resources.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`UE4 Network Profiler/Properties/Settings.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace UE4_Network_Profiler.Properties {
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "16.8.1.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        
        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
        
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
    }
}

```

`UE4 Network Profiler/Properties/Settings.settings`:

```settings
<?xml version='1.0' encoding='utf-8'?>
<SettingsFile xmlns="uri:settings" CurrentProfile="(Default)">
  <Profiles>
    <Profile Name="(Default)" />
  </Profiles>
  <Settings />
</SettingsFile>
```

`UE4 Network Profiler/UE4 Network Profiler.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{1466DE04-14E6-482D-9285-C6359C79EB19}</ProjectGuid>
    <OutputType>WinExe</OutputType>
    <RootNamespace>UE4_Network_Profiler</RootNamespace>
    <AssemblyName>UE4 Network Profiler</AssemblyName>
    <TargetFrameworkVersion>v4.7.2</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <ProjectTypeGuids>{60dc8134-eba5-43b8-bcc9-bb4bc16c2548};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>
    <WarningLevel>4</WarningLevel>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
    <Deterministic>true</Deterministic>
    <TargetFrameworkProfile />
    <NuGetPackageImportStamp>
    </NuGetPackageImportStamp>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="GameAnalytics.Mono, Version=1.0.7702.25490, Culture=neutral, processorArchitecture=MSIL">
      <HintPath>..\packages\GameAnalytics.Mono.SDK.3.1.2\lib\net45\GameAnalytics.Mono.dll</HintPath>
    </Reference>
    <Reference Include="HandyControl, Version=3.0.0.0, Culture=neutral, processorArchitecture=MSIL">
      <HintPath>..\packages\HandyControl.3.0.0\lib\net47\HandyControl.dll</HintPath>
    </Reference>
    <Reference Include="NLog, Version=4.0.0.0, Culture=neutral, PublicKeyToken=5120e14c03d0593c, processorArchitecture=MSIL">
      <HintPath>..\packages\NLog.4.3.8\lib\net45\NLog.dll</HintPath>
    </Reference>
    <Reference Include="ScottPlot, Version=4.1.9.0, Culture=neutral, PublicKeyToken=86698dc10387c39e, processorArchitecture=MSIL">
      <HintPath>..\packages\ScottPlot.4.1.9-beta\lib\net461\ScottPlot.dll</HintPath>
    </Reference>
    <Reference Include="ScottPlot.WPF, Version=4.1.9.0, Culture=neutral, PublicKeyToken=e53b06131e34a3aa, processorArchitecture=MSIL">
      <HintPath>..\packages\ScottPlot.WPF.4.1.9-beta\lib\net472\ScottPlot.WPF.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Data" />
    <Reference Include="System.Data.SQLite, Version=1.0.102.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139, processorArchitecture=MSIL">
      <HintPath>..\packages\GameAnalytics.Mono.SDK.3.1.2\lib\net45\System.Data.SQLite.dll</HintPath>
    </Reference>
    <Reference Include="System.Drawing" />
    <Reference Include="System.Drawing.Common, Version=4.0.0.1, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Drawing.Common.6.0.0-preview.1.21102.12\lib\net461\System.Drawing.Common.dll</HintPath>
    </Reference>
    <Reference Include="System.Runtime.InteropServices.RuntimeInformation, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Runtime.InteropServices.RuntimeInformation.4.3.0\lib\net45\System.Runtime.InteropServices.RuntimeInformation.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.ValueTuple, Version=4.0.3.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>..\packages\System.ValueTuple.4.5.0\lib\net47\System.ValueTuple.dll</HintPath>
    </Reference>
    <Reference Include="System.Xml" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Xaml">
      <RequiredTargetFramework>4.0</RequiredTargetFramework>
    </Reference>
    <Reference Include="WindowsBase" />
    <Reference Include="PresentationCore" />
    <Reference Include="PresentationFramework" />
  </ItemGroup>
  <ItemGroup>
    <ApplicationDefinition Include="App.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </ApplicationDefinition>
    <Compile Include="UserControls\AboutDialog.xaml.cs">
      <DependentUpon>AboutDialog.xaml</DependentUpon>
    </Compile>
    <Page Include="MainWindow.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </Page>
    <Compile Include="App.xaml.cs">
      <DependentUpon>App.xaml</DependentUpon>
      <SubType>Code</SubType>
    </Compile>
    <Compile Include="Classes\BinaryReaderBigEndian.cs" />
    <Compile Include="Classes\ChartParser.cs" />
    <Compile Include="Classes\NetworkStream.cs" />
    <Compile Include="Classes\PartialNetworkStream.cs" />
    <Compile Include="Classes\StreamHeader.cs" />
    <Compile Include="Classes\StreamParser.cs" />
    <Compile Include="Classes\Tokens.cs" />
    <Compile Include="MainWindow.xaml.cs">
      <DependentUpon>MainWindow.xaml</DependentUpon>
      <SubType>Code</SubType>
    </Compile>
    <Page Include="UserControls\AboutDialog.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Properties\AssemblyInfo.cs">
      <SubType>Code</SubType>
    </Compile>
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DesignTime>True</DesignTime>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
    <Compile Include="Properties\Settings.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Settings.settings</DependentUpon>
      <DesignTimeSharedInput>True</DesignTimeSharedInput>
    </Compile>
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
    </EmbeddedResource>
    <None Include="packages.config" />
    <None Include="Properties\Settings.settings">
      <Generator>SettingsSingleFileGenerator</Generator>
      <LastGenOutput>Settings.Designer.cs</LastGenOutput>
    </None>
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <Import Project="..\packages\GameAnalytics.Mono.SDK.3.1.2\build\net45\GameAnalytics.Mono.SDK.targets" Condition="Exists('..\packages\GameAnalytics.Mono.SDK.3.1.2\build\net45\GameAnalytics.Mono.SDK.targets')" />
  <Target Name="EnsureNuGetPackageBuildImports" BeforeTargets="PrepareForBuild">
    <PropertyGroup>
      <ErrorText>This project references NuGet package(s) that are missing on this computer. Use NuGet Package Restore to download them.  For more information, see http://go.microsoft.com/fwlink/?LinkID=322105. The missing file is {0}.</ErrorText>
    </PropertyGroup>
    <Error Condition="!Exists('..\packages\GameAnalytics.Mono.SDK.3.1.2\build\net45\GameAnalytics.Mono.SDK.targets')" Text="$([System.String]::Format('$(ErrorText)', '..\packages\GameAnalytics.Mono.SDK.3.1.2\build\net45\GameAnalytics.Mono.SDK.targets'))" />
  </Target>
</Project>
```

`UE4 Network Profiler/UserControls/AboutDialog.xaml`:

```xaml
<UserControl x:Class="UE4_Network_Profiler.UserControls.AboutDialog"
			 xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
			 xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
			 xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
			 xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
			 xmlns:hc="https://handyorg.github.io/handycontrol"
			 mc:Ignorable="d" 
			 Background="{DynamicResource RegionBrush}">
	<Grid>
		<TextBlock Margin="10 10 40 10" Style="{StaticResource TextBlockDefaultInfo}" Text="Based on the original WinForm based Network Profiler by Epic Games.&#xA;&#xA;Re-written in WPF by Satheesh (ryanjon2040)."/>
		<Button x:Name="CloseBtn" Content="Close" HorizontalAlignment="Right" VerticalAlignment="Top" Margin="0,10,10,0" Style="{StaticResource ButtonIcon}" Foreground="{DynamicResource PrimaryBrush}" hc:IconElement.Geometry="{StaticResource ErrorGeometry}" Padding="0" Width="22" Height="22" Click="CloseBtn_Click"/>
	</Grid>
</UserControl>

```

`UE4 Network Profiler/UserControls/AboutDialog.xaml.cs`:

```cs
using NetworkProfiler;
using System.Windows;
using System.Windows.Controls;

namespace UE4_Network_Profiler.UserControls
{
	public partial class AboutDialog : UserControl
	{
		private MainWindow _mainWindow;

		public AboutDialog(MainWindow InMainWindow)
		{
			InitializeComponent();
			_mainWindow = InMainWindow;
		}

		private void CloseBtn_Click(object sender, RoutedEventArgs e)
		{
			_mainWindow.CloseAboutDialog();
		}
	}
}

```

`UE4 Network Profiler/packages.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<packages>
  <package id="GameAnalytics.Mono.SDK" version="3.1.2" targetFramework="net472" />
  <package id="HandyControl" version="3.0.0" targetFramework="net472" />
  <package id="NLog" version="4.3.8" targetFramework="net472" />
  <package id="ScottPlot" version="4.1.9-beta" targetFramework="net472" />
  <package id="ScottPlot.WPF" version="4.1.9-beta" targetFramework="net472" />
  <package id="System.Drawing.Common" version="6.0.0-preview.1.21102.12" targetFramework="net472" />
  <package id="System.Runtime.InteropServices.RuntimeInformation" version="4.3.0" targetFramework="net472" />
  <package id="System.ValueTuple" version="4.5.0" targetFramework="net472" />
</packages>
```