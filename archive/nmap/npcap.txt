Project Path: arc_nmap_npcap_rnxfp_ub

Source Tree:

```txt
arc_nmap_npcap_rnxfp_ub
├── CHANGELOG.md
├── Common
│   ├── Packet32.h
│   ├── WpcapNames.h
│   ├── npcap-bpf.h
│   └── npcap-defs.h
├── Examples
│   ├── MakeAll.sln
│   ├── NETMETER
│   │   ├── CapDll.h
│   │   ├── CaptureThread.cpp
│   │   ├── Console.h
│   │   ├── LineColl.cpp
│   │   ├── LineColl.h
│   │   ├── MainFrm.cpp
│   │   ├── MainFrm.h
│   │   ├── NETMETER.CPP
│   │   ├── NETMETER.H
│   │   ├── NetMeter.vcxproj
│   │   ├── NetMeter.vcxproj.filters
│   │   ├── ProgCaptDlg.h
│   │   ├── SelectAdapter.cpp
│   │   ├── SelectAdapter.h
│   │   ├── StdAfx.cpp
│   │   ├── StdAfx.h
│   │   ├── netmeter.rc
│   │   ├── netmeterDoc.cpp
│   │   ├── netmeterDoc.h
│   │   ├── netmeterView.cpp
│   │   ├── netmeterView.h
│   │   ├── res
│   │   │   ├── BMP00001.BMP
│   │   │   ├── bitmap1.bmp
│   │   │   ├── bitmap2.bmp
│   │   │   ├── cap_wizi.bmp
│   │   │   ├── listbmp.bmp
│   │   │   ├── netmeter.ico
│   │   │   ├── netmeter.rc2
│   │   │   └── netmeterDoc.ico
│   │   └── resource.h
│   ├── PacketDriver
│   │   ├── GetMacAddress
│   │   │   ├── GetMacAddress.c
│   │   │   └── GetMacAddress.vcxproj
│   │   ├── TestPacketCapture
│   │   │   ├── TestPacketCapture.c
│   │   │   └── TestPacketCapture.vcxproj
│   │   ├── TestPacketSend
│   │   │   ├── TestPacketSend.c
│   │   │   └── TestPacketSend.vcxproj
│   │   └── readme.txt
│   ├── UDPdump
│   │   ├── UDPdump.vcxproj
│   │   └── udpdump.c
│   ├── UserLevelBridge
│   │   ├── UserBridge.c
│   │   └── UserBridge.vcxproj
│   ├── iflist
│   │   ├── iflist.c
│   │   ├── iflist.vcxproj
│   │   └── iflist.vcxproj.filters
│   ├── misc
│   │   ├── basic_dump.c
│   │   ├── basic_dump.vcxproj
│   │   ├── basic_dump_ex.c
│   │   ├── basic_dump_ex.vcxproj
│   │   ├── misc.h
│   │   ├── readfile.c
│   │   ├── readfile.vcxproj
│   │   ├── readfile_ex.c
│   │   ├── readfile_ex.vcxproj
│   │   ├── savedump.c
│   │   ├── savedump.vcxproj
│   │   ├── sendpack.c
│   │   └── sendpack.vcxproj
│   ├── pcap_filter
│   │   ├── pcap_filter.c
│   │   └── pcap_filter.vcxproj
│   ├── pcap_fopen
│   │   ├── pcap_fopen.cpp
│   │   └── pcap_fopen.vcxproj
│   ├── pktdump_ex
│   │   ├── pktdump_ex.c
│   │   └── pktdump_ex.vcxproj
│   ├── sendcap
│   │   ├── sendcap.c
│   │   ├── sendcap.vcxproj
│   │   └── sendcap.vcxproj.filters
│   ├── smp_1
│   │   ├── smp_1.c
│   │   └── smp_1.vcxproj
│   └── tcptop
│       ├── tcptop.c
│       └── tcptop.vcxproj
├── Examples-pcap
│   ├── GNUmakefile
│   ├── MakeAll.sln
│   ├── UDPdump
│   │   ├── GNUmakefile
│   │   ├── UDPdump.vcxproj
│   │   └── udpdump.c
│   ├── basic_dump
│   │   ├── GNUmakefile
│   │   ├── basic_dump.c
│   │   └── basic_dump.vcxproj
│   ├── basic_dump_ex
│   │   ├── GNUmakefile
│   │   ├── basic_dump_ex.c
│   │   └── basic_dump_ex.vcxproj
│   ├── iflist
│   │   ├── GNUmakefile
│   │   ├── iflist.c
│   │   └── iflist.vcxproj
│   ├── pcap_filter
│   │   ├── GNUmakefile
│   │   ├── Makefile.unix
│   │   ├── pcap_filter.c
│   │   └── pcap_filter.vcxproj
│   ├── pktdump_ex
│   │   ├── GNUmakefile
│   │   ├── pktdump_ex.c
│   │   └── pktdump_ex.vcxproj
│   ├── readfile
│   │   ├── GNUmakefile
│   │   ├── readfile.c
│   │   └── readfile.vcxproj
│   ├── readfile_ex
│   │   ├── GNUmakefile
│   │   ├── readfile_ex.c
│   │   └── readfile_ex.vcxproj
│   ├── savedump
│   │   ├── GNUmakefile
│   │   ├── savedump.c
│   │   └── savedump.vcxproj
│   ├── sendpack
│   │   ├── GNUmakefile
│   │   ├── sendpack.c
│   │   └── sendpack.vcxproj
│   ├── stats
│   │   ├── stats.c
│   │   └── stats.vcxproj
│   └── winpcap_stress
│       ├── winpcap_stress.c
│       └── winpcap_stress.vcxproj
├── LICENSE
├── Npcap_Guide.html
├── README.md
├── SDK_CHANGELOG.md
├── appveyor.yml
├── build_sdk.bat
├── build_sdk.txt
├── build_test.bat
├── create_docs.bat
├── create_docs.make
├── create_examples.bat
├── create_include.bat
├── create_lib.bat
├── docs
│   ├── Npcap-Third-Party-Open-Source.fodt
│   ├── Npcap-Third-Party-Open-Source.pdf
│   ├── README
│   ├── index.html
│   ├── npcap-api.xml
│   ├── npcap-devguide.xml
│   ├── npcap-guide-wrapper.html
│   ├── npcap-guide-wrapper.xml
│   ├── npcap-guide.xml
│   ├── npcap-internals.xml
│   ├── npcap-intro.xml
│   └── npcap-tutorial.xml
├── installer
│   ├── Build.bat
│   ├── CheckManifest.ps1
│   ├── CheckStatus.bat
│   ├── DiagReport.bat
│   ├── DiagReport.ps1
│   ├── FixInstall.bat
│   └── manifest.txt
├── packetWin7
│   ├── Dll
│   │   ├── AdInfo.cpp
│   │   ├── Packet.def
│   │   ├── Packet32-Int.h
│   │   ├── Packet32.cpp
│   │   ├── Project
│   │   │   ├── Packet.sln
│   │   │   ├── Packet.vcxproj
│   │   │   └── Packet.vcxproj.filters
│   │   ├── debug.h
│   │   ├── version.rc
│   │   └── version.rc2
│   ├── DriverQuery
│   │   ├── DriverQuery.c
│   │   ├── DriverQuery.rc
│   │   ├── DriverQuery.vcxproj
│   │   ├── DriverQuery.vcxproj.filters
│   │   ├── resource.h
│   │   └── version.rc2
│   ├── Helper
│   │   ├── NpcapHelper
│   │   │   ├── NpcapHelper.cpp
│   │   │   ├── NpcapHelper.exe.manifest.in
│   │   │   ├── NpcapHelper.vcxproj
│   │   │   ├── NpcapHelper.vcxproj.filters
│   │   │   ├── resource.h
│   │   │   ├── version.rc
│   │   │   └── version.rc2
│   │   ├── NpcapHelper.sln
│   │   ├── NpcapHelperTest
│   │   │   ├── NpcapHelperTest.c
│   │   │   ├── NpcapHelperTest.vcxproj
│   │   │   └── NpcapHelperTest.vcxproj.filters
│   │   └── debug.h
│   ├── NPFInstall
│   │   ├── NPFInstall
│   │   │   ├── CalloutInstall.cpp
│   │   │   ├── CalloutInstall.h
│   │   │   ├── DriverStoreClear.cpp
│   │   │   ├── DriverStoreClear.h
│   │   │   ├── LoopbackInstall.cpp
│   │   │   ├── LoopbackInstall.h
│   │   │   ├── LoopbackRecord.cpp
│   │   │   ├── LoopbackRecord.h
│   │   │   ├── LoopbackRename.cpp
│   │   │   ├── LoopbackRename.h
│   │   │   ├── LoopbackRename2.cpp
│   │   │   ├── LoopbackRename2.h
│   │   │   ├── NPFInstall.cpp
│   │   │   ├── NPFInstall.exe.manifest.in
│   │   │   ├── NPFInstall.vcxproj
│   │   │   ├── NPFInstall.vcxproj.filters
│   │   │   ├── ProcessUtil.cpp
│   │   │   ├── ProcessUtil.h
│   │   │   ├── ProtInstall.cpp
│   │   │   ├── ProtInstall.h
│   │   │   ├── RegUtil.cpp
│   │   │   ├── RegUtil.h
│   │   │   ├── msg.h
│   │   │   ├── netcfgapi.cpp
│   │   │   ├── netcfgapi.h
│   │   │   ├── rc_ids.h
│   │   │   ├── version.rc
│   │   │   └── version.rc2
│   │   └── NPFInstall.sln
│   ├── WlanHelper
│   │   ├── WlanHelper
│   │   │   ├── Tool.cpp
│   │   │   ├── Tool.h
│   │   │   ├── WlanHelper.cpp
│   │   │   ├── WlanHelper.exe.manifest.in
│   │   │   ├── WlanHelper.vcxproj
│   │   │   ├── WlanHelper.vcxproj.filters
│   │   │   ├── version.rc
│   │   │   └── version.rc2
│   │   └── WlanHelper.sln
│   ├── npf
│   │   ├── npf
│   │   │   ├── Loopback.c
│   │   │   ├── Loopback.h
│   │   │   ├── Openclos.c
│   │   │   ├── Packet.c
│   │   │   ├── Packet.h
│   │   │   ├── Read.c
│   │   │   ├── Write.c
│   │   │   ├── cpp.hint
│   │   │   ├── ieee80211_radiotap.h
│   │   │   ├── ioctls.h
│   │   │   ├── macros.h
│   │   │   ├── memory_tags.h
│   │   │   ├── npcap.inf
│   │   │   ├── npcap.rc
│   │   │   ├── npcap_wfp.inf
│   │   │   ├── npf.vcxproj
│   │   │   ├── npf.vcxproj.filters
│   │   │   ├── stdafx.h
│   │   │   ├── time_calls.h
│   │   │   ├── valid_insns.h
│   │   │   ├── win_bpf.h
│   │   │   └── win_bpf_filter.c
│   │   ├── npf Package
│   │   │   └── npf Package.vcxproj
│   │   └── npf.sln
│   └── vs14
│       └── npcap.sln
├── test
│   ├── README.md
│   ├── make_test.bat
│   └── static.props
├── version.h
└── wpcap
    ├── libpcap
    └── wpcap-cmake.bat

```

`CHANGELOG.md`:

```md
## Npcap 1.87 [2026-02-04]

* Fix a bug causing various BSoD crashes in `NPF_DoTap()`. Fixes [#831](https://issues.npcap.org/831).

## Npcap 1.86 [2026-01-07]

* Updated libpcap to 1.10.6. For a summary of the last 18 years of libpcap
  features that have been added since the libpcap 1.0.0 release that WinPcap is
  stuck on, check out the [What's New page on npcap.com](https://npcap.com/whats-new).

* Fix a BSoD crash (`DRIVER_IRQL_NOT_LESS_OR_EQUAL`) in `bpf_filter()` caused
  by the filter program being freed and overwritten while a packet is being
  processed. Fixes [#819](http://issues.npcap.org/819).

* Fix issues with placement/deletion of Uninstall.exe and DriverQuery.exe.
  Fixes [#821](http://issues.npcap.org/821).

* Fix a deadlock in Packet.dll preventing applications from starting when Npcap
  is installed in `/admin_only` mode. Npcap 1.84 and 1.85 were affected.
  Fixes [#813](http://issues.npcap.org/813).

* Fix a BSoD crash (`KMODE_EXCEPTION_NOT_HANDLED`) when capturing injected
  packets. Fixes [#815](http://issues.npcap.org/815).

* Fix an incompatibility that prevented Npcap 1.81 through 1.85 from being able
  to capture when installed with the `/prior_driver=yes` option on versions of
  Windows before Windows 10. This issue does not affect any version of Windows
  that is supported by Microsoft. Fixes [#822](http://issues.npcap.org/822).

## Npcap 1.85 [2025-11-18]

* Fix a BSoD crash in `bpf_filter()` caused by reading 1 byte past the end of a
  data buffer. Npcap 1.81 through 1.84 are affected. Fixes [#820](http://issues.npcap.org/820).

* Fix an intermittent issue where upgrading Npcap would fail due to a failure
  to remove the previous version's Uninstall.exe. Fixes [#811](http://issues.npcap.org/811).

## Npcap 1.84 [2025-10-02]

* Fixed a regression in #742 (previously fixed in Npcap 1.80). The fix changes
  to libpcap had been overwritten in our local branch, causing the same
  Application Verifier faults to recur.

* Resolve an issue in the installer/uninstaller where x64-emulated processes on
  ARM64 (and possibly 32-bit processes on both x64 and ARM64) that were using
  Npcap were not correctly terminated, leading to failed installations.

* New DriverQuery.exe diagnostic tool. This will be run as part of
  [DiagReport](https://npcap.com/guide/npcap-users-guide.html#npcap-issues-diagreport)
  on new installations, but can be run independently on older installations for
  better diagnosis of connection issues.

* Added performance metrics for time spent processing packets. These can be
  queried with the DriverQuery diagnostic tool or via `PacketGetInfo()` using
  the `NPF_GETINFO_STATS` query ID.

* Added additional checks to ensure data structures allocated when injecting
  packets are freed. No leaks were reported, but it is possible some packets
  could have been leaked when using the SendToRx feature.

* An experimental feature, adaptive buffer sizing, can be enabled in Packet.dll
  by setting the `PACKET_EXPERIMENTAL_OPTIMIZATION` environment variable.
  See ([#622](http://issues.npcap.org/622)).

## Npcap 1.83 [2025-08-01]

* \[SECURITY\] Rebuilt the Windows self-installer with NSIS 3.11, addressing
  CVE-2025-43715--a race condition in earlier NSIS versions that could allow
  local attackers to escalate to SYSTEM privileges when a vulnerable installer
  is run as SYSTEM. The Npcap installer does not run as SYSTEM by default.

* Added a check for malformed OID request objects. This should prevent the BSoD
  crashes that have been reported when setting up a PPPoE connection ([#296](http://issues.npcap.org/296)).

* Fixed an issue with SendToRx mode that resulted in packet injection calls
  hanging. Fixes [#785](http://issues.npcap.org/785).

* SendToRx mode, which causes injected packets to be indicated as receives
  instead of sends, can now be enabled per capture handle using the
  `pcap_setmode(handle, PACKET_MODE_SENDTORX)`. Since this feature was
  previously enabled globally via the Registry, user code can now opt out of it
  with `pcap_setmode(handle, PACKET_MODE_SENDTORX_CLEAR)`.

* The Npcap driver now can deliver packet timestamps using nanosecond
  precision. This feature will be made available via the portable libpcap API
  in the next Npcap SDK.

## Npcap 1.82 [2025-04-21]

* Fixed an issue where Npcap 1.81 would incorrectly reject packets as too large
  which had VLAN headers and would be equal to the maximum frame size when the
  header was removed. Fixes [#790](http://issues.npcap.org/790).

* Fixed an issue where captured frames with an 802.1q VLAN header would have
  the high-order bit of the 802.1p priority always set to `0`, so a priority of
  5 would be shown as 1, for instance. Fixes [#783](http://issues.npcap.org/783).

* Fixed an issue where packets with VLAN tags having a TCI of 0 would not have
  a VLAN tag when captured. Fixes [#791](http://issues.npcap.org/791).

## Npcap 1.81 [2025-02-20]

* Added complete capture support for 802.1q VLAN packets. The 802.1q frame tag
  is usually stripped by NDIS before Npcap encounters it, but Npcap will now
  restore it from the packet metadata if the VLAN ID is not 0. Filtering with the
  "vlan" keyword is also now supported on live captures. The deprecated
  `/vlan_support` installer option has no impact on this feature. Fixes [#171](http://issues.npcap.org/171).

* Added support for sending 802.1q VLAN packets. Ethernet frames passed to `pcap_sendpacket()` or
  `pcap_inject()` with 802.1q VLAN tags will have those tags converted to NDIS metadata, and the
  NDIS stack will process them appropriately. The adapter must be configured to allow traffic on the
  target VLAN.

* Significantly streamlined packet sending operations, especially for `pcap_sendqueue()`, removing
  unnecessary copying of packet data. Fixes [#555](http://issues.npcap.org/555).

* Fixed an issue with the installer where the appropriate code-signing certificates for the
  `/prior_driver=yes` option were not installed on Windows 7, 8, and 8.1. This could lead to failed
  installations on those versions of Windows.

* Fixed a layout issue in the installer that prevented the full warning from
  being displayed when a Win10Pcap installation is detected. Win10Pcap hasn’t been actively
  maintained since 2015, and we recommend uninstalling it before installing Npcap.

* Npcap now supports the `BPF_MOD` and `BPF_XOR` instructions. Previously, pcap
  filter expressions using the `%` and `^` operators would result in
  less-efficient user-mode filtering.

* The Npcap driver now supports a range of NDIS versions depending on what is
  available at runtime. This will allow us to support newer features like URO
  and hardware timestamping when available, without needing to have separate
  builds for each NDIS version at install time.

## Npcap 1.80 [2024-09-16]

* On ARM64, Npcap now installs ARM64X pure-forwarder DLLs so that Npcap can be used by x86_64
  processes running under emulation as well as x86 and ARM64 processes. Programmers do not need to
  make any special changes to take advantage of this feature. Fixes [#585](http://issues.npcap.org/585).

* Npcap now supports packet capture on SR-IOV virtual function adapters directly. Some
  manufacturers, such as Intel, were already supported because they use a separate miniport driver
  on top of the virtual function driver. Others that use a virtual function only, such as Broadcom,
  are now supported. Fixes [#34](http://issues.npcap.org/34).

* Due to Microsoft's deprecation of software publisher certificates with kernel-mode signing
  capability, installations of Npcap on Windows 7, 8, and 8.1 will use the Npcap 1.79 driver by
  default. The Npcap 1.80 driver can be chosen in the GUI and via the `/latest_driver=yes`
  command-line option if driver signing is disabled in Windows. See [#751](http://issues.npcap.org/751).

* Addressed faults found with Application Verifier: `WSACleanup()` was not being called in some
  cases, and in other cases was called from the `DllMain()` function of `wpcap.dll`, which Microsoft
  warns may cause deadlocks. Fixes [#742](http://issues.npcap.org/742).

* Fixed a BSoD crash due to a race condition between `NPF_DetachAdapter` and
  `NPF_Cleanup` when closing a capture handle. Fixes [#746](http://issues.npcap.org/746).

* Upgraded build system to Visual Studio 2022. This version prevents building drivers for earlier
  Windows versions, so the npcap.sys driver for Windows 7 through 8.1 is still built on Visual
  Studio 2019. See [#629](http://issues.npcap.org/629).

## Npcap 1.79 [2024-01-19]

* Fixed a condition where disabling and re-enabling a network adapter while a
  capture is active would prevent any packets from being received by the system
  until the capture handle was closed. Fixes [#710](http://issues.npcap.org/710).

* Introduced a workaround for a previously-unknown bug in Microsoft's bthpan.sys that was
  causing BSoD crashes with `INVALID_MDL_RANGE` when Npcap or other drivers sent packets over
  a Bluetooth-tethered connection. Microsoft intends to patch this Windows bug, but Npcap will
  no longer trigger it regardless of patch status. Fixes [#708](http://issues.npcap.org/708).

## Npcap 1.78 [2023-10-18]

* Fixed a memory leak in Npcap 1.77 which occurs when the kernel buffer is
  full. Fixes [#701](http://issues.npcap.org/701).

* Correctly handle an allocation failure during out-of-memory condition,
  avoiding a null pointer dereference. Fixes [#698](http://issues.npcap.org/698).

## Npcap 1.77 [2023-09-29]

* Fixed a memory leak in Npcap 1.76 only which occurs while capturing traffic
  at high data rates. Fixes [#688](http://issues.npcap.org/688).

* Fixed an issue in Npcap 1.76 where packets delivered to the driver by NDIS in
  a single indication, having the same timestamp, would be placed in the packet
  queue in reverse order. Fixes [#684](http://issues.npcap.org/684).

* Fixed an issue with Npcap 1.75 and 1.76 where changing timestamp modes could
  result in all packets being delivered with the same timestamp. Fixes [#695](http://issues.npcap.org/695).

* Fixed an issue with the Npcap installer that caused it to install duplicate
  certificates in the system's certificate store, which caused problems for
  some software. The fixed installer will remove the duplicates. Fixes [#692](http://issues.npcap.org/692).

## Npcap 1.76 [2023-07-19]

* Our code signing key has been reissued to "Nmap Software LLC" replacing the
  old "Insecure.Com LLC" subject name.

* Improve performance of the driver by reducing lock contention and
  consolidating data copy operations. This may help address
  [#663](http://issues.npcap.org/663).

* Additional fixes to locking discipline to potentially address a BSoD issue, [#679](http://issues.npcap.org/679).

## Npcap 1.75 [2023-04-27]

* Fix a critical regression in Npcap 1.74 which caused all captured packets to
  have the same timestamp. Fixes [#668](http://issues.npcap.org/668).

## Npcap 1.74 [2023-04-19]

* Updated libpcap to 1.10.4.

* Fixed an issue ([#667](http://issues.npcap.org/667)) that prevented capture
  handles from receiving packets after a NDIS stack pause operation.

* Fixed an issue that could cause inaccurate timestamps when multiple handles
  were open and using different timestamp modes. Fixes [#666](http://issues.npcap.org/666).

* Fixed an issue preventing raw WiFi frame capture since Npcap 1.60.

* Fixed an issue causing "failed to set hardware filter to promiscuous mode"
  errors with NetAdapterCx-based Windows 11 miniport drivers. Npcap was
  interpreting the NDIS spec too strictly; we have [opened an issue with Microsoft](https://github.com/microsoft/Network-Adapter-Class-Extension/issues/14)
  to address the fault in netadaptercx.sys. Fixes [#628](http://issues.npcap.org/628).

* Addressed several code readability and portability fixes in Packet.dll
  discovered using clang-tidy via Visual Studio Code Analysis.

## Npcap 1.73 [2023-03-28]

* Fixed an issue causing "failed to set hardware filter to promiscuous mode"
  errors due to a new code path failing to return appropriate error codes. Fix
  by Guy Harris in [PR #656](https://github.com/nmap/npcap/pull/656).
  Fixes [#628](http://issues.npcap.org/628).

* Fixed an issue with WlanHelper causing "error 0x7b" since Npcap 1.70.Fix by
  Hauke Neitzel in [PR #652](https://github.com/nmap/npcap/pull/652).
  Fixes [#649](http://issues.npcap.org/649).

* Fixed an issue preventing capture handles from reattaching after NDIS stack
  pause operations, resulting in persistent `ERROR_DEVICE_REMOVED` (1617)
  errors. Fixes [#627](http://issues.npcap.org/627).

* Restored original behavior of timestamps in the default case, 
  `PCAP_TSTAMP_HOST_HIPREC_UNSYNCED`/`TIMESTAMPMODE_SINGLE_SYNCHRONIZATION`.
  Since Npcap 0.9994, the timestamp was resynchronized after NDIS stack pause
  operations, which reduced timestamp drift from wall clock time but made it no
  longer monotonic, making packet interval calculations inaccurate. This
  restores the default behavior of WinPcap.

* Fixed an issue that prevented Npcap 1.71 and 1.72 from being completely
  removed on uninstall. A misconfigured npcap driver service had persisted.
  Fixes [#657](http://issues.npcap.org/657).

* Fixed an issue where applications using Npcap 1.20 or later DLLs with a Npcap
  1.00 driver would crash due to a stack buffer overrun when the driver returned
  too many bytes in response to a request for timestamp modes. Additionally,
  changed NPFInstall.exe to attempt to uninstall the Npcap NetCfg component
  prior to installation, in case an improperly-uninstalled component persists.

* Updated libpcap to 1.10.3.

## Npcap 1.72 [2022-12-14]

* Fixed an issue where promiscuous mode or other hardware packet filters are ignored after a second
  handle is opened on the same adapter, including handles opened in the process of listing adapters
  with `pcap_findalldevs()`. Fixes [#647](http://issues.npcap.org/647).

* Fixed an issue with validation of parameters to `PacketGetNetInfoEx()`. The `NEntries` parameter
  was not being checked for values less than or equal to 0. Fixes [#625](http://issues.npcap.org/625).
﻿
## Npcap 1.71 [2022-08-19]

* Increase strictness in checking for and restoring adapter parameters modified during capture:
  hardware packet filter and lookahead will only be modified if the original value can be
  determined. This fixes issues with connectivity on certain adapter types (WWAN and some WiFi
  adapters) after a capture is closed.

* Modify NDIS binding parameters so that Npcap will bind both above and below a NIC teaming or
  network bridge IM driver. This may improve capture options in related situations, like [#115](http://issues.npcap.org/115).

* Updated build configurations to enable DEP and ASLR for npcap.sys, which were missing from the
  original configs inherited from WinPcap. Additionally, enabled Control Flow Guard for Packet.dll
  and all helper EXEs.

* Fix a BSoD issue on Windows 8.1 due to registering a service without a name. Fixes [#565](http://issues.npcap.org/565).

* The silent-install option (/S) in [Npcap OEM](https://npcap.com/oem/) is now case-insensitive so that /s works
  as well.  All other Npcap installer options are already case-insensitive except for /D (destination directory)
  which is handled by NSIS itself. Closes [#630](http://issues.npcap.org/630).

* Fix an issue with admin-only mode where high-integrity processes (UAC not enforced) could not open
  or list adapters. Fixes [#606](http://issues.npcap.org/606).

* Restored an undocumented data member of the struct `ADAPTER` that is not used internally. Directly
  accessing members of the `ADAPTER` struct from `Packet32.h` is highly discouraged, since the
  API in `Packet32.h` is not intended for use apart from libpcap. Closes [#609](http://issues.npcap.org/609).

* Extensive refactoring of driver code for performance and maintainability.

## Npcap 1.70 [2022-06-24]

* Major overhaul of Packet.dll to improve performance of `PacketGetAdapterNames()`, used by
  `pcap_findalldevs()`, and `PacketOpenAdapter()`, used in all libpcap functions that return a
  `pcap_t`. Reduced calls to `GetAdaptersAddresses()`, properly caching results for short periods.
  Errors from lower functions are correctly propagated, making diagnosis of failures easier. Fixes
  [#168](http://issues.npcap.org/168), [#61](http://issues.npcap.org/61), and [#586](http://issues.npcap.org/586).

* PacketGetNetType() now always sets the LinkSpeed field to 0. Many adapters did not support the OID
  that was being used to get the link speed, and libpcap (Npcap's published API) does not pass this
  information through, so there should be no impact on the majority of software. Software that needs
  link speed may use `pcap_oid_get_request()` or `GetAdaptersAddresses()` to get the information.

* The undocumented `char PacketLibraryVersion[]` export has been removed. The `PacketGetVersion()`
  function is the documented way to get the runtime version of the Packet.dll library.

* Concurrently released the Npcap SDK Version 1.13 to reflect removal of PacketLibraryVersion and to
  add SAL annotations to most function prototypes and several struct fields. See SDK changelog at
  https://github.com/nmap/npcap/blob/master/SDK_CHANGELOG.md

* Packet injection operations (`pcap_inject()`, `PacketSendPacket()`, `pcap_sendqueue_transmit()`,
  and `PacketSendPackets()`) now properly pend the related Write IRP until the NBLs have
  been returned by NDIS. This may make packet injection more efficient.

* Packet injection operations are no longer limited to one at a time. Multiple threads can issue
  multiple send operations concurrently on the same capture handle without issue, unless system
  resource limits result in allocation failures. Additionally, WinPcap's limit of 256 concurrent
  sends on each adapter has been removed. Each Write call is still synchronous, however.

* Loopback packet capture and injection now uses fewer WFP filters and callbacks, avoids duplicate
  packet processing, uses inspection rather than blocking filters, and persists callout driver
  objects while still removing callout filters when captures are not using them. These and other
  improvements increase loopback capture efficiency and reduce interference with other network
  components.

* Npcap is only supported on Windows 7 SP1 and later, and requires KB4474419 to support SHA-2
  signature validation. The installer will now check these specific requirements, rather than
  attempting an installation that will fail anyway.

* Added timeouts to subprocess executions in the installer to prevent a hung installation.

* Fixed a minor issue with Npcap OEM's silent installer: Npcap 1.55 and later ought to avoid
  reinstalling the same version if the existing installation options match the requested options,
  but `/winpcap_mode=no` would never match.

* Packet sendqueue operations (`pcap_sendqueue_transmit()`, `PacketSendPackets()`)
  with time synchronization (`sync` parameter) have been improved to use timed waits when
  possible, only falling back to busy wait for inter-packet delays of less than 50
  microseconds. Time difference calculations have been revised to avoid integer overflows
  and loss of precision. Fixes [#580](http://issues.npcap.org/580).

* Packet sendqueue operations now more strictly check timestamp order. If an out-of-order
  timestamp is encountered, the packet will not be transmitted. `PacketSendPackets()` will
  set the last error value to `ERROR_INVALID_TIME`. Since packets may be
  reported slightly out-of-timestamp-order on multiprocessor machines due to
  processing delays, only timestamps that are more than 1ms earlier than the
  preceding timestamp will generate the error.

* Npcap is now built with the Win11 SDK and WDK (10.0.22000). We look forward to
  implementing support for the exciting new features of NDIS and WFP.

* Improve capture handle state transitions within the Npcap driver. Fixes BSoD
  [#601](http://issues.npcap.org/601) as well as
  [#584](http://issues.npcap.org/584), where the wrong error code was reported
  when the adapter was detached and reattached.

* Fix an issue where raw WiFi capture handles (`/dot11_support` install option) would not
  reattach after a network disconnect and reconnect. Normal handles got this ability in
  Npcap 1.60, but raw WiFi frame captures (monitor mode) did not take advantage of it.
  Fixes [#591](http://issues.npcap.org/591).

* Npcap now avoids setting hardware packet filters (`OID_GEN_CURRENT_PACKET_FILTER`,
  `PacketSetHwFilter()`) that the miniport does not declare support for. This may improve
  compatibility with WWAN (e.g. 3G and LTE) and VPN connections.

* Npcap now tracks the original lookahead value (`OID_GEN_CURRENT_LOOKAHEAD`,
  `PacketSetMaxLookahead()`) before requesting the max value from the miniport, and restores it once
  the capture handle is closed. The practice of setting the lookahead to max value was inherited
  from WinPcap, and may be changed in the future subject to performance testing.

## Npcap 1.60 [2021-12-06]

* Npcap can now tolerate network disconnections or NDIS stack
  modifications that previously resulted in programs like Wireshark
  stopping with the error "PacketReceivePacket error: The device has
  been removed. (1617)". This error may still be returned, but user
  programs can consider it a transient error.  If the network is
  reconnected, capture can resume on the same handle.  Fixes
  [#506](http://issues.npcap.org/506).

* Improved validation for IRP parameters, resolving potential BSoD
  crashes that could be triggered by software interacting directly
  with the driver's device interface. These bugs still affect the last
  releases of WinPcap. Thanks to Ilja Van Sprundel from IOActive for
  reporting them.

* Fix an issue with NX pool compatibility that caused Npcap 1.50 and
  1.55 to fail to run on some Windows 7 systems. Fixes
  [#536](http://issues.npcap.org/536).

* Fix how the installer handles `/option=enforced`, which was broken
  in Npcap 1.55. Fixes [#556](http://issues.npcap.org/556).

* Concurrently released the Npcap SDK Version 1.12, which fixes native
  ARM compilation by including the ARM64 wpcap.lib, among other
  changes.  The SDK now has its own change log at
  https://github.com/nmap/npcap/blob/master/SDK_CHANGELOG.md.

* Further driver source code hardening to catch more bugs
  before they manifest in worse ways. This includes adding more SAL
  annotations for code analysis, extra assertions, etc.

* The `/prior_driver` installer option now selects the Npcap 1.30
  driver, since Microsoft's cross-certificate expired 30 minutes
  before we signed Version 1.31. See
  [#536](http://issues.npcap.org/536).

* Simplified the code base by removing a bunch of unused or
  unneccessary code. This includes "kernel dump mode" (`MODE_DUMP`)
  which was inherited from WinPcap 3.1 even though it had already been
  deactivated there in 2005.  Also removed legacy WinPcap code which allowed
  their (long discontinued) "Pro" version DLL to install the driver
  itself. This is not allowed by modern operating systems.  We were
  able to remove a bunch of code from NPFInstall.exe too.  Updated the
  INF file to prevent npf_wifi service from being configured, since it
  was never actually used.

* Fix an issue causing `pcap_setmode()`/`PacketSetMode()` with a value
  of `MODE_CAPT` to fail. `MODE_CAPT` is the default for new handles,
  so this only affects software that uses `MODE_STAT` and then
  switches to `MODE_CAPT`, or software that expects a call to
  `pcap_setmode(MODE_CAPT)` on a handle already in `MODE_CAPT` to
  succeed. Fixes [#558](http://issues.npcap.org/558).

* When installing Npcap in WinPcap API-Compatible mode (the default),
  the Npcap installer will perform the uninstallation of WinPcap
  directly instead of running the WinPcap uninstaller. This prevents
  the WinPcap uninstaller from rebooting the system and allows us to
  clean up partial or broken installations.

* Further deprecate the "Legacy loopback support" option: The
  npcapwatchdog scheduled task will not check for the existence of the
  Npcap Loopback Adapter.

* Added the `PnpLockDown` directive to the npcap.sys INF file for
  additional Windows file protection of the driver binary.

* Replaced a feature of NPFInstall.exe and the SimpleSC.dll NSIS
  plugin with Powershell commands to improve installer size and
  compatibility.  May fix [#226](http://issues.npcap.org/226).

* While you won't see it in the code itself, we dramatically improved
  our automated build and testing proceses.  We now run automated
  native-arch builds and testing of multiple programs (particularly
  the SDK Examples) on all 3 architectures (x86, x64, and ARM). All
  tests are run with the debug build of the driver (assertions on) and
  Driver Verifier with at least standard settings, and only when that
  passes is the release build run through the same tests, also with
  Driver Verifier.  The tests are also run in x86 emulation on x64 and
  ARM.

## Npcap 1.55 [2021-09-03]

* Npcap installer can now recognize NetCfg status codes indicating that a
  reboot is required (0x0004a020, `NETCFG_S_REBOOT`), and will prompt the user
  to reboot. In silent mode, the installer will return code 3010 (0x0bc2,
  `ERROR_SUCCESS_REBOOT_REQUIRED`) to indicate this result. Fixes [#224](http://issues.npcap.org/224).

* The silent installer (only available in Nmap OEM) now offers better
  control over when to remove and reinstall an existing Npcap. You can
  specify your Npcap version number or feature requirements with the
  new `/require_version`, `/require_features`, and `/force`
  options. Software with strict requirements might re-run at startup
  to ensure that Npcap hasn't been uninstalled or changed. If Npcap
  still exists and meets your requirements, the installer quits
  immediately. These new options are documented at
  https://npcap.com/guide/npcap-users-guide.html and Nmap OEM is
  described at https://npcap.com/oem/ . Fixes
  [#523](http://issues.npcap.org/523).

* Fixed an installation failure (0xe0000247) on Windows 8.1/Server 2012 R2 and
  earlier systems which have not updated root certificates. The root certificates
  are now installed to the Roots trust store. Fixes [#233](http://issues.npcap.org/233).

* Fixed an issue since Npcap 1.30 where broadcast and subnet masks for adapters
  returned by `pcap_findalldevs()` were in host byte order, displaying values
  like "0.240.255.255". Fixes [#525](http://issues.npcap.org/525).

* Libpcap 1.10.1 has been updated to include some recent changes to the libpcap-1.10
  release branch which extend support to adapters with the NdisMediumIP media type,
  including Wireguard Wintun virtual adapters. Fixes [#173](http://issues.npcap.org/173).

* Added specific bad-value checks for issues originating in other drivers which
  may be incorrectly attributed to Npcap. These checks, in combination with
  additional `const` qualifiers, should serve as assurance that Npcap is not
  modifying traffic during capture and cannot be responsible for such crashes.

* Powershell commands launched by the installer are now run with the
  `-NoProfile` option. Fixes [#529](http://issues.npcap.org/529).

* Npcap SDK 1.11 released. This includes upstream libpcap changes to allow building with older
  Visual Studio versions, as well as minor changes to add const qualifiers to parameters to several
  Packet.dll functions.  Fixes [#518](http://issues.npcap.org/518).

* Npcap installer now uses Unicode internally. This may result in mixed-encoding install.log files.

## Npcap 1.50 [2021-06-22]

* Fixed [#513](http://issues.npcap.org/513) which prevented Npcap 1.40 from installing.

* Npcap can now be installed on Windows 10 for ARM64 devices. Both ARM64 and
  x86 DLLs will be installed, allowing existing x86 applications such as Nmap
  or Wireshark to run without modification.

* Npcap SDK 1.10 release coincides with this release, providing updated
  documentation and libs for ARM64.

* Npcap code now passes Microsoft's Static Driver Verifier for NDIS drivers and
  Visual Studio's Code Analysis "AllRules" ruleset. A couple of minor and
  extremely-improbable bugs were fixed in addition to general code cleanup and annotation.

* On Windows 8 and 8.1, the Npcap driver has been updated to NDIS 6.30,
  supporting network stack improvements like RSC and QoS. Windows 10 still uses
  NDIS 6.50 and Windows 7 uses NDIS 6.20.

* Npcap is no longer distributed with SHA-1 digital signatures. Windows 7 and
  Server 2008 R2 will require KB4474419 in order to install Npcap. All other
  platforms support SHA-2 digital signatures by default.

* Streamlined loopback packet injection to avoid using Winsock Kernel (WSK)
  sockets. This removes a significant amount of complexity and overhead.

* Due to Microsoft's [deprecation of cross-signed root certificates for kernel-mode code signing](https://docs.microsoft.com/en-us/windows-hardware/drivers/install/deprecation-of-software-publisher-certificates-and-commercial-release-certificates),
  Npcap 1.40 may not install correctly on Windows versions prior to Windows 10.
  Our testing did not show any issues, but users who experience installation
  failures may use the `/prior_driver=yes` installation option to install the
  Npcap 1.31 driver instead, which has no such issues.

* The "npcapwatchdog" scheduled task, which ensures the Npcap driver service is
  configured to start at boot, is now installed with a description when
  possible (Windows 7 does not support creating scheduled tasks via PowerShell).
  Fixes [#498](http://issues.npcap.org/498).

* All PowerShell scripts installed or used during installation are now digitally signed.

* Fix an issue where installation under Citrix Remote Access or other
  situations would fail with the message "Installer runtime error 255 at
  76539962, Could not load SimpleSC.dll". Fixes [#226](http://issues.npcap.org/226).

* Ensure driver signature can be validated on systems without Internet access
  by installing the entire certificate chain, including the chain for the
  timestamp counter-signature. This should address [#233](http://issues.npcap.org/233).

* Fix an issue with comparing adapter names retrieved from the Registry. This
  prevented Npcap 1.31 from being used for SendToRx and other less-used
  features. Fixes [#311](http://issues.npcap.org/311).

* Npcap driver no longer excludes adapters based on media type, which may allow
  capture on some devices that were previously unavailable.

## Npcap 1.40 [2021-06-21]

* This release was retracted due to installer issues. See [#513](http://issues.npcap.org/513).

## Npcap 1.31 [2021-04-21]

* Fix a bug with the non-default legacy loopback capture support that caused
  all requests to open a capture handle to open the loopback capture instead.
  It is recommended to not select "Legacy loopback support" at installation
  unless you know your application relies on it. Fixes [#302](http://issues.npcap.org/302).

* For Windows 10 and Server 2016 and later, restore the ability to capture
  traffic on VMware VMnet interfaces such as the host-only and NAT virtual
  networks. This will be restored for other supported Windows versions in a
  later release. Fixes [#304](http://issues.npcap.org/304).

## Npcap 1.30 [2021-04-09]

* Restore raw WiFi frame capture support, which had been broken in a few ways
  since Npcap 0.9983. Additional improvements enable `PacketSetMonitorMode()`
  for non-admin-privileged processes, allowing Wireshark to correctly enable
  monitor mode via checkbox without requiring WlanHelper.exe.

* Fixed WlanHelper.exe to correctly set modes and channels for adapters, if run
  with Administrator privileges. Fixes [#122](http://issues.npcap.org/122).

* Improved speed of `pcap_findalldevs()` by using fewer calls to
  `GetAdaptersAddresses()` and avoiding direct Registry inspection. The new
  method may result in more adapters being available for capture than
  previously reported. See [#169](http://issues.npcap.org/169).

* Updated Packet.dll to use modern `HeapAlloc()` allocation, faster than the
  legacy `GlobalAlloc()` inherited from WinPcap.

* Improve error reporting from `PacketGetAdapterNames()` and related functions.

## Npcap 1.20 [2021-03-10]

* Upgrade wpcap.dll to libpcap 1.10. This change enables software to use
  `pcap_set_tstamp_type()` to set the packet capture time source and precision
  per capture handle. The currently-supported types (see
  [`pcap-tstamp`](https://npcap.com/guide/wpcap/pcap-tstamp.html)) are:
  * `PCAP_TSTAMP_HOST_HIPREC_UNSYNCED` - default, maps to `TIMESTAMPMODE_SINGLE_SYNCHRONIZATION`
  * `PCAP_TSTAMP_HOST_LOWPREC` - maps to `TIMESTAMPMODE_QUERYSYSTEMTIME`
  * `PCAP_TSTAMP_HOST_HIPREC` - maps to `TIMESTAMPMODE_QUERYSYSTEMTIME_PRECISE`

* Fix an issue preventing `WlanHelper.exe` from changing WiFi parameters for
  adapters which caused the error message "makeOIDRequest::My_PacketOpenAdapter
  error". Fixes [#122](http://issues.npcap.org/122) and several other reports
  of the same issue.

* Fixed an issue that prevented NDIS protocol drivers from reducing the
  hardware packet filter, even if the removed bits/filters were only set by
  that protocol driver initially. This caused network interruptions on VMware systems.
  Fixes [#106](http://issues.npcap.org/106).

* Fixed an issue with `pcap_sendqueue_transmit()` that caused it to busy-wait
  in an attempt to synchronize packet sends with pcap timestamps, even when the
  program did not request synchronization. Fixes [#113](http://issues.npcap.org/113).

* The installer will now safely remove and replace broken installations due to
  [#268](http://issues.npcap.org/268).

* Upgraded installer to NSIS 3, which improves compatibility with modern Windows versions.

* Added application manifests to several installer tools and removed Windows
  Vista from the manifests of others, improving compatibility.

## Npcap 1.10 [2020-12-11]

* Fixed an issue where our upgrade uninstaller would trigger the
  [#1924](https://issues.nmap.org/1924) BSoD crash when upgrading from Npcap 0.9988 or older to
  version 0.9996 or greater. Fixes [#268](http://issues.npcap.org/268).

* Improved handling of large packets when a very small user buffer size is specified, which could
  lead to stalled captures and dropped packets.

* Fix a packet corruption issue when one capture handle sets a snaplen of exactly 256 bytes and
  another sets a snaplen of greater than 256 bytes and the packet size exceeds 256 bytes.

* Fix accounting of free space in the kernel buffer so that bugs like the previous one do not cause
  space to be permanently lost, leading to dropped packets. Instead, use assertions to catch this
  condition in testing with the debug build.

* Check that the npcap driver service is configured for `SYSTEM_START` in the `npcapwatchdog`
  scheduled task and correct it if necessary. Windows feature updates can modify this value.

## Npcap 1.00 [2020-09-25]

* After more than 7 years of development and 170 previous public releases, the
  Nmap Project is delighted to release Npcap version 1.00!

* New Packet.dll function `PacketGetTimestampModes()` to retrieve supported
  packet timestamping modes. These do not currently vary by adapter, but
  `TIMESTAMPMODE_QUERYSYSTEMTIME_PRECISE` is not supported on Windows 7, for
  example. Fixes [#174](http://issues.npcap.org/174).

* Npcap driver is now only signed with SHA256 signatures on platforms other
  than Windows 7, which may resolve signature validation issues on some
  systems. The Windows 7 driver is signed with SHA-1 signatures only.

## Npcap 0.9997 [2020-08-25]

* Fix an integer underflow in the amount of free buffer space available leading
  to excessive memory consumption. Fixes [#223](http://issues.npcap.org/223).

* Significantly reduced per-packet memory overhead for packets in the kernel capture buffer.

* Replaced object pool/slab allocator with Windows lookaside lists, improving
  performance by avoiding spinlocks and allowing the system to adjust memory
  consumption.

## Npcap 0.9996 [2020-08-07]

* Fix a runaway memory leak triggered by low-resources condition leading to
  system hangs. Fixes [#213](http://issues.npcap.org/213).

* Fix a BSoD crash in `NPF_Read` in some high-traffic cases. Fixes [#206](http://issues.npcap.org/206).

* Fix a handle leak in Packet.dll when enumerating interfaces. Fixes [#26](http://issues.npcap.org/26).

* Fix an inconsistency between return value and IRP completion status in
  `NPF_Read` when an adapter is removed. Driver Verifier would cause a bugcheck
  (BSoD) in this case, and pcap API functions would not detect an error.
  Fixes [#217](http://issues.npcap.org/217)

* Improved performance by reusing allocated packet data buffers and
  implementing `DISPATCH_LEVEL` tracking throughout the driver to speed up lock
  acquisition.

* When upgrading from compatible recent versions (currently Npcap 0.9985 and
  newer), the installer will unpack a new `Uninstall.exe` and `NPFInstall.exe`
  prior to removing the existing installation. This resolves issues with the
  uninstallation process such as were common in Npcap 0.9991 through 0.9994.

* Upgraded build system to Visual Studio 2019 and WDK 10.0.18362.0

## Npcap 0.9995 [2020-07-10]

* Fix a BSoD crash in `NPF_Read` when NDIS filter module is detached from the
  adapter. Fixes [#194](http://issues.npcap.org/194)

* On Windows 10, the Npcap driver has been updated to NDIS 6.50 and Windows 10
  WFP compatibility, supporting network stack improvements like RSC.
  Fixes [#196](http://issues.npcap.org/196).

* Correctly obey maximum frame size for an adapter by querying
  `OID_GEN_MAXIMUM_TOTAL_SIZE` instead of using MTU, which does not include
  space for the link layer header. Fixes [#186](http://issues.npcap.org/186).

* Fix detection of processes using Npcap resources during uninstall or upgrade.
  The fix for [#2015](http://issues.nmap.org/2015) had broken this so such
  processes were not terminated, leading to failed installations.

* Obey snaplen (`pcap_set_snaplen()`) even if a packet filter is not set. This
  is a backported change from upstream libpcap that corrects a deficiency that
  has been present in all previous versions of WinPcap and Npcap.
  Fixes [#201](http://issues.npcap.org/201).

* Improvements to object pool/slab allocator to allow nonpaged memory to be
  freed when not in use.

* When installing Npcap OEM in silent mode, avoid running `C:\Uninstall.exe` if
  no existing Npcap installation is present.

## Npcap 0.9994 [2020-06-12]

* Fix a BSoD crash in `NPF_ReleaseOpenInstanceResources` due to miscounting of
  number of open Loopback capture instances. Fixes [#185](http://issues.npcap.org/185).

* Fix corrupted and missing packets in Npcap 0.9992 and 0.9993 due to reusing a
  data structure that already contained packet data.

* Ensure our SHA-1 code signing certificate is also installed on systems which
  may require it. This was preventing installation on older platforms since
  Npcap 0.9991.

* Fix a crash in `NPFInstall.exe` that happened when trying to rebind Npcap to
  the network stack as part of some installations. Reported by Microsoft App
  Assure ISV Outreach Team.

* When multiple packets are indicated in a single `FilterReceiveNetBufferLists`
  callback, only get a single timestamp for all of them. Avoids extra calls to
  KeQueryPerformanceCounter or KeQuerySystemTimePrecise which only ended up
  measuring Npcap processing delay, not actual packet arrival time.

* Fix a potential NULL pointer deref issue in `Objpool.h` macros if an
  allocation were to fail and return a NULL pointer.

* Fix parsing of `pnputil.exe` output that resulted in Npcap drivers not being
  cleared from the DriverStore before installing or upgrading. This led to
  older drivers being preferred in some cases, such as installing an unsigned
  driver in test mode.

* Move all capture- and injection-related initialization code out of
  `NPF_OpenAdapter`, improving efficiency of operations like listing adapters
  or performing OID requests without starting a full capture.

* Added SAL annotations to most driver functions to improve static analysis.
  Found one issue related to using a NULL NDIS handle in an allocation
  function, which is not supported on Windows 7.

* Allow driver to load even if there is a problem initializing loopback capture
  or injection functions. The loopback capture device will simply be
  unavailable in that case.

## Npcap 0.9993 [2020-06-05]

* Fix a BSoD crash in `NPF_DoInternalRequest` triggered by suspending the
  system while a capture is running. Added source annotations to allow static
  analysis to catch bugs like this in the future. Fixes [#181](http://issues.npcap.org/181).

* Fix a bug introduced in Npcap 0.9992 which caused loopback capture to fail if
  any loopback capture had been previously started and finished.

* Fix packet length calculation for loopback capture. The packet length was
  being counted twice, leading to junk data being appended to captured packets.

* If installation fails for any reason other than a failure to uninstall the
  previous version of Npcap, the current version's uninstaller will be used to
  clean up any partial installation. The only remaining files will be the
  `install.log` and `NPFInstall.log` in the  Npcap installation directory.

* Replaced ReadWriteLock mechanisms with improved `NDIS_RW_LOCK_EX` new in NDIS
  6.20 for improved performance.

* Moved object pool for captured packets from the filter module (adapter)
  object to the open instance (pcap handle) to allow memory to be recovered
  after a capture is closed.

## Npcap 0.9992 [2020-06-03]

* Npcap issues are now tracked on [their own Github Issues
  page](http://issues.npcap.org), separate from Nmap issues. Many existing
  issues have been migrated, and issue numbers may have changed.

* Rewrote the kernel packet capture buffer code again to avoid requiring a
  separate worker thread. Instead, captured packets are held directly in a
  synchronized queue. The worker thread introduced in Npcap 0.9991 was unable
  to keep up with the volume of packet requests, leading to buffer bloat and
  reduced performance.

* Avoid initializing loopback capture-related functions and processing packets
  as soon as an adapter is opened. This will improve performance since adapters
  are opened as part of listing adapters.

* Fix a crash in NPFInstall.exe when terminating processes which are using
  Npcap resources. This could lead to failed installations and message windows
  about "A LWF & WFP driver installation tool has stopped working."

* Update Npcap from NDIS 6.10 to NDIS 6.20, which limits its compatibility to
  Windows 7 and higher. Closes [#167](http://issues.npcap.org/167).

* Fix a bug in Npcap 0.9991 which prevented packets from being captured until a
  BPF filter had been set. Fixes [#168](http://issues.npcap.org/168) (migrated
  from nmap/nmap#2037).

* Allow capture statistics and captured packets remaining in the buffer to be
  retrieved when an adapter is removed. Fixes [nmap/nmap#2036](https://issues.nmap.org/2036).

* Use WMI instead of the Windows 10-only `Get-NetAdapter` Powershell cmdlet in
  the DiagReport tool. Fixes [nmap/nmap#611](https://issues.nmap.org/611).

## Npcap 0.9991 [2020-05-04]

* Switched our code signing certificate back to DigiCert after some users found
  older Windows versions could not validate the signature on our driver for
  versions 0.9985 through 0.9990.  The driver is again dual-signed with SHA-1
  and SHA-2 certificates. See [#2012](https://issues.nmap.org/2012).

* Major changes to management of Npcap driver's circular packet buffer,
  switching from per-CPU unshared segments to a single worker thread managing a
  queue of work items. This improves buffer utilization, reduces the amount of
  time spent processing in the network stack, and should reduce packet loss.
  See [#1967](https://issues.nmap.org/1967).

* Several performance-related improvements to the NDIS filter driver: Switched
  from SpinLocks to ReadWriteLocks for several crucial shared data structures,
  which will improve performance by reducing resource contention on
  multiprocessor systems, and introduced an object-pool allocation pattern for
  several frequently-used short-lifetime objects, improving performance by
  reducing memory allocations.

* Again restore "unused" NDIS filter callbacks which cause Windows 7 to lose
  connectivity when they are removed. See [#1998](https://issues.nmap.org/1998).

* Include debug symbols for `wpcap.dll` in our debug symbols zip file at
  https://npcap.com/#download . Fixes [#1844](https://issues.nmap.org/1844).

* Fixed [#1996](https://issues.nmap.org/1996): heap corruption in
  `NPFInstall.exe` since Npcap 0.9989 leading to hung installs when the "raw
  802.11 traffic" option was checked.

* Fixed [#2014](https://issues.nmap.org/2014): Npcap OEM silent install
  produced a dialog when installing over an existing installation of the same
  version.

* Uninstaller improvements related to removing the installation directory,
  properly killing processes using Npcap DLLs, not leaving a partial
  installation if a step fails. Fixes [#2013](https://issues.nmap.org/2013)
  and [#2015](https://issues.nmap.org/2015).

## Npcap 0.9990 [2020-04-04]

* Improve compatibility with WinPcap's behavior regarding injected traffic.
  WinPcap uses inefficient loopback to capture all outbound traffic, but allows
  `PacketSetLoopbackBehavior()` to avoid this for injected traffic. Because of
  Npcap's more efficient design, injected traffic was never looped back up to
  protocol drivers, causing problems for some users who relied on this behavior.
  Now, injected traffic follows the same path as with WinPcap, though ordinary
  traffic is unaffected. For highest efficiency without loopback, use
  `PacketSetLoopbackBehavior(NPF_DISABLE_LOOPBACK)`. Fixes [#1343](https://issues.nmap.org/1343),
  [#1929](https://issues.nmap.org/1929), and [GNS3/gns3-gui#2936](https://github.com/GNS3/gns3-gui/issues/2936)

* No longer honor `NDIS_PACKET_TYPE_ALL_LOCAL` set via `PacketSetHwFilter()`.
  This packet filter causes all local traffic to be routed through an unoptimized
  loopback path within NDIS, which was necessary to capture outgoing traffic in
  WinPcap but is no longer needed in Npcap. Instead, this value will be treated as
  `NDIS_PACKET_TYPE_DIRECTED | NDIS_PACKET_TYPE_MULTICAST | NDIS_PACKET_TYPE_BROADCAST`.

* Fix a bug that caused `TIMESTAMPMODE_QUERYSYSTEMTIME_PRECISE` to fall back to
  `TIMESTAMPMODE_QUERYSYSTEMTIME` even when `KeQuerySystemTimePrecise()` was
  available. Fix by Mauro Levra in [PR#23](https://github.com/nmap/npcap/pull/24).

* Installer will now install an intermediate CA cert that was missing from some
  systems, which is needed to verify the driver's digital signature. Only
  affects Windows versions prior to Windows 10.

* Backport a fix from libpcap needed to properly support
  `NdisMediumWirelessWan`. See [#1573](https://issues.nmap.org/1573).

* Include experimental support for AirPcap cards if `airpcap.dll` (not
  included) is installed.

## Npcap 0.9989 [2020-03-19]

* Fix a BSOD crash in `NPF_OpenAdapter` due to reading past the end of a
  string. Fixes [#1924](https://issues.nmap.org/1924)

* Fix a BSOD crash (NULL pointer dereference) in `NPF_Restart`.
  Fixes [#1964](https://issues.nmap.org/1964).

* Fix a memory leak in the Loopback WFP filter. Additionally, WFP callbacks
  will be unregistered when all loopback captures are closed, reducing impact
  of related code when not in use. Fixes [#1966](https://issues.nmap.org/1966).

* New Packet.DLL function `PacketSetTimestampMode()` allows a user program to
  set the method used to timestamp packets as they arrive. See [#1775](https://issues.nmap.org/1775).
  Supported modes are:
  * `TIMESTAMPMODE_SINGLE_SYNCHRONIZATION` - default monotonic timestamps based
   on `KeQueryPerformanceCounter()`
  * `TIMESTAMPMODE_QUERYSYSTEMTIME` - low-precision wall clock time based on
   `KeQuerySystemTime()`
  * `TIMESTAMPMODE_QUERYSYSTEMTIME_PRECISE` - high-precision wall clock time
   based on `KeQuerySystemTimePrecise()`, new in this release and only
   available on Windows 8 and newer. See [#1407](https://issues.nmap.org/1407).

* Remove some problematic timestamp modes:
  `TIMESTAMPMODE_SYNCHRONIZATION_ON_CPU_WITH_FIXUP` and
  `TIMESTAMPMODE_SYNCHRONIZATION_ON_CPU_NO_FIXUP` were undocumented;
  `TIMESTAMPMODE_RDTSC` was x86-only and not suitable for multi-processor
  systems. See [#1829](https://issues.nmap.org/1829).

* The Npcap SDK 1.05 will be released to include the new
  `PacketSetTimestampMode()` function.

## Npcap 0.9988 [2020-03-05]

* If a capture is in progress when the system is suspended, it will continue
  without interruption after the system is woken. This also prevents capture
  interruptions when the OS makes certain network stack changes.
  Fixes [#1903](http://issues.nmap.org/1903).

* If the npcap driver is stopped, Packet.dll will attempt to start it
  automatically. This feature requires Administrator privilege and had been
  removed in Npcap 0.9983. Fixes [#1911](http://issues.nmap.org/1911). 

* Fix the check for fragmented packets in loopback capture.
  Closes [PR #22](https://github.com/nmap/npcap/pull/22).

* Eliminate clone/block/inject pattern from loopback capture except for packets
  already injected by Npcap. Should fix [#1529](http://issues.nmap.org/1529)
  and [#1789](http://issues.nmap.org/1789).

* Fix an issue in the Npcap OEM installer where silent mode would not detect a
  failure to install the npcap driver. Fixes [#1910](http://issues.nmap.org/1910).

* Improve the installer to avoid broken installations and allow the installer
  to continue if a broken installation is detected. Fixes [#1935](http://issues.nmap.org/1935).

* Formally removed support for Windows Vista and Server 2008 r1, which
  are no longer supported by Microsoft either. This allows us to support
  newer Windows WFP and NDIS features for better performance and
  compatibility. Folks who must still run these ancient Windows releases
  should use Npcap version 0.9984 from
  https://npcap.com/dist/?C=M;O=D. That was the last Npcap release
  to support the old (and less secure) SHA-128 driver signatures
  required by these Windows Vista/2008. Please note that Windows Server
  2008 r2 and Windows 7 are still supported in this release even though
  they have also passed their Microsoft end-of-life dates.

## Npcap 0.9987 [2020-02-03]

* Fix an issue where Npcap begins dropping large packets, then smaller ones
  until finally all packets are dropped. Our fix changes the way remaining free
  space in the kernel buffer is calculated, which ought to prevent the free
  space accounting from drifting from reality. Fixes
  [#1891](http://issues.nmap.org/1891).

* Fix a potential race condition when opening the loopback capture adapter. If
  two threads simultaneously determine that the WFP filters need to be
  registered, each may open a handle to the WFP engine using the same global
  pointer, leading to a double-free when the second one tries to close the
  handle.

* Allow Packet.dll and the npcap driver to skip loopback-related operations,
  including WFP and WSK setup, if the `LoopbackSupport` Registry key is set
  to 0. This configuration will not be supported by the installer, but may
  serve as a workaround for problems that may be related to Npcap's loopback
  traffic capture and injection capability.

* Ensure open handles to the Service Control Manager are closed on error in
  PacketGetFileVersion. Fixes [#1882](http://issues.nmap.org/1882).

## Npcap 0.9986 [2019-12-17]

* Fix a driver signing issue that made Npcap 0.9985 uninstallable on default
  configurations of Windows 8.1 and older, as well as certain older Windows
  Server releases. Fixes [#1856](http://issues.nmap.org/1856).

## Npcap 0.9985 [2019-12-13]

* The Nmap Project's (Insecure.Com LLC) code signing certificate has been
  renewed, and no longer exists as a SHA-1 certificate. Windows Vista and
  Server 2008 may therefore not recognize the digital signatures on the
  filter driver so a warning may be presented upon install. Please note
  that Microsoft is ending support for these operating systems in January 2020.

* WinPcap API-compatible mode no longer installs a separate filter driver.
  Packet.DLL will translate NPF device names so that they are all serviced by
  the npcap.sys driver. The npf.sys driver has been removed. See
  [#1812](http://issues.nmap.org/1812).

* Improve the speed of `pcap_findalldevs` by reducing the number of calls to
  `GetAdaptersAddresses`, removing a redundant function call, and improving
  buffer reallocation. Patch by Tomasz Moń
  ([#20](https://github.com/nmap/npcap/pull/20)).

* Temporary DLLs unpacked during installation are now signed with our code
  signing certificate. Certain strict application whitelisting systems were
  complaining about unsigned DLL's loaded from a temporary directory.

* Fixed a bug in the uninstaller preventing downgrades to prior versions of
  Npcap. On 64-bit Windows, the driver file `npcap.sys` was not properly
  removed, and Windows would not replace it with any older version. Fixes
  [#1686](http://issues.nmap.org/1686).

## Npcap 0.9984 [2019-10-30]

* Update libpcap to 1.9.1. See [the libpcap CHANGES
  file](https://github.com/the-tcpdump-group/libpcap/blob/libpcap-1.9.1/CHANGES)
  for this release. This update addresses several CVE-identified vulnerabilities.

* Address several code quality issues identified by Charles E. Smith of
  Tangible Security using Coverity source code analysis.

* Fixed processing of the "enforced" value for several command-line installer
  options. Fixes [#1719](http://issues.nmap.org/1719).

* The `DisplayName` value in the Uninstall registry key for Npcap no longer
  includes the version number, which has always been available in the
  `DisplayVersion` value. Instead, it will include the product name and
  edition, e.g. "Npcap" or "Npcap OEM". This value will also be recorded in the
  `Edition` value under the npcap service's Parameters registry key.

* Fixed a couple of issues with the
  [DiagReport tool](https://npcap.com/guide/npcap-users-guide.html#npcap-issues-diagreport)
  used for bug report diagnostics: remove extraneous partial output lines
  ([#1760](http://issues.nmap.org/1760)), and avoid relying on the Server
  service to determine privilege level ([#1757](http://issues.nmap.org/1757)).

## Npcap 0.9983 [2019-08-30]

* Npcap can now detect newly-added network adapters without restarting the
  driver. Fixes [#664](http://issues.nmap.org/664).

* Loopback capture and injection no longer requires the Npcap Loopback Adapter
  to be installed. This is a minor API change, so Nmap 7.80 and earlier will
  still require the adapter to do localhost scans, but Wireshark and most other
  software will not require changes. Loopback capture uses the device name
  `NPF_Loopback` instead of `NPF_{GUID}`, where `GUID` has to be looked up in
  the Registry. The Npcap Loopback Adapter can still be installed by selecting
  "Legacy loopback support" in the installer or using the
  `/loopback_support=yes` command-line option. The`LoopbackSupport` Registry
  value will always be 0x00000001.

* The `DltNull` Registry setting and the `/dlt_null` installer option are no
  longer supported. Loopback capture will use the `DLT_NULL` link type as
  described [in the tcpdump
  documentation](https://www.tcpdump.org/linktypes.html). Loopback packet
  injection will also use this link type instead of requiring a dummy Ethernet
  header to be constructed. The `DltNull` Registry value will still be present
  and set to `1` for software that consults this value.

* Some operations like `pcap_stats()` can now be completed even after the
  adapter that was in use is removed. See [#1650](http://issues.nmap.org/1650).

* Fixed a crash that could happen when stopping the driver during a loopback
  traffic capture. Fixes [#1678](http://issues.nmap.org/1678).

## Npcap 0.9982 [2019-07-30]

* Fix the packet statistics functionality used by `pcap_stats()`, which was
  broken in 0.9981. Fixes [#1668](http://issues.nmap.org/1668).

* Rework the flow of packets through the WFP callout driver that implements
  loopback traffic capture. This should prevent clobbering of redirect context
  data reported in [#1529](http://issues.nmap.org/1529).

* Restore the `/dlt_null` installer option to default to "yes" since it has
  been defaulting to "no" since Npcap 0.992. Using `DLT_NULL` for loopback
  capture is slightly more efficient than creating a dummy Ethernet header,
  which was the default before.

## Npcap 0.9981 [2019-07-23]

* When upgrading Npcap, do not uninstall the existing Npcap until the user
  clicks the Install button. Previously, the existing Npcap was uninstalled
  prior to the first options screen, so that canceling the upgrade left no
  working Npcap on the system.

* Redefine the I/O control codes used by Npcap using the `CTL_CODE` macro to
  ensure proper access control and consistent parameter passing. This is not a
  published API, but the change will require that Packet.DLL and the npcap
  driver are the same version.

* Fix a 1-byte overrun in NPFInstall.exe when killing processes with Npcap DLLs
  in use.

* In cases where PacketOpenAdapter is given an adapter name in UTF-16LE,
  translate it to ASCII before doing string operations on it. See
  [#1575](http://issues.nmap.org/1575).

* Significant reorganization of internal data structures to reduce memory use
  and initialization overhead.

## Npcap 0.997 [N/A]

* Internal testing build, no public release.

## Npcap 0.996 [2019-06-15]

* Fix a crash when stopping the npcap driver service, such as when upgrading
  Npcap, `DRIVER_IRQL_NOT_LESS_OR_EQUAL` in `NPF_DetachAdapter`. Since Npcap
  0.994 and 0.995 may crash when upgrading, the installer will offer to disable
  the npcap driver service if it is running, allowing the user to reboot and
  attempt the install again, avoiding a crash. Fixes [#1626](http://issues.nmap.org/1626).

* Ensure the uninstaller for the previous version of Nmap is called when
  upgrading. Npcap 0.95 through 0.995 erroneously skipped this step in simple
  non-silent upgrades, which could cause multiple Npcap Loopback Adapters to be
  installed.

## Npcap 0.995 [2019-05-10]

* Fix a crash reported via Microsoft crash telemetry,
  `DRIVER_IRQL_NOT_LESS_OR_EQUAL` in `NPF_NetworkClassify` introduced in Npcap
  0.994.  Fixes [#1591](http://issues.nmap.org/1591).

## Npcap 0.994 [2019-05-07]

* Fix the installer options screen, which would immediately proceed to
  installation when you clicked on the "Support loopback traffic" option. Fixes
  [#1577](http://issues.nmap.org/1577).

* Use the `/F` option to `SCHTASKS.EXE` in the installer so that the
  `npcapwatchdog` task can be successfully overwritten if it is present, though
  newer uninstallers also remove the task. Fixes [#1580](http://issues.nmap.org/1580).

* Fix the `CheckStatus.bat` script run by the `npcapwatchdog` scheduled task to
  correctly match output of `reg.exe` on non-English systems. Fixes
  [#1582](http://issues.nmap.org/1582).

* Improve synchronization between WFP (Loopback) and NDIS (control) functions
  within the driver, which ought to improve stability during system
  sleep/suspend events, particularly an access violation in
  `NPF_NetworkClassify` observed via Microsoft crash telemetry.

## Npcap 0.993 [2019-04-27]

* Complete the fix for [#1398](http://issues.nmap.org/1398) that was only
  partially applied in Npcap 0.992. Due to this partial fix, the user-provided
  buffer was double-freed, resulting in a `BAD_POOL_CALLER` BSoD. This issue
  was separately reported as [#1568](http://issues.nmap.org/1568), and has been
  issued the identifier CVE-2019-11490.

* Fix output of `pcap_lib_version` to again report "Npcap version 0.993, based
  on libpcap version 1.9.0" instead of "libpcap version 1.9.0 (packet.dll
  version 0.992)". Npcap 0.992 was the only version affected. Fixes
  [#1566](http://issues.nmap.org/1566).

* Fix a regression in loopback capture that was causing the loopback adapter to
  be missing from `pcap_findalldevs` until the driver was manually stopped and
  restarted. Fixes [#1570](http://issues.nmap.org/1570).

* Remove installer interface option "Automatically start the Npcap driver at
  boot time." Command-line and registry settings are still respected, but
  automatic start will be the default for all new installations, since manual
  start results in delays in network connectivity at boot. See
  [#1502](http://issues.nmap.org/1502).

* Avoid interpreting null or uninitialized memory as out-of-band media-specific
  information for purposes of constructing the Radiotap header when capturing
  in raw 802.11 monitor mode. Fixes [#1528](http://issues.nmap.org/1528).

* Ensure the uninstaller removes the `npcapwatchdog` scheduled task.

* Avoid an uninstaller failure if DLLs and executables are in use during
  uninstall by causing them to be deleted at reboot. See
  [#1555](http://issues.nmap.org/1555).

## Npcap 0.992 [2019-03-24]

* Update libpcap to 1.9.0. See [the libpcap CHANGES
  file](https://github.com/the-tcpdump-group/libpcap/blob/libpcap-1.9.0/CHANGES)
  for this release and [#1506](http://issues.nmap.org/1506).

* Fix a bug in the fix for [#1406](http://issues.nmap.org/1406) that caused
  capture filters to reject all packets when the packet header was offset from
  the start of the kernel data structure.

* Fix a bug in the fix for [#1398](http://issues.nmap.org/1398) that caused
  BSoD (`BAD_POOL_CALLER`) due to mismatch in functions used to allocate and
  free a data structure.

* Remove installer interface option "Use DLT_NULL as the loopback interface'
  link layer protocol instead of DLT_EN10MB." Command-line and registry
  settings are still respected, but `DLT_NULL` will be the default for all new
  installations.

* Remove installer interface option "Support 802.1Q VLAN tag when capturing and
  sending data," which was unsupported for three years. Support may be restored
  in future releases, but the option has not had any effect in earlier
  installers.

## Npcap 0.991 [2019-03-14]

* Fix a bug in the BPF packet filter engine that caused capture filters with
  byte offsets to reject packets due to fragmentation within `NET_BUFFER`
  structures. See [#1406](http://issues.nmap.org/1406) and
  [#1438](http://issues.nmap.org/1438).

* Fix a bug that caused several network device drivers to crash when using the
  `pcap_sendqueue_transmit` function, due to queued network packets being
  allocated from paged memory that paged out before the drivers accessed it.
  See [#1398](http://issues.nmap.org/1398).

* Fix a crash (`SYSTEM_EXCEPTION_NOT_HANDLED_M`) in `WSKCloseSocket` due to
  double-free, reported via Microsoft crash telemetry.

* Fix a BSOD inherited from WinPcap triggered when `PacketGetStats` is called
  with low system resources. See [#1517](http://issues.nmap.org/1517).

* Properly quote the path to the `CheckStatus.bat` script in the
  `npcapwatchdog` scheduled task. See [#1513](http://issues.nmap.org/1513).

* Fix errors when installing in WinPcap API-compatible mode over WinPcap when
  Npcap install directory does not already exist. See
  [#1456](http://issues.nmap.org/1456).

## Npcap 0.99-r9 [2019-01-22]

* Install a scheduled task at startup to check whether the Npcap Loopback
  Adapter has been removed and restore it. Windows 10 feature updates remove
  the Adapter. See [#1416](http://issues.nmap.org/1416).

* Package the correct driver version. On some platforms, the Npcap 0.99-r8
  installer would install the Npcap 0.99-r7 driver.

* Fix a crash (`REFERENCE_BY_POINTER`) in `NPF_ReleaseOpenInstanceResources`
  reported via Microsoft crash telemetry. See [#1419](http://issues.nmap.org/1419).

## Npcap 0.99-r8 [2018-12-17]

* Revert to using `SERVICE_SYSTEM_START` for the "Automatically start Npcap at
  boot" option. The previous value, `SERVICE_AUTO_START` had been introduced as
  a workaround for network interruption on Windows 7 that was finally solved in
  Npcap 0.99-r7. See [#1208](http://issues.nmap.org/1208).

* Removed extra Registry keywords from Npcap Loopback Adapter which were
  causing it to not appear properly in Windows API calls.
  Fixes [#1368](http://issues.nmap.org/1368).

* Detect in-use WinPcap installations before attempting to overwrite DLLs.
  Offer to terminate the processes just as we do for in-use Npcap.

* [Improved documentation](https://npcap.com/guide/) based on WinPcap
  documentation including updates for Npcap changes. Example code builds on
  Visual Studio 2015 and works with Npcap. Npcap SDK 1.01 includes these changes.

* Fix a crash in `NPF_RegisterCallouts` reported via Microsoft crash telemetry
  caused by a failure when opening the Npcap Loopback Adapter for packet
  capture.

* On Windows 8 and Server 2012, Npcap will rebind to network adapters after
  installation to ensure a more complete fix to
  [#1031](http://issues.nmap.org/1031).

## Npcap 0.99-r7 [2018-07-05]

* Fixed the installer so that Npcap in WinPcap API-compatible mode can do
  loopback capture. This capability is not guaranteed for future releases, but
  was only missing from 0.99-r3 to 0.99-r6. Native-mode Npcap was unaffected.
  Fixes [#1213](http://issues.nmap.org/1213)

* Added a script, `FixInstall.bat`, to fix common problems with installations,
  such as those caused by Windows 10 feature upgrades.
  See [#1216](http://issues.nmap.org/1216)

* Improved stability by restoring certain passthrough NDIS callbacks that are
  not used, but appear to cause connectivity problems if omitted.
  See [#1208](http://issues.nmap.org/1208).

## Npcap 0.99-r6 [2018-06-12]

* Fixed installation on Windows 8 and Server 2012 so that Npcap is able to
  capture on adapters without requiring a reboot. Fixes
  [#1031](http://issues.nmap.org/1031).

* Fixed loss of networking on Windows 7 when Npcap was configured to start at
  boot. Using `AUTO_START` instead of `SYSTEM_START` for the Npcap driver
  service solves the problem. Fixes [#1208](http://issues.nmap.org/1208).

* Fixed a crash reported via Microsoft crash telemetry,
  `DRIVER_IRQL_NOT_LESS_OR_EQUAL` in `NPF_IOControl` when setting
  `OID_GEN_CURRENT_LOOKAHEAD`. Fixes [#1194](http://issues.nmap.org/1194).

* Fixed certain interactions between processes with open Npcap handles that
  could allow one process to stop other running captures from receiving
  packets. Fixes [#1035](http://issues.nmap.org/1035).

## Npcap 0.99-r5 [2018-05-01]

* Restored installer code to silently uninstall WinPcap if silent installation
  in WinPcap API-compatible mode is needed (Npcap OEM only).

* Removed several optional passthrough driver functions that can be handled
  more efficiently by NDIS, since Npcap was not using them.

* Added validation of IRP parameters for additional security.

* Fixed a crash reported via Microsoft crash telemetry,
  `DRIVER_IRQL_NOT_LESS_OR_EQUAL` in `NPF_SendCompleteExForEachOpen` when the
  system is suspended. Fixes [#1193](http://issues.nmap.org/1193).

* Bundle and install the correct public code signing certificate. The
  certificate used to sign Npcap was updated for Npcap 0.99-r4, but the public
  cert file included was not, leading to some unwanted publisher trust dialogs
  during installation.

## Npcap 0.99-r4 [2018-04-19]

* On Windows 7, if Npcap driver installation fails due to maximum NDIS filters
  installed, attempt to increase the limit. No such limit exists on other
  Windows versions. Fixes [#1182](http://issues.nmap.org/1182).

* Avoid some cmd.exe popup windows during installation. See
  [#1188](http://issues.nmap.org/1188).

* Improve the license to allow unlimited copies of Npcap to be used
  (removes the 5 copy limitation) if the copies are solely used for
  Nmap and/or Wireshark.

## Npcap 0.99-r3 [2018-04-06]

* Fix recording of the Npcap Loopback Adapter's name in the service registry
  key. Loopback packet injection was broken in WinPcap API-compatible mode in
  Npcap 0.99-r1 and 0.99-r2. Fixes [#1165](http://issues.nmap.org/1165).

* Fix a double-close of a Registry key which could cause a crash in Packet.dll
  when debugging. Fixes [#1163](http://issues.nmap.org/1163).

## Npcap 0.99-r2 [2018-03-13]

* Fix installer to work on 32-bit Windows.

## Npcap 0.99-r1 [2018-03-05]

* We now offer an Npcap OEM Edition internal-use license. This
  provides all the advantages of Npcap OEM (such as the silent
  installer) and removes the 5-copy limitation of the free Npcap,
  while also providing for commercial support and updates.  It is
  for companies who only want to use Nmap internally.  We also still
  offer the Npcap OEM redistribution license for companies wanting to
  redistribute Npcap with their software.  See
  https://npcap.com/oem/.

* Improved installation of the Npcap Loopback Adapter, ensuring it can be
  correctly removed and reinstalled.

* Packet.DLL now only looks in the driver service's `Parameters` Registry key
  for installation options; in future releases, Npcap may stop writing these
  options to the `HKLM:\Software\Npcap` registry key.

* When NpcapHelper.exe is used for UAC elevation, the pipe it uses to
  communicate with the calling process is now restricted to the user SID of the
  calling process. Previously, any user could cause NpcapHelper to obtain
  handles to other devices, though the handles were only valid for the calling
  process.

* Performed Visual Studio Code Analysis on Packet.DLL and cleaned up several
  code health issues.

* Improved debug logging, error checking, and diagnostics throughout.

## Npcap 0.98 [2018-01-10]

* Fix digital signatures for some files: OEM drivers were missing the Microsoft
  Attestation signature required for Windows 10 1703, and the installer was
  missing the SHA-1 signature required for Windows Vista.

## Npcap 0.97 [2017-11-27]

* Only include data rate and channel fields in the RadioTap header if they are
  reported by the underlying WiFi card driver. See
  [#1036](http://issues.nmap.org/1036).

* When the Npcap installer detects that WinPcap is present, it will default to
  installing in WinPcap API-compatible mode, replacing WinPcap. This can be
  changed by the user in the interactive installer, or by setting the
  `/winpcap_mode=no` command-line option.

* The Silent installation feature of the Npcap installer is now limited to the
  [Npcap OEM edition](https://npcap.com/oem/).

## Npcap 0.96 [2017-10-31]

* Set the `*IfType`, `*MediaType`, and `*PhysicalMediaType` registry values for
  the Npcap Loopback Adapter. The values set should reduce the amount of
  configuration that Windows attempts to do on the adapter, preventing it from
  being labeled "Unknown Network."

* Record the ID of the Npcap Loopback Adapter in the registry when creating it,
  instead of only in the installer. This allows users to remove and create the
  adapter with NPFInstall directly, without requiring a reinstallation of Npcap.

* Expand the Npcap public license to allow 5 installations rather than only 1.

* Fix memory layout and accounting when writing Radiotap headers in raw 802.11
  monitor mode. Fixes [#1001](http://issues.nmap.org/1001),
  [#1028](http://issues.nmap.org/1028), and [#1036](http://issues.nmap.org/1036).

## Npcap 0.95 [2017-10-19]

* When upgrading, existing installation options will be retrieved from the
  Registry. Command-line installer options will still override these.

* The installer detects Win10pcap as distinct from WinPcap; since the installer
  cannot uninstall Win10pcap, WinPcap API-compatible mode will be disabled in
  the installer when it is present. Fixes [#999](http://issues.nmap.org/999).

* The npcap.cat file is no longer dual-signed; since it was not a PE
  executable, only one signature is supported. The invalid signature was
  causing some installation failures. Fixes [#994](http://issues.nmap.org/994).

* Silent installs will not downgrade the Npcap version unless the new
  `/downgrade=yes` option is given. Any version of [Npcap OEM](https://npcap.com/oem/)
   will be considered a "newer version" than any non-OEM version.

## Npcap 0.94 [2017-08-29]

* Npcap no longer prevents checksum offloading and Large Send Offloading on
  adapters that support them. This may cause problems with sniffing outgoing
  packets on those interfaces when those features are enabled, but users can
  disable them through standard Windows configuration means. Fixes
  [#989](http://issues.nmap.org/989)

## Npcap 0.93 [2017-07-27]

* Move the driver's Service Registry values from the
  `HKLM:\SYSTEM\CurrentControlSet\Services\npcap` key to the `Parameters`
  subkey. Applying Windows upgrades such as Windows 10 Creators Update deletes
  nonstandard values from the service key; the Parameters subkey is where these
  should be stored instead.

* Prevent the installer/uninstaller from crashing when faced with an incomplete
  Npcap installation, such as that created by applying a Windows version
  upgrade. Safely distinguish between old WinPcap installations and broken
  Npcap-in-WinPcap-API-mode installations. Fixes [#906](http://issues.nmap.org/906)

## Npcap 0.92 [2017-06-12]

* Force overwrite of files in installer, since uninstallers from versions
  0.78r5 through 0.81 do not remove npcap.sys, leading to mismatched driver vs
  DLL versions.

* New installer commandline option to skip setting a restore point:
  `/disable_restore_point=yes`

## Npcap 0.91 [2017-06-06]

* Fix WiFi interruption with certain hardware. This is a regression introduced
  in Npcap 0.90, which had optimistically removed the fix from 0.10-r15.

## Npcap 0.90 [2017-05-26]

* Fix BSOD introduced in 0.85; Locking while being cleaned up is bad.

* Fix WiFi interruption on Windows 7 in some circumstances, as demonstrated by
  inability to connect when Kaspersky Internet Security is installed.

## Npcap 0.86 [2017-04-12]

* Fix BSOD introduced in 0.85; wrong driver build had been packaged. Fixes [#840](http://issues.nmap.org/840)

## Npcap 0.85 [2017-04-10]

* Fix BSOD by reverting to simpler pre-0.82 data structures but retaining the
  spinlock improvement that was the core of that fix.

## Npcap 0.84 [2017-03-28]

* Fix a failure of 64-bit Npcap when installed in Admin-Only mode.
  [#814](http://issues.nmap.org/814)

## Npcap 0.83 [2017-03-04]

* Fix a crash caused by recieving loopback traffic after Windows starts to
  sleep. [#721](http://issues.nmap.org/721)

* Don't override CLI installer options like `/wpcap_mode` when WinPcap is
  found. [#717](http://issues.nmap.org/717)

* Restore the uninstaller instruction that deletes the npcap driver files.

## Npcap 0.82 [2017-02-23]

* Fix a crash that happened when many concurrent processes were using Npcap.
  If several of these quit during processing of a packet, the linked list of
  processes could become corrupted. Solved this by using a fixed array with
  copy-and-swap instead.

## Npcap 0.81 [2017-02-16]

* Moved distribution of executable installer to http://npcap.com/ from Github.

* Write log files in UTF-8 encoding to preserve localized error messages.

* Report human-readable error when LWF filter fails to be installed.

* Add `*NdisDeviceType=1` key to registry for Loopback adapter. Fixes [#653](http://issues.nmap.org/653)

## Npcap 0.80 [2017-01-09]

* Signed the uninstaller executable.

* Removed the legacy code supporting Windows XP and earlier.

* Added this CHANGELOG

* Fixed a few null pointer dereferences that may have led to Blue Screens under
  some scenarios.

* Restored changes from 0.78 r2 through 0.78 r4 that were accidentally omitted
  from 0.78 r5.

## Npcap 0.78 r5 [2016-12-15]

* Microsoft Attestation-signed drivers for Windows 10, required in Win10 1607.
  See [#492](http://issues.nmap.org/492)

* Removed Windows XP support from the executable installer. XP users can use
  WinPcap instead, as that is all that we were installing on that platform.

## Npcap 0.78 r4 [2016-12-10]

* Fixed the bug that "Npcap Loopback Adapter" can't be uninstalled.

## Npcap 0.78 r3 [2016-12-10]

* The uninstaller allows users to terminate processes that are using Npcap.

## Npcap 0.78 r2 [2016-12-03]

* The uninstaller lists the processes that are currently using Npcap,
  preventing a clean uninstall.

## Npcap 0.78 [2016-11-23]

* The uninstaller warns when it is unable to delete DLLs that are in use by
  applications.

## Npcap 0.11 [2016-11-21]

* Updated the WDK from 10.0.10586 to 10.0.14393.

## Npcap 0.10 r18 [2016-11-08]

* Improved the error message of invalid adapter name in WlanHelper.

## Npcap 0.10 r17 [2016-11-07]

* Built WlanHelper.exe in Unicode instead of Multi-Byte. This will fix the
  wrong display of non-English characters.

## Npcap 0.10 r16 [2016-11-07]

* Fixed the bug that some functions of WlanHelper.exe doesn't work.

## Npcap 0.10 r15 [2016-11-05]

* Fixed the bug that using Npcap to capture at the first time causes limited
  connectivity on Wi-Fi adapters.

## Npcap 0.10 r14 [2016-11-03]

* Fixed the bug that Npcap mode and WinPcap compatible mode can't use the
  loopback interface at the same time.

## Npcap 0.10 r13 [2016-11-01]

* Added the `/sign_mode` option for installer to choose to install SHA1-signed or
  SHA2-signed drivers.

## Npcap 0.10 r12 [2016-10-25]

* Fixed the issue that Nping shows both protocol unreachable and successful
  replies for "nping <Local IP>".

## Npcap 0.10 r11 [2016-10-24]

* Fixed the issue that Nping shows both protocol unreachable and successful
  replies for "nping 127.0.0.1".

## Npcap 0.10 r10 [2016-10-23]

* The uninstaller will not show the finish page if run with "/Q".

## Npcap 0.10 r9 [2016-10-17]

* Fixed the BSoD that happens when the OS sleeps after using Npcap Loopback
  Adapter.

## Npcap 0.10 r8 [2016-10-16]

* Improved the error messages of WlanHelper.exe.

## Npcap 0.10 r7 [2016-10-08]

* Raw 802.11 capture is provided without re-installing the driver!

## Npcap 0.10 r6 [2016-10-04]

* Fixed the BSoD that `NPF_RemoveFromGroupOpenArray()` referenced the freed group
  head.

## Npcap 0.10 r5 [2016-10-03]

* Fixed the "PAGE FAULT IN NONPAGED AREA" BSoD about the group adapter removal
  reported by Pavel.

## Npcap 0.10 r4 [2016-10-02]

* Fixed some BSoDs that causes the system to halt.

## Npcap 0.10 r3 [2016-10-02]

* Now NPFInstall debug traces will be logged into
  C:\Program Files\Npcap\NPFInstall.log

## Npcap 0.10 r2 [2016-09-21]

* Fixed the BSoD that `NPF_TapEx()` accessed the CPU buffer of the `OPEN_INSTANCE`
  that was released.

## Npcap 0.10 [2016-09-20]

* Fixed the bug that `PacketGetNetType()` doesn't return the correct `DLT_NULL`
  value on Nmap.

## Npcap 0.09-r9 []

## Npcap 0.09-r8 []

## Npcap 0.09-r7 []

## Npcap 0.09-r6 []

## Npcap 0.09-r5 []

## Npcap 0.09-r4 []

## Npcap 0.09-r3 []

## Npcap 0.09-r2 []

## Npcap 0.09-r13 []

## Npcap 0.09-r12 []

## Npcap 0.09-r11 []

## Npcap 0.09-r10 []

## Npcap 0.09 []

## Npcap 0.08-r9 []

## Npcap 0.08-r8 []

## Npcap 0.08-r7 []

## Npcap 0.08-r6 []

## Npcap 0.08-r5 []

## Npcap 0.08-r4 []

## Npcap 0.08-r3 []

## Npcap 0.08-r2 []

## Npcap 0.08-r10 []

## Npcap 0.08 []

## Npcap 0.07-r9 []

## Npcap 0.07-r8 []

## Npcap 0.07-r7 []

## Npcap 0.07-r6 []

## Npcap 0.07-r5 []

## Npcap 0.07-r4 []

## Npcap 0.07-r3 []

## Npcap 0.07-r2 []

## Npcap 0.07-r17 []

## Npcap 0.07-r16 []

## Npcap 0.07-r15 []

## Npcap 0.07-r14 []

## Npcap 0.07-r13 []

## Npcap 0.07-r12 []

## Npcap 0.07-r11 []

## Npcap 0.07-r10 []

## Npcap 0.07 []

## Npcap 0.06-r19 []

## Npcap 0.06-r18 []

## Npcap 0.06-r17 []

## Npcap 0.06-r16 []

## Npcap 0.06-r15 []

## Npcap 0.06-r14 []

## Npcap 0.06-r13 []

## Npcap 0.06-r12 []

## Npcap 0.06-r11 []

## Npcap 0.06-r10 []

## Npcap 0.06-r9 []

## Npcap 0.06-r8 []

## Npcap 0.06-r7 []

## Npcap 0.06-r6 []

## Npcap 0.06-r5 []

## Npcap 0.06-r4 [2016-03-04]

* The uninstallation window won't close itself now.

* Fixed the problem that the uninstallation process won't end in the Task Manager.

* System restore point will not be created in the uninstallation phase.

* Improved the text display of the installer.

## Npcap 0.06-r3 [2016-03-03]

* Improved the creating system restore point support. Now Npcap installer will
  create a Windows system restore point named Before Npcap %VERSION% installs
  before actual installation process and create a point named Before Npcap
  %VERSION% uninstalls before uninstallation.

## Npcap 0.06-r2 [2016-03-01]

* Made the loopback feature optional in the installer. This option is checked
  by default.

* Improved the creating system restore point logic by removing nested
  creation. A modified SysRestore plug-in is used:
  https://github.com/hsluoyz/SysRestore

## Npcap 0.06 [2016-02-29]

* Fixed the bug reported by yyjdelete that Npcap causes BSoD if the user tries to disable the adapter while sending packets.

## Npcap 0.05-r16 [2016-02-29]

* Added creating system restore point support. Now the installer has added an
  option called Create a system restore point before installing Npcap. It this
  option is checked, Npcap installer will create a Windows system restore
  point named Before installing Npcap before actual installation
  process. Returning back to this point will roll back all changes made by
  Npcap. Note: this option is NOT checked by default.

## Npcap 0.05-r15 [2016-02-28]

* Added debug symbols support. Now Npcap will release new versions shipping
  with the corresponding debug symbols. These PDB files will help debugging
  BSoDs and user-mode crashes of Npcap binaries.  See
  https://github.com/nmap/npcap/releases/tag/v0.05-r15.

## Npcap 0.05-r14 [2016-02-25]

* Fixed the driver signing error in Win7. We used the legacy SHA1 code signing
  cert to sign the Npcap driver in Win7, so no need for Win7 users to install
  KB3033929 patch any more.

* This version Npcap is supposed to have fixed all signing errors, so it will
  successfully install on all the platforms: Vista, Win7, Win8, Win8.1 and
  Win10 without any prerequisites.

## Npcap 0.05-r13 [2016-02-20]

* Fixed a driver signing error in Vista. See
  https://github.com/nmap/npcap/releases/tag/v0.05-r13.

## Npcap 0.05-r12 [2016-02-16]

* Signed the installer with better signing method

## Npcap 0.05-r11 [2016-02-16]

* Npcap 0.05 r11: Added firewall (Block-Rx) support. See
  https://github.com/nmap/npcap/releases/tag/v0.05-r11.

## Npcap 0.05-r10 [2016-02-04]

* Added different Timestamp modes support like original WinPcap.  See https://github.com/nmap/npcap/releases/tag/v0.05-r10

## Npcap 0.05-r9 [2016-02-04]

* Updated wpcap.dll from VS2005 to VS2013 and Packet.dll, NPFInstall.exe and
  NPcapHelper.exe from VS2010 to VS2013.

* Additionally, I rolled back the driver signing improvement in 0.05
  r8. Because it will show a Program Compatibility Assistant window said a
  well signed driver is needed. However, it's not true because npcap driver
  runs well by testing net start npf. To avoid this false message, I rolled
  back to the original signing commands.

## Npcap 0.05-r8 [2016-02-01]

* Now Npcap driver will be signed in both SHA1 and SHA256 digest algorithms
  and with timestamp. This improvement will help the driver installation on
  Vista and Win7. This is an issue reported by Graham Bloice (see graham's
  answer in
  https://ask.wireshark.org/questions/46689/failed-to-create-npcap-service).

## Npcap 0.05-r7 [2016-01-28]

* Now send-to-Rx adapters can be multiple. The string specified in registry's SendToRx value should be semicolon-separated.

An example for one send-to-Rx adapter:
'\Device\{754FC84C-EFBC-4443-B479-2EFAE01DC7BF}

An example for two send-to-Rx adapters:
'\Device\{754FC84C-EFBC-4443-B479-2EFAE01DC7BF};\Device\{F5A00000-E19A-4D17-B6D9-A23FE1852573}

## Npcap 0.05-r6 [2016-01-27]

* Now Npcap can have a send-to-Rx adapter. The send-to-Rx adapter will inject
  all its packets to "Receive Path" (Rx) instead of normal "Send Path"
  (Tx). So that instead of sending traffic to the network, the adapter will
  pretend to receive the injected traffic from the network in this way.

* Currently only one send-to-Rx adapter is supported by specifying SendToRx
  value in Npcap driver service's registry key (need to restart the driver to
  take effect).

* Npcap driver service's registry key is usually in:
  HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\npf. In this key. You
  need to manually create a REG_SZ value named SendToRx, the value is the name
  of the adapter you want to be send-to-Rx adapter. The name is usually like
  format of \Device\{F5A00000-E19A-4D17-B6D9-A23FE1852573}. You can query this
  value using Nmap's nmap --iflist command, you will get a similar value like
  \Device\NPF_{F5A00000-E19A-4D17-B6D9-A23FE1852573}, but they are NOT THE
  SAME. You need to remove the NPF_ in this string and copy it to registry's
  SendToRx value. Then reboot the driver by net stop npf and net start npf.

## Npcap 0.05-r5 [2016-01-11]

* Fixed the bug reported by Nuno Antonio Dias Ferreira that Npcap fails to
  retrieve the adapter list using NPF registry way.

## Npcap 0.05-r4 [2015-12-17]

* Fixed the bug reported by Tenzin Rigden that Npcap installer fails to
  install correct files in /S silent mode.

## Npcap 0.05-r3 [2015-11-25]

* Added Npcap's support for Vista, Npcap now will prepare separate binaries
  for Vista.

## Npcap 0.05-r2 [2015-11-05]

* Fixed the bug reported by Amos Sheldon that Npcap causes BSoD:
  ATTEMPTED_EXECUTE_OF_NOEXECUTE_MEMORY when using Wireshark on Win8, 10 x86.

## Npcap 0.05 [2015-09-11]

* Added the "DON'T LOOPBACK" feature, if software set
  PacketSetLoopbackBehavior() by disable, self-sent packets will not be
  received again.

* Built the installer using NSIS with strlen_8192, so system "PATH" will be
  updated normally in most cases (PATH is less than 8192).

* Added 128 CPU core support for Npcap, or Npcap will cause BSoD when running
  on 128-core system.

* Improved the appearance and text of the installer.

## Npcap 0.04-r9 [2015-08-31]

* Fixed the bug that Npcap can't capture real loopback traffic after system is
  resumed from standby.

## Npcap 0.04-r8 [2015-08-25]

* Now PCAP_IF_LOOPBACK flag in pcap_if_t struct will be set for "Npcap
  Loopback Adapter" both for DLT_NULL mode and Fake Ethernet mode.

## Npcap 0.04-r7 [2015-08-24]

* PCAP_IF_LOOPBACK flag in pcap_if_t struct will be set for "Npcap Loopback
  Adapter" now, only for DLT_NULL mode

* Fixed the bug that DLT_NULL mode can't be disabled in the driver.

## Npcap 0.04-r6 [2015-08-23]

* Packet.dll will return NdisMediumNull for "Npcap Loopback Adapter" now.

## Npcap 0.04-r5 [2015-08-21]

* Finished the DLT_NULL protocol support. But there's a problem that Wireshark
  didn't parse the loopback packets right, need fix.

## Npcap 0.04-r4 [2015-08-21]

* Npcap driver will return 65550 as "Maximum Packet Size" instead of default
  1514 for "Npcap Loopback Adapter", which refers to Linux implementation.

## Npcap 0.04-r3 [2015-08-18]

* Fixed the bug reported by Pascal Quantin that WSK code fails to init if it
  is run without Administrator right, the effect is Npcap loopback adapter
  can't be opened.

## Npcap 0.04-r2 [2015-08-16]

* Modified wpcap.dll version to 0.04, and improved the error trace message for
  Winsock Kernel socket operations.

## Npcap 0.04 [2015-08-15]

* Fixed the SYSTEM_SERVICE_EXCEPTION BSoD caused by NdisFOidRequest call, this
  may help to fix the BAD_POOL_CALLER BSoD (I said "may" because this BSoD
  can't be reproduced).

* Modified Nmap and Nping to be able to send loopback packets on Windows OS,
  here's a bug, Nmap still can't see reply packets. But the request and reply
  packets can be seen in Wireshark.

## Npcap 0.03-r6 [2015-08-06]

* Changed to static linked.

## Npcap 0.03-r5 [2015-08-06]

* Npcap can send loopback packets now!

## Npcap 0.03-r4 [2015-08-05]

* WSKTest can send IPv4 and IPv6 loopback packets based on Ethernet header
  now.

* Added IPv6 send support for WSKTest.

* WSKTest can send a self-constructed ICMPv4 request packet now

* Fixed the INF file lacking section issue in WSKTest.

* Updated WSKTest from VS 2013 to VS 2015.

## Npcap 0.03-r3 [2015-08-03]

## Npcap 0.03-r2 [2015-07-30]

* Improved WSK send code, update code format

## Npcap 0.03 [2015-07-27]

## Npcap 0.02-r4 [2015-07-26]

## Npcap 0.02-r3 [2015-07-24]

## Npcap 0.02-r2 [2015-07-22]

* Fixed the bug that "Npcap Loopback Adaprer" renaming fails in Win10 non-English editions.

## Npcap 0.02 [2015-07-22]

* Solve the "system error 2" issue

## Npcap 0.01-r2 [2015-07-19]

## Npcap 0.01 [2015-06-23]

* Add option to restrict Npcap usage to Windows users with admin rights rather
  than all users.

## Npcap Birthday (First Public Code Checkin)! [2013-06-24]

* Npcap's birthday! While Gordon "Fyodor" Lyon and Yang Luo had been working
  on the idea for a couple of months, June 24, 2013 was the date that Yang
  checked in the first actual code with the Npcap name!


```

`Common/Packet32.h`:

```h
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
/*
 * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)
 * Copyright (c) 2005 - 2007 CACE Technologies, Davis (California)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Politecnico di Torino, CACE Technologies 
 * nor the names of its contributors may be used to endorse or promote 
 * products derived from this software without specific prior written 
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/** @ingroup packetapi
 *  @{ 
 */

/** @defgroup packet32h Packet.dll definitions and data structures
 *  Packet32.h contains the data structures and the definitions used by packet.dll.
 *  The file is used both by the Win9x and the WinNTx versions of packet.dll, and can be included
 *  by the applications that use the functions of this library
 *  @{
 */

#ifndef __PACKET32
#define __PACKET32

#include <sal.h>
#include <winsock2.h>
#include "npcap-bpf.h"
#include "npcap-defs.h"

#ifdef HAVE_AIRPCAP_API
#include <airpcap.h>
#else
#if !defined(AIRPCAP_HANDLE__EAE405F5_0171_9592_B3C2_C19EC426AD34__DEFINED_)
#define AIRPCAP_HANDLE__EAE405F5_0171_9592_B3C2_C19EC426AD34__DEFINED_
typedef struct _AirpcapHandle* PAirpcapHandle;
#endif /* AIRPCAP_HANDLE__EAE405F5_0171_9592_B3C2_C19EC426AD34__DEFINED_ */
#endif /* HAVE_AIRPCAP_API */

// Libpcap/wpcap recognizes this macro and knows Npcap Packet API is provided for compilation.
#define HAVE_NPCAP_PACKET_API

// These items were deprecated/unused in WinPcap and remain deprecated in Npcap
#define PACKET_WINPCAP_DEPRECATED __declspec(deprecated("Deprecated prior to WinPcap 4"))
// Internal struct members should not be addressed directly; use Packet API functions instead.
#ifndef PACKET_DEPRECATED_INTERNAL_STRUCT_DEFINITIONS_OK
#define PACKET_DEPRECATED_INTERNAL_STRUCT_DEFINITION __declspec(deprecated("Packet API internal-only struct member access is deprecated."))
#else
#define PACKET_DEPRECATED_INTERNAL_STRUCT_DEFINITION
#endif

// Working modes, a 32-bit integer
// 0x000000ff: WinPcap legacy modes (least-significant byte)
// 0b00000000
//      |  ||_ STAT or CAPT
//      |  |__ MON (TME extensions, not supported)
//      |      UNUSED
//      |      UNUSED
//      |_____ DUMP (not supported)
#define PACKET_MODE_CAPT 0x0 ///< Capture mode
#define PACKET_MODE_STAT 0x1 ///< Statistical mode
#define PACKET_MODE_MON 0x2 ///< Monitoring mode
#define PACKET_MODE_DUMP 0x10 ///< Dump mode
#define PACKET_MODE_STAT_DUMP PACKET_MODE_DUMP | PACKET_MODE_STAT ///< Statistical dump Mode
// 0x0000ff00: Npcap extensions
// 0b00000000
//        |||_ SENDTORX
//        ||__ SENDTORX_CLEAR
//        |___ NANO
#define PACKET_MODE_SENDTORX       (1 << 8)  /// SendToRx mode
#define PACKET_MODE_SENDTORX_CLEAR (1 << 9)  /// Disable SendToRx, overriding Registry
#define PACKET_MODE_NANO           (1 << 10) /// Nanosecond precision timestamps


/// Alignment macro. Defines the alignment size.
#define Packet_ALIGNMENT sizeof(int)
/// Alignment macro. Rounds up to the next even multiple of Packet_ALIGNMENT. 
#define Packet_WORDALIGN(x) (((x)+(Packet_ALIGNMENT-1))&~(Packet_ALIGNMENT-1))

#define NdisMediumNull	-1		///< Custom linktype: NDIS doesn't provide an equivalent
#define NdisMediumCHDLC	-2		///< Custom linktype: NDIS doesn't provide an equivalent
#define NdisMediumPPPSerial	-3	///< Custom linktype: NDIS doesn't provide an equivalent
#define NdisMediumBare80211	-4	///< Custom linktype: NDIS doesn't provide an equivalent
#define NdisMediumRadio80211	-5	///< Custom linktype: NDIS doesn't provide an equivalent
#define NdisMediumPpi		-6	///< Custom linktype: NDIS doesn't provide an equivalent

// Loopback behaviour definitions
#define NPF_DISABLE_LOOPBACK	1	///< Drop the packets sent by the NPF driver
#define NPF_ENABLE_LOOPBACK		2	///< Capture the packets sent by the NPF driver

// Timestamp Modes
#define TIMESTAMPMODE_SINGLE_SYNCHRONIZATION 0 // KeQueryPerformanceCounter
#define TIMESTAMPMODE_QUERYSYSTEMTIME 2 // KeQuerySystemTime
#define TIMESTAMPMODE_QUERYSYSTEMTIME_PRECISE 4 // KeQuerySystemTimePrecise, Windows 8 and newer

/*!
  \brief Network type structure.

  This structure is used by the PacketGetNetType() function to return information on the current adapter's type.
*/
typedef struct NetType
{
	UINT LinkType;	///< The MAC of the current network adapter (see function PacketGetNetType() for more information)
	ULONGLONG LinkSpeed;	/// UNUSED, set to 0
}NetType;


#define 	   DOSNAMEPREFIX   TEXT("Packet_")	///< Prefix added to the adapters device names to create the WinPcap devices
#define 	   MAX_LINK_NAME_LENGTH	64			//< Maximum length of the devices symbolic links
#define 	   NMAX_PACKET 65535

/*!
  \brief Addresses of a network adapter.

  This structure is used by the PacketGetNetInfoEx() function to return the IP addresses associated with 
  an adapter.
*/
typedef struct npf_if_addr
{
	struct sockaddr_storage IPAddress;	///< IP address.
	struct sockaddr_storage SubnetMask;	///< Netmask for that address.
	struct sockaddr_storage Broadcast;	///< Broadcast address.
}npf_if_addr;


#define ADAPTER_NAME_LENGTH 256 + 12	///<  Maximum length for the name of an adapter. The value is the same used by the IP Helper API.
#define ADAPTER_DESC_LENGTH 128			///<  Maximum length for the description of an adapter. The value is the same used by the IP Helper API.
#define MAX_MAC_ADDR_LENGTH 8			///<  Maximum length for the link layer address of an adapter. The value is the same used by the IP Helper API.
#define MAX_NETWORK_ADDRESSES 16		///<  Maximum length for the link layer address of an adapter. The value is the same used by the IP Helper API.


typedef struct WAN_ADAPTER_INT WAN_ADAPTER; ///< Describes an opened wan (dialup, VPN...) network adapter using the NetMon API
typedef WAN_ADAPTER* PWAN_ADAPTER; ///< Describes an opened wan (dialup, VPN...) network adapter using the NetMon API

#define INFO_FLAG_NDIS_ADAPTER		0	///< Flag for ADAPTER_INFO: this is a traditional ndis adapter
#define INFO_FLAG_NDISWAN_ADAPTER	1	///< Flag for ADAPTER_INFO: this is a NdisWan adapter, and it's managed by WANPACKET
#define INFO_FLAG_DAG_CARD			2	///< Flag for ADAPTER_INFO: this is a DAG card
#define INFO_FLAG_DAG_FILE			6	///< Flag for ADAPTER_INFO: this is a DAG file
#define INFO_FLAG_DONT_EXPORT		8	///< Flag for ADAPTER_INFO: when this flag is set, the adapter will not be listed or openend by winpcap. This allows to prevent exporting broken network adapters, like for example FireWire ones.
#define INFO_FLAG_AIRPCAP_CARD		16	///< Flag for ADAPTER_INFO: this is an airpcap card
#define INFO_FLAG_NPFIM_DEVICE		32 /// NPFIM device, not supported
#define INFO_FLAG_MASK_NOT_NPF 0xff /// If any of these bits are set, it's not a NPF/Npcap-managed adapter.
#define INFO_FLAG_NPCAP_LOOPBACK 0x100 // Npcap loopback adapter
#define INFO_FLAG_NPCAP_DOT11 0x200 // Npcap dot11_support raw Wifi frame capture

/*!
  \brief Describes an opened network adapter.

  This structure is the most important for the functioning of packet.dll, but the great part of its fields
  should be ignored by the user, since the library offers functions that avoid to cope with low-level parameters
*/
typedef struct _ADAPTER
{
	PACKET_DEPRECATED_INTERNAL_STRUCT_DEFINITION HANDLE hFile;				///< \internal Handle to an open instance of the NPF driver.
	PACKET_DEPRECATED_INTERNAL_STRUCT_DEFINITION CHAR SymbolicLink[MAX_LINK_NAME_LENGTH]; ///< \internal A string containing the name of the network adapter currently opened.
	PACKET_DEPRECATED_INTERNAL_STRUCT_DEFINITION int NumWrites;				///< \internal Number of times a packets written on this adapter will be repeated 
	///< on the wire.
	PACKET_DEPRECATED_INTERNAL_STRUCT_DEFINITION HANDLE ReadEvent;			///< A notification event associated with the read calls on the adapter.
	///< It can be passed to standard Win32 functions (like WaitForSingleObject
	///< or WaitForMultipleObjects) to wait until the driver's buffer contains some 
	///< data. It is particularly useful in GUI applications that need to wait 
	///< concurrently on several events. The PacketSetMinToCopy()
	///< function can be used to define the minimum amount of data in the kernel buffer
	///< that will cause the event to be signalled. 

	PACKET_DEPRECATED_INTERNAL_STRUCT_DEFINITION UINT ReadTimeOut;  ///< \internal The amount of time PacketReceivePacket will wait for the ReadEvent to be signalled before issuing a ReadFile.
	PACKET_DEPRECATED_INTERNAL_STRUCT_DEFINITION CHAR Name[ADAPTER_NAME_LENGTH];
	PACKET_DEPRECATED_INTERNAL_STRUCT_DEFINITION PWAN_ADAPTER pWanAdapter;
	PACKET_DEPRECATED_INTERNAL_STRUCT_DEFINITION UINT Flags;					///< Adapter's flags. Tell if this adapter must be treated in a different way.

#ifdef HAVE_AIRPCAP_API
	PACKET_DEPRECATED_INTERNAL_STRUCT_DEFINITION PAirpcapHandle AirpcapAd;
#endif // HAVE_AIRPCAP_API
}  ADAPTER, * LPADAPTER;

/*!
  \brief Structure that contains a group of packets coming from the driver.

  This structure defines the header associated with every packet delivered to the application.
*/
typedef struct _PACKET
{
	PACKET_WINPCAP_DEPRECATED HANDLE hEvent;		///< \deprecated Still present for compatibility with old applications.
	PACKET_WINPCAP_DEPRECATED OVERLAPPED OverLapped;	///< \deprecated Still present for compatibility with old applications.
	_Field_size_bytes_part_(Length, ulBytesReceived)
	PVOID Buffer;		///< Buffer with containing the packets. See the PacketReceivePacket() for
	///< details about the organization of the data in this buffer
	UINT Length;		///< Length of the buffer
	DWORD ulBytesReceived;	///< Number of valid bytes present in the buffer, i.e. amount of data
	///< received by the last call to PacketReceivePacket()
	PACKET_WINPCAP_DEPRECATED BOOLEAN bIoComplete;	///< \deprecated Still present for compatibility with old applications.
}  PACKET, * LPPACKET;


#ifdef __cplusplus
extern "C"
{
#endif

	/**
	 *  @}
	 */

	//---------------------------------------------------------------------------
	// EXPORTED FUNCTIONS
	//---------------------------------------------------------------------------

	LPCSTR PacketGetVersion();
	LPCSTR PacketGetDriverVersion();
	LPCSTR PacketGetDriverName();
	_Success_(return) BOOLEAN PacketSetMinToCopy(_In_ LPADAPTER AdapterObject, _In_ int nbytes);
	_Success_(return) BOOLEAN PacketSetNumWrites(_In_ LPADAPTER AdapterObject, _In_ int nwrites);
	_Success_(return) BOOLEAN PacketSetMode(_In_ LPADAPTER AdapterObject, _In_ int mode);
	_Success_(return) BOOLEAN PacketSetReadTimeout(_In_ LPADAPTER AdapterObject, _In_ int timeout);
	_Success_(return) BOOLEAN PacketSetBpf(_In_ LPADAPTER AdapterObject, _In_ struct bpf_program* fp);
	_Success_(return) BOOLEAN PacketSetLoopbackBehavior(_In_ LPADAPTER  AdapterObject, _In_ UINT LoopbackBehavior);
	_Success_(return) BOOLEAN PacketSetTimestampMode(_In_ LPADAPTER AdapterObject, _In_ ULONG mode);
	_Success_(return) BOOLEAN PacketGetTimestampModes(_In_ LPADAPTER AdapterObject, _Inout_updates_to_(pModes[0], pModes[0]) PULONG pModes);
	INT PacketSetSnapLen(_In_ LPADAPTER AdapterObject, _In_ int snaplen);
	_Success_(return) BOOLEAN PacketGetStats(_In_ LPADAPTER AdapterObject, _Out_ struct bpf_stat* s);
	_Success_(return) BOOLEAN PacketGetStatsEx(_In_ LPADAPTER AdapterObject, _Out_ struct bpf_stat* s);
	_Success_(return) BOOLEAN PacketSetBuff(_In_ LPADAPTER AdapterObject, _In_ int dim);
	_Success_(return) BOOLEAN PacketGetNetType(_In_ LPADAPTER AdapterObject, _Out_ NetType* type);
	BOOLEAN PacketIsLoopbackAdapter(_In_ PCCH AdapterName);
	int PacketIsMonitorModeSupported(_In_ PCCH AdapterName);
	int PacketSetMonitorMode(_In_ PCCH AdapterName, _In_ int mode);
	int PacketGetMonitorMode(_In_ PCCH AdapterName);
	_Ret_maybenull_ LPADAPTER PacketOpenAdapter(_In_ PCCH AdapterName);
	_Success_(return) BOOLEAN PacketSendPacket(_In_ LPADAPTER AdapterObject, _In_ LPPACKET pPacket, _In_ BOOLEAN Sync);
	INT PacketSendPackets(_In_ LPADAPTER AdapterObject, _In_ PVOID PacketBuff, _In_ ULONG Size, _In_ BOOLEAN Sync);
	LPPACKET PacketAllocatePacket(void);
	VOID PacketInitPacket(_Out_ LPPACKET lpPacket, _In_reads_bytes_(Length) PVOID  Buffer, _In_ UINT  Length);
	VOID PacketFreePacket(_In_ _Post_invalid_ LPPACKET lpPacket);
	_Success_(return) BOOLEAN PacketReceivePacket(_In_ LPADAPTER AdapterObject, _Inout_updates_bytes_(lpPacket->Length) LPPACKET lpPacket, _In_ BOOLEAN Sync);
	_Success_(return) BOOLEAN PacketSetHwFilter(_In_ LPADAPTER AdapterObject, _In_ ULONG Filter);
	_Success_(return) BOOLEAN PacketGetAdapterNames(_Out_writes_opt_(_Old_(*BufferSize)) PCHAR pStr, _Inout_ PULONG  BufferSize);
	_Success_(return) BOOLEAN PacketGetNetInfoEx(_In_ PCCH AdapterName, _Out_writes_to_(_Old_(*NEntries),*NEntries) npf_if_addr* buffer, _Inout_ PLONG NEntries);
	_Success_(return) BOOLEAN PacketRequest(_In_ LPADAPTER  AdapterObject, _In_ BOOLEAN Set, _Inout_updates_bytes_(PACKET_OID_DATA_LENGTH(OidData->Length)) PPACKET_OID_DATA  OidData);
	_Success_(return) BOOLEAN PacketGetInfo(_In_opt_ LPADAPTER AdapterObject, _Inout_updates_bytes_(PACKET_OID_DATA_LENGTH(OidData->Length)) PPACKET_OID_DATA OidData);
	HANDLE PacketGetReadEvent(_In_ LPADAPTER AdapterObject);
	__declspec(deprecated("Kernel dump mode is not supported")) BOOLEAN PacketSetDumpName(LPADAPTER AdapterObject, void* name, int len);
	__declspec(deprecated("Kernel dump mode is not supported")) BOOLEAN PacketSetDumpLimits(LPADAPTER AdapterObject, UINT maxfilesize, UINT maxnpacks);
	__declspec(deprecated("Kernel dump mode is not supported")) BOOLEAN PacketIsDumpEnded(LPADAPTER AdapterObject, BOOLEAN sync);
	BOOL PacketStopDriver();
	BOOL PacketStopDriver60();
	VOID PacketCloseAdapter(_In_ _Post_invalid_ LPADAPTER lpAdapter);
	__declspec(deprecated("Deprecated WinPcap Pro function")) BOOLEAN PacketStartOem(PCHAR errorString, UINT errorStringLength);
	__declspec(deprecated("Deprecated WinPcap Pro function")) BOOLEAN PacketStartOemEx(PCHAR errorString, UINT errorStringLength, ULONG flags);
	PAirpcapHandle PacketGetAirPcapHandle(_In_ LPADAPTER AdapterObject);

	//
	// Used by PacketStartOemEx
	//
#define PACKET_START_OEM_NO_NETMON	0x00000001

#ifdef __cplusplus
}
#endif 

#endif //__PACKET32

```

`Common/WpcapNames.h`:

```h
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
/*
 * Copyright (c) 2005-2007 CACE Technologies
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of CACE Technologies nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
#ifndef __WPCAPNAMES_H_EED6D131C6DB4dd696757D219977A7E5
#define __WPCAPNAMES_H_EED6D131C6DB4dd696757D219977A7E5


//
// Original names
//
//  NOTE: 
//  - please do not use prefix names longer than 70 chars. 
//  - the following characters are surely accepted in the prefixes:  "[A-Z][a-z][0-9]_-',"   
//
#define NPF_DRIVER_NAME							"NPCAP"												///< (HHH) Packet.dll
#define NPF_DRIVER_NAME_WIDECHAR				L"NPCAP"											///< (HHH) Packet.dll
#define NPF_DRIVER_NAME_SMALL					"npcap"												///< (HHH) Packet.dll
#define NPF_DRIVER_NAME_SMALL_WIDECHAR			L"npcap"											///< (HHH) Packet.dll

#define NPF_DRIVER_NAME_SMALL_WIFI				NPF_DRIVER_NAME_SMALL "_wifi"
#define NPF_DRIVER_NAME_SMALL_WIDECHAR_WIFI		NPF_DRIVER_NAME_SMALL_WIDECHAR L"_wifi"

// Used as a logo string in NPFInstall
#define NPF_DRIVER_NAME_NORMAL					"Npcap"												///< (HHH) Packet.dll
#define NPF_DRIVER_NAME_NORMAL_WIDECHAR			L"Npcap"											///< (HHH) Packet.dll

// Used as the registry software key name
#define NPF_SOFT_REGISTRY_NAME					"NPCAP"												///< (HHH) Packet.dll
#define NPF_SOFT_REGISTRY_NAME_WIDECHAR			L"NPCAP"											///< (HHH) Packet.dll

#define NPF_ORGAN_NAME							"INSECURE"											///< (HHH) Packet.dll
#define NPF_ORGAN_NAME_WIDECHAR					L"INSECURE"											///< (HHH) Packet.dll

//
// Derived strings
//

// Used in packetWin7\Dll and the driver
#define NPF_DEVICE_NAMES_PREFIX					NPF_DRIVER_NAME "\\"     								///< (AAA) packet.dll
#define NPF_DEVICE_NAMES_PREFIX_WIDECHAR		NPF_DRIVER_NAME_WIDECHAR L"\\"     						///< (AAA) used by the NPF driver, that does not accept the TEXT(a) macro correctly.
#define NPF_DEVICE_NAMES_TAG_WIFI "WIFI_"
#define NPF_DEVICE_NAMES_TAG_WIDECHAR_WIFI L"WIFI_"
#define NPF_DEVICE_NAMES_PREFIX_WIFI			NPF_DEVICE_NAMES_PREFIX NPF_DEVICE_NAMES_TAG_WIFI
#define NPF_DEVICE_NAMES_PREFIX_WIDECHAR_WIFI	NPF_DEVICE_NAMES_PREFIX_WIDECHAR NPF_DEVICE_NAMES_TAG_WIDECHAR_WIFI

// Used in packetWin7\Dll
#define FAKE_LOOPBACK_ADAPTER_NAME "\\Device\\" NPF_DRIVER_NAME "\\Loopback"	///< (CCC) Name of a fake loopback adapter
#define FAKE_LOOPBACK_ADAPTER_DESCRIPTION "Adapter for loopback traffic capture" ///< (DDD) Description of a fake loopback adapter that is always available

// Used in packetWin7\Dll, NPFInstall and the driver
#define NPF_SERVICE_DESC						NPF_DRIVER_NAME_NORMAL " Packet Driver (" NPF_DRIVER_NAME ")"						///< (FFF) packet.dll
#define NPF_SERVICE_DESC_WIDECHAR				NPF_DRIVER_NAME_NORMAL_WIDECHAR L" Packet Driver (" NPF_DRIVER_NAME_WIDECHAR L")"	///< (FFF) packet.dll
#define NPF_SERVICE_DESC_TCHAR					_T(NPF_DRIVER_NAME_NORMAL) _T(" Packet Driver (") _T(NPF_DRIVER_NAME) _T(")")		///< (FFF) packet.dll
#define NPF_SERVICE_DESC_WIFI					NPF_SERVICE_DESC " (WiFi version)"
#define NPF_SERVICE_DESC_WIDECHAR_WIFI			NPF_SERVICE_DESC_WIDECHAR L" (WiFi version)"
#define NPF_SERVICE_DESC_TCHAR_WIFI				NPF_SERVICE_DESC_TCHAR _T(" (WiFi version)")

// Used in packetWin7\Dll
#define NPF_DRIVER_COMPLETE_DEVICE_PREFIX		"\\Device\\" NPF_DEVICE_NAMES_PREFIX					///< (III) packet.dll
// Used in packetWin7\Dll
#define NPF_DRIVER_COMPLETE_PATH				"system32\\drivers\\" NPF_DRIVER_NAME ".sys"			///< (LLL) packet.dll


//
// WinPcap Global Registry Key
//
#define WINPCAP_GLOBAL_KEY						"SOFTWARE\\CaceTech\\WinPcapOem"
#define WINPCAP_GLOBAL_KEY_WIDECHAR				L"SOFTWARE\\CaceTech\\WinPcapOem"
#define WINPCAP_INSTANCE_KEY					WINPCAP_GLOBAL_KEY "\\" NPF_DRIVER_NAME
#define WINPCAP_INSTANCE_KEY_WIDECHAR			WINPCAP_GLOBAL_KEY_WIDECHAR	L"\\" NPF_DRIVER_NAME_WIDECHAR
#define MAX_WINPCAP_KEY_CHARS					512

#endif //__WPCAPNAMES_H_EED6D131C6DB4dd696757D219977A7E5


```

`Common/npcap-bpf.h`:

```h
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
/* Portions of this file
 * Copyright (c) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from the Stanford/CMU enet packet filter,
 * (net/enet.c) distributed as part of 4.3BSD, and code contributed
 * to Berkeley by Steven McCanne and Van Jacobson both of Lawrence 
 * Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *  	This product includes software developed by the University of
 *  	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */
#ifndef NPCAP_BPF_H
#define NPCAP_BPF_H

/* These are defined by libpcap's bpf.h, so if that has already been included,
 * we want to avoid redefining them here.
 */
#ifndef lib_pcap_bpf_h

#ifndef _NTDDK_
#include <winsock2.h>
#endif

/*!
  \brief A BPF pseudo-assembly program.

  The program will be injected in the kernel by the PacketSetBPF() function and applied to every incoming packet. 
*/
struct bpf_program
{
	UINT bf_len; ///< Indicates the number of instructions of the program, i.e. the number of struct bpf_insn that will follow.
#ifdef _Field_size_full_  /* SAL annotation */
	_Field_size_full_(bf_len)
#endif
	struct bpf_insn* bf_insns; ///< A pointer to the first instruction of the program.
};

/*!
  \brief A single BPF pseudo-instruction.

  bpf_insn contains a single instruction for the BPF register-machine. It is used to send a filter program to the driver.
*/
struct bpf_insn
{
	USHORT code; ///< Instruction type and addressing mode.
	UCHAR jt;    ///< Jump if true
	UCHAR jf;    ///< Jump if false
	ULONG k;     ///< Generic field used for various purposes.
};

/*!
  \brief Structure that contains a couple of statistics values on the current capture.

  It is used by packet.dll to return statistics about a capture session.
*/
struct bpf_stat
{
	UINT bs_recv;  ///< Number of packets that the driver received from the network adapter 
	///< from the beginning of the current capture. This value includes the packets 
	///< lost by the driver.
	UINT bs_drop;  ///< number of packets that the driver lost from the beginning of a capture. 
	///< Basically, a packet is lost when the the buffer of the driver is full. 
	///< In this situation the packet cannot be stored and the driver rejects it.
	UINT ps_ifdrop; ///< drops by interface. XXX not yet supported
	UINT bs_capt;	///< number of packets that pass the filter, find place in the kernel buffer and
	///< thus reach the application.
};

/* Current version number of filter architecture. */
#define BPF_MAJOR_VERSION 1
#define BPF_MINOR_VERSION 1

/*!
  \brief Packet header.

  This structure defines the header associated with every packet delivered to the application.
*/
struct bpf_hdr
{
	struct timeval bh_tstamp; ///< The timestamp associated with the captured packet. 
	///< It is stored in a TimeVal structure.
	UINT bh_caplen;   ///< Length of captured portion. The captured portion <b>can be different</b>
	///< from the original packet, because it is possible (with a proper filter)
	///< to instruct the driver to capture only a portion of the packets.
	UINT bh_datalen;  ///< Original length of packet
	USHORT bh_hdrlen; ///< Length of bpf header (this struct plus alignment padding). In some cases,
	///< a padding could be added between the end of this structure and the packet
	///< data for performance reasons. This filed can be used to retrieve the actual data 
	///< of the packet.
};

/*!
  \brief Dump packet header.

  This structure defines the header associated with the packets in a buffer to be used with PacketSendPackets().
  It is simpler than the bpf_hdr, because it corresponds to the header in the pcap-savefile(5) format.
  This makes straightforward sending WinPcap dump files to the network.
*/
struct dump_bpf_hdr
{
	struct timeval ts; ///< Time stamp of the packet
	UINT caplen; ///< Length of captured portion. The captured portion can smaller than the 
	///< the original packet, because it is possible (with a proper filter) to 
	///< instruct the driver to capture only a portion of the packets. 
	UINT len; ///< Length of the original packet (off wire).
};

#endif /* lib_pcap_bpf_h */

/* BPF extensions */
/* Special offsets to mimic Linux kernel's BPF extensions.
 * The names are modeled off of Linux, though the values are different.
 * Code that uses Linux's SKF_AD_* constants, like libpcap's
 * gencode.c, can generally use the same code for Npcap.
 */
/* The base offset for these extensions */
#define NPCAP_AD_OFF (-0x1000)
/* The extensions are numbered in the order they were added.
 * Since they are treated like offsets, we space them by 4 to avoid the
 * appearance of reading overlapped memory segments.
 * User can issue BIOCGETINFO(NPF_GETINFO_BPFEXT) to retrieve the value of
 * NPCAP_AD_MAX, and any extension less than or equal to that value will be
 * supported. This is the same logic as Linux uses with the SO_BPF_EXTENSIONS socket option.
 */
/* Halfword (2 bytes) representing the 802.1q header. */
#define NPCAP_AD_VLAN_TAG 0
/* Boolean: is there VLAN metadata present? Currently, we cannot distinguish VLAN
 * 0 and priority class 0 (both defaults) from the case of no VLAN tag present,
 * so this will return false in that case. */
#define NPCAP_AD_VLAN_TAG_PRESENT 4
#define NPCAP_AD_MAX 4

/* Npcap SDK 1.15 defined these names instead, so they are preserved here for
 * compatibility and to simplify integration with existing Linux-targeted code.
 * However, it is preferred to use the NPCAP_AD_* prefix in new code. */
#ifndef SKF_AD_OFF
#define SKF_AD_OFF              NPCAP_AD_OFF
#define SKF_AD_VLAN_TAG         NPCAP_AD_VLAN_TAG
#define SKF_AD_VLAN_TAG_PRESENT NPCAP_AD_VLAN_TAG_PRESENT
#define SKF_AD_MAX              NPCAP_AD_MAX
#endif

#endif /* NPCAP_BPF_H */

```

`Common/npcap-defs.h`:

```h
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
/*
 * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)
 * Copyright (c) 2005 - 2010 CACE Technologies, Davis (California)
 * Copyright (c) 2010 - 2013 Riverbed Technology, San Francisco (California), Yang Luo (China)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Politecnico di Torino, CACE Technologies
 * nor the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
#ifndef NPCAP_DEFS_H
#define NPCAP_DEFS_H
/* Data structures and constants used by Npcap's driver and DLLs. */

typedef unsigned long ULONG;
typedef unsigned char UCHAR;

/*!
  \brief Structure containing an OID request.

  It is used by the PacketRequest() function to send an OID to the interface card driver. 
  It can be used, for example, to retrieve the status of the error counters on the adapter, its MAC address, 
  the list of the multicast groups defined on it, and so on.
*/
struct _PACKET_OID_DATA
{
	ULONG Oid; ///< OID code. See the Microsoft DDK documentation or the file ntddndis.h
	///< for a complete list of valid codes.
	ULONG Length; ///< Length of the data field
#ifdef _Field_size_full_  /* SAL annotation */
	_Field_size_full_(Length)
#endif
	UCHAR Data[1]; ///< variable-length field that contains the information passed to or received
	///< from the adapter.
}; 
typedef struct _PACKET_OID_DATA PACKET_OID_DATA, * PPACKET_OID_DATA;
#ifdef C_ASSERT
C_ASSERT(sizeof(PACKET_OID_DATA) == 12);
#endif

#define PACKET_OID_DATA_LENGTH(_DataLength) \
	(FIELD_OFFSET(PACKET_OID_DATA, Data) + _DataLength)

/* Info IDs for PacketGetInfo/BIOCGETINFO */
// Version of driver. Output is ULONG in MMmmbbbb format
#define NPF_GETINFO_VERSION 0x00000001
// Bitfield of capabilities, configs, and build attributes. Output is ULONG.
#define NPF_GETINFO_CONFIG 0x00000002
#define NPF_CONFIG_OEM       0x01 /* Npcap OEM */
#define NPF_CONFIG_INJECT    0x02 /* ifndef NPCAP_READ_ONLY */
#define NPF_CONFIG_ADMINONLY 0x04 /* AdminOnly */
#define NPF_CONFIG_DLTNULL   0x08 /* DltNull */
#define NPF_CONFIG_WIFI      0x10 /* Dot11Support */
#define NPF_CONFIG_LOOPBACK  0x20 /* LoopbackSupport */
#define NPF_CONFIG_TESTMODE  0x40 /* TestMode */
// BPF Extensions supported. Output is ULONG, max extension supported.
#define NPF_GETINFO_BPFEXT 0x00000003
// Supported mode bits for BIOCSMODE (PacketSetMode, pcap_setmode). Output is ULONG.
#define NPF_GETINFO_MODES 0x00000004
// Performance statistics for the filter module
#define NPF_GETINFO_STATS 0x00000005
// All of these are 2 USHORTs: average for last 10 and last 10K calls
#define NPF_STATSINFO_RECVTIMES 0x00000001 /* ticks per recieve indication */
#define NPF_STATSINFO_SENDTIMES 0x00000002 /* ticks per send indication */
#define NPF_STATSINFO_DPCTIMES  0x00000003 /* ticks at DPC level, both dirs */
// Internal debugging info unique to a filter module
#define NPF_GETINFO_MODDBG 0x00000006
// Subrequests of NPF_GETINFO_MODDBG
#define NPF_MODDBG_PF_SUPPORTED 0x00000001
#define NPF_MODDBG_PF_MY        0x00000002
#define NPF_MODDBG_PF_HIGHER    0x00000003
#define NPF_MODDBG_LA_MY        0x00000004
#define NPF_MODDBG_LA_HIGHER    0x00000005
#define NPF_MODDBG_BITS         0x00000006
#define NPF_MODDBG_MAXFRAME     0x00000007
#define NPF_MODDBG_NUMOPENS     0x00000008

#endif /* NPCAP_DEFS_H */

```

`Examples-pcap/GNUmakefile`:

```
# Makefile for cygwin gcc
# Nate Lawson <nate@rootlabs.com>

SUBDIRS = basic_dump basic_dump_ex iflist pcap_filter pktdump_ex readfile readfile_ex savedump sendpack UDPdump

all clean install uninstall: ${SUBDIRS}
	for subdir in ${SUBDIRS}; do \
		echo "Entering $$subdir"; \
		(cd $$subdir && ${MAKE} $@) \
	done;

```

`Examples-pcap/MakeAll.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31229.75
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "basic_dump", "basic_dump\basic_dump.vcxproj", "{66297062-96A0-4F0E-B147-3C8384031232}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "basic_dump_ex", "basic_dump_ex\basic_dump_ex.vcxproj", "{92849630-6B09-409C-A7AD-E91E682558B1}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "iflist", "iflist\iflist.vcxproj", "{0B27B213-4BF3-4611-B412-A2D09CDE8632}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "pcap_filter", "pcap_filter\pcap_filter.vcxproj", "{B9F68F6F-22AE-47A2-A3A3-1212831AF9FF}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "pktdump_ex", "pktdump_ex\pktdump_ex.vcxproj", "{3D62DEB4-3536-44AE-8E4B-AD6DFF1B795E}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "readfile", "readfile\readfile.vcxproj", "{161E7606-F4CD-4A04-AB6B-5837F7818EE1}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "readfile_ex", "readfile_ex\readfile_ex.vcxproj", "{3071DFB6-68F8-41EF-A56C-0C7A71B6967C}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "savedump", "savedump\savedump.vcxproj", "{1B8791CB-DD15-46BF-B0A2-879892085538}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "sendpack", "sendpack\sendpack.vcxproj", "{1C376689-5F61-48E7-AE83-0DED9EE9E458}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "UDPdump", "UDPdump\UDPdump.vcxproj", "{42E5F1D6-6E83-4C13-83CC-C6CD83478C58}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{66297062-96A0-4F0E-B147-3C8384031232}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{66297062-96A0-4F0E-B147-3C8384031232}.Debug|ARM64.Build.0 = Debug|ARM64
		{66297062-96A0-4F0E-B147-3C8384031232}.Debug|x64.ActiveCfg = Debug|x64
		{66297062-96A0-4F0E-B147-3C8384031232}.Debug|x64.Build.0 = Debug|x64
		{66297062-96A0-4F0E-B147-3C8384031232}.Debug|x86.ActiveCfg = Debug|Win32
		{66297062-96A0-4F0E-B147-3C8384031232}.Debug|x86.Build.0 = Debug|Win32
		{66297062-96A0-4F0E-B147-3C8384031232}.Release|ARM64.ActiveCfg = Release|ARM64
		{66297062-96A0-4F0E-B147-3C8384031232}.Release|ARM64.Build.0 = Release|ARM64
		{66297062-96A0-4F0E-B147-3C8384031232}.Release|x64.ActiveCfg = Release|x64
		{66297062-96A0-4F0E-B147-3C8384031232}.Release|x64.Build.0 = Release|x64
		{66297062-96A0-4F0E-B147-3C8384031232}.Release|x86.ActiveCfg = Release|Win32
		{66297062-96A0-4F0E-B147-3C8384031232}.Release|x86.Build.0 = Release|Win32
		{92849630-6B09-409C-A7AD-E91E682558B1}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{92849630-6B09-409C-A7AD-E91E682558B1}.Debug|ARM64.Build.0 = Debug|ARM64
		{92849630-6B09-409C-A7AD-E91E682558B1}.Debug|x64.ActiveCfg = Debug|x64
		{92849630-6B09-409C-A7AD-E91E682558B1}.Debug|x64.Build.0 = Debug|x64
		{92849630-6B09-409C-A7AD-E91E682558B1}.Debug|x86.ActiveCfg = Debug|Win32
		{92849630-6B09-409C-A7AD-E91E682558B1}.Debug|x86.Build.0 = Debug|Win32
		{92849630-6B09-409C-A7AD-E91E682558B1}.Release|ARM64.ActiveCfg = Release|ARM64
		{92849630-6B09-409C-A7AD-E91E682558B1}.Release|ARM64.Build.0 = Release|ARM64
		{92849630-6B09-409C-A7AD-E91E682558B1}.Release|x64.ActiveCfg = Release|x64
		{92849630-6B09-409C-A7AD-E91E682558B1}.Release|x64.Build.0 = Release|x64
		{92849630-6B09-409C-A7AD-E91E682558B1}.Release|x86.ActiveCfg = Release|Win32
		{92849630-6B09-409C-A7AD-E91E682558B1}.Release|x86.Build.0 = Release|Win32
		{0B27B213-4BF3-4611-B412-A2D09CDE8632}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{0B27B213-4BF3-4611-B412-A2D09CDE8632}.Debug|ARM64.Build.0 = Debug|ARM64
		{0B27B213-4BF3-4611-B412-A2D09CDE8632}.Debug|x64.ActiveCfg = Debug|x64
		{0B27B213-4BF3-4611-B412-A2D09CDE8632}.Debug|x64.Build.0 = Debug|x64
		{0B27B213-4BF3-4611-B412-A2D09CDE8632}.Debug|x86.ActiveCfg = Debug|Win32
		{0B27B213-4BF3-4611-B412-A2D09CDE8632}.Debug|x86.Build.0 = Debug|Win32
		{0B27B213-4BF3-4611-B412-A2D09CDE8632}.Release|ARM64.ActiveCfg = Release|ARM64
		{0B27B213-4BF3-4611-B412-A2D09CDE8632}.Release|ARM64.Build.0 = Release|ARM64
		{0B27B213-4BF3-4611-B412-A2D09CDE8632}.Release|x64.ActiveCfg = Release|x64
		{0B27B213-4BF3-4611-B412-A2D09CDE8632}.Release|x64.Build.0 = Release|x64
		{0B27B213-4BF3-4611-B412-A2D09CDE8632}.Release|x86.ActiveCfg = Release|Win32
		{0B27B213-4BF3-4611-B412-A2D09CDE8632}.Release|x86.Build.0 = Release|Win32
		{B9F68F6F-22AE-47A2-A3A3-1212831AF9FF}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{B9F68F6F-22AE-47A2-A3A3-1212831AF9FF}.Debug|ARM64.Build.0 = Debug|ARM64
		{B9F68F6F-22AE-47A2-A3A3-1212831AF9FF}.Debug|x64.ActiveCfg = Debug|x64
		{B9F68F6F-22AE-47A2-A3A3-1212831AF9FF}.Debug|x64.Build.0 = Debug|x64
		{B9F68F6F-22AE-47A2-A3A3-1212831AF9FF}.Debug|x86.ActiveCfg = Debug|Win32
		{B9F68F6F-22AE-47A2-A3A3-1212831AF9FF}.Debug|x86.Build.0 = Debug|Win32
		{B9F68F6F-22AE-47A2-A3A3-1212831AF9FF}.Release|ARM64.ActiveCfg = Release|ARM64
		{B9F68F6F-22AE-47A2-A3A3-1212831AF9FF}.Release|ARM64.Build.0 = Release|ARM64
		{B9F68F6F-22AE-47A2-A3A3-1212831AF9FF}.Release|x64.ActiveCfg = Release|x64
		{B9F68F6F-22AE-47A2-A3A3-1212831AF9FF}.Release|x64.Build.0 = Release|x64
		{B9F68F6F-22AE-47A2-A3A3-1212831AF9FF}.Release|x86.ActiveCfg = Release|Win32
		{B9F68F6F-22AE-47A2-A3A3-1212831AF9FF}.Release|x86.Build.0 = Release|Win32
		{3D62DEB4-3536-44AE-8E4B-AD6DFF1B795E}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{3D62DEB4-3536-44AE-8E4B-AD6DFF1B795E}.Debug|ARM64.Build.0 = Debug|ARM64
		{3D62DEB4-3536-44AE-8E4B-AD6DFF1B795E}.Debug|x64.ActiveCfg = Debug|x64
		{3D62DEB4-3536-44AE-8E4B-AD6DFF1B795E}.Debug|x64.Build.0 = Debug|x64
		{3D62DEB4-3536-44AE-8E4B-AD6DFF1B795E}.Debug|x86.ActiveCfg = Debug|Win32
		{3D62DEB4-3536-44AE-8E4B-AD6DFF1B795E}.Debug|x86.Build.0 = Debug|Win32
		{3D62DEB4-3536-44AE-8E4B-AD6DFF1B795E}.Release|ARM64.ActiveCfg = Release|ARM64
		{3D62DEB4-3536-44AE-8E4B-AD6DFF1B795E}.Release|ARM64.Build.0 = Release|ARM64
		{3D62DEB4-3536-44AE-8E4B-AD6DFF1B795E}.Release|x64.ActiveCfg = Release|x64
		{3D62DEB4-3536-44AE-8E4B-AD6DFF1B795E}.Release|x64.Build.0 = Release|x64
		{3D62DEB4-3536-44AE-8E4B-AD6DFF1B795E}.Release|x86.ActiveCfg = Release|Win32
		{3D62DEB4-3536-44AE-8E4B-AD6DFF1B795E}.Release|x86.Build.0 = Release|Win32
		{161E7606-F4CD-4A04-AB6B-5837F7818EE1}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{161E7606-F4CD-4A04-AB6B-5837F7818EE1}.Debug|ARM64.Build.0 = Debug|ARM64
		{161E7606-F4CD-4A04-AB6B-5837F7818EE1}.Debug|x64.ActiveCfg = Debug|x64
		{161E7606-F4CD-4A04-AB6B-5837F7818EE1}.Debug|x64.Build.0 = Debug|x64
		{161E7606-F4CD-4A04-AB6B-5837F7818EE1}.Debug|x86.ActiveCfg = Debug|Win32
		{161E7606-F4CD-4A04-AB6B-5837F7818EE1}.Debug|x86.Build.0 = Debug|Win32
		{161E7606-F4CD-4A04-AB6B-5837F7818EE1}.Release|ARM64.ActiveCfg = Release|ARM64
		{161E7606-F4CD-4A04-AB6B-5837F7818EE1}.Release|ARM64.Build.0 = Release|ARM64
		{161E7606-F4CD-4A04-AB6B-5837F7818EE1}.Release|x64.ActiveCfg = Release|x64
		{161E7606-F4CD-4A04-AB6B-5837F7818EE1}.Release|x64.Build.0 = Release|x64
		{161E7606-F4CD-4A04-AB6B-5837F7818EE1}.Release|x86.ActiveCfg = Release|Win32
		{161E7606-F4CD-4A04-AB6B-5837F7818EE1}.Release|x86.Build.0 = Release|Win32
		{3071DFB6-68F8-41EF-A56C-0C7A71B6967C}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{3071DFB6-68F8-41EF-A56C-0C7A71B6967C}.Debug|ARM64.Build.0 = Debug|ARM64
		{3071DFB6-68F8-41EF-A56C-0C7A71B6967C}.Debug|x64.ActiveCfg = Debug|x64
		{3071DFB6-68F8-41EF-A56C-0C7A71B6967C}.Debug|x64.Build.0 = Debug|x64
		{3071DFB6-68F8-41EF-A56C-0C7A71B6967C}.Debug|x86.ActiveCfg = Debug|Win32
		{3071DFB6-68F8-41EF-A56C-0C7A71B6967C}.Debug|x86.Build.0 = Debug|Win32
		{3071DFB6-68F8-41EF-A56C-0C7A71B6967C}.Release|ARM64.ActiveCfg = Release|ARM64
		{3071DFB6-68F8-41EF-A56C-0C7A71B6967C}.Release|ARM64.Build.0 = Release|ARM64
		{3071DFB6-68F8-41EF-A56C-0C7A71B6967C}.Release|x64.ActiveCfg = Release|x64
		{3071DFB6-68F8-41EF-A56C-0C7A71B6967C}.Release|x64.Build.0 = Release|x64
		{3071DFB6-68F8-41EF-A56C-0C7A71B6967C}.Release|x86.ActiveCfg = Release|Win32
		{3071DFB6-68F8-41EF-A56C-0C7A71B6967C}.Release|x86.Build.0 = Release|Win32
		{1B8791CB-DD15-46BF-B0A2-879892085538}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{1B8791CB-DD15-46BF-B0A2-879892085538}.Debug|ARM64.Build.0 = Debug|ARM64
		{1B8791CB-DD15-46BF-B0A2-879892085538}.Debug|x64.ActiveCfg = Debug|x64
		{1B8791CB-DD15-46BF-B0A2-879892085538}.Debug|x64.Build.0 = Debug|x64
		{1B8791CB-DD15-46BF-B0A2-879892085538}.Debug|x86.ActiveCfg = Debug|Win32
		{1B8791CB-DD15-46BF-B0A2-879892085538}.Debug|x86.Build.0 = Debug|Win32
		{1B8791CB-DD15-46BF-B0A2-879892085538}.Release|ARM64.ActiveCfg = Release|ARM64
		{1B8791CB-DD15-46BF-B0A2-879892085538}.Release|ARM64.Build.0 = Release|ARM64
		{1B8791CB-DD15-46BF-B0A2-879892085538}.Release|x64.ActiveCfg = Release|x64
		{1B8791CB-DD15-46BF-B0A2-879892085538}.Release|x64.Build.0 = Release|x64
		{1B8791CB-DD15-46BF-B0A2-879892085538}.Release|x86.ActiveCfg = Release|Win32
		{1B8791CB-DD15-46BF-B0A2-879892085538}.Release|x86.Build.0 = Release|Win32
		{1C376689-5F61-48E7-AE83-0DED9EE9E458}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{1C376689-5F61-48E7-AE83-0DED9EE9E458}.Debug|ARM64.Build.0 = Debug|ARM64
		{1C376689-5F61-48E7-AE83-0DED9EE9E458}.Debug|x64.ActiveCfg = Debug|x64
		{1C376689-5F61-48E7-AE83-0DED9EE9E458}.Debug|x64.Build.0 = Debug|x64
		{1C376689-5F61-48E7-AE83-0DED9EE9E458}.Debug|x86.ActiveCfg = Debug|Win32
		{1C376689-5F61-48E7-AE83-0DED9EE9E458}.Debug|x86.Build.0 = Debug|Win32
		{1C376689-5F61-48E7-AE83-0DED9EE9E458}.Release|ARM64.ActiveCfg = Release|ARM64
		{1C376689-5F61-48E7-AE83-0DED9EE9E458}.Release|ARM64.Build.0 = Release|ARM64
		{1C376689-5F61-48E7-AE83-0DED9EE9E458}.Release|x64.ActiveCfg = Release|x64
		{1C376689-5F61-48E7-AE83-0DED9EE9E458}.Release|x64.Build.0 = Release|x64
		{1C376689-5F61-48E7-AE83-0DED9EE9E458}.Release|x86.ActiveCfg = Release|Win32
		{1C376689-5F61-48E7-AE83-0DED9EE9E458}.Release|x86.Build.0 = Release|Win32
		{42E5F1D6-6E83-4C13-83CC-C6CD83478C58}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{42E5F1D6-6E83-4C13-83CC-C6CD83478C58}.Debug|ARM64.Build.0 = Debug|ARM64
		{42E5F1D6-6E83-4C13-83CC-C6CD83478C58}.Debug|x64.ActiveCfg = Debug|x64
		{42E5F1D6-6E83-4C13-83CC-C6CD83478C58}.Debug|x64.Build.0 = Debug|x64
		{42E5F1D6-6E83-4C13-83CC-C6CD83478C58}.Debug|x86.ActiveCfg = Debug|Win32
		{42E5F1D6-6E83-4C13-83CC-C6CD83478C58}.Debug|x86.Build.0 = Debug|Win32
		{42E5F1D6-6E83-4C13-83CC-C6CD83478C58}.Release|ARM64.ActiveCfg = Release|ARM64
		{42E5F1D6-6E83-4C13-83CC-C6CD83478C58}.Release|ARM64.Build.0 = Release|ARM64
		{42E5F1D6-6E83-4C13-83CC-C6CD83478C58}.Release|x64.ActiveCfg = Release|x64
		{42E5F1D6-6E83-4C13-83CC-C6CD83478C58}.Release|x64.Build.0 = Release|x64
		{42E5F1D6-6E83-4C13-83CC-C6CD83478C58}.Release|x86.ActiveCfg = Release|Win32
		{42E5F1D6-6E83-4C13-83CC-C6CD83478C58}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {879C566D-AB09-4E94-923D-9FDE09257A52}
	EndGlobalSection
EndGlobal

```

`Examples-pcap/UDPdump/GNUmakefile`:

```
# Makefile for cygwin gcc
# Loris Degioanni

PCAP_PATH = ../../lib
CFLAGS = -g -O -mno-cygwin -I ../../include

OBJS = udpdump.o
LIBS = -L ${PCAP_PATH} -lwpcap -lwsock32

all: ${OBJS}
	${CC} ${CFLAGS} -o udpdump.exe ${OBJS} ${LIBS}

clean:
	rm -f ${OBJS} udpdump.exe

.c.o:
	${CC} ${CFLAGS} -c -o $*.o $<

```

`Examples-pcap/UDPdump/UDPdump.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{42E5F1D6-6E83-4C13-83CC-C6CD83478C58}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <AdditionalDependencies>wpcap.lib;ws2_32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>wpcap.lib;ws2_32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;ws2_32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;ws2_32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;ws2_32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;ws2_32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="udpdump.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`Examples-pcap/UDPdump/udpdump.c`:

```c
/*
 * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)
 * Copyright (c) 2005 - 2006 CACE Technologies, Davis (California)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Politecnico di Torino, CACE Technologies 
 * nor the names of its contributors may be used to endorse or promote 
 * products derived from this software without specific prior written 
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#ifdef _MSC_VER
/*
 * we do not want the warnings about the old deprecated and unsecure CRT functions
 * since these examples can be compiled under *nix as well
 */
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <pcap.h>
#include <time.h>

#ifdef _WIN32
#include <tchar.h>
BOOL LoadNpcapDlls()
{
	_TCHAR npcap_dir[512];
	UINT len;
	len = GetSystemDirectory(npcap_dir, 480);
	if (!len) {
		fprintf(stderr, "Error in GetSystemDirectory: %x", GetLastError());
		return FALSE;
	}
	_tcscat_s(npcap_dir, 512, _T("\\Npcap"));
	if (SetDllDirectory(npcap_dir) == 0) {
		fprintf(stderr, "Error in SetDllDirectory: %x", GetLastError());
		return FALSE;
	}
	return TRUE;
}
#endif

/* 4 bytes IP address */
typedef struct ip_address
{
	u_char byte1;
	u_char byte2;
	u_char byte3;
	u_char byte4;
}ip_address;

/* IPv4 header */
typedef struct ip_header
{
	u_char	ver_ihl;		// Version (4 bits) + Internet header length (4 bits)
	u_char	tos;			// Type of service 
	u_short tlen;			// Total length 
	u_short identification; // Identification
	u_short flags_fo;		// Flags (3 bits) + Fragment offset (13 bits)
	u_char	ttl;			// Time to live
	u_char	proto;			// Protocol
	u_short crc;			// Header checksum
	ip_address	saddr;		// Source address
	ip_address	daddr;		// Destination address
	u_int	op_pad;			// Option + Padding
}ip_header;

/* UDP header*/
typedef struct udp_header
{
	u_short sport;			// Source port
	u_short dport;			// Destination port
	u_short len;			// Datagram length
	u_short crc;			// Checksum
}udp_header;

/* prototype of the packet handler */
void packet_handler(u_char *param, const struct pcap_pkthdr *header, const u_char *pkt_data);


int main()
{
	pcap_if_t *alldevs;
	pcap_if_t *d;
	int inum;
	int i=0;
	pcap_t *adhandle;
	char errbuf[PCAP_ERRBUF_SIZE];
	u_int netmask;
	char packet_filter[] = "ip and udp";
	struct bpf_program fcode;
	
#ifdef _WIN32
	/* Load Npcap and its functions. */
	if (!LoadNpcapDlls())
	{
		fprintf(stderr, "Couldn't load Npcap\n");
		exit(1);
	}
#endif

	/* Retrieve the device list */
	if(pcap_findalldevs(&alldevs, errbuf) == -1)
	{
		fprintf(stderr,"Error in pcap_findalldevs: %s\n", errbuf);
		exit(1);
	}
	
	/* Print the list */
	for(d=alldevs; d; d=d->next)
	{
		printf("%d. %s", ++i, d->name);
		if (d->description)
			printf(" (%s)\n", d->description);
		else
			printf(" (No description available)\n");
	}

	if(i==0)
	{
		printf("\nNo interfaces found! Make sure Npcap is installed.\n");
		return -1;
	}
	
	printf("Enter the interface number (1-%d):",i);
	scanf("%d", &inum);
	
	/* Check if the user specified a valid adapter */
	if(inum < 1 || inum > i)
	{
		printf("\nAdapter number out of range.\n");
		
		/* Free the device list */
		pcap_freealldevs(alldevs);
		return -1;
	}

	/* Jump to the selected adapter */
	for(d=alldevs, i=0; i< inum-1 ;d=d->next, i++);
	
	/* Open the adapter */
	if ((adhandle= pcap_open_live(d->name,	// name of the device
							 65536,			// portion of the packet to capture. 
											// 65536 grants that the whole packet will be captured on all the MACs.
							 1,				// promiscuous mode (nonzero means promiscuous)
							 1000,			// read timeout
							 errbuf			// error buffer
							 )) == NULL)
	{
		fprintf(stderr,"\nUnable to open the adapter: %s\n", errbuf);
		/* Free the device list */
		pcap_freealldevs(alldevs);
		return -1;
	}
	
	/* Check the link layer. We support only Ethernet for simplicity. */
	if(pcap_datalink(adhandle) != DLT_EN10MB)
	{
		fprintf(stderr,"\nThis program works only on Ethernet networks.\n");
		/* Free the device list */
		pcap_freealldevs(alldevs);
		return -1;
	}
	
	if(d->addresses != NULL)
		/* Retrieve the mask of the first address of the interface */
		netmask=((struct sockaddr_in *)(d->addresses->netmask))->sin_addr.S_un.S_addr;
	else
		/* If the interface is without addresses we suppose to be in a C class network */
		netmask=0xffffff; 


	//compile the filter
	if (pcap_compile(adhandle, &fcode, packet_filter, 1, netmask) <0 )
	{
		fprintf(stderr,"\nUnable to compile the packet filter. Check the syntax.\n");
		/* Free the device list */
		pcap_freealldevs(alldevs);
		return -1;
	}
	
	//set the filter
	if (pcap_setfilter(adhandle, &fcode)<0)
	{
		fprintf(stderr,"\nError setting the filter.\n");
		/* Free the device list */
		pcap_freealldevs(alldevs);
		return -1;
	}
	
	printf("\nlistening on %s...\n", d->description);
	
	/* At this point, we don't need any more the device list. Free it */
	pcap_freealldevs(alldevs);
	
	/* start the capture */
	pcap_loop(adhandle, 0, packet_handler, NULL);
	
	return 0;
}

/* Callback function invoked by libpcap for every incoming packet */
void packet_handler(u_char *param, const struct pcap_pkthdr *header, const u_char *pkt_data)
{
	struct tm *ltime;
	char timestr[16];
	ip_header *ih;
	udp_header *uh;
	u_int ip_len;
	u_short sport,dport;
	time_t local_tv_sec;

	/*
	 * unused parameter
	 */
	(VOID)(param);

	/* convert the timestamp to readable format */
	local_tv_sec = header->ts.tv_sec;
	ltime=localtime(&local_tv_sec);
	strftime( timestr, sizeof timestr, "%H:%M:%S", ltime);

	/* print timestamp and length of the packet */
	printf("%s.%.6d len:%d ", timestr, header->ts.tv_usec, header->len);

	/* retireve the position of the ip header */
	ih = (ip_header *) (pkt_data +
		14); //length of ethernet header

	/* retireve the position of the udp header */
	ip_len = (ih->ver_ihl & 0xf) * 4;
	uh = (udp_header *) ((u_char*)ih + ip_len);

	/* convert from network byte order to host byte order */
	sport = ntohs( uh->sport );
	dport = ntohs( uh->dport );

	/* print ip addresses and udp ports */
	printf("%d.%d.%d.%d.%d -> %d.%d.%d.%d.%d\n",
		ih->saddr.byte1,
		ih->saddr.byte2,
		ih->saddr.byte3,
		ih->saddr.byte4,
		sport,
		ih->daddr.byte1,
		ih->daddr.byte2,
		ih->daddr.byte3,
		ih->daddr.byte4,
		dport);
}

```

`Examples-pcap/basic_dump/GNUmakefile`:

```
# Makefile for cygwin gcc
# Nate Lawson <nate@rootlabs.com>

PCAP_PATH = ../../lib
CFLAGS = -g -O -mno-cygwin -I ../../include

OBJS = basic_dump.o
LIBS = -L ${PCAP_PATH} -lwpcap

all: ${OBJS}
	${CC} ${CFLAGS} -o basic_dump.exe ${OBJS} ${LIBS}

clean:
	rm -f ${OBJS} basic_dump.exe

.c.o:
	${CC} ${CFLAGS} -c -o $*.o $<

```

`Examples-pcap/basic_dump/basic_dump.c`:

```c
#ifdef _MSC_VER
/*
 * we do not want the warnings about the old deprecated and unsecure CRT functions
 * since these examples can be compiled under *nix as well
 */
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <pcap.h>
#include <stdio.h>
#include <time.h>
#ifdef _WIN32
#include <tchar.h>
BOOL LoadNpcapDlls()
{
	_TCHAR npcap_dir[512];
	UINT len;
	len = GetSystemDirectory(npcap_dir, 480);
	if (!len) {
		fprintf(stderr, "Error in GetSystemDirectory: %x", GetLastError());
		return FALSE;
	}
	_tcscat_s(npcap_dir, 512, _T("\\Npcap"));
	if (SetDllDirectory(npcap_dir) == 0) {
		fprintf(stderr, "Error in SetDllDirectory: %x", GetLastError());
		return FALSE;
	}
	return TRUE;
}
#endif

/* prototype of the packet handler */
void packet_handler(u_char *param, const struct pcap_pkthdr *header, const u_char *pkt_data);

int main()
{
	pcap_if_t *alldevs;
	pcap_if_t *d;
	int inum;
	int i=0;
	pcap_t *adhandle;
	char errbuf[PCAP_ERRBUF_SIZE];

#ifdef _WIN32
	/* Load Npcap and its functions. */
	if (!LoadNpcapDlls())
	{
		fprintf(stderr, "Couldn't load Npcap\n");
		exit(1);
	}
#endif

	/* Retrieve the device list */
	if(pcap_findalldevs(&alldevs, errbuf) == -1)
	{
		fprintf(stderr,"Error in pcap_findalldevs: %s\n", errbuf);
		exit(1);
	}
	
	/* Print the list */
	for(d=alldevs; d; d=d->next)
	{
		printf("%d. %s", ++i, d->name);
		if (d->description)
			printf(" (%s)\n", d->description);
		else
			printf(" (No description available)\n");
	}
	
	if(i==0)
	{
		printf("\nNo interfaces found! Make sure Npcap is installed.\n");
		return -1;
	}
	
	printf("Enter the interface number (1-%d):",i);
	scanf("%d", &inum);
	
	if(inum < 1 || inum > i)
	{
		printf("\nInterface number out of range.\n");
		/* Free the device list */
		pcap_freealldevs(alldevs);
		return -1;
	}
	
	/* Jump to the selected adapter */
	for(d=alldevs, i=0; i< inum-1 ;d=d->next, i++);
	
	/* Open the device */
	/* Open the adapter */
	if ((adhandle= pcap_open_live(d->name,	// name of the device
							 65536,			// portion of the packet to capture. 
											// 65536 grants that the whole packet will be captured on all the MACs.
							 1,				// promiscuous mode (nonzero means promiscuous)
							 1000,			// read timeout
							 errbuf			// error buffer
							 )) == NULL)
	{
		fprintf(stderr,"\nUnable to open the adapter. %s is not supported by Npcap\n", d->name);
		/* Free the device list */
		pcap_freealldevs(alldevs);
		return -1;
	}
	
	printf("\nlistening on %s...\n", d->description);
	
	/* At this point, we don't need any more the device list. Free it */
	pcap_freealldevs(alldevs);
	
	/* start the capture */
	pcap_loop(adhandle, 0, packet_handler, NULL);
	
	pcap_close(adhandle);
	return 0;
}


/* Callback function invoked by libpcap for every incoming packet */
void packet_handler(u_char *param, const struct pcap_pkthdr *header, const u_char *pkt_data)
{
	struct tm *ltime;
	char timestr[16];
	time_t local_tv_sec;

	/*
	 * unused parameters
	 */
	(VOID)(param);
	(VOID)(pkt_data);

	/* convert the timestamp to readable format */
	local_tv_sec = header->ts.tv_sec;
	ltime=localtime(&local_tv_sec);
	strftime( timestr, sizeof timestr, "%H:%M:%S", ltime);
	
	printf("%s,%.6d len:%d\n", timestr, header->ts.tv_usec, header->len);
	
}

```

`Examples-pcap/basic_dump/basic_dump.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{66297062-96A0-4F0E-B147-3C8384031232}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="basic_dump.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`Examples-pcap/basic_dump_ex/GNUmakefile`:

```
# Makefile for cygwin gcc
# Nate Lawson <nate@rootlabs.com>

PCAP_PATH = ../../lib
CFLAGS = -g -O -mno-cygwin -I ../../include

OBJS = basic_dump_ex.o
LIBS = -L ${PCAP_PATH} -lwpcap

all: ${OBJS}
	${CC} ${CFLAGS} -o basic_dump_ex.exe ${OBJS} ${LIBS}

clean:
	rm -f ${OBJS} basic_dump_ex.exe

.c.o:
	${CC} ${CFLAGS} -c -o $*.o $<

```

`Examples-pcap/basic_dump_ex/basic_dump_ex.c`:

```c
#ifdef _MSC_VER
/*
 * we do not want the warnings about the old deprecated and unsecure CRT functions
 * since these examples can be compiled under *nix as well
 */
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <pcap.h>
#include <stdio.h>
#include <time.h>
#ifdef _WIN32
#include <tchar.h>
BOOL LoadNpcapDlls()
{
	_TCHAR npcap_dir[512];
	UINT len;
	len = GetSystemDirectory(npcap_dir, 480);
	if (!len) {
		fprintf(stderr, "Error in GetSystemDirectory: %x", GetLastError());
		return FALSE;
	}
	_tcscat_s(npcap_dir, 512, _T("\\Npcap"));
	if (SetDllDirectory(npcap_dir) == 0) {
		fprintf(stderr, "Error in SetDllDirectory: %x", GetLastError());
		return FALSE;
	}
	return TRUE;
}
#endif

int main()
{
	pcap_if_t *alldevs;
	pcap_if_t *d;
	int inum;
	int i=0;
	pcap_t *adhandle;
	int res;
	char errbuf[PCAP_ERRBUF_SIZE];
	struct tm *ltime;
	char timestr[16];
	struct pcap_pkthdr *header;
	const u_char *pkt_data;
	time_t local_tv_sec;

#ifdef _WIN32
	/* Load Npcap and its functions. */
	if (!LoadNpcapDlls())
	{
		fprintf(stderr, "Couldn't load Npcap\n");
		exit(1);
	}
#endif

	/* Retrieve the device list */
	if(pcap_findalldevs(&alldevs, errbuf) == -1)
	{
		fprintf(stderr,"Error in pcap_findalldevs: %s\n", errbuf);
		return -1;
	}
    
    /* Print the list */
    for(d=alldevs; d; d=d->next)
    {
        printf("%d. %s", ++i, d->name);
        if (d->description)
            printf(" (%s)\n", d->description);
        else
            printf(" (No description available)\n");
    }
	
    if(i==0)
    {
        printf("\nNo interfaces found! Make sure Npcap is installed.\n");
        return -1;
    }
    
    printf("Enter the interface number (1-%d):",i);
    scanf("%d", &inum);
    
    if(inum < 1 || inum > i)
    {
        printf("\nInterface number out of range.\n");
        /* Free the device list */
        pcap_freealldevs(alldevs);
        return -1;
    }
	
    /* Jump to the selected adapter */
    for(d=alldevs, i=0; i< inum-1 ;d=d->next, i++);
    
	/* Open the adapter */
	if ((adhandle= pcap_open_live(d->name,	// name of the device
							 65536,			// portion of the packet to capture. 
											// 65536 grants that the whole packet will be captured on all the MACs.
							 1,				// promiscuous mode (nonzero means promiscuous)
							 1000,			// read timeout
							 errbuf			// error buffer
							 )) == NULL)
	{
		fprintf(stderr,"\nUnable to open the adapter. %s is not supported by Npcap\n", d->name);
		/* Free the device list */
		pcap_freealldevs(alldevs);
		return -1;
	}
    
    printf("\nlistening on %s...\n", d->description);
	
    /* At this point, we don't need any more the device list. Free it */
    pcap_freealldevs(alldevs);
	
	/* Retrieve the packets */
	while((res = pcap_next_ex( adhandle, &header, &pkt_data)) >= 0){
		
		if(res == 0)
			/* Timeout elapsed */
			continue;
		
		/* convert the timestamp to readable format */
		local_tv_sec = header->ts.tv_sec;
		ltime=localtime(&local_tv_sec);
		strftime( timestr, sizeof timestr, "%H:%M:%S", ltime);
		
		printf("%s,%.6d len:%d\n", timestr, header->ts.tv_usec, header->len);
	}
	
	if(res == -1){
		printf("Error reading the packets: %s\n", pcap_geterr(adhandle));
		return -1;
	}
	
   pcap_close(adhandle);  
   return 0;
}

```

`Examples-pcap/basic_dump_ex/basic_dump_ex.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{92849630-6B09-409C-A7AD-E91E682558B1}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="basic_dump_ex.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`Examples-pcap/iflist/GNUmakefile`:

```
# Makefile for cygwin gcc
# Nate Lawson <nate@rootlabs.com>

PCAP_PATH = ../../lib
CFLAGS = -g -O -mno-cygwin -I ../../include

OBJS = iflist.o
LIBS = -L ${PCAP_PATH} -lwpcap

all: ${OBJS}
	${CC} ${CFLAGS} -o iflist.exe ${OBJS} ${LIBS}

clean:
	rm -f ${OBJS} iflist.exe

.c.o:
	${CC} ${CFLAGS} -c -o $*.o $<

```

`Examples-pcap/iflist/iflist.c`:

```c
/*
 * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)
 * Copyright (c) 2005 - 2006 CACE Technologies, Davis (California)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Politecnico di Torino, CACE Technologies 
 * nor the names of its contributors may be used to endorse or promote 
 * products derived from this software without specific prior written 
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#ifdef _MSC_VER
/*
 * we do not want the warnings about the old deprecated and unsecure CRT functions
 * since these examples can be compiled under *nix as well
 */
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <pcap.h>
#include <stdio.h>

#ifndef _WIN32
	#include <sys/socket.h>
	#include <netinet/in.h>
#else
	#include <winsock2.h>
#endif

#ifdef _WIN32
#include <tchar.h>
BOOL LoadNpcapDlls()
{
	_TCHAR npcap_dir[512];
	UINT len;
	len = GetSystemDirectory(npcap_dir, 480);
	if (!len) {
		fprintf(stderr, "Error in GetSystemDirectory: %x", GetLastError());
		return FALSE;
	}
	_tcscat_s(npcap_dir, 512, _T("\\Npcap"));
	if (SetDllDirectory(npcap_dir) == 0) {
		fprintf(stderr, "Error in SetDllDirectory: %x", GetLastError());
		return FALSE;
	}
	return TRUE;
}

#endif


// Function prototypes
void ifprint(pcap_if_t *d);
const char* iptos(struct sockaddr *sockaddr);


int main()
{
	pcap_if_t *alldevs;
	pcap_if_t *d;
	char errbuf[PCAP_ERRBUF_SIZE+1];
	
#ifdef _WIN32
	WSADATA wsadata;
	int err = WSAStartup(MAKEWORD(2,2), &wsadata);

	if (err != 0) {
		fprintf(stderr, "WSAStartup failed: %d\n", err);
		exit(1);
	}
	/* Load Npcap and its functions. */
	if (!LoadNpcapDlls())
	{
		fprintf(stderr, "Couldn't load Npcap\n");
		WSACleanup();
		exit(1);
	}
#endif
	
	/* Retrieve the device list */
	if(pcap_findalldevs(&alldevs, errbuf) == -1)
	{
		fprintf(stderr,"Error in pcap_findalldevs: %s\n", errbuf);
		WSACleanup();
		exit(1);
	}
	
	/* Scan the list printing every entry */
	for(d=alldevs;d;d=d->next)
	{
		ifprint(d);
	}

	/* Free the device list */
	pcap_freealldevs(alldevs);

	WSACleanup();
	return 0;
}



/* Print all the available information on the given interface */
void ifprint(pcap_if_t *d)
{
  pcap_addr_t *a;

  /* Name */
  printf("%s\n",d->name);

  /* Description */
  if (d->description)
    printf("\tDescription: %s\n",d->description);

  /* Loopback Address*/
  printf("\tLoopback: %s\n",(d->flags & PCAP_IF_LOOPBACK)?"yes":"no");

  /* IP addresses */
  for(a=d->addresses;a;a=a->next) {
    printf("\tAddress Family: #%d\n",a->addr->sa_family);

    switch(a->addr->sa_family)
    {
      case AF_INET:
        printf("\tAddress Family Name: AF_INET\n");
        break;

      case AF_INET6:
        printf("\tAddress Family Name: AF_INET6\n");
        break;

      default:
        printf("\tAddress Family Name: Unknown\n");
        break;
    }
    if (a->addr && a->addr->sa_family > 0)
      printf("\tAddress: %s\n",iptos(a->addr));
    if (a->netmask && a->netmask->sa_family > 0)
      printf("\tNetmask: %s\n",iptos(a->netmask));
    if (a->broadaddr && a->broadaddr->sa_family > 0)
      printf("\tBroadcast Address: %s\n",iptos(a->broadaddr));
    if (a->dstaddr && a->dstaddr->sa_family > 0)
      printf("\tDestination Address: %s\n",iptos(a->dstaddr));
  }
  printf("\n");
}

#define ADDR_STR_MAX 128
const char* iptos(struct sockaddr *sockaddr)
{
  static char address[ADDR_STR_MAX] = {0};
  int gni_error = 0;

  gni_error = getnameinfo(sockaddr,
      sizeof(struct sockaddr_storage),
      address,
      ADDR_STR_MAX,
      NULL,
      0,
      NI_NUMERICHOST);
  if (gni_error != 0)
  {
    fprintf(stderr, "getnameinfo: %s\n", gai_strerror(gni_error));
    return "ERROR!";
  }

  return address;
}

```

`Examples-pcap/iflist/iflist.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{0B27B213-4BF3-4611-B412-A2D09CDE8632}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <AdditionalDependencies>wpcap.lib;ws2_32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>wpcap.lib;ws2_32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;ws2_32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;ws2_32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;ws2_32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;ws2_32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="iflist.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`Examples-pcap/pcap_filter/GNUmakefile`:

```
# Makefile for cygwin gcc
# Nate Lawson <nate@rootlabs.com>

PCAP_PATH = ../../lib
CFLAGS = -g -O -mno-cygwin -I ../../include

OBJS = pcap_filter.o
LIBS = -L ${PCAP_PATH} -lwpcap

all: ${OBJS}
	${CC} ${CFLAGS} -o pf.exe ${OBJS} ${LIBS}

clean:
	rm -f ${OBJS} pf.exe

.c.o:
	${CC} ${CFLAGS} -c -o $*.o $<

```

`Examples-pcap/pcap_filter/Makefile.unix`:

```unix

CC	=	gcc
INCLDIR	=	-I /usr/src/sys
LIBS	= 	-lpcap 

pktdump: pcap_filter.o
        $(CC) $(INCLDIR) pcap_filter.o $(LIBS) -o pf
	rm *.o


```

`Examples-pcap/pcap_filter/pcap_filter.c`:

```c
/*
 * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)
 * Copyright (c) 2005 - 2006 CACE Technologies, Davis (California)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Politecnico di Torino, CACE Technologies 
 * nor the names of its contributors may be used to endorse or promote 
 * products derived from this software without specific prior written 
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */


#include <stdlib.h>
#include <stdio.h>

#include <pcap.h>

#define MAX_PRINT 80
#define MAX_LINE 16

#ifdef _WIN32
#include <tchar.h>
BOOL LoadNpcapDlls()
{
	_TCHAR npcap_dir[512];
	UINT len;
	len = GetSystemDirectory(npcap_dir, 480);
	if (!len) {
		fprintf(stderr, "Error in GetSystemDirectory: %x", GetLastError());
		return FALSE;
	}
	_tcscat_s(npcap_dir, 512, _T("\\Npcap"));
	if (SetDllDirectory(npcap_dir) == 0) {
		fprintf(stderr, "Error in SetDllDirectory: %x", GetLastError());
		return FALSE;
	}
	return TRUE;
}
#endif


int usage(int ret);


int main(int argc, char **argv)
{
	pcap_t *fp;
	char errbuf[PCAP_ERRBUF_SIZE] = {0};
	char *source = NULL;
	char *ofilename = NULL;
	char *filter = NULL;
	int i;
	pcap_dumper_t *dumpfile;
	struct bpf_program fcode;
	bpf_u_int32 NetMask;
	int res;
	struct pcap_pkthdr *header;
	const u_char *pkt_data;
	int snaplen = 65536;
	
#ifdef _WIN32
	/* Load Npcap and its functions. */
	if (!LoadNpcapDlls())
	{
		fprintf(stderr, "Couldn't load Npcap\n");
		exit(1);
	}
#endif

	if (argc <= 1)
	{
		return usage(-1);
	}

	/* Parse parameters */
	for(i=1;i < argc - 1; i+= 2)
	{
		if (argv[i][0] != '-') {
			fprintf(stderr, "Invalid option '%s'\n", argv[i]);
			return usage(1);
		}
		switch (argv[i] [1])
		{
			case 's':
				source=argv[i+1];
				break;
			
			case 'o':
				ofilename=argv[i+1];
				break;

			case 'f':
				filter=argv[i+1];
				break;
			case 'l':
				snaplen = atoi(argv[i+1]);
				if (snaplen <= 0 || snaplen == INT_MAX) {
					fprintf(stderr, "Invalid snaplen; must be positive integer smaller than INT_MAX\n");
					return usage(1);
				}
				break;
			default:
				fprintf(stderr, "Invalid option '%s'\n", argv[i]);
				return usage(1);
		}
	}
	
	// open a capture from the network
	if (source != NULL)
	{
		fp = pcap_create(source, errbuf);
		if (fp == NULL) {
			fprintf(stderr, "pcap_create error: %s\n", errbuf);
			return -2;
		}
		res = pcap_set_snaplen(fp, snaplen);
		if (res < 0) {
			fprintf(stderr, "pcap_set_snaplen error: %s\n", pcap_statustostr(res));
			return -2;
		}
		res = pcap_set_promisc(fp, 1);
		if (res < 0) {
			fprintf(stderr, "pcap_set_promisc error: %s\n", pcap_statustostr(res));
			return -2;
		}
		res = pcap_set_timeout(fp, 1000);
		if (res < 0) {
			fprintf(stderr, "pcap_set_timeout error: %s\n", pcap_statustostr(res));
			return -2;
		}
		res = pcap_activate(fp);
		if (res < 0) {
			fprintf(stderr, "pcap_activate error: %s\n", pcap_statustostr(res));
			return -2;
		}
	}
	else return usage(1);

	if (filter != NULL)
	{
		// We should loop through the adapters returned by the pcap_findalldevs_ex()
		// in order to locate the correct one.
		//
		// Let's do things simpler: we suppose to be in a C class network ;-)
		NetMask=0xffffff;

		//compile the filter
		if((res = pcap_compile(fp, &fcode, filter, 1, NetMask)) < 0)
		{
			fprintf(stderr,"\nError compiling filter: %s\n", pcap_statustostr(res));

			pcap_close(fp);
			return -3;
		}

		//set the filter
		if((res = pcap_setfilter(fp, &fcode))<0)
		{
			fprintf(stderr,"\nError setting the filter: %s\n", pcap_statustostr(res));

			pcap_close(fp);
			return -4;
		}

	}

	//open the dump file
	if (ofilename != NULL)
	{
		dumpfile= pcap_dump_open(fp, ofilename);

		if (dumpfile == NULL)
		{
			fprintf(stderr,"\nError opening output file: %s\n", pcap_geterr(fp));

			pcap_close(fp);
			return -5;
		}
	}
	else return usage(1);

	//start the capture
 	while((res = pcap_next_ex( fp, &header, &pkt_data)) >= 0)
	{

		if(res == 0)
		/* Timeout elapsed */
		continue;

		//save the packet on the dump file
		pcap_dump((unsigned char *) dumpfile, header, pkt_data);

	}

	pcap_close(fp);
	pcap_dump_close(dumpfile);

	return 0;
}


int usage(int ret)
{

	printf("\npf - Generic Packet Filter.\n");
	printf("\nUsage:\npf -s source -o output_file_name [-f filter_string] [-l snaplen]\n\n");
	return ret;
}

```

`Examples-pcap/pcap_filter/pcap_filter.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{B9F68F6F-22AE-47A2-A3A3-1212831AF9FF}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="pcap_filter.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`Examples-pcap/pktdump_ex/GNUmakefile`:

```
PCAP_PATH = ../../lib
CFLAGS = -g -O -mno-cygwin -I ../../include

OBJS = pktdump_ex.o
LIBS = -L ${PCAP_PATH} -lwpcap

all: ${OBJS}
	${CC} ${CFLAGS} -o pktdump_ex.exe ${OBJS} ${LIBS}

clean:
	rm -f ${OBJS} pktdump_ex.exe

.c.o:
	${CC} ${CFLAGS} -c -o $*.o $<

```

`Examples-pcap/pktdump_ex/pktdump_ex.c`:

```c
/*
 * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)
 * Copyright (c) 2005 - 2006 CACE Technologies, Davis (California)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Politecnico di Torino, CACE Technologies 
 * nor the names of its contributors may be used to endorse or promote 
 * products derived from this software without specific prior written 
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#ifdef _MSC_VER
/*
 * we do not want the warnings about the old deprecated and unsecure CRT functions
 * since these examples can be compiled under *nix as well
 */
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <stdlib.h>
#include <stdio.h>

#include <pcap.h>

#define LINE_LEN 16

#ifdef _WIN32
#include <tchar.h>
BOOL LoadNpcapDlls()
{
	_TCHAR npcap_dir[512];
	UINT len;
	len = GetSystemDirectory(npcap_dir, 480);
	if (!len) {
		fprintf(stderr, "Error in GetSystemDirectory: %x", GetLastError());
		return FALSE;
	}
	_tcscat_s(npcap_dir, 512, _T("\\Npcap"));
	if (SetDllDirectory(npcap_dir) == 0) {
		fprintf(stderr, "Error in SetDllDirectory: %x", GetLastError());
		return FALSE;
	}
	return TRUE;
}
#endif


int main(int argc, char **argv)
{	
	pcap_if_t *alldevs, *d;
	pcap_t *fp;
	u_int inum, i=0;
	char errbuf[PCAP_ERRBUF_SIZE];
	int res;
	struct pcap_pkthdr *header;
	const u_char *pkt_data;
	
#ifdef _WIN32
	/* Load Npcap and its functions. */
	if (!LoadNpcapDlls())
	{
		fprintf(stderr, "Couldn't load Npcap\n");
		exit(1);
	}
#endif

	printf("pktdump_ex: prints the packets of the network using Npcap.\n");
	printf("   Usage: pktdump_ex [-s source]\n\n"
		"   Examples:\n"
		"      pktdump_ex -s file.acp\n"
		"      pktdump_ex -s \\Device\\NPF_{C8736017-F3C3-4373-94AC-9A34B7DAD998}\n\n");

	if(argc < 3)
	{
		printf("\nNo adapter selected: printing the device list:\n");
		/* The user didn't provide a packet source: Retrieve the local device list */
		if(pcap_findalldevs(&alldevs, errbuf) == -1)
		{
			fprintf(stderr,"Error in pcap_findalldevs_ex: %s\n", errbuf);
			exit(1);
		}
		
		/* Print the list */
		for(d=alldevs; d; d=d->next)
		{
			printf("%d. %s\n    ", ++i, d->name);

			if (d->description)
				printf(" (%s)\n", d->description);
			else
				printf(" (No description available)\n");
		}
		
		if (i==0)
		{
			printf("\nNo interfaces found! Make sure Npcap is installed.\n");
			return -1;
		}
		
		printf("Enter the interface number (1-%d):",i);
		scanf("%d", &inum);
		
		if (inum < 1 || inum > i)
		{
			printf("\nInterface number out of range.\n");

			/* Free the device list */
			pcap_freealldevs(alldevs);
			return -1;
		}
		
		/* Jump to the selected adapter */
		for (d=alldevs, i=0; i< inum-1 ;d=d->next, i++);
		
		/* Open the adapter */
		if ((fp = pcap_open_live(d->name,	// name of the device
			65536,							// portion of the packet to capture. 
											// 65536 grants that the whole packet will be captured on all the MACs.
			1,								// promiscuous mode (nonzero means promiscuous)
			1000,							// read timeout
			errbuf							// error buffer
			)) == NULL)
		{
			fprintf(stderr,"\nError opening adapter\n");
			return -1;
		}
	}
	else 
	{
		/* Do not check for the switch type ('-s') */
		if ((fp = pcap_open_live(argv[2],	// name of the device
			65536,							// portion of the packet to capture. 
											// 65536 grants that the whole packet will be captured on all the MACs.
			1,								// promiscuous mode (nonzero means promiscuous)
			1000,							// read timeout
			errbuf							// error buffer
			)) == NULL)
		{
			fprintf(stderr,"\nError opening adapter\n");
			return -1;
		}
	}

	/* Read the packets */
	while((res = pcap_next_ex( fp, &header, &pkt_data)) >= 0)
	{

		if(res == 0)
			/* Timeout elapsed */
			continue;

		/* print pkt timestamp and pkt len */
		printf("%ld:%ld (%ld)\n", header->ts.tv_sec, header->ts.tv_usec, header->len);			
		
		/* Print the packet */
		for (i=1; (i < header->caplen + 1 ) ; i++)
		{
			printf("%.2x ", pkt_data[i-1]);
			if ( (i % LINE_LEN) == 0) printf("\n");
		}
		
		printf("\n\n");		
	}

	if(res == -1)
	{
		printf("Error reading the packets: %s\n", pcap_geterr(fp));
		return -1;
	}

	pcap_close(fp);
	return 0;
}

```

`Examples-pcap/pktdump_ex/pktdump_ex.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{3D62DEB4-3536-44AE-8E4B-AD6DFF1B795E}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="pktdump_ex.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`Examples-pcap/readfile/GNUmakefile`:

```
# Makefile for cygwin gcc
# Nate Lawson <nate@rootlabs.com>

PCAP_PATH = ../../lib
CFLAGS = -g -O -mno-cygwin -I ../../include

OBJS = readfile.o
LIBS = -L ${PCAP_PATH} -lwpcap

all: ${OBJS}
	${CC} ${CFLAGS} -o readfile.exe ${OBJS} ${LIBS}

clean:
	rm -f ${OBJS} readfile.exe

.c.o:
	${CC} ${CFLAGS} -c -o $*.o $<

```

`Examples-pcap/readfile/readfile.c`:

```c
#include <string.h>
#include <stdio.h>
#include <pcap.h>

#define LINE_LEN 16
#define TIMEVAL_AFTER(a, b) (((a).tv_sec > (b).tv_sec) || ((a).tv_sec == (b).tv_sec && (a).tv_usec > (b).tv_usec))
#define TIMEVAL_BEFORE(a, b) (((a).tv_sec < (b).tv_sec) || ((a).tv_sec == (b).tv_sec && (a).tv_usec < (b).tv_usec))

#ifdef _WIN32
#include <tchar.h>
BOOL LoadNpcapDlls()
{
	_TCHAR npcap_dir[512];
	UINT len;
	len = GetSystemDirectory(npcap_dir, 480);
	if (!len) {
		fprintf(stderr, "Error in GetSystemDirectory: %x", GetLastError());
		return FALSE;
	}
	_tcscat_s(npcap_dir, 512, _T("\\Npcap"));
	if (SetDllDirectory(npcap_dir) == 0) {
		fprintf(stderr, "Error in SetDllDirectory: %x", GetLastError());
		return FALSE;
	}
	return TRUE;
}
#endif

void dispatcher_handler(u_char *, const struct pcap_pkthdr *, const u_char *);

struct state {
	int verify;
	const struct timeval first;
	const struct timeval prev;
	pcap_t *p;
};

int main(int argc, char **argv)
{
	pcap_t *fp;
	char *filename = NULL;
	char errbuf[PCAP_ERRBUF_SIZE];
	struct state st;
	memset(&st, 0, sizeof(st));
	
#ifdef _WIN32
	/* Load Npcap and its functions. */
	if (!LoadNpcapDlls())
	{
		fprintf(stderr, "Couldn't load Npcap\n");
		exit(1);
	}
#endif

	if (argc == 3 && strcmp(argv[1], "-v") == 0) {
		filename = argv[2];
		st.verify = 1;
	}
	else if(argc != 2)
	{	
		printf("usage: %s [-v] filename", argv[0]);
		return -1;

	}
	else
		filename = argv[1];
	
	/* Open the capture file */
	if ((fp = pcap_open_offline(filename, // name of the device
					errbuf // error buffer
				   )) == NULL)
	{
		fprintf(stderr,"\nUnable to open the file %s: %s\n", filename, errbuf);
		return -1;
	}

	/* read and dispatch packets until EOF is reached */
	st.p = fp;
	if (0 != pcap_loop(fp, 0, dispatcher_handler, (u_char *) &st)) {
		fprintf(stderr, "pcap_loop error: %s\n", pcap_geterr(fp));
		pcap_close(fp);
		return -1;
	}

	if (st.prev.tv_sec == 0 && st.prev.tv_usec == 0) {
		fprintf(stderr, "No packets processed!\n");
		pcap_close(fp);
		return -1;
	}

	if (!TIMEVAL_AFTER(st.prev, st.first)) {
		fprintf(stderr, "Timestamps do not increase: %lu.%06lu\n", st.prev.tv_sec, st.prev.tv_usec);
		pcap_close(fp);
		return -1;
	}
	pcap_close(fp);
	return 0;
}



void dispatcher_handler(u_char *temp1, 
						const struct pcap_pkthdr *header, 
						const u_char *pkt_data)
{
	u_int i=0;
	
	struct state *st = (struct state *) temp1;
	if (st->first.tv_sec == 0 && st->first.tv_usec == 0) {
		memcpy(&st->first, &header->ts, sizeof(struct timeval));
	}

	if (st->verify && (st->prev.tv_sec != 0 || st->prev.tv_usec != 0)) {
		/* Default timestamp mode is monotonically increasing */
		if (TIMEVAL_BEFORE(header->ts, st->prev)) {
			fprintf(stderr, "Backwards timestamp!\n");
			pcap_breakloop(st->p);
		}
	}

	/* print pkt timestamp and pkt len */
	printf("%ld:%ld (%ld)\n", header->ts.tv_sec, header->ts.tv_usec, header->len);			
	
	/* Print the packet */
	for (i=1; (i < header->caplen + 1 ) ; i++)
	{
		printf("%.2x ", pkt_data[i-1]);
		if ( (i % LINE_LEN) == 0) printf("\n");
	}
	
	printf("\n\n");		
	memcpy(&st->prev, &header->ts, sizeof(struct timeval));
}

```

`Examples-pcap/readfile/readfile.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{161E7606-F4CD-4A04-AB6B-5837F7818EE1}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="readfile.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`Examples-pcap/readfile_ex/GNUmakefile`:

```
# Makefile for cygwin gcc
# Nate Lawson <nate@rootlabs.com>

PCAP_PATH = ../../lib
CFLAGS = -g -O -mno-cygwin -I ../../include

OBJS = readfile_ex.o
LIBS = -L ${PCAP_PATH} -lwpcap

all: ${OBJS}
	${CC} ${CFLAGS} -o readfile_ex.exe ${OBJS} ${LIBS}

clean:
	rm -f ${OBJS} readfile_ex.exe

.c.o:
	${CC} ${CFLAGS} -c -o $*.o $<

```

`Examples-pcap/readfile_ex/readfile_ex.c`:

```c
#include <stdio.h>
#include <pcap.h>

#define LINE_LEN 16

#ifdef _WIN32
#include <tchar.h>
BOOL LoadNpcapDlls()
{
	_TCHAR npcap_dir[512];
	UINT len;
	len = GetSystemDirectory(npcap_dir, 480);
	if (!len) {
		fprintf(stderr, "Error in GetSystemDirectory: %x", GetLastError());
		return FALSE;
	}
	_tcscat_s(npcap_dir, 512, _T("\\Npcap"));
	if (SetDllDirectory(npcap_dir) == 0) {
		fprintf(stderr, "Error in SetDllDirectory: %x", GetLastError());
		return FALSE;
	}
	return TRUE;
}
#endif

int main(int argc, char **argv)
{
	pcap_t *fp;
	char errbuf[PCAP_ERRBUF_SIZE];
	struct pcap_pkthdr *header;
	const u_char *pkt_data;
	u_int i=0;
	int res;
	
#ifdef _WIN32
	/* Load Npcap and its functions. */
	if (!LoadNpcapDlls())
	{
		fprintf(stderr, "Couldn't load Npcap\n");
		exit(1);
	}
#endif

	if(argc != 2)
	{	
		printf("usage: %s filename", argv[0]);
		return -1;

	}
	
	/* Open the capture file */
	if ((fp = pcap_open_offline(argv[1],			// name of the device
						 errbuf					// error buffer
						 )) == NULL)
	{
		fprintf(stderr,"\nUnable to open the file %s.\n", argv[1]);
		return -1;
	}
	
	/* Retrieve the packets from the file */
	while((res = pcap_next_ex(fp, &header, &pkt_data)) >= 0)
	{
		/* print pkt timestamp and pkt len */
		printf("%ld:%ld (%ld)\n", header->ts.tv_sec, header->ts.tv_usec, header->len);			
		
		/* Print the packet */
		for (i=1; (i < header->caplen + 1 ) ; i++)
		{
			printf("%.2x ", pkt_data[i-1]);
			if ( (i % LINE_LEN) == 0) printf("\n");
		}
		
		printf("\n\n");		
	}
	
	
	if (res == -1)
	{
		printf("Error reading the packets: %s\n", pcap_geterr(fp));
	}
	
	pcap_close(fp);
	return 0;
}


```

`Examples-pcap/readfile_ex/readfile_ex.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{3071DFB6-68F8-41EF-A56C-0C7A71B6967C}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="readfile_ex.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`Examples-pcap/savedump/GNUmakefile`:

```
# Makefile for cygwin gcc
# Nate Lawson <nate@rootlabs.com>

PCAP_PATH = ../../lib
CFLAGS = -g -O -mno-cygwin -I ../../include

OBJS = savedump.o
LIBS = -L ${PCAP_PATH} -lwpcap

all: ${OBJS}
	${CC} ${CFLAGS} -o savedump.exe ${OBJS} ${LIBS}

clean:
	rm -f ${OBJS} savedump.exe

.c.o:
	${CC} ${CFLAGS} -c -o $*.o $<

```

`Examples-pcap/savedump/savedump.c`:

```c
#ifdef _MSC_VER
/*
 * we do not want the warnings about the old deprecated and unsecure CRT functions
 * since these examples can be compiled under *nix as well
 */
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <pcap.h>

#ifdef _WIN32
#include <tchar.h>
BOOL LoadNpcapDlls()
{
	_TCHAR npcap_dir[512];
	UINT len;
	len = GetSystemDirectory(npcap_dir, 480);
	if (!len) {
		fprintf(stderr, "Error in GetSystemDirectory: %x", GetLastError());
		return FALSE;
	}
	_tcscat_s(npcap_dir, 512, _T("\\Npcap"));
	if (SetDllDirectory(npcap_dir) == 0) {
		fprintf(stderr, "Error in SetDllDirectory: %x", GetLastError());
		return FALSE;
	}
	return TRUE;
}
#endif

/* prototype of the packet handler */
void packet_handler(u_char *param, const struct pcap_pkthdr *header, const u_char *pkt_data);

int main(int argc, char **argv)
{
	pcap_if_t *alldevs;
	pcap_if_t *d;
	int inum;
	int i=0;
	pcap_t *adhandle;
	char errbuf[PCAP_ERRBUF_SIZE];
	pcap_dumper_t *dumpfile;
	
#ifdef _WIN32
	/* Load Npcap and its functions. */
	if (!LoadNpcapDlls())
	{
		fprintf(stderr, "Couldn't load Npcap\n");
		exit(1);
	}
#endif


    /* Check command line */
	if(argc != 2)
	{
        printf("usage: %s filename", argv[0]);
        return -1;
    }
    
	/* Retrieve the device list on the local machine */
	if (pcap_findalldevs(&alldevs, errbuf) == -1)
	{
		fprintf(stderr,"Error in pcap_findalldevs: %s\n", errbuf);
		exit(1);
	}
    
    /* Print the list */
    for(d=alldevs; d; d=d->next)
    {
        printf("%d. %s", ++i, d->name);
        if (d->description)
            printf(" (%s)\n", d->description);
        else
            printf(" (No description available)\n");
    }

    if(i==0)
    {
        printf("\nNo interfaces found! Make sure Npcap is installed.\n");
        return -1;
    }
    
    printf("Enter the interface number (1-%d):",i);
    scanf("%d", &inum);
    
    if(inum < 1 || inum > i)
    {
        printf("\nInterface number out of range.\n");
        /* Free the device list */
        pcap_freealldevs(alldevs);
        return -1;
    }
		
	/* Jump to the selected adapter */
    for(d=alldevs, i=0; i< inum-1 ;d=d->next, i++);
    
    
	/* Open the adapter */
	if ((adhandle= pcap_open_live(d->name,	// name of the device
							 65536,			// portion of the packet to capture. 
											// 65536 grants that the whole packet will be captured on all the MACs.
							 1,				// promiscuous mode (nonzero means promiscuous)
							 1000,			// read timeout
							 errbuf			// error buffer
							 )) == NULL)
	{
		fprintf(stderr,"\nUnable to open the adapter. %s is not supported by Npcap\n", d->name);
		/* Free the device list */
		pcap_freealldevs(alldevs);
		return -1;
	}

	/* Open the dump file */
	dumpfile = pcap_dump_open(adhandle, argv[1]);

	if(dumpfile==NULL)
	{
		fprintf(stderr,"\nError opening output file\n");
		return -1;
	}
    
    printf("\nlistening on %s... Press Ctrl+C to stop...\n", d->description);
	
    /* At this point, we no longer need the device list. Free it */
    pcap_freealldevs(alldevs);
    
    /* start the capture */
    pcap_loop(adhandle, 0, packet_handler, (unsigned char *)dumpfile);

    pcap_close(adhandle);
    return 0;
}

/* Callback function invoked by libpcap for every incoming packet */
void packet_handler(u_char *dumpfile, const struct pcap_pkthdr *header, const u_char *pkt_data)
{
	/* save the packet on the dump file */
	pcap_dump(dumpfile, header, pkt_data);
}

```

`Examples-pcap/savedump/savedump.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{1B8791CB-DD15-46BF-B0A2-879892085538}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="savedump.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`Examples-pcap/sendpack/GNUmakefile`:

```
# Makefile for cygwin gcc
# Nate Lawson <nate@rootlabs.com>

PCAP_PATH = ../../lib
CFLAGS = -g -O -mno-cygwin -I ../../include

OBJS = sendpack.o
LIBS = -L ${PCAP_PATH} -lwpcap

all: ${OBJS}
	${CC} ${CFLAGS} -o sendpack.exe ${OBJS} ${LIBS}

clean:
	rm -f ${OBJS} sendpack.exe

.c.o:
	${CC} ${CFLAGS} -c -o $*.o $<

```

`Examples-pcap/sendpack/sendpack.c`:

```c
#include <stdlib.h>
#include <stdio.h>

#include <pcap.h>

#ifdef _WIN32
#include <tchar.h>
BOOL LoadNpcapDlls()
{
	_TCHAR npcap_dir[512];
	UINT len;
	len = GetSystemDirectory(npcap_dir, 480);
	if (!len) {
		fprintf(stderr, "Error in GetSystemDirectory: %x", GetLastError());
		return FALSE;
	}
	_tcscat_s(npcap_dir, 512, _T("\\Npcap"));
	if (SetDllDirectory(npcap_dir) == 0) {
		fprintf(stderr, "Error in SetDllDirectory: %x", GetLastError());
		return FALSE;
	}
	return TRUE;
}
#endif

/* case-insensitive string comparison that may mix up special characters and numbers */
int close_enough(char *one, char *two)
{
	while (*one && *two)
	{
		if ( *one != *two && !(
			(*one >= 'a' && *one - *two == 0x20) ||
			(*two >= 'a' && *two - *one == 0x20)
			))
		{
			return 0;
		}
		one++;
		two++;
	}
	if (*one || *two)
	{
		return 0;
	}
	return 1;
}

#define ORIG_PACKET_LEN 64
int main(int argc, char **argv)
{
	pcap_t *fp;
	char errbuf[PCAP_ERRBUF_SIZE] = {0};
	u_char packet[ORIG_PACKET_LEN] = 
		/* Ethernet frame header */
		"\xff\xff\xff\xff\xff\xff" /* dst mac */
		"\x02\x02\x02\x02\x02\x02" /* src mac */
		"\x08\x00" /* ethertype IPv4 */
		/* IPv4 packet header */
		"\x45\x00\x00\x00" /* IPv4, minimal header, length TBD */
		"\x12\x34\x00\x00" /* IPID 0x1234, no fragmentation */
		"\x10\x11\x00\x00" /* TTL 0x10, UDP, checksum (not required) */
		"\x00\x00\x00\x00" /* src IP (TBD) */
		"\xff\xff\xff\xff" /* dst IP (broadcast) */
		/* UDP header */
		"\x00\x07\x00\x07" /* src port 7, dst port 7 (echo) */
		"\x00\x00\x00\x00" /* length TBD, cksum 0 (unset) */
	;
	u_char *sendme = packet;
	size_t packet_len = ORIG_PACKET_LEN;
	pcap_if_t *ifaces = NULL;
	pcap_if_t *dev = NULL;
	pcap_addr_t *addr = NULL;

#ifdef _WIN32
	/* Load Npcap and its functions. */
	if (!LoadNpcapDlls())
	{
		fprintf(stderr, "Couldn't load Npcap\n");
		exit(1);
	}
#endif

	/* Check the validity of the command line */
	if (argc != 2)
	{
		printf("usage: %s interface", argv[0]);
		return 1;
	}
    
	if (0 != pcap_init(PCAP_CHAR_ENC_LOCAL, errbuf)) {
		fprintf(stderr, "Failed to initialize pcap lib: %s\n", errbuf);
		return 2;
	}

	/* Find the IPv4 address of the device */
	if (0 != pcap_findalldevs(&ifaces, errbuf)) {
		fprintf(stderr, "Failed to get list of devices: %s\n", errbuf);
		return 2;
	}

	for (dev = ifaces; dev != NULL; dev = dev->next)
	{
		if (close_enough(dev->name, argv[1]))
		{
			break;
		}
	}
	if (dev == NULL) {
		fprintf(stderr, "Could not find %s in the list of devices\n", argv[1]);
		return 3;
	}

	for (addr = dev->addresses; addr != NULL; addr = addr->next)
	{
		if (addr->addr->sa_family == AF_INET)
		{
			break;
		}
	}
	if (addr == NULL) {
		fprintf(stderr, "Could not find IPv4 address for %s\n", argv[1]);
		return 3;
	}

	/* Fill in the length and source addr and calculate checksum */
	packet[14 + 2] = 0xff & ((ORIG_PACKET_LEN - 14) >> 8);
	packet[14 + 3] = 0xff & (ORIG_PACKET_LEN - 14);
	/* UDP length */
	packet[14 + 20 + 4] = 0xff & ((ORIG_PACKET_LEN - 14 - 20) >> 8);
	packet[14 + 20 + 5] = 0xff & (ORIG_PACKET_LEN - 14 - 20);
	*(u_long *)(packet + 14 + 12) = ((struct sockaddr_in *)(addr->addr))->sin_addr.S_un.S_addr;

	uint32_t cksum = 0;
	for (int i=14; i < 14 + 4 * (packet[14] & 0xf); i += 2)
	{
		cksum += *(uint16_t *)(packet + i);
	}
	while (cksum>>16)
		cksum = (cksum & 0xffff) + (cksum >> 16);
	cksum = ~cksum;
	*(uint16_t *)(packet + 14 + 10) = cksum;

	/* Open the adapter */
	if ((fp = pcap_open_live(argv[1],		// name of the device
							 0, // portion of the packet to capture. 0 == no capture.
							 0, // non-promiscuous mode
							 1000,			// read timeout
							 errbuf			// error buffer
							 )) == NULL)
	{
		fprintf(stderr,"\nUnable to open the adapter. %s is not supported by Npcap\n", argv[1]);
		return 2;
	}
	
	switch(pcap_datalink(fp))
	{
		case DLT_NULL:
			/* Skip Ethernet header, retreat NULL header length */
#define NULL_VS_ETH_DIFF (14 - 4)
			sendme = packet + NULL_VS_ETH_DIFF;
			packet_len -= NULL_VS_ETH_DIFF;
			// Pretend IPv4
			sendme[0] = 2;
			sendme[1] = 0;
			sendme[2] = 0;
			sendme[3] = 0;
			break;
		case DLT_EN10MB:
			/* Already set up */
			sendme = packet;
			break;
		default:
			fprintf(stderr, "\nError, unknown data-link type %u\n", pcap_datalink(fp));
			return 4;
	}
	
	/* Send down the packet */
	if (pcap_sendpacket(fp,	// Adapter
		sendme, // buffer with the packet
		packet_len // size
		) != 0)
	{
		fprintf(stderr,"\nError sending the packet: %s\n", pcap_geterr(fp));
		return 3;
	}

	pcap_close(fp);	
	return 0;
}

```

`Examples-pcap/sendpack/sendpack.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{1C376689-5F61-48E7-AE83-0DED9EE9E458}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="sendpack.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`Examples-pcap/stats/stats.c`:

```c
/*
 * Copyright (c) 2006
 * CACE Technologies, Davis, California
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright 
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright 
 * notice, this list of conditions and the following disclaimer in the 
 * documentation and/or other materials provided with the distribution. 
 * 3. Neither the name of the Politecnico di Torino nor the names of its 
 * contributors may be used to endorse or promote products derived from 
 * this software without specific prior written permission. 
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 *
 * This is a test for pcap_stats(). It opens an adapter, sets a filter that
 * drops all the packets, and then cycles printing the result of pcap_stats().
 * The following two defines can be used to specify the time between two calls
 * to pcap_stats(), and the kernel buffer size.
 *
 * Author: Loris Degioanni, April 2006
 *
 */

#include <pcap.h>
#include <stdio.h>

#define TIME_TO_SLEEP_MS 5000 
#define KERNEL_BUFFER_SIZE_BYTES 16000 

#ifdef _WIN32
#include <tchar.h>
BOOL LoadNpcapDlls()
{
	_TCHAR npcap_dir[512];
	UINT len;
	len = GetSystemDirectory(npcap_dir, 480);
	if (!len) {
		fprintf(stderr, "Error in GetSystemDirectory: %x", GetLastError());
		return FALSE;
	}
	_tcscat_s(npcap_dir, 512, _T("\\Npcap"));
	if (SetDllDirectory(npcap_dir) == 0) {
		fprintf(stderr, "Error in SetDllDirectory: %x", GetLastError());
		return FALSE;
	}
	return TRUE;
}
#endif

main()
{
	pcap_if_t *alldevs;
	pcap_if_t *d;
	int inum;
	int i = 0;
	pcap_t *adhandle;
	char errbuf[PCAP_ERRBUF_SIZE];
	struct pcap_stat stats;
	unsigned int j;
	u_int netmask;
	char packet_filter[] = "greater 30000";
	struct bpf_program fcode;
	
#ifdef _WIN32
	/* Load Npcap and its functions. */
	if (!LoadNpcapDlls())
	{
		fprintf(stderr, "Couldn't load Npcap\n");
		exit(1);
	}
#endif

	/* Retrieve the device list */
	if(pcap_findalldevs(&alldevs, errbuf) == -1)
	{
		fprintf(stderr,"Error in pcap_findalldevs: %s\n", errbuf);
		exit(1);
	}
	
	/* Print the list */
	for(d=alldevs; d; d=d->next)
	{
		printf("%d. %s", ++i, d->name);
		if (d->description)
			printf(" (%s)\n", d->description);
		else
			printf(" (No description available)\n");
	}

	if(i==0)
	{
		printf("\nNo interfaces found! Make sure Npcap is installed.\n");
		return -1;
	}
	
	printf("Enter the interface number (1-%d):",i);
	scanf("%d", &inum);
	
	/* Check if the user specified a valid adapter */
	if(inum < 1 || inum > i)
	{
		printf("\nAdapter number out of range.\n");
		
		/* Free the device list */
		pcap_freealldevs(alldevs);
		return -1;
	}

	/* Jump to the selected adapter */
	for(d = alldevs, i = 0; i < inum-1 ;d = d->next, i++);
	
	/* Open the adapter */
	if ((adhandle = pcap_open_live(d->name,	// name of the device
							 65536,			// portion of the packet to capture. 
											// 65536 grants that the whole packet will be captured on all the MACs.
							 1,				// promiscuous mode (nonzero means promiscuous)
							 1000,			// read timeout
							 errbuf			// error buffer
							 )) == NULL)
	{
		fprintf(stderr,"\nUnable to open the adapter: %s\n", errbuf);
		/* Free the device list */
		pcap_freealldevs(alldevs);
		return -1;
	}
			
	printf("\nlistening on %s...\n", d->description);
		
	if(d->addresses != NULL)
	{
		/* Retrieve the mask of the first address of the interface */
		netmask=((struct sockaddr_in *)(d->addresses->netmask))->sin_addr.S_un.S_addr;
	}
	else
	{
		/* If the interface is without addresses we suppose to be in a C class network */
		netmask=0xffffff; 
	}

	//compile the filter
	if (pcap_compile(adhandle, &fcode, packet_filter, 1, netmask) <0 )
	{
		fprintf(stderr,"\nUnable to compile the packet filter. Check the syntax.\n");
		/* Free the device list */
		pcap_freealldevs(alldevs);
		return -1;
	}
	
	/* At this point, we don't need any more the device list. Free it */
	pcap_freealldevs(alldevs);

	/* set the filter */
	if (pcap_setfilter(adhandle, &fcode)<0)
	{
		fprintf(stderr,"\nError setting the filter.\n");
		/* Free the device list */
		pcap_freealldevs(alldevs);
		return -1;
	}


	/* Set the kernel capture buffer size*/
	if(pcap_setbuff(adhandle, KERNEL_BUFFER_SIZE_BYTES) != 0)
	{
		printf("Error setting the kernel buffer (%s)\n", pcap_geterr(adhandle));
		return -1;

		pcap_close(adhandle);
	}

	/* cycle printing the statisctics from pcap_stats() */
	for(j = 0; ; j++)
	{
		pcap_stats(adhandle, &stats);

		printf("Recv: %u, Dropped:%u\n",
			stats.ps_recv,
			stats.ps_drop);

		if(j % 5 == 0)
		{
			Sleep(TIME_TO_SLEEP_MS);
		}
	}
	
	return 0;
}

```

`Examples-pcap/stats/stats.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{2D9808D5-5935-4A25-83FF-F51B0C93D945}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="stats.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`Examples-pcap/winpcap_stress/winpcap_stress.c`:

```c
/*============================================================================*
 * FILE: winpcap_stress.c
 *============================================================================*
 *
 * COPYRIGHT (C) 2006 BY
 *          CACE TECHNOLOGIES, INC., DAVIS, CALIFORNIA
 *          ALL RIGHTS RESERVED.
 *
 *          THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND
 *          COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE AND WITH
 *          THE INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY
 *          OTHER COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE
 *          AVAILABLE TO ANY OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF THE
 *          SOFTWARE IS HEREBY TRANSFERRED.
 *
 *          THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT
 *          NOTICE AND SHOULD NOT BE CONSTRUED AS A COMMITMENT BY CACE TECNOLOGIES
 *
 *===========================================================================*
 *
 * This program is a generic "stress test" for winpcap. It creates several threads
 * each of which opens an adapter, captures some packets and then closes it.
 * The user can specify:
 *
 *  - the number of threads
 *  - the number of read operations that every thread performs before exiting
 *
 * The program prints statistics before exiting.
 *
 *===========================================================================*/

/////////////////////////////////////////////////////////////////////
// Program parameters
/////////////////////////////////////////////////////////////////////
#undef STRESS_AIRPCAP_TRANSMISSION
#define NUM_THREADS 16
#define MAX_NUM_READS 500
#define MAX_NUM_WRITES 10000
#define READ_TIMEOUT	100

#define WRITES_FREQUENCY 2	// This constant specifies how often a thread will transmit instead of receiving
							// packets. 
							//   - 0 means no Tx threads 
							//   - 1 means all threads are Tx
							//   - 2 means that 1 thread every 2 is Tx
							//   - 3 means that 1 thread every 3 is Tx 
							//   ...and so on

#undef INJECT_FILTERS

/////////////////////////////////////////////////////////////////////

#include <stdlib.h>
#include <stdio.h>
#include <signal.h>

#include <pcap.h>

#ifdef STRESS_AIRPCAP_TRANSMISSION
#include <airpcap.h>
#endif

#define LINE_LEN 16

#ifdef _WIN32
#include <tchar.h>
BOOL LoadNpcapDlls()
{
	_TCHAR npcap_dir[512];
	UINT len;
	len = GetSystemDirectory(npcap_dir, 480);
	if (!len) {
		fprintf(stderr, "Error in GetSystemDirectory: %x", GetLastError());
		return FALSE;
	}
	_tcscat_s(npcap_dir, 512, _T("\\Npcap"));
	if (SetDllDirectory(npcap_dir) == 0) {
		fprintf(stderr, "Error in SetDllDirectory: %x", GetLastError());
		return FALSE;
	}
	return TRUE;
}
#endif


#define FILTER "ether[80:1] < 128 || ether[81:1] > 127 || ether[82:1] < 180 || ether[83:1] > 181" \
			"|| ether[84:1] < 128 || ether[85:1] > 127 || ether[86:1] < 180 || ether[87:1] > 181" \
			"|| ether[88:1] < 128 || ether[89:1] > 127 || ether[90:1] < 180 || ether[91:1] > 181" \
			"|| ether[92:1] < 128 || ether[93:1] > 127 || ether[94:1] < 180 || ether[95:1] > 181" \
			"|| ether[96:1] < 128 || ether[97:1] > 127 || ether[98:1] < 180 || ether[99:1] > 181" \
			"|| ether[100:1] < 128 || ether[101:1] > 127 || ether[102:1] < 180 || ether[103:1] > 181" \
			"|| ether[104:1] < 128 || ether[105:1] > 127 || ether[106:1] < 180 || ether[107:1] > 181" \
			"|| ether[108:1] < 128 || ether[109:1] > 127 || ether[110:1] < 180 || ether[111:1] > 181" \


u_int n_iterations = 0;
u_int n_packets = 0;
u_int n_timeouts = 0;
u_int n_open_errors = 0;
u_int n_read_errors = 0;
u_int n_write_errors = 0;
u_int n_findalldevs_errors = 0;
u_int n_setfilters = 0;
u_int thread_id = 0;

CRITICAL_SECTION print_cs;

#define MAX_TX_PACKET_SIZE 1604
u_char pkt_to_send[MAX_TX_PACKET_SIZE];


/////////////////////////////////////////////////////////////////////
// Radiotap header. Used for 802.11 transmission
/////////////////////////////////////////////////////////////////////

#ifndef __MINGW32__
#pragma pack(push)
#pragma pack(1)
#endif // __MINGW32__
typedef struct _tx_ieee80211_radiotap_header 
{
	u_int8_t it_version;
	u_int8_t it_pad;
	u_int16_t it_len;
	u_int32_t it_present;
	u_int8_t it_rate;
}
#ifdef __MINGW32__
__attribute__((__packed__))
#endif // __MINGW32__
tx_ieee80211_radiotap_header;
#ifndef __MINGW32__
#pragma pack(pop)
#endif // __MINGW32__

/////////////////////////////////////////////////////////////////////
// Table of legal radiotap Tx rates
/////////////////////////////////////////////////////////////////////
UCHAR TxRateInfoTable[] =
{
	2,	
	4,	
	11,
	12,
	18,
	22,
	24,
	36,
	48,
	72,
	96,
	108
};

/////////////////////////////////////////////////////////////////////

void usage()
{
	printf("winpcap_stress: utility that stresses winpcap by opening and capturing from multiple adapters at the same time.\n");
	printf("   Usage: winpcap_stress <nthreads> <adapter_substring_to_match>\n\n"
		"   Examples:\n"
		"      winpcap_stress\n"
		"      winpcap_stress 10\n\n"
		"      winpcap_stress 10 \\Device\\NPF_{ \n");	
}

/////////////////////////////////////////////////////////////////////

void sigh(int val)
{
	EnterCriticalSection(&print_cs);

	printf("\nNumber of iterations:\t\t%u\n", n_iterations);
	printf("Number of packets captured:\t\t%u\n", n_packets);
	printf("Number of read timeouts:\t\t%u\n", n_timeouts);
	printf("Number of open errors:\t\t%u\n", n_open_errors);
	printf("Number of read errors:\t\t%u\n", n_read_errors);
	printf("Number of setfilters:\t\t%u\n", n_setfilters);

	//
	// Note: we don't release the critical section on purpose, so the user doesn't 
	// get crappy input when he presses CTRL+C 
	//
	exit(0);
}



/////////////////////////////////////////////////////////////////////

DWORD WINAPI pcap_thread(LPVOID arg)
{
	pcap_t *fp;
	char* AdName = (char*)arg;
	char errbuf[PCAP_ERRBUF_SIZE];
	int res;
	struct pcap_pkthdr *header;
	const u_char *pkt_data;
	u_int i;
	u_int n_reads, n_writes;
#ifdef INJECT_FILTERS
	struct bpf_program fcode;
	int compile_result;
#endif
#ifdef STRESS_AIRPCAP_TRANSMISSION
	PAirpcapHandle airpcap_handle;
	tx_ieee80211_radiotap_header *radio_header;
	u_int rate_index;
#endif

	srand( (unsigned)time( NULL ) );

	//
	// Open the adapter
	//
	if((fp = pcap_open_live(AdName,
		65535,
		0,								// promiscuous mode
		READ_TIMEOUT,								// read timeout
		errbuf)) == NULL)
	{
		EnterCriticalSection(&print_cs);
		fprintf(stderr,"\nError opening adapter (%s)\n", errbuf);
		LeaveCriticalSection(&print_cs);
		n_open_errors++;
		return -1;
	}

	//
	// Decide if this is going to be a read or write thread
	//

	if((WRITES_FREQUENCY != 0) && ((thread_id++) % WRITES_FREQUENCY == 0))
	{
		//
		// Write thread
		//
		if(MAX_NUM_WRITES)
		{
			n_writes = rand() % MAX_NUM_READS;
		}
		else
		{
			n_writes = 0;
		}
		
		//
		// Get the airpcap handle so we can change wireless-specific settings
		//
#ifdef STRESS_AIRPCAP_TRANSMISSION
		airpcap_handle = pcap_get_airpcap_handle(fp);
		
		if(airpcap_handle != NULL)
		{
			//
			// Configure the AirPcap adapter
			//
			
			// Tell the adapter that the packets we'll send don't include the FCS
			if(!AirpcapSetFcsPresence(airpcap_handle, FALSE))
			{
				printf("Error setting the Fcs presence: %s\n", AirpcapGetLastError(airpcap_handle));
				pcap_close(fp);
				return -1;
			}
			
			//
			// Set the link layer to 802.11 + radiotap
			//
			if(!AirpcapSetLinkType(airpcap_handle, AIRPCAP_LT_802_11_PLUS_RADIO))
			{
				printf("Error setting the link layer: %s\n", AirpcapGetLastError(airpcap_handle));
				pcap_close(fp);
				return -1;
			}
			
			//
			// Create the radiotap header
			//
			radio_header = (tx_ieee80211_radiotap_header*)pkt_to_send;
			radio_header->it_version = 0;
			radio_header->it_pad = 0;
			radio_header->it_len = sizeof(tx_ieee80211_radiotap_header);
			radio_header->it_present = 1 << 2;	// bit 2 is the rate
			rate_index = 18/*rand() % (sizeof(TxRateInfoTable) / sizeof(TxRateInfoTable[0]))*/;
			radio_header->it_rate = 18/*TxRateInfoTable[rate_index]*/;
		}
#endif
		for(i = 0; i < n_writes; i++)
		{
			if(pcap_sendpacket(fp, pkt_to_send, (rand() % MAX_TX_PACKET_SIZE) + 10) != 0)
			{
//				EnterCriticalSection(&print_cs);
//				printf("Write Error: %s\n", pcap_geterr(fp));
//				LeaveCriticalSection(&print_cs);
				n_write_errors++;
			}
		}
	}
	else
	{
		
		//
		// Read Thread
		//
		if(MAX_NUM_READS)
		{
			n_reads = rand() % MAX_NUM_READS;
		}
		else
		{
			n_reads = 0;
		}
		
		for(i = 0; i < n_reads; i++)
		{
			res = pcap_next_ex(fp, &header, &pkt_data);
			
			if(res < 0)
			{
				break;
			}
			
#ifdef INJECT_FILTERS

			EnterCriticalSection(&print_cs);
			compile_result = pcap_compile(fp, &fcode, FILTER, 1, 0xFFFFFFFF);
			LeaveCriticalSection(&print_cs);
			
			
			
			//compile the filter
			if( compile_result < 0)
			{
				fprintf(stderr,"Error compiling filter: wrong syntax.\n");
			}
			else
			{
				//set the filterf
				if(pcap_setfilter(fp, &fcode)<0)
				{
					fprintf(stderr,"Error setting the filter\n");
				}
				else
				{
					InterlockedIncrement(&n_setfilters);
				}
				pcap_freecode(&fcode);
			}
#endif
			
			if(res == 0)
			{
				// Timeout elapsed
				n_timeouts++;
				continue;
			}
			
			
			// print pkt timestamp and pkt len
			n_packets++;
		}
		
		if(res == -1)
		{
			EnterCriticalSection(&print_cs);
			printf("Read error: %s\n", pcap_geterr(fp));
			LeaveCriticalSection(&print_cs);
			n_read_errors++;
		}
	}
	
	pcap_close(fp);
	
	return 1;
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

int main(int argc, char **argv)
{	
	pcap_if_t *alldevs, *d;
	u_int i;
	char errbuf[PCAP_ERRBUF_SIZE];
	u_int n_threads;
	HANDLE* hThreads;
	char* string_to_match;
	DWORD WaitRes;

#ifdef _WIN32
	/* Load Npcap and its functions. */
	if (!LoadNpcapDlls())
	{
		fprintf(stderr, "Couldn't load Npcap\n");
		exit(1);
	}
#endif

	//
	// Parse input
	//
	if(argc == 1)
	{
		n_threads = NUM_THREADS;
		string_to_match = NULL;
	}
	else
	if(argc == 2)
	{
		n_threads = atoi(argv[1]);
		string_to_match = NULL;
	}
	else
	if(argc == 3)
	{
		n_threads = atoi(argv[1]);
		string_to_match = argv[2];
	}
	else
	{
		usage();
		return 1;
	}

	//
	// Init the Tx packet
	//
	for(i = 0; i < MAX_TX_PACKET_SIZE; i++)
	{
		pkt_to_send[i] = i & 0xff; 
	}

	//
	// Allocate storage for the threads list
	//
	hThreads = (HANDLE*)malloc(n_threads * sizeof(HANDLE));
	if(!hThreads)
	{
		printf("Memeory allocation failure\n");
		return -1;
	}
	
	memset(hThreads, 0, n_threads * sizeof(HANDLE));

	signal(SIGINT, sigh);
	InitializeCriticalSection(&print_cs);

	// 
	// Scan the device list
	//
	if(pcap_findalldevs(&alldevs, errbuf) == -1)
	{
		EnterCriticalSection(&print_cs);
		fprintf(stderr,"Error in pcap_findalldevs_ex: %s\n", errbuf);
		LeaveCriticalSection(&print_cs);
		n_findalldevs_errors++;
//		continue;
		return -1;
	}
	
	//
	// Jump to the selected adapter
	//
	for(i = 0;;)
	{		
		//
		// Go through the list, feeding a thread with each adapter that contains our substring
		//
		for(d = alldevs; d; d = d->next)
		{
			if(string_to_match)
			{
				if(!strstr(d->name, string_to_match))
				{
					continue;
				}
			}

			if(i == n_threads)
			{
				i= 0;
			}
			
			//
			// Check if the thread is done
			//
			WaitRes = WaitForSingleObject(hThreads[i], 1);

			if(WaitRes == WAIT_TIMEOUT)
			{
				//
				// In case of timeout, we switch to the following thread
				//
				i++;
				continue;
			}
			
			//
			// Create the child thread
			//
			printf("Thread %u, %s 0x%x\n", i, d->name, WaitRes);
			
			//
			// Close the thread handle 
			//
			if(hThreads[i])
			{
				CloseHandle(hThreads[i]);
			}

			hThreads[i] = CreateThread(NULL, 0, pcap_thread, d->name, 0, NULL);
			
			if(hThreads[i] == NULL)
			{
				printf("error creating thread. Quitting\n");
				sigh(42);
			}

			n_iterations++;
			i++;
		}
	}
	
	free(hThreads);
	
	return 0;
}

```

`Examples-pcap/winpcap_stress/winpcap_stress.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{4F73FCBE-F4ED-45EA-A207-38633D9526D0}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="winpcap_stress.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`Examples/MakeAll.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31229.75
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "iflist", "iflist\iflist.vcxproj", "{0B27B213-4BF3-4611-B412-A2D09CDE8632}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "sendcap", "sendcap\sendcap.vcxproj", "{D6B93A03-446A-4B13-87B8-9AA752A5CC8C}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "GetMacAddress", "PacketDriver\GetMacAddress\GetMacAddress.vcxproj", "{1ED069D6-3B12-4175-A97D-7FFEBEA26628}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "TestPacketCapture", "PacketDriver\TestPacketCapture\TestPacketCapture.vcxproj", "{79942922-E02C-486D-9EE3-A13C0876C4C2}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "TestPacketSend", "PacketDriver\TestPacketSend\TestPacketSend.vcxproj", "{1E3BED58-2F2C-463A-B9FD-9A55235C6840}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "pcap_filter", "pcap_filter\pcap_filter.vcxproj", "{B9F68F6F-22AE-47A2-A3A3-1212831AF9FF}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "pcap_fopen", "pcap_fopen\pcap_fopen.vcxproj", "{DD317CB5-6337-498F-A560-553B5558E133}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "pktdump_ex", "pktdump_ex\pktdump_ex.vcxproj", "{3D62DEB4-3536-44AE-8E4B-AD6DFF1B795E}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "smp_1", "smp_1\smp_1.vcxproj", "{21F49E7F-6C58-4DA5-ABE5-A9DFB6165C83}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "tcptop", "tcptop\tcptop.vcxproj", "{B671D5DF-3A80-4A21-BC01-79E3FB73D372}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "UDPdump", "UDPdump\UDPdump.vcxproj", "{42E5F1D6-6E83-4C13-83CC-C6CD83478C58}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "UserBridge", "UserLevelBridge\UserBridge.vcxproj", "{BB73BFD4-454F-42C8-AFE6-FA890A8BD8FC}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "basic_dump", "misc\basic_dump.vcxproj", "{66297062-96A0-4F0E-B147-3C8384031232}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "basic_dump_ex", "misc\basic_dump_ex.vcxproj", "{92849630-6B09-409C-A7AD-E91E682558B1}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "readfile", "misc\readfile.vcxproj", "{161E7606-F4CD-4A04-AB6B-5837F7818EE1}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "readfile_ex", "misc\readfile_ex.vcxproj", "{3071DFB6-68F8-41EF-A56C-0C7A71B6967C}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "savedump", "misc\savedump.vcxproj", "{1B8791CB-DD15-46BF-B0A2-879892085538}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "sendpack", "misc\sendpack.vcxproj", "{1C376689-5F61-48E7-AE83-0DED9EE9E458}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{0B27B213-4BF3-4611-B412-A2D09CDE8632}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{0B27B213-4BF3-4611-B412-A2D09CDE8632}.Debug|ARM64.Build.0 = Debug|ARM64
		{0B27B213-4BF3-4611-B412-A2D09CDE8632}.Debug|x64.ActiveCfg = Debug|x64
		{0B27B213-4BF3-4611-B412-A2D09CDE8632}.Debug|x64.Build.0 = Debug|x64
		{0B27B213-4BF3-4611-B412-A2D09CDE8632}.Debug|x86.ActiveCfg = Debug|Win32
		{0B27B213-4BF3-4611-B412-A2D09CDE8632}.Debug|x86.Build.0 = Debug|Win32
		{0B27B213-4BF3-4611-B412-A2D09CDE8632}.Release|ARM64.ActiveCfg = Release|ARM64
		{0B27B213-4BF3-4611-B412-A2D09CDE8632}.Release|ARM64.Build.0 = Release|ARM64
		{0B27B213-4BF3-4611-B412-A2D09CDE8632}.Release|x64.ActiveCfg = Release|x64
		{0B27B213-4BF3-4611-B412-A2D09CDE8632}.Release|x64.Build.0 = Release|x64
		{0B27B213-4BF3-4611-B412-A2D09CDE8632}.Release|x86.ActiveCfg = Release|Win32
		{0B27B213-4BF3-4611-B412-A2D09CDE8632}.Release|x86.Build.0 = Release|Win32
		{D6B93A03-446A-4B13-87B8-9AA752A5CC8C}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{D6B93A03-446A-4B13-87B8-9AA752A5CC8C}.Debug|ARM64.Build.0 = Debug|ARM64
		{D6B93A03-446A-4B13-87B8-9AA752A5CC8C}.Debug|x64.ActiveCfg = Debug|x64
		{D6B93A03-446A-4B13-87B8-9AA752A5CC8C}.Debug|x64.Build.0 = Debug|x64
		{D6B93A03-446A-4B13-87B8-9AA752A5CC8C}.Debug|x86.ActiveCfg = Debug|Win32
		{D6B93A03-446A-4B13-87B8-9AA752A5CC8C}.Debug|x86.Build.0 = Debug|Win32
		{D6B93A03-446A-4B13-87B8-9AA752A5CC8C}.Release|ARM64.ActiveCfg = Release|ARM64
		{D6B93A03-446A-4B13-87B8-9AA752A5CC8C}.Release|ARM64.Build.0 = Release|ARM64
		{D6B93A03-446A-4B13-87B8-9AA752A5CC8C}.Release|x64.ActiveCfg = Release|x64
		{D6B93A03-446A-4B13-87B8-9AA752A5CC8C}.Release|x64.Build.0 = Release|x64
		{D6B93A03-446A-4B13-87B8-9AA752A5CC8C}.Release|x86.ActiveCfg = Release|Win32
		{D6B93A03-446A-4B13-87B8-9AA752A5CC8C}.Release|x86.Build.0 = Release|Win32
		{1ED069D6-3B12-4175-A97D-7FFEBEA26628}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{1ED069D6-3B12-4175-A97D-7FFEBEA26628}.Debug|ARM64.Build.0 = Debug|ARM64
		{1ED069D6-3B12-4175-A97D-7FFEBEA26628}.Debug|x64.ActiveCfg = Debug|x64
		{1ED069D6-3B12-4175-A97D-7FFEBEA26628}.Debug|x64.Build.0 = Debug|x64
		{1ED069D6-3B12-4175-A97D-7FFEBEA26628}.Debug|x86.ActiveCfg = Debug|Win32
		{1ED069D6-3B12-4175-A97D-7FFEBEA26628}.Debug|x86.Build.0 = Debug|Win32
		{1ED069D6-3B12-4175-A97D-7FFEBEA26628}.Release|ARM64.ActiveCfg = Release|ARM64
		{1ED069D6-3B12-4175-A97D-7FFEBEA26628}.Release|ARM64.Build.0 = Release|ARM64
		{1ED069D6-3B12-4175-A97D-7FFEBEA26628}.Release|x64.ActiveCfg = Release|x64
		{1ED069D6-3B12-4175-A97D-7FFEBEA26628}.Release|x64.Build.0 = Release|x64
		{1ED069D6-3B12-4175-A97D-7FFEBEA26628}.Release|x86.ActiveCfg = Release|Win32
		{1ED069D6-3B12-4175-A97D-7FFEBEA26628}.Release|x86.Build.0 = Release|Win32
		{79942922-E02C-486D-9EE3-A13C0876C4C2}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{79942922-E02C-486D-9EE3-A13C0876C4C2}.Debug|ARM64.Build.0 = Debug|ARM64
		{79942922-E02C-486D-9EE3-A13C0876C4C2}.Debug|x64.ActiveCfg = Debug|x64
		{79942922-E02C-486D-9EE3-A13C0876C4C2}.Debug|x64.Build.0 = Debug|x64
		{79942922-E02C-486D-9EE3-A13C0876C4C2}.Debug|x86.ActiveCfg = Debug|Win32
		{79942922-E02C-486D-9EE3-A13C0876C4C2}.Debug|x86.Build.0 = Debug|Win32
		{79942922-E02C-486D-9EE3-A13C0876C4C2}.Release|ARM64.ActiveCfg = Release|ARM64
		{79942922-E02C-486D-9EE3-A13C0876C4C2}.Release|ARM64.Build.0 = Release|ARM64
		{79942922-E02C-486D-9EE3-A13C0876C4C2}.Release|x64.ActiveCfg = Release|x64
		{79942922-E02C-486D-9EE3-A13C0876C4C2}.Release|x64.Build.0 = Release|x64
		{79942922-E02C-486D-9EE3-A13C0876C4C2}.Release|x86.ActiveCfg = Release|Win32
		{79942922-E02C-486D-9EE3-A13C0876C4C2}.Release|x86.Build.0 = Release|Win32
		{1E3BED58-2F2C-463A-B9FD-9A55235C6840}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{1E3BED58-2F2C-463A-B9FD-9A55235C6840}.Debug|ARM64.Build.0 = Debug|ARM64
		{1E3BED58-2F2C-463A-B9FD-9A55235C6840}.Debug|x64.ActiveCfg = Debug|x64
		{1E3BED58-2F2C-463A-B9FD-9A55235C6840}.Debug|x64.Build.0 = Debug|x64
		{1E3BED58-2F2C-463A-B9FD-9A55235C6840}.Debug|x86.ActiveCfg = Debug|Win32
		{1E3BED58-2F2C-463A-B9FD-9A55235C6840}.Debug|x86.Build.0 = Debug|Win32
		{1E3BED58-2F2C-463A-B9FD-9A55235C6840}.Release|ARM64.ActiveCfg = Release|ARM64
		{1E3BED58-2F2C-463A-B9FD-9A55235C6840}.Release|ARM64.Build.0 = Release|ARM64
		{1E3BED58-2F2C-463A-B9FD-9A55235C6840}.Release|x64.ActiveCfg = Release|x64
		{1E3BED58-2F2C-463A-B9FD-9A55235C6840}.Release|x64.Build.0 = Release|x64
		{1E3BED58-2F2C-463A-B9FD-9A55235C6840}.Release|x86.ActiveCfg = Release|Win32
		{1E3BED58-2F2C-463A-B9FD-9A55235C6840}.Release|x86.Build.0 = Release|Win32
		{B9F68F6F-22AE-47A2-A3A3-1212831AF9FF}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{B9F68F6F-22AE-47A2-A3A3-1212831AF9FF}.Debug|ARM64.Build.0 = Debug|ARM64
		{B9F68F6F-22AE-47A2-A3A3-1212831AF9FF}.Debug|x64.ActiveCfg = Debug|x64
		{B9F68F6F-22AE-47A2-A3A3-1212831AF9FF}.Debug|x64.Build.0 = Debug|x64
		{B9F68F6F-22AE-47A2-A3A3-1212831AF9FF}.Debug|x86.ActiveCfg = Debug|Win32
		{B9F68F6F-22AE-47A2-A3A3-1212831AF9FF}.Debug|x86.Build.0 = Debug|Win32
		{B9F68F6F-22AE-47A2-A3A3-1212831AF9FF}.Release|ARM64.ActiveCfg = Release|ARM64
		{B9F68F6F-22AE-47A2-A3A3-1212831AF9FF}.Release|ARM64.Build.0 = Release|ARM64
		{B9F68F6F-22AE-47A2-A3A3-1212831AF9FF}.Release|x64.ActiveCfg = Release|x64
		{B9F68F6F-22AE-47A2-A3A3-1212831AF9FF}.Release|x64.Build.0 = Release|x64
		{B9F68F6F-22AE-47A2-A3A3-1212831AF9FF}.Release|x86.ActiveCfg = Release|Win32
		{B9F68F6F-22AE-47A2-A3A3-1212831AF9FF}.Release|x86.Build.0 = Release|Win32
		{DD317CB5-6337-498F-A560-553B5558E133}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{DD317CB5-6337-498F-A560-553B5558E133}.Debug|ARM64.Build.0 = Debug|ARM64
		{DD317CB5-6337-498F-A560-553B5558E133}.Debug|x64.ActiveCfg = Debug|x64
		{DD317CB5-6337-498F-A560-553B5558E133}.Debug|x64.Build.0 = Debug|x64
		{DD317CB5-6337-498F-A560-553B5558E133}.Debug|x86.ActiveCfg = Debug|Win32
		{DD317CB5-6337-498F-A560-553B5558E133}.Debug|x86.Build.0 = Debug|Win32
		{DD317CB5-6337-498F-A560-553B5558E133}.Release|ARM64.ActiveCfg = Release|ARM64
		{DD317CB5-6337-498F-A560-553B5558E133}.Release|ARM64.Build.0 = Release|ARM64
		{DD317CB5-6337-498F-A560-553B5558E133}.Release|x64.ActiveCfg = Release|x64
		{DD317CB5-6337-498F-A560-553B5558E133}.Release|x64.Build.0 = Release|x64
		{DD317CB5-6337-498F-A560-553B5558E133}.Release|x86.ActiveCfg = Release|Win32
		{DD317CB5-6337-498F-A560-553B5558E133}.Release|x86.Build.0 = Release|Win32
		{3D62DEB4-3536-44AE-8E4B-AD6DFF1B795E}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{3D62DEB4-3536-44AE-8E4B-AD6DFF1B795E}.Debug|ARM64.Build.0 = Debug|ARM64
		{3D62DEB4-3536-44AE-8E4B-AD6DFF1B795E}.Debug|x64.ActiveCfg = Debug|x64
		{3D62DEB4-3536-44AE-8E4B-AD6DFF1B795E}.Debug|x64.Build.0 = Debug|x64
		{3D62DEB4-3536-44AE-8E4B-AD6DFF1B795E}.Debug|x86.ActiveCfg = Debug|Win32
		{3D62DEB4-3536-44AE-8E4B-AD6DFF1B795E}.Debug|x86.Build.0 = Debug|Win32
		{3D62DEB4-3536-44AE-8E4B-AD6DFF1B795E}.Release|ARM64.ActiveCfg = Release|ARM64
		{3D62DEB4-3536-44AE-8E4B-AD6DFF1B795E}.Release|ARM64.Build.0 = Release|ARM64
		{3D62DEB4-3536-44AE-8E4B-AD6DFF1B795E}.Release|x64.ActiveCfg = Release|x64
		{3D62DEB4-3536-44AE-8E4B-AD6DFF1B795E}.Release|x64.Build.0 = Release|x64
		{3D62DEB4-3536-44AE-8E4B-AD6DFF1B795E}.Release|x86.ActiveCfg = Release|Win32
		{3D62DEB4-3536-44AE-8E4B-AD6DFF1B795E}.Release|x86.Build.0 = Release|Win32
		{21F49E7F-6C58-4DA5-ABE5-A9DFB6165C83}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{21F49E7F-6C58-4DA5-ABE5-A9DFB6165C83}.Debug|ARM64.Build.0 = Debug|ARM64
		{21F49E7F-6C58-4DA5-ABE5-A9DFB6165C83}.Debug|x64.ActiveCfg = Debug|x64
		{21F49E7F-6C58-4DA5-ABE5-A9DFB6165C83}.Debug|x64.Build.0 = Debug|x64
		{21F49E7F-6C58-4DA5-ABE5-A9DFB6165C83}.Debug|x86.ActiveCfg = Debug|Win32
		{21F49E7F-6C58-4DA5-ABE5-A9DFB6165C83}.Debug|x86.Build.0 = Debug|Win32
		{21F49E7F-6C58-4DA5-ABE5-A9DFB6165C83}.Release|ARM64.ActiveCfg = Release|ARM64
		{21F49E7F-6C58-4DA5-ABE5-A9DFB6165C83}.Release|ARM64.Build.0 = Release|ARM64
		{21F49E7F-6C58-4DA5-ABE5-A9DFB6165C83}.Release|x64.ActiveCfg = Release|x64
		{21F49E7F-6C58-4DA5-ABE5-A9DFB6165C83}.Release|x64.Build.0 = Release|x64
		{21F49E7F-6C58-4DA5-ABE5-A9DFB6165C83}.Release|x86.ActiveCfg = Release|Win32
		{21F49E7F-6C58-4DA5-ABE5-A9DFB6165C83}.Release|x86.Build.0 = Release|Win32
		{B671D5DF-3A80-4A21-BC01-79E3FB73D372}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{B671D5DF-3A80-4A21-BC01-79E3FB73D372}.Debug|ARM64.Build.0 = Debug|ARM64
		{B671D5DF-3A80-4A21-BC01-79E3FB73D372}.Debug|x64.ActiveCfg = Debug|x64
		{B671D5DF-3A80-4A21-BC01-79E3FB73D372}.Debug|x64.Build.0 = Debug|x64
		{B671D5DF-3A80-4A21-BC01-79E3FB73D372}.Debug|x86.ActiveCfg = Debug|Win32
		{B671D5DF-3A80-4A21-BC01-79E3FB73D372}.Debug|x86.Build.0 = Debug|Win32
		{B671D5DF-3A80-4A21-BC01-79E3FB73D372}.Release|ARM64.ActiveCfg = Release|ARM64
		{B671D5DF-3A80-4A21-BC01-79E3FB73D372}.Release|ARM64.Build.0 = Release|ARM64
		{B671D5DF-3A80-4A21-BC01-79E3FB73D372}.Release|x64.ActiveCfg = Release|x64
		{B671D5DF-3A80-4A21-BC01-79E3FB73D372}.Release|x64.Build.0 = Release|x64
		{B671D5DF-3A80-4A21-BC01-79E3FB73D372}.Release|x86.ActiveCfg = Release|Win32
		{B671D5DF-3A80-4A21-BC01-79E3FB73D372}.Release|x86.Build.0 = Release|Win32
		{42E5F1D6-6E83-4C13-83CC-C6CD83478C58}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{42E5F1D6-6E83-4C13-83CC-C6CD83478C58}.Debug|ARM64.Build.0 = Debug|ARM64
		{42E5F1D6-6E83-4C13-83CC-C6CD83478C58}.Debug|x64.ActiveCfg = Debug|x64
		{42E5F1D6-6E83-4C13-83CC-C6CD83478C58}.Debug|x64.Build.0 = Debug|x64
		{42E5F1D6-6E83-4C13-83CC-C6CD83478C58}.Debug|x86.ActiveCfg = Debug|Win32
		{42E5F1D6-6E83-4C13-83CC-C6CD83478C58}.Debug|x86.Build.0 = Debug|Win32
		{42E5F1D6-6E83-4C13-83CC-C6CD83478C58}.Release|ARM64.ActiveCfg = Release|ARM64
		{42E5F1D6-6E83-4C13-83CC-C6CD83478C58}.Release|ARM64.Build.0 = Release|ARM64
		{42E5F1D6-6E83-4C13-83CC-C6CD83478C58}.Release|x64.ActiveCfg = Release|x64
		{42E5F1D6-6E83-4C13-83CC-C6CD83478C58}.Release|x64.Build.0 = Release|x64
		{42E5F1D6-6E83-4C13-83CC-C6CD83478C58}.Release|x86.ActiveCfg = Release|Win32
		{42E5F1D6-6E83-4C13-83CC-C6CD83478C58}.Release|x86.Build.0 = Release|Win32
		{BB73BFD4-454F-42C8-AFE6-FA890A8BD8FC}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{BB73BFD4-454F-42C8-AFE6-FA890A8BD8FC}.Debug|ARM64.Build.0 = Debug|ARM64
		{BB73BFD4-454F-42C8-AFE6-FA890A8BD8FC}.Debug|x64.ActiveCfg = Debug|x64
		{BB73BFD4-454F-42C8-AFE6-FA890A8BD8FC}.Debug|x64.Build.0 = Debug|x64
		{BB73BFD4-454F-42C8-AFE6-FA890A8BD8FC}.Debug|x86.ActiveCfg = Debug|Win32
		{BB73BFD4-454F-42C8-AFE6-FA890A8BD8FC}.Debug|x86.Build.0 = Debug|Win32
		{BB73BFD4-454F-42C8-AFE6-FA890A8BD8FC}.Release|ARM64.ActiveCfg = Release|ARM64
		{BB73BFD4-454F-42C8-AFE6-FA890A8BD8FC}.Release|ARM64.Build.0 = Release|ARM64
		{BB73BFD4-454F-42C8-AFE6-FA890A8BD8FC}.Release|x64.ActiveCfg = Release|x64
		{BB73BFD4-454F-42C8-AFE6-FA890A8BD8FC}.Release|x64.Build.0 = Release|x64
		{BB73BFD4-454F-42C8-AFE6-FA890A8BD8FC}.Release|x86.ActiveCfg = Release|Win32
		{BB73BFD4-454F-42C8-AFE6-FA890A8BD8FC}.Release|x86.Build.0 = Release|Win32
		{66297062-96A0-4F0E-B147-3C8384031232}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{66297062-96A0-4F0E-B147-3C8384031232}.Debug|ARM64.Build.0 = Debug|ARM64
		{66297062-96A0-4F0E-B147-3C8384031232}.Debug|x64.ActiveCfg = Debug|x64
		{66297062-96A0-4F0E-B147-3C8384031232}.Debug|x64.Build.0 = Debug|x64
		{66297062-96A0-4F0E-B147-3C8384031232}.Debug|x86.ActiveCfg = Debug|Win32
		{66297062-96A0-4F0E-B147-3C8384031232}.Debug|x86.Build.0 = Debug|Win32
		{66297062-96A0-4F0E-B147-3C8384031232}.Release|ARM64.ActiveCfg = Release|ARM64
		{66297062-96A0-4F0E-B147-3C8384031232}.Release|ARM64.Build.0 = Release|ARM64
		{66297062-96A0-4F0E-B147-3C8384031232}.Release|x64.ActiveCfg = Release|x64
		{66297062-96A0-4F0E-B147-3C8384031232}.Release|x64.Build.0 = Release|x64
		{66297062-96A0-4F0E-B147-3C8384031232}.Release|x86.ActiveCfg = Release|Win32
		{66297062-96A0-4F0E-B147-3C8384031232}.Release|x86.Build.0 = Release|Win32
		{92849630-6B09-409C-A7AD-E91E682558B1}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{92849630-6B09-409C-A7AD-E91E682558B1}.Debug|ARM64.Build.0 = Debug|ARM64
		{92849630-6B09-409C-A7AD-E91E682558B1}.Debug|x64.ActiveCfg = Debug|x64
		{92849630-6B09-409C-A7AD-E91E682558B1}.Debug|x64.Build.0 = Debug|x64
		{92849630-6B09-409C-A7AD-E91E682558B1}.Debug|x86.ActiveCfg = Debug|Win32
		{92849630-6B09-409C-A7AD-E91E682558B1}.Debug|x86.Build.0 = Debug|Win32
		{92849630-6B09-409C-A7AD-E91E682558B1}.Release|ARM64.ActiveCfg = Release|ARM64
		{92849630-6B09-409C-A7AD-E91E682558B1}.Release|ARM64.Build.0 = Release|ARM64
		{92849630-6B09-409C-A7AD-E91E682558B1}.Release|x64.ActiveCfg = Release|x64
		{92849630-6B09-409C-A7AD-E91E682558B1}.Release|x64.Build.0 = Release|x64
		{92849630-6B09-409C-A7AD-E91E682558B1}.Release|x86.ActiveCfg = Release|Win32
		{92849630-6B09-409C-A7AD-E91E682558B1}.Release|x86.Build.0 = Release|Win32
		{161E7606-F4CD-4A04-AB6B-5837F7818EE1}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{161E7606-F4CD-4A04-AB6B-5837F7818EE1}.Debug|ARM64.Build.0 = Debug|ARM64
		{161E7606-F4CD-4A04-AB6B-5837F7818EE1}.Debug|x64.ActiveCfg = Debug|x64
		{161E7606-F4CD-4A04-AB6B-5837F7818EE1}.Debug|x64.Build.0 = Debug|x64
		{161E7606-F4CD-4A04-AB6B-5837F7818EE1}.Debug|x86.ActiveCfg = Debug|Win32
		{161E7606-F4CD-4A04-AB6B-5837F7818EE1}.Debug|x86.Build.0 = Debug|Win32
		{161E7606-F4CD-4A04-AB6B-5837F7818EE1}.Release|ARM64.ActiveCfg = Release|ARM64
		{161E7606-F4CD-4A04-AB6B-5837F7818EE1}.Release|ARM64.Build.0 = Release|ARM64
		{161E7606-F4CD-4A04-AB6B-5837F7818EE1}.Release|x64.ActiveCfg = Release|x64
		{161E7606-F4CD-4A04-AB6B-5837F7818EE1}.Release|x64.Build.0 = Release|x64
		{161E7606-F4CD-4A04-AB6B-5837F7818EE1}.Release|x86.ActiveCfg = Release|Win32
		{161E7606-F4CD-4A04-AB6B-5837F7818EE1}.Release|x86.Build.0 = Release|Win32
		{3071DFB6-68F8-41EF-A56C-0C7A71B6967C}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{3071DFB6-68F8-41EF-A56C-0C7A71B6967C}.Debug|ARM64.Build.0 = Debug|ARM64
		{3071DFB6-68F8-41EF-A56C-0C7A71B6967C}.Debug|x64.ActiveCfg = Debug|x64
		{3071DFB6-68F8-41EF-A56C-0C7A71B6967C}.Debug|x64.Build.0 = Debug|x64
		{3071DFB6-68F8-41EF-A56C-0C7A71B6967C}.Debug|x86.ActiveCfg = Debug|Win32
		{3071DFB6-68F8-41EF-A56C-0C7A71B6967C}.Debug|x86.Build.0 = Debug|Win32
		{3071DFB6-68F8-41EF-A56C-0C7A71B6967C}.Release|ARM64.ActiveCfg = Release|ARM64
		{3071DFB6-68F8-41EF-A56C-0C7A71B6967C}.Release|ARM64.Build.0 = Release|ARM64
		{3071DFB6-68F8-41EF-A56C-0C7A71B6967C}.Release|x64.ActiveCfg = Release|x64
		{3071DFB6-68F8-41EF-A56C-0C7A71B6967C}.Release|x64.Build.0 = Release|x64
		{3071DFB6-68F8-41EF-A56C-0C7A71B6967C}.Release|x86.ActiveCfg = Release|Win32
		{3071DFB6-68F8-41EF-A56C-0C7A71B6967C}.Release|x86.Build.0 = Release|Win32
		{1B8791CB-DD15-46BF-B0A2-879892085538}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{1B8791CB-DD15-46BF-B0A2-879892085538}.Debug|ARM64.Build.0 = Debug|ARM64
		{1B8791CB-DD15-46BF-B0A2-879892085538}.Debug|x64.ActiveCfg = Debug|x64
		{1B8791CB-DD15-46BF-B0A2-879892085538}.Debug|x64.Build.0 = Debug|x64
		{1B8791CB-DD15-46BF-B0A2-879892085538}.Debug|x86.ActiveCfg = Debug|Win32
		{1B8791CB-DD15-46BF-B0A2-879892085538}.Debug|x86.Build.0 = Debug|Win32
		{1B8791CB-DD15-46BF-B0A2-879892085538}.Release|ARM64.ActiveCfg = Release|ARM64
		{1B8791CB-DD15-46BF-B0A2-879892085538}.Release|ARM64.Build.0 = Release|ARM64
		{1B8791CB-DD15-46BF-B0A2-879892085538}.Release|x64.ActiveCfg = Release|x64
		{1B8791CB-DD15-46BF-B0A2-879892085538}.Release|x64.Build.0 = Release|x64
		{1B8791CB-DD15-46BF-B0A2-879892085538}.Release|x86.ActiveCfg = Release|Win32
		{1B8791CB-DD15-46BF-B0A2-879892085538}.Release|x86.Build.0 = Release|Win32
		{1C376689-5F61-48E7-AE83-0DED9EE9E458}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{1C376689-5F61-48E7-AE83-0DED9EE9E458}.Debug|ARM64.Build.0 = Debug|ARM64
		{1C376689-5F61-48E7-AE83-0DED9EE9E458}.Debug|x64.ActiveCfg = Debug|x64
		{1C376689-5F61-48E7-AE83-0DED9EE9E458}.Debug|x64.Build.0 = Debug|x64
		{1C376689-5F61-48E7-AE83-0DED9EE9E458}.Debug|x86.ActiveCfg = Debug|Win32
		{1C376689-5F61-48E7-AE83-0DED9EE9E458}.Debug|x86.Build.0 = Debug|Win32
		{1C376689-5F61-48E7-AE83-0DED9EE9E458}.Release|ARM64.ActiveCfg = Release|ARM64
		{1C376689-5F61-48E7-AE83-0DED9EE9E458}.Release|ARM64.Build.0 = Release|ARM64
		{1C376689-5F61-48E7-AE83-0DED9EE9E458}.Release|x64.ActiveCfg = Release|x64
		{1C376689-5F61-48E7-AE83-0DED9EE9E458}.Release|x64.Build.0 = Release|x64
		{1C376689-5F61-48E7-AE83-0DED9EE9E458}.Release|x86.ActiveCfg = Release|Win32
		{1C376689-5F61-48E7-AE83-0DED9EE9E458}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {3A93F6BE-2B93-4E52-B58A-DAD8BA66C9F7}
	EndGlobalSection
EndGlobal

```

`Examples/NETMETER/CapDll.h`:

```h
/*
 * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)
 * Copyright (c) 2005 - 2006 CACE Technologies, Davis (California)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Politecnico di Torino, CACE Technologies 
 * nor the names of its contributors may be used to endorse or promote 
 * products derived from this software without specific prior written 
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */


#if !defined(AFX_CapDll_H__03FA9206_C8EA_11D2_B729_0048540133F7__INCLUDED_)
#define AFX_CapDll_H__03FA9206_C8EA_11D2_B729_0048540133F7__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols
#define MaxCapPars 10

/////////////////////////////////////////////////////////////////////////////
// CCapDll:
// See CapDll.cpp for the implementation of this class
//
#ifdef _EXPORTING   
#define CLASS_DECLSPEC __declspec(dllexport)
#else
#define CLASS_DECLSPEC __declspec(dllimport)
#endif

void CLASS_DECLSPEC InitCapDll(const char* INI);

class CLASS_DECLSPEC CCapDll
{
public:
	CCapDll();
	const char* GetFileName();
	char* SetFileName(const char* fn);
	const char* GetAdapter();
	const char* GetPath();
	const char* GetFilter();
	char* SetPath(const char * p);
	char* SetAdapter(const char* ad);
	char* SetFilter(const char* ad);
	int CaptureDialog(const char* Adapter,const char* P, CWnd* mw);
	int ChooseAdapter(const char* Adapter, CWnd* mw);
	const char* Capture(const char* file, CWnd* mw);
	~CCapDll();
private:
	char* Path;
	char* Adapter;
	char* FileName;
	char* Filter;
	int bufdim;
	int ncapture;
	int snaplen;	
	int promisquous;
	void LoadCmds();
	CString RetrieveValue(CString keyval);
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CapDll_H__03FA9206_C8EA_11D2_B729_0048540133F7__INCLUDED_)

```

`Examples/NETMETER/CaptureThread.cpp`:

```cpp
/*
 * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)
 * Copyright (c) 2005 - 2006 CACE Technologies, Davis (California)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Politecnico di Torino, CACE Technologies 
 * nor the names of its contributors may be used to endorse or promote 
 * products derived from this software without specific prior written 
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include "stdafx.h"
#include "resource.h"
#include "capdll.h"
#include "console.h"

HANDLE in,out,err;

DWORD d;
CCapPars* pObject;
CRITICAL_SECTION Crit;

// callback routine called by libpcap for every incoming packet
void dispatcher_handler(u_char *pParam,const struct pcap_pkthdr *header, const u_char *pkt_data)
{
UINT delay;
LARGE_INTEGER Bps,Pps;
CCapPars* pObject;

	pObject=(CCapPars*)pParam;
	//Calculate the delay in microseconds from the last sample.
	//This value is obtained from the timestamp that the capture driver
	//associates to the sample.
	delay=(header->ts.tv_sec-pObject->lasttime.tv_sec)*1000000-pObject->lasttime.tv_usec+header->ts.tv_usec;
	//get the number of Bits per second
	Bps.QuadPart=(((LONGLONG)(*(LONGLONG*)(pkt_data+8))*80)/(delay));
	//get the number of Packets per second
	Pps.QuadPart=(((LONGLONG)(*(LONGLONG*)(pkt_data))*100000000)/((LONGLONG)delay*14880));

	//store current timestamp
	pObject->lasttime.tv_sec=header->ts.tv_sec;
	pObject->lasttime.tv_usec=header->ts.tv_usec;

	pObject->prg->DrawBoard(&(pObject->prg->DrawBuffer),pObject->prg->wrett,Bps.LowPart,Pps.LowPart);
}

//main thread procedure: launches the capture and wait
UINT MyThreadProc( LPVOID pParam )
{   
	int i;

    if (pParam == NULL)
    return -1;    // illegal parameter
	pObject=(CCapPars*)pParam;

	//reset the timer
	pObject->lasttime.tv_sec=0;
	pObject->lasttime.tv_usec=0;

	//start the capture loop
	i = pcap_loop(pObject->fp, 0, dispatcher_handler, (PUCHAR)pParam);

	Sleep(INFINITE);

	return 0;
}


```

`Examples/NETMETER/Console.h`:

```h
/*
 * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)
 * Copyright (c) 2005 - 2006 CACE Technologies, Davis (California)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Politecnico di Torino, CACE Technologies 
 * nor the names of its contributors may be used to endorse or promote 
 * products derived from this software without specific prior written 
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <pcap.h>
#include "netmeterDoc.h"
#include "netmeterView.h"

UINT MyThreadProc( LPVOID pParam );

typedef struct CCapPars
{
	CNetmeterView* prg;	//CNetmeterView class that launched the capture thread
	pcap_t *fp;			//libpcap adapter
	struct timeval lasttime;	//last capture time (internal)
}CCapPars;

```

`Examples/NETMETER/LineColl.cpp`:

```cpp
/*
 * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)
 * Copyright (c) 2005 - 2006 CACE Technologies, Davis (California)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Politecnico di Torino, CACE Technologies 
 * nor the names of its contributors may be used to endorse or promote 
 * products derived from this software without specific prior written 
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include "LineColl.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

LineCollection::LineCollection(CString *s,int skip)
{
	m_Skip=skip;
	if(s==NULL) return;
	*this=*s;
}

LineCollection::LineCollection(CArchive &ar,int skip)
{
	if (ar.IsStoring())
	{
		return;
	}
	else
	{
		m_Skip=skip;
		CString s;
		int i,j;
		vect.SetSize(0);
		for(i=0,j=0;ar.ReadString(s);i++)
		{
			if(m_Skip && s=="") continue;
			vect.SetSize(j+1);
			vect[j]=s;
			j++;
		}
	}
}

LineCollection::~LineCollection()
{
}

int LineCollection::GetSize()
{
	return vect.GetSize();
}

CString & LineCollection::operator =(CString &s)
{
	int i,l,n,t=0;
	l=s.GetLength();
	vect.SetSize(0);
	for(i=0,n=0;i<l;i++)
	{
		if ((s)[i]=='\n')
		{
			if(m_Skip && i>0 && (s)[i-1]=='\n') continue;
			vect.SetSize(t+1);
			vect[t]=(s).Mid(n,i-n-1);
			t++;
			n=i+1;
		}
	}
	return s;
}

void LineCollection::clear()
{
	vect.SetSize(0);
}


```

`Examples/NETMETER/LineColl.h`:

```h
/*
 * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)
 * Copyright (c) 2005 - 2006 CACE Technologies, Davis (California)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Politecnico di Torino, CACE Technologies 
 * nor the names of its contributors may be used to endorse or promote 
 * products derived from this software without specific prior written 
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#if !defined(AFX_LINECOLL_H__EE11D4A3_ED58_11D1_939A_000000000000__INCLUDED_)
#define AFX_LINECOLL_H__EE11D4A3_ED58_11D1_939A_000000000000__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <afx.h>
#include <afxtempl.h>

class LineCollection  
{
public:
	void clear();
	CString & operator =(CString &);
	int GetSize();
	int getLineCount(){return GetSize();};
	const char* line(int i){if (i<GetSize()) return (LPCTSTR) vect[i];else return NULL;};
	LineCollection(CString *s=NULL,int skip=0);
	LineCollection(CArchive &ar,int skip=0);
	virtual ~LineCollection();
	void Insert(CString& s){vect.SetSize(vect.GetSize()+1);vect[vect.GetSize()-1]=s;}
private:
	int m_Skip;
	CArray<CString,CString&> vect;
};

#endif // !defined(AFX_LINECOLL_H__EE11D4A3_ED58_11D1_939A_000000000000__INCLUDED_)

```

`Examples/NETMETER/MainFrm.cpp`:

```cpp
/*
 * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)
 * Copyright (c) 2005 - 2006 CACE Technologies, Davis (California)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Politecnico di Torino, CACE Technologies 
 * nor the names of its contributors may be used to endorse or promote 
 * products derived from this software without specific prior written 
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include "stdafx.h"
#include "netmeter.h"

#include "MainFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
}

CMainFrame::~CMainFrame()
{
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	if( !CFrameWnd::PreCreateWindow(cs) )
		return FALSE;

	cs.style = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX;
	cs.cx=260;
	cs.cy=180;

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CFrameWnd::Dump(dc);
}

#endif //_DEBUG

```

`Examples/NETMETER/MainFrm.h`:

```h
/*
 * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)
 * Copyright (c) 2005 - 2006 CACE Technologies, Davis (California)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Politecnico di Torino, CACE Technologies 
 * nor the names of its contributors may be used to endorse or promote 
 * products derived from this software without specific prior written 
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__3BF6CD27_6C2B_11D3_B76F_0080C8DF82B3__INCLUDED_)
#define AFX_MAINFRM_H__3BF6CD27_6C2B_11D3_B76F_0080C8DF82B3__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CMainFrame : public CFrameWnd
{
	
protected: // create from serialization only
	CMainFrame();
	DECLARE_DYNCREATE(CMainFrame)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	public:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__3BF6CD27_6C2B_11D3_B76F_0080C8DF82B3__INCLUDED_)

```

`Examples/NETMETER/NETMETER.CPP`:

```CPP
/*
 * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)
 * Copyright (c) 2005 - 2006 CACE Technologies, Davis (California)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Politecnico di Torino, CACE Technologies 
 * nor the names of its contributors may be used to endorse or promote 
 * products derived from this software without specific prior written 
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include "stdafx.h"
#include "netmeter.h"

#include "MainFrm.h"
#include "netmeterDoc.h"
#include "netmeterView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include <tchar.h>
BOOL LoadNpcapDlls()
{
	TCHAR npcap_dir[512];
	UINT len;
	len = GetSystemDirectory(npcap_dir, 480);
	if (!len) {
		fprintf(stderr, "Error in GetSystemDirectory: %x", GetLastError());
		return FALSE;
	}
	_tcscat_s(npcap_dir, 512, TEXT("\\Npcap"));
	if (SetDllDirectory(npcap_dir) == 0) {
		fprintf(stderr, "Error in SetDllDirectory: %x", GetLastError());
		return FALSE;
	}
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CNetmeterApp

BEGIN_MESSAGE_MAP(CNetmeterApp, CWinApp)
	//{{AFX_MSG_MAP(CNetmeterApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
	//}}AFX_MSG_MAP
	// Standard file based document commands
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNetmeterApp construction

CNetmeterApp::CNetmeterApp()
{
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CNetmeterApp object

CNetmeterApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CNetmeterApp initialization

BOOL CNetmeterApp::InitInstance()
{
	// Standard initialization
	/* Load Npcap and its functions. */
	if (!LoadNpcapDlls())
	{
		fprintf(stderr, "Couldn't load Npcap\n");
		return FALSE;
	}

	// Change the registry key under which our settings are stored.
	SetRegistryKey(_T("Local AppWizard-Generated Applications"));

	LoadStdProfileSettings();  // Load standard INI file options (including MRU)

	// Register document templates

	CSingleDocTemplate* pDocTemplate;
	pDocTemplate = new CSingleDocTemplate(
		IDR_MAINFRAME,
		RUNTIME_CLASS(CNetmeterDoc),
		RUNTIME_CLASS(CMainFrame),       // main SDI frame window
		RUNTIME_CLASS(CNetmeterView));
	AddDocTemplate(pDocTemplate);

//	CNetmeterView

	// Parse command line for standard shell commands, DDE, file open
	CCommandLineInfo cmdInfo;
	ParseCommandLine(cmdInfo);

	// Dispatch commands specified on the command line
	if (!ProcessShellCommand(cmdInfo))
		return FALSE;
	m_pMainWnd->ShowWindow(SW_SHOW);
	m_pMainWnd->UpdateWindow();

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
		// No message handlers
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CNetmeterApp::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CNetmeterApp message handlers

```

`Examples/NETMETER/NETMETER.H`:

```H
/*
 * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)
 * Copyright (c) 2005 - 2006 CACE Technologies, Davis (California)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Politecnico di Torino, CACE Technologies 
 * nor the names of its contributors may be used to endorse or promote 
 * products derived from this software without specific prior written 
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

// netmeter.h : main header file for the NETMETER application
//

#if !defined(AFX_NETMETER_H__3BF6CD23_6C2B_11D3_B76F_0080C8DF82B3__INCLUDED_)
#define AFX_NETMETER_H__3BF6CD23_6C2B_11D3_B76F_0080C8DF82B3__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CNetmeterApp:
// See netmeter.cpp for the implementation of this class
//

class CNetmeterApp : public CWinApp
{
public:
	CNetmeterApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNetmeterApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation
	//{{AFX_MSG(CNetmeterApp)
	afx_msg void OnAppAbout();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NETMETER_H__3BF6CD23_6C2B_11D3_B76F_0080C8DF82B3__INCLUDED_)

```

`Examples/NETMETER/NetMeter.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{99DAC428-2DC6-4E30-8448-3E349FC3A483}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;_AFXDLL;_WINDOWS;WPCAP;HAVE_REMOTE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_AFXDLL;_WINDOWS;WPCAP;HAVE_REMOTE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;_AFXDLL;_WINDOWS;WPCAP;HAVE_REMOTE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <SubSystem>Windows</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_AFXDLL;_WINDOWS;WPCAP;HAVE_REMOTE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <SubSystem>Windows</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="CaptureThread.cpp" />
    <ClCompile Include="LineColl.cpp" />
    <ClCompile Include="MainFrm.cpp" />
    <ClCompile Include="NETMETER.CPP" />
    <ClCompile Include="netmeterDoc.cpp" />
    <ClCompile Include="netmeterView.cpp" />
    <ClCompile Include="SelectAdapter.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="CapDll.h" />
    <ClInclude Include="Console.h" />
    <ClInclude Include="LineColl.h" />
    <ClInclude Include="MainFrm.h" />
    <ClInclude Include="NETMETER.H" />
    <ClInclude Include="netmeterDoc.h" />
    <ClInclude Include="netmeterView.h" />
    <ClInclude Include="ProgCaptDlg.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="SelectAdapter.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="netmeter.rc" />
  </ItemGroup>
  <ItemGroup>
    <None Include="res\netmeter.rc2" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`Examples/NETMETER/NetMeter.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="CaptureThread.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="LineColl.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="MainFrm.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="NETMETER.CPP">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="netmeterDoc.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="netmeterView.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="SelectAdapter.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="CapDll.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Console.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="LineColl.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="MainFrm.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="NETMETER.H">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="netmeterDoc.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="netmeterView.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ProgCaptDlg.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="SelectAdapter.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="netmeter.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="res\netmeter.rc2">
      <Filter>Resource Files</Filter>
    </None>
  </ItemGroup>
</Project>
```

`Examples/NETMETER/ProgCaptDlg.h`:

```h
/*
 * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)
 * Copyright (c) 2005 - 2006 CACE Technologies, Davis (California)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Politecnico di Torino, CACE Technologies 
 * nor the names of its contributors may be used to endorse or promote 
 * products derived from this software without specific prior written 
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */


#if !defined(AFX_PROGCAPTDLG_H__D79DA3C4_3B52_11D2_9482_0020AF2A4474__INCLUDED_)
#define AFX_PROGCAPTDLG_H__D79DA3C4_3B52_11D2_9482_0020AF2A4474__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ProgCaptDlg.h : header file
//
#include "..\..\include\pcap-c.h"

class CCapPars;

/////////////////////////////////////////////////////////////////////////////
// CProgCaptDlg dialog

class CProgCaptDlg : public CDialog
{
// Construction
public:
	CProgCaptDlg(CWnd* pParent = NULL);   // standard constructor
	CCapPars* m_Main;
	int npc;
	int init;
	pcap_t *fp;
	pcap_dumper_t *dumpfile;


// Dialog Data
	//{{AFX_DATA(CProgCaptDlg)
	enum { IDD = IDD_CAP_BUSY };
	CStatic	m_Static;
	CProgressCtrl	m_Progress;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CProgCaptDlg)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	int p;
	int v;

	// Generated message map functions
	//{{AFX_MSG(CProgCaptDlg)
	virtual BOOL OnInitDialog();
	virtual void OnCancel();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROGCAPTDLG_H__D79DA3C4_3B52_11D2_9482_0020AF2A4474__INCLUDED_)

```

`Examples/NETMETER/SelectAdapter.cpp`:

```cpp
/*
 * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)
 * Copyright (c) 2005 - 2006 CACE Technologies, Davis (California)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Politecnico di Torino, CACE Technologies 
 * nor the names of its contributors may be used to endorse or promote 
 * products derived from this software without specific prior written 
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include "stdafx.h"
#include "CapDll.h"
#include "SelectAdapter.h"
#include "LineColl.h"
#include <pcap.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define SA_ERR "Unable to choose Adaptors"
#define SA_ADS "Network Cards"
#define MFR_TCPDUMPERR "Unable to Capture on this operating system"

/////////////////////////////////////////////////////////////////////////////
// CSelectAdapter dialog


CSelectAdapter::CSelectAdapter(CWnd* pParent /*=NULL*/)
	: CDialog(CSelectAdapter::IDD, pParent)
{
	//{{AFX_DATA_INIT(CSelectAdapter)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CSelectAdapter::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSelectAdapter)
	DDX_Control(pDX, IDC_ADAPTER, m_CAdapter);
	DDX_Control(pDX, IDC_LIST1, m_ListCtrl);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSelectAdapter, CDialog)
	//{{AFX_MSG_MAP(CSelectAdapter)
	ON_NOTIFY(HDN_ITEMCLICK, IDC_LIST1, OnSelectItem)
	ON_NOTIFY(HDN_ITEMDBLCLICK, IDC_LIST1, Ondblclickitem)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSelectAdapter message handlers

BOOL CSelectAdapter::OnInitDialog() 
{
char ebuf[PCAP_ERRBUF_SIZE];
char devicelist[65000];
pcap_if_t *alldevs, *d;
char *devicelistptr;


	CDialog::OnInitDialog();

	/* Retrieve the device list on the local machine */
	/* Don't check for errors */
	pcap_findalldevs_ex(PCAP_SRC_IF_STRING, NULL, &alldevs, ebuf);

	devicelistptr= devicelist;
	devicelist[0]= 0;

	for(d=alldevs; d; d=d->next)
	{

		strcat(devicelistptr, d->name);
		devicelistptr+= strlen(d->name);

		strcat(devicelistptr, "\r\n");
		devicelistptr+= strlen("\r\n");
	}

	m_Cmd= devicelist;

	pcap_freealldevs(alldevs);

	LineCollection lc(&m_Cmd);	
    m_ListCtrl.InsertColumn(0,SA_ADS /*Adapters*/, LVCFMT_LEFT,200);
	m_ctlImage.Create(IDB_CAP_WIZ,16,0,RGB(255,0,255));
	m_ListCtrl.SetImageList(&m_ctlImage,LVSIL_SMALL);
	Update(lc);
	m_ListCtrl.SetFocus();
	m_CAdapter.SetWindowText(m_Adapter);
	return FALSE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CSelectAdapter::AddItem(int nItem,int nSubItem,LPCTSTR strItem,int nImageIndex)
{
	LV_ITEM lvItem;
	lvItem.mask = LVIF_TEXT;
	lvItem.iItem = nItem;
	lvItem.iSubItem = nSubItem;
	lvItem.pszText = (LPTSTR) strItem;
	if(nImageIndex != -1){
		lvItem.mask |= LVIF_IMAGE;
		lvItem.iImage = nImageIndex;
	}
	if(nSubItem == 0)
		m_ListCtrl.InsertItem(&lvItem);
	else m_ListCtrl.SetItem(&lvItem);
}

void CSelectAdapter::SelectItem(int i)
{
	LV_FINDINFO it;
	
	it.flags=LVFI_PARAM;
	it.lParam=i;
	i=m_ListCtrl.FindItem(&it);
	m_ListCtrl.SetItemState(i,0xFFFFFFFF,LVIS_SELECTED);
}

void CSelectAdapter::Update(LineCollection &lc)
{
        m_ListCtrl.DeleteAllItems();
	    int n=lc.getLineCount();
		CString t;
        for(n--;n>=0;n--)
         {
			t=lc.line(n);
			t.TrimLeft();
			t.TrimRight();
			if (strlen(t)>0)
	        AddItem(0,0,t,3);
         }
		m_ListCtrl.UpdateWindow();
		n=m_ListCtrl.GetItemCount();
		for (n--;n>=0;n--)
		{
			if (m_Adapter.CompareNoCase(m_ListCtrl.GetItemText(n,0))==0)
				{
					SelectItem(n);
					return;
				}
		}
		m_Adapter=m_ListCtrl.GetItemText(0,0);
}


void CSelectAdapter::OnOK() 
{
	int i,n=m_ListCtrl.GetItemCount();
	for(i=0;i<n;i++)
	{
		if (m_ListCtrl.GetItemState(i,LVIS_SELECTED))
		{
			m_Adapter=m_ListCtrl.GetItemText(i,0);
			break;
		}
	}
	if(i==n) 
	{
		if (n!=0) m_Adapter=m_ListCtrl.GetItemText(0,0);
		else m_Adapter="";
	}
	
	CDialog::OnOK();
}

void CSelectAdapter::OnSelectItem(NMHDR* pNMHDR, LRESULT* pResult) 
{
	HD_NOTIFY *phdn = (HD_NOTIFY *) pNMHDR;

	int i,n=m_ListCtrl.GetItemCount();
	for(i=0;i<n;i++)
	{
		if (m_ListCtrl.GetItemState(i,LVIS_SELECTED))
		{
			m_Adapter=m_ListCtrl.GetItemText(i,0);
			break;
		}
	}
	if(i==n) 
	{
		if (n!=0) m_Adapter=m_ListCtrl.GetItemText(0,0);
		else m_Adapter="";
	}
	m_CAdapter.SetWindowText(m_Adapter);
	
	*pResult = 0;
}

void CSelectAdapter::Ondblclickitem(NMHDR* pNMHDR, LRESULT* pResult) 
{
	HD_NOTIFY *phdn = (HD_NOTIFY *) pNMHDR;

	AfxMessageBox("Error setting the filter");

	int i,n=m_ListCtrl.GetItemCount();
	for(i=0;i<n;i++)
	{
		if (m_ListCtrl.GetItemState(i,LVIS_SELECTED))
		{
			m_Adapter=m_ListCtrl.GetItemText(i,0);
			break;
		}
	}
	if(i==n) 
	{
		if (n!=0) m_Adapter=m_ListCtrl.GetItemText(0,0);
		else m_Adapter="";
	}

	*pResult = 0;
	SendMessage(WM_CLOSE,0,0);

}

```

`Examples/NETMETER/SelectAdapter.h`:

```h
/*
 * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)
 * Copyright (c) 2005 - 2006 CACE Technologies, Davis (California)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Politecnico di Torino, CACE Technologies 
 * nor the names of its contributors may be used to endorse or promote 
 * products derived from this software without specific prior written 
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#if !defined(AFX_SELECTADAPTER_H__D41A3004_2B3D_11D0_9528_0020AF2A4474__INCLUDED_)
#define AFX_SELECTADAPTER_H__D41A3004_2B3D_11D0_9528_0020AF2A4474__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// SelectAdapter.h : header file
//

#include "linecoll.h"
#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CSelectAdapter dialog

int ExecuteApp(CString & s);

class CSelectAdapter : public CDialog
{
// Construction
public:
	CSelectAdapter(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CSelectAdapter)
	enum { IDD = IDD_ADAPTER };
	CStatic	m_CAdapter;
	CListCtrl	m_ListCtrl;
	//}}AFX_DATA
	CString m_Adapter;
	CString m_Cmd;
    CImageList m_ctlImage;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSelectAdapter)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void Update(LineCollection &lc);
	void AddItem(int nItem,int nSubItem,LPCTSTR strItem,int nImageIndex=-1);
	void SelectItem(int i);

	// Generated message map functions
	//{{AFX_MSG(CSelectAdapter)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnSelectItem(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void Ondblclickitem(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SELECTADAPTER_H__D41A3004_2B3D_11D0_9528_0020AF2A4474__INCLUDED_)

```

`Examples/NETMETER/StdAfx.cpp`:

```cpp
/*
 * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)
 * Copyright (c) 2005 - 2006 CACE Technologies, Davis (California)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Politecnico di Torino, CACE Technologies 
 * nor the names of its contributors may be used to endorse or promote 
 * products derived from this software without specific prior written 
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

// stdafx.cpp : source file that includes just the standard includes
//	netmeter.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"




```

`Examples/NETMETER/StdAfx.h`:

```h
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__3BF6CD25_6C2B_11D3_B76F_0080C8DF82B3__INCLUDED_)
#define AFX_STDAFX_H__3BF6CD25_6C2B_11D3_B76F_0080C8DF82B3__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__3BF6CD25_6C2B_11D3_B76F_0080C8DF82B3__INCLUDED_)

```

`Examples/NETMETER/netmeter.rc`:

```rc
//Microsoft Developer Studio generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "afxres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// Neutral (Default) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_NEUD)
#ifdef _WIN32
LANGUAGE LANG_NEUTRAL, SUBLANG_DEFAULT
#pragma code_page(1252)
#endif //_WIN32

/////////////////////////////////////////////////////////////////////////////
//
// Bitmap
//

IDB_CAP_WIZ             BITMAP  DISCARDABLE     "res\\cap_wizi.bmp"
#endif    // Neutral (Default) resources
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// English (U.S.) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
#ifdef _WIN32
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
#pragma code_page(1252)
#endif //_WIN32

/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDR_MAINFRAME           ICON    DISCARDABLE     "res\\netmeter.ico"

/////////////////////////////////////////////////////////////////////////////
//
// Menu
//

IDR_MAINFRAME MENU PRELOAD DISCARDABLE 
BEGIN
    POPUP "&File"
    BEGIN
        MENUITEM "&Select the Adapter",         seladapter
        MENUITEM SEPARATOR
        MENUITEM "E&xit",                       ID_APP_EXIT
    END
    POPUP "&Help"
    BEGIN
        MENUITEM "&About netmeter",             ID_APP_ABOUT
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// Accelerator
//

IDR_MAINFRAME ACCELERATORS PRELOAD MOVEABLE PURE 
BEGIN
    "N",            ID_FILE_NEW,            VIRTKEY, CONTROL
    "O",            ID_FILE_OPEN,           VIRTKEY, CONTROL
    "S",            ID_FILE_SAVE,           VIRTKEY, CONTROL
    "Z",            ID_EDIT_UNDO,           VIRTKEY, CONTROL
    "X",            ID_EDIT_CUT,            VIRTKEY, CONTROL
    "C",            ID_EDIT_COPY,           VIRTKEY, CONTROL
    "V",            ID_EDIT_PASTE,          VIRTKEY, CONTROL
    VK_BACK,        ID_EDIT_UNDO,           VIRTKEY, ALT
    VK_DELETE,      ID_EDIT_CUT,            VIRTKEY, SHIFT
    VK_INSERT,      ID_EDIT_COPY,           VIRTKEY, CONTROL
    VK_INSERT,      ID_EDIT_PASTE,          VIRTKEY, SHIFT
    VK_F6,          ID_NEXT_PANE,           VIRTKEY 
    VK_F6,          ID_PREV_PANE,           VIRTKEY, SHIFT
END


/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

IDD_ABOUTBOX DIALOG DISCARDABLE  0, 0, 235, 154
STYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "About netmeter"
FONT 8, "MS Sans Serif"
BEGIN
    LTEXT           "NetMeter Version 2.0",IDC_STATIC,40,19,119,8,
                    SS_NOPREFIX
    LTEXT           "Copyright (C) 1999-2002 Loris Degioanni (loris@netgroup-serv.polito.it)",
                    IDC_STATIC,7,38,221,8
    DEFPUSHBUTTON   "OK",IDOK,92,133,50,14,WS_GROUP
    LTEXT           "Shows the diagram of a 10Mbit Ethernet network's load in:",
                    IDC_STATIC,7,58,209,11
    LTEXT           "This program uses Npcap",IDC_STATIC,7,114,111,
                    8
    LTEXT           "Each interval on the horizontal axis is approximately 5 seconds",
                    IDC_STATIC,8,100,196,8
    ICON            IDR_MAINFRAME,IDC_STATIC,13,13,20,20
    CONTROL         135,IDC_STATIC,"Static",SS_BITMAP,15,71,8,7
    CONTROL         134,IDC_STATIC,"Static",SS_BITMAP,15,84,8,7
    LTEXT           "Bits per second (Min=0, Max=10 mega)",IDC_STATIC,31,71,
                    185,8
    LTEXT           "Packets per second (Min=0, Max=14880)",IDC_STATIC,31,84,
                    185,8
END


#ifndef _MAC
/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,1
 PRODUCTVERSION 1,0,0,1
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x4L
 FILETYPE 0x1L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904B0"
        BEGIN
            VALUE "CompanyName", "\0"
            VALUE "FileDescription", "netmeter MFC Application\0"
            VALUE "FileVersion", "1, 0, 0, 1\0"
            VALUE "InternalName", "netmeter\0"
            VALUE "LegalCopyright", "Copyright (C) 1999\0"
            VALUE "LegalTrademarks", "\0"
            VALUE "OriginalFilename", "netmeter.EXE\0"
            VALUE "ProductName", "netmeter Application\0"
            VALUE "ProductVersion", "1, 0, 0, 1\0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END

#endif    // !_MAC


/////////////////////////////////////////////////////////////////////////////
//
// DESIGNINFO
//

#ifdef APSTUDIO_INVOKED
GUIDELINES DESIGNINFO DISCARDABLE 
BEGIN
    IDD_ABOUTBOX, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 228
        TOPMARGIN, 7
        BOTTOMMARGIN, 147
    END
END
#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// String Table
//

STRINGTABLE PRELOAD DISCARDABLE 
BEGIN
    IDR_MAINFRAME           "netmeter\n\nNetmet\n\n\nNetmeter.Document\nNetmet Document"
END

STRINGTABLE PRELOAD DISCARDABLE 
BEGIN
    AFX_IDS_APP_TITLE       "netmeter"
    AFX_IDS_IDLEMESSAGE     "Ready"
END

STRINGTABLE DISCARDABLE 
BEGIN
    ID_INDICATOR_EXT        "EXT"
    ID_INDICATOR_CAPS       "CAP"
    ID_INDICATOR_NUM        "NUM"
    ID_INDICATOR_SCRL       "SCRL"
    ID_INDICATOR_OVR        "OVR"
    ID_INDICATOR_REC        "REC"
END

STRINGTABLE DISCARDABLE 
BEGIN
    ID_FILE_NEW             "Create a new document\nNew"
    ID_FILE_OPEN            "Open an existing document\nOpen"
    ID_FILE_CLOSE           "Close the active document\nClose"
    ID_FILE_SAVE            "Save the active document\nSave"
    ID_FILE_SAVE_AS         "Save the active document with a new name\nSave As"
END

STRINGTABLE DISCARDABLE 
BEGIN
    ID_APP_ABOUT            "Display program information, version number and copyright\nAbout"
    ID_APP_EXIT             "Quit the application; prompts to save documents\nExit"
END

STRINGTABLE DISCARDABLE 
BEGIN
    ID_FILE_MRU_FILE1       "Open this document"
    ID_FILE_MRU_FILE2       "Open this document"
    ID_FILE_MRU_FILE3       "Open this document"
    ID_FILE_MRU_FILE4       "Open this document"
    ID_FILE_MRU_FILE5       "Open this document"
    ID_FILE_MRU_FILE6       "Open this document"
    ID_FILE_MRU_FILE7       "Open this document"
    ID_FILE_MRU_FILE8       "Open this document"
    ID_FILE_MRU_FILE9       "Open this document"
    ID_FILE_MRU_FILE10      "Open this document"
    ID_FILE_MRU_FILE11      "Open this document"
    ID_FILE_MRU_FILE12      "Open this document"
    ID_FILE_MRU_FILE13      "Open this document"
    ID_FILE_MRU_FILE14      "Open this document"
    ID_FILE_MRU_FILE15      "Open this document"
    ID_FILE_MRU_FILE16      "Open this document"
END

STRINGTABLE DISCARDABLE 
BEGIN
    ID_NEXT_PANE            "Switch to the next window pane\nNext Pane"
    ID_PREV_PANE            "Switch back to the previous window pane\nPrevious Pane"
END

STRINGTABLE DISCARDABLE 
BEGIN
    ID_WINDOW_SPLIT         "Split the active window into panes\nSplit"
END

STRINGTABLE DISCARDABLE 
BEGIN
    ID_EDIT_CLEAR           "Erase the selection\nErase"
    ID_EDIT_CLEAR_ALL       "Erase everything\nErase All"
    ID_EDIT_COPY            "Copy the selection and put it on the Clipboard\nCopy"
    ID_EDIT_CUT             "Cut the selection and put it on the Clipboard\nCut"
    ID_EDIT_FIND            "Find the specified text\nFind"
    ID_EDIT_PASTE           "Insert Clipboard contents\nPaste"
    ID_EDIT_REPEAT          "Repeat the last action\nRepeat"
    ID_EDIT_REPLACE         "Replace specific text with different text\nReplace"
    ID_EDIT_SELECT_ALL      "Select the entire document\nSelect All"
    ID_EDIT_UNDO            "Undo the last action\nUndo"
    ID_EDIT_REDO            "Redo the previously undone action\nRedo"
END

STRINGTABLE DISCARDABLE 
BEGIN
    AFX_IDS_SCSIZE          "Change the window size"
    AFX_IDS_SCMOVE          "Change the window position"
    AFX_IDS_SCMINIMIZE      "Reduce the window to an icon"
    AFX_IDS_SCMAXIMIZE      "Enlarge the window to full size"
    AFX_IDS_SCNEXTWINDOW    "Switch to the next document window"
    AFX_IDS_SCPREVWINDOW    "Switch to the previous document window"
    AFX_IDS_SCCLOSE         "Close the active window and prompts to save the documents"
END

STRINGTABLE DISCARDABLE 
BEGIN
    AFX_IDS_SCRESTORE       "Restore the window to normal size"
    AFX_IDS_SCTASKLIST      "Activate Task List"
END

#endif    // English (U.S.) resources
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// Italian (Italy) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ITA)
#ifdef _WIN32
LANGUAGE LANG_ITALIAN, SUBLANG_ITALIAN
#pragma code_page(1252)
#endif //_WIN32

/////////////////////////////////////////////////////////////////////////////
//
// Bitmap
//

IDB_YELL                BITMAP  DISCARDABLE     "res\\bitmap1.bmp"
IDB_BLUE                BITMAP  DISCARDABLE     "res\\bitmap2.bmp"

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE DISCARDABLE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE DISCARDABLE 
BEGIN
    "#include ""afxres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE DISCARDABLE 
BEGIN
    "#define _AFX_NO_SPLITTER_RESOURCES\r\n"
    "#define _AFX_NO_OLE_RESOURCES\r\n"
    "#define _AFX_NO_TRACKER_RESOURCES\r\n"
    "#define _AFX_NO_PROPERTY_RESOURCES\r\n"
    "\r\n"
    "#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)\r\n"
    "#ifdef _WIN32\r\n"
    "LANGUAGE 9, 1\r\n"
    "#pragma code_page(1252)\r\n"
    "#endif //_WIN32\r\n"
    "#include ""res\\netmeter.rc2""  // non-Microsoft Visual C++ edited resources\r\n"
    "#include ""afxres.rc""         // Standard components\r\n"
    "#endif\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

#endif    // Italian (Italy) resources
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// English (U.K.) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENG)
#ifdef _WIN32
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_UK
#pragma code_page(1252)
#endif //_WIN32

/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

IDD_ADAPTER DIALOG DISCARDABLE  0, 0, 186, 122
STYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Choose the Network Adapter"
FONT 8, "MS Sans Serif"
BEGIN
    DEFPUSHBUTTON   "OK",IDOK,129,7,50,14
    PUSHBUTTON      "Cancel",IDCANCEL,129,24,50,14
    CONTROL         "List1",IDC_LIST1,"SysListView32",LVS_REPORT | WS_BORDER | 
                    WS_TABSTOP,7,7,116,81
    LTEXT           "Current network adapter",IDC_STATIC,7,92,164,10
    LTEXT           "NONE",IDC_ADAPTER,8,106,168,12
END

#endif    // English (U.K.) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
#define _AFX_NO_SPLITTER_RESOURCES
#define _AFX_NO_OLE_RESOURCES
#define _AFX_NO_TRACKER_RESOURCES
#define _AFX_NO_PROPERTY_RESOURCES

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
#ifdef _WIN32
LANGUAGE 9, 1
#pragma code_page(1252)
#endif //_WIN32
#include "res\netmeter.rc2"  // non-Microsoft Visual C++ edited resources
#include "afxres.rc"         // Standard components
#endif

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`Examples/NETMETER/netmeterDoc.cpp`:

```cpp
/*
 * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)
 * Copyright (c) 2005 - 2006 CACE Technologies, Davis (California)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Politecnico di Torino, CACE Technologies 
 * nor the names of its contributors may be used to endorse or promote 
 * products derived from this software without specific prior written 
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include "stdafx.h"
#include "netmeter.h"

#include "netmeterDoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNetmeterDoc

IMPLEMENT_DYNCREATE(CNetmeterDoc, CDocument)

BEGIN_MESSAGE_MAP(CNetmeterDoc, CDocument)
	//{{AFX_MSG_MAP(CNetmeterDoc)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNetmeterDoc construction/destruction

CNetmeterDoc::CNetmeterDoc()
{
}

CNetmeterDoc::~CNetmeterDoc()
{
}

BOOL CNetmeterDoc::OnNewDocument()
{
	if (!CDocument::OnNewDocument())
		return FALSE;

	return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
// CNetmeterDoc serialization

void CNetmeterDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
	}
	else
	{
	}
}

/////////////////////////////////////////////////////////////////////////////
// CNetmeterDoc diagnostics

#ifdef _DEBUG
void CNetmeterDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CNetmeterDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CNetmeterDoc commands

```

`Examples/NETMETER/netmeterDoc.h`:

```h
/*
 * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)
 * Copyright (c) 2005 - 2006 CACE Technologies, Davis (California)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Politecnico di Torino, CACE Technologies 
 * nor the names of its contributors may be used to endorse or promote 
 * products derived from this software without specific prior written 
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

// netmeterDoc.h : interface of the CNetmeterDoc class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_NETMETERDOC_H__3BF6CD29_6C2B_11D3_B76F_0080C8DF82B3__INCLUDED_)
#define AFX_NETMETERDOC_H__3BF6CD29_6C2B_11D3_B76F_0080C8DF82B3__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


class CNetmeterDoc : public CDocument
{
protected: // create from serialization only
	CNetmeterDoc();
	DECLARE_DYNCREATE(CNetmeterDoc)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNetmeterDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual void Serialize(CArchive& ar);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CNetmeterDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CNetmeterDoc)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NETMETERDOC_H__3BF6CD29_6C2B_11D3_B76F_0080C8DF82B3__INCLUDED_)

```

`Examples/NETMETER/netmeterView.cpp`:

```cpp
/*
 * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)
 * Copyright (c) 2005 - 2006 CACE Technologies, Davis (California)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Politecnico di Torino, CACE Technologies 
 * nor the names of its contributors may be used to endorse or promote 
 * products derived from this software without specific prior written 
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <sys/types.h>
#include <sys/timeb.h>
#include <time.h>

#include "stdafx.h"
#include "netmeter.h"

#include "netmeterDoc.h"
#include "netmeterView.h"
#include "console.h"
#include "selectadapter.h"
#include <pcap.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

pcap_t *fp;
pcap_dumper_t *dumpfile;
struct _timeb OldTime;

/////////////////////////////////////////////////////////////////////////////
// CNetmeterView

IMPLEMENT_DYNCREATE(CNetmeterView, CView)

BEGIN_MESSAGE_MAP(CNetmeterView, CView)
	//{{AFX_MSG_MAP(CNetmeterView)
	ON_COMMAND(seladapter, OnSelAdapter)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNetmeterView construction/destruction

CNetmeterView::CNetmeterView()
{
	//init the values
	time=0;
	TimeSlice=1000;
	delta=5;
	lastval1=0;
	lastval2=0;
	Adapter="";
	BytesCaptured=0;
	gridpen.CreatePen(PS_SOLID,0,RGB(0,150,0));
	diagrampen1.CreatePen(PS_SOLID,0,RGB(255,255,0));
	diagrampen2.CreatePen(PS_SOLID,0,RGB(0,255,255));
	InitializeCriticalSection(&Crit);

	//begin the capture

	CString result;
	if ((result=StartCapture())!=""){
		AfxMessageBox("Error initializing the capture:\n"+result); 
		exit(0);
	}

}

CNetmeterView::~CNetmeterView()
{
//stop the capture and close libpcap 
	StopCapture();
}

BOOL CNetmeterView::PreCreateWindow(CREATESTRUCT& cs)
{
	return CView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// function that starts the capture

CString CNetmeterView::StartCapture()
{
char *ebuf;
char *myAdapter;
pcap_if_t *alldevs;


	CCapPars *pars=new CCapPars;

	pars->prg=this;

	ebuf=(char*)malloc(PCAP_ERRBUF_SIZE);

	if (Adapter=="")
	{
		//If no adapter is defined choose the first

		/* Retrieve the device list on the local machine */
		/* Don't check for errors */
		pcap_findalldevs_ex(PCAP_SRC_IF_STRING, NULL, &alldevs, ebuf);

		myAdapter= alldevs->name;

		//open the adapter
		//note: the snaplen is 1 byte because we don't need the data
		//and the header of the packet, but only the length.
		//Snaplen is not set to 0 because with this value the filter
		//drops all the packet without copying them. Snaplen=0 can be 
		//used to count the packets with the minimun overhead on the system.

		if ( (fp= pcap_open((char*)myAdapter, 1, PCAP_OPENFLAG_PROMISCUOUS, 1000, NULL, ebuf) ) == NULL)
		{
			return "PCAP error: Error opening the adapter";
		}

		pcap_freealldevs(alldevs);
	}
	else
	{
		if ( (fp= pcap_open(Adapter.GetBuffer(0), 1, PCAP_OPENFLAG_PROMISCUOUS, 1000, NULL, ebuf) ) == NULL)
		{
			return "PCAP error: Error opening the adapter";
		}
	}



	//this example shows a correct diagram only on 10Mbit Ethernets
	if(pcap_datalink(fp)!=1/*Ether10*/)
	{
			AfxMessageBox("Warning: the nework adapter '"+Adapter+"' is not supported correctly by netmeter.\nNetmeter works correcly only with 10Mbit ethernet adapters.");
	}


	//set mode 1 (statistics mode).
	//When set in this mode, the capture driver DOES'T capture anything.
	//It only counts the packets and the number of bytes that satisfy the BPF filter,
	//and returns to the application this values every Mon.delay milliseconds.
	if(pcap_setmode(fp,MODE_STAT)==-1){
		pcap_close(fp);
		return "PCAP error setting count mode";
	}


	//We set a 256 bytes kernel buffer, big enough to contain the statistical summary created by the driver
	if(pcap_setbuff(fp, 256)<0){
		pcap_close(fp);
		return "Not enough memory to allocate the capture buffer\nTry to set a smaller buffer.";
	}

	pars->fp=fp;

	//start the capture thread
	thr=AfxBeginThread(MyThreadProc, pars);
	if(!thr) {
		pcap_close(fp);
		return "Error launching the capture thread.";
	}

	//get the time of the beginning of the capture
	_ftime( &OldTime );
	return "";


}

/////////////////////////////////////////////////////////////////////////////
// function that stops the capture

void CNetmeterView::StopCapture()
{

	HANDLE thread=thr->m_hThread;

	//kill the capture thread.
	BOOL res=TerminateThread(thread,0);
	
	if(res==false){
		AfxMessageBox("Fatal Error: cannot terminate the capture thread"); 
		exit(0);
	}
	//close the adapter
	pcap_close(fp);

	//wait the end of the capture thread
	WaitForSingleObject(thread,INFINITE);

}

/////////////////////////////////////////////////////////////////////////////
// Create a new blackboard

void CNetmeterView::CreateBoard(CDC* pDC,CDC *DrawBuff,RECT rett)
{
		int i;
		CDC dc;

		DrawBuff->CreateCompatibleDC(pDC);

		hBitmap=CreateCompatibleBitmap(*pDC,rett.right-rett.left,rett.bottom-rett.top);
		DrawBuff->SelectObject(hBitmap);

		DrawBuff->FillSolidRect(0,0,rett.right-rett.left,rett.bottom-rett.top,0);
		DrawBuff->SelectObject(gridpen);

		for(i=1;i<10;i++){
			DrawBuff->MoveTo(0,(rett.bottom-rett.top)*i/10);
			DrawBuff->LineTo(rett.right-rett.left,(rett.bottom-rett.top)*i/10);
		}
		for(i=1;i<=10;i++){
			DrawBuff->MoveTo((rett.right-rett.left)*i/10-1,0);
			DrawBuff->LineTo((rett.right-rett.left)*i/10-1,rett.bottom-rett.top);
		}

		DrawBuff->LineTo(rett.right-rett.left,rett.bottom-rett.top);

		DrawBoard(DrawBuff,rett,0,0);
		pDC->BitBlt( rett.left, rett.top, rett.right-rett.left, rett.bottom-rett.top, DrawBuff, 0, 0, SRCCOPY);

}

/////////////////////////////////////////////////////////////////////////////
// Scroll the blackboard and insert a new value

void CNetmeterView::DrawBoard(CDC* pDC,RECT rett,int height1,int height2)
{
	int i;
	int x,y;


	
	pDC->SelectObject(gridpen);
	pDC->BitBlt( 0, 0, rett.right-rett.left, rett.bottom-rett.top, pDC, delta, 0, SRCCOPY);
	pDC->FillSolidRect(rett.right-delta,0,rett.right,rett.bottom-rett.top,0);



	for(i=1;i<10;i++){
		pDC->MoveTo(rett.right-rett.left-delta,(rett.bottom-rett.top)*i/10);
		pDC->LineTo(rett.right-rett.left,(rett.bottom-rett.top)*i/10);
	}

	if(((time)*delta)/((rett.right-rett.left)/10) > ((time-1)*delta)/((rett.right-rett.left)/10))
	{
		pDC->MoveTo((rett.right-rett.left)*i/10-1,0);
		pDC->LineTo((rett.right-rett.left)*i/10-1,rett.bottom-rett.top);
	}

	// draw the line for the new PPS
	pDC->SelectObject(diagrampen2);

	x=rett.right-rett.left-delta-1;
	y=rett.bottom-rett.top-lastval2*(rett.bottom-rett.top)/100-1;
	pDC->MoveTo(x,y);
	pDC->SetPixelV(x,y,RGB(255,255,255));
	x=rett.right-rett.left-1;
	y=rett.bottom-rett.top-height2*(rett.bottom-rett.top)/100-1;
	pDC->LineTo(x,y);
	pDC->SetPixelV(x,y,RGB(255,255,255));
	lastval2=height2;

	// draw the line for the new BPS
	pDC->SelectObject(diagrampen1);

	x=rett.right-rett.left-delta-1;
	y=rett.bottom-rett.top-lastval1*(rett.bottom-rett.top)/100-1;
	pDC->MoveTo(x,y);
	pDC->SetPixelV(x,y,RGB(255,255,255));
	x=rett.right-rett.left-1;
	y=rett.bottom-rett.top-height1*(rett.bottom-rett.top)/100-1;
	pDC->LineTo(x,y);
	pDC->SetPixelV(x,y,RGB(255,255,255));
	lastval1=height1;
	
	//redraw
	if(time>0){
		Invalidate( FALSE );
		UpdateWindow();
	}
	time++;
}
/////////////////////////////////////////////////////////////////////////////
// CNetmeterView drawing

void CNetmeterView::OnDraw(CDC* pDC)
{
	CNetmeterDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	CWnd* wind=pDC->GetWindow();
	wind->GetClientRect(&wrett);


	if(time==0){
		
		//write the name of the adapter in the title bar of the program's window
		CWnd *pater=this->GetParent();
		CString titlestr;
		CString tmpstr;

		tmpstr=Adapter.Right(12);
		if(tmpstr.GetLength()==Adapter.GetLength())
		 titlestr.Format("netmeter-%s",Adapter);
		else
		 titlestr.Format("netmeter-...%s",tmpstr);
		pater->SetWindowText(titlestr);
		
		CreateBoard(pDC,&DrawBuffer,wrett);
		time++;
	}

	if(time>0)pDC->BitBlt( wrett.left, wrett.top, wrett.right-wrett.left, wrett.bottom-wrett.top, &DrawBuffer, 0, 0, SRCCOPY);

}

/////////////////////////////////////////////////////////////////////////////
// CNetmeterView diagnostics

#ifdef _DEBUG
void CNetmeterView::AssertValid() const
{
	CView::AssertValid();
}

void CNetmeterView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}

CNetmeterDoc* CNetmeterView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CNetmeterDoc)));
	return (CNetmeterDoc*)m_pDocument;
}
#endif //_DEBUG



void CNetmeterView::OnSelAdapter() 
{
	CSelectAdapter dlg;

	//stop the current capture process
	StopCapture();

	//show the selectadapter dialog
	dlg.m_Adapter=Adapter;
	if (dlg.DoModal()==IDOK) Adapter=dlg.m_Adapter;
	
	//write the name of the adapter in the title bar of the program's window
	CWnd *pater=this->GetParent();
	CString titlestr;
	CString tmpstr;

	tmpstr=Adapter.Right(12);
	if(tmpstr.GetLength()==Adapter.GetLength())
	 titlestr.Format("netmeter-%s",Adapter);
	else
	 titlestr.Format("netmeter-...%s",tmpstr);
	pater->SetWindowText(titlestr);
	
	//start the new capture process
	StartCapture();
}

```

`Examples/NETMETER/netmeterView.h`:

```h
/*
 * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)
 * Copyright (c) 2005 - 2006 CACE Technologies, Davis (California)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Politecnico di Torino, CACE Technologies 
 * nor the names of its contributors may be used to endorse or promote 
 * products derived from this software without specific prior written 
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#if !defined(AFX_NETMETERVIEW_H__3BF6CD2B_6C2B_11D3_B76F_0080C8DF82B3__INCLUDED_)
#define AFX_NETMETERVIEW_H__3BF6CD2B_6C2B_11D3_B76F_0080C8DF82B3__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CNetmeterView : public CView
{
protected: // create from serialization only
	CRITICAL_SECTION Crit;
	CWinThread* thr;
	CString  StartCapture();
	void StopCapture();
	CNetmeterView();
	DECLARE_DYNCREATE(CNetmeterView)
// Attributes
public:
	CPen gridpen;
	CPen diagrampen1;
	CPen diagrampen2;
	UINT BytesCaptured;
	int lastval1,lastval2;
	CDC DrawBuffer;
	int time;
	int delta;
	int TimeSlice;
	CString Adapter;
	RECT wrett;
	HBITMAP hBitmap;
	CNetmeterDoc* GetDocument();
	void DrawBoard(CDC* pDC,RECT rett,int height1,int height2);
	void CreateBoard(CDC* pDC,CDC *DrawBuff,RECT rett);
// Operations
public:
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNetmeterView)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CNetmeterView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CNetmeterView)
	afx_msg void OnTimer(UINT nIDEvent);
	afx_msg void OnSelAdapter();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in netmeterView.cpp
inline CNetmeterDoc* CNetmeterView::GetDocument()
   { return (CNetmeterDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NETMETERVIEW_H__3BF6CD2B_6C2B_11D3_B76F_0080C8DF82B3__INCLUDED_)

```

`Examples/NETMETER/res/netmeter.rc2`:

```rc2
//
// NETMETER.RC2 - resources Microsoft Visual C++ does not edit directly
//

#ifdef APSTUDIO_INVOKED
	#error this file is not editable by Microsoft Visual C++
#endif //APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
// Add manually edited resources here...

/////////////////////////////////////////////////////////////////////////////

```

`Examples/NETMETER/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by netmeter.rc
//
#define IDD_ABOUTBOX                    100
#define IDR_MAINFRAME                   128
#define IDR_NETMETTYPE                  129
#define IDB_YELLOW                      133
#define IDB_BLUE                        134
#define IDB_YELL                        135
#define IDB_CAP_WIZ                     175
#define IDD_ADAPTER                     180
#define IDC_ADAPTER                     1000
#define IDC_LIST1                       3109
#define seladapter                      32771

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        137
#define _APS_NEXT_COMMAND_VALUE         32772
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`Examples/PacketDriver/GetMacAddress/GetMacAddress.c`:

```c
/*
 * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)
 * Copyright (c) 2005 - 2006 CACE Technologies, Davis (California)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Politecnico di Torino, CACE Technologies 
 * nor the names of its contributors may be used to endorse or promote 
 * products derived from this software without specific prior written 
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <stdio.h>
#include <conio.h>
#include <Packet32.h>
#include <ntddndis.h>

#define Max_Num_Adapter 10
char		AdapterList[Max_Num_Adapter][1024];

#include <tchar.h>
BOOL LoadNpcapDlls()
{
	TCHAR npcap_dir[512];
	UINT len;
	len = GetSystemDirectory(npcap_dir, 480);
	if (!len) {
		fprintf(stderr, "Error in GetSystemDirectory: %x", GetLastError());
		return FALSE;
	}
	_tcscat_s(npcap_dir, 512, TEXT("\\Npcap"));
	if (SetDllDirectory(npcap_dir) == 0) {
		fprintf(stderr, "Error in SetDllDirectory: %x", GetLastError());
		return FALSE;
	}
	return TRUE;
}

int main()
{
	LPADAPTER	lpAdapter = 0;
	int			i;
	DWORD		dwErrorCode;
	char		AdapterName[8192];
	char		*temp,*temp1;
	int			AdapterNum=0,Open;
	ULONG		AdapterLength;
	PPACKET_OID_DATA  OidData;
	BOOLEAN		Status;
	
	/* Load Npcap and its functions. */
	if (!LoadNpcapDlls())
	{
		fprintf(stderr, "Couldn't load Npcap\n");
		exit(1);
	}

	//
	// Obtain the name of the adapters installed on this machine
	//

	printf("Packet.dll test application. Library version:%s\n", PacketGetVersion());
	
	printf("Adapters installed:\n");
	i=0;	
	
	AdapterLength = sizeof(AdapterName);
	
	if(PacketGetAdapterNames(AdapterName,&AdapterLength)==FALSE){
		printf("Unable to retrieve the list of the adapters!\n");
		return -1;
	}
	temp=AdapterName;
	temp1=AdapterName;

	while ((*temp!='\0')||(*(temp-1)!='\0'))
	{
		if (*temp=='\0') 
		{
			memcpy(AdapterList[i],temp1,temp-temp1);
			temp1=temp+1;
			i++;
		}
		temp++;
	}
		  
	AdapterNum=i;
	for (i=0;i<AdapterNum;i++)
		printf("\n%d- %s\n",i+1,AdapterList[i]);
	printf("\n");


	do 
	{
		printf("Select the number of the adapter to open : ");
		scanf_s("%d",&Open);
		if (Open>AdapterNum) printf("\nThe number must be smaller than %d",AdapterNum); 
	} while (Open>AdapterNum);
	

	//
	// Open the selected adapter
	//

	lpAdapter =   PacketOpenAdapter(AdapterList[Open-1]);
	
	if (!lpAdapter || (lpAdapter->hFile == INVALID_HANDLE_VALUE))
	{
		dwErrorCode=GetLastError();
		printf("Unable to open the adapter, Error Code : %lx\n",dwErrorCode); 

		return -1;
	}	

	// 
	// Allocate a buffer to get the MAC adress
	//

	OidData = malloc(6 + sizeof(PACKET_OID_DATA));
	if (OidData == NULL) 
	{
		printf("error allocating memory!\n");
		PacketCloseAdapter(lpAdapter);
		return -1;
	}

	// 
	// Retrieve the adapter MAC querying the NIC driver
	//

	OidData->Oid = OID_802_3_CURRENT_ADDRESS;

	OidData->Length = 6;
	ZeroMemory(OidData->Data, 6);
	
	Status = PacketRequest(lpAdapter, FALSE, OidData);
	if(Status)
	{
		printf("The MAC address of the adapter is %.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n",
			(OidData->Data)[0],
			(OidData->Data)[1],
			(OidData->Data)[2],
			(OidData->Data)[3],
			(OidData->Data)[4],
			(OidData->Data)[5]);
	}
	else
	{
		printf("error retrieving the MAC address of the adapter!\n");
	}

	free(OidData);
	PacketCloseAdapter(lpAdapter);
	return (0);
}


```

`Examples/PacketDriver/GetMacAddress/GetMacAddress.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{1ED069D6-3B12-4175-A97D-7FFEBEA26628}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <AdditionalDependencies>Packet.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>Packet.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>Packet.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>Packet.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalDependencies>Packet.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <AdditionalDependencies>Packet.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <DelayLoadDLLs>Packet.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <DelayLoadDLLs>Packet.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <AdditionalDependencies>Packet.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <AdditionalDependencies>Packet.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <DelayLoadDLLs>Packet.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <DelayLoadDLLs>Packet.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="GetMacAddress.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`Examples/PacketDriver/TestPacketCapture/TestPacketCapture.c`:

```c
/*
 * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)
 * Copyright (c) 2005 - 2006 CACE Technologies, Davis (California)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Politecnico di Torino, CACE Technologies 
 * nor the names of its contributors may be used to endorse or promote 
 * products derived from this software without specific prior written 
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */


#include <stdio.h>
#include <conio.h>


#include <Packet32.h>
#include <ntddndis.h>

#define Max_Num_Adapter 10

#include <tchar.h>
BOOL LoadNpcapDlls()
{
	TCHAR npcap_dir[512];
	UINT len;
	len = GetSystemDirectory(npcap_dir, 480);
	if (!len) {
		fprintf(stderr, "Error in GetSystemDirectory: %x", GetLastError());
		return FALSE;
	}
	_tcscat_s(npcap_dir, 512, TEXT("\\Npcap"));
	if (SetDllDirectory(npcap_dir) == 0) {
		fprintf(stderr, "Error in SetDllDirectory: %x", GetLastError());
		return FALSE;
	}
	return TRUE;
}
// Prototypes

void PrintPackets(LPPACKET lpPacket);

char        AdapterList[Max_Num_Adapter][1024];

int main()
{
//define a pointer to an ADAPTER structure

LPADAPTER  lpAdapter = 0;

//define a pointer to a PACKET structure

LPPACKET   lpPacket;

int        i;
DWORD      dwErrorCode;

//ascii strings
char		AdapterName[8192]; // string that contains a list of the network adapters
char		*temp,*temp1;


int			AdapterNum=0,Open;
ULONG		AdapterLength;

char buffer[256000];  // buffer to hold the data coming from the driver

struct bpf_stat stat;
	
	/* Load Npcap and its functions. */
	if (!LoadNpcapDlls())
	{
		fprintf(stderr, "Couldn't load Npcap\n");
		exit(1);
	}

	//
	// Obtain the name of the adapters installed on this machine
	//
	printf("Packet.dll test application. Library version:%s\n", PacketGetVersion());

	printf("Adapters installed:\n");
	i=0;	

	AdapterLength = sizeof(AdapterName);

	if(PacketGetAdapterNames(AdapterName,&AdapterLength)==FALSE){
		printf("Unable to retrieve the list of the adapters!\n");
		return -1;
	}
	temp=AdapterName;
	temp1=AdapterName;

	while ((*temp!='\0')||(*(temp-1)!='\0'))
	{
		if (*temp=='\0') 
		{
			memcpy(AdapterList[i],temp1,temp-temp1);
			temp1=temp+1;
			i++;
		}
		temp++;
	}
		  
	AdapterNum=i;
	for (i=0;i<AdapterNum;i++)
		printf("\n%d- %s\n",i+1,AdapterList[i]);
	printf("\n");


	do 
	{
		printf("Select the number of the adapter to open : ");
		scanf_s("%d",&Open);
		if (Open>AdapterNum) printf("\nThe number must be smaller than %d",AdapterNum); 
	} while (Open>AdapterNum);
	

	
	
	lpAdapter =   PacketOpenAdapter(AdapterList[Open-1]);
	
	if (!lpAdapter || (lpAdapter->hFile == INVALID_HANDLE_VALUE))
	{
		dwErrorCode=GetLastError();
		printf("Unable to open the adapter, Error Code : %lx\n",dwErrorCode); 

		return -1;
	}	

	// set the network adapter in promiscuous mode
	
	if(PacketSetHwFilter(lpAdapter,NDIS_PACKET_TYPE_PROMISCUOUS)==FALSE){
			printf("Warning: unable to set promiscuous mode!\n");
	}

	// set a 512K buffer in the driver
	if(PacketSetBuff(lpAdapter,512000)==FALSE){
			printf("Unable to set the kernel buffer!\n");
			return -1;
	}

	// set a 1 second read timeout
	if(PacketSetReadTimeout(lpAdapter,1000)==FALSE){
			printf("Warning: unable to set the read tiemout!\n");
	}

	//allocate and initialize a packet structure that will be used to
	//receive the packets.
	if((lpPacket = PacketAllocatePacket())==NULL){
		printf("\nError: failed to allocate the LPPACKET structure.");
		return (-1);
	}
	PacketInitPacket(lpPacket,(char*)buffer,256000);
	
	//main capture loop
	while(!_kbhit())
	{
	    // capture the packets
		if(PacketReceivePacket(lpAdapter,lpPacket,TRUE)==FALSE){
			printf("Error: PacketReceivePacket failed");
			return (-1);
		}

		PrintPackets(lpPacket);
	}


	//print the capture statistics
	if(PacketGetStats(lpAdapter,&stat)==FALSE){
			printf("Warning: unable to get stats from the kernel!\n");
	}
	else
		printf("\n\n%d packets received.\n%d Packets lost",stat.bs_recv,stat.bs_drop);

	PacketFreePacket(lpPacket);
	
	// close the adapter and exit

	PacketCloseAdapter(lpAdapter);
	return (0);
}

// this function prints the content of a block of packets received from the driver

void PrintPackets(LPPACKET lpPacket)
{

	ULONG	i, j, ulLines, ulen, ulBytesReceived;
	char	*pChar, *pLine, *base;
	char	*buf;
	u_int off=0;
	u_int tlen,tlen1;
	struct bpf_hdr *hdr;
	
		ulBytesReceived = lpPacket->ulBytesReceived;


		buf = lpPacket->Buffer;

		off=0;

		while(off<ulBytesReceived){	
			if(_kbhit())return;
		hdr=(struct bpf_hdr *)(buf+off);
		tlen1=hdr->bh_datalen;
		tlen=hdr->bh_caplen;
		printf("Packet length, captured portion: %ld, %ld\n", tlen1, tlen);
		off+=hdr->bh_hdrlen;

		ulLines = (tlen + 15) / 16;

		pChar =(char*)(buf+off);
		base=pChar;
		off=Packet_WORDALIGN(off+tlen);
		
		for ( i=0; i<ulLines; i++ )
		{

			pLine =pChar;

			printf( "%p : ", (void *)(pChar - base));

			ulen=tlen;
			ulen = ( ulen > 16 ) ? 16 : ulen;
			tlen -= ulen;

			for ( j=0; j<ulen; j++ )
				printf( "%02x ", *(BYTE *)pChar++ );

			if ( ulen < 16 )
				printf( "%*s", (16-ulen)*3, " " );

			pChar = pLine;

			for ( j=0; j<ulen; j++, pChar++ )
				printf( "%c", isprint( (unsigned char)*pChar ) ? *pChar : '.' );

			printf( "\n" );
		} 

		printf( "\n" );
		}
} 

 

```

`Examples/PacketDriver/TestPacketCapture/TestPacketCapture.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{79942922-E02C-486D-9EE3-A13C0876C4C2}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <AdditionalDependencies>Packet.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>Packet.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>Packet.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>Packet.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalDependencies>Packet.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <AdditionalDependencies>Packet.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <DelayLoadDLLs>Packet.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <DelayLoadDLLs>Packet.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <AdditionalDependencies>Packet.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <AdditionalDependencies>Packet.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <DelayLoadDLLs>Packet.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <DelayLoadDLLs>Packet.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="TestPacketCapture.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`Examples/PacketDriver/TestPacketSend/TestPacketSend.c`:

```c
/*
 * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)
 * Copyright (c) 2005 - 2006 CACE Technologies, Davis (California)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Politecnico di Torino, CACE Technologies 
 * nor the names of its contributors may be used to endorse or promote 
 * products derived from this software without specific prior written 
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <stdio.h>
#include <conio.h>
#include <time.h>

#include <Packet32.h>


#define Max_Num_Adapter 10

#include <tchar.h>
BOOL LoadNpcapDlls()
{
	TCHAR npcap_dir[512];
	UINT len;
	len = GetSystemDirectory(npcap_dir, 480);
	if (!len) {
		fprintf(stderr, "Error in GetSystemDirectory: %x", GetLastError());
		return FALSE;
	}
	_tcscat_s(npcap_dir, 512, TEXT("\\Npcap"));
	if (SetDllDirectory(npcap_dir) == 0) {
		fprintf(stderr, "Error in SetDllDirectory: %x", GetLastError());
		return FALSE;
	}
	return TRUE;
}

// Prototypes

void PrintPackets(LPPACKET lpPacket);

char        AdapterList[Max_Num_Adapter][8192];



int main(int argc, char **argv)
{	
char packetbuff[5000];

// define a pointer to a ADAPTER structure

LPADAPTER  lpAdapter = 0;

// define a pointer to a PACKET structure

LPPACKET   lpPacket;

int        i,npacks,Snaplen;
DWORD      dwErrorCode;

//ascii strings
char		AdapterName[8192]; // string that contains a list of the network adapters
char		*temp,*temp1;

int			AdapterNum=0,Open;
ULONG		AdapterLength;

float	cpu_time;
	
	/* Load Npcap and its functions. */
	if (!LoadNpcapDlls())
	{
		fprintf(stderr, "Couldn't load Npcap\n");
		exit(1);
	}

	printf("Traffic Generator v 0.9999\nCopyright 1999 Loris Degioanni (loris@netgroup-serv.polito.it)");
	printf("\nSends a set of packets to the network using packet.dll API.\n");
	
	if (argc == 1){
		printf("\n\n Usage: TestpacketSend [-i adapter] -n npacks -s size");
		printf("\n size is between 60 and 1514\n\n");
		return -1;
	}
	
	
	AdapterName[0]=0;
	
	//get the command line parameters
	for(i=1;i<argc;i+=2){
		
		switch (argv[i] [1])
		{
			
		case 'i':
			sscanf_s(argv[i+1],"%s",AdapterName, (unsigned)_countof(AdapterName));
			break;
			
		case 'n':
			sscanf_s(argv[i+1],"%d",&npacks);
			break;
			
		case 's':
			sscanf_s(argv[i+1],"%d",&Snaplen);
			break;
			
		}
		
	}
	
	
	
	if(AdapterName[0]==0){
		
		//
		// Obtain the name of the adapters installed on this machine		
		//
		printf("Adapters installed:\n");
		i=0;
		
		AdapterLength = sizeof(AdapterName);

		if(PacketGetAdapterNames(AdapterName,&AdapterLength)==FALSE){
			printf("Unable to retrieve the list of the adapters!\n");
			return -1;
		}
		temp=AdapterName;
		temp1=AdapterName;
			
		while ((*temp!='\0')||(*(temp-1)!='\0'))
		{
			if (*temp=='\0') 
			{
				memcpy(AdapterList[i],temp1,temp-temp1);
				temp1=temp+1;
				i++;
			}
			temp++;
		}
			
		AdapterNum=i;
		for (i=0;i<AdapterNum;i++)
			printf("\n%d- %s\n",i+1,AdapterList[i]);
		printf("\n");
			
		do 
		{
			printf("Select the number of the adapter to open : ");scanf_s("%d",&Open);
			if (Open>AdapterNum) printf("\nThe number must be smaller than %d",AdapterNum); 
		} while (Open>AdapterNum);
		
		
		
		
		lpAdapter =   PacketOpenAdapter(AdapterList[Open-1]);
		
		if (!lpAdapter || (lpAdapter->hFile == INVALID_HANDLE_VALUE))
		{
			dwErrorCode=GetLastError();
			printf("Unable to open the driver, Error Code : %lx\n",dwErrorCode); 
			
			return(-1);
		}	
		
	}
	else{
		
		lpAdapter =  PacketOpenAdapter(AdapterName);
		
		if (!lpAdapter || (lpAdapter->hFile == INVALID_HANDLE_VALUE))
		{
			dwErrorCode=GetLastError();
			printf("Unable to open the driver, Error Code : %lx\n",dwErrorCode); 
			
			return(-1);
		}
		
	}
	
	if((lpPacket = PacketAllocatePacket())==NULL){
		printf("\nError:failed to allocate the LPPACKET structure.");
		return (-1);
	}
	
	packetbuff[0]=1;
	packetbuff[1]=1;
	packetbuff[2]=1;
	packetbuff[3]=1;
	packetbuff[4]=1;
	packetbuff[5]=1;
	
	packetbuff[6]=2;
	packetbuff[7]=2;
	packetbuff[8]=2;
	packetbuff[9]=2;
	packetbuff[10]=2;
	packetbuff[11]=2;
	
	for(i=12;i<1514;i++){
		packetbuff[i]= (char)i;
	}
	
	PacketInitPacket(lpPacket,packetbuff,Snaplen);
	// capture the packet
	
	
	if(PacketSetNumWrites(lpAdapter,npacks)==FALSE){
		printf("warning: Unable to send more than one packet in a single write!\n");
	}
	
	printf("\n\nGenerating %d packets...",npacks);
	
	cpu_time = (float)clock ();
	
	if(PacketSendPacket(lpAdapter,lpPacket,TRUE)==FALSE){
		printf("Error sending the packets!\n");
		return -1;
	}
	
	cpu_time = (clock() - cpu_time)/CLK_TCK;
	
	printf ("\n\nElapsed time: %5.3f\n", cpu_time);
	printf ("\nTotal packets generated = %d", npacks);
	printf ("\nTotal bytes generated = %d", (Snaplen+24)*npacks);
	printf ("\nTotal bits generated = %d", (Snaplen+24)*npacks*8);
	printf ("\nAverage packets per second = %d", (int)((double)npacks/cpu_time));
	printf ("\nAverage bytes per second = %d", (int)((double)((Snaplen+24)*npacks)/cpu_time));
	printf ("\nAverage bits per second = %d", (int)((double)((Snaplen+24)*npacks*8)/cpu_time));
	printf ("\n");
	
	PacketFreePacket(lpPacket);
	
	// close the adapter and exit
	
	PacketCloseAdapter(lpAdapter);
	return (0);
}

```

`Examples/PacketDriver/TestPacketSend/TestPacketSend.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{1E3BED58-2F2C-463A-B9FD-9A55235C6840}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <AdditionalDependencies>Packet.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>Packet.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>Packet.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>Packet.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalDependencies>Packet.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <AdditionalDependencies>Packet.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <DelayLoadDLLs>Packet.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <DelayLoadDLLs>Packet.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <AdditionalDependencies>Packet.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <AdditionalDependencies>Packet.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <DelayLoadDLLs>Packet.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <DelayLoadDLLs>Packet.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="TestPacketSend.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`Examples/PacketDriver/readme.txt`:

```txt
These files use the packet.dll API instead of wpcap.dll.
The use of packet.dll API is strongly discouraged.

```

`Examples/UDPdump/UDPdump.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{42E5F1D6-6E83-4C13-83CC-C6CD83478C58}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <AdditionalDependencies>wpcap.lib;ws2_32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>wpcap.lib;ws2_32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;ws2_32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;ws2_32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;ws2_32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;ws2_32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="udpdump.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`Examples/UDPdump/udpdump.c`:

```c
/*
 * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)
 * Copyright (c) 2005 - 2006 CACE Technologies, Davis (California)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Politecnico di Torino, CACE Technologies 
 * nor the names of its contributors may be used to endorse or promote 
 * products derived from this software without specific prior written 
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <pcap.h>
#include <time.h>
#include <Winsock2.h>
#include <tchar.h>
BOOL LoadNpcapDlls()
{
    _TCHAR npcap_dir[512];
    UINT len;
    len = GetSystemDirectory(npcap_dir, 480);
    if (!len) {
        fprintf(stderr, "Error in GetSystemDirectory: %x", GetLastError());
        return FALSE;
    }
    _tcscat_s(npcap_dir, 512, _T("\\Npcap"));
    if (SetDllDirectory(npcap_dir) == 0) {
        fprintf(stderr, "Error in SetDllDirectory: %x", GetLastError());
        return FALSE;
    }
    return TRUE;
}


/* 4 bytes IP address */
typedef struct ip_address{
	u_char byte1;
	u_char byte2;
	u_char byte3;
	u_char byte4;
}ip_address;

/* IPv4 header */
typedef struct ip_header{
	u_char	ver_ihl;		// Version (4 bits) + Internet header length (4 bits)
	u_char	tos;			// Type of service 
	u_short tlen;			// Total length 
	u_short identification; // Identification
	u_short flags_fo;		// Flags (3 bits) + Fragment offset (13 bits)
	u_char	ttl;			// Time to live
	u_char	proto;			// Protocol
	u_short crc;			// Header checksum
	ip_address	saddr;		// Source address
	ip_address	daddr;		// Destination address
	u_int	op_pad;			// Option + Padding
}ip_header;

/* UDP header*/
typedef struct udp_header{
	u_short sport;			// Source port
	u_short dport;			// Destination port
	u_short len;			// Datagram length
	u_short crc;			// Checksum
}udp_header;

/* prototype of the packet handler */
void packet_handler(u_char *param, const struct pcap_pkthdr *header, const u_char *pkt_data);


int main()
{
pcap_if_t *alldevs;
pcap_if_t *d;
int inum;
int i=0;
pcap_t *adhandle;
char errbuf[PCAP_ERRBUF_SIZE];
u_int netmask;
char packet_filter[] = "ip and udp";
struct bpf_program fcode;

    /* Load Npcap and its functions. */
    if (!LoadNpcapDlls())
    {
        fprintf(stderr, "Couldn't load Npcap\n");
        exit(1);
    }

	/* Retrieve the device list */
	if (pcap_findalldevs_ex(PCAP_SRC_IF_STRING, NULL, &alldevs, errbuf) == -1)
	{
		fprintf(stderr,"Error in pcap_findalldevs: %s\n", errbuf);
		exit(1);
	}
	
	/* Print the list */
	for(d=alldevs; d; d=d->next)
	{
		printf("%d. %s", ++i, d->name);
		if (d->description)
			printf(" (%s)\n", d->description);
		else
			printf(" (No description available)\n");
	}

	if(i==0)
	{
		printf("\nNo interfaces found! Make sure Npcap is installed.\n");
		return -1;
	}
	
	printf("Enter the interface number (1-%d):",i);
	scanf_s("%d", &inum);
	
	if(inum < 1 || inum > i)
	{
		printf("\nInterface number out of range.\n");
		/* Free the device list */
		pcap_freealldevs(alldevs);
		return -1;
	}

	/* Jump to the selected adapter */
	for(d=alldevs, i=0; i< inum-1 ;d=d->next, i++);
	
	/* Open the adapter */
	if ( (adhandle= pcap_open(d->name,	// name of the device
							 65536,		// portion of the packet to capture. 
										// 65536 grants that the whole packet will be captured on all the MACs.
							 PCAP_OPENFLAG_PROMISCUOUS,			// promiscuous mode
							 1000,		// read timeout
							 NULL,		// remote authentication
							 errbuf		// error buffer
							 ) ) == NULL)
	{
		fprintf(stderr,"\nUnable to open the adapter. %s is not supported by Npcap\n", d->name);
		/* Free the device list */
		pcap_freealldevs(alldevs);
		return -1;
	}
	
	/* Check the link layer. We support only Ethernet for simplicity. */
	if(pcap_datalink(adhandle) != DLT_EN10MB)
	{
		fprintf(stderr,"\nThis program works only on Ethernet networks.\n");
		/* Free the device list */
		pcap_freealldevs(alldevs);
		return -1;
	}
	
	if(d->addresses != NULL)
		/* Retrieve the mask of the first address of the interface */
		netmask=((struct sockaddr_in *)(d->addresses->netmask))->sin_addr.S_un.S_addr;
	else
		/* If the interface is without addresses we suppose to be in a C class network */
		netmask=0xffffff; 


	//compile the filter
	if (pcap_compile(adhandle, &fcode, packet_filter, 1, netmask) <0 )
	{
		fprintf(stderr,"\nUnable to compile the packet filter. Check the syntax.\n");
		/* Free the device list */
		pcap_freealldevs(alldevs);
		return -1;
	}
	
	//set the filter
	if (pcap_setfilter(adhandle, &fcode)<0)
	{
		fprintf(stderr,"\nError setting the filter.\n");
		/* Free the device list */
		pcap_freealldevs(alldevs);
		return -1;
	}
	
	printf("\nlistening on %s...\n", d->description);
	
	/* At this point, we don't need any more the device list. Free it */
	pcap_freealldevs(alldevs);
	
	/* start the capture */
	pcap_loop(adhandle, 0, packet_handler, NULL);
	
	return 0;
}

/* Callback function invoked by libpcap for every incoming packet */
void packet_handler(u_char *param, const struct pcap_pkthdr *header, const u_char *pkt_data)
{
	struct tm ltime;
	char timestr[16];
	ip_header *ih;
	udp_header *uh;
	u_int ip_len;
	u_short sport,dport;
	time_t local_tv_sec;

	/*
	 * Unused variable
	 */
	(VOID)(param);

	/* convert the timestamp to readable format */
	local_tv_sec = header->ts.tv_sec;
	localtime_s(&ltime, &local_tv_sec);
	strftime( timestr, sizeof timestr, "%H:%M:%S", &ltime);

	/* print timestamp and length of the packet */
	printf("%s.%.6d len:%d ", timestr, header->ts.tv_usec, header->len);

	/* retireve the position of the ip header */
	ih = (ip_header *) (pkt_data +
		14); //length of ethernet header

	/* retireve the position of the udp header */
	ip_len = (ih->ver_ihl & 0xf) * 4;
	uh = (udp_header *) ((u_char*)ih + ip_len);

	/* convert from network byte order to host byte order */
	sport = ntohs( uh->sport );
	dport = ntohs( uh->dport );

	/* print ip addresses and udp ports */
	printf("%d.%d.%d.%d.%d -> %d.%d.%d.%d.%d\n",
		ih->saddr.byte1,
		ih->saddr.byte2,
		ih->saddr.byte3,
		ih->saddr.byte4,
		sport,
		ih->daddr.byte1,
		ih->daddr.byte2,
		ih->daddr.byte3,
		ih->daddr.byte4,
		dport);
}

```

`Examples/UserLevelBridge/UserBridge.c`:

```c
/*
 * Copyright (c) 2005 - 2006
 *		CACE Technologies, Davis, CA
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright 
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright 
 * notice, this list of conditions and the following disclaimer in the 
 * documentation and/or other materials provided with the distribution. 
 * 3. Neither the name of CACE Technologies nor the names of its 
 * contributors may be used to endorse or promote products derived from 
 * this software without specific prior written permission. 
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */

/*
 * This simple program implements a user-level bridge. 
 * It opens two adapters specified by the user and starts two threads.
 * The first thread receives packets from adapter 1 and sends them down to
 * adapter 2. The second thread does the same, but in the opposite 
 * direction.
 */

#include <signal.h>
#include <pcap.h>
#include <tchar.h>
BOOL LoadNpcapDlls()
{
    _TCHAR npcap_dir[512];
    UINT len;
    len = GetSystemDirectory(npcap_dir, 480);
    if (!len) {
        fprintf(stderr, "Error in GetSystemDirectory: %x", GetLastError());
        return FALSE;
    }
    _tcscat_s(npcap_dir, 512, _T("\\Npcap"));
    if (SetDllDirectory(npcap_dir) == 0) {
        fprintf(stderr, "Error in SetDllDirectory: %x", GetLastError());
        return FALSE;
    }
    return TRUE;
}


/* Storage data structure used to pass parameters to the threads */
typedef struct _in_out_adapters
{
	unsigned int state;		/* Some simple state information */
	pcap_t *input_adapter;
	pcap_t *output_adapter;
}in_out_adapters;

/* Prototypes */
DWORD WINAPI CaptureAndForwardThread(LPVOID lpParameter);
void ctrlc_handler(int sig);

/* This prevents the two threads to mess-up when they do printfs */
CRITICAL_SECTION print_cs;

/* Thread handlers. Global because we wait on the threads from the CTRL+C handler */
HANDLE threads[2];

/* This global variable tells the forwarder threads they must terminate */
volatile int kill_forwaders = 0;


/*******************************************************************/

int main()
{
	pcap_if_t *alldevs;
	pcap_if_t *d;
	int inum1, inum2;
	int i=0;
	pcap_t *adhandle1, *adhandle2;
	char errbuf[PCAP_ERRBUF_SIZE];
	u_int netmask1, netmask2;
	char packet_filter[256];
	struct bpf_program fcode;
	in_out_adapters couple0, couple1;

	/* Load Npcap and its functions. */
	if (!LoadNpcapDlls())
	{
		fprintf(stderr, "Couldn't load Npcap\n");
		exit(1);
	}

	/* 
	 * Retrieve the device list 
	 */

	if (pcap_findalldevs_ex(PCAP_SRC_IF_STRING, NULL, &alldevs, errbuf) == -1)
	{
		fprintf(stderr,"Error in pcap_findalldevs: %s\n", errbuf);
		exit(1);
	}
	
	/* Print the list */
	for(d=alldevs; d; d=d->next)
	{
		printf("%d. ", ++i);
		if (d->description)
			printf("%s\n", d->description);
		else
			printf("<unknown adapter>\n");
	}

	if(i==0)
	{
		printf("\nNo interfaces found! Make sure Npcap is installed.\n");
		return -1;
	}


	/*
	 * Get input from the user
	 */

	/* Get the filter*/
	printf("\nSpecify filter (hit return for no filter):");
	
	fgets(packet_filter, sizeof(packet_filter), stdin);

	/* Get the first interface number*/
	printf("\nEnter the number of the first interface to use (1-%d):",i);
	scanf_s("%d", &inum1);
	
	if(inum1 < 1 || inum1 > i)
	{
		printf("\nInterface number out of range.\n");
		/* Free the device list */
		pcap_freealldevs(alldevs);
		return -1;
	}

	/* Get the second interface number*/
	printf("Enter the number of the first interface to use (1-%d):",i);
	scanf_s("%d", &inum2);
	
	if(inum2 < 1 || inum2 > i)
	{
		printf("\nInterface number out of range.\n");
		/* Free the device list */
		pcap_freealldevs(alldevs);
		return -1;
	}

	if(inum1 == inum2 )
	{
		printf("\nCannot bridge packets on the same interface.\n");
		/* Free the device list */
		pcap_freealldevs(alldevs);
		return -1;
	}


	/*
	 * Open the specified couple of adapters
	 */

	/* Jump to the first selected adapter */
	for(d = alldevs, i = 0; i< inum1 - 1 ;d = d->next, i++);
	
	/* 
	 * Open the first adapter.
	 * *NOTICE* the flags we are using, they are important for the behavior of the prgram:
	 *	- PCAP_OPENFLAG_PROMISCUOUS: tells the adapter to go in promiscuous mode.
	 *    This means that we are capturing all the traffic, not only the one to or from
	 *    this machine.
	 *	- PCAP_OPENFLAG_NOCAPTURE_LOCAL: prevents the adapter from capturing again the packets
	 *	  transmitted by itself. This avoids annoying loops.
	 *	- PCAP_OPENFLAG_MAX_RESPONSIVENESS: configures the adapter to provide minimum latency,
	 *	  at the cost of higher CPU usage.
	 */
	if((adhandle1 = pcap_open(d->name,						// name of the device
							 65536,							// portion of the packet to capture. 
															// 65536 grants that the whole packet will be captured on every link layer.
							 PCAP_OPENFLAG_PROMISCUOUS |	// flags. We specify that we don't want to capture loopback packets, and that the driver should deliver us the packets as fast as possible
							 PCAP_OPENFLAG_NOCAPTURE_LOCAL |
							 PCAP_OPENFLAG_MAX_RESPONSIVENESS,
							 500,							// read timeout
							 NULL,							// remote authentication
							 errbuf							// error buffer
							 )) == NULL)
	{
		fprintf(stderr,"\nUnable to open the adapter. %s is not supported by Npcap\n", d->description);
		/* Free the device list */
		pcap_freealldevs(alldevs);
		return -1;
	}
		
	if(d->addresses != NULL)
	{
		/* Retrieve the mask of the first address of the interface */
		netmask1 = ((struct sockaddr_in *)(d->addresses->netmask))->sin_addr.S_un.S_addr;
	}
	else
	{
		/* If the interface is without addresses we suppose to be in a C class network */
		netmask1 = 0xffffff; 
	}

	/* Jump to the second selected adapter */
	for(d = alldevs, i = 0; i< inum2 - 1 ;d = d->next, i++);
	
	/* Open the second adapter */
	if((adhandle2 = pcap_open(d->name,						// name of the device
							 65536,							// portion of the packet to capture. 
															// 65536 grants that the whole packet will be captured on every link layer.
							 PCAP_OPENFLAG_PROMISCUOUS |	// flags. We specify that we don't want to capture loopback packets, and that the driver should deliver us the packets as fast as possible
							 PCAP_OPENFLAG_NOCAPTURE_LOCAL |
							 PCAP_OPENFLAG_MAX_RESPONSIVENESS,
							 500,							// read timeout
							 NULL,							// remote authentication
							 errbuf							// error buffer
							 )) == NULL)
	{
		fprintf(stderr,"\nUnable to open the adapter. %s is not supported by Npcap\n", d->description);
		/* Free the device list */
		pcap_freealldevs(alldevs);
		return -1;
	}

	if(d->addresses != NULL)
	{
		/* Retrieve the mask of the first address of the interface */
		netmask2 = ((struct sockaddr_in *)(d->addresses->netmask))->sin_addr.S_un.S_addr;
	}
	else
	{
		/* If the interface is without addresses we suppose to be in a C class network */
		netmask2 = 0xffffff; 
	}


	/*
	 * Compile and set the filters
	 */

	/* compile the filter for the first adapter */
	if (pcap_compile(adhandle1, &fcode, packet_filter, 1, netmask1) <0 )
	{
		fprintf(stderr,"\nUnable to compile the packet filter. Check the syntax.\n");

		/* Close the adapters */
		pcap_close(adhandle1);
		pcap_close(adhandle2);

		/* Free the device list */
		pcap_freealldevs(alldevs);
		return -1;
	}
	
	/* set the filter for the first adapter*/
	if (pcap_setfilter(adhandle1, &fcode)<0)
	{
		fprintf(stderr,"\nError setting the filter.\n");

		/* Close the adapters */
		pcap_close(adhandle1);
		pcap_close(adhandle2);

		/* Free the device list */
		pcap_freealldevs(alldevs);
		return -1;
	}
	
	/* compile the filter for the second adapter */
	if (pcap_compile(adhandle2, &fcode, packet_filter, 1, netmask2) <0 )
	{
		fprintf(stderr,"\nUnable to compile the packet filter. Check the syntax.\n");
		
		/* Close the adapters */
		pcap_close(adhandle1);
		pcap_close(adhandle2);

		/* Free the device list */
		pcap_freealldevs(alldevs);
		return -1;
	}
	
	/* set the filter for the second adapter*/
	if (pcap_setfilter(adhandle2, &fcode)<0)
	{
		fprintf(stderr,"\nError setting the filter.\n");

		/* Close the adapters */
		pcap_close(adhandle1);
		pcap_close(adhandle2);

		/* Free the device list */
		pcap_freealldevs(alldevs);
		return -1;
	}
	
	/* At this point, we don't need the device list any more. Free it */
	pcap_freealldevs(alldevs);
		
	/* 
	 * Start the threads that will forward the packets 
	 */

	/* Initialize the critical section that will be used by the threads for console output */
	InitializeCriticalSection(&print_cs);

	/* Init input parameters of the threads */
	couple0.state = 0;
	couple0.input_adapter = adhandle1;
	couple0.output_adapter = adhandle2;
	couple1.state = 1;
	couple1.input_adapter = adhandle2;
	couple1.output_adapter = adhandle1;
	
	/* Start first thread */
	if((threads[0] = CreateThread(
		NULL,
		0,
		CaptureAndForwardThread,
		&couple0,
		0,
		NULL)) == NULL)
	{
			fprintf(stderr, "error creating the first forward thread");
			
			/* Close the adapters */
			pcap_close(adhandle1);
			pcap_close(adhandle2);
			
			/* Free the device list */
			pcap_freealldevs(alldevs);
			return -1;
	}

	/* Start second thread */
	if((threads[1] = CreateThread(
		NULL,
		0,
		CaptureAndForwardThread,
		&couple1,
		0,
		NULL)) == NULL)
	{
			fprintf(stderr, "error creating the second forward thread");
	
			/* Kill the first thread. Not very gentle at all...*/
			TerminateThread(threads[0], 0);

			/* Close the adapters */
			pcap_close(adhandle1);
			pcap_close(adhandle2);
			
			/* Free the device list */
			pcap_freealldevs(alldevs);
			return -1;
	}

	/*
	 * Install a CTRL+C handler that will do the cleanups on exit
	 */
	signal(SIGINT, ctrlc_handler);

	/* 
	 * Done! 
	 * Wait for the Greek calends... 
	 */
	printf("\nStart bridging the two adapters...\n", d->description);
	Sleep(INFINITE);
	return 0;
}

/*******************************************************************
 * Forwarding thread.
 * Gets the packets from the input adapter and sends them to the output one.
 *******************************************************************/
DWORD WINAPI CaptureAndForwardThread(LPVOID lpParameter)
{
	struct pcap_pkthdr *header;
	const u_char *pkt_data;
	int res = 0;
	in_out_adapters* ad_couple = lpParameter;
	unsigned int n_fwd = 0;
	
	/*
	 * Loop receiving packets from the first input adapter
	 */

	while((!kill_forwaders) && (res = pcap_next_ex(ad_couple->input_adapter, &header, &pkt_data)) >= 0)
	{		
		if(res != 0)	/* Note: res=0 means "read timeout elapsed"*/
		{
			/* 
			 * Print something, just to show when we have activity.
			 * BEWARE: acquiring a critical section and printing strings with printf
			 * is something inefficient that you seriously want to avoid in your packet loop!	
			 * However, since this is a *sample program*, we privilege visual output to efficiency.
			 */
			EnterCriticalSection(&print_cs);
			
			if(ad_couple->state == 0)
				printf(">> Len: %u\n", header->caplen);
			else
				printf("<< Len: %u\n", header->caplen);		
			
			LeaveCriticalSection(&print_cs); 

			/*
			 * Send the just received packet to the output adaper
			 */
			if(pcap_sendpacket(ad_couple->output_adapter, pkt_data, header->caplen) != 0)
			{
				EnterCriticalSection(&print_cs);
				
				printf("Error sending a %u bytes packets on interface %u: %s\n",
					header->caplen,
					ad_couple->state,
					pcap_geterr(ad_couple->output_adapter));
				
				LeaveCriticalSection(&print_cs); 
			}
			else
			{
				n_fwd++;
			}
		}
	}

	/*
	 * We're out of the main loop. Check the reason.
	 */
	if(res < 0)
	{
		EnterCriticalSection(&print_cs);

		printf("Error capturing the packets: %s\n", pcap_geterr(ad_couple->input_adapter));
		fflush(stdout);
		
		LeaveCriticalSection(&print_cs); 
	}
	else
	{
		EnterCriticalSection(&print_cs);

		printf("End of bridging on interface %u. Forwarded packets:%u\n",
			ad_couple->state,
			n_fwd);
		fflush(stdout);
		
		LeaveCriticalSection(&print_cs);
	}

	return 0;
}

/*******************************************************************
 * CTRL+C hanlder.
 * We order the threads to die and then we patiently wait for their
 * suicide.
 *******************************************************************/
void ctrlc_handler(int sig)
{
	/*
	 * unused variable
	 */
	(VOID)(sig);

	kill_forwaders = 1;

	WaitForMultipleObjects(2,
				threads,
				TRUE,		/* Wait for all the handles */
				5000);		/* Timeout */

	exit(0);
}

```

`Examples/UserLevelBridge/UserBridge.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{BB73BFD4-454F-42C8-AFE6-FA890A8BD8FC}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="UserBridge.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`Examples/iflist/iflist.c`:

```c
/*
 * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)
 * Copyright (c) 2005 - 2006 CACE Technologies, Davis (California)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Politecnico di Torino, CACE Technologies 
 * nor the names of its contributors may be used to endorse or promote 
 * products derived from this software without specific prior written 
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <stdio.h>

#include "pcap.h"

#ifndef _WIN32
	#include <sys/socket.h>
	#include <netinet/in.h>
#else
	#include <winsock.h>
	#include <tchar.h>
BOOL LoadNpcapDlls()
{
	TCHAR npcap_dir[512];
	UINT len;
	len = GetSystemDirectory(npcap_dir, 480);
	if (!len) {
		fprintf(stderr, "Error in GetSystemDirectory: %x", GetLastError());
		return FALSE;
	}
	_tcscat_s(npcap_dir, 512, TEXT("\\Npcap"));
	if (SetDllDirectory(npcap_dir) == 0) {
		fprintf(stderr, "Error in SetDllDirectory: %x", GetLastError());
		return FALSE;
	}
	return TRUE;
}
#endif


// Function prototypes
void ifprint(pcap_if_t *d);
char *iptos(u_long in);
char* ip6tos(struct sockaddr *sockaddr, char *address, int addrlen);


int main()
{
  pcap_if_t *alldevs;
  pcap_if_t *d;
  char errbuf[PCAP_ERRBUF_SIZE+1];
  char source[PCAP_ERRBUF_SIZE+1];
#ifdef _WIN32
  /* Load Npcap and its functions. */
  if (!LoadNpcapDlls())
  {
	  fprintf(stderr, "Couldn't load Npcap\n");
	  exit(1);
  }
#endif
  printf("Enter the device you want to list:\n"
			"rpcap://              ==> lists interfaces in the local machine\n"
			"rpcap://hostname:port ==> lists interfaces in a remote machine\n"
			"                          (rpcapd daemon must be up and running\n"
			"                           and it must accept 'null' authentication)\n"
			"file://foldername     ==> lists all pcap files in the give folder\n\n"
			"Enter your choice: ");

  fgets(source, PCAP_ERRBUF_SIZE, stdin);
  source[PCAP_ERRBUF_SIZE] = '\0';

  /* Retrieve the interfaces list */
  if (pcap_findalldevs_ex(source, NULL, &alldevs, errbuf) == -1)
  {
    fprintf(stderr,"Error in pcap_findalldevs: %s\n",errbuf);
    exit(1);
  }

  /* Scan the list printing every entry */
  for(d=alldevs;d;d=d->next)
  {
    ifprint(d);
  }

  pcap_freealldevs(alldevs);

  return 1;
}



/* Print all the available information on the given interface */
void ifprint(pcap_if_t *d)
{
  pcap_addr_t *a;
  char ip6str[128];

  /* Name */
  printf("%s\n",d->name);

  /* Description */
  if (d->description)
    printf("\tDescription: %s\n",d->description);

  /* Loopback Address*/
  printf("\tLoopback: %s\n",(d->flags & PCAP_IF_LOOPBACK)?"yes":"no");

  /* IP addresses */
  for(a=d->addresses;a;a=a->next) {
    printf("\tAddress Family: #%d\n",a->addr->sa_family);
  
    switch(a->addr->sa_family)
    {
      case AF_INET:
        printf("\tAddress Family Name: AF_INET\n");
        if (a->addr)
          printf("\tAddress: %s\n",iptos(((struct sockaddr_in *)a->addr)->sin_addr.s_addr));
        if (a->netmask)
          printf("\tNetmask: %s\n",iptos(((struct sockaddr_in *)a->netmask)->sin_addr.s_addr));
        if (a->broadaddr)
          printf("\tBroadcast Address: %s\n",iptos(((struct sockaddr_in *)a->broadaddr)->sin_addr.s_addr));
        if (a->dstaddr)
          printf("\tDestination Address: %s\n",iptos(((struct sockaddr_in *)a->dstaddr)->sin_addr.s_addr));
        break;

	  case AF_INET6:
        printf("\tAddress Family Name: AF_INET6\n");
        if (a->addr)
          printf("\tAddress: %s\n", ip6tos(a->addr, ip6str, sizeof(ip6str)));
       break;

	  default:
        printf("\tAddress Family Name: Unknown\n");
        break;
    }
  }
  printf("\n");
}



/* From tcptraceroute, convert a numeric IP address to a string */
#define IPTOSBUFFERS	12
char *iptos(u_long in)
{
	static char output[IPTOSBUFFERS][3*4+3+1];
	static short which;
	u_char *p;

	p = (u_char *)&in;
	which = (which + 1 == IPTOSBUFFERS ? 0 : which + 1);
	_snprintf_s(output[which], sizeof(output[which]), sizeof(output[which]),"%d.%d.%d.%d", p[0], p[1], p[2], p[3]);
	return output[which];
}

char* ip6tos(struct sockaddr *sockaddr, char *address, int addrlen)
{
	socklen_t sockaddrlen;

	#ifdef _WIN32
	sockaddrlen = sizeof(struct sockaddr_in6);
	#else
	sockaddrlen = sizeof(struct sockaddr_storage);
	#endif


	if(getnameinfo(sockaddr, 
		sockaddrlen, 
		address, 
		addrlen, 
		NULL, 
		0, 
		NI_NUMERICHOST) != 0) address = NULL;

	return address;
}



```

`Examples/iflist/iflist.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{0B27B213-4BF3-4611-B412-A2D09CDE8632}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <AdditionalDependencies>wpcap.lib;ws2_32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>wpcap.lib;ws2_32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;ws2_32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;ws2_32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;ws2_32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;ws2_32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="iflist.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`Examples/iflist/iflist.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="iflist.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`Examples/misc/basic_dump.c`:

```c
#include <pcap.h>
#include "misc.h"
#include <time.h>

/* prototype of the packet handler */
void packet_handler(u_char *param, const struct pcap_pkthdr *header, const u_char *pkt_data);

int main()
{
pcap_if_t *alldevs;
pcap_if_t *d;
int inum;
int i=0;
pcap_t *adhandle;
char errbuf[PCAP_ERRBUF_SIZE];
	
    /* Load Npcap and its functions. */
    if (!LoadNpcapDlls())
    {
        fprintf(stderr, "Couldn't load Npcap\n");
        exit(1);
    }

	/* Retrieve the device list on the local machine */
	if (pcap_findalldevs_ex(PCAP_SRC_IF_STRING, NULL, &alldevs, errbuf) == -1)
	{
		fprintf(stderr,"Error in pcap_findalldevs: %s\n", errbuf);
		exit(1);
	}
	
	/* Print the list */
	for(d=alldevs; d; d=d->next)
	{
		printf("%d. %s", ++i, d->name);
		if (d->description)
			printf(" (%s)\n", d->description);
		else
			printf(" (No description available)\n");
	}
	
	if(i==0)
	{
		printf("\nNo interfaces found! Make sure Npcap is installed.\n");
		return -1;
	}
	
	printf("Enter the interface number (1-%d):",i);
	scanf_s("%d", &inum);
	
	if(inum < 1 || inum > i)
	{
		printf("\nInterface number out of range.\n");
		/* Free the device list */
		pcap_freealldevs(alldevs);
		return -1;
	}
	
	/* Jump to the selected adapter */
	for(d=alldevs, i=0; i< inum-1 ;d=d->next, i++);
	
	/* Open the device */
	if ( (adhandle= pcap_open(d->name,			// name of the device
							  65536,			// portion of the packet to capture
												// 65536 guarantees that the whole packet will be captured on all the link layers
							  PCAP_OPENFLAG_PROMISCUOUS, 	// promiscuous mode
							  1000,				// read timeout
							  NULL,				// authentication on the remote machine
							  errbuf			// error buffer
							  ) ) == NULL)
	{
		fprintf(stderr,"\nUnable to open the adapter. %s is not supported by Npcap\n", d->name);
		/* Free the device list */
		pcap_freealldevs(alldevs);
		return -1;
	}
	
	printf("\nlistening on %s...\n", d->description);
	
	/* At this point, we don't need any more the device list. Free it */
	pcap_freealldevs(alldevs);
	
	/* start the capture */
	pcap_loop(adhandle, 0, packet_handler, NULL);
	
	return 0;
}


/* Callback function invoked by libpcap for every incoming packet */
void packet_handler(u_char *param, const struct pcap_pkthdr *header, const u_char *pkt_data)
{
	struct tm ltime;
	char timestr[16];
	time_t local_tv_sec;

	/*
	 * unused variables
	 */
	(VOID)(param);
	(VOID)(pkt_data);

	/* convert the timestamp to readable format */
	local_tv_sec = header->ts.tv_sec;
	localtime_s(&ltime, &local_tv_sec);
	strftime( timestr, sizeof timestr, "%H:%M:%S", &ltime);
	
	printf("%s,%.6d len:%d\n", timestr, header->ts.tv_usec, header->len);
	
}

```

`Examples/misc/basic_dump.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{66297062-96A0-4F0E-B147-3C8384031232}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/FS %(AdditionalOptions)</AdditionalOptions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/FS %(AdditionalOptions)</AdditionalOptions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/FS %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/FS %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/FS %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/FS %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="basic_dump.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`Examples/misc/basic_dump_ex.c`:

```c
#include "pcap.h"
#include <time.h>


int main()
{
pcap_if_t *alldevs;
pcap_if_t *d;
int inum;
int i=0;
pcap_t *adhandle;
int res;
char errbuf[PCAP_ERRBUF_SIZE];
struct tm ltime;
char timestr[16];
struct pcap_pkthdr *header;
const u_char *pkt_data;
time_t local_tv_sec;
	
    
	/* Retrieve the device list on the local machine */
	if (pcap_findalldevs_ex(PCAP_SRC_IF_STRING, NULL, &alldevs, errbuf) == -1)
	{
		fprintf(stderr,"Error in pcap_findalldevs: %s\n", errbuf);
		exit(1);
	}
    
    /* Print the list */
    for(d=alldevs; d; d=d->next)
    {
        printf("%d. %s", ++i, d->name);
        if (d->description)
            printf(" (%s)\n", d->description);
        else
            printf(" (No description available)\n");
    }
	
    if(i==0)
    {
        printf("\nNo interfaces found! Make sure Npcap is installed.\n");
        return -1;
    }
    
    printf("Enter the interface number (1-%d):",i);
    scanf_s("%d", &inum);
    
    if(inum < 1 || inum > i)
    {
        printf("\nInterface number out of range.\n");
        /* Free the device list */
        pcap_freealldevs(alldevs);
        return -1;
    }
	
    /* Jump to the selected adapter */
    for(d=alldevs, i=0; i< inum-1 ;d=d->next, i++);
    
	/* Open the device */
	if ( (adhandle= pcap_open(d->name,			// name of the device
							  65536,			// portion of the packet to capture. 
												// 65536 guarantees that the whole packet will be captured on all the link layers
							  PCAP_OPENFLAG_PROMISCUOUS, 	// promiscuous mode
							  1000,				// read timeout
							  NULL,				// authentication on the remote machine
							  errbuf			// error buffer
							  ) ) == NULL)
	{
		fprintf(stderr,"\nUnable to open the adapter. %s is not supported by Npcap\n", d->name);
		/* Free the device list */
		pcap_freealldevs(alldevs);
		return -1;
	}
    
    printf("\nlistening on %s...\n", d->description);
	
    /* At this point, we don't need any more the device list. Free it */
    pcap_freealldevs(alldevs);
	
	/* Retrieve the packets */
	while((res = pcap_next_ex( adhandle, &header, &pkt_data)) >= 0){
		
		if(res == 0)
			/* Timeout elapsed */
			continue;
		
		/* convert the timestamp to readable format */
		local_tv_sec = header->ts.tv_sec;
		localtime_s(&ltime, &local_tv_sec);
		strftime( timestr, sizeof timestr, "%H:%M:%S", &ltime);
		
		printf("%s,%.6d len:%d\n", timestr, header->ts.tv_usec, header->len);
	}
	
	if(res == -1){
		printf("Error reading the packets: %s\n", pcap_geterr(adhandle));
		return -1;
	}
	
    return 0;
}

```

`Examples/misc/basic_dump_ex.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{92849630-6B09-409C-A7AD-E91E682558B1}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/FS %(AdditionalOptions)</AdditionalOptions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/FS %(AdditionalOptions)</AdditionalOptions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/FS %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/FS %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/FS %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/FS %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="basic_dump_ex.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`Examples/misc/misc.h`:

```h
#include <tchar.h>
#include <stdio.h>
BOOL LoadNpcapDlls()
{
    _TCHAR npcap_dir[512];
    UINT len;
    len = GetSystemDirectory(npcap_dir, 480);
    if (!len) {
        fprintf(stderr, "Error in GetSystemDirectory: %x", GetLastError());
        return FALSE;
    }
    _tcscat_s(npcap_dir, 512, _T("\\Npcap"));
    if (SetDllDirectory(npcap_dir) == 0) {
        fprintf(stderr, "Error in SetDllDirectory: %x", GetLastError());
        return FALSE;
    }
    return TRUE;
}


```

`Examples/misc/readfile.c`:

```c
#include <stdio.h>
#include <pcap.h>
#include "misc.h"

#define LINE_LEN 16

void dispatcher_handler(u_char *, const struct pcap_pkthdr *, const u_char *);

int main(int argc, char **argv)
{
pcap_t *fp;
char errbuf[PCAP_ERRBUF_SIZE];
char source[PCAP_BUF_SIZE];

    /* Load Npcap and its functions. */
    if (!LoadNpcapDlls())
    {
        fprintf(stderr, "Couldn't load Npcap\n");
        exit(1);
    }

	if(argc != 2){

		printf("usage: %s filename", argv[0]);
		return -1;

	}

	/* Create the source string according to the new WinPcap syntax */
	if ( pcap_createsrcstr(	source,			// variable that will keep the source string
							PCAP_SRC_FILE,	// we want to open a file
							NULL,			// remote host
							NULL,			// port on the remote host
							argv[1],		// name of the file we want to open
							errbuf			// error buffer
							) != 0)
	{
		fprintf(stderr,"\nError creating a source string\n");
		return -1;
	}
	
	/* Open the capture file */
	if ( (fp= pcap_open(source,			// name of the device
						65536,			// portion of the packet to capture
										// 65536 guarantees that the whole packet will be captured on all the link layers
						 PCAP_OPENFLAG_PROMISCUOUS, 	// promiscuous mode
						 1000,				// read timeout
						 NULL,				// authentication on the remote machine
						 errbuf			// error buffer
						 ) ) == NULL)
	{
		fprintf(stderr,"\nUnable to open the file %s.\n", source);
		return -1;
	}

	// read and dispatch packets until EOF is reached
	pcap_loop(fp, 0, dispatcher_handler, NULL);

	return 0;
}



void dispatcher_handler(u_char *temp1, 
						const struct pcap_pkthdr *header, const u_char *pkt_data)
{
	u_int i=0;

	/*
	 * Unused variable
	 */
	(VOID)temp1;

	/* print pkt timestamp and pkt len */
	printf("%ld:%ld (%ld)\n", header->ts.tv_sec, header->ts.tv_usec, header->len);			
	
	/* Print the packet */
	for (i=1; (i < header->caplen + 1 ) ; i++)
	{
		printf("%.2x ", pkt_data[i-1]);
		if ( (i % LINE_LEN) == 0) printf("\n");
	}
	
	printf("\n\n");		
	
}

```

`Examples/misc/readfile.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{161E7606-F4CD-4A04-AB6B-5837F7818EE1}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/FS %(AdditionalOptions)</AdditionalOptions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/FS %(AdditionalOptions)</AdditionalOptions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/FS %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/FS %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/FS %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/FS %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="readfile.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`Examples/misc/readfile_ex.c`:

```c
#include <stdio.h>
#include <pcap.h>
#include "misc.h"

#define LINE_LEN 16

int main(int argc, char **argv)
{
pcap_t *fp;
char errbuf[PCAP_ERRBUF_SIZE];
char source[PCAP_BUF_SIZE];
struct pcap_pkthdr *header;
const u_char *pkt_data;
u_int i=0;
int res;

    /* Load Npcap and its functions. */
    if (!LoadNpcapDlls())
    {
        fprintf(stderr, "Couldn't load Npcap\n");
        exit(1);
    }

	if(argc != 2)
	{
		printf("usage: %s filename", argv[0]);
		return -1;
	}
	
	/* Create the source string according to the new WinPcap syntax */
	if ( pcap_createsrcstr(	source,			// variable that will keep the source string
							PCAP_SRC_FILE,	// we want to open a file
							NULL,			// remote host
							NULL,			// port on the remote host
							argv[1],		// name of the file we want to open
							errbuf			// error buffer
							) != 0)
	{
		fprintf(stderr,"\nError creating a source string\n");
		return -1;
	}
	
	/* Open the capture file */
	if ( (fp= pcap_open(source,			// name of the device
						65536,			// portion of the packet to capture
										// 65536 guarantees that the whole packet will be captured on all the link layers
						 PCAP_OPENFLAG_PROMISCUOUS, 	// promiscuous mode
						 1000,				// read timeout
						 NULL,				// authentication on the remote machine
						 errbuf			// error buffer
						 ) ) == NULL)
	{
		fprintf(stderr,"\nUnable to open the file %s.\n", source);
		return -1;
	}
	
	/* Retrieve the packets from the file */
	while((res = pcap_next_ex( fp, &header, &pkt_data)) >= 0)
	{
		/* print pkt timestamp and pkt len */
		printf("%ld:%ld (%ld)\n", header->ts.tv_sec, header->ts.tv_usec, header->len);			
		
		/* Print the packet */
		for (i=1; (i < header->caplen + 1 ) ; i++)
		{
			printf("%.2x ", pkt_data[i-1]);
			if ( (i % LINE_LEN) == 0) printf("\n");
		}
		
		printf("\n\n");		
	}
	
	
	if (res == -1)
	{
		printf("Error reading the packets: %s\n", pcap_geterr(fp));
	}
	
	return 0;
}


```

`Examples/misc/readfile_ex.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{3071DFB6-68F8-41EF-A56C-0C7A71B6967C}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/FS %(AdditionalOptions)</AdditionalOptions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/FS %(AdditionalOptions)</AdditionalOptions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/FS %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/FS %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/FS %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/FS %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="readfile_ex.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`Examples/misc/savedump.c`:

```c
#include <pcap.h>
#include "misc.h"

/* prototype of the packet handler */
void packet_handler(u_char *param, const struct pcap_pkthdr *header, const u_char *pkt_data);

int main(int argc, char **argv)
{
pcap_if_t *alldevs;
pcap_if_t *d;
int inum;
int i=0;
pcap_t *adhandle;
char errbuf[PCAP_ERRBUF_SIZE];
pcap_dumper_t *dumpfile;

    /* Load Npcap and its functions. */
    if (!LoadNpcapDlls())
    {
        fprintf(stderr, "Couldn't load Npcap\n");
        exit(1);
    }

    /* Check command line */
	if(argc != 2)
	{
        printf("usage: %s filename", argv[0]);
        return -1;
    }
    
	/* Retrieve the device list on the local machine */
	if (pcap_findalldevs_ex(PCAP_SRC_IF_STRING, NULL, &alldevs, errbuf) == -1)
	{
		fprintf(stderr,"Error in pcap_findalldevs: %s\n", errbuf);
		exit(1);
	}
    
    /* Print the list */
    for(d=alldevs; d; d=d->next)
    {
        printf("%d. %s", ++i, d->name);
        if (d->description)
            printf(" (%s)\n", d->description);
        else
            printf(" (No description available)\n");
    }

    if(i==0)
    {
        printf("\nNo interfaces found! Make sure Npcap is installed.\n");
        return -1;
    }
    
    printf("Enter the interface number (1-%d):",i);
    scanf_s("%d", &inum);
    
    if(inum < 1 || inum > i)
    {
        printf("\nInterface number out of range.\n");
        /* Free the device list */
        pcap_freealldevs(alldevs);
        return -1;
    }
		
	/* Jump to the selected adapter */
    for(d=alldevs, i=0; i< inum-1 ;d=d->next, i++);
    
    
	/* Open the device */
	if ( (adhandle= pcap_open(d->name,			// name of the device
							  65536,			// portion of the packet to capture
												// 65536 guarantees that the whole packet will be captured on all the link layers
							  PCAP_OPENFLAG_PROMISCUOUS, 	// promiscuous mode
							  1000,				// read timeout
							  NULL,				// authentication on the remote machine
							  errbuf			// error buffer
							  ) ) == NULL)
	{
		fprintf(stderr,"\nUnable to open the adapter. %s is not supported by Npcap\n", d->name);
		/* Free the device list */
		pcap_freealldevs(alldevs);
		return -1;
	}

	/* Open the dump file */
	dumpfile = pcap_dump_open(adhandle, argv[1]);

	if(dumpfile==NULL)
	{
		fprintf(stderr,"\nError opening output file\n");
		return -1;
	}
    
    printf("\nlistening on %s... Press Ctrl+C to stop...\n", d->description);
	
    /* At this point, we no longer need the device list. Free it */
    pcap_freealldevs(alldevs);
    
    /* start the capture */
    pcap_loop(adhandle, 0, packet_handler, (unsigned char *)dumpfile);

    return 0;
}

/* Callback function invoked by libpcap for every incoming packet */
void packet_handler(u_char *dumpfile, const struct pcap_pkthdr *header, const u_char *pkt_data)
{
	/* save the packet on the dump file */
	pcap_dump(dumpfile, header, pkt_data);
}

```

`Examples/misc/savedump.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{1B8791CB-DD15-46BF-B0A2-879892085538}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/FS %(AdditionalOptions)</AdditionalOptions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/FS %(AdditionalOptions)</AdditionalOptions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/FS %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/FS %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/FS %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/FS %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="savedump.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`Examples/misc/sendpack.c`:

```c
#include <stdlib.h>
#include <stdio.h>

#include <pcap.h>
#include "misc.h"


void main(int argc, char **argv)
{
pcap_t *fp;
char errbuf[PCAP_ERRBUF_SIZE];
u_char packet[100];
int i;

    /* Load Npcap and its functions. */
    if (!LoadNpcapDlls())
    {
        fprintf(stderr, "Couldn't load Npcap\n");
        exit(1);
    }

	/* Check the validity of the command line */
	if (argc != 2)
	{
		printf("usage: %s interface (e.g. 'rpcap://eth0')", argv[0]);
		return;
	}
    
	/* Open the output device */
	if ( (fp= pcap_open(argv[1],			// name of the device
						100,				// portion of the packet to capture (only the first 100 bytes)
						PCAP_OPENFLAG_PROMISCUOUS, 	// promiscuous mode
						1000,				// read timeout
						NULL,				// authentication on the remote machine
						errbuf				// error buffer
						) ) == NULL)
	{
		fprintf(stderr,"\nUnable to open the adapter. %s is not supported by Npcap\n", argv[1]);
		return;
	}

	i = 0;
	switch(pcap_datalink(fp))
	{
		case DLT_NULL:
			// Pretend IPv4
			packet[i++] = 2;
			packet[i++] = 0;
			packet[i++] = 0;
			packet[i++] = 0;
			break;
		case DLT_EN10MB:
			/* Supposing to be on ethernet, set mac destination to 1:1:1:1:1:1 */
			while (i < 6)
				packet[i++]=1;

			/* set mac source to 2:2:2:2:2:2 */
			while (i < 12)
				packet[i++]=2;
			break;
		default:
			fprintf(stderr, "\nError, unknown data-link type %u\n", pcap_datalink(fp));
			return 4;
	}
	
	/* Fill the rest of the packet */
	for(;i<100;i++)
	{
		packet[i]=(u_char)i;
	}

	/* Send down the packet */
	if (pcap_sendpacket(fp, packet, 100 /* size */) != 0)
	{
		fprintf(stderr,"\nError sending the packet: %s\n", pcap_geterr(fp));
		return;
	}

	return;
}

```

`Examples/misc/sendpack.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{1C376689-5F61-48E7-AE83-0DED9EE9E458}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/FS %(AdditionalOptions)</AdditionalOptions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/FS %(AdditionalOptions)</AdditionalOptions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/FS %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/FS %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/FS %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/FS %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="sendpack.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`Examples/pcap_filter/pcap_filter.c`:

```c
/*
 * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)
 * Copyright (c) 2005 - 2006 CACE Technologies, Davis (California)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Politecnico di Torino, CACE Technologies 
 * nor the names of its contributors may be used to endorse or promote 
 * products derived from this software without specific prior written 
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */


#include <stdlib.h>
#include <stdio.h>

#include <pcap.h>

#define MAX_PRINT 80
#define MAX_LINE 16

#ifdef _WIN32
#include <tchar.h>
BOOL LoadNpcapDlls()
{
	TCHAR npcap_dir[512];
	UINT len;
	len = GetSystemDirectory(npcap_dir, 480);
	if (!len) {
		fprintf(stderr, "Error in GetSystemDirectory: %x", GetLastError());
		return FALSE;
	}
	_tcscat_s(npcap_dir, 512, TEXT("\\Npcap"));
	if (SetDllDirectory(npcap_dir) == 0) {
		fprintf(stderr, "Error in SetDllDirectory: %x", GetLastError());
		return FALSE;
	}
	return TRUE;
}
#endif

void usage();


void main(int argc, char **argv)
{
pcap_t *fp;
char errbuf[PCAP_ERRBUF_SIZE] = {0};
char *source=NULL;
char *ofilename=NULL;
char *filter=NULL;
int i;
pcap_dumper_t *dumpfile;
struct bpf_program fcode;
bpf_u_int32 NetMask;
int res;
struct pcap_pkthdr *header;
const u_char *pkt_data;

#ifdef _WIN32
	/* Load Npcap and its functions. */
	if (!LoadNpcapDlls())
	{
		fprintf(stderr, "Couldn't load Npcap\n");
		exit(1);
	}
#endif

	if (argc == 1)
	{
		usage();
		return;
	}

	for(i=1;i < argc; i+= 2)
	{

		switch (argv[i] [1])
		{
			case 's':
			{
				source=argv[i+1];
			};
			break;

			case 'o':
			{
				ofilename=argv[i+1];
			};
			break;

			case 'f':
			{
				filter=argv[i+1];
			};
			break;
		}
	}

	// open a capture from the network
	if (source != NULL)
	{
		if ( (fp= pcap_open(source,
							1514 /*snaplen*/,
							PCAP_OPENFLAG_PROMISCUOUS /*flags*/,
							20 /*read timeout*/,
							NULL /* remote authentication */,
							errbuf)
							) == NULL)
		{
			fprintf(stderr,"\nUnable to open the adapter: %s\n", errbuf);
			return;
		}
	}

	else usage();

	if (filter != NULL)
	{
		// We should loop through the adapters returned by the pcap_findalldevs_ex()
		// in order to locate the correct one.
		//
		// Let's do things simpler: we suppose to be in a C class network ;-)
		NetMask=0xffffff;

		//compile the filter
		if((res = pcap_compile(fp, &fcode, filter, 1, NetMask)) < 0)
		{
			fprintf(stderr,"\nError compiling filter: %s\n", pcap_statustostr(res));
			pcap_close(fp);
			return;
		}

		//set the filter
		if((res = pcap_setfilter(fp, &fcode))<0)
		{
			fprintf(stderr,"\nError setting the filter: %s\n", pcap_statustostr(res));
			pcap_close(fp);
			return;
		}

	}

	//open the dump file
	if (ofilename != NULL)
	{
		dumpfile= pcap_dump_open(fp, ofilename);

		if (dumpfile == NULL)
		{
			fprintf(stderr,"\nError opening output file: %s\n", pcap_geterr(fp));
			pcap_close(fp);
			return;
		}
	}
	else usage();

	//start the capture
 	while((res = pcap_next_ex( fp, &header, &pkt_data)) >= 0)
	{

		if(res == 0)
		/* Timeout elapsed */
		continue;

		//save the packet on the dump file
		pcap_dump((unsigned char *) dumpfile, header, pkt_data);

	}
}


void usage()
{

	printf("\npf - Generic Packet Filter.\n");
	printf("\nUsage:\npf -s source -o output_file_name [-f filter_string]\n\n");
	exit(0);
}

```

`Examples/pcap_filter/pcap_filter.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{B9F68F6F-22AE-47A2-A3A3-1212831AF9FF}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="pcap_filter.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`Examples/pcap_fopen/pcap_fopen.cpp`:

```cpp
/*
 * Copyright (c) 2008 CACE Technologies, Davis (California)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of CACE Technologies nor the names of its 
 * contributors may be used to endorse or promote products derived from 
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * This sample was contributed by 
 * Marcin Okraszewski (Marcin.OkraszewskiATpl.compuware.com)
 *
 */

#include <tchar.h>
#include <pcap.h>
#include <stdio.h>

BOOL LoadNpcapDlls()
{
    _TCHAR npcap_dir[512];
    UINT len;
    len = GetSystemDirectory(npcap_dir, 480);
    if (!len) {
        fprintf(stderr, "Error in GetSystemDirectory: %x", GetLastError());
        return FALSE;
    }
    _tcscat_s(npcap_dir, 512, _T("\\Npcap"));
    if (SetDllDirectory(npcap_dir) == 0) {
        fprintf(stderr, "Error in SetDllDirectory: %x", GetLastError());
        return FALSE;
    }
    return TRUE;
}

/** Prints packet timestaps regardless of format*/
int _tmain(int argc, _TCHAR* argv[])
{
    char errbuf[PCAP_ERRBUF_SIZE];
    _TCHAR cmd[1024];
    _TCHAR tshark_path[MAX_PATH];
    _TCHAR file_path[MAX_PATH];

    /* Load Npcap and its functions. */
    if (!LoadNpcapDlls())
    {
        fprintf(stderr, "Couldn't load Npcap\n");
        exit(1);
    }

    if ( argc != 3 ) {
        _tprintf(_T("Prints packet timestaps regardless of format.\n"));
        _tprintf(_T("Usage:\n\t%s <tshark path> <trace file>\n"), argv[0]);
        return 1;
    }

    // conversion to short path name in case there are spaces
    if ( ! GetShortPathName(argv[1], tshark_path, MAX_PATH) || 
         ! GetShortPathName(argv[2], file_path, MAX_PATH) )
    {
        _tprintf(_T("Failed to convert paths to short form."));
        return 1;
    }

    // create tshark command, which will make the trace conversion and print in libpcap format to stdout
    if ( _stprintf_s(cmd, 1024, _T("%s -r %s -w - -F libpcap"), tshark_path, file_path) < 0 ) {
        _tprintf(_T("Failed to create command\n"));
        return 1;
    }

    // start tshark
    FILE *tshark_out = _tpopen(cmd, _T("rb"));
    if ( tshark_out == NULL ) {
        strerror_s(errbuf, PCAP_ERRBUF_SIZE, errno);
        printf("Failed run tshark: %s\n", errbuf);
        _tprintf(_T("Command: %s"), cmd);
        return 1;
    }

    // open stdout from tshark
    pcap_t *pcap = pcap_fopen_offline(tshark_out, errbuf);
    if ( pcap == NULL ) {
        printf("Error opening stream from tshark: %s\n", errbuf);
        return 1;
    }

    // print information about every packet int trace
    struct pcap_pkthdr hdr;
    while ( pcap_next(pcap, &hdr) ) {
        printf("packet: ts: %u.%06u,  len: %4u,  caplen: %4u\n", hdr.ts.tv_sec, hdr.ts.tv_usec, hdr.len, hdr.caplen);
    }

    // clean up
    pcap_close(pcap);
    _pclose(tshark_out);
    return 0;
}


```

`Examples/pcap_fopen/pcap_fopen.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{DD317CB5-6337-498F-A560-553B5558E133}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_UNICODE;UNICODE;_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_UNICODE;UNICODE;NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_UNICODE;UNICODE;_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_UNICODE;UNICODE;_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_UNICODE;UNICODE;NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_UNICODE;UNICODE;NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="pcap_fopen.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`Examples/pktdump_ex/pktdump_ex.c`:

```c
/*
 * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)
 * Copyright (c) 2005 - 2006 CACE Technologies, Davis (California)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Politecnico di Torino, CACE Technologies 
 * nor the names of its contributors may be used to endorse or promote 
 * products derived from this software without specific prior written 
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */


#include <stdlib.h>
#include <stdio.h>

//
// NOTE: remember to include WPCAP and HAVE_REMOTE among your
// preprocessor definitions.
//

#include <pcap.h>

#define LINE_LEN 16

#include <tchar.h>
BOOL LoadNpcapDlls()
{
    _TCHAR npcap_dir[512];
    UINT len;
    len = GetSystemDirectory(npcap_dir, 480);
    if (!len) {
        fprintf(stderr, "Error in GetSystemDirectory: %x", GetLastError());
        return FALSE;
    }
    _tcscat_s(npcap_dir, 512, _T("\\Npcap"));
    if (SetDllDirectory(npcap_dir) == 0) {
        fprintf(stderr, "Error in SetDllDirectory: %x", GetLastError());
        return FALSE;
    }
    return TRUE;
}

int main(int argc, char **argv)
{	
pcap_if_t *alldevs, *d;
pcap_t *fp;
u_int inum, i=0;
char errbuf[PCAP_ERRBUF_SIZE];
int res;
struct pcap_pkthdr *header;
const u_char *pkt_data;

    /* Load Npcap and its functions. */
    if (!LoadNpcapDlls())
    {
        fprintf(stderr, "Couldn't load Npcap\n");
        exit(1);
    }

	printf("pktdump_ex: prints the packets of the network using Npcap.\n");
	printf("   Usage: pktdump_ex [-s source]\n\n"
		   "   Examples:\n"
		   "      pktdump_ex -s file://c:/temp/file.acp\n"
		   "      pktdump_ex -s rpcap://\\Device\\NPF_{C8736017-F3C3-4373-94AC-9A34B7DAD998}\n\n");

	if(argc < 3)
	{

		printf("\nNo adapter selected: printing the device list:\n");
		/* The user didn't provide a packet source: Retrieve the local device list */
		if (pcap_findalldevs_ex(PCAP_SRC_IF_STRING, NULL, &alldevs, errbuf) == -1)
		{
			fprintf(stderr,"Error in pcap_findalldevs_ex: %s\n", errbuf);
			return -1;
		}
		
		/* Print the list */
		for(d=alldevs; d; d=d->next)
		{
			printf("%d. %s\n    ", ++i, d->name);

			if (d->description)
				printf(" (%s)\n", d->description);
			else
				printf(" (No description available)\n");
		}
		
		if (i==0)
		{
			fprintf(stderr,"No interfaces found! Exiting.\n");
			return -1;
		}
		
		printf("Enter the interface number (1-%d):",i);
		scanf_s("%d", &inum);
		
		if (inum < 1 || inum > i)
		{
			printf("\nInterface number out of range.\n");

			/* Free the device list */
			pcap_freealldevs(alldevs);
			return -1;
		}
		
		/* Jump to the selected adapter */
		for (d=alldevs, i=0; i< inum-1 ;d=d->next, i++);
		
		/* Open the device */
		if ( (fp= pcap_open(d->name,
							100 /*snaplen*/,
							PCAP_OPENFLAG_PROMISCUOUS /*flags*/,
							20 /*read timeout*/,
							NULL /* remote authentication */,
							errbuf)
							) == NULL)
		{
			fprintf(stderr,"\nError opening adapter\n");
			return -1;
		}
	}
	else 
	{
		// Do not check for the switch type ('-s')
		if ( (fp= pcap_open(argv[2],
							100 /*snaplen*/,
							PCAP_OPENFLAG_PROMISCUOUS /*flags*/,
							20 /*read timeout*/,
							NULL /* remote authentication */,
							errbuf)
							) == NULL)
		{
			fprintf(stderr,"\nError opening source: %s\n", errbuf);
			return -1;
		}
	}

	/* Read the packets */
	while((res = pcap_next_ex( fp, &header, &pkt_data)) >= 0)
	{

		if(res == 0)
			/* Timeout elapsed */
			continue;

		/* print pkt timestamp and pkt len */
		printf("%ld:%ld (%ld)\n", header->ts.tv_sec, header->ts.tv_usec, header->len);			
		
		/* Print the packet */
		for (i=1; (i < header->caplen + 1 ) ; i++)
		{
			printf("%.2x ", pkt_data[i-1]);
			if ( (i % LINE_LEN) == 0) printf("\n");
		}
		
		printf("\n\n");		
	}

	if(res == -1)
	{
		fprintf(stderr, "Error reading the packets: %s\n", pcap_geterr(fp));
		return -1;
	}

	return 0;
}

```

`Examples/pktdump_ex/pktdump_ex.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{3D62DEB4-3536-44AE-8E4B-AD6DFF1B795E}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="pktdump_ex.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`Examples/sendcap/sendcap.c`:

```c
/*
 * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)
 * Copyright (c) 2005 - 2006 CACE Technologies, Davis (California)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Politecnico di Torino, CACE Technologies 
 * nor the names of its contributors may be used to endorse or promote 
 * products derived from this software without specific prior written 
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <stdlib.h>
#include <stdio.h>

#include <pcap.h>
#include <time.h>

#ifdef _WIN32
#include <tchar.h>
BOOL LoadNpcapDlls()
{
	TCHAR npcap_dir[512];
	UINT len;
	len = GetSystemDirectory(npcap_dir, 480);
	if (!len) {
		fprintf(stderr, "Error in GetSystemDirectory: %x", GetLastError());
		return FALSE;
	}
	_tcscat_s(npcap_dir, 512, TEXT("\\Npcap"));
	if (SetDllDirectory(npcap_dir) == 0) {
		fprintf(stderr, "Error in SetDllDirectory: %x", GetLastError());
		return FALSE;
	}
	return TRUE;
}
#endif

void usage();

int main(int argc, char **argv)
{
	pcap_t *indesc,*outdesc;
	char errbuf[PCAP_ERRBUF_SIZE];
	char source[PCAP_BUF_SIZE];
	FILE *capfile;
	int caplen, sync;
	u_int res;
	pcap_send_queue *squeue;
	struct pcap_pkthdr *pktheader;
	u_char *pktdata;
	float cpu_time;
	u_int npacks = 0;
	errno_t fopen_error;
	int rval = 0;

#ifdef _WIN32
	/* Load Npcap and its functions. */
	if (!LoadNpcapDlls())
	{
		fprintf(stderr, "Couldn't load Npcap\n");
		exit(1);
	}
#endif

	/* Check the validity of the command line */
	if (argc <= 2 || argc >= 5)
	{
		usage();
		return 1;
	}
		
	/* Retrieve the length of the capture file */
	fopen_error = fopen_s(&capfile, argv[1],"rb");
	if(fopen_error != 0){
		printf("Error opening the file, errno %d.\n", fopen_error);
		return 1;
	}
	
	fseek(capfile , 0, SEEK_END);
	caplen= ftell(capfile)- sizeof(struct pcap_file_header);
	fclose(capfile);
			
	/* Chek if the timestamps must be respected */
	if(argc == 4 && argv[3][0] == 's')
		sync = TRUE;
	else
		sync = FALSE;

	/* Open the capture */
	/* Create the source string according to the new WinPcap syntax */
	if ( pcap_createsrcstr(	source,			// variable that will keep the source string
							PCAP_SRC_FILE,	// we want to open a file
							NULL,			// remote host
							NULL,			// port on the remote host
							argv[1],		// name of the file we want to open
							errbuf			// error buffer
							) != 0)
	{
		fprintf(stderr,"\nError creating a source string\n");
		return 1;
	}
	
	/* Open the capture file */
	if ( (indesc= pcap_open(source, 65536, PCAP_OPENFLAG_PROMISCUOUS, 1000, NULL, errbuf) ) == NULL)
	{
		fprintf(stderr,"\nUnable to open the file %s: %s.\n", source, errbuf);
		return 1;
	}

	/* Open the output adapter */
	if ( (outdesc= pcap_open(argv[2], 100, PCAP_OPENFLAG_PROMISCUOUS, 1000, NULL, errbuf) ) == NULL)
	{
		fprintf(stderr,"\nUnable to open adapter %s: %s.\n", argv[2], errbuf);
		return 1;
	}

	/* Check the MAC type */
	if (pcap_datalink(indesc) != pcap_datalink(outdesc))
	{
		printf("Warning: the datalink of the capture differs from the one of the selected interface.\n");
		printf("Press a key to continue, or CTRL+C to stop.\n");
		getchar();
	}

	/* Allocate a send queue */
	squeue = pcap_sendqueue_alloc(caplen);

	/* Fill the queue with the packets from the file */
	while ((res = pcap_next_ex( indesc, &pktheader, &pktdata)) == 1)
	{
		if (pcap_sendqueue_queue(squeue, pktheader, pktdata) == -1)
		{
			printf("Warning: packet buffer too small, not all the packets will be sent.\n");
			break;
		}

		npacks++;
	}

	if (res == -1)
	{
		printf("Corrupted input file.\n");
		pcap_sendqueue_destroy(squeue);
		return 1;
	}

	/* Transmit the queue */
	
	cpu_time = (float)clock ();

	if ((res = pcap_sendqueue_transmit(outdesc, squeue, sync)) < squeue->len)
	{
		printf("An error occurred sending the packets: %s. Only %d bytes were sent\n", pcap_geterr(outdesc), res);
		rval = 1;
	}
	else
	{
		cpu_time = (clock() - cpu_time)/CLOCKS_PER_SEC;

		printf ("\n\nElapsed time: %5.3f\n", cpu_time);
		printf ("\nTotal packets generated = %d", npacks);
		printf ("\nAverage packets per second = %d", (int)((double)npacks/cpu_time));
		printf ("\n");
	}

	/* free the send queue */
	pcap_sendqueue_destroy(squeue);

	/* Close the input file */
	pcap_close(indesc);

	/* 
	 * lose the output adapter 
	 * IMPORTANT: remember to close the adapter, otherwise there will be no guarantee that all the 
	 * packets will be sent!
	 */
	pcap_close(outdesc);


	return rval;
}


void usage()
{
	
	printf("\nSendcap, sends a libpcap/tcpdump capture file to the net. Copyright (C) 2002 Loris Degioanni.\n");
	printf("\nUsage:\n");
	printf("\t sendcap file_name adapter [s]\n");
	printf("\nParameters:\n");
	printf("\nfile_name: the name of the dump file that will be sent to the network\n");
	printf("\nadapter: the device to use. Use \"WinDump -D\" for a list of valid devices\n");
	printf("\ns: if present, forces the packets to be sent synchronously, i.e. respecting the timestamps in the dump file. This option will work only under Windows NTx.\n\n");

	exit(0);
}

```

`Examples/sendcap/sendcap.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{D6B93A03-446A-4B13-87B8-9AA752A5CC8C}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="sendcap.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`Examples/sendcap/sendcap.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="sendcap.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`Examples/smp_1/smp_1.c`:

```c
/*
 * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)
 * Copyright (c) 2005 - 2006 CACE Technologies, Davis (California)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Politecnico di Torino, CACE Technologies 
 * nor the names of its contributors may be used to endorse or promote 
 * products derived from this software without specific prior written 
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */


#include <stdlib.h>
#include <stdio.h>
#include <conio.h>

#include <pcap.h>

#include <tchar.h>
BOOL LoadNpcapDlls()
{
    _TCHAR npcap_dir[512];
    UINT len;
    len = GetSystemDirectory(npcap_dir, 480);
    if (!len) {
        fprintf(stderr, "Error in GetSystemDirectory: %x", GetLastError());
        return FALSE;
    }
    _tcscat_s(npcap_dir, 512, _T("\\Npcap"));
    if (SetDllDirectory(npcap_dir) == 0) {
        fprintf(stderr, "Error in SetDllDirectory: %x", GetLastError());
        return FALSE;
    }
    return TRUE;
}


int main()
{	
pcap_if_t *alldevs, *d;
pcap_t *fp;
u_int inum, i=0;
char errbuf[PCAP_ERRBUF_SIZE];
int res;
struct pcap_pkthdr *header;
const u_char *pkt_data;
struct pcap_pkthdr old;

    /* Load Npcap and its functions. */
    if (!LoadNpcapDlls())
    {
        fprintf(stderr, "Couldn't load Npcap\n");
        exit(1);
    }

	printf("SMP_1\n");
	printf("\nThis program tests the Npcap kernel driver on SMP machines.\n");
	printf("The program tests that timestamps on the captured packets are consistent,\n");
	printf("and that the caplen is equal to the packet length.\n");
	printf("If there is an error, it will print out a message saying \"Inconsistent XXX\"\n");

	if (pcap_findalldevs_ex(PCAP_SRC_IF_STRING, NULL, &alldevs, errbuf) == -1)
	{
		fprintf(stderr,"Error in pcap_findalldevs: %s\n", errbuf);
		exit(1);
	}
		
	/* Print the list */
	for(d=alldevs; d; d=d->next)
	{
		printf("%d. %s", ++i, d->name);
		if (d->description)
			printf(" (%s)\n", d->description);
		else
			printf(" (No description available)\n");
	}
		
	if(i==0)
	{
		printf("\nNo interfaces found! Make sure Npcap is installed.\n");
		return -1;
	}
		
	printf("Enter the interface number (1-%d):",i);
	scanf_s("%d", &inum);
		
	if(inum < 1 || inum > i)
	{
		printf("\nInterface number out of range.\n");
		/* Free the device list */
		pcap_freealldevs(alldevs);
		return -1;
	}
		
	/* Jump to the selected adapter */
	for(d=alldevs, i=0; i< inum-1 ;d=d->next, i++);
	
	/* Open the device */
	if ( (fp= pcap_open(d->name, 65536, PCAP_OPENFLAG_PROMISCUOUS, 1000, NULL, errbuf) ) == NULL)
	{
		fprintf(stderr,"\nUnable to open the adapter. %s is not supported by Npcap\n", d->name);
		/* Free the device list */
		pcap_freealldevs(alldevs);
		return -1;
	}

	old.ts.tv_sec=0;
	old.ts.tv_usec=0;


	/* Read the packets */
	while((res = pcap_next_ex( fp, &header, &pkt_data)) >= 0){

		if(res == 0)
			continue;

		//check that caplen is equal to packet length
		if (header->caplen!=header->len)
			printf("Inconsistent header: CapLen %d\t Len %d\n",header->caplen,header->len);

		//check that timestamps always grow
		if ( old.ts.tv_sec > header->ts.tv_sec || (old.ts.tv_sec == header->ts.tv_sec  && old.ts.tv_usec > header->ts.tv_usec))
			printf("Inconsistent Timestamps! Old was %d.%.06d - New is %d.%.06d\n",old.ts.tv_sec,old.ts.tv_usec, header->ts.tv_sec,header->ts.tv_usec);

		old=*header;

	}

	if(res == -1){
		printf("Error reading the packets: %s\n", pcap_geterr(fp));
		return -1;
	}

	_getch();

	return 0;
}

```

`Examples/smp_1/smp_1.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{21F49E7F-6C58-4DA5-ABE5-A9DFB6165C83}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="smp_1.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`Examples/tcptop/tcptop.c`:

```c
/*
 * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)
 * Copyright (c) 2005 - 2006 CACE Technologies, Davis (California)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Politecnico di Torino, CACE Technologies 
 * nor the names of its contributors may be used to endorse or promote 
 * products derived from this software without specific prior written 
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <stdlib.h>
#include <stdio.h>

#include <pcap.h>
#include <time.h>

#include <tchar.h>
BOOL LoadNpcapDlls()
{
    _TCHAR npcap_dir[512];
    UINT len;
    len = GetSystemDirectory(npcap_dir, 480);
    if (!len) {
        fprintf(stderr, "Error in GetSystemDirectory: %x", GetLastError());
        return FALSE;
    }
    _tcscat_s(npcap_dir, 512, _T("\\Npcap"));
    if (SetDllDirectory(npcap_dir) == 0) {
        fprintf(stderr, "Error in SetDllDirectory: %x", GetLastError());
        return FALSE;
    }
    return TRUE;
}

void usage();

void dispatcher_handler(u_char *, const struct pcap_pkthdr *, const u_char *);


void main(int argc, char **argv)
{
pcap_t *fp;
char errbuf[PCAP_ERRBUF_SIZE];
struct timeval st_ts;
u_int netmask;
struct bpf_program fcode;
  
    /* Load Npcap and its functions. */
    if (!LoadNpcapDlls())
    {
        fprintf(stderr, "Couldn't load Npcap\n");
        exit(1);
    }

	/* Check the validity of the command line */
	if (argc != 2)
	{
		usage();
		return;
	}
		
	/* Open the output adapter */
	if ( (fp= pcap_open(argv[1], 100, PCAP_OPENFLAG_PROMISCUOUS, 1000, NULL, errbuf) ) == NULL)
	{
		fprintf(stderr,"\nUnable to open adapter %s.\n", errbuf);
		return;
	}

    /* Don't care about netmask, it won't be used for this filter */
    netmask=0xffffff; 

    //compile the filter
    if (pcap_compile(fp, &fcode, "tcp", 1, netmask) <0 )
	{
        fprintf(stderr,"\nUnable to compile the packet filter. Check the syntax.\n");
        /* Free the device list */
        return;
    }
    
    //set the filter
    if (pcap_setfilter(fp, &fcode)<0)
	{
        fprintf(stderr,"\nError setting the filter.\n");
		pcap_close(fp);
        /* Free the device list */
        return;
    }

	/* Put the interface in statstics mode */
	if (pcap_setmode(fp, MODE_STAT)<0)
	{
        fprintf(stderr,"\nError setting the mode.\n");
		pcap_close(fp);
        /* Free the device list */
        return;
    }


	printf("TCP traffic summary:\n");

	/* Start the main loop */
	pcap_loop(fp, 0, dispatcher_handler, (PUCHAR)&st_ts);

	pcap_close(fp);
	return;
}

void dispatcher_handler(u_char *state, const struct pcap_pkthdr *header, const u_char *pkt_data)
{
	struct timeval *old_ts = (struct timeval *)state;
	u_int delay;
	LARGE_INTEGER Bps,Pps;
	struct tm ltime;
	char timestr[16];
	time_t local_tv_sec;

	/* Calculate the delay in microseconds from the last sample. */
	/* This value is obtained from the timestamp that the associated with the sample. */
	delay=(header->ts.tv_sec - old_ts->tv_sec) * 1000000 - old_ts->tv_usec + header->ts.tv_usec;
	/* Get the number of Bits per second */
	Bps.QuadPart=(((*(LONGLONG*)(pkt_data + 8)) * 8 * 1000000) / (delay));
	/*                                            ^      ^
                                                  |      |
                                                  |      | 
                                                  |      |
                         converts bytes in bits --       |
                                                         |
                    delay is expressed in microseconds --
	*/

	/* Get the number of Packets per second */
	Pps.QuadPart=(((*(LONGLONG*)(pkt_data)) * 1000000) / (delay));

	/* Convert the timestamp to readable format */
	local_tv_sec = header->ts.tv_sec;
	localtime_s(&ltime, &local_tv_sec);
	strftime( timestr, sizeof timestr, "%H:%M:%S", &ltime);

	/* Print timestamp*/
	printf("%s ", timestr);

	/* Print the samples */
	printf("BPS=%I64u ", Bps.QuadPart);
	printf("PPS=%I64u\n", Pps.QuadPart);

	//store current timestamp
	old_ts->tv_sec=header->ts.tv_sec;
	old_ts->tv_usec=header->ts.tv_usec;
}


void usage()
{
	
	printf("\nShows the TCP traffic load, in bits per second and packets per second.\nCopyright (C) 2002 Loris Degioanni.\n");
	printf("\nUsage:\n");
	printf("\t tcptop adapter\n");
	printf("\t You can use \"WinDump -D\" if you don't know the name of your adapters.\n");

	exit(0);
}

```

`Examples/tcptop/tcptop.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{B671D5DF-3A80-4A21-BC01-79E3FB73D372}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <AdditionalDependencies>wpcap.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Link>
      <DelayLoadDLLs>wpcap.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>C:\npcap-sdk\Lib\ARM64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <AdditionalIncludeDirectories>C:\npcap-sdk\Include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;HAVE_REMOTE;WPCAP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="tcptop.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`LICENSE`:

```

NPCAP COPYRIGHT / END USER LICENSE AGREEMENT

Npcap (https://npcap.com) is a Windows packet sniffing driver and
library and is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap
Project").  All rights reserved.

Even though Npcap source code is publicly available for review, it is
not open source software and may not be redistributed or used in other
software without special permission from the Nmap Project.  The
standard (free) version is usually limited to installation on five
systems. We fund the Npcap project by selling two types of commercial
licenses to a special Npcap OEM edition:

1) The Npcap OEM Redistribution License allows companies distribute
Npcap OEM within their products. Licensees generally use the Npcap OEM
silent installer, ensuring a seamless experience for end
users. Licensees may choose between a perpetual unlimited license or
a quarterly term license, along with options for commercial support and
updates. Prices and details: https://npcap.com/oem/redist.html

2) The Npcap OEM Internal-Use License is for organizations that wish
to use Npcap OEM internally, without redistribution outside their
organization. This allows them to bypass the 5-system usage cap of the
Npcap free edition. It includes commercial support and update options,
and provides the extra Npcap OEM features such as the silent installer
for automated deployment. Prices and details:
https://npcap.com/oem/internal.html

Both of these licenses include updates and support as well as a
warranty. Npcap OEM also includes a silent installer for unattended
installation. Further details about Npcap OEM are available from
https://npcap.com/oem/, and you are also welcome to contact us at
sales@nmap.com to ask any questions or set up a license for your
organization.

Free and open source software producers are also welcome to contact us
for redistribution requests. However, we normally recommend that such
authors instead ask your users to download and install Npcap
themselves. It will be free for them if they need 5 or fewer copies.

If the Nmap Project (directly or through one of our commercial
licensing customers) has granted you additional rights to Npcap or
Npcap OEM, those additional rights take precedence where they conflict
with the terms of this license agreement.

Since the Npcap source code is available for download and review,
users sometimes contribute code patches to fix bugs or add new
features.  By sending these changes to the Nmap Project (including
through direct email or our mailing lists or submitting pull requests
through our source code repository), it is understood unless you
specify otherwise that you are offering the Nmap Project the
unlimited, non-exclusive right to reuse, modify, and relicense your
code contribution so that we may (but are not obligated to)
incorporate it into Npcap.  If you wish to specify special license
conditions or restrictions on your contributions, just say so when you
send them.

This copy of Npcap (the "Software") and accompanying documentation is
licensed and not sold. This Software is protected by copyright laws
and treaties, as well as laws and treaties related to other forms of
intellectual property. The Nmap Project owns intellectual property
rights in the Software.  The Licensee's ("you" or "your") license to
download, use, copy, or change the Software is subject to these rights
and to all the terms and conditions of this End User License Agreement
("Agreement").

ACCEPTANCE

By accepting this agreement or by downloading, installing, using, or
copying the Software, or by clicking "I Agree", you agree to be bound
by the terms of this EULA.  If you do not agree to the terms of this
EULA, do not install, use, or copy the Software.

LICENSE GRANT

This Agreement entitles you to install and use five (5) copies of the
Software. In addition, you may make archival copies of the Software
which may only be used for the reinstallation of the Software. This
Agreement does not permit the installation or use of more than 5
copies of the Software, or the installation of the Software on more
than five computer at any given time, on a system that allows shared
used of applications by more than five users, or on any configuration
or system of computers that allows more than five users. A user may
only have one instance of this Agreement active at once.  For example,
downloading the software multiple times, downloading multiple versions
of the software, and/or executing the software installer multiple
times do not grant any additional rights such as using the software on
more machines.

The terms "computer" and "machine" in this license include any
computing device, including software computing instances such as
virtual machines and Docker containers.

Copies of Npcap do not count toward the five copy, five computer, or
five user limitations imposed by this section if they are installed
and used solely in conjunction with any of the following software:

o The Nmap Security Scanner, as distributed from https://nmap.org

o The Wireshark network protocol analyzer, as distributed from
  https://www.wireshark.org/
  
o Microsoft Defender for Identity, as distributed from
  https://www.microsoft.com/en-us/microsoft-365/security/identity-defender

Users wishing to redistribute Npcap or exceed the usage limits imposed
by this free license or benefit from commercial support and features
such as a silent installer should contact sales@nmap.com to obtain an
appropriate commercial license agreement.  More details on our OEM
edition is also available from https://npcap.com/oem/.

DISCLAIMER OF WARRANTIES AND LIMITATION OF LIABILITY

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

RESTRICTIONS ON TRANSFER

Without first obtaining the express written consent of the Nmap
Project, you may not assign your rights and obligations under this
Agreement, or redistribute, encumber, sell, rent, lease, sublicense,
or otherwise transfer your rights to the Software Product.

RESTRICTIONS ON USE

You may not use, copy, or install the Software Product on more than
five computers, or permit the use, copying, or installation of the
Software Product by more than five users or on more than five
computers.

RESTRICTIONS ON COPYING

You may not copy any part of the Software except to the extent that
licensed use inherently demands the creation of a temporary copy
stored in computer memory and not permanently affixed on storage
medium. You may make archival copies as well.

DISCLAIMER OF WARRANTIES AND LIMITATION OF LIABILITY

UNLESS OTHERWISE EXPLICITLY AGREED TO IN WRITING BY THE NMAP PROJECT,
THE NMAP PROJECT MAKES NO OTHER WARRANTIES, EXPRESS OR IMPLIED, IN
FACT OR IN LAW, INCLUDING, BUT NOT LIMITED TO, ANY IMPLIED WARRANTIES
OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE OTHER THAN AS
SET FORTH IN THIS AGREEMENT OR IN THE LIMITED WARRANTY DOCUMENTS
PROVIDED WITH THE SOFTWARE.

The Nmap Project makes no warranty that the Software will meet your
requirements or operate under your specific conditions of use. The
Nmap Project makes no warranty that operation of the Software Product
will be secure, error free, or free from interruption. YOU MUST
DETERMINE WHETHER THE SOFTWARE SUFFICIENTLY MEETS YOUR REQUIREMENTS
FOR SECURITY AND UNINTERRUPTABILITY. YOU BEAR SOLE RESPONSIBILITY AND
ALL LIABILITY FOR ANY LOSS INCURRED DUE TO FAILURE OF THE SOFTWARE TO
MEET YOUR REQUIREMENTS. THE NMAP PROJECT WILL NOT, UNDER ANY
CIRCUMSTANCES, BE RESPONSIBLE OR LIABLE FOR THE LOSS OF DATA ON ANY
COMPUTER OR INFORMATION STORAGE DEVICE.

UNDER NO CIRCUMSTANCES SHALL THE NMAP PROJECT, ITS DIRECTORS,
OFFICERS, EMPLOYEES OR AGENTS BE LIABLE TO YOU OR ANY OTHER PARTY FOR
INDIRECT, CONSEQUENTIAL, SPECIAL, INCIDENTAL, PUNITIVE, OR EXEMPLARY
DAMAGES OF ANY KIND (INCLUDING LOST REVENUES OR PROFITS OR LOSS OF
BUSINESS) RESULTING FROM THIS AGREEMENT, OR FROM THE FURNISHING,
PERFORMANCE, INSTALLATION, OR USE OF THE SOFTWARE, WHETHER DUE TO A
BREACH OF CONTRACT, BREACH OF WARRANTY, OR THE NEGLIGENCE OF THE NMAP
PROJECT OR ANY OTHER PARTY, EVEN IF THE NMAP PROJECT IS ADVISED
BEFOREHAND OF THE POSSIBILITY OF SUCH DAMAGES. TO THE EXTENT THAT THE
APPLICABLE JURISDICTION LIMITS THE NMAP PROJECT'S ABILITY TO DISCLAIM
ANY IMPLIED WARRANTIES, THIS DISCLAIMER SHALL BE EFFECTIVE TO THE
MAXIMUM EXTENT PERMITTED.

LIMITATIONS OF REMEDIES AND DAMAGES

Your remedy for a breach of this Agreement or of any warranty included
in this Agreement is the correction or replacement of the Software or
a refund of the purchase price of the Software, exclusive of any costs
for shipping and handling. Selection of whether to correct or replace
or refund shall be solely at the discretion of the Nmap Project. The
Nmap Project reserves the right to substitute a functionally
equivalent copy of the Software Product as a replacement.

Any claim must be made within the applicable warranty period. All
warranties cover only defects arising under normal use and do not
include malfunctions or failure resulting from misuse, abuse, neglect,
alteration, problems with electrical power, acts of nature, unusual
temperatures or humidity, improper installation, or damage determined
by the Nmap Project to have been caused by you. All limited warranties
on the Software Product are granted only to you and are
non-transferable.

You agree to indemnify and hold the Nmap Project harmless from all
claims, judgments, liabilities, expenses, or costs arising from your
breach of this Agreement and/or acts or omissions.

GOVERNING LAW, JURISDICTION AND COSTS

This Agreement is governed by the laws of the United States of America
and Deleware State, without regard to Delaware's conflict or choice of
law provisions.

SEVERABILITY

If any provision of this Agreement shall be held to be invalid or
unenforceable, the remainder of this Agreement shall remain in full
force and effect. To the extent any express or implied restrictions
are not permitted by applicable laws, these express or implied
restrictions shall remain in force and effect to the maximum extent
permitted by such applicable laws.

THIRD PARTY SOFTWARE ATTRIBUTION

Npcap uses several 3rd party open source software libraries:

* The libpcap portable packet capturing library from https://tcpdump.org
* The Winpcap packet capturing library. It has been abandoned, but is
  currently still available from https://www.winpcap.org/.
* The ieee80211_radiotap.h header file from David Young

All of these are open source with BSD-style licenses that allow for
unlimited use and royalty-free redistribution within other software
(including commercial/proprietary software). Some include a warranty
disclaimer (relating to the original authors) and require a small
amount of acknowledgment text be added somewhere in the documentation
of any software which includes them (including indirect inclusion
through Npcap).

The required acknowledgement text as well as full license text and
source details for these libraries is available from:
https://npcap.com/src/docs/Npcap-Third-Party-Open-Source.pdf .

Since Nmap Software LLC is not the author of this 3rd party code, we
can not waive or modify its software copyright or license.  Npcap
users and redistributors must comply with the relevant Npcap license
(either the free/demo license or a commercial Npcap OEM license they
may have purchased) as well as the minimal requirements of this 3rd
party open source software.

```

`Npcap_Guide.html`:

```html
<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta http-equiv="refresh" content="0; url=./docs/index.html">
    <title>Npcap Guide</title>
    <script type="text/javascript">
window.location.href='./docs/index.html';
    </script>
  </head>
  <body>
    <p>The Npcap Guide is located <a href="./docs/index.html">in the "docs" directory</a>.
    You can also find the latest version of the Guide <a href="https://npcap.com/guide/">on Npcap.com</a>.
    </p>
  </body>
</html>

```

`README.md`:

```md
Npcap
==========

[![Build status](https://ci.appveyor.com/api/projects/status/woero8l6qhgy4syx?svg=true)](https://ci.appveyor.com/project/dmiller-nmap/npcap)
![Environment](https://img.shields.io/badge/Windows-7,%208,%208.1,%2010,%2011-brightgreen.svg)
[![Release](https://img.shields.io/github/release/nmap/npcap.svg)](https://npcap.com/#download)
[![Issues](https://img.shields.io/github/issues/nmap/npcap.svg)](https://github.com/nmap/npcap/issues)

[**Npcap**](https://npcap.com) is a packet capture and injection library for
Windows by the [**Nmap Project**](https://nmap.org). It is a complete update to
the unmaintained [**WinPcap**](http://www.winpcap.org/) project with improved
speed, reliability, and security.

## Documentation

The complete documentation for Npcap is available in the [Npcap
Guide](https://npcap.com/guide/) on [npcap.com](https://npcap.com/). There you
will find information about
[installation](https://npcap.com/guide/npcap-users-guide.html#npcap-installation),
[reporting
bugs](https://npcap.com/guide/npcap-users-guide.html#npcap-issues),
[developing software with
Npcap](https://npcap.com/guide/npcap-devguide.html), and [Npcap
internals](https://npcap.com/guide/npcap-internals.html).

## Downloads

The latest installer, Software Development Kit (SDK), source, and debug symbols
can be downloaded from https://npcap.com/#download

## Bug report

Please report any bugs or issues about Npcap at: [Npcap issues on
GitHub](https://github.com/nmap/npcap/issues). In your report, please provide
your
[**DiagReport**](https://npcap.com/guide/npcap-users-guide.html#npcap-issues-diagreport)
output, user software version (e.g. Nmap, Wireshark), reproduce steps and other
information you think necessary. Refer to [the Npcap Guide section on reporting
bugs](https://npcap.com/guide/npcap-users-guide.html#npcap-issues) for more
complete directions.

## License

The [Npcap License](https://github.com/nmap/npcap/blob/master/LICENSE) allows
end users to download, install, and use Npcap from our site for free on up to 5
systems (including commercial usage). Software providers (open source or
otherwise) which want to use Npcap functionality are welcome to point their
users to [npcap.com](https://npcap.com/) for those users to download and install.

We fund the Npcap project by selling [Npcap OEM](https://npcap.com/oem/). This
special version of Npcap includes enterprise features such as the silent
installer and commercial support as well as special license rights.


## Contact

* ``dev@nmap.org`` (Nmap development list, for technical issues and discussion)
* ``sales@nmap.com`` (Sales address for commercial/licensing issues)
* [Npcap Issues Tracker](https://github.com/nmap/npcap/issues/)

```

`SDK_CHANGELOG.md`:

```md
## Npcap SDK 1.16 [2026-01-07]

* Upgraded libpcap to 1.10.6.

* Renamed the `SKF_AD_*` constants to `NPCAP_AD_*` to avoid confusion with code
  that may expect the same values or ordering as the constants defined by
  Linux. The old names are still conditionally defined for convenience.

* Defined additional modes for `PacketSetMode()`/`pcap_setmode()`:
  `MODE_SENDTORX` and `MODE_SENDTORX_CLEAR` to enable and disable the SendToRx
  feature independent of systemwide Registry setting.
  Requires Npcap 1.83 driver or later.

* Enable nanosecond-precision timestamps on a packet handle using
  `PACKET_MODE_NANO` with `PacketSetMode()`. Requires Npcap 1.83 driver or later.

* Added new constants for `PacketGetInfo()`: `NPF_GETINFO_MODES` returns
  supported mode bits for `PacketSetMode()`. `NPF_GETINFO_STATS` retrieves
  performance statistics for the filter module. `NPF_GETINFO_MODDBG` gets
  internal debugging info unique to a filter module. These require Npcap 1.84
  driver or later.

## Npcap SDK 1.15 [2025]

* Added a new function, `PacketGetInfo()`. This uses the `PACKET_OID_DATA`
  structure to issue information requests to the Npcap driver. Currently
  defined requests are `NPF_GETINFO_VERSION`, `NPF_GETINFO_CONFIG`, and
  `NPF_GETINFO_BPFEXT`.

* Using `PacketGetInfo()` with `NPF_GETINFO_BPFEXT` allows user code to
  determine which BPF extensions are supported by the driver. The first
  extensions supported by the driver will be `SKF_AD_VLAN_TAG` and
  `SKF_AD_VLAN_TAG_PRESENT`, which have the same meanings as the Linux kernel's
  BPF extensions of the same names.

* Moved Npcap's BPF definitions to `npcap-bpf.h` and other definitions to
  `npcap-defs.h` to allow them to be used independently of `Packet32.h`. They
  are included by `Packet32.h`, so there should be no need to change existing
  code.

## Npcap SDK 1.14 [2022-08-18]

* Restored `PacketLibraryVersion` export. It is still preferred to use
  `PacketGetVersion()`

## Npcap SDK 1.13 [2022-06-21]

* Added SAL annotations to most function prototypes and several struct fields
  in `Packet32.h`

* The undocumented `char PacketLibraryVersion[]` export has been removed from
  Npcap 1.70 and later. The `PacketGetVersion()` function is the documented way
  to get the runtime version of the Packet.dll library.

* PacketGetNetType() now always sets the LinkSpeed field to 0. Many adapters
  did not support the OID that was being used to get the link speed, and
  libpcap (Npcap's published API) does not pass this information through, so
  there should be no impact on the majority of software. Software that needs
  link speed may use `pcap_oid_get_request()` or `GetAdaptersAddresses()` to
  get the information.

## Npcap SDK 1.12 [2021-12-06]

* Added this changelog.

* Included wpcap.lib for ARM64.

* Updated `Examples-pcap/pcap_filter` to show modern API usage with
  `pcap_create()` and `pcap_activate()`.

* Removed documentation and examples for the "kernel dump" feature of WinPcap,
  which has never been supported by Npcap and was disabled in WinPcap 3.1. The
  `Packet32.h` functions which supported this mode have been marked as
  deprecated.

## Npcap SDK 1.11 [2021-09-03]

* Fix an issue with libpcap header files which required VS 2015 or later. This
  change was made to accommodate a few existing licensees. We strongly
  recommend using a currently-supported compiler version to build software with Npcap.

* Added `const` qualifiers to input parameters for several `Packet32.h` functions.

## Npcap SDK 1.10 [2021-06-22]

* ARM64 libs for Packet.dll added.

* Updated documentation.

## Npcap SDK 1.07 [2021-03-10]

* Updated libpcap headers to 1.10.1 from 1.9.1. See [the libpcap CHANGES
  file](https://github.com/the-tcpdump-group/libpcap/blob/libpcap-1.10/CHANGES)
  and issue [#276](http://issues.npcap.org/276) for notable changes.

* Added `Packet32.h` functions to set per-handle time source and precision.
  This supports libpcap function `pcap_set_tstamp_type()` on Npcap 1.20 and
  later.


----
Earlier changes not tracked.

```

`appveyor.yml`:

```yml
# Notes:
#   - Minimal appveyor.yml file is an empty file. All sections are optional.
#   - Indent each level of configuration with 2 spaces. Do not use tabs!
#   - All section names are case-sensitive.
#   - Section names should be unique on each level.

#---------------------------------#
#      general configuration      #
#---------------------------------#

# version format
version: 0.10.{build}

# branches to build
branches:
  # blacklist
  except:
    - gh-pages

# Do not build on tags (GitHub only)
skip_tags: true

#---------------------------------#
#    environment configuration    #
#---------------------------------#

image: Visual Studio 2022

# clone directory
clone_folder: C:\Npcap
clone_depth: 10

# environment variables
environment:
  SignTool: C:\Program Files (x86)\Windows Kits\10\bin\x64

# scripts that run after cloning repository
install:
  # clone the submodules
  - cmd: git submodule update --init --recursive
  # install Win-Flex-Bison
  - cmd: cinst winflexbison -y

#---------------------------------#
#       build configuration       #
#---------------------------------#

# scripts to run before build
# before_build:

# scripts to run *after* solution is built and *before* automatic packaging occurs (web apps, NuGet packages, Azure Cloud Services)
# before_package:

# scripts to run after build
# after_build:

# to run your custom scripts instead of automatic MSBuild
build_script:
  - cmd: cd installer
  - cmd: echo .| Build.bat

# to disable automatic builds
# build: off

```

`build_sdk.bat`:

```bat
@echo off
for /F tokens^=3^,4^ delims^=^"^	^  %%A in (version.h) do if "%%A" == "NPCAP_SDK_VERSION" set SDK_VER=%%B
if "%SDK_VER%" == "" goto :fail
set SDKFILENAME=npcap-sdk-%SDK_VER%.zip

if "%2"== "" ( rd /s/q ./npcap-sdk 2>nul >nul) else ( rd /s /q "%2" 2>nul >nul)

SET TOPSRCDIR=%cd%

rem Must build Npcap in order to have the lib files available (and to ensure it builds correctly!)
cd installer
call Build.bat
cd %TOPSRCDIR%

call create_include.bat %1 %2

call create_lib.bat %1 %2 || goto :fail

call create_examples.bat %1 %2

rem Requires msys2 or cygwin, roffit, xsltproc and Docbook XSL stylesheets
call create_docs.bat %1 %2 || goto :fail

del %SDKFILENAME%
copy SDK_CHANGELOG.md .\npcap-sdk\SDK_CHANGELOG.md

cd .\npcap-sdk
"C:\Program Files\7-Zip\7z.exe" a ..\%SDKFILENAME% .
PAUSE

exit /b
:fail
echo Failed!
pause
exit /b 1

```

`build_sdk.txt`:

```txt
In order to build the developers' pack, you need to compile the various DLLs and then call build_sdk.bat
This batch file, in turn, calls the four batches
- create_includes.bat	creates the include folder
- create_lib.bat		creates the lib folder
- create_examples.bat	copies the examples folder to the developers' pack. The examples can be compiled only under the developers' pack folder.
- create_docs.bat		creates the documentation (via Docbook XSL and Roffit), and then copies the generated files under the developers' pack folder.

The syntax for the various scripts is

<script.bat> winpcap_folder developer_folder

winpcap_folder		The winpcap sources folder. It is defaulted to .\
developer_folder	The developers' pack folder. It is defaulted to .\npcap-sdk.

HINT: just call build_sdk.bat without any parameter!


```

`build_test.bat`:

```bat
SET MODE="Release"
SET TOPSRCDIR=%cd%
SET VERB=Build
if NOT "%1" == "" SET VERB="%1"

rem call build_sdk.bat || goto :error
cd %TOPSRCDIR%

Call :BUILD_TEST x86 || goto :error
Call :BUILD_TEST x64 || goto :error
Call :BUILD_TEST ARM64 || goto :error
exit /b

:BUILD_TEST
set TOOLSET=%1
if "%1" == "ARM64" set TOOLSET=amd64_arm64
for /f "usebackq delims=#" %%a in (`"%ProgramFiles(x86)%\Microsoft Visual Studio\Installer\vswhere" -version 17 -property installationPath`) do call "%%a\VC\Auxiliary\Build\vcvarsall.bat" %TOOLSET%
if %ERRORLEVEL% NEQ 0 goto :error

msbuild /p:ForceImportBeforeCppTargets="%CD%\test\static.props" ".\Examples-pcap\MakeAll.sln" /m /t:%VERB% /p:Configuration=%MODE% /p:Platform="%1" || goto :error
msbuild /p:ForceImportBeforeCppTargets="%CD%\test\static.props" ".\Examples\sendcap\sendcap.vcxproj" /m /t:%VERB% /p:Configuration=%MODE% /p:Platform="%1" || goto :error
if NOT "%VERB%" == "Build" goto :EOF

set BINDIR=%1\
if "%1" == "x86" set BINDIR=""

mkdir test\%1\
copy /b ".\Examples-pcap\%BINDIR%%MODE%\iflist.exe" test\%1\
copy /b ".\Examples-pcap\%BINDIR%%MODE%\pcap_filter.exe" test\%1\
copy /b ".\Examples-pcap\%BINDIR%%MODE%\sendpack.exe" test\%1\
copy /b ".\Examples-pcap\%BINDIR%%MODE%\readfile.exe" test\%1\

copy /b ".\Examples\sendcap\%BINDIR%%MODE%\sendcap.exe" test\%1\

goto :EOF

:error
echo Something failed: %ERRORLEVEL%
exit /b 1

```

`create_docs.bat`:

```bat
@echo off

rem Ensure trailing slash
IF "%2"=="" (set WPDPACKDESTDIR=.\npcap-sdk\) ELSE (set WPDPACKDESTDIR=%~dp2)
rem Remove last character (trailing slash)
set WPDPACKDESTDIR=%WPDPACKDESTDIR:~0,-1%

rem Ensure trailing slash
IF ""=="%1" (set WINPCAPSOURCEDIR=.\) ELSE (set WINPCAPSOURCEDIR=%~dp1) 
rem Remove last character (trailing slash)
set WINPCAPSOURCEDIR=%WINPCAPSOURCEDIR:~0,-1%

set DOCBOOKXSL_VER=1.79.2

if exist "C:\msys64\usr\bin\env.exe" (
	set RUNBASH=C:\msys64\usr\bin\env.exe MSYSTEM=MINGW64 CHERE_INVOKING=1 /usr/bin/bash --login
) else (
	set RUNBASH=C:\cygwin\bin\bash.exe --login
)

set DOCBOOKXSL=C:\xslt\docbook-xsl-%DOCBOOKXSL_VER%
set XSLTPROC=C:\xslt\bin\xsltproc.exe
if not exist %XSLTPROC% (
	set XSLTPROC=%RUNBASH% -c "xsltproc ""$@"";" --
	set DOCBOOKXSL=/mingw64/share/xml/docbook/xsl-stylesheets-%DOCBOOKXSL_VER%
) else (
	if not exist %DOCBOOKXSL% (
		set MISSING=%DOCBOOKXSL%
		goto :missing
	)
)
set ROFFIT=%WINPCAPSOURCEDIR%\..\roffit\roffit
if not exist %ROFFIT% (
	set MISSING=%ROFFIT%
	goto :missing
)

echo Creating \docs folder
mkdir %WPDPACKDESTDIR% >nul 2>nul
mkdir %WPDPACKDESTDIR%\docs >nul 2>nul

echo - Deleting existing WinPcap documentation
del /q /S %WPDPACKDESTDIR%\docs\*.* 2> nul > nul
echo - Creating new documentation
xcopy /v /Y "%WINPCAPSOURCEDIR%\Npcap_Guide.html" %WPDPACKDESTDIR%\
mkdir %WPDPACKDESTDIR%\docs\wpcap >nul 2>nul
%XSLTPROC% --path %DOCBOOKXSL% --nonet --stringparam media.type html --stringparam base.dir %WPDPACKDESTDIR%/docs/ --stringparam use.id.as.filename 1 %DOCBOOKXSL%/html/chunk.xsl %WINPCAPSOURCEDIR%/docs/npcap-guide-wrapper.xml

for %%i in (%WINPCAPSOURCEDIR%) do set FULLPATHSOURCE=%%~fi
for %%i in (%WPDPACKDESTDIR%) do set FULLPATHDEST=%%~fi
%RUNBASH% -c "cd $(cygpath '%FULLPATHSOURCE%'); make -f create_docs.make LIBPCAPDIR=$(cygpath '%FULLPATHSOURCE%/wpcap/libpcap') DOCDIR=$(cygpath '%FULLPATHDEST%/docs') ROFFIT=perl\ $(cygpath '%ROFFIT%');"

echo Folder \docs created successfully
set WPDPACKDESTDIR=
set WINPCAPSOURCEDIR=
exit /b

:missing
echo "Failed to generate docs: %MISSING% is missing"
exit /b 1

```

`create_docs.make`:

```make
ROFFIT = roffit
LIBPCAPDIR = ./wpcap/libpcap
DOCDIR = ./npcap-sdk/docs

PCT = %

%.3pcap: %.3pcap.in
	sed -e 's/@MAN_MISC_INFO@/7/g' -e 's/@MAN_FILE_FORMATS@/5/g' -e 's/@MAN_ADMIN_COMMANDS@/8/g' $< > $@
%.7: %.manmisc.in
	sed -e 's/@MAN_MISC_INFO@/7/g' -e 's/@MAN_FILE_FORMATS@/5/g' -e 's/@MAN_ADMIN_COMMANDS@/8/g' $< > $@
%.5: %.manfile.in
	sed -e 's/@MAN_MISC_INFO@/7/g' -e 's/@MAN_FILE_FORMATS@/5/g' -e 's/@MAN_ADMIN_COMMANDS@/8/g' $< > $@

${DOCDIR}/wpcap/pcap.html: $(LIBPCAPDIR)/pcap.3pcap $(LIBPCAPDIR)/pcap.3pcap $(LIBPCAPDIR)/pcap_compile.3pcap $(LIBPCAPDIR)/pcap_datalink.3pcap $(LIBPCAPDIR)/pcap_dump_open.3pcap $(LIBPCAPDIR)/pcap_get_tstamp_precision.3pcap $(LIBPCAPDIR)/pcap_list_datalinks.3pcap $(LIBPCAPDIR)/pcap_list_tstamp_types.3pcap $(LIBPCAPDIR)/pcap_open_dead.3pcap $(LIBPCAPDIR)/pcap_open_offline.3pcap $(LIBPCAPDIR)/pcap_set_tstamp_precision.3pcap $(LIBPCAPDIR)/pcap_set_tstamp_type.3pcap $(LIBPCAPDIR)/pcap-savefile.5 $(LIBPCAPDIR)/pcap-filter.7 $(LIBPCAPDIR)/pcap-linktype.7 $(LIBPCAPDIR)/pcap-tstamp.7
	mkdir -p ${DOCDIR}/wpcap/ build/wpcap/
	rm -f ${DOCDIR}/wpcap/*.html build/wpcap/*.html
# Generate the contents
	find "$(LIBPCAPDIR)" -maxdepth 1 \( -name '*.3pcap' -o -name '*.7' -o -name '*.5' \) | while read m; do \
		p=$${m$(PCT).3pcap} ; \
		p=$${p$(PCT).7} ; \
		p=$${p$(PCT).5} ; \
		p=$${p##*/} ; \
		$(ROFFIT) --mandir="$(LIBPCAPDIR)" --hrefdir=. "$$m" > ${DOCDIR}/wpcap/$$p.html ; \
	done

```

`create_examples.bat`:

```bat
@echo off

IF "%2"=="" (set WPDPACKDESTDIR=npcap-sdk) ELSE (set WPDPACKDESTDIR=%2)

IF ""=="%1" (set WINPCAPSOURCEDIR=.\) ELSE (set WINPCAPSOURCEDIR=%1) 

echo Creating \Examples folder
mkdir %WPDPACKDESTDIR% >nul 2>nul
rd /S /Q %WPDPACKDESTDIR%\Examples-pcap >nul 2>nul
mkdir %WPDPACKDESTDIR%\Examples-pcap >nul 2>nul
rd /S /Q %WPDPACKDESTDIR%\Examples-remote >nul 2>nul
mkdir %WPDPACKDESTDIR%\Examples-remote >nul 2>nul

rem Can't pipe stdout to stdin of tar; claims "Damaged archive"
git archive --prefix="%WPDPACKDESTDIR%/Examples-remote/" HEAD:Examples -o Examples-remote.tar
tar xf Examples-remote.tar
del Examples-remote.tar

git archive --prefix="%WPDPACKDESTDIR%/Examples-pcap/" HEAD:Examples-pcap -o Examples-pcap.tar
tar xf Examples-pcap.tar
del Examples-pcap.tar

rem *** Delete Netmeter since it's no more part of the Developer's pack *** 
rd /S /Q %WPDPACKDESTDIR%\Examples-remote\NetMeter\

rem *** Delete WinPcapStress, since it's not a real example ***
rd /S /Q %WPDPACKDESTDIR%\Examples-pcap\winpcap_stress

rem *** Delete stats, since it's not a real example ***
rd /S /Q %WPDPACKDESTDIR%\Examples-pcap\stats


echo Folder \Examples created successfully
set WPDPACKDESTDIR=
set WINPCAPSOURCEDIR=

echo ********************************************************************
echo *                                                                  *
echo * Now you can build the examples from the developers' pack folder! *
echo *                                                                  *
echo ********************************************************************

```

`create_include.bat`:

```bat
@echo off

IF "%2"=="" (set WPDPACKDESTDIR=.\npcap-sdk\) ELSE (set WPDPACKDESTDIR=%2)

IF ""=="%1" (set WINPCAPSOURCEDIR=.\) ELSE (set WINPCAPSOURCEDIR=%1) 

echo Creating \Include folder
mkdir %WPDPACKDESTDIR%  		2>nul >nul
mkdir %WPDPACKDESTDIR%\Include  	2>nul >nul
mkdir %WPDPACKDESTDIR%\Include\pcap  	2>nul >nul


SETLOCAL ENABLEEXTENSIONS

xcopy /v /Y %WINPCAPSOURCEDIR%\wpcap\libpcap\pcap\  %WPDPACKDESTDIR%\Include\pcap\ >nul
for /F "usebackq skip=1 tokens=3 delims=/ " %%i in (`findstr "CMAKE_INSTALL_INCLUDEDIR" "%WINPCAPSOURCEDIR%\wpcap\libpcap\CMakeLists.txt"`) do (
	copy /v /Y "%WINPCAPSOURCEDIR%\wpcap\libpcap\%%i"  "%WPDPACKDESTDIR%\Include\%%i"
)

xcopy /v /Y %WINPCAPSOURCEDIR%\Common\Packet32.h   %WPDPACKDESTDIR%\Include\ >nul
xcopy /v /Y %WINPCAPSOURCEDIR%\Common\npcap-bpf.h  %WPDPACKDESTDIR%\Include\ >nul
xcopy /v /Y %WINPCAPSOURCEDIR%\Common\npcap-defs.h %WPDPACKDESTDIR%\Include\ >nul

echo Folder \Include created successfully
set WPDPACKDESTDIR=
set WINPCAPSOURCEDIR=

```

`create_lib.bat`:

```bat
@echo off

IF "%2"=="" (set WPDPACKDESTDIR=.\npcap-sdk\) ELSE (set WPDPACKDESTDIR=%2)

IF ""=="%1" (set WINPCAPSOURCEDIR=.\) ELSE (set WINPCAPSOURCEDIR=%1) 

echo Checking for wpcap build dirs
set WPCAPBUILDDIR32=%WINPCAPSOURCEDIR%\wpcap\build-win32
if not exist "%WPCAPBUILDDIR32%" goto :fail
set WPCAPBUILDDIR64=%WINPCAPSOURCEDIR%\wpcap\build-x64
if not exist "%WPCAPBUILDDIR64%" goto :fail
set WPCAPBUILDDIRARM=%WINPCAPSOURCEDIR%\wpcap\build-ARM64
if not exist "%WPCAPBUILDDIRARM%" goto :fail

echo Checking for Packet build dir
set PACKETBUILDDIR=%WINPCAPSOURCEDIR%\packetWin7\vs14
if not exist "%PACKETBUILDDIR%" goto :fail

echo Creating \Lib folder
mkdir %WPDPACKDESTDIR% 		>nul 2>nul
mkdir %WPDPACKDESTDIR%\Lib 	>nul 2>nul
mkdir %WPDPACKDESTDIR%\Lib\x64	>nul 2>nul
mkdir %WPDPACKDESTDIR%\Lib\ARM64	>nul 2>nul

xcopy /v /Y "%WPCAPBUILDDIR32%\Release\wpcap.lib" %WPDPACKDESTDIR%\Lib\ || goto :fail
xcopy /v /Y "%WPCAPBUILDDIR64%\Release\wpcap.lib" %WPDPACKDESTDIR%\Lib\x64 || goto :fail
xcopy /v /Y "%WPCAPBUILDDIRARM%\Release\wpcap.lib" %WPDPACKDESTDIR%\Lib\ARM64 || goto :fail
xcopy /v /Y "%PACKETBUILDDIR%\Release\packet.lib" %WPDPACKDESTDIR%\Lib\ || goto :fail
xcopy /v /Y "%PACKETBUILDDIR%\x64\Release\packet.lib" %WPDPACKDESTDIR%\Lib\x64 || goto :fail
xcopy /v /Y "%PACKETBUILDDIR%\ARM64\Release No AirPcap\packet.lib" %WPDPACKDESTDIR%\Lib\ARM64 || goto :fail

echo Folder \Lib created successfully

set WPDPACKDESTDIR=
set WINPCAPSOURCEDIR=

exit /b

:fail
echo Failed.
pause
exit /b 1


```

`docs/Npcap-Third-Party-Open-Source.fodt`:

```fodt
<?xml version="1.0" encoding="UTF-8"?>

<office:document xmlns:officeooo="http://openoffice.org/2009/office" xmlns:css3t="http://www.w3.org/TR/css3-text/" xmlns:grddl="http://www.w3.org/2003/g/data-view#" xmlns:xhtml="http://www.w3.org/1999/xhtml" xmlns:formx="urn:openoffice:names:experimental:ooxml-odf-interop:xmlns:form:1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:chart="urn:oasis:names:tc:opendocument:xmlns:chart:1.0" xmlns:svg="urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0" xmlns:text="urn:oasis:names:tc:opendocument:xmlns:text:1.0" xmlns:oooc="http://openoffice.org/2004/calc" xmlns:style="urn:oasis:names:tc:opendocument:xmlns:style:1.0" xmlns:ooow="http://openoffice.org/2004/writer" xmlns:meta="urn:oasis:names:tc:opendocument:xmlns:meta:1.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rpt="http://openoffice.org/2005/report" xmlns:draw="urn:oasis:names:tc:opendocument:xmlns:drawing:1.0" xmlns:config="urn:oasis:names:tc:opendocument:xmlns:config:1.0" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:fo="urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0" xmlns:ooo="http://openoffice.org/2004/office" xmlns:office="urn:oasis:names:tc:opendocument:xmlns:office:1.0" xmlns:dr3d="urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0" xmlns:table="urn:oasis:names:tc:opendocument:xmlns:table:1.0" xmlns:number="urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0" xmlns:of="urn:oasis:names:tc:opendocument:xmlns:of:1.2" xmlns:calcext="urn:org:documentfoundation:names:experimental:calc:xmlns:calcext:1.0" xmlns:tableooo="http://openoffice.org/2009/table" xmlns:drawooo="http://openoffice.org/2010/draw" xmlns:loext="urn:org:documentfoundation:names:experimental:office:xmlns:loext:1.0" xmlns:dom="http://www.w3.org/2001/xml-events" xmlns:field="urn:openoffice:names:experimental:ooo-ms-interop:xmlns:field:1.0" xmlns:math="http://www.w3.org/1998/Math/MathML" xmlns:form="urn:oasis:names:tc:opendocument:xmlns:form:1.0" xmlns:script="urn:oasis:names:tc:opendocument:xmlns:script:1.0" xmlns:xforms="http://www.w3.org/2002/xforms" office:version="1.3" office:mimetype="application/vnd.oasis.opendocument.text">
 <office:meta><dc:title>Third-Party Open Source Software Used By Npcap</dc:title><meta:initial-creator>Insecure.Com LLC</meta:initial-creator><meta:creation-date>2016-08-17T21:15:00</meta:creation-date><dc:date>2022-01-25T14:15:09.090000000</dc:date><meta:print-date>2016-08-17T21:19:00</meta:print-date><meta:editing-cycles>35</meta:editing-cycles><meta:editing-duration>PT23H14M2S</meta:editing-duration><meta:generator>LibreOffice/7.3.6.2$Linux_X86_64 LibreOffice_project/30$Build-2</meta:generator><meta:document-statistic meta:table-count="0" meta:image-count="0" meta:object-count="0" meta:page-count="5" meta:paragraph-count="93" meta:word-count="1939" meta:character-count="13263" meta:non-whitespace-character-count="11379"/><meta:template xlink:type="simple" xlink:actuate="onRequest" xlink:title="Normal" xlink:href=""/></office:meta>
 <office:settings>
  <config:config-item-set config:name="ooo:view-settings">
   <config:config-item config:name="ViewAreaTop" config:type="long">0</config:config-item>
   <config:config-item config:name="ViewAreaLeft" config:type="long">0</config:config-item>
   <config:config-item config:name="ViewAreaWidth" config:type="long">22666</config:config-item>
   <config:config-item config:name="ViewAreaHeight" config:type="long">31203</config:config-item>
   <config:config-item config:name="ShowRedlineChanges" config:type="boolean">false</config:config-item>
   <config:config-item config:name="InBrowseMode" config:type="boolean">false</config:config-item>
   <config:config-item-map-indexed config:name="Views">
    <config:config-item-map-entry>
     <config:config-item config:name="ViewId" config:type="string">view2</config:config-item>
     <config:config-item config:name="ViewLeft" config:type="long">9253</config:config-item>
     <config:config-item config:name="ViewTop" config:type="long">13564</config:config-item>
     <config:config-item config:name="VisibleLeft" config:type="long">0</config:config-item>
     <config:config-item config:name="VisibleTop" config:type="long">0</config:config-item>
     <config:config-item config:name="VisibleRight" config:type="long">22664</config:config-item>
     <config:config-item config:name="VisibleBottom" config:type="long">31201</config:config-item>
     <config:config-item config:name="ZoomType" config:type="short">3</config:config-item>
     <config:config-item config:name="ViewLayoutColumns" config:type="short">1</config:config-item>
     <config:config-item config:name="ViewLayoutBookMode" config:type="boolean">false</config:config-item>
     <config:config-item config:name="ZoomFactor" config:type="short">159</config:config-item>
     <config:config-item config:name="IsSelectedFrame" config:type="boolean">false</config:config-item>
     <config:config-item config:name="KeepRatio" config:type="boolean">false</config:config-item>
     <config:config-item config:name="AnchoredTextOverflowLegacy" config:type="boolean">false</config:config-item>
    </config:config-item-map-entry>
   </config:config-item-map-indexed>
  </config:config-item-set>
  <config:config-item-set config:name="ooo:configuration-settings">
   <config:config-item config:name="PrintProspect" config:type="boolean">false</config:config-item>
   <config:config-item config:name="PrintReversed" config:type="boolean">false</config:config-item>
   <config:config-item config:name="PrintSingleJobs" config:type="boolean">false</config:config-item>
   <config:config-item config:name="PrintLeftPages" config:type="boolean">true</config:config-item>
   <config:config-item config:name="PrintTables" config:type="boolean">true</config:config-item>
   <config:config-item config:name="PrintControls" config:type="boolean">true</config:config-item>
   <config:config-item config:name="PrintPageBackground" config:type="boolean">true</config:config-item>
   <config:config-item config:name="PrintDrawings" config:type="boolean">true</config:config-item>
   <config:config-item config:name="PrintBlackFonts" config:type="boolean">false</config:config-item>
   <config:config-item config:name="PrintAnnotationMode" config:type="short">0</config:config-item>
   <config:config-item config:name="PrintTextPlaceholder" config:type="boolean">false</config:config-item>
   <config:config-item config:name="ProtectFields" config:type="boolean">false</config:config-item>
   <config:config-item config:name="ProtectBookmarks" config:type="boolean">false</config:config-item>
   <config:config-item config:name="EmptyDbFieldHidesPara" config:type="boolean">false</config:config-item>
   <config:config-item config:name="DisableOffPagePositioning" config:type="boolean">true</config:config-item>
   <config:config-item config:name="SubtractFlysAnchoredAtFlys" config:type="boolean">true</config:config-item>
   <config:config-item config:name="PropLineSpacingShrinksFirstLine" config:type="boolean">false</config:config-item>
   <config:config-item config:name="ApplyParagraphMarkFormatToNumbering" config:type="boolean">false</config:config-item>
   <config:config-item config:name="GutterAtTop" config:type="boolean">false</config:config-item>
   <config:config-item config:name="TreatSingleColumnBreakAsPageBreak" config:type="boolean">false</config:config-item>
   <config:config-item config:name="EmbedSystemFonts" config:type="boolean">false</config:config-item>
   <config:config-item config:name="EmbedComplexScriptFonts" config:type="boolean">false</config:config-item>
   <config:config-item config:name="EmbedAsianScriptFonts" config:type="boolean">false</config:config-item>
   <config:config-item config:name="EmbedLatinScriptFonts" config:type="boolean">false</config:config-item>
   <config:config-item config:name="EmbedOnlyUsedFonts" config:type="boolean">false</config:config-item>
   <config:config-item config:name="ContinuousEndnotes" config:type="boolean">false</config:config-item>
   <config:config-item config:name="EmbedFonts" config:type="boolean">false</config:config-item>
   <config:config-item config:name="ClippedPictures" config:type="boolean">true</config:config-item>
   <config:config-item config:name="FloattableNomargins" config:type="boolean">false</config:config-item>
   <config:config-item config:name="UnbreakableNumberings" config:type="boolean">true</config:config-item>
   <config:config-item config:name="HeaderSpacingBelowLastPara" config:type="boolean">false</config:config-item>
   <config:config-item config:name="AllowPrintJobCancel" config:type="boolean">true</config:config-item>
   <config:config-item config:name="UseOldPrinterMetrics" config:type="boolean">false</config:config-item>
   <config:config-item config:name="TabOverMargin" config:type="boolean">true</config:config-item>
   <config:config-item config:name="TabsRelativeToIndent" config:type="boolean">false</config:config-item>
   <config:config-item config:name="UseOldNumbering" config:type="boolean">false</config:config-item>
   <config:config-item config:name="InvertBorderSpacing" config:type="boolean">true</config:config-item>
   <config:config-item config:name="PrintPaperFromSetup" config:type="boolean">false</config:config-item>
   <config:config-item config:name="UpdateFromTemplate" config:type="boolean">true</config:config-item>
   <config:config-item config:name="CurrentDatabaseCommandType" config:type="int">0</config:config-item>
   <config:config-item config:name="LinkUpdateMode" config:type="short">1</config:config-item>
   <config:config-item config:name="AddParaSpacingToTableCells" config:type="boolean">true</config:config-item>
   <config:config-item config:name="FrameAutowidthWithMorePara" config:type="boolean">false</config:config-item>
   <config:config-item config:name="CurrentDatabaseCommand" config:type="string"/>
   <config:config-item config:name="PrinterIndependentLayout" config:type="string">high-resolution</config:config-item>
   <config:config-item config:name="ApplyUserData" config:type="boolean">false</config:config-item>
   <config:config-item config:name="PrintFaxName" config:type="string"/>
   <config:config-item config:name="CurrentDatabaseDataSource" config:type="string"/>
   <config:config-item config:name="ClipAsCharacterAnchoredWriterFlyFrames" config:type="boolean">false</config:config-item>
   <config:config-item config:name="IsKernAsianPunctuation" config:type="boolean">false</config:config-item>
   <config:config-item config:name="SaveThumbnail" config:type="boolean">false</config:config-item>
   <config:config-item config:name="UseFormerTextWrapping" config:type="boolean">false</config:config-item>
   <config:config-item config:name="AddExternalLeading" config:type="boolean">true</config:config-item>
   <config:config-item config:name="AddParaTableSpacing" config:type="boolean">true</config:config-item>
   <config:config-item config:name="StylesNoDefault" config:type="boolean">false</config:config-item>
   <config:config-item config:name="ChartAutoUpdate" config:type="boolean">true</config:config-item>
   <config:config-item-map-indexed config:name="ForbiddenCharacters">
    <config:config-item-map-entry>
     <config:config-item config:name="Language" config:type="string">ja</config:config-item>
     <config:config-item config:name="Country" config:type="string">JP</config:config-item>
     <config:config-item config:name="Variant" config:type="string"/>
     <config:config-item config:name="BeginLine" config:type="string">!%),.:;?]}¢°’”‰′″℃、。々〉》」』】〕゛゜ゝゞ・ヽヾ！％），．：；？］｝｡｣､･ﾞﾟ￠</config:config-item>
     <config:config-item config:name="EndLine" config:type="string">$([\{£¥‘“〈《「『【〔＄（［｛｢￡￥</config:config-item>
    </config:config-item-map-entry>
   </config:config-item-map-indexed>
   <config:config-item config:name="PrinterSetup" config:type="base64Binary"/>
   <config:config-item config:name="AddParaTableSpacingAtStart" config:type="boolean">true</config:config-item>
   <config:config-item config:name="Rsid" config:type="int">6190950</config:config-item>
   <config:config-item config:name="EmbeddedDatabaseName" config:type="string"/>
   <config:config-item config:name="FieldAutoUpdate" config:type="boolean">true</config:config-item>
   <config:config-item config:name="OutlineLevelYieldsNumbering" config:type="boolean">false</config:config-item>
   <config:config-item config:name="FootnoteInColumnToPageEnd" config:type="boolean">true</config:config-item>
   <config:config-item config:name="AlignTabStopPosition" config:type="boolean">true</config:config-item>
   <config:config-item config:name="CharacterCompressionType" config:type="short">0</config:config-item>
   <config:config-item config:name="PrinterName" config:type="string"/>
   <config:config-item config:name="SaveGlobalDocumentLinks" config:type="boolean">false</config:config-item>
   <config:config-item config:name="PrinterPaperFromSetup" config:type="boolean">false</config:config-item>
   <config:config-item config:name="UseFormerLineSpacing" config:type="boolean">false</config:config-item>
   <config:config-item config:name="AddParaLineSpacingToTableCells" config:type="boolean">false</config:config-item>
   <config:config-item config:name="UseFormerObjectPositioning" config:type="boolean">false</config:config-item>
   <config:config-item config:name="PrintGraphics" config:type="boolean">true</config:config-item>
   <config:config-item config:name="SurroundTextWrapSmall" config:type="boolean">true</config:config-item>
   <config:config-item config:name="ConsiderTextWrapOnObjPos" config:type="boolean">true</config:config-item>
   <config:config-item config:name="MsWordCompTrailingBlanks" config:type="boolean">false</config:config-item>
   <config:config-item config:name="TabAtLeftIndentForParagraphsInList" config:type="boolean">false</config:config-item>
   <config:config-item config:name="PrintRightPages" config:type="boolean">true</config:config-item>
   <config:config-item config:name="TabOverSpacing" config:type="boolean">false</config:config-item>
   <config:config-item config:name="IgnoreFirstLineIndentInNumbering" config:type="boolean">false</config:config-item>
   <config:config-item config:name="RedlineProtectionKey" config:type="base64Binary"/>
   <config:config-item config:name="DoNotJustifyLinesWithManualBreak" config:type="boolean">false</config:config-item>
   <config:config-item config:name="PrintProspectRTL" config:type="boolean">false</config:config-item>
   <config:config-item config:name="PrintEmptyPages" config:type="boolean">false</config:config-item>
   <config:config-item config:name="DoNotResetParaAttrsForNumFont" config:type="boolean">false</config:config-item>
   <config:config-item config:name="AddFrameOffsets" config:type="boolean">true</config:config-item>
   <config:config-item config:name="IgnoreTabsAndBlanksForLineCalculation" config:type="boolean">true</config:config-item>
   <config:config-item config:name="LoadReadonly" config:type="boolean">false</config:config-item>
   <config:config-item config:name="DoNotCaptureDrawObjsOnPage" config:type="boolean">false</config:config-item>
   <config:config-item config:name="AddVerticalFrameOffsets" config:type="boolean">false</config:config-item>
   <config:config-item config:name="UnxForceZeroExtLeading" config:type="boolean">false</config:config-item>
   <config:config-item config:name="IsLabelDocument" config:type="boolean">false</config:config-item>
   <config:config-item config:name="TableRowKeep" config:type="boolean">true</config:config-item>
   <config:config-item config:name="RsidRoot" config:type="int">365532</config:config-item>
   <config:config-item config:name="PrintHiddenText" config:type="boolean">false</config:config-item>
   <config:config-item config:name="ProtectForm" config:type="boolean">false</config:config-item>
   <config:config-item config:name="MsWordCompMinLineHeightByFly" config:type="boolean">false</config:config-item>
   <config:config-item config:name="BackgroundParaOverDrawings" config:type="boolean">false</config:config-item>
   <config:config-item config:name="SaveVersionOnClose" config:type="boolean">false</config:config-item>
   <config:config-item config:name="MathBaselineAlignment" config:type="boolean">true</config:config-item>
   <config:config-item config:name="SmallCapsPercentage66" config:type="boolean">false</config:config-item>
   <config:config-item config:name="CollapseEmptyCellPara" config:type="boolean">true</config:config-item>
   <config:config-item config:name="TabOverflow" config:type="boolean">true</config:config-item>
  </config:config-item-set>
 </office:settings>
 <office:scripts>
  <office:script script:language="ooo:Basic">
   <ooo:libraries xmlns:ooo="http://openoffice.org/2004/office" xmlns:xlink="http://www.w3.org/1999/xlink">
    <ooo:library-embedded ooo:name="Standard"/>
   </ooo:libraries>
  </office:script>
 </office:scripts>
 <office:font-face-decls>
  <style:font-face style:name="Arial" svg:font-family="Arial" style:font-family-generic="swiss" style:font-pitch="variable"/>
  <style:font-face style:name="Liberation Serif" svg:font-family="&apos;Liberation Serif&apos;" style:font-family-generic="roman" style:font-pitch="variable"/>
  <style:font-face style:name="Lohit Devanagari" svg:font-family="&apos;Lohit Devanagari&apos;" style:font-family-generic="system" style:font-pitch="variable"/>
  <style:font-face style:name="Lucida Sans" svg:font-family="&apos;Lucida Sans&apos;" style:font-family-generic="swiss"/>
  <style:font-face style:name="OpenSymbol" svg:font-family="OpenSymbol" style:font-charset="x-symbol"/>
  <style:font-face style:name="Source Han Sans CN Regular" svg:font-family="&apos;Source Han Sans CN Regular&apos;" style:font-family-generic="system" style:font-pitch="variable"/>
  <style:font-face style:name="Times" svg:font-family="Times" style:font-family-generic="roman" style:font-pitch="variable"/>
  <style:font-face style:name="Times New Roman" svg:font-family="&apos;Times New Roman&apos;" style:font-family-generic="roman" style:font-pitch="variable"/>
  <style:font-face style:name="Times New Roman1" svg:font-family="&apos;Times New Roman&apos;" style:font-adornments="Bold" style:font-family-generic="roman" style:font-pitch="variable"/>
 </office:font-face-decls>
 <office:styles>
  <style:default-style style:family="graphic">
   <style:graphic-properties svg:stroke-color="#3465a4" draw:fill-color="#729fcf" fo:wrap-option="no-wrap" draw:shadow-offset-x="0.1181in" draw:shadow-offset-y="0.1181in" draw:start-line-spacing-horizontal="0.1114in" draw:start-line-spacing-vertical="0.1114in" draw:end-line-spacing-horizontal="0.1114in" draw:end-line-spacing-vertical="0.1114in" style:flow-with-text="false"/>
   <style:paragraph-properties style:text-autospace="ideograph-alpha" style:line-break="strict" style:writing-mode="lr-tb" style:font-independent-line-spacing="false">
    <style:tab-stops/>
   </style:paragraph-properties>
   <style:text-properties style:use-window-font-color="true" loext:opacity="0%" style:font-name="Liberation Serif" fo:font-size="12pt" fo:language="en" fo:country="US" style:letter-kerning="true" style:font-name-asian="Source Han Sans CN Regular" style:font-size-asian="10.5pt" style:language-asian="zh" style:country-asian="CN" style:font-name-complex="Lohit Devanagari" style:font-size-complex="12pt" style:language-complex="hi" style:country-complex="IN"/>
  </style:default-style>
  <style:default-style style:family="paragraph">
   <style:paragraph-properties fo:hyphenation-ladder-count="no-limit" style:text-autospace="ideograph-alpha" style:punctuation-wrap="hanging" style:line-break="strict" style:tab-stop-distance="0.5in" style:writing-mode="lr-tb"/>
   <style:text-properties style:use-window-font-color="true" loext:opacity="0%" style:font-name="Liberation Serif" fo:font-size="12pt" fo:language="en" fo:country="US" style:letter-kerning="true" style:font-name-asian="Source Han Sans CN Regular" style:font-size-asian="10.5pt" style:language-asian="zh" style:country-asian="CN" style:font-name-complex="Lohit Devanagari" style:font-size-complex="12pt" style:language-complex="hi" style:country-complex="IN" fo:hyphenate="false" fo:hyphenation-remain-char-count="2" fo:hyphenation-push-char-count="2" loext:hyphenation-no-caps="false"/>
  </style:default-style>
  <style:default-style style:family="table">
   <style:table-properties table:border-model="collapsing"/>
  </style:default-style>
  <style:default-style style:family="table-row">
   <style:table-row-properties fo:keep-together="auto"/>
  </style:default-style>
  <style:style style:name="Standard" style:family="paragraph" style:class="text">
   <style:paragraph-properties fo:orphans="0" fo:widows="0" style:writing-mode="lr-tb"/>
   <style:text-properties style:use-window-font-color="true" loext:opacity="0%" style:font-name="Times New Roman" fo:font-family="&apos;Times New Roman&apos;" style:font-family-generic="roman" style:font-pitch="variable" fo:font-size="11pt" fo:language="en" fo:country="US" style:font-name-asian="Times New Roman" style:font-family-asian="&apos;Times New Roman&apos;" style:font-family-generic-asian="roman" style:font-pitch-asian="variable" style:font-size-asian="11pt" style:font-name-complex="Times New Roman" style:font-family-complex="&apos;Times New Roman&apos;" style:font-family-generic-complex="roman" style:font-pitch-complex="variable" style:font-size-complex="10pt" style:language-complex="ar" style:country-complex="SA"/>
  </style:style>
  <style:style style:name="Heading" style:family="paragraph" style:parent-style-name="Standard" style:next-style-name="Standard" style:default-outline-level="1" style:list-style-name="" style:class="text">
   <style:paragraph-properties fo:margin-top="0.1665in" fo:margin-bottom="0.0417in" style:contextual-spacing="false" fo:text-align="center" style:justify-single-word="false"/>
   <style:text-properties style:font-name="Arial" fo:font-family="Arial" style:font-family-generic="swiss" style:font-pitch="variable" fo:font-size="16pt" fo:font-weight="bold" style:letter-kerning="true" style:font-size-asian="16pt" style:font-weight-asian="bold" style:font-name-complex="Arial" style:font-family-complex="Arial" style:font-family-generic-complex="swiss" style:font-pitch-complex="variable" style:font-size-complex="16pt" style:font-weight-complex="bold"/>
  </style:style>
  <style:style style:name="Text_20_body" style:display-name="Text body" style:family="paragraph" style:parent-style-name="Standard" style:class="text">
   <style:paragraph-properties fo:margin-top="0in" fo:margin-bottom="0.0972in" style:contextual-spacing="false" fo:line-height="115%"/>
  </style:style>
  <style:style style:name="List" style:family="paragraph" style:parent-style-name="Text_20_body" style:class="list">
   <style:text-properties style:font-size-asian="12pt" style:font-name-complex="Lucida Sans" style:font-family-complex="&apos;Lucida Sans&apos;" style:font-family-generic-complex="swiss"/>
  </style:style>
  <style:style style:name="Caption" style:family="paragraph" style:parent-style-name="Standard" style:class="extra">
   <style:paragraph-properties fo:margin-top="0.0835in" fo:margin-bottom="0.0835in" style:contextual-spacing="false" text:number-lines="false" text:line-number="0"/>
   <style:text-properties fo:font-size="12pt" fo:font-style="italic" style:font-size-asian="12pt" style:font-style-asian="italic" style:font-name-complex="Lucida Sans" style:font-family-complex="&apos;Lucida Sans&apos;" style:font-family-generic-complex="swiss" style:font-size-complex="12pt" style:font-style-complex="italic"/>
  </style:style>
  <style:style style:name="Index" style:family="paragraph" style:parent-style-name="Standard" style:class="index">
   <style:paragraph-properties text:number-lines="false" text:line-number="0"/>
   <style:text-properties fo:language="zxx" fo:country="none" style:font-size-asian="12pt" style:language-asian="zxx" style:country-asian="none" style:font-name-complex="Lucida Sans" style:font-family-complex="&apos;Lucida Sans&apos;" style:font-family-generic-complex="swiss" style:language-complex="zxx" style:country-complex="none"/>
  </style:style>
  <style:style style:name="Header_20_and_20_Footer" style:display-name="Header and Footer" style:family="paragraph" style:parent-style-name="Standard" style:class="extra">
   <style:paragraph-properties text:number-lines="false" text:line-number="0">
    <style:tab-stops>
     <style:tab-stop style:position="3.4626in" style:type="center"/>
     <style:tab-stop style:position="6.9252in" style:type="right"/>
    </style:tab-stops>
   </style:paragraph-properties>
  </style:style>
  <style:style style:name="Footer" style:family="paragraph" style:parent-style-name="Standard" style:class="extra">
   <style:paragraph-properties>
    <style:tab-stops>
     <style:tab-stop style:position="2.8752in" style:type="center"/>
     <style:tab-stop style:position="5.75in" style:type="right"/>
    </style:tab-stops>
   </style:paragraph-properties>
   <style:text-properties fo:color="#ff0000" loext:opacity="100%" style:font-name="Times" fo:font-family="Times" style:font-family-generic="roman" style:font-pitch="variable" fo:font-size="6pt" style:font-size-asian="6pt" style:font-name-complex="Times" style:font-family-complex="Times" style:font-family-generic-complex="roman" style:font-pitch-complex="variable"/>
  </style:style>
  <style:style style:name="Header" style:family="paragraph" style:parent-style-name="Standard" style:class="extra">
   <style:paragraph-properties>
    <style:tab-stops>
     <style:tab-stop style:position="3in" style:type="center"/>
     <style:tab-stop style:position="6in" style:type="right"/>
    </style:tab-stops>
   </style:paragraph-properties>
  </style:style>
  <style:style style:name="Title" style:family="paragraph" style:parent-style-name="Heading" style:class="chapter">
   <style:paragraph-properties fo:text-align="center" style:justify-single-word="false"/>
   <style:text-properties style:font-name="Times New Roman1" fo:font-family="&apos;Times New Roman&apos;" style:font-style-name="Bold" style:font-family-generic="roman" style:font-pitch="variable" fo:font-size="20pt" fo:font-weight="bold" style:font-size-asian="28pt" style:font-weight-asian="bold" style:font-size-complex="28pt" style:font-weight-complex="bold"/>
  </style:style>
  <style:style style:name="Subtitle" style:family="paragraph" style:parent-style-name="Heading" style:class="chapter">
   <style:paragraph-properties fo:margin-top="0.0417in" fo:margin-bottom="0.0835in" style:contextual-spacing="false" fo:text-align="center" style:justify-single-word="false"/>
   <style:text-properties style:font-name="Times New Roman1" fo:font-family="&apos;Times New Roman&apos;" style:font-style-name="Bold" style:font-family-generic="roman" style:font-pitch="variable" fo:font-size="18pt" style:font-size-asian="18pt" style:font-size-complex="18pt"/>
  </style:style>
  <style:style style:name="Quotations" style:family="paragraph" style:parent-style-name="Standard" style:class="html">
   <style:paragraph-properties fo:margin-left="0.3937in" fo:margin-right="0.3937in" fo:margin-top="0in" fo:margin-bottom="0.1965in" style:contextual-spacing="false" fo:text-indent="0in" style:auto-text-indent="false"/>
  </style:style>
  <style:style style:name="Frame_20_contents" style:display-name="Frame contents" style:family="paragraph" style:parent-style-name="Standard" style:class="extra"/>
  <style:style style:name="Internet_20_link" style:display-name="Internet link" style:family="text">
   <style:text-properties fo:color="#0000ff" loext:opacity="100%" style:text-underline-style="solid" style:text-underline-width="auto" style:text-underline-color="font-color"/>
  </style:style>
  <style:style style:name="Bullet_20_Symbols" style:display-name="Bullet Symbols" style:family="text">
   <style:text-properties style:font-name="OpenSymbol" fo:font-family="OpenSymbol" style:font-charset="x-symbol" style:font-name-asian="OpenSymbol" style:font-family-asian="OpenSymbol" style:font-charset-asian="x-symbol" style:font-name-complex="OpenSymbol" style:font-family-complex="OpenSymbol" style:font-charset-complex="x-symbol"/>
  </style:style>
  <style:style style:name="Visited_20_Internet_20_Link" style:display-name="Visited Internet Link" style:family="text">
   <style:text-properties fo:color="#800000" loext:opacity="100%" fo:language="zxx" fo:country="none" style:text-underline-style="solid" style:text-underline-width="auto" style:text-underline-color="font-color" style:language-asian="zxx" style:country-asian="none" style:language-complex="zxx" style:country-complex="none"/>
  </style:style>
  <style:style style:name="Frame" style:family="graphic">
   <style:graphic-properties text:anchor-type="paragraph" svg:x="0in" svg:y="0in" style:wrap="parallel" style:number-wrapped-paragraphs="no-limit" style:wrap-contour="false" style:vertical-pos="top" style:vertical-rel="paragraph-content" style:horizontal-pos="center" style:horizontal-rel="paragraph-content"/>
  </style:style>
  <style:style style:name="Graphics" style:family="graphic">
   <style:graphic-properties text:anchor-type="paragraph" svg:x="0in" svg:y="0in" style:wrap="dynamic" style:number-wrapped-paragraphs="no-limit" style:wrap-contour="false" style:vertical-pos="top" style:vertical-rel="paragraph" style:horizontal-pos="center" style:horizontal-rel="paragraph"/>
  </style:style>
  <style:style style:name="OLE" style:family="graphic">
   <style:graphic-properties text:anchor-type="paragraph" svg:x="0in" svg:y="0in" style:wrap="dynamic" style:number-wrapped-paragraphs="no-limit" style:wrap-contour="false" style:vertical-pos="top" style:vertical-rel="paragraph" style:horizontal-pos="center" style:horizontal-rel="paragraph"/>
  </style:style>
  <text:outline-style style:name="Outline">
   <text:outline-level-style text:level="1" loext:num-list-format="%1%" style:num-format="">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab" text:list-tab-stop-position="0.3in" fo:text-indent="-0.3in" fo:margin-left="0.3in"/>
    </style:list-level-properties>
   </text:outline-level-style>
   <text:outline-level-style text:level="2" loext:num-list-format="%2%" style:num-format="">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab" text:list-tab-stop-position="0.4in" fo:text-indent="-0.4in" fo:margin-left="0.4in"/>
    </style:list-level-properties>
   </text:outline-level-style>
   <text:outline-level-style text:level="3" loext:num-list-format="%3%" style:num-format="">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab" text:list-tab-stop-position="0.5in" fo:text-indent="-0.5in" fo:margin-left="0.5in"/>
    </style:list-level-properties>
   </text:outline-level-style>
   <text:outline-level-style text:level="4" loext:num-list-format="%4%" style:num-format="">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab" text:list-tab-stop-position="0.6in" fo:text-indent="-0.6in" fo:margin-left="0.6in"/>
    </style:list-level-properties>
   </text:outline-level-style>
   <text:outline-level-style text:level="5" loext:num-list-format="%5%" style:num-format="">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab" text:list-tab-stop-position="0.7in" fo:text-indent="-0.7in" fo:margin-left="0.7in"/>
    </style:list-level-properties>
   </text:outline-level-style>
   <text:outline-level-style text:level="6" loext:num-list-format="%6%" style:num-format="">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab" text:list-tab-stop-position="0.8in" fo:text-indent="-0.8in" fo:margin-left="0.8in"/>
    </style:list-level-properties>
   </text:outline-level-style>
   <text:outline-level-style text:level="7" loext:num-list-format="%7%" style:num-format="">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab" text:list-tab-stop-position="0.9in" fo:text-indent="-0.9in" fo:margin-left="0.9in"/>
    </style:list-level-properties>
   </text:outline-level-style>
   <text:outline-level-style text:level="8" loext:num-list-format="%8%" style:num-format="">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab" text:list-tab-stop-position="1in" fo:text-indent="-1in" fo:margin-left="1in"/>
    </style:list-level-properties>
   </text:outline-level-style>
   <text:outline-level-style text:level="9" loext:num-list-format="%9%" style:num-format="">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab" text:list-tab-stop-position="1.1in" fo:text-indent="-1.1in" fo:margin-left="1.1in"/>
    </style:list-level-properties>
   </text:outline-level-style>
   <text:outline-level-style text:level="10" loext:num-list-format="%10%" style:num-format="">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab" text:list-tab-stop-position="1.2in" fo:text-indent="-1.2in" fo:margin-left="1.2in"/>
    </style:list-level-properties>
   </text:outline-level-style>
  </text:outline-style>
  <text:notes-configuration text:note-class="footnote" style:num-format="1" text:start-value="0" text:footnotes-position="page" text:start-numbering-at="document"/>
  <text:notes-configuration text:note-class="endnote" style:num-format="i" text:start-value="0"/>
  <text:linenumbering-configuration text:number-lines="false" text:offset="0.1965in" style:num-format="1" text:number-position="left" text:increment="5"/>
  <style:default-page-layout>
   <style:page-layout-properties style:writing-mode="lr-tb" style:layout-grid-standard-mode="true"/>
  </style:default-page-layout>
 </office:styles>
 <office:automatic-styles>
  <style:style style:name="P1" style:family="paragraph" style:parent-style-name="Footer">
   <style:paragraph-properties fo:line-height="0.139in"/>
  </style:style>
  <style:style style:name="P2" style:family="paragraph" style:parent-style-name="Footer">
   <style:paragraph-properties fo:line-height="0.139in"/>
   <style:text-properties fo:font-size="9.5pt" style:font-size-asian="9.5pt"/>
  </style:style>
  <style:style style:name="P3" style:family="paragraph" style:parent-style-name="Footer">
   <style:paragraph-properties fo:line-height="0.139in"/>
  </style:style>
  <style:style style:name="P4" style:family="paragraph" style:parent-style-name="Footer">
   <style:paragraph-properties fo:line-height="0.139in"/>
   <style:text-properties fo:font-size="9.5pt" style:font-size-asian="9.5pt"/>
  </style:style>
  <style:style style:name="P5" style:family="paragraph" style:parent-style-name="Standard">
   <style:text-properties officeooo:paragraph-rsid="004e0489"/>
  </style:style>
  <style:style style:name="P6" style:family="paragraph" style:parent-style-name="Standard">
   <style:text-properties officeooo:paragraph-rsid="0053ec82"/>
  </style:style>
  <style:style style:name="P7" style:family="paragraph" style:parent-style-name="Standard">
   <style:text-properties officeooo:rsid="0053ec82" officeooo:paragraph-rsid="0053ec82"/>
  </style:style>
  <style:style style:name="P8" style:family="paragraph" style:parent-style-name="Standard">
   <style:text-properties officeooo:rsid="00553f12" officeooo:paragraph-rsid="00553f12"/>
  </style:style>
  <style:style style:name="P9" style:family="paragraph" style:parent-style-name="Standard">
   <style:text-properties officeooo:paragraph-rsid="005732ba"/>
  </style:style>
  <style:style style:name="P10" style:family="paragraph" style:parent-style-name="Subtitle">
   <style:text-properties officeooo:paragraph-rsid="005732ba"/>
  </style:style>
  <style:style style:name="P11" style:family="paragraph" style:parent-style-name="Standard">
   <style:text-properties officeooo:paragraph-rsid="004f76bd"/>
  </style:style>
  <style:style style:name="P12" style:family="paragraph" style:parent-style-name="Standard">
   <style:text-properties style:use-window-font-color="true" loext:opacity="0%" style:font-name="Times New Roman" fo:font-size="11pt" fo:language="en" fo:country="US" officeooo:rsid="0053ec82" officeooo:paragraph-rsid="005732ba" style:font-name-asian="Times New Roman" style:font-size-asian="11pt" style:font-name-complex="Times New Roman" style:font-size-complex="10pt" style:language-complex="ar" style:country-complex="SA"/>
  </style:style>
  <style:style style:name="P13" style:family="paragraph" style:parent-style-name="Standard">
   <style:text-properties style:use-window-font-color="true" loext:opacity="0%" style:font-name="Times New Roman" fo:font-size="11pt" fo:language="en" fo:country="US" officeooo:rsid="0053ec82" officeooo:paragraph-rsid="0053ec82" style:font-name-asian="Times New Roman" style:font-size-asian="11pt" style:font-name-complex="Times New Roman" style:font-size-complex="10pt" style:language-complex="ar" style:country-complex="SA"/>
  </style:style>
  <style:style style:name="P14" style:family="paragraph" style:parent-style-name="Standard">
   <style:text-properties style:use-window-font-color="true" loext:opacity="0%" style:font-name="Times New Roman" fo:font-size="11pt" fo:language="en" fo:country="US" officeooo:rsid="0053ec82" officeooo:paragraph-rsid="00553f12" style:font-name-asian="Times New Roman" style:font-size-asian="11pt" style:font-name-complex="Times New Roman" style:font-size-complex="10pt" style:language-complex="ar" style:country-complex="SA"/>
  </style:style>
  <style:style style:name="P15" style:family="paragraph" style:parent-style-name="Standard">
   <style:paragraph-properties fo:orphans="0" fo:widows="0" style:writing-mode="lr-tb"/>
   <style:text-properties style:use-window-font-color="true" loext:opacity="0%" style:font-name="Times New Roman" fo:font-size="11pt" fo:language="en" fo:country="US" officeooo:rsid="0053ec82" officeooo:paragraph-rsid="0053ec82" style:font-name-asian="Times New Roman" style:font-size-asian="11pt" style:font-name-complex="Times New Roman" style:font-size-complex="10pt" style:language-complex="ar" style:country-complex="SA"/>
  </style:style>
  <style:style style:name="P16" style:family="paragraph" style:parent-style-name="Standard">
   <style:text-properties fo:font-variant="normal" fo:text-transform="none" style:use-window-font-color="true" loext:opacity="0%" style:font-name="Times New Roman" fo:font-size="11pt" fo:letter-spacing="normal" fo:language="en" fo:country="US" fo:font-style="normal" fo:font-weight="normal" officeooo:rsid="0056425b" officeooo:paragraph-rsid="005732ba" style:font-name-asian="Times New Roman" style:font-size-asian="11pt" style:font-name-complex="Times New Roman" style:font-size-complex="10pt" style:language-complex="ar" style:country-complex="SA"/>
  </style:style>
  <style:style style:name="P17" style:family="paragraph" style:parent-style-name="Standard">
   <style:paragraph-properties fo:orphans="0" fo:widows="0" style:writing-mode="lr-tb"/>
  </style:style>
  <style:style style:name="P18" style:family="paragraph" style:parent-style-name="Standard">
   <style:paragraph-properties fo:orphans="0" fo:widows="0" style:writing-mode="lr-tb"/>
   <style:text-properties officeooo:paragraph-rsid="0053ec82"/>
  </style:style>
  <style:style style:name="P19" style:family="paragraph" style:parent-style-name="Subtitle">
   <style:text-properties fo:font-size="16pt" style:font-size-asian="16pt" style:font-size-complex="16pt"/>
  </style:style>
  <style:style style:name="P20" style:family="paragraph" style:parent-style-name="Subtitle">
   <style:text-properties fo:font-size="16pt" officeooo:paragraph-rsid="005732ba" style:font-size-asian="16pt" style:font-size-complex="16pt"/>
  </style:style>
  <style:style style:name="P21" style:family="paragraph" style:parent-style-name="Title">
   <style:text-properties fo:font-size="20pt" style:font-size-asian="20pt" style:font-size-complex="20pt"/>
  </style:style>
  <style:style style:name="P22" style:family="paragraph" style:parent-style-name="Standard" style:list-style-name="L1"/>
  <style:style style:name="T1" style:family="text">
   <style:text-properties fo:font-size="9.5pt" style:font-size-asian="9.5pt"/>
  </style:style>
  <style:style style:name="T2" style:family="text">
   <style:text-properties fo:font-weight="bold" style:font-weight-asian="bold" style:font-weight-complex="bold"/>
  </style:style>
  <style:style style:name="T3" style:family="text">
   <style:text-properties fo:font-weight="bold" officeooo:rsid="0049daac" style:font-weight-asian="bold" style:font-weight-complex="bold"/>
  </style:style>
  <style:style style:name="T4" style:family="text">
   <style:text-properties fo:font-weight="bold" officeooo:rsid="005e7766" style:font-weight-asian="bold" style:font-weight-complex="bold"/>
  </style:style>
  <style:style style:name="T5" style:family="text">
   <style:text-properties officeooo:rsid="0049daac"/>
  </style:style>
  <style:style style:name="T6" style:family="text">
   <style:text-properties officeooo:rsid="004ab568"/>
  </style:style>
  <style:style style:name="T7" style:family="text">
   <style:text-properties officeooo:rsid="004bd6bd"/>
  </style:style>
  <style:style style:name="T8" style:family="text">
   <style:text-properties style:use-window-font-color="true" loext:opacity="0%" style:font-name="Times New Roman" fo:font-size="11pt" fo:language="en" fo:country="US" officeooo:rsid="004bd6bd" style:font-name-asian="Times New Roman" style:font-size-asian="11pt" style:font-name-complex="Times New Roman" style:font-size-complex="10pt" style:language-complex="ar" style:country-complex="SA"/>
  </style:style>
  <style:style style:name="T9" style:family="text">
   <style:text-properties style:use-window-font-color="true" loext:opacity="0%" style:font-name="Times New Roman" fo:font-size="11pt" fo:language="en" fo:country="US" officeooo:rsid="0053ec82" style:font-name-asian="Times New Roman" style:font-size-asian="11pt" style:font-name-complex="Times New Roman" style:font-size-complex="10pt" style:language-complex="ar" style:country-complex="SA"/>
  </style:style>
  <style:style style:name="T10" style:family="text">
   <style:text-properties style:use-window-font-color="true" loext:opacity="0%" style:font-name="Times New Roman" fo:font-size="11pt" fo:language="en" fo:country="US" officeooo:rsid="0053ed15" style:font-name-asian="Times New Roman" style:font-size-asian="11pt" style:font-name-complex="Times New Roman" style:font-size-complex="10pt" style:language-complex="ar" style:country-complex="SA"/>
  </style:style>
  <style:style style:name="T11" style:family="text">
   <style:text-properties style:use-window-font-color="true" loext:opacity="0%" style:font-name="Times New Roman" fo:font-size="11pt" fo:language="en" fo:country="US" officeooo:rsid="00553f12" style:font-name-asian="Times New Roman" style:font-size-asian="11pt" style:font-name-complex="Times New Roman" style:font-size-complex="10pt" style:language-complex="ar" style:country-complex="SA"/>
  </style:style>
  <style:style style:name="T12" style:family="text">
   <style:text-properties style:use-window-font-color="true" loext:opacity="0%" style:font-name="Times New Roman" fo:font-size="11pt" fo:language="en" fo:country="US" officeooo:rsid="0056425b" style:font-name-asian="Times New Roman" style:font-size-asian="11pt" style:font-name-complex="Times New Roman" style:font-size-complex="10pt" style:language-complex="ar" style:country-complex="SA"/>
  </style:style>
  <style:style style:name="T13" style:family="text">
   <style:text-properties style:use-window-font-color="true" loext:opacity="0%" style:font-name="Times New Roman" fo:font-size="11pt" fo:language="en" fo:country="US" officeooo:rsid="005732ba" style:font-name-asian="Times New Roman" style:font-size-asian="11pt" style:font-name-complex="Times New Roman" style:font-size-complex="10pt" style:language-complex="ar" style:country-complex="SA"/>
  </style:style>
  <style:style style:name="T14" style:family="text">
   <style:text-properties style:use-window-font-color="true" loext:opacity="0%" style:font-name="Times New Roman" fo:font-size="11pt" fo:language="en" fo:country="US" officeooo:rsid="00580212" style:font-name-asian="Times New Roman" style:font-size-asian="11pt" style:font-name-complex="Times New Roman" style:font-size-complex="10pt" style:language-complex="ar" style:country-complex="SA"/>
  </style:style>
  <style:style style:name="T15" style:family="text">
   <style:text-properties style:use-window-font-color="true" loext:opacity="0%" style:font-name="Times New Roman" fo:font-size="11pt" fo:language="en" fo:country="US" officeooo:rsid="005b434a" style:font-name-asian="Times New Roman" style:font-size-asian="11pt" style:font-name-complex="Times New Roman" style:font-size-complex="10pt" style:language-complex="ar" style:country-complex="SA"/>
  </style:style>
  <style:style style:name="T16" style:family="text">
   <style:text-properties style:use-window-font-color="true" loext:opacity="0%" style:text-position="super 58%" style:font-name="Times New Roman" fo:font-size="11pt" fo:language="en" fo:country="US" officeooo:rsid="0056425b" style:font-name-asian="Times New Roman" style:font-size-asian="11pt" style:font-name-complex="Times New Roman" style:font-size-complex="10pt" style:language-complex="ar" style:country-complex="SA"/>
  </style:style>
  <style:style style:name="T17" style:family="text">
   <style:text-properties style:use-window-font-color="true" loext:opacity="0%" style:font-name="Times New Roman1" fo:font-size="18pt" fo:language="en" fo:country="US" fo:font-weight="bold" officeooo:rsid="005994ea" style:letter-kerning="true" style:font-name-asian="Times New Roman" style:font-size-asian="18pt" style:font-weight-asian="bold" style:font-name-complex="Arial" style:font-size-complex="18pt" style:language-complex="ar" style:country-complex="SA" style:font-weight-complex="bold"/>
  </style:style>
  <style:style style:name="T18" style:family="text">
   <style:text-properties style:use-window-font-color="true" loext:opacity="0%" style:font-name="Times New Roman1" fo:language="en" fo:country="US" fo:font-weight="bold" officeooo:rsid="005994ea" style:letter-kerning="true" style:font-name-asian="Times New Roman" style:font-weight-asian="bold" style:font-name-complex="Arial" style:language-complex="ar" style:country-complex="SA" style:font-weight-complex="bold"/>
  </style:style>
  <style:style style:name="T19" style:family="text">
   <style:text-properties officeooo:rsid="004c6593"/>
  </style:style>
  <style:style style:name="T20" style:family="text">
   <style:text-properties officeooo:rsid="004cd03c"/>
  </style:style>
  <style:style style:name="T21" style:family="text">
   <style:text-properties officeooo:rsid="004e0489"/>
  </style:style>
  <style:style style:name="T22" style:family="text">
   <style:text-properties officeooo:rsid="004f76bd"/>
  </style:style>
  <style:style style:name="T23" style:family="text">
   <style:text-properties officeooo:rsid="00515e90"/>
  </style:style>
  <style:style style:name="T24" style:family="text">
   <style:text-properties officeooo:rsid="005223f1"/>
  </style:style>
  <style:style style:name="T25" style:family="text">
   <style:text-properties style:text-position="super 58%" officeooo:rsid="005223f1"/>
  </style:style>
  <style:style style:name="T26" style:family="text">
   <style:text-properties officeooo:rsid="0053ec82"/>
  </style:style>
  <style:style style:name="T27" style:family="text">
   <style:text-properties fo:font-variant="normal" fo:text-transform="none" style:use-window-font-color="true" loext:opacity="0%" style:font-name="Times New Roman" fo:font-size="11pt" fo:letter-spacing="normal" fo:language="en" fo:country="US" fo:font-style="normal" fo:font-weight="normal" officeooo:rsid="0056425b" style:font-name-asian="Times New Roman" style:font-size-asian="11pt" style:font-name-complex="Times New Roman" style:font-size-complex="10pt" style:language-complex="ar" style:country-complex="SA"/>
  </style:style>
  <style:style style:name="T28" style:family="text">
   <style:text-properties officeooo:rsid="005732ba"/>
  </style:style>
  <style:style style:name="T29" style:family="text">
   <style:text-properties officeooo:rsid="00580212"/>
  </style:style>
  <style:style style:name="T30" style:family="text">
   <style:text-properties officeooo:rsid="005994ea"/>
  </style:style>
  <style:style style:name="T31" style:family="text">
   <style:text-properties officeooo:rsid="005c24eb"/>
  </style:style>
  <style:style style:name="fr1" style:family="graphic" style:parent-style-name="Frame">
   <style:graphic-properties style:vertical-pos="top" style:vertical-rel="paragraph-content" style:horizontal-pos="center" style:horizontal-rel="paragraph-content"/>
  </style:style>
  <text:list-style style:name="L1">
   <text:list-level-style-bullet text:level="1" text:style-name="Bullet_20_Symbols" loext:num-list-format="%1%" text:bullet-char="•">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab" text:list-tab-stop-position="0.5in" fo:text-indent="-0.25in" fo:margin-left="0.5in"/>
    </style:list-level-properties>
   </text:list-level-style-bullet>
   <text:list-level-style-number text:level="2" loext:num-list-format="%2%." style:num-suffix="." style:num-format="1">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab" text:list-tab-stop-position="0.75in" fo:text-indent="-0.25in" fo:margin-left="0.75in"/>
    </style:list-level-properties>
   </text:list-level-style-number>
   <text:list-level-style-number text:level="3" loext:num-list-format="%3%." style:num-suffix="." style:num-format="1">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab" text:list-tab-stop-position="1in" fo:text-indent="-0.25in" fo:margin-left="1in"/>
    </style:list-level-properties>
   </text:list-level-style-number>
   <text:list-level-style-number text:level="4" loext:num-list-format="%4%." style:num-suffix="." style:num-format="1">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab" text:list-tab-stop-position="1.25in" fo:text-indent="-0.25in" fo:margin-left="1.25in"/>
    </style:list-level-properties>
   </text:list-level-style-number>
   <text:list-level-style-number text:level="5" loext:num-list-format="%5%." style:num-suffix="." style:num-format="1">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab" text:list-tab-stop-position="1.5in" fo:text-indent="-0.25in" fo:margin-left="1.5in"/>
    </style:list-level-properties>
   </text:list-level-style-number>
   <text:list-level-style-number text:level="6" loext:num-list-format="%6%." style:num-suffix="." style:num-format="1">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab" text:list-tab-stop-position="1.75in" fo:text-indent="-0.25in" fo:margin-left="1.75in"/>
    </style:list-level-properties>
   </text:list-level-style-number>
   <text:list-level-style-number text:level="7" loext:num-list-format="%7%." style:num-suffix="." style:num-format="1">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab" text:list-tab-stop-position="2in" fo:text-indent="-0.25in" fo:margin-left="2in"/>
    </style:list-level-properties>
   </text:list-level-style-number>
   <text:list-level-style-number text:level="8" loext:num-list-format="%8%." style:num-suffix="." style:num-format="1">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab" text:list-tab-stop-position="2.25in" fo:text-indent="-0.25in" fo:margin-left="2.25in"/>
    </style:list-level-properties>
   </text:list-level-style-number>
   <text:list-level-style-number text:level="9" loext:num-list-format="%9%." style:num-suffix="." style:num-format="1">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab" text:list-tab-stop-position="2.5in" fo:text-indent="-0.25in" fo:margin-left="2.5in"/>
    </style:list-level-properties>
   </text:list-level-style-number>
   <text:list-level-style-number text:level="10" loext:num-list-format="%10%." style:num-suffix="." style:num-format="1">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab" text:list-tab-stop-position="2.75in" fo:text-indent="-0.25in" fo:margin-left="2.75in"/>
    </style:list-level-properties>
   </text:list-level-style-number>
  </text:list-style>
  <style:page-layout style:name="pm1">
   <style:page-layout-properties fo:page-width="8.5in" fo:page-height="11in" style:num-format="1" style:print-orientation="portrait" fo:margin-top="0.5in" fo:margin-bottom="0.5in" fo:margin-left="0.8in" fo:margin-right="0.8in" style:writing-mode="lr-tb" style:layout-grid-color="#c0c0c0" style:layout-grid-lines="40" style:layout-grid-base-height="0.25in" style:layout-grid-ruby-height="0in" style:layout-grid-mode="none" style:layout-grid-ruby-below="false" style:layout-grid-print="false" style:layout-grid-display="false" style:layout-grid-base-width="0.1528in" style:layout-grid-snap-to="true" style:footnote-max-height="0in" loext:margin-gutter="0in">
    <style:footnote-sep style:width="0.0071in" style:distance-before-sep="0.0398in" style:distance-after-sep="0.0398in" style:line-style="solid" style:adjustment="left" style:rel-width="25%" style:color="#000000"/>
   </style:page-layout-properties>
   <style:header-style>
    <style:header-footer-properties fo:min-height="0.25in" fo:margin-left="0in" fo:margin-right="0in" fo:margin-bottom="0.211in" style:dynamic-spacing="true"/>
   </style:header-style>
   <style:footer-style>
    <style:header-footer-properties fo:min-height="0.5in" fo:margin-left="0in" fo:margin-right="0in" fo:margin-top="0.461in" style:dynamic-spacing="true"/>
   </style:footer-style>
  </style:page-layout>
  <style:style style:name="dp1" style:family="drawing-page">
   <style:drawing-page-properties draw:background-size="full"/>
  </style:style>
 </office:automatic-styles>
 <office:master-styles>
  <style:master-page style:name="Standard" style:page-layout-name="pm1" draw:style-name="dp1">
   <style:header>
    <text:p text:style-name="Header"/>
   </style:header>
   <style:header-first>
    <text:p text:style-name="Header"><text:tab/><text:tab/></text:p>
   </style:header-first>
   <style:footer>
    <text:p text:style-name="P1"><draw:frame draw:style-name="fr1" draw:name="Frame1" text:anchor-type="paragraph" draw:z-index="3">
      <draw:text-box fo:min-height="0.0228in" fo:min-width="0.0161in">
       <text:p text:style-name="P2"><text:page-number text:select-page="current">5</text:page-number></text:p>
      </draw:text-box>
     </draw:frame></text:p>
   </style:footer>
   <style:footer-first>
    <text:p text:style-name="Footer"/>
   </style:footer-first>
  </style:master-page>
 </office:master-styles>
 <office:body>
  <office:text text:use-soft-page-breaks="true">
   <office:forms form:automatic-focus="false" form:apply-design-mode="false"/>
   <text:tracked-changes text:track-changes="false">
    <text:changed-region xml:id="ct94743512384976" text:id="ct94743512384976">
     <text:insertion>
      <office:change-info>
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2022-03-22T03:32:18</dc:date>
      </office:change-info>
     </text:insertion>
    </text:changed-region>
    <text:changed-region xml:id="ct94743512384496" text:id="ct94743512384496">
     <text:deletion>
      <office:change-info>
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2022-03-22T03:31:41</dc:date>
      </office:change-info>
     </text:deletion>
    </text:changed-region>
    <text:changed-region xml:id="ct94743551696464" text:id="ct94743551696464">
     <text:insertion>
      <office:change-info>
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2022-03-22T03:31:42</dc:date>
      </office:change-info>
     </text:insertion>
    </text:changed-region>
    <text:changed-region xml:id="ct94743602991344" text:id="ct94743602991344">
     <text:deletion>
      <office:change-info>
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2022-03-22T03:31:45</dc:date>
      </office:change-info>
     </text:deletion>
    </text:changed-region>
    <text:changed-region xml:id="ct94743414946336" text:id="ct94743414946336">
     <text:deletion>
      <office:change-info>
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2022-03-22T03:32:29</dc:date>
      </office:change-info>
     </text:deletion>
    </text:changed-region>
    <text:changed-region xml:id="ct94743604729408" text:id="ct94743604729408">
     <text:insertion>
      <office:change-info>
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2022-03-22T03:32:53</dc:date>
      </office:change-info>
     </text:insertion>
    </text:changed-region>
    <text:changed-region xml:id="ct94743415022112" text:id="ct94743415022112">
     <text:deletion>
      <office:change-info>
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2022-03-22T03:32:46</dc:date>
      </office:change-info>
     </text:deletion>
    </text:changed-region>
    <text:changed-region xml:id="ct94743605420704" text:id="ct94743605420704">
     <text:insertion>
      <office:change-info>
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2022-03-22T03:32:47</dc:date>
      </office:change-info>
     </text:insertion>
    </text:changed-region>
    <text:changed-region xml:id="ct94743551493504" text:id="ct94743551493504">
     <text:insertion>
      <office:change-info>
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2022-03-22T03:33:37</dc:date>
      </office:change-info>
     </text:insertion>
    </text:changed-region>
    <text:changed-region xml:id="ct94743597638464" text:id="ct94743597638464">
     <text:deletion>
      <office:change-info>
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2022-03-22T03:33:50</dc:date>
      </office:change-info>
     </text:deletion>
    </text:changed-region>
    <text:changed-region xml:id="ct94743551209376" text:id="ct94743551209376">
     <text:insertion>
      <office:change-info>
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2022-03-22T03:33:52</dc:date>
      </office:change-info>
     </text:insertion>
    </text:changed-region>
    <text:changed-region xml:id="ct94743492270816" text:id="ct94743492270816">
     <text:deletion>
      <office:change-info>
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2022-03-22T03:34:45</dc:date>
      </office:change-info>
     </text:deletion>
    </text:changed-region>
    <text:changed-region xml:id="ct94743493432928" text:id="ct94743493432928">
     <text:insertion>
      <office:change-info>
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2022-03-22T03:34:45</dc:date>
      </office:change-info>
     </text:insertion>
    </text:changed-region>
    <text:changed-region xml:id="ct94743511062496" text:id="ct94743511062496">
     <text:deletion>
      <office:change-info>
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2022-03-22T03:36:25</dc:date>
      </office:change-info>
     </text:deletion>
    </text:changed-region>
    <text:changed-region xml:id="ct94743493504672" text:id="ct94743493504672">
     <text:insertion>
      <office:change-info>
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2022-03-22T03:36:25</dc:date>
      </office:change-info>
     </text:insertion>
    </text:changed-region>
    <text:changed-region xml:id="ct94743510384400" text:id="ct94743510384400">
     <text:insertion>
      <office:change-info>
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2022-03-22T03:31:10</dc:date>
      </office:change-info>
     </text:insertion>
    </text:changed-region>
    <text:changed-region xml:id="ct94743600844320" text:id="ct94743600844320">
     <text:insertion>
      <office:change-info>
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2022-03-22T03:31:10</dc:date>
      </office:change-info>
     </text:insertion>
    </text:changed-region>
    <text:changed-region xml:id="ct94743553241088" text:id="ct94743553241088">
     <text:insertion>
      <office:change-info>
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2022-03-22T03:31:10</dc:date>
      </office:change-info>
     </text:insertion>
    </text:changed-region>
    <text:changed-region xml:id="ct94743400384432" text:id="ct94743400384432">
     <text:insertion>
      <office:change-info>
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2022-03-22T03:37:13</dc:date>
      </office:change-info>
     </text:insertion>
    </text:changed-region>
    <text:changed-region xml:id="ct94743415409552" text:id="ct94743415409552">
     <text:deletion>
      <office:change-info>
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2022-03-22T03:31:04</dc:date>
      </office:change-info>
     </text:deletion>
    </text:changed-region>
    <text:changed-region xml:id="ct94743510229856" text:id="ct94743510229856">
     <text:deletion>
      <office:change-info>
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2022-03-22T03:30:58</dc:date>
      </office:change-info>
     </text:deletion>
    </text:changed-region>
    <text:changed-region xml:id="ct94743400759344" text:id="ct94743400759344">
     <text:deletion>
      <office:change-info>
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2022-03-22T03:28:39</dc:date>
      </office:change-info>
     </text:deletion>
    </text:changed-region>
    <text:changed-region xml:id="ct94743493494784" text:id="ct94743493494784">
     <text:deletion>
      <office:change-info>
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2022-03-22T03:30:58</dc:date>
      </office:change-info>
     </text:deletion>
    </text:changed-region>
    <text:changed-region xml:id="ct94743605596672" text:id="ct94743605596672">
     <text:deletion>
      <office:change-info>
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2022-03-21T20:33:26</dc:date>
      </office:change-info>
     </text:deletion>
    </text:changed-region>
    <text:changed-region xml:id="ct94743492828224" text:id="ct94743492828224">
     <text:deletion>
      <office:change-info>
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2022-03-21T20:36:45</dc:date>
      </office:change-info>
     </text:deletion>
    </text:changed-region>
   </text:tracked-changes>
   <text:sequence-decls>
    <text:sequence-decl text:display-outline-level="0" text:name="Illustration"/>
    <text:sequence-decl text:display-outline-level="0" text:name="Table"/>
    <text:sequence-decl text:display-outline-level="0" text:name="Text"/>
    <text:sequence-decl text:display-outline-level="0" text:name="Drawing"/>
    <text:sequence-decl text:display-outline-level="0" text:name="Figure"/>
   </text:sequence-decls>
   <text:h text:style-name="P21" text:outline-level="1">Third-Party Open Source Software Used By Npcap</text:h>
   <text:p text:style-name="Standard"/>
   <text:p text:style-name="P5"><text:span text:style-name="T7">Npcap </text:span><text:change-start text:change-id="ct94743512384976"/><text:span text:style-name="T28">(</text:span><text:a xlink:type="simple" xlink:href="https://npcap.com/" text:style-name="Internet_20_link" text:visited-style-name="Visited_20_Internet_20_Link"><text:span text:style-name="T28">https://npcap.com</text:span></text:a><text:span text:style-name="T28">) </text:span><text:change-end text:change-id="ct94743512384976"/><text:span text:style-name="T7">is a software library for packet captu</text:span><text:span text:style-name="T20">re and transmission</text:span><text:span text:style-name="T7"> on the Microsoft Windows platform</text:span><text:change-start text:change-id="ct94743512384496"/><text:span text:style-name="T7">,</text:span><text:change-end text:change-id="ct94743512384496"/><text:change-start text:change-id="ct94743551696464"/><text:span text:style-name="T7">. </text:span><text:change-end text:change-id="ct94743551696464"/><text:change-start text:change-id="ct94743602991344"/><text:span text:style-name="T7"><text:s/>as </text:span><text:change-end text:change-id="ct94743602991344"/><text:change-start text:change-id="ct94743414946336"/><text:span text:style-name="T7">distributed and described at </text:span><text:a xlink:type="simple" xlink:href="https://npcap.com/" text:style-name="Internet_20_link" text:visited-style-name="Visited_20_Internet_20_Link"><text:span text:style-name="T7">https://npcap.com</text:span></text:a><text:span text:style-name="T7">. </text:span><text:change-end text:change-id="ct94743414946336"/><text:span text:style-name="T19">The</text:span><text:span text:style-name="T21">re is a free/demo Npcap which is mostly for personal use, and a commercial </text:span><text:a xlink:type="simple" xlink:href="https://npcap.com/oem/" text:style-name="Internet_20_link" text:visited-style-name="Visited_20_Internet_20_Link"><text:span text:style-name="T20">Npcap OEM Edition</text:span></text:a><text:span text:style-name="T20"> </text:span><text:span text:style-name="T21">for companies who want automated deployment, commercial support, greater internal-use rights, or even to redistribute Npcap OEM with</text:span><text:change-start text:change-id="ct94743604729408"/><text:span text:style-name="T28">in</text:span><text:change-end text:change-id="ct94743604729408"/><text:span text:style-name="T21"> their </text:span><text:change-start text:change-id="ct94743415022112"/><text:span text:style-name="T21">r</text:span><text:change-end text:change-id="ct94743415022112"/><text:span text:style-name="T21">p</text:span><text:change-start text:change-id="ct94743605420704"/><text:span text:style-name="T28">r</text:span><text:change-end text:change-id="ct94743605420704"/><text:span text:style-name="T21">oducts.</text:span></text:p>
   <text:p text:style-name="P5"/>
   <text:p text:style-name="P5"><text:span text:style-name="T7">Npcap </text:span>uses <text:span text:style-name="T29">three</text:span> third-party open source software <text:span text:style-name="T21">components: </text:span><text:span text:style-name="T29">Libpcap, Winpcap, and ieee80211_radiotap.h.</text:span> All <text:span text:style-name="T21">of these </text:span>are open source with BSD-style licenses that allow for unlimited use and royalty-free redistribution within other software (including commercial/proprietary software). Some include a warranty disclaimer (relating to the original authors) and require a small amount of acknowledgment text be added to the documentation of any software which includes them (including indirectly through Npcap). An example of such text <text:change-start text:change-id="ct94743551493504"/><text:span text:style-name="T28">provided in the next section of this document.</text:span><text:change-end text:change-id="ct94743551493504"/><text:change-start text:change-id="ct94743597638464"/><text:span text:style-name="T28">is in the copyright statements section at the end of this document. S</text:span><text:change-end text:change-id="ct94743597638464"/><text:change-start text:change-id="ct94743551209376"/> <text:span text:style-name="T28">S</text:span><text:change-end text:change-id="ct94743551209376"/>ince <text:span text:style-name="T8">Nmap Software</text:span> LLC is not the author of this third-party code, we can not waive or modify its software copyright or license. Npcap users and redistributors must comply with the relevant Npcap license (either the free/demo license or a commercial Npcap OEM license<text:span text:style-name="T21">)</text:span> as well as the fairly minimal requirements of th<text:span text:style-name="T21">e</text:span> third-party open source software <text:span text:style-name="T21">listed </text:span><text:span text:style-name="T29">here. <text:s/>Each of the three components has a section later in this document </text:span><text:span text:style-name="T14">detailing the software and providing its</text:span><text:span text:style-name="T29"> full license text.</text:span></text:p>
   <text:p text:style-name="Standard"/>
   <text:p text:style-name="Standard">Please note that all Npcap support, warranties and indemnification that we (<text:span text:style-name="T8">Nmap Software</text:span> LLC) offer to commercial customers <text:span text:style-name="T21">apply to </text:span>these third-party <text:change-start text:change-id="ct94743492270816"/>libraries along with all <text:change-end text:change-id="ct94743492270816"/><text:change-start text:change-id="ct94743493432928"/><text:span text:style-name="T13">components and all </text:span><text:change-end text:change-id="ct94743493432928"/>other Npcap code. The warranty disclaimers in their license text just mean that the original library authors and maintainers aren’t responsible for that support <text:span text:style-name="T21">you buy from us instead.</text:span></text:p>
   <text:p text:style-name="Standard"/>
   <text:p text:style-name="Standard">This document covers <text:span text:style-name="T2">Npcap version 1.</text:span><text:span text:style-name="T4">71</text:span>. Licensees or potential licensees who want this information for a different N<text:span text:style-name="T5">pc</text:span>ap release should contact <text:a xlink:type="simple" xlink:href="mailto:sales@nmap.com" text:style-name="Internet_20_link" text:visited-style-name="Visited_20_Internet_20_Link">sales@nmap.com</text:a>.</text:p>
   <text:p text:style-name="Standard"/>
   <text:p text:style-name="P11"><text:span text:style-name="T22">Anyone may redistribute this document in whole or part, including incorporating it into larger documents. In particular, redistributing this document along with Npcap OEM (for parties who hold an </text:span><text:a xlink:type="simple" xlink:href="https://npcap.com/oem/redist.html" text:style-name="Internet_20_link" text:visited-style-name="Visited_20_Internet_20_Link"><text:span text:style-name="T22">Npcap OEM Redistribution License</text:span></text:a><text:span text:style-name="T22">) is often helpful to comply with attribution </text:span><text:span text:style-name="T31">and warranty disclaimer </text:span><text:span text:style-name="T22">clauses of the software component licenses detailed </text:span><text:change-start text:change-id="ct94743511062496"/><text:span text:style-name="T22">below</text:span><text:change-end text:change-id="ct94743511062496"/><text:change-start text:change-id="ct94743493504672"/><text:span text:style-name="T13">herein</text:span><text:change-end text:change-id="ct94743493504672"/><text:span text:style-name="T22">.</text:span></text:p>
   <text:p text:style-name="Standard"><text:change-start text:change-id="ct94743510384400"/></text:p>
   <text:h text:style-name="P20" text:outline-level="1"><text:change-end text:change-id="ct94743510384400"/><text:span text:style-name="T18">Suggested</text:span><text:change-start text:change-id="ct94743600844320"/> Acknowledgment Text</text:h>
   <text:p text:style-name="P9"/>
   <text:p text:style-name="P9"><text:span text:style-name="T24">To give credit where due and also comply with attribution clauses of the various 3</text:span><text:span text:style-name="T25">rd</text:span><text:span text:style-name="T24"> party </text:span><text:span text:style-name="T26">software component licenses detailed in this document, we </text:span><text:span text:style-name="T9">suggest that </text:span><text:a xlink:type="simple" xlink:href="https://npcap.com/oem/redist.html" text:style-name="Internet_20_link" text:visited-style-name="Visited_20_Internet_20_Link">companies licensed to redistribute Npcap OEM</text:a><text:span text:style-name="T9"> include this document </text:span><text:span text:style-name="T13">itself </text:span><text:span text:style-name="T9">along with their software and also include </text:span><text:span text:style-name="T13">a statement like the one below </text:span><text:span text:style-name="T9">in their documentation:</text:span></text:p>
   <text:p text:style-name="P12"/>
   <text:p text:style-name="P9"><text:span text:style-name="T9">This </text:span><text:span text:style-name="T10">program</text:span><text:span text:style-name="T9"> contains the Npcap OEM Windows packet capturing software (</text:span><text:a xlink:type="simple" xlink:href="https://npcap.com/" text:style-name="Internet_20_link" text:visited-style-name="Visited_20_Internet_20_Link">https://npcap.com</text:a><text:span text:style-name="T9">) pursuant to a license </text:span><text:span text:style-name="T10">agreement with</text:span><text:span text:style-name="T9"> Nmap Software LLC. </text:span><text:span text:style-name="T10">Npcap OEM contains programming code from the Libpcap project (</text:span><text:a xlink:type="simple" xlink:href="https://www.tcpdump.org/" text:style-name="Internet_20_link" text:visited-style-name="Visited_20_Internet_20_Link">https://www.tcpdump.org</text:a><text:span text:style-name="T10">) which is Copyright (c) by The TCPdump Group and its contributors. Npcap also incorporates code from the now-defunct Win</text:span><text:change-end text:change-id="ct94743600844320"/><text:span text:style-name="T15">p</text:span><text:change-start text:change-id="ct94743553241088"/><text:span text:style-name="T10">cap </text:span><text:span text:style-name="T13">software</text:span><text:span text:style-name="T10"> (</text:span><text:a xlink:type="simple" xlink:href="https://winpcap.org/" text:style-name="Internet_20_link" text:visited-style-name="Visited_20_Internet_20_Link">https://winpcap.org</text:a><text:span text:style-name="T10">) which is Copyright (c) NetGroup, Politecnico di Torino, CACE Technologies, </text:span><text:span text:style-name="T11">and </text:span><text:span text:style-name="T10">The Regents of the University of California. </text:span><text:span text:style-name="T12">In addition, </text:span><text:span text:style-name="T11">Npcap contains an ieee80211_radiotap.h header file which is Copyright (c) David Young. </text:span><text:span text:style-name="T12">Full license text and details for these 3</text:span><text:span text:style-name="T16">rd</text:span><text:span text:style-name="T12"> party components are available in the Npcap-Third-Party-Open-Source.pdf file included with this program and/or available at </text:span><text:a xlink:type="simple" xlink:href="https://npcap.com/src/docs/Npcap-Third-Party-Open-Source.pdf" text:style-name="Internet_20_link" text:visited-style-name="Visited_20_Internet_20_Link">https://npcap.com/src/docs/Npcap-Third-Party-Open-Source.pdf</text:a><text:span text:style-name="T27">.</text:span><text:change-end text:change-id="ct94743553241088"/><text:change-start text:change-id="ct94743400384432"/></text:p>
   <text:p text:style-name="P16"><text:change-end text:change-id="ct94743400384432"/></text:p>
   <text:h text:style-name="P19" text:outline-level="1">Libpcap Portable Packet Capturing Library</text:h>
   <text:p text:style-name="Standard"><text:soft-page-break/></text:p>
   <text:p text:style-name="Standard"><text:span text:style-name="T2">Description:</text:span> Libpcap is a popular reference implementation of the pcap packet capturing API. It is produced by The T<text:span text:style-name="T5">CP</text:span>dump Group and supports Linux and Mac OS X systems (among others). Npcap implements this API for Microsoft Windows by combining the high-level open source libpcap API code with our own custom Windows driver that implements the low-level network operations. Our wpcap.dll library file is mostly <text:span text:style-name="T5">l</text:span>ibpcap code. We occasionally make our own fixes and changes to the libpcap code, but we have a great relationship with The T<text:span text:style-name="T5">CP</text:span>dump Group and try to submit all of our changes to them for incorporation in future libpcap releases.</text:p>
   <text:p text:style-name="Standard"><text:span text:style-name="T2">Software URL:</text:span> <text:a xlink:type="simple" xlink:href="http://www.tcpdump.org/" text:style-name="Internet_20_link" text:visited-style-name="Visited_20_Internet_20_Link">http://www.tcpdump.org/</text:a></text:p>
   <text:p text:style-name="Standard"><text:span text:style-name="T2">Version used:</text:span> 1.10</text:p>
   <text:p text:style-name="Standard"><text:span text:style-name="T2">License Summary:</text:span> Modified BSD license (3-clause) – allows free redistribution as long as you include a short attribution statement and warranty disclaimer somewhere in your documentation.</text:p>
   <text:p text:style-name="Standard"><text:span text:style-name="T2">License </text:span><text:span text:style-name="T3">T</text:span><text:span text:style-name="T2">ext:</text:span> Libpcap is Copyright (c) by The TCPdump <text:span text:style-name="T5">G</text:span>roup and its contributors. This license text was taken from <text:a xlink:type="simple" xlink:href="https://github.com/the-tcpdump-group/libpcap/blob/master/LICENSE" text:style-name="Internet_20_link" text:visited-style-name="Visited_20_Internet_20_Link">https://github.com/the-tcpdump-group/libpcap/blob/master/LICENSE</text:a> on August 25, 2020:</text:p>
   <text:p text:style-name="Standard"/>
   <text:p text:style-name="Quotations">License: BSD</text:p>
   <text:p text:style-name="Quotations">Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</text:p>
   <text:p text:style-name="Quotations"><text:s text:c="2"/>1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</text:p>
   <text:p text:style-name="Quotations"><text:s text:c="2"/>2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</text:p>
   <text:p text:style-name="Quotations"><text:s text:c="2"/>3. The names of the authors may not be used to endorse or promote products derived from this software without specific prior written permission.</text:p>
   <text:p text:style-name="Quotations">THIS SOFTWARE IS PROVIDED ``AS IS&apos;&apos; AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.</text:p>
   <text:h text:style-name="P19" text:outline-level="1">Winpcap Windows Packet Capturing Library</text:h>
   <text:p text:style-name="Standard"/>
   <text:p text:style-name="Standard"><text:span text:style-name="T2">Description:</text:span> Winpcap is an earlier (now abandoned) open source implementation of the pcap API for Windows. The last Winpcap release was made in March 2013. <text:s text:c="4"/>We created Npcap by starting with that abandoned code and updating it to support modern Windows NDIS API’s and fixing well-known bugs and security issues. While Npcap has diverged substantially over the years, it still contains a substantial amount of original Winpcap code, so the Winpcap license must be followed. It is used by Nmap on Windows for raw packet reading during host discovery, port scanning, and OS detection. It is a derivative of LibPcap, so that license (see Libpcap section) must be followed as well. It is only needed and used on Windows.</text:p>
   <text:p text:style-name="Standard"><text:span text:style-name="T2">Software URL:</text:span> <text:a xlink:type="simple" xlink:href="https://www.winpcap.org/" text:style-name="Internet_20_link" text:visited-style-name="Visited_20_Internet_20_Link">https://www.winpcap.org/</text:a></text:p>
   <text:p text:style-name="Standard"><text:span text:style-name="T2">Version used:</text:span> 4.1.3</text:p>
   <text:p text:style-name="Standard"><text:span text:style-name="T2">License Summary:</text:span> Modified BSD license (3-clause) – allows free redistribution as long as you include attribution statement and warranty disclaimer somewhere in your documentation. The fourth clause, which relates to attribution in advertising materials has been officially removed and revoked by the University of California, Berkeley: <text:a xlink:type="simple" xlink:href="https://ipira.berkeley.edu/sites/default/files/shared/docs/Advertising_clause_removed_from_BSD_license.pdf" text:style-name="Internet_20_link" text:visited-style-name="Visited_20_Internet_20_Link">https://ipira.berkeley.edu/sites/default/files/shared/docs/Advertising_clause_removed_from_BSD_license.pdf</text:a></text:p>
   <text:p text:style-name="Standard"><text:soft-page-break/><text:span text:style-name="T2">License T</text:span><text:span text:style-name="T3">e</text:span><text:span text:style-name="T2">xt:</text:span> This was taken from <text:a xlink:type="simple" xlink:href="https://www.winpcap.org/misc/copyright.htm" text:style-name="Internet_20_link" text:visited-style-name="Visited_20_Internet_20_Link">https://www.winpcap.org/misc/copyright.htm</text:a> on March 11, 2016 and we made the following updates:</text:p>
   <text:list xml:id="list3766194689" text:style-name="L1">
    <text:list-item>
     <text:p text:style-name="P22">Removed the “advertising clause” from University of California, Berkeley copyright statement because they have officiall<text:span text:style-name="T5">y</text:span> removed and revoked that as documented here: <text:a xlink:type="simple" xlink:href="https://ipira.berkeley.edu/sites/default/files/shared/docs/Advertising_clause_removed_from_BSD_license.pdf" text:style-name="Internet_20_link" text:visited-style-name="Visited_20_Internet_20_Link">https://ipira.berkeley.edu/sites/default/files/shared/docs/Advertising_clause_removed_from_BSD_license.pdf</text:a></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P22">Removed copyright notice from Kungliga Tekniska Högskolan because that code is no longer in Npcap.</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P22">Removed copyright notice from Yen Yen Lim and north Dakota State University because that code is no longer in Npcap.</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P22">Removed copyright notice from Digital Equipment Corporation because that code is no longer in Npcap.</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P22">Removed copyright notice from WIDE Project because that code is no longer in Npcap.</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P22">Removed copyright notice from Juniper Networks because that code is no longer in Npcap.</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P22">Removed copyright notice from Daniel Hartmeier since that code is no longer in Npcap.</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P22">Removed copyright notice from Carnegie Mellon since that code is no longer in Npcap.</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P22">Removed the 1983 copyright notice from UC Berkeley since that code is no longer in Npcap. The notice from their 1990’s contributions is still there.</text:p>
    </text:list-item>
   </text:list>
   <text:p text:style-name="Standard"/>
   <text:p text:style-name="Quotations">Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy).</text:p>
   <text:p text:style-name="Quotations">Copyright (c) 2005 - 2010 CACE Technologies, Davis (California).</text:p>
   <text:p text:style-name="Quotations">All rights reserved.</text:p>
   <text:p text:style-name="Quotations">Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</text:p>
   <text:p text:style-name="Quotations">1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</text:p>
   <text:p text:style-name="Quotations">2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</text:p>
   <text:p text:style-name="Quotations">3. Neither the name of the Politecnico di Torino, CACE Technologies nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</text:p>
   <text:p text:style-name="Quotations">THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</text:p>
   <text:p text:style-name="Quotations">This product includes software developed by the University of California, Lawrence Berkeley <text:soft-page-break/>Laboratory and its contributors.</text:p>
   <text:p text:style-name="Quotations">Portions Copyright (c) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997 The Regents of the University of California. All rights reserved.</text:p>
   <text:p text:style-name="Quotations">Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</text:p>
   <text:p text:style-name="Quotations">1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</text:p>
   <text:p text:style-name="Quotations">2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</text:p>
   <text:p text:style-name="Quotations">3. Neither the name of the University nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</text:p>
   <text:p text:style-name="Quotations">THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS&apos;&apos; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</text:p>
   <text:h text:style-name="P19" text:outline-level="1">The ieee80211_radiotap.h Header File</text:h>
   <text:p text:style-name="Standard"/>
   <text:p text:style-name="Standard"><text:span text:style-name="T2">Description:</text:span> This is just a short header file defining data structures for the IEEE 802.11 radio capture header.</text:p>
   <text:p text:style-name="Standard"><text:span text:style-name="T2">Software URL:</text:span> <text:a xlink:type="simple" xlink:href="http://web.mit.edu/~mkgray/afs/bar/afs/sipb.mit.edu/project/freebsd/head/contrib/wpa/src/utils/radiotap.h" text:style-name="Internet_20_link" text:visited-style-name="Visited_20_Internet_20_Link">http://web.mit.edu/~mkgray/afs/bar/afs/sipb.mit.edu/project/freebsd/head/contrib/wpa/src/utils/radiotap.h</text:a></text:p>
   <text:p text:style-name="Standard"><text:span text:style-name="T2">Version used:</text:span> There is not a specific version number, but it says “Copyright (c) 2003, 2004 David Young”</text:p>
   <text:p text:style-name="Standard"><text:span text:style-name="T2">License Summary:</text:span> Modified BSD license (3-clause) – allows free redistribution as long as you include a short attribution statement and warranty disclaimer somewhere in your documentation.</text:p>
   <text:p text:style-name="Standard"><text:span text:style-name="T2">License Text: </text:span>This is from a comment near the top of <text:a xlink:type="simple" xlink:href="https://github.com/nmap/npcap/blob/master/packetWin7/npf/npf/ieee80211_radiotap.h" text:style-name="Internet_20_link" text:visited-style-name="Visited_20_Internet_20_Link">the ieee80211_radiotap.h file itself</text:a>:</text:p>
   <text:p text:style-name="Standard"/>
   <text:p text:style-name="Quotations">Copyright (c) 2003, 2004 David Young. <text:s/>All rights reserved.</text:p>
   <text:p text:style-name="Quotations">Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</text:p>
   <text:p text:style-name="Quotations">1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</text:p>
   <text:p text:style-name="Quotations">2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the <text:soft-page-break/>distribution.</text:p>
   <text:p text:style-name="Quotations">3. The name of David Young may not be used to endorse or promote products derived from this software without specific prior written permission.</text:p>
   <text:p text:style-name="Quotations">THIS SOFTWARE IS PROVIDED BY DAVID YOUNG ``AS IS&apos;&apos; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. <text:s/>IN NO EVENT SHALL DAVID YOUNG BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<text:change-start text:change-id="ct94743415409552"/></text:p>
   <text:p text:style-name="Quotations"><text:change-end text:change-id="ct94743415409552"/><text:change-start text:change-id="ct94743510229856"/>Copyright Statements and Acknowledgment/Disclaimer Text</text:p>
   <text:p text:style-name="Standard"/>
   <text:p text:style-name="P6"><text:span text:style-name="T24">To give credit where due and also comply with attribution clauses of the various 3</text:span><text:span text:style-name="T25">rd</text:span><text:span text:style-name="T24"> party </text:span><text:span text:style-name="T26">software component licenses detailed in this document, we </text:span><text:span text:style-name="T9">suggest that </text:span><text:a xlink:type="simple" xlink:href="https://npcap.com/oem/redist.html" text:style-name="Internet_20_link" text:visited-style-name="Visited_20_Internet_20_Link">companies licensed to redistribute Npcap OEM</text:a><text:span text:style-name="T9"> include this document along with their software and also include </text:span><text:change-end text:change-id="ct94743510229856"/><text:change-start text:change-id="ct94743400759344"/><text:span text:style-name="T10">the following (or similar) </text:span><text:span text:style-name="T9">statement </text:span><text:change-end text:change-id="ct94743400759344"/><text:change-start text:change-id="ct94743493494784"/><text:span text:style-name="T9">in their documentation:</text:span></text:p>
   <text:p text:style-name="P13"/>
   <text:p text:style-name="P6"><text:span text:style-name="T9">This </text:span><text:span text:style-name="T10">program</text:span><text:span text:style-name="T9"> contains the Npcap OEM Windows packet capturing software (</text:span><text:a xlink:type="simple" xlink:href="https://npcap.com/" text:style-name="Internet_20_link" text:visited-style-name="Visited_20_Internet_20_Link">https://npcap.com</text:a><text:span text:style-name="T9">) pursuant to a license </text:span><text:span text:style-name="T10">agreement with</text:span><text:span text:style-name="T9"> Nmap Software LLC. <text:s/></text:span><text:span text:style-name="T10">Npcap OEM contains programming code from the Libpcap project (</text:span><text:a xlink:type="simple" xlink:href="https://www.tcpdump.org/" text:style-name="Internet_20_link" text:visited-style-name="Visited_20_Internet_20_Link">https://www.tcpdump.org</text:a><text:span text:style-name="T10">) which is </text:span><text:change-end text:change-id="ct94743493494784"/><text:change-start text:change-id="ct94743605596672"/><text:span text:style-name="T10">and also from WinPcap (https://winpcap.org).</text:span><text:change-end text:change-id="ct94743605596672"/><text:change-start text:change-id="ct94743492828224"/></text:p>
   <text:p text:style-name="P14"/>
   <text:p text:style-name="P13">the following acknowledgment/disclaimer statement in the </text:p>
   <text:p text:style-name="P6"/>
   <text:p text:style-name="P7">Npcap is Copyright (c) 2013-2025 Nmap Software</text:p>
   <text:p text:style-name="P6"/>
   <text:p text:style-name="P6"><text:span text:style-name="T24"><text:s/>above</text:span>the <text:span text:style-name="T23">following </text:span>copyright/acknowledgment/disclaimer <text:span text:style-name="T23">text </text:span><text:s/><text:span text:style-name="T23">we use give fair attribution to the authors o</text:span>as required by the various open source licenses (see above). <text:s/>We’re including this both to fulfill the license agreements ourselves, and as a template that companies distributing Npcap (which is only allowed with the redistribution license described at <text:a xlink:type="simple" xlink:href="https://npcap.com/oem/redist.html" text:style-name="Internet_20_link" text:visited-style-name="Visited_20_Internet_20_Link">https://npcap.com/oem/redist.html</text:a>) can use in their own documentation as well.</text:p>
   <text:p text:style-name="P15"/>
   <text:p text:style-name="P18">Npcap is Copyright (c) 2013-202<text:span text:style-name="T6">2 Nmap Software</text:span> LLC. All rights reserved. See <text:a xlink:type="simple" xlink:href="https://npcap.com/" text:style-name="Internet_20_link" text:visited-style-name="Visited_20_Internet_20_Link">https://npcap.com</text:a> for details.</text:p>
   <text:p text:style-name="P17">Portions of Npcap are Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy).</text:p>
   <text:p text:style-name="P17">Portions of Npcap are Copyright (c) 2005 - 2010 CACE Technologies, Davis (California).</text:p>
   <text:p text:style-name="P17">All rights reserved.</text:p>
   <text:p text:style-name="P17">Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</text:p>
   <text:p text:style-name="P17">1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</text:p>
   <text:p text:style-name="P17">2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</text:p>
   <text:p text:style-name="P17">3. Neither the name of the Politecnico di Torino, CACE Technologies nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</text:p>
   <text:p text:style-name="P17">THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</text:p>
   <text:p text:style-name="P17">This product includes software developed by the University of California, Lawrence Berkeley Laboratory and its contributors.</text:p>
   <text:p text:style-name="P17">Portions of Npcap are Copyright (c) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997 The Regents of the University of California. All rights reserved.</text:p>
   <text:p text:style-name="P17">Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</text:p>
   <text:p text:style-name="P17">1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</text:p>
   <text:p text:style-name="P17">2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</text:p>
   <text:p text:style-name="P17">3. Neither the name of the University nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</text:p>
   <text:p text:style-name="P17">THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS&apos;&apos; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</text:p>
   <text:p text:style-name="P17">Portions of Npcap are Copyright (c) 2003, 2004 David Young. <text:s/>All rights reserved.</text:p>
   <text:p text:style-name="P17">Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</text:p>
   <text:p text:style-name="P17">1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</text:p>
   <text:p text:style-name="P17">2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</text:p>
   <text:p text:style-name="P17">3. The name of David Young may not be used to endorse or promote products derived from this software without specific prior written permission.</text:p>
   <text:p text:style-name="P6">THIS SOFTWARE IS PROVIDED BY DAVID YOUNG ``AS IS&apos;&apos; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. <text:s/>IN NO EVENT SHALL DAVID YOUNG BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<text:change-end text:change-id="ct94743492828224"/></text:p>
  </office:text>
 </office:body>
</office:document>

```

`docs/README`:

```
The documentation in this directory can be found in HTML format at
https://npcap.com/guide/

```

`docs/index.html`:

```html
<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta http-equiv="refresh" content="3; url=https://npcap.com/guide/">
    <title>Npcap Guide</title>
    <script type="text/javascript">
setTimeout(function(){window.location.href='https://npcap.com/guide/'},3000);
    </script>
  </head>
  <body>
    <p>The Npcap Guide has moved to
    <a href="https://npcap.com/guide/">https://npcap.com/guide/</a>.
    If you are not redirected automatically within 3 seconds,
    <a href="https://npcap.com/guide/">follow this link</a>.</p>
  </body>
</html>

```

`docs/npcap-api.xml`:

```xml
<sect1 id="npcap-api">
  <title>The Npcap API</title>
  <sect1info>
    <abstract>
      <para>The Npcap Application Programming Interface (<acronym>API</acronym>) consists of the
        libpcap API and a few non-portable extensions: <code>pcap_setbuff</code>, 
          <code>pcap_setuserbuffer</code>,
          <code>pcap_setmintocopy</code>,
          <code>pcap_getevent</code>,
          <code>pcap_setmode</code>,
          <code>pcap_oid_get_request</code> and <code>pcap_oid_set_request</code>,
          functions for batch-sending packets with <code>pcap_send_queue</code>,
          and <code>pcap_stats_ex</code>.
        </para>
    </abstract>
  </sect1info>

  <para>The Npcap API is exported by <filename>wpcap.dll</filename> and is the
	  Windows port of <ulink url="https://www.tcpdump.org/">libpcap</ulink>.
	  The API and functions are described in
          <ulink url="wpcap/pcap.html">the pcap(1) man page</ulink>.
          This port varies from the standard Unix libpcap API in just a few ways.
          First, the <literal>pcap_get_selectable_fd()</literal> and
          <literal>pcap_get_required_select_timeout()</literal>
          functions are not defined or exported. Second, as described in
          <xref linkend="npcap-api-extensions"/>, Npcap extends the libpcap API with
          a set of non-portable functions. Lastly, Npcap includes functions from the
          remote capture API of libpcap, which is described in
          <xref linkend="npcap-api-remote"/>.
  </para>

  <sect2 id="npcap-api-extensions">
    <title>Extensions to libpcap for Windows</title>
    <para>
      There are a few extensions to libpcap that exist only on Windows.
      Software that uses these extensions will not be portable to non-Windows
      systems. The following is a brief list of these extensions and their purpose.
    </para>
    <variablelist>
      <varlistentry>
        <term>
          <code>pcap_setbuff</code>
        </term>
        <listitem>
          <para>
            Sets the size of the kernel buffer associated with an adapter.
          </para>
          <code>int pcap_setbuff(pcap_t *p, int dim);</code>
          <para><literal>dim</literal> specifies the size of the buffer in
            bytes. The return value is 0 when the call succeeds, -1 otherwise.
            If an old buffer was already created with a previous call to
            <literal>pcap_setbuff()</literal>, it is deleted and its content is
            discarded. <ulink
              url="wpcap/pcap_open_live.html">pcap_open_live()</ulink> creates
            a 1 MByte buffer by default.
          </para>
	  <para>
            <emphasis>Portability note:</emphasis> libpcap provides the <ulink
              url="wpcap/pcap_set_buffer_size.html">pcap_set_buffer_size()</ulink>
            function for setting the kernel buffer size.  This removes the need
            to use the non-portable <literal>pcap_setbuff()</literal> for this
            purpose.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>
          <code>pcap_setmode</code>
        </term>
        <listitem>
          <para>Sets the working mode of the interface.</para>
          <code>int pcap_setmode(pcap_t *p, int mode);</code>
          <para>
            The <literal>mode</literal> parameter is defined as a bitwise-OR
            of the constants defined below. These are bit flags and may be
            combined using bitwise-OR to enable multiple behaviors.
            <literal>MODE_CAPT</literal> and <literal>MODE_STAT</literal>
            share the same bit position: <literal>MODE_CAPT</literal>
            is defined as 0 (LSB clear) and <literal>MODE_STAT</literal>
            as 1 (LSB set). As a result, <literal>MODE_CAPT</literal>
            is mutually exclusive with <literal>MODE_STAT</literal>
            and cannot be explicitly combined with it.
          </para>
          <para>
            Valid values for mode are listed below. WinPcap also defined
            <literal>MODE_MON</literal> and <literal>MODE_DUMP</literal>,
            but these are not supported by Npcap.
          </para>
          <variablelist>
            <varlistentry>
              <term>
                <literal>MODE_CAPT</literal>
              </term>
              <listitem>
                <para>Default packet capture mode.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>MODE_STAT</literal>
              </term>
              <listitem>
                <para>Statistical mode. See <xref linkend="npcap-tutorial-statistics" /> for details.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>MODE_SENDTORX</literal>
              </term>
              <listitem>
                <para>Causes injected packets to be sent on the receive path as though
                they were received by the network adapter. This is the same
                behavior as the SendToRxAdapters Registry value, but affects
                  only this handle.</para>
                <note><para>This mode was added in Npcap 1.83</para></note>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>MODE_SENDTORX_CLEAR</literal>
              </term>
              <listitem>
                <para>Forces this handle to use the default behavior (sending injected
                packets on the transmit path), canceling any system-wide Npcap
                  configuration by the SendToRxAdapters Registry value.</para>
                <note><para>This mode was added in Npcap 1.83</para></note>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>
          <code>pcap_setmintocopy</code>
        </term>
        <listitem>
          <para>
            Sets the minumum amount of data received by the kernel in a single call.
          </para>
          <code>int pcap_setmintocopy(pcap_t *p, int size);</code>

          <para>
            This function changes the minimum amount of data in the
            kernel buffer that causes a read from the application to return
            (unless the timeout expires). If the value of
            <literal>size</literal> is large, the kernel is forced to wait the
            arrival of several packets before
            copying the data to the user. This guarantees a low number of
            system calls, i.e. low processor usage, and is a good setting for
            applications like packet-sniffers and protocol analyzers. Vice
            versa, in presence of a small value for this variable, the kernel
            will copy the packets as soon as the application is ready to
            receive them. This is useful for real time applications that need
            the best responsiveness from the kernel. <ulink
              url="wpcap/pcap_open_live.html">pcap_open_live()</ulink> sets a
            default <literal>size</literal> value of 16000 bytes.
          </para>
          <para>
            <emphasis>Portability note:</emphasis> libpcap provides the <ulink
              url="wpcap/pcap_set_immediate_mode.html">pcap_set_immediate_mode()</ulink>
            function for applications that need to receive packets as soon as
            they arrive. This removes the need to use the non-portable
            <literal>pcap_setmintocopy()</literal> for this purpose.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>
          <code>pcap_getevent</code>
        </term>
        <listitem>
          <para>Returns the handle of the event associated with the interface.</para>
          <code>HANDLE pcap_getevent(pcap_t *p);</code>

          <para> This event can be passed to functions like
            <literal>WaitForSingleObject()</literal> or
            <literal>WaitForMultipleObjects()</literal> to wait until the
            driver's buffer contains some data without performing a read.
          </para>

          <para>
            <emphasis>Portability note:</emphasis> This function is the Windows
            alternative to <ulink
              url="wpcap/pcap_get_selectable_fd.html">pcap_get_selectable_fd()</ulink>,
            which is only available on UNIX-like systems.
	  </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>
          <code>pcap_oid_get_request</code> and <code>pcap_oid_set_request</code>
        </term>
        <listitem>
          <para>Send an OID request to the underlying NDIS drivers</para>
          <code>int pcap_oid_get_request(pcap_t *, bpf_u_int32, void *, size_t *);</code>
          <code>int pcap_oid_set_request(pcap_t *, bpf_u_int32, const void *, size_t *);</code>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>
          Queuing sent packets with <code>pcap_send_queue</code>
        </term>
        <listitem>
          <para>
            Npcap has the ability to queue multiple raw packets for
            transmission on the network in a single call. This is more
            efficient than issuing a series of
            <literal>pcap_sendpacket()</literal>, because the packets are
            buffered in the kernel driver, so the number of context switches is
            reduced.
          </para>
          <code>pcap_send_queue* pcap_sendqueue_alloc(u_int memsize);</code>
          <code>void pcap_sendqueue_destroy(pcap_send_queue* queue);</code>
          <para>Allocate a send queue as a buffer of <literal>memsize</literal>
            bytes. The <literal>pcap_send_queue</literal> allocated can be
            freed with <literal>pcap_sendqueue_destroy()</literal>.</para>
          <code>int pcap_sendqueue_queue(pcap_send_queue* queue, const struct pcap_pkthdr *pkt_header, const u_char *pkt_data);</code>
          <para>
            <literal>pcap_sendqueue_queue()</literal> adds a packet at the end
            of the send queue pointed by the <literal>queue</literal>
            parameter.  <literal>pkt_header</literal> points to a
            <literal>pcap_pkthdr</literal> structure with the timestamp and the
            length of the packet, <literal>pkt_data</literal> points to a
            buffer with the data of the packet.
          </para>

          <para>
            The <literal>pcap_pkthdr</literal> structure is the same used by
            Npcap and libpcap to store the packets in a file, therefore sending
            a capture file is straightforward. 'Raw packet' means that the
            sending application will have to include the protocol headers,
            since every packet is sent to the network 'as is'. The CRC of the
            packets needs not to be calculated, because it will be
            transparently added by the network interface.
          </para>
          <code>u_int pcap_sendqueue_transmit(pcap_t *p, pcap_send_queue* queue, int sync);</code>
          <para>
            This function transmits the content of a queue to the wire.
            <literal>p</literal> is a pointer to the adapter on which the
            packets will be sent, <literal>queue</literal> points to a
            <literal>pcap_send_queue</literal> structure containing the packets
            to send), <literal>sync</literal> determines if the send operation
            must be synchronized: if it is non-zero, the packets are sent
            respecting the timestamps, otherwise they are sent as fast as
            possible.
          </para>

          <para>
            The return value is the amount of bytes actually sent. If it is
            smaller than the <literal>size</literal> parameter, an error
            occurred during the send.  The error can be caused by a
            driver/adapter problem or by an inconsistent/bogus send queue.
          </para>

          <para>
            <emphasis>Performance note:</emphasis> When <literal>sync</literal>
            is set to <literal>TRUE</literal>, the packets are synchronized in
            the kernel with a high precision timestamp.  This requires a
            non-negligible amount of CPU, but allows normally to send the
            packets with a precision of some microseconds (depending on the
            accuracy of the performance counter of the machine). Such a
            precision cannot be reached sending the packets with
            <literal>pcap_sendpacket()</literal>.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>
          <code>pcap_stats_ex</code>
        </term>
        <listitem>
          <code>struct pcap_stat *pcap_stats_ex(pcap_t *p, int *pcap_stat_size);</code>
          <para>
            <literal>pcap_stats_ex()</literal> extends the
            <literal>pcap_stats()</literal> allowing to return more statistical
            parameters than the old call.  One of the advantages of
            this new call is that the <literal>pcap_stat</literal> structure is
            not allocated by the user; instead, it is returned back by the
            system. This allow to extend the <literal>pcap_stat</literal>
            structure without affecting backward compatibility on older
            applications. These will simply check at the values of the members
            at the beginning of the structure, while only newest applications
            are able to read new statistical values, which are appended in
            tail.
          </para>

          <para>
            To be sure not to read a piece of memory which has not been allocated
            by the system, the variable <literal>pcap_stat_size</literal> will
            return back the size of the structure <literal>pcap_stat</literal>
            allocated by the system.
          </para>

          <para>
            <literal>p</literal>: pointer to the <literal>pcap_t</literal>
            currently in use. <literal>pcap_stat_size</literal>: pointer to an
            integer that will contain (when the function returns back) the size
            of the structure <literal>pcap_stat</literal> as it has been
            allocated by the system.
          </para>

          <para>
            The function returns a pointer to a pcap_stat structure, that will
            contain the statistics related to the current device. The return
            value is <literal>NULL</literal> in case of errors, and the error
            text can be obtained with <literal>pcap_perror()</literal> or
            <literal>pcap_geterr()</literal>.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>
          <code>pcap_setuserbuffer</code>
        </term>
        <listitem>
          <para>Sets the size of the buffer that accepts packets from the kernel driver.</para>
          <code>int pcap_setuserbuffer(pcap_t *p, int size);</code>

          <para>
            The size of the packet buffer is a parameter that can sensibly
            influence the performance of the capture process, since this buffer
            will contain the packets received from the the Npcap driver. The
            driver is able to return several packets using a single read call,
            and the number of packets transferable to the application in a call
            is limited only by the size of this buffer.  Therefore setting a
            larger buffer siz can noticeably decrease the number of system
            calls, reducing the impact of the capture process on the processor.
          </para>
        </listitem>
      </varlistentry>

    </variablelist>
  </sect2>

  <sect2 id="npcap-api-remote">
    <title>The libpcap remote capture API</title>
    <para>
      WinPcap introduced several additional functions to the libpcap API in
      order to support remote capture. While the upstream libpcap project has
      absorbed these functions, they have not yet published documentation on
      them. Here is a brief overview.
    </para>
    <variablelist>
      <varlistentry>
        <term>
          <code>pcap_open</code>
        </term>
        <listitem>
          <para>
            Opens a remote or local capture handle.
          </para>
	  <code>pcap_t* pcap_open(const char * source, int snaplen, int flags, int read_timeout, struct pcap_rmtauth *auth, char *errbuf);</code>
          <para>
            This routine can open a savefile, a local device, or a device on
            a remote machine running an RPCAP server.
          </para>
          <variablelist>
            <varlistentry>
              <term><code>source</code></term>
              <listitem>
                <para>
                  Zero-terminated string containing the source name to open.
                  The source name must be in one of the following formats:
                </para>
                <itemizedlist>
                  <listitem><para><literal>file://path/to/file.pcap</literal></para></listitem>
                  <listitem><para>
                      <literal>rpcap://devicename</literal> (or the equivalent,
                      <literal>devicename</literal>)
                  </para></listitem>
                  <listitem><para><literal>rpcap://host/devicename</literal></para></listitem>
                  <listitem><para><literal>rpcap://host:port/devicename</literal></para></listitem>
                </itemizedlist>
                <para>
                  Adapter names returned by <literal>pcap_findalldevs_ex()</literal>
                  are already in this format. For convenience, compatible source
                  strings can be built with the helper function,
                  <literal>int pcap_createsrcstr(char *source, int type, const char *host, const char *port, const char *name, char *errbuf)</literal>,
                  where <literal>type</literal> is one of
                  <literal>PCAP_SRC_FILE</literal>,
                  <literal>PCAP_SRC_IFLOCAL</literal>, or
                  <literal>PCAP_SRC_IFREMOTE</literal>,
                  and <literal>source</literal> is a user-allocated buffer of
                  at least <literal>PCAP_BUF_SIZE</literal> bytes.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><code>snaplen</code></term>
              <listitem>
                <para>
                  See the documentation for
                  <ulink url="wpcap/pcap_open_live.html">pcap_open_live()</ulink>.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><code>flags</code></term>
              <listitem>
                <para>
                  Keeps several flags that can be needed for capturing packets.
                  The allowed flags are defined in the pcap_open() flags .
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><code>read_timeout></code></term>
              <listitem>
                <para>
                  See the documentation for
                  <ulink url="wpcap/pcap_open_live.html">pcap_open_live()</ulink>.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><code>auth</code></term>
              <listitem>
                <para>
                  A pointer to a 'struct pcap_rmtauth' that keeps the
                  information required to authenticate the user on a remote
                  machine. In case this is not a remote capture, this pointer
                  can be set to NULL.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><code>errbuf</code></term>
              <listitem>
                <para>
                  See the documentation for
                  <ulink url="wpcap/pcap_open_live.html">pcap_open_live()</ulink>.
                </para>
              </listitem>
            </varlistentry>
          </variablelist>
 
          <para>
            <emphasis>Portability notes:</emphasis> For opening a savefile, the
            <ulink url="wpcap/pcap_open_offline.html">pcap_open_offline</ulink>
            routines can be used, and will work just as well; code using them
            will work on more platforms than code using <literal>pcap_open()</literal>
            to open savefiles.
          </para>
 
          <para>
            For opening a local device,
            <ulink url="wpcap/pcap_open_live.html">pcap_open_live()</ulink>
            can be used; it supports most of the capabilities than
            <literal>pcap_open()</literal> supports, and code using it will work
            on more platforms than code using <literal>pcap_open()</literal>.
            <ulink url="wpcap/pcap_create.html">pcap_create()</ulink> and
            <ulink url="wpcap/pcap_activate.html">pcap_activate()</ulink>
            can also be used; they support all capabilities that
            <literal>pcap_open()</literal> supports, except for the Windows-only
            <literal>PCAP_OPENFLAG_NOCAPTURE_LOCAL</literal>,
            and they support additional capabilities.
          </para>
 
          <para>
            For opening a remote capture, <literal>pcap_open()</literal> is
            currently the only API available.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <code>pcap_findalldevs_ex</code>
        </term>
        <listitem>
          <para>
            Lists local and remote capture sources.
          </para>
          <code>int pcap_findalldevs_ex(char *source, struct pcap_rmtauth *auth, pcap_if_t **alldevs, char *errbuf);</code>
          <variablelist>
            <varlistentry>
              <term><code>source</code></term>
              <listitem>
                <para>
                  Zero-terminated string containing the source name to list.
                  The source name must be in one of the following formats:
                </para>
                <itemizedlist>
                  <listitem><para>
                      <literal>file://path/to/directory</literal>
                      - lists capture files in a directory
                  </para></listitem>
                  <listitem><para>
                      <literal>rpcap://</literal> - lists local adapters
                  </para></listitem>
                  <listitem><para>
                      <literal>rpcap://host[:port]</literal>
                        - lists remote adapters
                  </para></listitem>
                </itemizedlist>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><code>auth</code></term>
              <listitem>
                <para>See <literal>pcap_open()</literal>.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><code>alldevs</code></term>
              <listitem>
                <para>
                  See <ulink href="wpcap/pcap_findalldevs.html">pcap_findalldevs()</ulink>.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><code>errbuf</code></term>
              <listitem>
                <para>
                  See <ulink href="wpcap/pcap_findalldevs.html">pcap_findalldevs()</ulink>.
                </para>
              </listitem>
            </varlistentry>
          </variablelist>
          <para>
            As with <literal> pcap_findalldevs()</literal>, the buffer returned in
            <literal>alldevs</literal> must be freed using
            <ulink href="wpcap/pcap_freealldevs.html">pcap_freealldevs()</ulink>.
          </para>
        </listitem>
      </varlistentry>
    </variablelist>
  </sect2>
  <sect2 id="npcap-api-specifics">
    <title>Implementation-specific API details</title>
    <para>
      Some libpcap functions and features can vary from platform to
      platform. Here are some specific clarifications for those cases.
    </para>
    <variablelist>
      <varlistentry>
        <term>Statistics reported by <code>pcap_stats()</code></term>
        <listitem>
          <para>In Npcap, the members of <code>struct pcap_stat</code> are:</para>
          <variablelist>
            <varlistentry>
              <term><code>ps_recv</code></term>
              <listitem>
                <para>The number of packets processed by this handle, regardless of
                  whether they passed the packet filter.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><code>ps_drop</code></term>
              <listitem>
                <para>The number of packets dropped due to resource limits
                  or a full buffer</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><code>ps_ifdrop</code></term>
              <listitem>
                <para>Not used. This is always set to 0.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><code>ps_capt</code></term>
              <listitem>
                <para>For <code>pcap_stats()</code>, this is not used.
                  For <code>pcap_stats_ex()</code>, this is the number of packets
                  that passed the packet filter AND were queued for capture
                  (i.e. not dropped due to limited buffer space).</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><code>ps_sent</code></term>
              <listitem>
                <para>Not used.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><code>ps_netdrop</code></term>
              <listitem>
                <para>Not used.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Timestamp types</term>
        <listitem>
          <para>Npcap supports the following timestamp types for
          <ulink url="wpcap/pcap_set_tstamp_type.html"><code>pcap_set_tstamp_type()</code></ulink>:
          </para>
          <variablelist>
            <varlistentry>
              <term><code>PCAP_TSTAMP_HOST</code></term>
              <listitem>
                <para>Default timestamp type, usually <code>TIMESTAMP_MODE_SINGLE_SYNCHRONIZATION</code>.
                  Registry settings may change this default for new handles.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><code>PCAP_TSTAMP_HOST_HIPREC_UNSYNCED</code></term>
              <listitem>
                <para>Maps to <code>TIMESTAMP_MODE_SINGLE_SYNCHRONIZATION</code>,
                  a monotonic timestamp based on the system performance counter
                  (<code>KeQueryPerformanceCounter()</code>).
                  This may drift from system time, but will never move backward.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><code>PCAP_TSTAMP_HOST_LOWPREC</code></term>
              <listitem>
                <para>Maps to <code>TIMESTAMP_MODE_QUERYSYSTEMTIME</code>.
                Timestamps are synchronized to the system clock and obtained
                by calling <code>KeQuerySystemTime()</code>,
                which is accurate to within one system clock tick (roughly ten milliseconds).
                If the system time moves backwards due to NTP or other time change,
                the timestamps will also go backwards.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><code>PCAP_TSTAMP_HOST_HIPREC</code></term>
              <listitem>
                <para>Maps to <code>TIMESTAMP_MODE_QUERYSYSTEMTIME_PRECISE</code>.
                Timestamps are synchronized to the system clock and obtained
                by calling <code>KeQuerySystemTimePrecise()</code>, which is accurate
                to within a microsecond.</para>
                <para>Note that Windows 7 does not have the
                  <code>KeQuerySystemTimePrecise()</code> function, so
                  <code>PCAP_TSTAMP_HOST_HIPREC</code> is identical to
                  <code>PCAP_TSTAMP_HOST_LOWPREC</code> on that system.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Timestamp precision</term>
        <listitem>
          <para>Npcap 1.86 and later support requesting timestamps in nanosecond precision using
          <ulink url="wpcap/pcap_set_tstamp_precision.html"><code>pcap_set_tstamp_precision()</code></ulink>.
            The timestamps are still subject to the 100-nanosecond
            resolution of the Windows system clock.
            </para>
        </listitem>
      </varlistentry>
    </variablelist>
  </sect2>
</sect1>

```

`docs/npcap-devguide.xml`:

```xml
<sect1 id="npcap-devguide">
  <title>Developing software with Npcap</title>
  <sect1info>
    <abstract>
      <para> Writing software that captures or injects network traffic is easy
        with Npcap.  This guide describes the Npcap SDK, WinPcap compatibility,
        and the Npcap API.</para>
    </abstract>
  </sect1info>

  <sect2 id="npcap-development">
    <title>Using the Npcap SDK</title>

    <para>
      To build software that uses Npcap, use the latest version of the Npcap Software Development Kit (SDK).
      The latest SDK can be downloaded on <ulink role="hidepdf" url="https://npcap.com/#download">Npcap.org</ulink>.
      Updates to the SDK are much less frequent than updates to the Npcap binaries.
    </para>
  </sect2>

  <sect2 id="npcap-examples">
    <title>Examples</title>

    <para>
      Examples of applications using Npcap are available <ulink role="hidepdf" url="https://github.com/nmap/npcap/tree/master/Examples">in the Examples directory</ulink> in the source distribution.
    Several of these examples are explored in more depth in the <xref linkend="npcap-tutorial" />.
    </para>

    <para>
      Npcap developer Yang Luo has also provided an example:
      <ulink role="hidepdf" url="https://github.com/hsluoyz/UserBridge/">UserBridge</ulink>,
      which is a tool to redirect all packets from one interface to another.
    </para>
  </sect2>

  <sect2 id="npcap-devguide-updating">
    <title>Updating WinPcap software to Npcap</title>
    <para>
      For the most part, Npcap is completely compatible with software written
      for WinPcap. Minor changes need to be made to <xref
        linkend="npcap-feature-native-dll">DLL loading order</xref> and in some
      cases <xref linkend="npcap-feature-native-servicename">driver service
        name</xref>. However, there have been many improvements to the libpcap
      API between the last release of WinPcap and the current release of Npcap.
      Reviewing the changes may help improve performance, reliability, and
      maintainability of software that uses Npcap.
    </para>

    <para>Apart from the libpcap API, WinPcap exported a few functions used by
      <ulink url="https://www.winpcap.org/windump/">WinDump</ulink> that were
      related to porting a Unix-style tool to Windows but unrelated to packet
      capture. Those functions were not documented in the WinPcap
      documentation, have never been included in libpcap, and are therefore not
      in the Npcap API: <code>getservent</code>, <code>endservent</code>, and
      <code>eproto_db</code>.</para>

    <para>One other function exported by WinPcap, <code>wsockinit</code>, is
      available via the Npcap API as <code>pcap_wsockinit</code>. It calls
      <code>WSAStartup</code> for Windows Sockets version 1.1 and ensures that
      <code>WSACleanup</code> is called when the process ends.</para>

  </sect2>

  <sect2 id="npcap-detect">
    <title>How to detect what version Npcap/WinPcap you are using?</title>

    <para>
      Sometimes, our user software needs to detect the existence of Npcap/WinPcap
      at install-time or run-time. Although Npcap's GUI installer has the ability
      to handle this, you may want to handle it by yourself in some conditions,
      like you run Npcap installer in silent-mode.  The run-time detection is even
      more useful. Your software probably has some functions that rely on Npcap's
      particular features (like loopback capture). You need to know if you
      are running on top of Npcap or the legacy WinPcap to control whether to
      switch your functions on.  Fortunately, Npcap provides you some methods to
      detect Npcap/WinPcap at install-time and run-time.
    </para>

    <sect3 id="npcap-detect-version">
      <title>Npcap version</title>

      <para> Npcap has a version number that is independent of WinPcap. The last
        release of WinPcap was version 4.1.3, but Npcap started over counting
        versions from 0.00. In order to make it clear to the installers and other
        software that Npcap is newer and more advanced, the executable
        <quote>file version</quote> was advanced to <quote>5.0.0.000</quote> at
        that point. The major version will always be <quote>5</quote> to
        distinguish Npcap from WinPcap. The minor version is Npcap's major
        version; the revision is Npcap's minor version; and the build number is
        an encoding of the build date. So a file version of
        <quote>5.0.92.612</quote> is Npcap 0.92, built on June 12th.</para>
    </sect3>

    <sect3 id="npcap-detect-install-time">
      <title>Install-time detection</title>

      <para>
        You can check the existence of <filename>C:\Program Files\Npcap\NPFInstall.exe</filename> to
        detect Npcap's existence. If Npcap exists, you can check the file version of
        <filename>C:\Program Files\Npcap\NPFInstall.exe</filename> to detect Npcap e-version. The
        e-version also gives you the version. The NSIS code is shown below. <varname>$inst_ver</varname>
        is an e-version string like <quote>5.0.7.424</quote>
      </para>
      <screen>
GetDllVersion "C:\Program Files\Npcap\NPFInstall.exe" $R0 $R1
IntOp $R2 $R0 / 0x00010000
IntOp $R3 $R0 &amp; 0x0000FFFF
IntOp $R4 $R1 / 0x00010000
IntOp $R5 $R1 &amp; 0x0000FFFF
StrCpy $inst_ver "$R2.$R3.$R4.$R5"</screen>

      <para>
        You can check the installation options of an already installed Npcap by reading the registry
        key: <filename>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\npcap\Parameters</filename>.
        The entries like <filename>AdminOnly</filename>,
        <filename>LoopbackSupport</filename>, <filename>DltNull</filename>,<filename>Dot11Support</filename>,
        <filename>WinPcapCompatible</filename>, etc. 
        are <code>REG_DWORD</code> type. A 0x00000001 value
        indicates the installation option is <emphasis>CHECKED</emphasis>.
      </para>
      <para>Note: Prior to Npcap 0.93, these values were stored in the
        <filename>Services\npcap</filename> key directly.</para>
    </sect3>

    <sect3 id="npcap-detect-run-time">
      <title>Run-time detection</title>

      <para>
        Npcap and WinPcap can be installed together on a system. Which capture
        library is used by the user software relies on the DLL loading path. If
        Npcap's <filename>wpcap.dll</filename> is loaded first, then you are using
        Npcap, vice versa. However, it's difficult and fragile to check the DLL
        loading path by yourself.  Fortunately, you can use
        <function>pcap_lib_version</function> to get the Npcap/WinPcap version
        string.
      </para>

      <screen>
char *pcap_version = pcap_lib_version();
printf("%s", pcap_version);
// Npcap output: "Npcap version 0.92, based on libpcap version 1.8.1"
// WinPcap output: "WinPcap version 4.1.3"</screen>

      <para>Npcap requires the <varname>npcap</varname> service to be running.
        A code sample from Nmap showing how to check the status of the service is
        <ulink role="hidepdf" url="https://github.com/nmap/nmap/blob/8c8e4a08c6c6b7abd2343e5921aafb6077bdb257/mswin32/winfix.cc#L322-L328">here</ulink>.
      </para>
    </sect3>
  </sect2>

  <sect2 id="npcap-feature-native">
    <title>For software that want to use Npcap first when Npcap and WinPcap coexist</title>

    <para>
      Prerequisite: Uncheck the <option>Install Npcap in WinPcap API-compatible Mode</option> option at
      install-time (which is by default).
    </para>

    <sect3 id="npcap-feature-native-dll">
      <title>DLL loading</title>

      <para>Npcap installs its DLLs into <filename>C:\Windows\System32\Npcap\</filename>
        instead of WinPcap's <filename>C:\Windows\System32\</filename>. Because of how Windows'
        <ulink role="hidepdf" url="https://msdn.microsoft.com/en-us/library/windows/desktop/ms686203(v=vs.85).aspx">DLL search path</ulink> works,
        your application will use WinPcap first by default when Npcap and WinPcap coexist,
        as <filename>C:\Windows\System32\</filename> is prior to <filename>C:\Windows\System32\Npcap\</filename>.
        So when Npcap and WinPcap coexist, an application that want to use Npcap instead
        of WinPcap must make <filename>C:\Windows\System32\Npcap\</filename> precedent to the
        <filename>C:\Windows\System32\</filename> in the DLL search path. Here are two ways
        to modify this search path to make your application load Npcap's DLLs first,
        based on how your application links Npcap/WinPcap's library
        (<filename>wpcap.dll</filename>).</para>

      <sect4 id="npcap-feature-native-dll-implicitly">
        <title>If the application <emphasis>implicitly</emphasis> links <filename>wpcap.dll</filename></title>

        <para>Implicit linking means that either you specified <filename>wpcap.lib</filename>
          in your <option>Project Properties</option> -> <option>Configuration Properties</option>
          -> <option>Linker</option> -> <option>Input</option> -> <option>Additional Dependencies</option> in Visual Studio,
          or specified <code>#pragma comment(linker, "wpcap.lib")</code> in your code.</para>

        <para>You need to do the following two steps:</para>

        <itemizedlist>
          <listitem><para>Specify <filename>wpcap.dll</filename> as a delay-loaded DLL: In
              Visual Studio, open the <option>Project Properties</option> window. Go to:
              <option>Configuration Properties</option> -> <option>Linker</option> -> <option>Input</option>
              -> <option>Delay Loaded Dlls</option>. Enter <filename>wpcap.dll</filename>
              in that option.</para></listitem>

          <listitem><para>Before calling any <filename>wpcap.dll</filename> functions,
              call <function>SetDllDirectory</function> to add <filename>C:\Windows\System32\Npcap\</filename>
              to DLL search path.</para></listitem>
        </itemizedlist>

        <!-- TODO: Should we take ownership of WinDump if it is used as an example? -->
        <para><ulink role="hidepdf" url="https://github.com/hsluoyz/WinDump/">Here</ulink>
          is an example called WinDump, a simple packet capture tool using Npcap/WinPcap.
          And <ulink role="hidepdf" url="https://github.com/hsluoyz/WinDump/commit/dffe2eaa520fc3b449ec0a90dcfa24f96359bbfa">this commit</ulink>
          makes it able to use Npcap first when Npcap and WinPcap coexist.</para>
      </sect4>

      <sect4 id="npcap-feature-native-dll-explicitly">
        <title>If the application <emphasis>explicitly</emphasis> links <filename>wpcap.dll</filename></title>

        <para>Explicit linking means that you explicitly called <function>LoadLibrary</function>
          to load <filename>wpcap.dll</filename> and called <function>GetProcAddress</function> to get the
          function pointers.</para>

        <para>You need to do the following one step:</para>

        <itemizedlist>
          <listitem><para>Before calling <function>LoadLibrary</function> to load <filename>wpcap.dll</filename>,
              call <function>SetDllDirectory</function> to add <filename>C:\Windows\System32\Npcap\</filename>
              to DLL search path.</para></listitem>
        </itemizedlist>

        <para>The function <function>init_npcap_dll_path</function> is provided in the following example:
          <ulink role="hidepdf" url="https://github.com/hsluoyz/WinDump/commit/dffe2eaa520fc3b449ec0a90dcfa24f96359bbfa">WinDump</ulink></para>
      </sect4>
    </sect3>

    <sect3 id="npcap-feature-native-servicename">
      <title>Service name</title>

      <para>Because Npcap is a NDIS 6 LWF filter driver it is designed to run
        at system boot, so software will generally not need to start it,
        unlike WinPcap which was often installed in a demand-start
        configuration.</para> 

      <para>Npcap uses service name <quote>npcap</quote> instead of WinPcap's <quote>npf</quote>,
        so applications using
        <command>net start npf</command> for starting service must change to this:
        run <command>net start npcap</command>.
        </para>
    </sect3>
  </sect2>

  <sect2 id="npcap-feature-loopback">
    <title id="npcap-feature-loopback.title">For software that uses Npcap loopback feature</title>

    <para>
      Npcap 0.9983 and newer support loopback traffic capture and injection without requiring a particular installation option.
    </para>

    <para>
      Npcap's loopback adapter device is reported by
      <function>pcap_findalldevs()</function> as
      <quote>\Device\NPF_Loopback</quote>. This name is always available even
      if <quote>Legacy loopback support</quote> was chosen at install time,
      which puts the name of the legacy loopback adapter in the
      <filename>LoopbackAdapter</filename> REG_SZ value of the
      <filename>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\npcap\Parameters</filename>.
      Registry key.
    </para>

    <para>
      Traffic captured and injected on the loopback adapter uses the
      <varname>DLT_NULL</varname> data link type, which consists of a 4-byte
      header in host byte order that is either 2 for IPv4 packets or 24 for
      IPv6 packets.
    </para>

    <para>
      The MTU of <quote>Npcap Loopback Adapter</quote> is hard-coded to 65536 by Npcap. Software
      using Npcap should get this value automatically and no special handling is needed. This value is
      arbitrary and does not imply a limitation on the Windows loopback stack,
      so it may be possible to capture packets with a size larger than the adapter's MTU.
    </para>

    <para>
      Don't try to make OID requests to <quote>Npcap Loopback Adapter</quote> except
      <varname>OID_GEN_MAXIMUM_TOTAL_SIZE</varname> (MTU). Those requests will still succeed like
      other adapters do, but they only make sense for NDIS adapters and Npcap doesn't even use the
      NDIS way to handle the loopback traffic. The only handled OID request by Npcap is
      <varname>OID_GEN_MAXIMUM_TOTAL_SIZE</varname>. If you query its value, you will always get
      65550 (65536 + 14). If you try to set its value, the operation will always fail.
    </para>

    <para>If you use IP Helper API to get adapter list, you will get an interface named
      like <quote>Loopback Pseudo-Interface 1</quote>. This interface is a DUMMY interface by Microsoft
      and can't be seen in NDIS layer. And it also takes the 127.0.0.1/::1 IP address. A good practice
      for software is replacing the <varname>AdapterName</varname> of the
      <quote>Loopback Pseudo-Interface 1</quote> entry with
      <quote>NPF_Loopback</quote>, as Nmap does in its enhancements to
      libdnet.</para>

    <para><quote>Legacy loopback support</quote> installs a copy of the
      Microsft KM-TEST loopback adapter named <quote>Npcap Loopback
        Adapter</quote> for software that expects to find the loopback adapter
      via ordinary Windows API calls. The features and operation are no
      different from standard loopback support, but the
      name of the adapter will be written to the
      <filename>LoopbackAdapter</filename> Registry value.
      </para>

  </sect2>

  <sect2 id="npcap-feature-dot11">
    <title id="npcap-feature-dot11.title">For software that uses Npcap raw 802.11 feature</title>

    <para>
      Prerequisite: Check the <option>Support raw 802.11 traffic (and monitor mode) for wireless adapters</option> option at install-time.
    </para>

    <sect3 id="npcap-feature-dot11-steps">
      <title>Steps</title>
      <itemizedlist>
        <listitem><para>Install the latest version Npcap with the
            <option>Support raw 802.11 traffic (and monitor mode) for wireless
              adapters</option> option checked in the installation wizard. With this
            option checked, Npcap will see packets with <emphasis>Radiotap +
              802.11</emphasis> headers for wireless adapters. Otherwise, Npcap will
            see packets with <emphasis>fake Ethernet</emphasis> headers for wireless
            adapters.</para></listitem>

        <listitem><para>Run <filename>WlanHelper.exe</filename> with
            <emphasis>Administrator privilege</emphasis>. If you use
            <option>-i</option>, follow the interactive prompts to choose your
            wireless adapter and select <quote>Network Monitor</quote> mode.
            <filename>WlanHelper.exe</filename> also supports parameters to be used
            in an API manner, run <command>WlanHelper.exe -h</command> for
            details.</para></listitem>

        <listitem><para>Use the Npcap API from your user software as usual. For
            example, launch Wireshark and capture on the wireless adapter, viewingall
            802.11 packets (<emphasis>data + control + management</emphasis>).
        </para></listitem>

        <listitem><para>If you need to return to <quote>Managed Mode</quote>, run
            <command>WlanHelper.exe</command> again, following the prompts or
            selecting the appropriate command-line options to switch off the
            <quote>Monitor Mode</quote>.</para></listitem>
      </itemizedlist>
    </sect3>

    <sect3 id="npcap-feature-dot11-tips">
      <title>Tips</title>
      <itemizedlist>
        <listitem><para>You can use <filename>WlanHelper.exe</filename> tool to
            switch on the <quote>Monitor Mode</quote> in order to see
            <emphasis>802.11 control and management</emphasis> packets. You
            can also use the <code>pcap_set_rfmon</code> function within your
            code, as Wireshark does.
        </para></listitem>

        <listitem><para>Switching on the <quote>Monitor Mode</quote> will
            disconnect your wireless network from the AP, you can switch back to
            <quote>Managed Mode</quote> using the same
            <filename>WlanHelper.exe</filename> tool.</para></listitem>

        <listitem><para>The <filename>WlanHelper.exe</filename> tool is
            installed to <quote>%SYSTEMROOT%\System32\Npcap</quote> after installing Npcap.</para></listitem>
      </itemizedlist>
    </sect3>

    <sect3 id="npcap-feature-dot11-terminology">
      <title>Terminology</title>
      <para>
        <quote>Managed Mode</quote> (for Linux) = <quote>Extensible Station Mode</quote> (aka <quote>ExtSTA</quote>, for Windows)
      </para>

      <para>
        <quote>Monitor Mode</quote> (for Linux) = <quote>Network Monitor Mode</quote> (aka <quote>NetMon</quote>, for Windows)
      </para>

      <para>
        <quote>Master Mode</quote> (for Linux) = <quote>Extensible Access Point</quote> (aka <quote>ExtAP</quote>, for Windows)
      </para>
    </sect3>

    <sect3 id="npcap-feature-dot11-wlanhelper">
      <title>WlanHelper</title>
      <para>
        WlanHelper is used to set/get the operation mode (like <quote>Monitor
          Mode</quote>) for a wireless adapter on Windows.  WlanHelper tries to
        follow the grammar of <filename>iwconfig</filename>, a wireless
        management tool for Linux. So if you rename
        <filename>WlanHelper.exe</filename> to <filename>iwconfig.exe</filename>,
        your command lines for WlanHelper will be exactly the same with the
        iwconfig tool.
        <!-- TODO: check that this is still true, and more fully document WlanHelper -->
      </para>

      <sect4 id="npcap-feature-dot11-wlanhelper-usage">
        <title>WlanHelper's Usage</title>
        <para>
          Note: <command>WlanHelper</command> must run under <emphasis>Administrator privilege</emphasis>.
        </para>

        <sect5 id="npcap-feature-dot11-wlanhelper-usage-interactive">
          <title>Interactive way</title>
          <para>
            Run <command>WlanHelper</command> with the <option>-i</option> option.
          </para>
        </sect5>

        <sect5 id="npcap-feature-dot11-wlanhelper-usage-api">
          <title>Command-line API way</title>

          <itemizedlist>
            <listitem><para>Run <command>netsh wlan show interfaces</command>, get the <option>Name</option> or <option>GUID</option> for the interface.</para></listitem>
            <listitem><para>Run <command>WlanHelper -h</command> to see the man page.</para></listitem>
          </itemizedlist>
          <example id="npcap-ex-wlanhelper-man">
            <title>WlanHelper Man</title>
            <screen>
C:\> <userinput>WlanHelper.exe</userinput>
WlanHelper for Npcap 0.91 ( https://npcap.com )
Usage: WlanHelper [Commands]
or: WlanHelper {Interface Name or GUID} [Options]

OPTIONS:
mode                  : Get interface operation mode
mode &lt;managed|monitor|master|..&gt;  : Set interface operation mode
modes                 : Get all operation modes supported by the interface, comma-separated
channel               : Get interface channel
channel &lt;1-14&gt;            : Set interface channel (only works in monitor mode)
freq                  : Get interface frequency
freq &lt;VALUE&gt;              : Set interface frequency (only works in monitor mode)
modu                  : Get interface modulation
modu &lt;dsss|fhss|irbaseband|ofdm|hrdsss|erp|ht|vht|ihv (VALUE)|..&gt; : Set interface modulation
modus                 : Get all modulations supported by the interface, comma-separated

COMMANDS:
-i                    : Enter the interactive mode
-h                    : Print this help summary page

OPERATION MODES:
managed   : The Extensible Station (ExtSTA) operation mode
monitor   : The Network Monitor (NetMon) operation mode
master    : The Extensible Access Point (ExtAP) operation mode (supported from Windows 7 and later)
wfd_device    : The Wi-Fi Direct Device operation mode (supported from Windows 8 and later)
wfd_owner : The Wi-Fi Direct Group Owner operation mode (supported from Windows 8 and later)
wfd_client    : The Wi-Fi Direct Client operation mode (supported from Windows 8 and later)

802.11 MODULATIONS (https://en.wikipedia.org/wiki/IEEE_802.11):
802.11-1997   : dsss, fhss
802.11a   : ofdm
802.11b   : dsss
802.11g   : ofdm
802.11n   : mimo-ofdm
802.11ac  : mimo-ofdm

EXAMPLES:
WlanHelper Wi-Fi mode
WlanHelper 42dfd47a-2764-43ac-b58e-3df569c447da channel 11
WlanHelper 42dfd47a-2764-43ac-b58e-3df569c447da freq 2
WlanHelper "Wireless Network Connection" mode monitor

SEE THE MAN PAGE (https://github.com/nmap/npcap) FOR MORE OPTIONS AND EXAMPLES</screen>
          </example>
          <para>
            An example:
          </para>
          <example id="npcap-ex-wlanhelper-api">
            <title>WlanHelper API Usage</title>
            <screen>
C:\> <userinput>netsh wlan show interfaces</userinput>

There is 1 interface on the system:

Name                   : <replaceable>Wi-Fi</replaceable>
Description            : Qualcomm Atheros AR9485WB-EG Wireless Network Adapter
GUID                   : <replaceable>42dfd47a-2764-43ac-b58e-3df569c447da</replaceable>
Physical address       : a4:db:30:d9:3a:9a
State                  : connected
SSID                   : LUO-PC_Network
BSSID                  : d8:15:0d:72:8c:18
Network type           : Infrastructure
Radio type             : 802.11n
Authentication         : WPA2-Personal
Cipher                 : CCMP
Connection mode        : Auto Connect
Channel                : 1
Receive rate (Mbps)    : 150
Transmit rate (Mbps)   : 150
Signal                 : 100%
Profile                : LUO-PC_Network

Hosted network status  : Not available

C:\> <userinput>WlanHelper.exe <replaceable>wi-fi</replaceable> mode</userinput>
managed
C:\> <userinput>WlanHelper.exe <replaceable>wi-fi</replaceable> mode monitor</userinput>
Success
C:\> <userinput>WlanHelper.exe <replaceable>wi-fi</replaceable> mode </userinput>
monitor
C:\> <userinput>WlanHelper.exe <replaceable>wi-fi</replaceable> mode managed</userinput>
Success
C:\> <userinput>WlanHelper.exe <replaceable>wi-fi</replaceable> mode</userinput>
managed</screen>
          </example>
        </sect5>
      </sect4>
    </sect3>

  </sect2>
</sect1>

```

`docs/npcap-guide-wrapper.html`:

```html
<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta http-equiv="refresh" content="3; url=https://npcap.com/guide/">
    <title>Npcap Guide</title>
    <script type="text/javascript">
setTimeout(function(){window.location.href='https://npcap.com/guide/'},3000);
    </script>
  </head>
  <body>
    <p>The Npcap Guide has moved to
    <a href="https://npcap.com/guide/">https://npcap.com/guide/"</a>.
    If you are not redirected automatically within 3 seconds,
    <a href="https://npcap.com/guide/">follow this link</a>.</p>
  </body>
</html>

```

`docs/npcap-guide-wrapper.xml`:

```xml
<?xml version="1.0"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd"
[
<!ENTITY npcap-intro SYSTEM "npcap-intro.xml">
<!ENTITY npcap-guide SYSTEM "npcap-guide.xml">
<!ENTITY npcap-devguide SYSTEM "npcap-devguide.xml">
<!ENTITY npcap-tutorial SYSTEM "npcap-tutorial.xml">
<!ENTITY npcap-api SYSTEM "npcap-api.xml">
<!ENTITY npcap-internals SYSTEM "npcap-internals.xml">
]>

<article id="npcap">
<articleinfo>
  <title>Npcap Reference Guide</title>
  <abstract>
    <para>A manual and guide to Npcap, a packet capture and network analysis framework for Windows, for users and
      software developers. Npcap is a modern, safe, and compatible update to WinPcap.</para>
  </abstract>
</articleinfo>

&npcap-intro;
&npcap-guide;
&npcap-devguide;
&npcap-api;
&npcap-tutorial;
&npcap-internals;

</article>

```

`docs/npcap-guide.xml`:

```xml
<sect1 id="npcap-users-guide">
  <title>Npcap Users' Guide</title>
  <sect1info>
    <abstract>
      <para>The Users' Guide covers the basics of installing and removing
        Npcap, interactions with WinPcap, frequently asked questions,
        and how to report bugs.</para>
    </abstract>
  </sect1info>

  <para>Because Npcap is a packet capture architecture, not merely a software
    library, some aspects of installation and configuration may fall to the end
    user. This Users' Guide covers the basics of installing, configuring, and
    removing Npcap, as well as how to report bugs.</para>

  <sect2 id="npcap-installation">
    <title>Installation</title>

    <para>
      Npcap is distributed as a signed executable installer, downloadable from
      <ulink url="https://npcap.com/#download">Nmap.com</ulink>. Major
      versions are backwards-compatible, and users of the free non-commercial
      version are encouraged to upgrade regularly for security and stability
      fixes. Software distributors may have separate requirements for supported
      Npcap versions.  Please refer to
      <ulink url="https://npcap.com/#license">the Npcap License</ulink> for
      terms of use and redistribution.</para>

    <para>
      The Npcap installer and uninstaller are easy to use in
      <quote>Graphical Mode</quote> (direct run) and <quote>Silent Mode</quote> (run with
      <option>/S</option> parameter, available only with <ulink url="https://npcap.com/oem/">Npcap OEM</ulink>).
    </para>

    <sect3 id="npcap-installation-exit">
      <title>Installer exit codes</title>
			<para>The Npcap installer provides information about its execution via the process exit code. The exit
				codes defined are as follows:</para>
			<itemizedlist>
				<listitem><para><literal>0</literal>: Normal execution, no error.</para></listitem>
				<listitem><para><literal>1</literal>: Installation aborted by user (cancel button).</para></listitem>
				<listitem><para><literal>2</literal>: Installation aborted by script.</para></listitem>
				<listitem><para><literal>350</literal> (<literal>ERROR_FAIL_NOACTION_REBOOT</literal>): Installation failed; reboot and try again.</para></listitem>
				<listitem><para><literal>3010</literal> (<literal>ERROR_SUCCESS_REBOOT_REQUIRED</literal>): Installation succeeded; reboot required before Npcap is ready to use.</para></listitem>
			</itemizedlist>

      <para>It is important to note that the installer is a backgrounded app (even in silent mode) and so to get
        the correct process exit code, you need to launch and wait for it. Two ways to do this are using 
        <command>start /wait</command> in <literal>cmd.exe</literal> or <command>Start-Process -Wait</command>
				in PowerShell.</para>

        <para>In the case of return code 2, and in general, it is best to verify a working Npcap installation
          instead of relying on the installer exit code. This could include checking for the
					<literal>npcap</literal> driver service or verifying the Npcap DLLs can be loaded and calling
					<function>pcap_version</function>.</para>
    </sect3>

    <sect3 id="npcap-installation-options">
      <title>Installer options</title>
      <para>
        The installer accepts several command-line options that correspond to the
        options presented in the graphical interface (GUI).  The options can be
        set by command-line flags taking the form
        <option>/<replaceable>name</replaceable>=<replaceable>value</replaceable></option>.
      </para>
      <para>The values for these options must be one of:
      </para>
      <itemizedlist>
        <listitem><para><option>yes</option>: select the option</para></listitem>
        <listitem><para><option>no</option>: unselect the option</para></listitem>
        <listitem><para><option>enforced</option>: select the option and make it unchangable in the GUI</para></listitem>
        <listitem><para><option>disabled</option>: unselect the option and make it unchangable in the GUI</para></listitem>
      </itemizedlist>
      <sect4 id="npcap-installer-options-gui">
        <title>Graphical installer options</title>
        <para>The following options are presented as checkboxes in the
          installer, but can be set or locked via command-line flags. Unless
          otherwise noted, the default for these options is <option>no</option>.
        </para>

        <variablelist>
          <varlistentry>
            <term><option>/loopback_support</option></term>
            <listitem><para>
		<emphasis>Legacy loopback support for Nmap 7.80 and older. Not needed for Wireshark.</emphasis>
		Older versions of Npcap required a Microsoft KM-TEST loopback
		adapter to be installed in order to capture and inject loopback
		traffic. This is no longer needed, but some software won't be
		able to do loopback injection unless the adapter is installed.
		Use this option to install the legacy loopback adapter if
		needed.
              </para>
              <para>See <xref linkend="npcap-feature-loopback" /> for more
                information.
            </para></listitem>
          </varlistentry>

          <varlistentry>
            <term><option>/admin_only</option></term>
            <listitem><para>
                <emphasis>Restrict Npcap driver's access to Administrators
                  only</emphasis>. When this option is chosen, the devices
                created by the Npcap driver for capture and injection on each
                network adapter will be created with a restrictive ACL that
                only allows access to the device by the SYSTEM and built-in
                Administrators. Because this level of access requires UAC
                elevation, a helper binary, <literal>NpcapHelper.exe</literal>,
                is used to request elevation for each process that opens a
                capture handle.
            </para></listitem>
          </varlistentry>

          <varlistentry>
            <term><option>/dot11_support</option></term>
            <listitem><para>
                <emphasis>Support raw 802.11 traffic (and monitor mode) for
                  wireless adapters</emphasis>. This option installs a second
                Lightweight Filter Driver that uses the Native WiFi API to
                capture raw 802.11 WiFi frames on devices that are put into
                network monitor mode. Captured frames are given a Radiotap
                header. Not all hardware or network drivers support the Native
                WiFi API.
            </para></listitem>
          </varlistentry>

          <varlistentry>
            <term><option>/winpcap_mode</option></term>
            <listitem><para>
                <emphasis>Install Npcap in WinPcap API-compatible
                  Mode</emphasis>. The default for this option is
		  <option>yes</option> in Npcap 0.9985 and later. Npcap's DLLs
                    have always been installed into a separate
                    <literal>Npcap</literal> subdirectory of the system
                    directory to avoid conflicting with existing WinPcap
                    installations. This option also installs the DLLs to the
                    system directory, replacing WinPcap. Any existing WinPcap
                    installation will be removed.
            </para></listitem>
          </varlistentry>

          <varlistentry>
            <term><option>/prior_driver</option></term>
            <listitem><para>
		<emphasis>Install older (version 1.30) Npcap driver on pre-Windows-10 systems</emphasis>.
		Some, but not all, ancient Windows systems (so old that Microsoft no longer supports them)
		refuse to install the latest Npcap drivers for signature validation reasons.  They don't
		support the
		<ulink url="https://learn.microsoft.com/en-us/windows-hardware/drivers/dashboard/code-signing-attestation"
			>modern attestation signing method</ulink>, but also can't use drivers signed after
		<ulink url="https://learn.microsoft.com/en-us/windows-hardware/drivers/install/deprecation-of-software-publisher-certificates-and-commercial-release-certificates"
			>Microsoft let their cross-signing certificates for the old method expire in July
			2021</ulink>.  If your Npcap install fails on a pre-Win10 OS (especially with error
		code <varname>0xe0000247</varname>), try again with <option>/prior_driver=yes</option>. This
		option isn't the default because many/most old Windows systems still accept the newest Npcap
		drivers. They may be configured with less-strict codesigning requirements.
            </para></listitem>
          </varlistentry>

          <varlistentry>
            <term><option>/latest_driver</option></term>
            <listitem><para>
		<emphasis>Install the latest Npcap driver on pre-Windows-10 systems</emphasis>.
		Depending on system configuration, many older Windows systems have been accepting our driver
                signatures through Npcap 1.79 because our certificate still chained back to the Microsoft
                cross-certificates. Since that certificate expired in June 2024, most of these Windows 7
                through 8.1 systems will not accept Npcap drivers later than 1.79. These last compatible
		drivers are installed by default, but users can override this using the
		<option>/latest_driver=yes</option> option.
            </para></listitem>
          </varlistentry>
        </variablelist>
      </sect4>

      <sect4 id="npcap-installer-options-cli">
        <title>Command-line installation options</title>
        <para>Some advanced or deprecated options are only available on the
          command-line. Options marked <literal>(deprecated)</literal> are
          subject to removal in future versions.</para>

        <variablelist>
          <varlistentry>
            <term><option>/S</option> (Silent install, Npcap OEM only)</term>
            <listitem><para>
                Installs Npcap without showing any graphical windows or
                prompts. Silent install is available only for Npcap OEM.
            </para></listitem>
          </varlistentry>

          <varlistentry>
            <term><option>/disable_restore_point</option></term>
            <listitem><para>
                The default for this option is <option>yes</option>, so the
                installer will not set a system restore point.  Windows may
                independently create a restore point because of the driver
                installation independent from this option. To ensure a
                restore point is made, specify
                <option>/disable_restore_point=no</option>.
            </para></listitem>
          </varlistentry>

          <varlistentry>
            <term><option>/no_kill</option></term>
            <listitem><para>
                Control termination of
                processes using Npcap during upgrades or WinPcap when
                <option>/winpcap_mode=yes</option> is chosen. See
                <xref linkend="npcap-installation-uninstall-options" />
                for more detailed discussion.
            </para></listitem>
          </varlistentry>

          <varlistentry>
            <term><option>/require_version</option></term>
            <listitem><para>
		Uninstall and replace an existing Npcap installation even if it
		is newer than this version of the installer. By default, the
		Npcap installer will not remove and replace a version of Npcap
		that is newer than its own. In GUI mode, this hides the message
		box asking the user how to proceed.
            </para></listitem>
          </varlistentry>

          <varlistentry>
            <term><option>/require_features</option></term>
            <listitem><para>
		Uninstall and replace an existing Npcap installation of any
		version if it does not provide the same features as the other
		command-line options specify. Features are the /winpcap_mode,
		/dot11_support, /loopback_support, and /admin_only options.
            </para></listitem>
          </varlistentry>

          <varlistentry>
            <term><option>/force</option></term>
            <listitem><para>
		Uninstall and replace an existing Npcap installation regardless
		of version or whether the installation would be modified. By
		default, the Npcap installer will not remove and replace a
		Npcap installation of the same version unless the install
		options would be modified. In GUI mode, this hides the message
		box asking the user how to proceed.
            </para></listitem>
          </varlistentry>

          <varlistentry>
            <term><option>/D</option> (destination directory)</term>
            <listitem><para>
                The destination directory for installation can be overridden by
                the <option>/D</option> option, with a few restrictions. First, it will
                only affect where Npcap keeps its installation logs and helper utilities.
                The driver and DLLs will always be installed into the appropriate
                directories below <command>%SYSTEMROOT%\System32\</command>. Second, the
                <option>/D</option> must be the last option in the command, and the path
                must not contain quotes. This option is case-sensitive. For example, to change the installation directory
                to <filename>C:\Path With Spaces\</filename>, the invocation would be:
                <command>npcap-<replaceable>version</replaceable>.exe /D=C:\Path With Spaces</command>
            </para></listitem>
          </varlistentry>

          <varlistentry>
            <term><option>/npf_startup</option> (deprecated)</term>
            <listitem><para>
                <emphasis>Automatically start the Npcap driver at boot
                  time</emphasis>. This option defaults to
                <option>yes</option>, because Windows expects NDIS filter
                drivers to be available at boot time. If you choose to disable
                this, Windows may not start networking for up to 90 seconds
                after boot.
            </para></listitem>
          </varlistentry>

          <varlistentry>
            <term><option>/vlan_support</option> (deprecated, ignored)</term>
            <listitem><para>
                <emphasis>Support 802.1Q VLAN tag when capturing and sending
                  data (currently unsupported)</emphasis>. This feature was
                disabled in 2016 to prevent a crash and has not been
                re-enabled.
            </para></listitem>
          </varlistentry>
        </variablelist>

      </sect4>
    </sect3>

    <sect3 id="npcap-installation-uninstall-options">
      <title>Uninstaller options</title>
      <para>
        The uninstaller provided with Npcap also accepts some command-line options.
      </para>
      <variablelist>
        <varlistentry>
          <term><option>/S</option> (Silent uninstall)</term>
          <listitem>
            <para>Uninstalls Npcap without showing any graphical windows or
              prompts. Silent uninstall is available in all editions of Npcap,
              not just Npcap OEM. If Npcap OEM installer in silent mode needs
              to uninstall an older Npcap installation, it passes the
              <option>/S</option> option to the existing uninstaller. This option is case-sensitive.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>/Q</option> (Quick uninstall)</term>
          <listitem>
            <para>Skips the confirmation page and finish page in the uninstall
            wizard. This option does not have any meaning for silent
            uninstalls.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>/no_kill</option>=<replaceable>yes|no</replaceable> (do not kill processes)</term>
          <listitem>
            <para>Controls how the uninstaller handles processes that are still using
              Npcap at the time of uninstall. The default value is
              <literal>no</literal>, which allows the uninstaller to terminate
              processes that would block Npcap from being uninstalled. If
              <option>/no_kill=yes</option> is specified, then Npcap
              uninstaller will fail if there are still applications using Npcap
              driver or DLLs.</para>

            <para>In the default case, <option>/no_kill=no</option>, the
              graphical uninstaller will give the user the choice to manually
              close the offending programs, have the uninstaller terminate
              them, or abort the uninstallation.  In silent mode, Npcap
              uninstaller will immediately terminate any command-line processes
              that are using Npcap (like a Nmap process that is still
              scanning), and wait for at most 15 seconds to gracefully
              terminate any GUI processes that are using Npcap (like Wireshark
              UI that is still capturing).  <quote>Gracefully</quote> means
              that if you are still capturing via Wireshark, Wireshark UI will
              prompt the user about whether to save the current capture before
              closing. The user will have 15 seconds to save his session.
              <emphasis>Note:</emphasis> although Npcap uninstaller won't
              terminate Wireshark UI processes immediately, the live capture
              stops immediately. This is because Wireshark UI uses command-line
              processes named <varname>dumpcap.exe</varname> to capture, and
              that command-line process will be terminated immediately.</para>

            <para>If this option is provided on the
              <emphasis>installer</emphasis> command line, it will be passed to
              the Npcap uninstaller when doing an upgrade or
              replacement.</para>
          </listitem>
        </varlistentry>
      </variablelist>

    </sect3>

    <sect3 id="npcap-installation-options-disabled">
      <title>Disabled and enforced options for GUI Mode</title>

      <para>
        We may disable or enforce certain options in the installer GUI to make them unselectable. This
        usually means that those options can easily cause compatibility issues and are considered
        not suitable for most users, or we think we need to enforce some rules for the Npcap API. Advanced users can still change their states via command-line
        parameters, which is described in following sections.
      </para>

      <para>
        Fortunately, if a distributor wants to start the Npcap installer GUI and disable or enforce
        certain options for reasons like compatibility. It can also use the four value
        mechanism by setting the command-line parameters to <option>disabled</option> or <option>enforced</option>.
        For example, the following command will start an installer GUI with the
        <option>loopback_support</option> option disabled and unselected:
      </para>

      <para>
        <command>npcap-<replaceable>version</replaceable>.exe /loopback_support=disabled</command>
      </para>
    </sect3>

  </sect2>

  <sect2 id="npcap-watchdog">
    <title>The <literal>npcapwatchdog</literal> scheduled task</title>
    <para>
      Due to the complexities of installing Npcap as a device driver and an NDIS filter driver, Windows
      Feature Updates have occasionally uninstalled the Npcap driver, leading to a broken installation. To
      reduce the likelihood and impact of such a removal, the Npcap installer creates a scheduled task
      named <literal>npcapwatchdog</literal> that runs once at each system startup. The script executes
      the <filename>CheckStatus.bat</filename> script from the Npcap installation directory to determine
      whether the Npcap service is running and installed correctly. If it finds a problem, it runs the
      adjacent <filename>FixInstall.bat</filename> script to reinstall the Npcap driver.</para>
  </sect2>

  <sect2 id="npcap-platforms">
    <title>Windows platforms supported</title>
    <para>Npcap supports all Windows versions currently supported by Microsoft. Depending on Windows version, the
      driver may support a different NDIS version, which corresponds to a set of network stack
      features.</para>
    <itemizedlist>
      <listitem>
        <para>On <emphasis>Windows 11</emphasis>, <emphasis>Windows Server 2022</emphasis>,
        <emphasis>Windows 10</emphasis>, <emphasis>Windows Server 2016</emphasis>, and
        <emphasis>Windows Server 2019</emphasis>, Npcap installs a NDIS 6.50
          driver.</para></listitem>
      <listitem>
        <para>On <emphasis>Windows 8.1</emphasis>, <emphasis>Windows 8</emphasis>,
        <emphasis>Windows Server 2012 R2</emphasis>, and
        <emphasis>Windows Server 2012</emphasis>,
          Npcap installs a NDIS 6.30 driver.</para></listitem>
      <listitem>
        <para>On <emphasis>Windows 7</emphasis> and <emphasis>Windows Server 2008 R2</emphasis>, Npcap
          installs a NDIS 6.20 driver.</para></listitem>
    </itemizedlist>
    <para>Microsoft ended Extended support for Windows versions prior to Windows 10 on January 10, 2023. Future
      Npcap releases <emphasis>may</emphasis> omit support for these operating systems, especially after
      Microsoft ends the pricier Extended Security Update support in 2024 for Server 2008 R2 and in 2026
      for Server 2012 R2.</para>
    <para>Npcap can be installed on x86, x86-64, and ARM64. DLLs for the native architecture will be installed, as
      well as x86 DLLs for applications running in 32-bit emulation.</para>
  </sect2>

  <sect2 id="npcap-feature-dot11-wireshark">
    <title>How to use Wireshark to capture raw 802.11 traffic in <quote>Monitor Mode</quote></title>

    <para>
      The latest Wireshark has already integrated the support for Npcap's <quote>Monitor Mode</quote> capture.
      If you want to use Wireshark to capture raw 802.11 traffic in <quote>Monitor Mode</quote>, you need to
      switch on the monitor mode inside the Wireshark UI instead of using <xref linkend="npcap-feature-dot11-wlanhelper" />.
      This is because Wireshark only recognizes the monitor mode set by itself. So when you turn
      on monitor mode outside Wireshark (like in <filename>WlanHelper</filename>), Wireshark will not know the adapter
      has been in monitor mode, and will still try to capture in Ethernet mode, which will get no traffic.
<!-- TODO: Change instructions in other sections to reflect this. Verify that it is correct, first -->
      So after all, the correct steps are:
    </para>

    <itemizedlist>
      <listitem><para>Install latest version Wireshark and latest version Npcap with
          <option>Support raw 802.11 traffic</option> option checked.</para></listitem>

      <listitem><para>Launch Wireshark QT UI (GTK version is similar), go to <quote>Capture options</quote>.
          Then toggle the checkbox in the <quote>Monitor Mode</quote> column of your wireless adapter's row.
          Click the <quote>Start</quote> button. If you see a horizontal line instead of the checkbox,
          then it probably means that your adapter doesn't support monitor mode. You can use the
          <filename>WlanHelper</filename> tool to double-check this fact.</para></listitem>

      <listitem><para>To decrypt <emphasis>encrypted 802.11 data</emphasis>
          packets, you need to specify the decipher key in Wireshark, otherwise
          you will only see 802.11 data packets.</para></listitem>

      <listitem><para>Stop the capture in Wireshark UI when you finishes capturing, the monitor mode
          will be turned off automatically by Npcap.</para></listitem>
    </itemizedlist>
  </sect2>

  <sect2 id="npcap-qa">
    <title>Q &amp; A</title>

    <itemizedlist>
	<listitem><para>Network interruption while installing Npcap: Installing a filter driver may
	    cause brief interruptions to network connectivity based on the specific changes needed
	    to install the driver in the network stack. This known issue is documented as
	    <ulink role="hidepdf" url="">issue #53</ulink> on our tracker.</para>
	<para> A separate issue is a longer interruption in connectivity if the
	    <varname>npcap</varname> service is not started, which used to be an installer option.
	    As Microsoft states <ulink role="hidepdf" url="https://support.microsoft.com/en-us/kb/2019184">here</ulink>,
          <emphasis>an optional NDIS light-weight filter (LWF) driver like Npcap could cause
            90-second delay in network availability</emphasis>. Some solutions you could try
          are: 1) wait for 90 seconds; 2) disable and re-enable the adapter icon in
          <command>ncpa.cpl</command>; 3) reboot. If the network is still unable to connect,
          please <ulink role="hidepdf" url="http://issues.npcap.org/new?title=Npcap+Bug+Report">file a bug report</ulink>.
      </para></listitem>
      <listitem><para>Installation fails with error code <varname>0x8004a029</varname>:
          The cause is that you have <quote>reached the maximum number of network filter
            drivers</quote>, see solution
          <ulink role="hidepdf" url="https://social.technet.microsoft.com/Forums/windows/en-US/4deb27fc-33ce-4fc0-a26f-3fec5b57733d/is-there-a-maximum-number-of-network-filter-drivers-in-windows-7?forum=w7itpronetworking">here</ulink>.
      </para></listitem>
      <listitem><para>Npcap Adapter for Loopback Capture is missing:
          Npcap's loopback capture is based on the Windows Filtering Platform (WFP), so it depends on the <varname>Base Filtering Enging (BFE)</varname>
          service. To fix this issue, you should start this service at <varname>services.msc</varname>
          manually and restart the Npcap service by running <command>net stop npcap</command>
          and <command>net start npcap</command>. See details about this issue
          <ulink role="hidepdf" url="https://github.com/nmap/npcap/issues/426">here</ulink>.
      </para></listitem>

      <listitem><para>Npcap only captures TCP handshake and teardown, but not data packets:
        A deprecated and uncommon network adapter feature called
        <ulink role="hidepdf" url="https://techcommunity.microsoft.com/blog/coreinfrastructureandsecurityblog/why-are-we-deprecating-network-performance-features-kb4014193/259053">TCP Chimney</ulink>
	can cause this issue. Disable TCP Chimney in the network adapter properties on Windows.
      </para></listitem>

      <listitem><para>Captured packets have incorrect checksums or large sizes:
        Generally speaking, offload features of a miniport driver and/or NIC
        mean that the version of the packet that Npcap sees within the Windows
        network stack may be different in some way from the packet that ends up
        on the physical link. Usually, this is evident as a zero or incorrect
        TCP, UDP, or IP checksum for sent packets, but it can also appear as
        extra-large packets (greater than the TCP MSS or the link maximum frame
        size) received when RSC is enabled. For most purposes, this is not a
        problem, since the payload data is the same, but it may be relevant for
      users who want or need a more forensically-sound packet capture.
      These offload features can be disabled in Windows' network adapter properties page.
      </para></listitem>
    </itemizedlist>
  </sect2>

  <sect2 id="npcap-issues">
    <title>Reporting Bugs</title>

    <para>
      Please report any bugs or issues about Npcap on
      <ulink role="hidepdf" url="http://issues.npcap.org/new?title=Npcap+Bug+Report">the Nmap Project's Issues tracker</ulink>.
      In your report, please provide your <emphasis>DiagReport</emphasis> output, user
      software version (e.g. Nmap, Wireshark), steps to reproduce the problem, and other information
      you think necessary. If your issue occurs only on a particular OS version (e.g. Win10
      1511, 1607), please mention it in the report.
    </para>

    <sect3 id="npcap-issues-diagreport">
      <title>Diagnostic report</title>

      <para>
        Npcap has provided a diagnostic utility called <filename>DiagReport</filename>.
        It provides a lot of information including OS metadata, Npcap related files,
        install options, registry values, services, etc. You can simply click the
        <filename>C:\Program Files\Npcap\DiagReport.bat</filename> file to run <filename>DiagReport</filename>.
        It will pop up a text report via Notepad (it's stored in: <filename>C:\Program Files\Npcap\DiagReport.txt</filename>).
        Please always submit it to us if you encounter any issues.
      </para>

    </sect3>
    <sect3 id="npcap-issues-installation-log">
      <title>General installation log</title>

      <para>
        Npcap keeps track of the installation in a log file:
        <filename>C:\Program Files\Npcap\install.log</filename>. Please submit it
        together in your report if you encounter issues during the installation
        (e.g. the installer halts).
      </para>
    </sect3>

    <sect3 id="npcap-issues-driver-installation-log">
      <title>Driver installation log</title>

      <para>
        Npcap keeps track of the driver installation (aka commands run by
        <filename>NPFInstall.exe</filename>) in a log file:
        <filename>C:\Program Files\Npcap\NPFInstall.log</filename>, please submit
        it together in your report if you encounter issues during the driver
        installation or problems with the <quote>Npcap Loopback Adapter</quote>.
      </para>

      <para>
        There's another system-provided driver installation log in:
        <filename>C:\Windows\INF\setupapi.dev.log</filename>.
        If you encounter errors during the driver/service installation, please copy
        the Npcap-related lines out and send them together in
        your report.
      </para>
    </sect3>

    <sect3 id="npcap-issues-packet-log">
      <title>Dynamic link library (DLL) log</title>

      <para>
        For problems with Npcap's regular operation, you may need to obtain a
        debug log from <filename>Packet.dll</filename>.  To do this, you will
        need a debug build of Npcap.  If you are a Npcap developer, you can build
        the <filename>Packet.sln</filename> project with the
        <varname>_DEBUG_TO_FILE</varname> macro defined. If you are an end user,
        you can contact the Npcap development team for the latest Npcap debug
        build.  The debugging process will continue to append to the debug log
        (<filename>C:\Program Files\Npcap\Packet.log</filename>), so you may want
        to delete it after an amount of time, or save your output to another
        place before it gets too large.
      </para>
    </sect3>

    <sect3 id="npcap-issues-driver-log">
      <title>Driver log</title>

      <para>
        If there is an issue with the Npcap driver, you can open an
        <emphasis>Administrator</emphasis> command prompt,  enter <command>sc query
          npcap</command> to query the driver status and <command>net start
          npcap</command> to start the driver. The command
        output will inform you whether there's an error. If the driver is running
        well, but the issue still exists, then you may need to check the driver's
        log. Normal Npcap releases don't switch on the driver log function for
        performance. Contact the Npcap development team to obtain a driver-debug
        version of the Npcap installer.  When you have got an appropriate
        driver-debug version Npcap, you need to use <ulink role="hidepdf"
          url="https://technet.microsoft.com/en-us/sysinternals/debugview.aspx">DbgView</ulink>
        to read the Windows kernel log (which contains our driver log).  You may
        need to turn on DbgView before installing Npcap, if the error occurs when
        the driver loads. When done, save the DbgView output to a file and submit
        it in your report.
      </para>
    </sect3>
    <sect3 id="npcap-issues-bsod">
      <title>Blue screen of death (BSoD) dump</title>

      <para>
        If you encountered BSoD when using Npcap, please attach the minidump
        file (in <filename>C:\Windows\Minidump\</filename>) to your report
        together with the Npcap version. We may ask you to provide the full
        dump (<filename>C:\Windows\MEMORY.DMP</filename>) for further troubleshooting.
      </para>
    </sect3>
  </sect2>

</sect1>

```

`docs/npcap-internals.xml`:

```xml
<sect1 id="npcap-internals">
  <title>Npcap internals</title>
  <sect1info>
    <abstract>
      <para>Describes the internal structure and interfaces of Npcap: the NPF
        driver and Packet.dll</para>
    </abstract>
  </sect1info>
  <para>This portion of the manual describes the internal structure and
    interfaces of Npcap, starting from the lowest-level module. It is targeted
    at people who must extend or modify this software, or to the ones
    interested in how it works. Therefore, developers who just want to use
    Npcap in their software don't need to read it.</para>

  <sect2 id="npcap-structure">
    <title>Npcap structure</title>

    <para>Npcap is an architecture for packet capture and network analysis for the
      Win32 platforms. It includes a kernel-level packet filter, a
      low-level dynamic link library (packet.dll), and a high-level and
      system-independent library (wpcap.dll).</para>

    <para>Why do we use the term <wordasword>architecture</wordasword> rather
      than <wordasword>library</wordasword>? Because packet capture is a low
      level mechanism that requires a strict interaction with the network
      adapter and with the operating system, in particular with its networking
      implementation, so a simple library is not sufficient.</para>

    <!-- TODO: update this markup with a diagram
    <para>The following figure shows the various components of Npcap:</para>
    <p align="center">
      <img src="internals-arch.gif" width="280" height="355">
        <p align="center"> -->
    <sect3>
      <title>Main components of Npcap.</title>

      <para>First, a capture system needs to bypass the operating systems's
        protocol stack in order to access the raw data transiting on the
        network. This requires a portion running inside the kernel of OS,
        interacting directly with the network interface drivers. This portion
        is very system dependent, and in our solution it is realized as a
        device driver, called Netgroup Packet Filter (NPF); This driver offers
        basic features like packet capture and injection, as well as more
        advanced ones like a programmable filtering system and a monitoring
        engine. The filtering system can be used to restrict a capture session
        to a subset of the network traffic (e.g. it is possible to capture only
        the ftp traffic generated by a particular host); the monitoring engine
        provides a powerful but simple to use mechanism to obtain statistics on
        the traffic (e.g. it is possible to obtain the network load or the
        amount of data exchanged between two hosts).</para>

      <para>Second, the capture system must export an interface that user-level
        applications will use to take advantage of the features provided by the
        kernel driver. Npcap provides two different libraries:
        <filename>packet.dll</filename> and
        <filename>wpcap.dll</filename>.</para>

      <para> Packet.dll offers a low-level API that can be used to directly
        access the functions of the driver, with a programming interface
        independent from the Microsoft OS.</para>

      <!-- TODO: Should we acknowledge libpcap more significantly here? Wpcap.dll *IS* libpcap, not just compatible. -->
      <para>Wpcap.dll exports a more powerful set of high level capture
        primitives that are compatible with libpcap, the well known Unix
        capture library. These functions enable packet capture in a manner that
        is independent of the underlying network hardware and operating
        system.</para>
    </sect3>
  </sect2>

  <sect2 id="npcap-internals-driver">
    <title>Npcap driver internals</title>

    <para>This section documents the internals of the Netgroup Packet Filter
      (NPF), the kernel portion of Npcap. Normal users are probably interested
      in how to use Npcap and not in its internal structure. Therefore the
      information present in this module is destined mainly to Npcap developers
      and maintainers, or to the people interested in how the driver works. In
      particular, a good knowledge of OSes, networking and Windows kernel
      programming and device drivers development is required to profitably read
      this section.</para>

    <para>NPF is the Npcap component that does the hard work, processing the
      packets that transit on the network and exporting capture, injection and
      analysis capabilities to user-level.</para>

    <para>The following paragraphs will describe the interaction of NPF with
      the OS and its basic structure.</para>

    <sect3 id="npcap-internals-driver-ndis">
      <title>NPF and NDIS</title>

      <para>NDIS (Network Driver Interface Specification) is a standard that
        defines the communication between a network adapter (or, better, the
        driver that manages it) and the protocol drivers (that implement for
        example TCP/IP). Main NDIS purpose is to act as a wrapper that allows
        protocol drivers to send and receive packets onto a network (LAN or
        WAN) without caring either the particular adapter or the particular
        Win32 operating system.</para>

      <para>NDIS supports four types of network drivers:</para>

      <orderedlist>
        <listitem>
          <para><emphasis>Miniport drivers</emphasis>. Miniport drivers
            directly manage network interface cards, referred to as NICs. The
            miniport drivers interface directly to the hardware at their lower
            edge and at their upper edge present an interface to allow upper
            layers to send packets on the network, to handle interrupts, to
            reset the NIC, to halt the NIC and to query and set the operational
            characteristics of the driver.</para>
          <para>Miniport drivers implement only the hardware-specific
            operations necessary to manage a NIC, including sending and
            receiving data on the NIC. Operations common to all lowest level
            NIC drivers, such as synchronization, is provided by NDIS.
            Miniports do not call operating system routines directly; their
            interface to the operating system is NDIS.</para>
          <para>A miniport does not keep track of bindings. It merely passes
            packets up to NDIS and NDIS makes sure that these packets are
            passed to the correct protocols.</para>
        </listitem>
        <listitem>
          <para><emphasis>Intermediate drivers</emphasis>. Intermediate drivers
            interface between an upper-level driver such as a protocol driver
            and a miniport. To the upper-level driver, an intermediate driver
            looks like a miniport. To a miniport, the intermediate driver looks
            like a protocol driver. An intermediate protocol driver can layer
            on top of another intermediate driver although such layering could
            have a negative effect on system performance. A typical reason for
            developing an intermediate driver is to perform media translation
            between an existing legacy protocol driver and a miniport that
            manages a NIC for a new media type unknown to the protocol driver.
            For instance, an intermediate driver could translate from LAN
            protocol to ATM protocol. An intermediate driver cannot communicate
            with user-mode applications, but only with other NDIS drivers.</para>
        </listitem>
        <listitem>
          <para><emphasis>Filter drivers</emphasis>. Filter drivers can monitor
            and modify traffic between protocol drivers and miniport drivers
            like an intermediate driver, but are much simpler. They have less
            processing overhead than intermediate drivers.</para>
        </listitem>
        <listitem>
          <para><emphasis>Transport drivers or protocol drivers</emphasis>. A
            protocol driver implements a network protocol stack such as IPX/SPX
            or TCP/IP, offering its services over one or more network interface
            cards. A protocol driver services application-layer clients at its
            upper edge and connects to one or more NIC driver(s) or
            intermediate NDIS driver(s) at its lower edge.</para>
        </listitem>
      </orderedlist>

      <para>NPF is implemented as a filter driver. In order to provide complete
        access to the raw traffic and allow injection of packets, it is
        registered as a modifying filter driver in the compression
        <literal>FilterClass</literal>.</para>

      <para>Notice that the various Windows operating systems have different
        versions of NDIS: NPF is NDIS 6.0 compliant, and so requires a Windows
        OS that supports NDIS 6.0: Windows Vista or later.</para>

      <!-- TODO: Update this figure for Npcap
      <para>Next figure shows the position of NPF inside the NDIS stack:</para>
      <p align="center"><img border="0" src="npf-ndis.gif"></para>
        <p align="center"><b>Figure 1: NPF inside NDIS.</b></para>
      -->
      <!-- TODO: Verify that this documentation is still correct for NDIS 6.0 LWF
      <para>The interaction with the OS is normally asynchronous. This means
        that the driver provides a set of callback functions that are invoked
        by the system when some operation is required to NPF. NPF exports
        callback functions for all the I/O operations of the applications:
        open, close, read, write, ioctl, etc.</para>

      <para>The interaction with NDIS is asynchronous as well: events like the
        arrival of a new packet are notified to NPF through a callback function
        (Packet_tap() in this case). Furthermore, the interaction with NDIS and
        the NIC driver takes always place by means of non blocking functions:
        when NPF invokes a NDIS function, the call returns immediately; when
        the processing ends, NDIS invokes a specific NPF callback to inform
        that the function has finished. The driver exports a callback for any
        low-level operation, like sending packets, setting or requesting
        parameters on the NIC, etc.</para>
       -->
    </sect3>
    <sect3 id="npcap-internals-structure">
      <title>NPF structure basics</title>

      <!-- TODO: Update this figure
      <para>Next figure shows the structure of Npcap, with particular reference
        to the NPF driver.</para>

        <p align="center"><img border="0" src="npf-npf.gif" width="500" height="412"></para>

          <p align="center"><b>Figure 2: NPF device driver.</b>
        -->

      <para>NPF is able to perform a number of different operations: capture,
        monitoring, packet injection. The following paragraphs
        will describe shortly each of these operations.</para>
      <sect4 id="npcap-internals-capture">
        <title>Packet Capture</title>

        <para>The most important operation of NPF is packet capture.  During a
          capture, the driver sniffs the packets using a network interface and
          delivers them intact to the user-level applications.</para>
        <para>The capture process relies on two main components:</para>
        <itemizedlist>
          <listitem><para>A packet filter that decides if an incoming packet
              has to be accepted and copied to the listening application.  Most
              applications using NPF reject far more packets than those
              accepted, therefore a versatile and efficient packet filter is
              critical for good over-all performance. A packet filter is a
              function with boolean output that is applied to a packet. If the
              value of the function is true the capture driver copies the
              packet to the application; if it is false the packet is
              discarded. NPF packet filter is a bit more complex, because it
              determines not only if the packet should be kept, but also the
              amount of bytes to keep. The filtering system adopted by NPF
              derives from the <emphasis>BSD Packet Filter</emphasis> (BPF), a
              virtual processor able to execute filtering programs expressed in
              a pseudo-assembler and created at user level. The application
              takes a user-defined filter (e.g. <quote>pick up all UDP
                packets</quote>) and, using wpcap.dll, compiles them into a BPF
              program (e.g.  <quote>if the packet is IP and the
                <literal>protocol type</literal>  field is equal to 17, then
                return true</quote>). Then, the application uses the
              <literal>BIOCSETF</literal> IOCTL to inject the filter in the
              kernel. At this point, the program is executed for every incoming
              packet, and only the conformant packets are accepted. Unlike
              traditional solutions, NPF does not
              <emphasis>interpret</emphasis> the filters, but it
              <emphasis>executes</emphasis> them. For performance reasons,
              before using the filter NPF feeds it to a JIT compiler that
              translates it into a native 80x86 function. When a packet is
              captured, NPF calls this native function instead of invoking the
              filter interpreter, and this makes the process very fast.  The
              concept behind this optimization is very similar to the one of
              Java jitters.</para>
          </listitem>
          <listitem>
            <para>A circular buffer to store the packets and avoid loss. A
              packet is stored in the buffer with a header that maintains
              information like the timestamp and the size of the packet.
              Moreover, an alignment padding is inserted between the packets in
              order to speed-up the access to their data by the applications.
              Groups of packets can be copied with a single operation from the
              NPF buffer to the applications. This improves performances
              because it minimizes the number of reads. If the buffer is full
              when a new packet arrives, the packet is discarded and hence it's
              lost. Both kernel and user buffer can be changed at runtime for
              maximum versatility: packet.dll and wpcap.dll provide functions
              for this purpose.</para>
          </listitem>
        </itemizedlist>

        <para>The size of the user buffer is very important because it determines
          the <emphasis>maximum</emphasis> amount of data that can be copied from
          kernel space to user space within a single system call. On the other
          hand, it can be noticed that also the <emphasis>minimum</emphasis>
          amount of data that can be copied in a single call is extremely
          important. In presence of a large value for this variable, the kernel
          waits for the arrival of several packets before copying the data to the
          user. This guarantees a low number of system calls, i.e. low processor
          usage, which is a good setting for applications like sniffers. On the
          other side, a small value means that the kernel will copy the packets
          as soon as the application is ready to receive them. This is excellent
          for real time applications (like, for example, ARP redirectors or
          bridges) that need the better responsiveness from the kernel.  From
          this point of view, NPF has a configurable behavior, that allows users
          to choose between best efficiency or best responsiveness (or any
          intermediate situation).</para>

        <para>The wpcap library includes a couple of system calls that can be
          used both to set the timeout after which a read expires and the minimum
          amount of data that can be transferred to the application. By default,
          the read timeout is 1 second, and the minimum amount of data copied
          between the kernel and the application is 16K.</para>
      </sect4>
      <sect4 id="npcap-internals-injection">
        <title>Packet injection</title>

        <para>NPF allows to write raw packets to the network. To send data, a
          user-level application performs a WriteFile() system call on the NPF
          device file. The data is sent to the network as is, without
          encapsulating it in any protocol, therefore the application will have
          to build the various headers for each packet. The application usually
          does not need to generate the FCS because it is calculated by the
          network adapter hardware and it is attached automatically at the end of
          a packet before sending it to the network.</para>

        <para>In normal situations, the sending rate of the packets to the
          network is not very high because of the need of a system call for each
          packet. For this reason, the possibility to send a single packet more
          than once with a single write system call has been added. The
          user-level application can set, with an IOCTL call
          (<literal>BIOCSWRITEREP</literal>), the number of times a single packet
          will be repeated: for example, if this value is set to 1000, every raw
          packet written by the application on the driver's device file will be
          sent 1000 times.  This feature can be used to generate high speed
          traffic for testing purposes: the overload of context switches is no
          longer present, so performance is remarkably better.</para>
      </sect4>

      <sect4 id="npcap-internals-monitoring">
        <title>Network monitoring</title>

        <para>Npcap offers a kernel-level programmable monitoring module, able to
          calculate simple statistics on the network traffic.  Statistics can be
          gathered without the need to copy the packets to the application, that
          simply receives and displays the results obtained from the monitoring
          engine.  This allows to avoid great part of the capture overhead in
          terms of memory and CPU clocks.</para>

        <para>The monitoring engine is made of a <emphasis>classifier</emphasis>
          followed by a <emphasis>counter</emphasis>. The packets are classified
          using the filtering engine of NPF, that provides a configurable way to
          select a subset of the traffic. The data that pass the filter go to the
          counter, that keeps some variables like the number of packets and the
          amount of bytes accepted by the filter and updates them with the data
          of the incoming packets. These variables are passed to the user-level
          application at regular intervals whose period can be configured by the
          user. No buffers are allocated at kernel and user level.</para>
      </sect4>

    </sect3>
  </sect2>
  <sect2 id="npcap-internals-references">
    <title>Further reading</title>
    <para>The structure of NPF and its filtering engine derive directly from
      the one of the BSD Packet Filter (BPF), so if you are interested the
      subject you can read the following papers:</para>
    <itemizedlist>
      <listitem><para>S. McCanne and V. Jacobson, <ulink
            url="ftp://ftp.ee.lbl.gov/papers/bpf-usenix93.ps.Z">The BSD Packet
            Filter: A New Architecture for User-level Packet Capture</ulink>.
          Proceedings of the 1993 Winter USENIX Technical Conference (San
          Diego, CA, Jan.  1993), USENIX.</para>
      </listitem>
      <listitem><para>A. Begel, S. McCanne, S.L.Graham, BPF+: <ulink
            url="http://www.acm.org/pubs/articles/proceedings/comm/316188/p123-begel/p123-begel.pdf">Exploiting
            Global Data-flow Optimization in a Generalized Packet Filter
            Architecture</ulink>, Proceedings of ACM SIGCOMM '99, pages 123-134,
          Conference on Applications, technologies, architectures, and
          protocols for computer communications, August 30 - September 3, 1999,
          Cambridge, USA</para>
      </listitem>
    </itemizedlist>
  </sect2>

</sect1>

```

`docs/npcap-intro.xml`:

```xml
<sect1 id="npcap-intro">
  <title>Introduction</title>

  <para>This Manual describes the programming interface and the source code of
    Npcap. It provides detailed descriptions of the functions and structures
    exported to programmers, along with complete documentation of the Npcap
    internals. Several tutorials and examples are provided as well.</para>

  <sect2 id="npcap-description">
    <title>What is Npcap?</title>

    <para>Npcap is an architecture for packet capture and network analysis for
      Windows operating systems, consisting of a software library and a network
      driver.</para>

    <para>Most networking applications access the network through widely-used
      operating system primitives such as sockets. It is easy to access data on
      the network with this approach since the operating system copes with the
      low level details (protocol handling, packet reassembly, etc.) and
      provides a familiar interface that is similar to the one used to read and
      write files.</para>

    <para>Sometimes, however, the <quote>easy way</quote> is not up to the task,
      since some applications require direct access to packets on the network.
      That is, they need access to the <quote>raw</quote> data on the network
      without the interposition of protocol processing by the operating
      system.</para>

    <para>The purpose of Npcap is to give this kind of access to Windows
      applications. It provides facilities to:</para>

    <itemizedlist>
      <listitem>capture raw packets, both the ones destined to the machine where
        it's running and the ones exchanged by other hosts (on shared media)</listitem>
      <listitem>filter the packets according to user-specified rules before
        dispatching them to the application</listitem>
      <listitem>transmit raw packets to the network</listitem>
      <listitem>gather statistical information on the network traffic</listitem>
    </itemizedlist>

    <para>This set of capabilities is obtained by means of a device driver,
      which is installed inside the networking portion of the Windows kernel,
      plus a couple of DLLs.</para>

    <para>All of these features are exported through a powerful programming
      interface, easily usable by applications. The main goal of this manual is
      to document this interface, with the help of several examples.</para>

    <sect3>
      <title>What kind of programs use Npcap?</title>

      <para>The Npcap programming interface can be used by many types of
        network tools for analysis, troubleshooting, security and monitoring.
        In particular, classical tools that rely on Npcap are:</para>

      <itemizedlist>
        <listitem>network and protocol analyzers</listitem>
        <listitem>network monitors</listitem>
        <listitem>traffic loggers</listitem>
        <listitem>traffic generators</listitem>
        <listitem>user-level bridges and routers</listitem>
        <listitem>network intrusion detection systems (NIDS)</listitem>
        <listitem>network scanners</listitem>
        <listitem>security tools</listitem>
      </itemizedlist>
    </sect3>

    <sect3>
      <title>What Npcap can't do</title>

      <para>Npcap receives and sends the packets independently from the host
        protocols, like TCP/IP. This means that it isn't able to block, filter or
        manipulate the traffic generated by other programs on the same machine: it 
        simply <quote>sniffs</quote> the packets that transit on the wire. Therefore, it does not 
        provide the appropriate support for applications like traffic shapers, QoS 
        schedulers and personal firewalls. </para>
    </sect3>

  </sect2>

  <sect2 id="npcap-features">
    <title>Npcap Features</title>

      <para>Npcap has many exciting features that set it above other packet capture solutions:</para>

      <itemizedlist>
        <listitem><para><emphasis>Built for modern Windows</emphasis>: Npcap is written for Windows 10, Windows 8.1, Windows 8, and Windows 7. Using up-to-date NDIS versions, it allows you to capture traffic without slowing down the network stack. Npcap is implemented as a NDIS 6 Lightweight Filter driver, faster and with less overhead
	    than the legacy <ulink role="hidepdf" url="https://docs.microsoft.com/en-us/previous-versions/windows/hardware/network/ff557149(v=vs.85)">NDIS 5 Protocol Driver</ulink>
            used by WinPcap.
        </para></listitem>

	<listitem><para><emphasis>WinPcap compatibility</emphasis>: Npcap is a
	    drop-in replacement for <ulink role="hidepdf" url="https://www.winpcap.org/">WinPcap</ulink>
	    in most applications. 
        </para></listitem>

	<listitem><para><emphasis>Updated cross-platform libpcap API</emphasis>:
	    The libpcap API allows cross-platform packet capture applications
	    to target Linux, Windows, macOS, BSD, Solaris and others. Npcap includes
            the latest version of <ulink role="hidepdf" url="https://tcpdump.org">libpcap</ulink>,
	    providing the best solution for compatibility, performance, functionality, and security.
            </para></listitem>

        <listitem><para><emphasis>Loopback packet capture and injection</emphasis>: Npcap is able to
            see Windows loopback packets using the
            <ulink role="hidepdf" url="https://msdn.microsoft.com/en-us/library/windows/desktop/aa366510(v=vs.85).aspx">
              Windows Filtering Platform (WFP)</ulink>. Npcap supplies an
            interface named <quote>NPF_Loopback</quote>, with the description <quote>Adapter for loopback capture.</quote>
            Wireshark users can choose this adapter to capture all loopback traffic the same way as other
	    non-loopback adapters.
	    Packet injection works as well with <function>pcap_inject()</function>.
            </para></listitem>

        <listitem><para><emphasis>Raw 802.11 Packet Capture Support</emphasis>: Npcap is able to see
            <emphasis>802.11</emphasis> frames instead of <emphasis>emulated Ethernet</emphasis> frames on ordinary wireless
            adapters. You need to select the <option>Support raw 802.11 traffic (and monitor
              mode) for wireless adapters</option> option in the installation wizard to enable
            this feature. When your adapter is in <quote>Monitor Mode</quote>, Npcap will supply all
	    <emphasis>802.11 data + control + management</emphasis> packets with <ulink role="hidepdf" url="http://www.radiotap.org/">Radiotap</ulink> headers. When
            your adapter is in <quote>Managed Mode</quote>, Npcap will only supply <emphasis>Ethernet</emphasis>
            packets. Npcap directly supports using Wireshark to capture in <quote>Monitor Mode</quote>.
            Npcap also provides the <filename>WlanHelper.exe</filename>
            tool to manually configure WiFi PHY parameters. See more details
            about this feature in <xref linkend="npcap-feature-dot11" />.
            </para></listitem>

        <listitem><para><emphasis><quote>Admin-only Mode</quote> Support</emphasis>: Npcap supports restricting its
            use to Administrators for safety purpose. If Npcap is installed with
            the option <quote>Restrict Npcap driver's access to Administrators only</quote> checked,
            only Built-in Administrators may access its features via user software (Nmap, Wireshark, etc).
	    This provides a level of restriction similar to requiring root access for packet capture on Linux/UNIX.</para></listitem>

      </itemizedlist>
  </sect2>

  <sect2>
    <title>Purpose of this manual</title>

    <para>The purpose of this manual is to provide a comprehensive and easy way
      to browse the documentation of the Npcap architecture. You will find
      three main sections:</para>

    <para><xref linkend="npcap-users-guide" /> is for end users of Npcap, and
      primarily concerns installation options, hardware compatibility, and bug
      reporting procedures.</para>

    <para><xref linkend="npcap-devguide" /> is for programmers who need to use
      Npcap from an application: it contains information about functions and
      data structures exported by the Npcap API, a manual for writing packet
      filters, and information on how to include it in an application. A
      tutorial with several code samples is provided as well; it can be used to
      learn the basics of the Npcap API using a step-by-step approach, but it
      also offers code snippets that demonstrate advanced features.</para>

    <para><xref linkend="npcap-internals" /> is intended for Npcap developers
      and maintainers, or for people who are curious about how this system
      works: it provides a general description of the Npcap architecture and
      explains how it works. Additionally, it documents the complete device
      driver structure, the source code, the Packet.dll interface and the
      low-level Npcap API. If you want to understand what happens inside Npcap
      or if you need to extend it, this is the section you will want to
      read.</para>
  </sect2>

  <sect2>
    <title>Terminology</title>

    <para>We call Npcap an <wordasword>architecture</wordasword> rather than
      <wordasword>library</wordasword> because packet capture is a low level
      mechanism that requires a strict interaction with the network adapter and
      with the operating system, in particular with its networking
      implementation, so a simple library is not sufficient.</para>

    <para>For consistency with the literature, we will use the term
      <wordasword>packet</wordasword> even though
      <wordasword>frame</wordasword> is more accurate since the capture process
      is done at the data-link layer and the data-link header is included in
      the captured data.</para>

  </sect2>

  <sect2 id="npcap-license">
    <title>Npcap License</title>

    <para>Even though Npcap source code is publicly available for review, it is
      not open source software and may not be redistributed without special 
      permission from the Nmap Project. The
      <ulink
	  url="https://github.com/nmap/npcap/blob/master/LICENSE">Npcap
      Free License</ulink>
      allows end users to download, install, and use up to 5 copies of
      Npcap from our site for
      free. Copies which are only used with <ulink
      url="https://nmap.org">Nmap</ulink>, <ulink url="https://www.wireshark.org">Wireshark</ulink>, and/or
      <ulink
	  url="https://www.microsoft.com/en-us/microsoft-365/security/identity-defender">Microsoft
      Defender for Identity</ulink> don't count toward this 5-install
      limit.
    </para>


    <para>We fund the Npcap project by selling the Npcap OEM
    Edition. This special version of Npcap includes enterprise
    features such as the silent installer and commercial support as
    well as special license rights allowing customers to redistribute
    Npcap with their products or to install it on more systems within
    their organization with easy enterprise deployment. We offer two
    commercial license types:</para>

    <itemizedlist>
      <listitem>
	<para>The <ulink
	url="https://npcap.com/oem/redist.html">Npcap OEM
	Redistribution License</ulink> is for companies that wish to
	distribute Npcap OEM within their products (the free Npcap
	edition does not allow this). Licensees generally use the
	Npcap OEM silent installer, ensuring a seamless experience for
	end users. Licensees may choose between a perpetual unlimited
	license or an annual term license, along with options for
	commercial support and updates.</para>
      </listitem>
      <listitem>
	<para>The <ulink
	url="https://npcap.com/oem/internal.html">Npcap OEM
	Internal-Use License</ulink> is for organizations that wish to
	use Npcap OEM internally without redistribution outside their
	organization. This allows them to bypass the 5-system usage
	cap of the Npcap free edition. It includes commercial support
	and update options, and provides the extra Npcap OEM features
	such as the silent installer for enterprise-wide
	deployment.</para>
      </listitem>
    </itemizedlist>    
  </sect2>

  <sect2 id="npcap-download">
    <title>Obtaining Npcap</title>

    <para>The latest Npcap release can always be found
      <ulink url="https://npcap.com/#download">on the Npcap
        website</ulink> as an executable installer and as a source code
      archive.</para>
  </sect2>

  <sect2 id="npcap-guide-copyright">
    <title>Acknowledgements and copyright</title>

    <para>Npcap is an update of <ulink role="hidepdf" url="https://www.winpcap.org/">WinPcap</ulink>.
      It is developed
      by the <ulink role="hidepdf" url="https://nmap.org/">Nmap Project</ulink>
      as a continuation of the project started by Yang Luo
      under <ulink role="hidepdf" url="https://www.google-melange.com/gsoc/project/details/google/gsoc2013/hsluoyz/5727390428823552">Google Summer of Code 2013</ulink> and
      <ulink role="hidepdf" url="https://www.google-melange.com/gsoc/project/details/google/gsoc2015/hsluoyz/5723971634855936">2015</ulink>.
      It also received many helpful tests from <ulink role="hidepdf" url="https://www.wireshark.org/">Wireshark</ulink>
      and <ulink role="hidepdf" url="https://www.netscantools.com/">NetScanTools</ulink>.
    </para>

    <para>Portions of this guide were adapted from the WinPcap documentation.
      Copyright &#169; 2002-2005 Politecnico di Torino. Copyright &#169;
      2005-2010 CACE Technologies. Copyright &#169; 2010-2013 Riverbed
      Technology. Copyright &#169; 2025 Nmap Software LLC. All rights
      reserved.</para>
  </sect2>
</sect1>

```

`docs/npcap-tutorial.xml`:

```xml
<sect1 id="npcap-tutorial">
  <title>Npcap Development Tutorial</title>
  <sect1info>
    <abstract>
      <para>A step-by-step guide to writing software that uses Npcap to list
        network adapters, capture packets, and send network traffic.</para>
    </abstract>
  </sect1info>

  <para>This section shows how to use the features of the Npcap API. It is
    organized as a tutorial, subdivided into a set of lessons that will
    introduce the reader, in a step-by-step fashion, to program development
    using Npcap, from the basic functions (obtaining the adapter list,
    starting a capture, etc.) to the most advanced ones (handling send queues
    and gathering statistics about network traffic).</para>

  <!-- REVISE
  <para>Several code snippets, as well as simple but complete programs are
    provided as a reference: all of the source code contains links to the rest
    of the manual, making it is possible to click on functions and data
    structures to jump to the corresponding documentation.</para>
-->

  <para>The samples are written in plain C, so a basic knowledge of C
    programming is required. Also, since this is a tutorial about a library
    dealing with "raw" networking packets, good knowledge of networks and
    network protocols is assumed.</para>

  <para>The code in this section is copied from the <xref
      linkend="npcap-examples">Examples directory</xref> in the source
    distribution and the SDK. The code is released under a BSD-3-clause license and
    copyright: NetGroup, Politecnico di Torino (Italy); CACE Technologies,
    Davis (California); and Insecure.com, LLC. Full text of the code license
    can be found in each source file.</para>

  <sect2 id="npcap-tutorial-devlist">
    <title>Obtaining the device list</title>
    <para>Typically, the first thing that a Npcap-based application does is
      get a list of attached network adapters. Both libpcap and Npcap provide
      the <ulink url="wpcap/pcap_findalldevs.html">pcap_findalldevs_ex()</ulink> function for this purpose:
      this function returns a linked list of <literal>pcap_if</literal> structures, each of which contains
      comprehensive information about an attached adapter. In particular, the
      fields <literal>name</literal> and <literal>description</literal> contain the name and a
      human readable description, respectively, of the corresponding
      device.</para>

    <para>The following code retrieves the adapter list and shows it on the
      screen, printing an error if no adapters are found.</para>

    <programlisting language="C"><!-- inline --><![CDATA[
#include "pcap.h"

main()
{
  pcap_if_t *alldevs;
  pcap_if_t *d;
  int i=0;
  char errbuf[PCAP_ERRBUF_SIZE];
  
  /* Retrieve the device list from the local machine */
  if (pcap_findalldevs_ex(PCAP_SRC_IF_STRING,
    NULL /* auth is not needed */,
    &alldevs, errbuf) == -1)
  {
    fprintf(stderr,
      "Error in pcap_findalldevs_ex: %s\n",
      errbuf);
    exit(1);
  }
  
  /* Print the list */
  for(d= alldevs; d != NULL; d= d->next)
  {
    printf("%d. %s", ++i, d->name);
    if (d->description)
      printf(" (%s)\n", d->description);
    else
      printf(" (No description available)\n");
  }
  
  if (i == 0)
  {
    printf("\nNo interfaces found! Make sure Npcap is installed.\n");
    return;
  }

  /* We don't need any more the device list. Free it */
  pcap_freealldevs(alldevs);
}
]]></programlisting>

    <para>Some comments about this code.</para>

    <para>First of all, <ulink
        url="./wpcap/pcap_findalldevs.html">pcap_findalldevs_ex()</ulink>, like
      other libpcap functions, has an <literal>errbuf</literal> parameter. This
      parameter points to a string filled by libpcap with a description of the
      error if something goes wrong.</para>

    <para>Second, remember that not all the OSes supported by libpcap provide a
      description of the network interfaces, therefore if we want to write a
      portable application, we must consider the case in which
      <literal>description</literal> is null: we print the string "No
      description available" in that situation.</para>

    <para>Note finally that we free the list with <ulink
        url="wpcap/pcap_findalldevs.html">pcap_freealldevs()</ulink> once when
      we have finished with it.</para>

    <para>Assuming we have compiled the program, let's try to run it. On a
      particular Windows workstation, the result we optained is</para>

    <screen>
1. \Device\NPF_{4E273621-5161-46C8-895A-48D0E52A0B83} (Realtek RTL8029(AS) Ethernet Adapter)
2. \Device\NPF_{5D24AE04-C486-4A96-83FB-8B5EC6C7F430} (3Com EtherLink PCI)</screen>
    
    <para>As you can see, the name of the network adapters (that will be passed
      to libpcap when opening the devices) under Windows are quite unreadable,
      so the parenthetical descriptions can be very helpful.</para>
  </sect2>

  <sect2 id="npcap-tutorial-devdetails">
    <title>Obtaining advanced information about installed devices</title>

    <para>Lesson 1 (<xref linkend="npcap-tutorial-devlist" />) demonstrated how
      to get basic information (i.e. device name and description) about
      available adapters. Actually, Npcap provides also other advanced
      information. In particular, every <literal>pcap_if</literal> structure
      returned by <ulink
        url="wpcap/pcap_findalldevs.html">pcap_findalldevs_ex()</ulink>
      contains also a list of <literal>pcap_addr</literal> structures,
      with:</para>

    <itemizedlist>
      <listitem>a list of addresses for that interface.</listitem>
      <listitem>a list of netmasks (each of which corresponds to an entry in
        the addresses list).</listitem>
      <listitem>a list of broadcast addresses (each of which corresponds to an
        entry in the addresses list).</listitem>
      <listitem>a list of destination addresses (each of which corresponds to
        an entry in the addresses list).</listitem>
    </itemizedlist>

    <para>Additionally, <literal>pcap_findalldevs_ex()</literal> can also
      return remote adapters and a list of pcap files that are located in a
      given local folder.</para>

    <para>The following sample provides an ifprint() function that prints the
      complete contents of a <literal>pcap_if</literal> structure. It is
      invoked by the program for every entry returned by
      <literal>pcap_findalldevs_ex()</literal>.</para>

    <programlisting language="C"><!-- Examples/iflist/iflist.c --><![CDATA[
/* Print all the available information on the given interface */
void ifprint(pcap_if_t *d)
{
  pcap_addr_t *a;
  char ip6str[128];

  /* Name */
  printf("%s\n",d->name);

  /* Description */
  if (d->description)
    printf("\tDescription: %s\n",d->description);

  /* Loopback Address*/
  printf("\tLoopback: %s\n",(d->flags & PCAP_IF_LOOPBACK)?"yes":"no");

  /* IP addresses */
  for(a=d->addresses;a;a=a->next) {
    printf("\tAddress Family: #%d\n",a->addr->sa_family);
  
    switch(a->addr->sa_family)
    {
      case AF_INET:
        printf("\tAddress Family Name: AF_INET\n");
        if (a->addr)
          printf("\tAddress: %s\n",iptos(((struct sockaddr_in *)a->addr)->sin_addr.s_addr));
        if (a->netmask)
          printf("\tNetmask: %s\n",iptos(((struct sockaddr_in *)a->netmask)->sin_addr.s_addr));
        if (a->broadaddr)
          printf("\tBroadcast Address: %s\n",iptos(((struct sockaddr_in *)a->broadaddr)->sin_addr.s_addr));
        if (a->dstaddr)
          printf("\tDestination Address: %s\n",iptos(((struct sockaddr_in *)a->dstaddr)->sin_addr.s_addr));
        break;

      case AF_INET6:
        printf("\tAddress Family Name: AF_INET6\n");
        if (a->addr)
          printf("\tAddress: %s\n", ip6tos(a->addr, ip6str, sizeof(ip6str)));
       break;

      default:
        printf("\tAddress Family Name: Unknown\n");
        break;
    }
  }
  printf("\n");
}
]]></programlisting>

  </sect2>

  <sect2 id="npcap-tutorial-openadapter">
    <title>Opening an adapter and capturing the packets</title>

    <para>Now that we've seen how to obtain an adapter to play with, let's
      start the real job, opening an adapter and capturing some traffic. In
      this lesson we'll write a program that prints some information about each
      packet flowing through the adapter.</para>

    <para>The function that opens a capture device is <ulink
        url="wpcap/pcap_open.html">pcap_open()</ulink>. The parameters,
      <literal>snaplen</literal>, <literal>flags</literal> and
      <literal>to_ms</literal> deserve some explanation.</para>

    <para><literal>snaplen</literal> specifies the portion of the packet to capture. On
      some OSes (like xBSD and Win32), the packet driver can be configured to
      capture only the initial part of any packet: this decreases the amount of
      data to copy to the application and therefore improves the efficiency of
      the capture. In this case we use the value 65536 which is higher than the
      greatest MTU that we could encounter. In this manner we ensure that the
      application will always receive the whole packet.</para>

    <para><literal>flags:</literal> the most important flag is the one that
      indicates if the adapter will be put in promiscuous mode. In normal
      operation, an adapter only captures packets from the network that are
      destined to it; the packets exchanged by other hosts are therefore
      ignored. Instead, when the adapter is in promiscuous mode it captures all
      packets whether they are destined to it or not. This means that on shared
      media (like non-switched Ethernet), Npcap will be able to capture the
      packets of other hosts. Promiscuous mode is the default for most capture
      applications, so we enable it in the following example.</para>

    <para><literal>to_ms</literal> specifies the read timeout, in milliseconds.
      A read on the adapter (for example, with <ulink
        url="wpcap/pcap_loop.html">pcap_dispatch()</ulink> or <ulink
        url="wpcap/pcap_next_ex.html">pcap_next_ex()</ulink>) will always
      return after <literal>to_ms</literal> milliseconds, even if no packets
      are available from the network. <literal>to_ms</literal> also defines the
      interval between statistical reports if the adapter is in statistical
      mode (see the lesson "\ref wpcap_tut9" for information about statistical
      mode). Setting <literal>to_ms</literal> to 0 means no timeout, a read on
      the adapter never returns if no packets arrive. A -1 timeout on the other
      side causes a read on the adapter to always return immediately.</para>

    <programlisting language="C"><!-- Examples/misc/basic_dump.c --><![CDATA[
#include <pcap.h>
#include "misc.h" /* LoadNpcapDlls */

/* prototype of the packet handler */
void packet_handler(
  u_char *param,
  const struct pcap_pkthdr *header,
  const u_char *pkt_data);

int main()
{
  pcap_if_t *alldevs;
  pcap_if_t *d;
  int inum;
  int i=0;
  pcap_t *adhandle;
  char errbuf[PCAP_ERRBUF_SIZE];
  
  /* Load Npcap and its functions. */
  if (!LoadNpcapDlls())
  {
    fprintf(stderr, "Couldn't load Npcap\n");
    exit(1);
  }

  /* Retrieve the device list on the local machine */
  if (pcap_findalldevs_ex(PCAP_SRC_IF_STRING,
    NULL, &alldevs, errbuf) == -1)
  {
    fprintf(stderr,"Error in pcap_findalldevs: %s\n", errbuf);
    exit(1);
  }
  
  /* Print the list */
  for(d=alldevs; d; d=d->next)
  {
    printf("%d. %s", ++i, d->name);
    if (d->description)
      printf(" (%s)\n", d->description);
    else
      printf(" (No description available)\n");
  }
  
  if(i==0)
  {
    printf("\nNo interfaces found! Make sure Npcap is installed.\n");
    return -1;
  }
  
  printf("Enter the interface number (1-%d):",i);
  scanf_s("%d", &inum);
  
  if(inum < 1 || inum > i)
  {
    printf("\nInterface number out of range.\n");
    /* Free the device list */
    pcap_freealldevs(alldevs);
    return -1;
  }
  
  /* Jump to the selected adapter */
  for(d=alldevs, i=0; i< inum-1 ;d=d->next, i++);
  
  /* Open the device */
  if ( (adhandle= pcap_open(d->name, // name of the device
          65536, // portion of the packet to capture
                 // 65536 guarantees that the whole packet will
                 // be captured on all the link layers
          PCAP_OPENFLAG_PROMISCUOUS, // promiscuous mode
          1000, // read timeout
          NULL, // authentication on the remote machine
          errbuf // error buffer
          ) ) == NULL)
  {
    fprintf(stderr,
      "\nUnable to open the adapter. %s is not supported by Npcap\n",
      d->name);
    /* Free the device list */
    pcap_freealldevs(alldevs);
    return -1;
  }
  
  printf("\nlistening on %s...\n", d->description);
  
  /* At this point, we don't need any more the device list. Free it */
  pcap_freealldevs(alldevs);
  
  /* start the capture */
  pcap_loop(adhandle, 0, packet_handler, NULL);
  
  return 0;
}


/* Callback function invoked by libpcap for every incoming packet */
void packet_handler(u_char *param,
  const struct pcap_pkthdr *header,
  const u_char *pkt_data)
{
  struct tm ltime;
  char timestr[16];
  time_t local_tv_sec;

  /*
   * unused variables
   */
  (VOID)(param);
  (VOID)(pkt_data);

  /* convert the timestamp to readable format */
  local_tv_sec = header->ts.tv_sec;
  localtime_s(&ltime, &local_tv_sec);
  strftime( timestr, sizeof timestr, "%H:%M:%S", &ltime);
  
  printf("%s,%.6d len:%d\n",
    timestr, header->ts.tv_usec, header->len);
}
]]></programlisting>

    <para>Once the adapter is opened, the capture can be started with <ulink
        url="wpcap/pcap_loop.html">pcap_dispatch()</ulink> or <ulink
        url="wpcap/pcap_loop.html">pcap_loop()</ulink>. These two functions are
      very similar, the difference is that <literal>pcap_dispatch()</literal>
      returns (although not guaranteed) when the timeout expires while
      <literal>pcap_loop()</literal> doesn't return until
      <literal>cnt</literal> packets have been captured, so it can block for an
      arbitrary period on an under-utilized network.
      <literal>pcap_loop()</literal> is enough for the purpose of this sample,
      while <literal>pcap_dispatch()</literal> is normally used in a more
      complex program.</para>

    <para>Both of these functions have a <literal>callback</literal> parameter,
      <literal>packet_handler</literal>, pointing to a function that will
      receive the packets. This function is invoked by libpcap for every new
      packet coming from the network and receives a generic status
      (corresponding to the <literal>user</literal> parameter of <ulink
        url="wpcap/pcap_loop.html">pcap_loop()</ulink> and <ulink
        url="wpcap/pcap_loop.html">pcap_dispatch()</ulink>), a header with some
      information on the packet like the timestamp and the length and the
      actual data of the packet including all the protocol headers. Note that
      the frame CRC is normally not present, because it is removed by the
      network adapter after frame validation. Note also that most adapters
      discard packets with wrong CRCs, therefore Npcap is normally not able
      to capture them.</para>

    <para>The above example extracts the timestamp and the length of every
      packet from the <literal>pcap_pkthdr</literal> header and prints them on
      the screen.</para>

    <para>Please note that there may be a drawback using <ulink
        url="wpcap/pcap_loop.html">pcap_loop()</ulink> mainly related to the
      fact that the handler is called by the packet capture driver; therefore
      the user application does not have direct control over it. Another
      approach (and to have more readable programs) is to use the <ulink
        url="wpcap/pcap_next_ex.html">pcap_next_ex()</ulink> function, which is
      presented in the next example (<xref linkend="npcap-tutorial-pcap-next-ex"
        />).</para>
  </sect2>

  <sect2 id="npcap-tutorial-pcap-next-ex">
    <title>Capturing the packets without the callback</title>

    <para>The example program in this lesson behaves exactly like the previous
      program (<xref linkend="npcap-tutorial-openadapter" />), but it uses
      <ulink url="wpcap/pcap_next_ex.html">pcap_next_ex()</ulink> instead of
      <ulink url="wpcap/pcap_loop.html">pcap_loop()</ulink>.</para>

    <para>The callback-based capture mechanism of <ulink
        url="wpcap/pcap_loop.html">pcap_loop()</ulink> is elegant and it could
      be a good choice in some situations. However, handling a callback is
      sometimes not practical&#x2014;it often makes the program more complex
      especially in situations with multithreaded applications or C++
      classes.</para>

    <para>In these cases, <ulink
        url="wpcap/pcap_next_ex.html">pcap_next_ex()</ulink> retrievs a packet
      with a direct call&#x2014;using <literal>pcap_next_ex()</literal>,
      packets are received only when the programmer wants them.</para>

    <para>The parameters of this function are the same as a capture callback.
      It takes an adapter descriptor and a couple of pointers that will be
      initialized and returned to the user (one to a
      <literal>pcap_pkthdr</literal> structure and another to a buffer with the
      packet data).</para>

    <para>In the following program, we recycle the callback code of the
      previous lesson's example and move it inside main() right after the call
      to <ulink url="wpcap/pcap_next_ex.html">pcap_next_ex()</ulink>.</para>

    <programlisting language="C"><!-- Examples/misc/basic_dump_ex.c --><![CDATA[
/* Open the device */
if ( (adhandle= pcap_open(d->name, // name of the device
      65536, // portion of the packet to capture. 
             // 65536 guarantees that the whole packet will
             // be captured on all the link layers
      PCAP_OPENFLAG_PROMISCUOUS, // promiscuous mode
      1000, // read timeout
      NULL, // authentication on the remote machine
      errbuf // error buffer
  ) ) == NULL)
{
  fprintf(stderr,
    "\nUnable to open the adapter. %s is not supported by Npcap\n",
    d->name);
  /* Free the device list */
  pcap_freealldevs(alldevs);
  return -1;
}

printf("\nlistening on %s...\n", d->description);

/* At this point, we don't need any more the device list. Free it */
pcap_freealldevs(alldevs);

/* Retrieve the packets */
while((res = pcap_next_ex( adhandle, &header, &pkt_data)) >= 0){

  if(res == 0)
    /* Timeout elapsed */
    continue;

  /* convert the timestamp to readable format */
  local_tv_sec = header->ts.tv_sec;
  localtime_s(&ltime, &local_tv_sec);
  strftime( timestr, sizeof timestr, "%H:%M:%S", &ltime);

  printf("%s,%.6d len:%d\n", timestr, header->ts.tv_usec, header->len);
}

if(res == -1){
  printf("Error reading the packets: %s\n", pcap_geterr(adhandle));
  return -1;
}
]]></programlisting>

    <para>Why do we use <ulink
        url="wpcap/pcap_next_ex.html">pcap_next_ex()</ulink> instead of the old
      <ulink url="wpcap/pcap_loop.html">pcap_next()</ulink>? Because
      <literal>pcap_next()</literal> has some drawbacks. First of all, it is
      inefficient because it hides the callback method but still relies on
      <literal>pcap_dispatch()</literal>. Second, it is not able to detect EOF,
      so it's not very useful when gathering packets from a file.</para>

    <para>Notice also that <literal>pcap_next_ex()</literal> returns different
      values for success, timeout elapsed, error and EOF conditions.</para>
  </sect2>

  <sect2 id="npcap-tutorial-filtering">
    <title>Filtering the traffic</title>

    <para>One of the most powerful features offered by Npcap (and by libpcap as
      well) is the filtering engine. It provides a very efficient way to
      receive subsets of the network traffic, and is (usually) integrated with
      the capture mechanism provided by Npcap. The functions used to filter
      packets are <ulink url="wpcap/pcap_compile.html">pcap_compile()</ulink>
      and <ulink
        url="wpcap/pcap_setfilter.html">pcap_setfilter()</ulink>.</para>

    <para><ulink url="wpcap/pcap_compile.html">pcap_compile()</ulink> takes a
      string containing a high-level Boolean (filter) expression and produces a
      low-level byte code that can be interpreted by the fileter engine in the
      packet driver. The syntax of the boolean expression can be found in the
      <ulink url="wpcap/pcap-filter.html">Filtering expression syntax</ulink>
      section of this documentation.</para>

    <para><ulink url="wpcap/pcap_setfilter.html">pcap_setfilter()</ulink>
      associates a filter with a capture session in the kernel driver. Once
      <literal>pcap_setfilter()</literal> is called, the associated filter will
      be applied to all the packets coming from the network, and all the
      conformant packets (i.e., packets for which the Boolean expression
      evaluates to true) will be actually copied to the application.</para>

    <para>The following code shows how to compile and set a filter. Note that
      we must retrieve the netmask from the <literal>pcap_if</literal>
      structure that describes the adapter, because some filters created by
      <literal>pcap_compile()</literal> require it.</para>

    <para>The filter passed to <literal>pcap_compile()</literal> in this code
      snippet is "ip and tcp", which means to "keep only the packets that are
      both IPv4 and TCP and deliver them to the application".</para>

    <!-- TODO: PCAP_NETMASK_UNKNOWN? -->
    <programlisting language="C"><!-- inline --><![CDATA[
if (d->addresses != NULL)
  /* Retrieve the mask of the first address of the interface */
  netmask=((struct sockaddr_in *)(d->addresses->netmask))->sin_addr.S_un.S_addr;
else
  /* If the interface is without an address
   * we suppose to be in a C class network */
  netmask=0xffffff; 


//compile the filter
if (pcap_compile(adhandle, &fcode, "ip and tcp", 1, netmask) < 0)
{
  fprintf(stderr,
    "\nUnable to compile the packet filter. Check the syntax.\n");
  /* Free the device list */
  pcap_freealldevs(alldevs);
  return -1;
}

//set the filter
if (pcap_setfilter(adhandle, &fcode) < 0)
{
  fprintf(stderr,"\nError setting the filter.\n");
  /* Free the device list */
  pcap_freealldevs(alldevs);
  return -1;
}
]]></programlisting>

    <para>If you want to see some code that uses the filtering functions shown
      in this lesson, look at the example presented in the next Lesson, <xref
        linkend="npcap-tutorial-interpreting" />.</para>

  </sect2>

  <sect2 id="npcap-tutorial-interpreting">
    <title>Interpreting the packets</title>

    <para>Now that we are able to capture and filter network traffic, we want
      to put our knowledge to work with a simple "real world"
      application.</para>
   
    <para>In this lesson we will take code from the previous lessons and use
      these pieces to build a more useful program. the main purpose of the
      current program is to show how the protocol headers of a captured packet
      can be parsed and interpreted. The resulting application, called UDPdump,
      prints a summary of the UDP traffic on our network.</para>

    <para>We have chosen to parse and display the UDP protocol because it is
      more accessible than other protocols such as TCP and consequently is an
      excellent initial example. Let's look at the code:</para>

    <programlisting language="C"><!-- Examples/UDPdump/udpdump.c --><![CDATA[
#include <pcap.h>
#include <Winsock2.h>
#include <tchar.h>
BOOL LoadNpcapDlls()
{
  _TCHAR npcap_dir[512];
  UINT len;
  len = GetSystemDirectory(npcap_dir, 480);
  if (!len) {
    fprintf(stderr, "Error in GetSystemDirectory: %x", GetLastError());
    return FALSE;
  }
  _tcscat_s(npcap_dir, 512, _T("\\Npcap"));
  if (SetDllDirectory(npcap_dir) == 0) {
    fprintf(stderr, "Error in SetDllDirectory: %x", GetLastError());
    return FALSE;
  }
  return TRUE;
}


/* 4 bytes IP address */
typedef struct ip_address{
  u_char byte1;
  u_char byte2;
  u_char byte3;
  u_char byte4;
}ip_address;

/* IPv4 header */
typedef struct ip_header{
  u_char  ver_ihl; // Version (4 bits) + IP header length (4 bits)
  u_char  tos;     // Type of service 
  u_short tlen;    // Total length 
  u_short identification; // Identification
  u_short flags_fo; // Flags (3 bits) + Fragment offset (13 bits)
  u_char  ttl;      // Time to live
  u_char  proto;    // Protocol
  u_short crc;      // Header checksum
  ip_address  saddr; // Source address
  ip_address  daddr; // Destination address
  u_int  op_pad;     // Option + Padding
}ip_header;

/* UDP header*/
typedef struct udp_header{
  u_short sport; // Source port
  u_short dport; // Destination port
  u_short len;   // Datagram length
  u_short crc;   // Checksum
}udp_header;

/* prototype of the packet handler */
void packet_handler(u_char *param,
  const struct pcap_pkthdr *header,
  const u_char *pkt_data);


int main()
{
  pcap_if_t *alldevs;
  pcap_if_t *d;
  int inum;
  int i=0;
  pcap_t *adhandle;
  char errbuf[PCAP_ERRBUF_SIZE];
  u_int netmask;
  char packet_filter[] = "ip and udp";
  struct bpf_program fcode;

  /* Load Npcap and its functions. */
  if (!LoadNpcapDlls())
  {
    fprintf(stderr, "Couldn't load Npcap\n");
    exit(1);
  }

  /* Retrieve the device list */
  if (pcap_findalldevs_ex(PCAP_SRC_IF_STRING,
     NULL, &alldevs, errbuf) == -1)
  {
    fprintf(stderr,"Error in pcap_findalldevs: %s\n", errbuf);
    exit(1);
  }
  
  /* Print the list */
  for(d=alldevs; d; d=d->next)
  {
    printf("%d. %s", ++i, d->name);
    if (d->description)
      printf(" (%s)\n", d->description);
    else
      printf(" (No description available)\n");
  }

  if(i==0)
  {
    printf("\nNo interfaces found! Make sure Npcap is installed.\n");
    return -1;
  }
  
  printf("Enter the interface number (1-%d):",i);
  scanf_s("%d", &inum);
  
  if(inum < 1 || inum > i)
  {
    printf("\nInterface number out of range.\n");
    /* Free the device list */
    pcap_freealldevs(alldevs);
    return -1;
  }

  /* Jump to the selected adapter */
  for(d=alldevs, i=0; i< inum-1 ;d=d->next, i++);
  
  /* Open the adapter */
  if ( (adhandle= pcap_open(d->name, // name of the device
               65536, // portion of the packet to capture. 
                      // 65536 grants that the whole packet
                      // will be captured on all the MACs.
               PCAP_OPENFLAG_PROMISCUOUS, // promiscuous mode
               1000, // read timeout
               NULL, // remote authentication
               errbuf // error buffer
               ) ) == NULL)
  {
    fprintf(stderr,
      "\nUnable to open the adapter. %s is not supported by Npcap\n",
      d->name);
    /* Free the device list */
    pcap_freealldevs(alldevs);
    return -1;
  }
  
  /* Check the link layer. We support only Ethernet for simplicity. */
  if(pcap_datalink(adhandle) != DLT_EN10MB)
  {
    fprintf(stderr,"\nThis program works only on Ethernet networks.\n");
    /* Free the device list */
    pcap_freealldevs(alldevs);
    return -1;
  }
  
  if(d->addresses != NULL)
    /* Retrieve the mask of the first address of the interface */
    netmask=((struct sockaddr_in *)(d->addresses->netmask))->sin_addr.S_un.S_addr;
  else
    /* If the interface is without addresses
     * we suppose to be in a C class network */
    netmask=0xffffff; 


  //compile the filter
  if (pcap_compile(adhandle, &fcode, packet_filter, 1, netmask) <0 )
  {
    fprintf(stderr,"\nUnable to compile the packet filter. Check the syntax.\n");
    /* Free the device list */
    pcap_freealldevs(alldevs);
    return -1;
  }
  
  //set the filter
  if (pcap_setfilter(adhandle, &fcode)<0)
  {
    fprintf(stderr,"\nError setting the filter.\n");
    /* Free the device list */
    pcap_freealldevs(alldevs);
    return -1;
  }
  
  printf("\nlistening on %s...\n", d->description);
  
  /* At this point, we don't need any more the device list. Free it */
  pcap_freealldevs(alldevs);
  
  /* start the capture */
  pcap_loop(adhandle, 0, packet_handler, NULL);
  
  return 0;
}

/* Callback function invoked by libpcap for every incoming packet */
void packet_handler(u_char *param,
  const struct pcap_pkthdr *header,
  const u_char *pkt_data)
{
  struct tm ltime;
  char timestr[16];
  ip_header *ih;
  udp_header *uh;
  u_int ip_len;
  u_short sport,dport;
  time_t local_tv_sec;

  /*
   * Unused variable
   */
  (VOID)(param);

  /* convert the timestamp to readable format */
  local_tv_sec = header->ts.tv_sec;
  localtime_s(&ltime, &local_tv_sec);
  strftime( timestr, sizeof timestr, "%H:%M:%S", &ltime);

  /* print timestamp and length of the packet */
  printf("%s.%.6d len:%d ", timestr, header->ts.tv_usec, header->len);

  /* retireve the position of the ip header */
  ih = (ip_header *) (pkt_data +
    14); //length of ethernet header

  /* retireve the position of the udp header */
  ip_len = (ih->ver_ihl & 0xf) * 4;
  uh = (udp_header *) ((u_char*)ih + ip_len);

  /* convert from network byte order to host byte order */
  sport = ntohs( uh->sport );
  dport = ntohs( uh->dport );

  /* print ip addresses and udp ports */
  printf("%d.%d.%d.%d.%d -> %d.%d.%d.%d.%d\n",
    ih->saddr.byte1,
    ih->saddr.byte2,
    ih->saddr.byte3,
    ih->saddr.byte4,
    sport,
    ih->daddr.byte1,
    ih->daddr.byte2,
    ih->daddr.byte3,
    ih->daddr.byte4,
    dport);
}
]]></programlisting>

    <para>First of all, we set the filter to "ip and udp". In this way we are
      sure that packet_handler() will receive only UDP packets over IPv4: this
      simplifies the parsing and increases the efficiency of the
      program.</para>

    <para>We have also created a couple of structs that describe the IP and UDP
      headers. These structs are used by packet_handler() to properly locate
      the various header fields.</para>

    <para>packet_handler(), although limited to a single protocol dissector
      (UDP over IPv4), shows how complex "sniffers" like tcpdump/WinDump decode
      the network traffic. Since we aren't interested in the MAC header, we
      skip it. For simplicity and before starting the capture, we check the MAC
      layer with <ulink url="wpcap/pcap_datalink.html">pcap_datalink()</ulink>
      to make sure that we are dealing with an Ethernet network. This way we
      can be sure that the MAC header is exactly 14 bytes.</para>

    <para>The IP header is located just after the MAC header. We will extract
      the IP source and destination addresses from the IP header.</para>

    <para>Reaching the UDP header is a bit more complicated, because the IP
      header doesn't have a fixed length. Therefore, we use the IP header's
      length field to know its size. Once we know the location of the UDP
      header, we extract the source and destination ports.</para>

    <para>The extracted values are printed on the screen, and the result is
      something like:</para>
    <screen>
\Device\Packet_{A7FD048A-5D4B-478E-B3C1-34401AC3B72F} (Xircom t 10/100 Adapter)
Enter the interface number (1-2):1
 listening on Xircom CardBus Ethernet 10/100 Adapter...
16:13:15.312784 len:87 130.192.31.67.2682 -&gt; 130.192.3.21.53
16:13:15.314796 len:137 130.192.3.21.53 -&gt; 130.192.31.67.2682
16:13:15.322101 len:78 130.192.31.67.2683 -&gt; 130.192.3.21.53</screen>
    <para>Each of the final 3 lines represents a different packet.</para>
  </sect2>

  <sect2 id="npcap-tutorial-offline">
    <title>Handling offline dump files</title>

    <para>In this lession we are going to learn how to handle packet capture to
      a file (dump to file). Npcap offers a wide range of functions to save
      the network traffic to a file and to read the content of
      dumps&#x2014;this lesson will teach how to use all of these
      functions.</para>

    <para>The format for dump files is the libpcap one. This format contains
      the data of the captured packets in binary form and is a standard used by
      many network tools including WinDump, Wireshark and Snort.</para>

    <sect3 id="npcap-tutorial-offline-saving">
      <title>Saving packets to a dump file</title>

      <para>First of all, let's see how to write packets in libpcap
        format.</para>

      <para>The following example captures the packets from the selected
        interface and saves them on a file whose name is provided by the
        user.</para>
      <programlisting language="C"><!-- Examples/misc/savedump.c --><![CDATA[
#include <pcap.h>
#include "misc.h" /* LoadNpcapDlls */

/* prototype of the packet handler */
void packet_handler(u_char *param,
  const struct pcap_pkthdr *header,
  const u_char *pkt_data);

int main(int argc, char **argv)
{
  pcap_if_t *alldevs;
  pcap_if_t *d;
  int inum;
  int i=0;
  pcap_t *adhandle;
  char errbuf[PCAP_ERRBUF_SIZE];
  pcap_dumper_t *dumpfile;

  /* Load Npcap and its functions. */
  if (!LoadNpcapDlls())
  {
    fprintf(stderr, "Couldn't load Npcap\n");
    exit(1);
  }

  /* Check command line */
  if(argc != 2)
  {
    printf("usage: %s filename", argv[0]);
    return -1;
  }
    
  /* Retrieve the device list on the local machine */
  if (pcap_findalldevs_ex(PCAP_SRC_IF_STRING,
    NULL, &alldevs, errbuf) == -1)
  {
    fprintf(stderr,"Error in pcap_findalldevs: %s\n", errbuf);
    exit(1);
  }
    
  /* Print the list */
  for(d=alldevs; d; d=d->next)
  {
    printf("%d. %s", ++i, d->name);
    if (d->description)
      printf(" (%s)\n", d->description);
    else
      printf(" (No description available)\n");
  }

  if(i==0)
  {
    printf("\nNo interfaces found! Make sure Npcap is installed.\n");
    return -1;
  }
  
  printf("Enter the interface number (1-%d):",i);
  scanf_s("%d", &inum);
  
  if(inum < 1 || inum > i)
  {
    printf("\nInterface number out of range.\n");
    /* Free the device list */
    pcap_freealldevs(alldevs);
    return -1;
  }
  
  /* Jump to the selected adapter */
  for(d=alldevs, i=0; i< inum-1 ;d=d->next, i++);
    
    
  /* Open the device */
  if ( (adhandle= pcap_open(d->name, // name of the device
                65536, // portion of the packet to capture
                       // 65536 guarantees that the whole packet
                       // will be captured on all the link layers
                PCAP_OPENFLAG_PROMISCUOUS, // promiscuous mode
                1000, // read timeout
                NULL, // authentication on the remote machine
                errbuf // error buffer
                ) ) == NULL)
  {
    fprintf(stderr,
      "\nUnable to open the adapter. %s is not supported by Npcap\n",
      d->name);
    /* Free the device list */
    pcap_freealldevs(alldevs);
    return -1;
  }

  /* Open the dump file */
  dumpfile = pcap_dump_open(adhandle, argv[1]);

  if(dumpfile==NULL)
  {
    fprintf(stderr,"\nError opening output file\n");
    return -1;
  }

  printf("\nlistening on %s... Press Ctrl+C to stop...\n", d->description);

  /* At this point, we no longer need the device list. Free it */
  pcap_freealldevs(alldevs);
  
  /* start the capture */
  pcap_loop(adhandle, 0, packet_handler, (unsigned char *)dumpfile);

  return 0;
}

/* Callback function invoked by libpcap for every incoming packet */
void packet_handler(u_char *dumpfile,
  const struct pcap_pkthdr *header,
  const u_char *pkt_data)
{
  /* save the packet on the dump file */
  pcap_dump(dumpfile, header, pkt_data);
}
]]></programlisting>

      <para>As you can see, the structure of the program is very similar to the
        ones we have seen in the previous lessons. The differences
        are:</para>

      <itemizedlist>
        <listitem>a call to <ulink
            url="wpcap/pcap_dump_open.html">pcap_dump_open()</ulink> is issued
          once the interface is opened. This call opens a dump file and
          associates it with the interface.</listitem>

        <listitem>the packets are written to this file with a <ulink
            url="wpcap/pcap_dump.html">pcap_dump()</ulink> from the
          packet_handler() callback. The parameters of
          <literal>pcap_dump()</literal> are in 1-1 correspondence with the
          parameters of <ulink
            url="wpcap/pcap_loop.html">pcap_handler()</ulink>.</listitem>
      </itemizedlist>
    </sect3>

    <sect3 id="npcap-tutorial-offline-reading">
      <title>Reading packets from a dump file</title>

      <para>Now that we have a dump file available, we can try to read its
        content. The following code opens a Npcap/libpcap dump file and
        displays every packet contained in the file. The file is opened with
        <ulink url="wpcap/pcap_open_offline.html">pcap_open_offline()</ulink>,
        then the usual <ulink url="wpcap/pcap_loop.html">pcap_loop()</ulink> is
        used to sequence through the packets. As you can see, reading packets
        from an offline capture is nearly identical to receiving them from a
        physical interface.</para>

      <para>This example introduces another function:
        <literal>pcap_createsrcstr()</literal>. This function is required to
        create a source string that begins with a marker used to tell Npcap the
        type of the source, e.g. "rpcap://" if we are going to open an adapter,
        or "file://" if we are going to open a file. This step is not required
        when <literal>pcap_findalldevs_ex()</literal> is used (the returned
        values already contain these strings). However, it is required in this
        example because the name of the file is read from the user
        input.</para>

      <programlisting language="C"><!-- Examples/misc/readfile.c --><![CDATA[
#include <stdio.h>
#include <pcap.h>
#include "misc.h" /* LoadNpcapDlls */

#define LINE_LEN 16

void dispatcher_handler(u_char *,
  const struct pcap_pkthdr *,
  const u_char *);

int main(int argc, char **argv)
{
  pcap_t *fp;
  char errbuf[PCAP_ERRBUF_SIZE];
  char source[PCAP_BUF_SIZE];

  /* Load Npcap and its functions. */
  if (!LoadNpcapDlls())
  {
    fprintf(stderr, "Couldn't load Npcap\n");
    exit(1);
  }

  if(argc != 2){

    printf("usage: %s filename", argv[0]);
    return -1;

  }

  /* Create the source string according to the new Npcap syntax */
  if ( pcap_createsrcstr(  source, // variable that will keep the source string
              PCAP_SRC_FILE,  // we want to open a file
              NULL,      // remote host
              NULL,      // port on the remote host
              argv[1],    // name of the file we want to open
              errbuf      // error buffer
              ) != 0)
  {
    fprintf(stderr,"\nError creating a source string\n");
    return -1;
  }
  
  /* Open the capture file */
  if ( (fp= pcap_open(source, // name of the device
            65536, // portion of the packet to capture
                   // 65536 guarantees that the whole packet
                   // will be captured on all the link layers
             PCAP_OPENFLAG_PROMISCUOUS, // promiscuous mode
             1000, // read timeout
             NULL, // authentication on the remote machine
             errbuf // error buffer
             ) ) == NULL)
  {
    fprintf(stderr,"\nUnable to open the file %s.\n", source);
    return -1;
  }

  // read and dispatch packets until EOF is reached
  pcap_loop(fp, 0, dispatcher_handler, NULL);

  return 0;
}


void dispatcher_handler(u_char *temp1, 
  const struct pcap_pkthdr *header,
  const u_char *pkt_data)
{
  u_int i=0;

  /*
   * Unused variable
   */
  (VOID)temp1;

  /* print pkt timestamp and pkt len */
  printf("%ld:%ld (%ld)\n", header->ts.tv_sec, header->ts.tv_usec, header->len);      
  
  /* Print the packet */
  for (i=1; (i < header->caplen + 1 ) ; i++)
  {
    printf("%.2x ", pkt_data[i-1]);
    if ( (i % LINE_LEN) == 0) printf("\n");
  }
  
  printf("\n\n");    
  
}
]]></programlisting>

      <para>The following example has the same purpose of the last one, but
        <ulink url="wpcap/pcap_next_ex.html">pcap_next_ex()</ulink> is used
        instead of the <ulink url="wpcap/pcap_loop.html">pcap_loop()</ulink>
        callback method.</para>

      <programlisting language="C"><!-- Examples/misc/readfile_ex.c --><![CDATA[
#include <stdio.h>
#include <pcap.h>
#include "misc.h" /* LoadNpcapDlls */

#define LINE_LEN 16

int main(int argc, char **argv)
{
  pcap_t *fp;
  char errbuf[PCAP_ERRBUF_SIZE];
  char source[PCAP_BUF_SIZE];
  struct pcap_pkthdr *header;
  const u_char *pkt_data;
  u_int i=0;
  int res;

  /* Load Npcap and its functions. */
  if (!LoadNpcapDlls())
  {
    fprintf(stderr, "Couldn't load Npcap\n");
    exit(1);
  }

  if(argc != 2)
  {
    printf("usage: %s filename", argv[0]);
    return -1;
  }
  
  /* Create the source string according to the new Npcap syntax */
  if ( pcap_createsrcstr(  source, // variable that will keep the source string
              PCAP_SRC_FILE,  // we want to open a file
              NULL,      // remote host
              NULL,      // port on the remote host
              argv[1],    // name of the file we want to open
              errbuf      // error buffer
              ) != 0)
  {
    fprintf(stderr,"\nError creating a source string\n");
    return -1;
  }
  
  /* Open the capture file */
  if ( (fp= pcap_open(source, // name of the device
            65536, // portion of the packet to capture
                   // 65536 guarantees that the whole packet
                   // will be captured on all the link layers
             PCAP_OPENFLAG_PROMISCUOUS, // promiscuous mode
             1000, // read timeout
             NULL, // authentication on the remote machine
             errbuf // error buffer
             ) ) == NULL)
  {
    fprintf(stderr,"\nUnable to open the file %s.\n", source);
    return -1;
  }
  
  /* Retrieve the packets from the file */
  while((res = pcap_next_ex( fp, &header, &pkt_data)) >= 0)
  {
    /* print pkt timestamp and pkt len */
    printf("%ld:%ld (%ld)\n", header->ts.tv_sec, header->ts.tv_usec, header->len);      
    
    /* Print the packet */
    for (i=1; (i < header->caplen + 1 ) ; i++)
    {
      printf("%.2x ", pkt_data[i-1]);
      if ( (i % LINE_LEN) == 0) printf("\n");
    }
    
    printf("\n\n");    
  }
  
  
  if (res == -1)
  {
    printf("Error reading the packets: %s\n", pcap_geterr(fp));
  }
  
  return 0;
}
]]></programlisting>

    </sect3>

  </sect2>

  <sect2 id="npcap-tutorial-sending">
    <title>Sending Packets</title>
    <para>Although the name <emphasis>Npcap</emphasis> indicates clearly that the purpose
      of the library is packet capture, other useful features for raw
      networking are provided. Among them, the user can find a complete set of
      functions to send packets.</para>

    <sect3>
      <title>Sending a single packet with <literal>pcap_sendpacket()</literal></title>

      <para>The simplest way to send a packet is shown in the following code
        snippet. After opening an adapter, <ulink
          url="wpcap/pcap_inject.html">pcap_sendpacket()</ulink> is called to
        send a hand-crafted packet. <literal>pcap_sendpacket()</literal> takes
        as arguments a buffer containing the data to send, the length of the
        buffer and the adapter that will send it. Notice that the buffer is
        sent to the net as is, without any manipulation. This means that the
        application has to create the correct protocol headers in order to send
        something meaningful.</para>

      <programlisting language="C"><!-- Examples/misc/sendpack.c --><![CDATA[
#include <stdlib.h>
#include <stdio.h>

#include <pcap.h>
#include "misc.h" /* LoadNpcapDlls */

void main(int argc, char **argv)
{
  pcap_t *fp;
  char errbuf[PCAP_ERRBUF_SIZE];
  u_char packet[100];
  int i;

  /* Load Npcap and its functions. */
  if (!LoadNpcapDlls())
  {
    fprintf(stderr, "Couldn't load Npcap\n");
    exit(1);
  }

  /* Check the validity of the command line */
  if (argc != 2)
  {
    printf("usage: %s interface (e.g. 'rpcap://eth0')", argv[0]);
    return;
  }
    
  /* Open the output device */
  if ( (fp= pcap_open(argv[1], // name of the device
            100, // portion of the packet to capture
            PCAP_OPENFLAG_PROMISCUOUS, // promiscuous mode
            1000, // read timeout
            NULL, // authentication on the remote machine
            errbuf // error buffer
            ) ) == NULL)
  {
    fprintf(stderr,
      "\nUnable to open the adapter. %s is not supported by Npcap\n",
      argv[1]);
    return;
  }

  /* Supposing to be on ethernet, set mac destination to 1:1:1:1:1:1 */
  packet[0]=1;
  packet[1]=1;
  packet[2]=1;
  packet[3]=1;
  packet[4]=1;
  packet[5]=1;
  
  /* set mac source to 2:2:2:2:2:2 */
  packet[6]=2;
  packet[7]=2;
  packet[8]=2;
  packet[9]=2;
  packet[10]=2;
  packet[11]=2;
  
  /* Fill the rest of the packet */
  for(i=12;i<100;i++)
  {
    packet[i]=(u_char)i;
  }

  /* Send down the packet */
  if (pcap_sendpacket(fp, packet, 100 /* size */) != 0)
  {
    fprintf(stderr,"\nError sending the packet: %s\n", pcap_geterr(fp));
    return;
  }

  return;
}
]]></programlisting>

    </sect3>

    <sect3>
      <title>Send queues</title>

      <para>While <ulink url="wpcap/pcap_inject.html">pcap_sendpacket()</ulink>
        offers a simple and immediate way to send a single packet,
        <emphasis>send queues</emphasis> provide an advanced, powerful and
        optimized mechanism to send a collection of packets. A send queue is a
        container for a variable number of packets that will be sent to the
        network. It has a size, that represents the maximum amount of bytes it
        can store.</para>

      <para>A send queue is created calling the
        <literal>pcap_sendqueue_alloc()</literal> function, specifying the size
        of the new send queue.</para>

      <para>Once the send queue is created,
        <literal>pcap_sendqueue_queue()</literal> can be used to add a packet
        to the send queue. This function takes a <literal>pcap_pkthdr</literal>
        with the timestamp and the length and a buffer with the data of the
        packet. These parameters are the same as those received by <ulink
          url="wpcap/pcap_next_ex.html">pcap_next_ex()</ulink> and
        <literal>pcap_handler()</literal>, therefore queuing a packet that was
        just captured or read from a file is a matter of passing these
        parameters to <literal>pcap_sendqueue_queue()</literal>.</para>

      <para>To transmit a send queue, Npcap provides the
        <literal>pcap_sendqueue_transmit()</literal> function. Note the third
        parameter: if nonzero, the send will be
        <emphasis>synchronized</emphasis>, i.e. the relative timestamps of the
        packets will be respected. This operation requires a remarkable amount
        of CPU, because the synchronization takes place in the kernel driver
        using "busy wait" loops. Although this operation is quite CPU
        intensive, it often results in very high precision packet transmissions
        (often around few microseconds or less).</para>

      <para>Note that transmitting a send queue with
        <literal>pcap_sendqueue_transmit()</literal> is much more efficient
        than performing a series of <ulink
          url="wpcap/pcap_inject.html">pcap_sendpacket()</ulink>, because the
        send queue is buffered at kernel level drastically decreasing the
        number of context switches.</para>

      <para>When a queue is no longer needed, it can be deleted with
        <literal>pcap_sendqueue_destroy()</literal> that frees all the buffers
        associated with the send queue.</para>

      <para>The next program shows how to use send queues. It opens a capture
        file with <ulink
          url="wpcap/pcap_open_offline.html">pcap_open_offline()</ulink>, then
        it moves the packets from the file to a properly allocated send queue.
        At his point it transmits the queue, synchronizing it if requested by
        the user.</para>

      <para>Note that the link-layer of the dumpfile is compared with the one
        of the interface that will send the packets using <ulink
          url="wpcap/pcap_datalink.html">pcap_datalink()</ulink>, and a warning
        is printed if they are different&#x2014;it is important that the
        capture-file link-layer be the same as the adapter's link layer for
        otherwise the transmission is pointless.</para>

      <programlisting language="C"><!-- Examples/sendcap/sendcap.c --><![CDATA[
#include <stdlib.h>
#include <stdio.h>

#include <pcap.h>

#ifdef _WIN32
#include <tchar.h>
BOOL LoadNpcapDlls()
{
  TCHAR npcap_dir[512];
  UINT len;
  len = GetSystemDirectory(npcap_dir, 480);
  if (!len) {
    fprintf(stderr, "Error in GetSystemDirectory: %x", GetLastError());
    return FALSE;
  }
  _tcscat_s(npcap_dir, 512, TEXT("\\Npcap"));
  if (SetDllDirectory(npcap_dir) == 0) {
    fprintf(stderr, "Error in SetDllDirectory: %x", GetLastError());
    return FALSE;
  }
  return TRUE;
}
#endif

void usage();

void main(int argc, char **argv)
{
  pcap_t *indesc,*outdesc;
  char errbuf[PCAP_ERRBUF_SIZE];
  char source[PCAP_BUF_SIZE];
  FILE *capfile;
  int caplen, sync;
  u_int res;
  pcap_send_queue *squeue;
  struct pcap_pkthdr *pktheader;
  u_char *pktdata;
  float cpu_time;
  u_int npacks = 0;
  errno_t fopen_error;

#ifdef _WIN32
  /* Load Npcap and its functions. */
  if (!LoadNpcapDlls())
  {
    fprintf(stderr, "Couldn't load Npcap\n");
    exit(1);
  }
#endif

  /* Check the validity of the command line */
  if (argc <= 2 || argc >= 5)
  {
    usage();
    return;
  }
    
  /* Retrieve the length of the capture file */
  fopen_error = fopen_s(&capfile, argv[1],"rb");
  if(fopen_error != 0){
    printf("Error opening the file, errno %d.\n", fopen_error);
    return;
  }
  
  fseek(capfile , 0, SEEK_END);
  caplen= ftell(capfile)- sizeof(struct pcap_file_header);
  fclose(capfile);
      
  /* Chek if the timestamps must be respected */
  if(argc == 4 && argv[3][0] == 's')
    sync = TRUE;
  else
    sync = FALSE;

  /* Open the capture */
  /* Create the source string according to the new WinPcap syntax */
  if ( pcap_createsrcstr(
              source, // variable that will keep the source string
              PCAP_SRC_FILE,  // we want to open a file
              NULL,      // remote host
              NULL,      // port on the remote host
              argv[1],    // name of the file we want to open
              errbuf      // error buffer
              ) != 0)
  {
    fprintf(stderr,"\nError creating a source string\n");
    return;
  }
  
  /* Open the capture file */
  if ( (indesc= pcap_open(source, 65536, PCAP_OPENFLAG_PROMISCUOUS,
                          1000, NULL, errbuf) ) == NULL)
  {
    fprintf(stderr,"\nUnable to open the file %s.\n", source);
    return;
  }

  /* Open the output adapter */
  if ( (outdesc= pcap_open(argv[2], 100, PCAP_OPENFLAG_PROMISCUOUS,
                           1000, NULL, errbuf) ) == NULL)
  {
    fprintf(stderr,"\nUnable to open adapter %s.\n", source);
    return;
  }

  /* Check the MAC type */
  if (pcap_datalink(indesc) != pcap_datalink(outdesc))
  {
    printf("Warning: the datalink of the capture differs"
           " from the one of the selected interface.\n");
    printf("Press a key to continue, or CTRL+C to stop.\n");
    getchar();
  }

  /* Allocate a send queue */
  squeue = pcap_sendqueue_alloc(caplen);

  /* Fill the queue with the packets from the file */
  while ((res = pcap_next_ex( indesc, &pktheader, &pktdata)) == 1)
  {
    if (pcap_sendqueue_queue(squeue, pktheader, pktdata) == -1)
    {
      printf("Warning: packet buffer too small, not all the packets will be sent.\n");
      break;
    }

    npacks++;
  }

  if (res == -1)
  {
    printf("Corrupted input file.\n");
    pcap_sendqueue_destroy(squeue);
    return;
  }

  /* Transmit the queue */
  
  cpu_time = (float)clock ();

  if ((res = pcap_sendqueue_transmit(outdesc, squeue, sync)) < squeue->len)
  {
    printf("An error occurred sending the packets: %s."
           " Only %d bytes were sent\n", pcap_geterr(outdesc), res);
  }
  
  cpu_time = (clock() - cpu_time)/CLK_TCK;
  
  printf ("\n\nElapsed time: %5.3f\n", cpu_time);
  printf ("\nTotal packets generated = %d", npacks);
  printf ("\nAverage packets per second = %d", (int)((double)npacks/cpu_time));
  printf ("\n");

  /* free the send queue */
  pcap_sendqueue_destroy(squeue);

  /* Close the input file */
  pcap_close(indesc);

  /* 
   * close the output adapter 
   * IMPORTANT: remember to close the adapter, otherwise there will be no
   * guarantee that all the packets will be sent!
   */
  pcap_close(outdesc);

  return;
}


void usage()
{
  
  printf("\nSendcap, sends a libpcap/tcpdump capture file to the net."
         " Copyright (C) 2002 Loris Degioanni.\n");
  printf("\nUsage:\n");
  printf("\t sendcap file_name adapter [s]\n");
  printf("\nParameters:\n");
  printf("\nfile_name: the name of the dump file that will be sent to the network\n");
  printf("\nadapter: the device to use. Use \"WinDump -D\" for a list of valid devices\n");
  printf("\ns: if present, forces the packets to be sent synchronously,"
         " i.e. respecting the timestamps in the dump file.\n\n");

  exit(0);
}
]]></programlisting>
    </sect3>
  </sect2>

  <sect2 id="npcap-tutorial-statistics">
    <title>Gathering Statistics on the network traffic</title>

    <para>This lesson shows another advanced feature of Npcap: the ability to
      collect statistics about network traffic. The statistical engine makes
      use of the kernel-level packet filter to efficiently classify the
      incoming packet.</para>

    <para>In order to use this feature, the programmer must open an adapter and
      put it in <emphasis>statistical mode</emphasis>. This can be done with
      <literal>pcap_setmode()</literal>. In particular,
      <literal>MODE_STAT</literal> must be used as the <literal>mode</literal>
      argument of this function.</para>

    <para>With statistical mode, making an application that monitors the TCP
      traffic load is a matter of few lines of code. The following sample shows
      how to do it.</para>

    <programlisting language="C"><!-- Examples/tcptop/tcptop.c --><![CDATA[
#include <stdlib.h>
#include <stdio.h>

#include <pcap.h>

#include <tchar.h>
BOOL LoadNpcapDlls()
{
  _TCHAR npcap_dir[512];
  UINT len;
  len = GetSystemDirectory(npcap_dir, 480);
  if (!len) {
    fprintf(stderr, "Error in GetSystemDirectory: %x", GetLastError());
    return FALSE;
  }
  _tcscat_s(npcap_dir, 512, _T("\\Npcap"));
  if (SetDllDirectory(npcap_dir) == 0) {
    fprintf(stderr, "Error in SetDllDirectory: %x", GetLastError());
    return FALSE;
  }
  return TRUE;
}

void usage();

void dispatcher_handler(u_char *, const struct pcap_pkthdr *, const u_char *);


void main(int argc, char **argv)
{
  pcap_t *fp;
  char errbuf[PCAP_ERRBUF_SIZE];
  struct timeval st_ts;
  u_int netmask;
  struct bpf_program fcode;
  
  /* Load Npcap and its functions. */
  if (!LoadNpcapDlls())
  {
    fprintf(stderr, "Couldn't load Npcap\n");
    exit(1);
  }

  /* Check the validity of the command line */
  if (argc != 2)
  {
    usage();
    return;
  }
    
  /* Open the output adapter */
  if ( (fp= pcap_open(argv[1], 100, PCAP_OPENFLAG_PROMISCUOUS,
                      1000, NULL, errbuf) ) == NULL)
  {
    fprintf(stderr,"\nUnable to open adapter %s.\n", errbuf);
    return;
  }

  /* Don't care about netmask, it won't be used for this filter */
  netmask=0xffffff; 

  //compile the filter
  if (pcap_compile(fp, &fcode, "tcp", 1, netmask) <0 )
  {
    fprintf(stderr,"\nUnable to compile the packet filter. Check the syntax.\n");
    /* Free the device list */
    return;
  }
    
  //set the filter
  if (pcap_setfilter(fp, &fcode)<0)
  {
    fprintf(stderr,"\nError setting the filter.\n");
    pcap_close(fp);
    /* Free the device list */
    return;
  }

  /* Put the interface in statstics mode */
  if (pcap_setmode(fp, MODE_STAT)<0)
  {
    fprintf(stderr,"\nError setting the mode.\n");
    pcap_close(fp);
    /* Free the device list */
    return;
  }


  printf("TCP traffic summary:\n");

  /* Start the main loop */
  pcap_loop(fp, 0, dispatcher_handler, (PUCHAR)&st_ts);

  pcap_close(fp);
  return;
}

void dispatcher_handler(u_char *state,
  const struct pcap_pkthdr *header,
  const u_char *pkt_data)
{
  struct timeval *old_ts = (struct timeval *)state;
  u_int delay;
  LARGE_INTEGER Bps,Pps;
  struct tm ltime;
  char timestr[16];
  time_t local_tv_sec;

  /* Calculate the delay in microseconds from the last sample. This value
   * is obtained from the timestamp that the associated with the sample. */
  delay = (header->ts.tv_sec - old_ts->tv_sec) * 1000000
    - old_ts->tv_usec + header->ts.tv_usec;
  /* Get the number of Bits per second */
  Bps.QuadPart=(((*(LONGLONG*)(pkt_data + 8)) * 8 * 1000000) / (delay));
  /*                                            ^      ^
                                                  |      |
                                                  |      | 
                                                  |      |
                         converts bytes in bits --       |
                                                         |
                    delay is expressed in microseconds --
  */

  /* Get the number of Packets per second */
  Pps.QuadPart=(((*(LONGLONG*)(pkt_data)) * 1000000) / (delay));

  /* Convert the timestamp to readable format */
  local_tv_sec = header->ts.tv_sec;
  localtime_s(&ltime, &local_tv_sec);
  strftime( timestr, sizeof timestr, "%H:%M:%S", &ltime);

  /* Print timestamp*/
  printf("%s ", timestr);

  /* Print the samples */
  printf("BPS=%I64u ", Bps.QuadPart);
  printf("PPS=%I64u\n", Pps.QuadPart);

  //store current timestamp
  old_ts->tv_sec=header->ts.tv_sec;
  old_ts->tv_usec=header->ts.tv_usec;
}


void usage()
{
  printf("\nShows the TCP traffic load, in bits per second and packets per second."
         "\nCopyright (C) 2002 Loris Degioanni.\n");
  printf("\nUsage:\n");
  printf("\t tcptop adapter\n");
  printf("\t You can use \"WinDump -D\" if you don't know the name of your adapters.\n");

  exit(0);
}
]]></programlisting>

    <para>Before enabling statistical mode, the user has the option to set a
      filter that defines the subset of network traffic that will be monitored.
      See the <ulink url="wpcap/pcap-filter.html">Filtering expression
        syntax</ulink> documentation for details. If no filter has been set,
      all of the traffic will be monitored.</para>

    <para>Once
      <itemizedlist>
        <listitem>the filter is set</listitem>
        <listitem><literal>pcap_setmode()</literal> is called</listitem>
        <listitem>callback invocation is enabled with <ulink
            url="wpcap/pcap_loop.html">pcap_loop()</ulink></listitem>
      </itemizedlist>
      the interface descriptor starts to work in statistical mode. Notice the
      fourth parameter (<literal>to_ms</literal>) of <ulink
        url="wpcap/pcap_open.html">pcap_open()</ulink>: it defines the interval
      among the statistical samples. The callback function receives the samples
      calculated by the driver every <literal>to_ms</literal> milliseconds.
      These samples are encapsulated in the second and third parameters of the
      callback function.
      <!-- <img src="stats_wpcap.gif" alt="stats_wpcap.gif"/> -->
      Two 64-bit counters are provided: the number of packets and the amount of
      bytes received during the last interval.</para>

    <para>In the example, the adapter is opened with a timeout of 1000 ms. This
      means that dispatcher_handler() is called once per second. At this point
      a filter that keeps only tcp packets is compiled and set. Then
      <literal>pcap_setmode()</literal> and <literal>pcap_loop()</literal> are
      called. Note that a struct timeval pointer is passed to
      <literal>pcap_loop()</literal> as the <literal>user</literal> parameter.
      This structure will be used to store a timestamp in order to calculate
      the interval between two samples.  dispatcher_handler()uses this interval
      to obtain the bits per second and the packets per second and then prints
      these values on the screen.</para>

    <para>Note finally that this example is by far more efficient than a
      program that captures the packets in the traditional way and calculates
      statistics at user-level. Statistical mode requires the minumum amount of
      data copies and context switches and therefore the CPU is optimized.
      Moreover, a very small amount of memory is required.</para>
  </sect2>
</sect1>


```

`installer/Build.bat`:

```bat
SET NPCAPDIR=".."
SET MODE="Release"
rem SET MODE="Debug"
SET VSVER=17

::::::::::
for /f "usebackq delims=#" %%a in (`"%ProgramFiles(x86)%\Microsoft Visual Studio\Installer\vswhere" -version %VSVER% -property installationPath`) do call "%%a\VC\Auxiliary\Build\vcvarsall.bat" x86 & goto :break1
:break1
if %ERRORLEVEL% NEQ 0 goto :badenv

msbuild "%NPCAPDIR%\packetWin7\vs14\npcap.sln" /m /t:Build /p:Configuration="%MODE%" /p:Platform="x86"
msbuild "%NPCAPDIR%\packetWin7\vs14\npcap.sln" /m /t:Build /p:Configuration="%MODE% Win10 driver" /p:Platform="x86"
msbuild "%NPCAPDIR%\wpcap\build-win32\wpcap.vcxproj" /m /t:Build /p:Configuration="%MODE%" /p:Platform="Win32"

for /f "usebackq delims=#" %%a in (`"%ProgramFiles(x86)%\Microsoft Visual Studio\Installer\vswhere" -version %VSVER% -property installationPath`) do call "%%a\VC\Auxiliary\Build\vcvarsall.bat" x64 & goto :break2
:break2
if %ERRORLEVEL% NEQ 0 goto :badenv

msbuild "%NPCAPDIR%\packetWin7\vs14\npcap.sln" /m /t:Build /p:Configuration="%MODE%" /p:Platform="x64"
msbuild "%NPCAPDIR%\packetWin7\vs14\npcap.sln" /m /t:Build /p:Configuration="%MODE% Win10 driver" /p:Platform="x64"
msbuild "%NPCAPDIR%\wpcap\build-x64\wpcap.vcxproj" /m /t:Build /p:Configuration="%MODE%" /p:Platform="x64"

for /f "usebackq delims=#" %%a in (`"%ProgramFiles(x86)%\Microsoft Visual Studio\Installer\vswhere" -version %VSVER% -property installationPath`) do call "%%a\VC\Auxiliary\Build\vcvarsall.bat" amd64_arm64 & goto :break3
:break3
if %ERRORLEVEL% NEQ 0 goto :badenv

msbuild "%NPCAPDIR%\packetWin7\vs14\npcap.sln" /m /t:Build /p:Configuration="%MODE%" /p:Platform="ARM64"
msbuild "%NPCAPDIR%\packetWin7\vs14\npcap.sln" /m /t:Build /p:Configuration="%MODE% Win10 driver" /p:Platform="ARM64"
msbuild "%NPCAPDIR%\wpcap\build-ARM64\wpcap.vcxproj" /m /t:Build /p:Configuration="%MODE%" /p:Platform="ARM64"

exit /b

:bad_env
echo Failed to set environment
exit /b 1

```

`installer/CheckManifest.ps1`:

```ps1
param(
    [string]$ManifestPath = ".\manifest.txt",
    [string]$InstallRoot  = "C:\Program Files\Npcap",
    [switch]$Uninstall
)

$Is64OS  = [Environment]::Is64BitOperatingSystem
$Is64PS  = [Environment]::Is64BitProcess

$IsARM64 = $false
if ($Is64OS) {
	$IsARM64 = (Get-CimInstance Win32_OperatingSystem -Property OSArchitecture).OSArchitecture.StartsWith("ARM")
}

$BadCondition = "Missing items"
if ($Uninstall) {
	$BadCondition = "Remaining items"
}

$System32 = "${env:SystemRoot}\System32"
$System64 = $null
if ($Is64OS) {
	if ($Is64PS) {
		$System64 = "${env:SystemRoot}\SysWoW64"
	}
	else {
		$System64 = "${env:SystemRoot}\Sysnative"
	}
}

# Read manifest
$manifest = Get-Content $ManifestPath |
    ForEach-Object {
	    $_ = $_.Trim()
	    if ($IsARM64 -and $_.EndsWith(".dll")) {
		    $_.Replace(".dll", "_arm64.dll")
		    $_.Replace(".dll", "_x64.dll")
	    }
	    $_
	    } |
    Where-Object { $_ -and -not $_.StartsWith("#") }

$requiredPaths = foreach ($line in $manifest) {
    # Split at first backslash: token + remainder
    if ($line -notmatch '^(?<root>[^\\]+)\\(?<rest>.+)$') {
        throw "Invalid manifest line: $line"
    }

    $rootToken = $Matches.root
    $relative  = $Matches.rest

    if ($rootToken -eq "INSTDIR") {
        Join-Path $InstallRoot $relative
    }
    elseif ($rootToken -eq "SYSDIR") {
        Join-Path $System32 $relative
	if (-not $relative.EndsWith(".sys")) {
		Join-Path $System32 "Npcap\$relative"
	}
	if ($Is64OS) {
		Join-Path $System64 $relative
		if (-not $relative.EndsWith(".sys")) {
			Join-Path $System64 "Npcap\$relative"
		}
	}
    }
    else {
        throw "Unknown root token '$rootToken' in manifest line: $line"
    }
}

$results = @()

foreach ($path in $requiredPaths) {
    $exists = Test-Path $path

    $results += [pscustomobject]@{
        Path      = $path
        Exists    = $exists
    }
}
Write-Information -InformationAction Continue ($results | Format-Table | Out-String)

# Report missing
$missing = $results | Where-Object { $_.Exists -eq $Uninstall }

Write-Host "=== Manifest Verification Report ==="
Write-Host ""

if ($missing) {
    Write-Host "${BadCondition}:"
    $missing | Format-Table -AutoSize
    throw "Manifest validation failed: ${BadCondition}"
} else {
    Write-Host "Passed: No ${BadCondition}."
}

# Optional: Check for unexpected files in install root
$expectedSet = $results | Where-Object { $_.Exists } | ForEach-Object { $_.Path.ToLowerInvariant() }
$actual = foreach ($path in ($InstallRoot, "$System32\Npcap")) {
	if (Test-Path $path) {
		Get-ChildItem -Recurse $path | Select-Object -ExpandProperty FullName
	}
}
$actualSet = $actual | ForEach-Object { $_.ToLowerInvariant() }

$unexpected = $actualSet | Where-Object { -not $_.EndsWith(".log") -and $expectedSet -notcontains $_ }

if ($unexpected) {
    Write-Host ""
    Write-Host "Unexpected items present:"
    $unexpected | Format-Table -AutoSize
    throw "Manifest validation failed: unexpected items"
} else {
    Write-Host "No unexpected items are present."
}

```

`installer/CheckStatus.bat`:

```bat
@echo off

rem Make sure we can find where Npcap is installed
set KEY_NAME=HKLM\Software\WOW6432Node\Npcap
for /F "usebackq tokens=1,2*" %%A IN (`reg query "%KEY_NAME%" /ve 2^>nul ^| find "REG_SZ"`) do (
	set NPCAP_DIR=%%C
)
if defined NPCAP_DIR (goto DO_CHECK)
set KEY_NAME=HKLM\Software\Npcap
for /F "usebackq tokens=1,2*" %%A IN (`reg query "%KEY_NAME%" /ve 2^>nul ^| find "REG_SZ"`) do (
	set NPCAP_DIR=%%C
)
if defined NPCAP_DIR (goto DO_CHECK) else (goto ABORT)

:DO_CHECK

rem If start type is not SYSTEM_START, we need to fix that.
for /F "usebackq tokens=1,4" %%A in (`sc.exe qc npcap`) do (
	if %%A == START_TYPE (
	    if NOT %%B == SYSTEM_START (
		goto FIXINSTALL
	    )
	)
)

goto ABORT

:FIXINSTALL
"%NPCAP_DIR%\FixInstall.bat"
exit /b %ERRORLEVEL%

:ABORT
exit /b 0

```

`installer/DiagReport.bat`:

```bat
@echo off

whoami /Groups | find "S-1-16-12288" >NUL
if ERRORLEVEL 1 (
  rem This tools must run with administrator permissions
  rem It will popup the UAC dialog, please click [Yes] to continue.
  echo Set UAC = CreateObject^("Shell.Application"^) > "%temp%\getadmin.vbs"
  echo UAC.ShellExecute "%~s0", "%*", "", "runas", 1 >> "%temp%\getadmin.vbs"
  "%temp%\getadmin.vbs"
  exit /b 2
)

set dir=%~dp0
set scriptPath=%dir%DiagReport.ps1
for /f "tokens=*" %%a in ('powershell Get-ExecutionPolicy') do (
set originPolicy=%%a
)
powershell Set-ExecutionPolicy 0

rem this call only works for Administrator
rem powershell %scriptPath%

rem This call works also for normal users
rem "No Exit" version:
rem powershell -NoExit -noprofile -command "&{start-process powershell -ArgumentList '-NoExit -noprofile -file \"%scriptPath%\"' -verb RunAs}"
rem "Exit" version:
powershell -noprofile -command "&{start-process powershell -ArgumentList '-noprofile -file \"%scriptPath%\"' -verb RunAs}"

powershell Set-ExecutionPolicy %originPolicy%

rem pause

```

`installer/DiagReport.ps1`:

```ps1
#
# Deploy.ps1 - The diagnostic report script for Npcap
# Author: Yang Luo
# Date: August 29, 2016
#

$report_file_name = $MyInvocation.MyCommand.Definition.Replace(".ps1", "-" + (Get-Date -Format 'yyyyMMdd-HHmmss') + ".txt")

# Delete the old report if exists.
if (Test-Path $report_file_name)
{
    Remove-Item $report_file_name
}

$(

# $ErrorActionPreference="SilentlyContinue"
# Stop-Transcript | Out-Null
# $ErrorActionPreference = "Continue"
# Start-Transcript -IncludeInvocationHeader -Path $report_file_name

function write_report($text)
{
    # Write-Host $text
    # Write-Output $text
    # $text | Out-File -Append -FilePath $report_file_name
    $text
    # $text >> $report_file_name
    # Write-Output $text | Out-File -Append -FilePath $report_file_name
}

function get_script_bit()
{
    if ([IntPtr]::Size -eq 8)
    {
        '64-bit'
    }
    else
    {
        '32-bit'
    }
}

function get_os_bit()
{
    return (Get-WmiObject Win32_OperatingSystem).OSArchitecture
}

function get_install_path()
{
    if ($os_bit -eq "32-bit")
    {
        return (Get-ItemProperty HKLM:\SOFTWARE\Npcap).'(default)'
    }
    else
    {
        return (Get-ItemProperty HKLM:\SOFTWARE\WOW6432Node\Npcap).'(default)'
    }
}

$os_bit = get_os_bit
$install_path = get_install_path

function get_props_safe($item)
{
	write_report ("${item}:")
	try {
		(Get-ItemProperty -erroraction stop $item | out-string -stream -Width 2147483647 | ? { $_ -NOTMATCH '^ps.+' })
	}
	catch [System.Management.Automation.ItemNotFoundException] {
		"Not present."
	}
}

write_report ("*************************************************")
write_report "DiagReport for Npcap ( https://npcap.com )"
write_report ("*************************************************")
"Script Architecture:`t`t" + (get_script_bit)
"Script Path:`t`t`t" + ($MyInvocation.MyCommand.Definition)
"Current Time:`t`t`t" + (Get-Date)
"Npcap install path:`t`t" + $install_path
"Npcap Version:`t`t`t" + ([System.Diagnostics.FileVersionInfo]::GetVersionInfo($install_path + "\NPFInstall.exe").FileVersion)
"PowerShell Version:`t`t" + ($PSVersionTable.PSVersion)

#########################################################
write_report ("`n")
write_report ("*************************************************")
write_report ("OS Info:")
write_report ("*************************************************")

(Get-WmiObject Win32_OperatingSystem) | Format-List Caption, BuildNumber, Locale, MUILanguages, OSArchitecture, ServicePackMajorVersion, ServicePackMinorVersion, SystemDirectory, Version

#########################################################
write_report ("`n")
write_report ("*************************************************")
write_report ("CPU Info:")
write_report ("*************************************************")

(Get-WmiObject Win32_Processor) | Format-List Name, Manufacturer, DeviceID, NumberOfCores, NumberOfEnabledCore, NumberOfLogicalProcessors, Addresswidth

#########################################################
write_report ("`n")
write_report ("*************************************************")
write_report ("Memory Info:")
write_report ("*************************************************")

"Size:`t`t`t`t" + [int]((Get-WmiObject Win32_ComputerSystem).TotalPhysicalMemory / 1024 / 1024) + " MB" + " (" + (Get-WmiObject Win32_ComputerSystem).TotalPhysicalMemory + " Bytes)"

#########################################################
write_report ("`n")
write_report ("*************************************************")
write_report ("Network Adapter(s) Info:")
write_report ("*************************************************")

(Get-WmiObject Win32_NetworkAdapter) | Where-Object {$_.GUID -ne $null} | Format-List Caption, GUID, Index, InterfaceIndex, Manufacturer, MACAddress, Speed, NetConnectionID, NetConnectionStatus, PNPDeviceID, ServiceName, AdapterType

#########################################################
#write_report ("`n")
#write_report ("*************************************************")
#write_report ("Driver Info:")
#write_report ("*************************************************")

#Get-WmiObject Win32_SystemDriver | 
#    select *, @{ N='CompanyName';E={ (Get-ItemProperty $_.pathname -ErrorAction Ignore).VersionInfo.companyname }} |
#    Where CompanyName -NotLike "*microsoft*" |
#    Where State -NotLike "Stopped" |
#    sort State, Name |
#    Format-Table Name, Description, ServiceType, State, ExitCode, CompanyName, PathName

#########################################################
write_report ("`n")
write_report ("*************************************************")
write_report ("NDIS Light-Weight Filter (LWF) Info:")
write_report ("*************************************************")

get_props_safe 'HKLM:\SYSTEM\CurrentControlSet\Control\Network\{4d36e974-e325-11ce-bfc1-08002be10318}\*'

Get-NetAdapterBinding -ComponentID "INSECURE_NPCAP*"

#########################################################
write_report ("`n")
"*************************************************"
write_report ("File Info:")
write_report ("*************************************************")

# write_report ("C:\Program Files\Npcap:")
dir $install_path
ls ($install_path + '\npcap.*'),($install_path + '\*.exe') | Get-AuthenticodeSignature | select -property Path, Status, StatusMessage, @{Name="Thumbprint"; Expression={$_.SignerCertificate | select -expandproperty Thumbprint}}

# write_report ("C:\Windows\System32:")
dir ($env:WinDir + "\System32\") NpcapHelper.exe
dir ($env:WinDir + "\System32\") Packet.dll
dir ($env:WinDir + "\System32\") WlanHelper.exe
dir ($env:WinDir + "\System32\") wpcap.dll
dir ($env:WinDir + "\System32\Npcap\")

if ($os_bit -eq "64-bit")
{
    # write_report ("C:\Windows\SysWOW64:")
    dir ($env:WinDir + "\SysWOW64\") NpcapHelper.exe
    dir ($env:WinDir + "\SysWOW64\") Packet.dll
    dir ($env:WinDir + "\SysWOW64\") WlanHelper.exe
    dir ($env:WinDir + "\SysWOW64\") wpcap.dll
    dir ($env:WinDir + "\SysWOW64\Npcap\")
}

#########################################################
write_report ("`n")
write_report ("*************************************************")
write_report ("WinPcap Info:")
write_report ("*************************************************")

if ($os_bit -eq "32-bit")
{
    get_props_safe ("HKLM:\SOFTWARE\WinPcap")
}
else
{
    get_props_safe ("HKLM:\SOFTWARE\WOW6432Node\WinPcap")
}

#########################################################
write_report ("`n")
write_report ("*************************************************")
write_report ("Registry Info:")
write_report ("*************************************************")

if ($os_bit -eq "32-bit")
{
    get_props_safe ("HKLM:\SOFTWARE\Npcap")
}
else
{
    get_props_safe ("HKLM:\SOFTWARE\WOW6432Node\Npcap")
}

get_props_safe ("HKLM:\SYSTEM\CurrentControlSet\Services\npcap")
get_props_safe ("HKLM:\SYSTEM\CurrentControlSet\Services\npcap\Parameters")
get_props_safe ("HKLM:\SYSTEM\CurrentControlSet\Services\npcap_wifi")

# WinPcap registry items
get_props_safe ("HKLM:\SYSTEM\CurrentControlSet\Services\npf")
get_props_safe ("HKLM:\SYSTEM\CurrentControlSet\Services\npf\Parameters")
get_props_safe ("HKLM:\SYSTEM\CurrentControlSet\Services\npf_wifi")

#########################################################
write_report ("`n")
write_report ("*************************************************")
write_report ("Service Info:")
write_report ("*************************************************")

Get-Service npcap

Get-Service npf

#########################################################
write_report ("`n")
write_report ("*************************************************")
write_report ("Install Info:")
write_report ("*************************************************")

write_report ("Please refer to: $install_path\install.log")

if (Test-Path -Path "$install_path\DriverQuery.exe" -PathType Leaf) {
	& "$install_path\DriverQuery.exe"
}

# Stop-Transcript
# ) *>&1 > $report_file_name
# ) >> $report_file_name
) 2>&1 >> $report_file_name

notepad $report_file_name

# SIG # Begin signature block
# MIIouAYJKoZIhvcNAQcCoIIoqTCCKKUCAQExDzANBglghkgBZQMEAgEFADB5Bgor
# BgEEAYI3AgEEoGswaTA0BgorBgEEAYI3AgEeMCYCAwEAAAQQH8w7YFlLCE63JNLG
# KX7zUQIBAAIBAAIBAAIBAAIBADAxMA0GCWCGSAFlAwQCAQUABCDFOYxrrmsFf38/
# K4G5Z6hlTZhMVncdU3qscbtNt+CZyKCCIbUwggWNMIIEdaADAgECAhAOmxiO+dAt
# 5+/bUOIIQBhaMA0GCSqGSIb3DQEBDAUAMGUxCzAJBgNVBAYTAlVTMRUwEwYDVQQK
# EwxEaWdpQ2VydCBJbmMxGTAXBgNVBAsTEHd3dy5kaWdpY2VydC5jb20xJDAiBgNV
# BAMTG0RpZ2lDZXJ0IEFzc3VyZWQgSUQgUm9vdCBDQTAeFw0yMjA4MDEwMDAwMDBa
# Fw0zMTExMDkyMzU5NTlaMGIxCzAJBgNVBAYTAlVTMRUwEwYDVQQKEwxEaWdpQ2Vy
# dCBJbmMxGTAXBgNVBAsTEHd3dy5kaWdpY2VydC5jb20xITAfBgNVBAMTGERpZ2lD
# ZXJ0IFRydXN0ZWQgUm9vdCBHNDCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoC
# ggIBAL/mkHNo3rvkXUo8MCIwaTPswqclLskhPfKK2FnC4SmnPVirdprNrnsbhA3E
# MB/zG6Q4FutWxpdtHauyefLKEdLkX9YFPFIPUh/GnhWlfr6fqVcWWVVyr2iTcMKy
# unWZanMylNEQRBAu34LzB4TmdDttceItDBvuINXJIB1jKS3O7F5OyJP4IWGbNOsF
# xl7sWxq868nPzaw0QF+xembud8hIqGZXV59UWI4MK7dPpzDZVu7Ke13jrclPXuU1
# 5zHL2pNe3I6PgNq2kZhAkHnDeMe2scS1ahg4AxCN2NQ3pC4FfYj1gj4QkXCrVYJB
# MtfbBHMqbpEBfCFM1LyuGwN1XXhm2ToxRJozQL8I11pJpMLmqaBn3aQnvKFPObUR
# WBf3JFxGj2T3wWmIdph2PVldQnaHiZdpekjw4KISG2aadMreSx7nDmOu5tTvkpI6
# nj3cAORFJYm2mkQZK37AlLTSYW3rM9nF30sEAMx9HJXDj/chsrIRt7t/8tWMcCxB
# YKqxYxhElRp2Yn72gLD76GSmM9GJB+G9t+ZDpBi4pncB4Q+UDCEdslQpJYls5Q5S
# UUd0viastkF13nqsX40/ybzTQRESW+UQUOsxxcpyFiIJ33xMdT9j7CFfxCBRa2+x
# q4aLT8LWRV+dIPyhHsXAj6KxfgommfXkaS+YHS312amyHeUbAgMBAAGjggE6MIIB
# NjAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBTs1+OC0nFdZEzfLmc/57qYrhwP
# TzAfBgNVHSMEGDAWgBRF66Kv9JLLgjEtUYunpyGd823IDzAOBgNVHQ8BAf8EBAMC
# AYYweQYIKwYBBQUHAQEEbTBrMCQGCCsGAQUFBzABhhhodHRwOi8vb2NzcC5kaWdp
# Y2VydC5jb20wQwYIKwYBBQUHMAKGN2h0dHA6Ly9jYWNlcnRzLmRpZ2ljZXJ0LmNv
# bS9EaWdpQ2VydEFzc3VyZWRJRFJvb3RDQS5jcnQwRQYDVR0fBD4wPDA6oDigNoY0
# aHR0cDovL2NybDMuZGlnaWNlcnQuY29tL0RpZ2lDZXJ0QXNzdXJlZElEUm9vdENB
# LmNybDARBgNVHSAECjAIMAYGBFUdIAAwDQYJKoZIhvcNAQEMBQADggEBAHCgv0Nc
# Vec4X6CjdBs9thbX979XB72arKGHLOyFXqkauyL4hxppVCLtpIh3bb0aFPQTSnov
# Lbc47/T/gLn4offyct4kvFIDyE7QKt76LVbP+fT3rDB6mouyXtTP0UNEm0Mh65Zy
# oUi0mcudT6cGAxN3J0TU53/oWajwvy8LpunyNDzs9wPHh6jSTEAZNUZqaVSwuKFW
# juyk1T3osdz9HNj0d1pcVIxv76FQPfx2CWiEn2/K2yCNNWAcAgPLILCsWKAOQGPF
# mCLBsln1VWvPJ6tsds5vIy30fnFqI2si/xK4VC0nftg62fC2h5b9W9FcrBjDTZ9z
# twGpn1eqXijiuZQwggawMIIEmKADAgECAhAIrUCyYNKcTJ9ezam9k67ZMA0GCSqG
# SIb3DQEBDAUAMGIxCzAJBgNVBAYTAlVTMRUwEwYDVQQKEwxEaWdpQ2VydCBJbmMx
# GTAXBgNVBAsTEHd3dy5kaWdpY2VydC5jb20xITAfBgNVBAMTGERpZ2lDZXJ0IFRy
# dXN0ZWQgUm9vdCBHNDAeFw0yMTA0MjkwMDAwMDBaFw0zNjA0MjgyMzU5NTlaMGkx
# CzAJBgNVBAYTAlVTMRcwFQYDVQQKEw5EaWdpQ2VydCwgSW5jLjFBMD8GA1UEAxM4
# RGlnaUNlcnQgVHJ1c3RlZCBHNCBDb2RlIFNpZ25pbmcgUlNBNDA5NiBTSEEzODQg
# MjAyMSBDQTEwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDVtC9C0Cit
# eLdd1TlZG7GIQvUzjOs9gZdwxbvEhSYwn6SOaNhc9es0JAfhS0/TeEP0F9ce2vnS
# 1WcaUk8OoVf8iJnBkcyBAz5NcCRks43iCH00fUyAVxJrQ5qZ8sU7H/Lvy0daE6ZM
# swEgJfMQ04uy+wjwiuCdCcBlp/qYgEk1hz1RGeiQIXhFLqGfLOEYwhrMxe6TSXBC
# Mo/7xuoc82VokaJNTIIRSFJo3hC9FFdd6BgTZcV/sk+FLEikVoQ11vkunKoAFdE3
# /hoGlMJ8yOobMubKwvSnowMOdKWvObarYBLj6Na59zHh3K3kGKDYwSNHR7OhD26j
# q22YBoMbt2pnLdK9RBqSEIGPsDsJ18ebMlrC/2pgVItJwZPt4bRc4G/rJvmM1bL5
# OBDm6s6R9b7T+2+TYTRcvJNFKIM2KmYoX7BzzosmJQayg9Rc9hUZTO1i4F4z8ujo
# 7AqnsAMrkbI2eb73rQgedaZlzLvjSFDzd5Ea/ttQokbIYViY9XwCFjyDKK05huzU
# tw1T0PhH5nUwjewwk3YUpltLXXRhTT8SkXbev1jLchApQfDVxW0mdmgRQRNYmtwm
# KwH0iU1Z23jPgUo+QEdfyYFQc4UQIyFZYIpkVMHMIRroOBl8ZhzNeDhFMJlP/2NP
# TLuqDQhTQXxYPUez+rbsjDIJAsxsPAxWEQIDAQABo4IBWTCCAVUwEgYDVR0TAQH/
# BAgwBgEB/wIBADAdBgNVHQ4EFgQUaDfg67Y7+F8Rhvv+YXsIiGX0TkIwHwYDVR0j
# BBgwFoAU7NfjgtJxXWRM3y5nP+e6mK4cD08wDgYDVR0PAQH/BAQDAgGGMBMGA1Ud
# JQQMMAoGCCsGAQUFBwMDMHcGCCsGAQUFBwEBBGswaTAkBggrBgEFBQcwAYYYaHR0
# cDovL29jc3AuZGlnaWNlcnQuY29tMEEGCCsGAQUFBzAChjVodHRwOi8vY2FjZXJ0
# cy5kaWdpY2VydC5jb20vRGlnaUNlcnRUcnVzdGVkUm9vdEc0LmNydDBDBgNVHR8E
# PDA6MDigNqA0hjJodHRwOi8vY3JsMy5kaWdpY2VydC5jb20vRGlnaUNlcnRUcnVz
# dGVkUm9vdEc0LmNybDAcBgNVHSAEFTATMAcGBWeBDAEDMAgGBmeBDAEEATANBgkq
# hkiG9w0BAQwFAAOCAgEAOiNEPY0Idu6PvDqZ01bgAhql+Eg08yy25nRm95RysQDK
# r2wwJxMSnpBEn0v9nqN8JtU3vDpdSG2V1T9J9Ce7FoFFUP2cvbaF4HZ+N3HLIvda
# qpDP9ZNq4+sg0dVQeYiaiorBtr2hSBh+3NiAGhEZGM1hmYFW9snjdufE5BtfQ/g+
# lP92OT2e1JnPSt0o618moZVYSNUa/tcnP/2Q0XaG3RywYFzzDaju4ImhvTnhOE7a
# brs2nfvlIVNaw8rpavGiPttDuDPITzgUkpn13c5UbdldAhQfQDN8A+KVssIhdXNS
# y0bYxDQcoqVLjc1vdjcshT8azibpGL6QB7BDf5WIIIJw8MzK7/0pNVwfiThV9zeK
# iwmhywvpMRr/LhlcOXHhvpynCgbWJme3kuZOX956rEnPLqR0kq3bPKSchh/jwVYb
# KyP/j7XqiHtwa+aguv06P0WmxOgWkVKLQcBIhEuWTatEQOON8BUozu3xGFYHKi8Q
# xAwIZDwzj64ojDzLj4gLDb879M4ee47vtevLt/B3E+bnKD+sEq6lLyJsQfmCXBVm
# zGwOysWGw/YmMwwHS6DTBwJqakAwSEs0qFEgu60bhQjiWQ1tygVQK+pKHJ6l/aCn
# HwZ05/LWUpD9r4VIIflXO7ScA+2GRfS0YW6/aOImYIbqyK+p/pQd52MbOoZWeE4w
# gga0MIIEnKADAgECAhANx6xXBf8hmS5AQyIMOkmGMA0GCSqGSIb3DQEBCwUAMGIx
# CzAJBgNVBAYTAlVTMRUwEwYDVQQKEwxEaWdpQ2VydCBJbmMxGTAXBgNVBAsTEHd3
# dy5kaWdpY2VydC5jb20xITAfBgNVBAMTGERpZ2lDZXJ0IFRydXN0ZWQgUm9vdCBH
# NDAeFw0yNTA1MDcwMDAwMDBaFw0zODAxMTQyMzU5NTlaMGkxCzAJBgNVBAYTAlVT
# MRcwFQYDVQQKEw5EaWdpQ2VydCwgSW5jLjFBMD8GA1UEAxM4RGlnaUNlcnQgVHJ1
# c3RlZCBHNCBUaW1lU3RhbXBpbmcgUlNBNDA5NiBTSEEyNTYgMjAyNSBDQTEwggIi
# MA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQC0eDHTCphBcr48RsAcrHXbo0Zo
# dLRRF51NrY0NlLWZloMsVO1DahGPNRcybEKq+RuwOnPhof6pvF4uGjwjqNjfEvUi
# 6wuim5bap+0lgloM2zX4kftn5B1IpYzTqpyFQ/4Bt0mAxAHeHYNnQxqXmRinvuNg
# xVBdJkf77S2uPoCj7GH8BLuxBG5AvftBdsOECS1UkxBvMgEdgkFiDNYiOTx4OtiF
# cMSkqTtF2hfQz3zQSku2Ws3IfDReb6e3mmdglTcaarps0wjUjsZvkgFkriK9tUKJ
# m/s80FiocSk1VYLZlDwFt+cVFBURJg6zMUjZa/zbCclF83bRVFLeGkuAhHiGPMvS
# GmhgaTzVyhYn4p0+8y9oHRaQT/aofEnS5xLrfxnGpTXiUOeSLsJygoLPp66bkDX1
# ZlAeSpQl92QOMeRxykvq6gbylsXQskBBBnGy3tW/AMOMCZIVNSaz7BX8VtYGqLt9
# MmeOreGPRdtBx3yGOP+rx3rKWDEJlIqLXvJWnY0v5ydPpOjL6s36czwzsucuoKs7
# Yk/ehb//Wx+5kMqIMRvUBDx6z1ev+7psNOdgJMoiwOrUG2ZdSoQbU2rMkpLiQ6bG
# RinZbI4OLu9BMIFm1UUl9VnePs6BaaeEWvjJSjNm2qA+sdFUeEY0qVjPKOWug/G6
# X5uAiynM7Bu2ayBjUwIDAQABo4IBXTCCAVkwEgYDVR0TAQH/BAgwBgEB/wIBADAd
# BgNVHQ4EFgQU729TSunkBnx6yuKQVvYv1Ensy04wHwYDVR0jBBgwFoAU7NfjgtJx
# XWRM3y5nP+e6mK4cD08wDgYDVR0PAQH/BAQDAgGGMBMGA1UdJQQMMAoGCCsGAQUF
# BwMIMHcGCCsGAQUFBwEBBGswaTAkBggrBgEFBQcwAYYYaHR0cDovL29jc3AuZGln
# aWNlcnQuY29tMEEGCCsGAQUFBzAChjVodHRwOi8vY2FjZXJ0cy5kaWdpY2VydC5j
# b20vRGlnaUNlcnRUcnVzdGVkUm9vdEc0LmNydDBDBgNVHR8EPDA6MDigNqA0hjJo
# dHRwOi8vY3JsMy5kaWdpY2VydC5jb20vRGlnaUNlcnRUcnVzdGVkUm9vdEc0LmNy
# bDAgBgNVHSAEGTAXMAgGBmeBDAEEAjALBglghkgBhv1sBwEwDQYJKoZIhvcNAQEL
# BQADggIBABfO+xaAHP4HPRF2cTC9vgvItTSmf83Qh8WIGjB/T8ObXAZz8OjuhUxj
# aaFdleMM0lBryPTQM2qEJPe36zwbSI/mS83afsl3YTj+IQhQE7jU/kXjjytJgnn0
# hvrV6hqWGd3rLAUt6vJy9lMDPjTLxLgXf9r5nWMQwr8Myb9rEVKChHyfpzee5kH0
# F8HABBgr0UdqirZ7bowe9Vj2AIMD8liyrukZ2iA/wdG2th9y1IsA0QF8dTXqvcnT
# mpfeQh35k5zOCPmSNq1UH410ANVko43+Cdmu4y81hjajV/gxdEkMx1NKU4uHQcKf
# ZxAvBAKqMVuqte69M9J6A47OvgRaPs+2ykgcGV00TYr2Lr3ty9qIijanrUR3anzE
# wlvzZiiyfTPjLbnFRsjsYg39OlV8cipDoq7+qNNjqFzeGxcytL5TTLL4ZaoBdqbh
# OhZ3ZRDUphPvSRmMThi0vw9vODRzW6AxnJll38F0cuJG7uEBYTptMSbhdhGQDpOX
# gpIUsWTjd6xpR6oaQf/DJbg3s6KCLPAlZ66RzIg9sC+NJpud/v4+7RWsWCiKi9EO
# LLHfMR2ZyJ/+xhCx9yHbxtl5TPau1j/1MIDpMPx0LckTetiSuEtQvLsNz3Qbp7wG
# WqbIiOWCnb5WqxL3/BAPvIXKUjPSxyZsq8WhbaM2tszWkPZPubdcMIIG7TCCBNWg
# AwIBAgIQCoDvGEuN8QWC0cR2p5V0aDANBgkqhkiG9w0BAQsFADBpMQswCQYDVQQG
# EwJVUzEXMBUGA1UEChMORGlnaUNlcnQsIEluYy4xQTA/BgNVBAMTOERpZ2lDZXJ0
# IFRydXN0ZWQgRzQgVGltZVN0YW1waW5nIFJTQTQwOTYgU0hBMjU2IDIwMjUgQ0Ex
# MB4XDTI1MDYwNDAwMDAwMFoXDTM2MDkwMzIzNTk1OVowYzELMAkGA1UEBhMCVVMx
# FzAVBgNVBAoTDkRpZ2lDZXJ0LCBJbmMuMTswOQYDVQQDEzJEaWdpQ2VydCBTSEEy
# NTYgUlNBNDA5NiBUaW1lc3RhbXAgUmVzcG9uZGVyIDIwMjUgMTCCAiIwDQYJKoZI
# hvcNAQEBBQADggIPADCCAgoCggIBANBGrC0Sxp7Q6q5gVrMrV7pvUf+GcAoB38o3
# zBlCMGMyqJnfFNZx+wvA69HFTBdwbHwBSOeLpvPnZ8ZN+vo8dE2/pPvOx/Vj8Tch
# TySA2R4QKpVD7dvNZh6wW2R6kSu9RJt/4QhguSssp3qome7MrxVyfQO9sMx6ZAWj
# FDYOzDi8SOhPUWlLnh00Cll8pjrUcCV3K3E0zz09ldQ//nBZZREr4h/GI6Dxb2Uo
# yrN0ijtUDVHRXdmncOOMA3CoB/iUSROUINDT98oksouTMYFOnHoRh6+86Ltc5zjP
# KHW5KqCvpSduSwhwUmotuQhcg9tw2YD3w6ySSSu+3qU8DD+nigNJFmt6LAHvH3KS
# uNLoZLc1Hf2JNMVL4Q1OpbybpMe46YceNA0LfNsnqcnpJeItK/DhKbPxTTuGoX7w
# JNdoRORVbPR1VVnDuSeHVZlc4seAO+6d2sC26/PQPdP51ho1zBp+xUIZkpSFA8vW
# doUoHLWnqWU3dCCyFG1roSrgHjSHlq8xymLnjCbSLZ49kPmk8iyyizNDIXj//cOg
# rY7rlRyTlaCCfw7aSUROwnu7zER6EaJ+AliL7ojTdS5PWPsWeupWs7NpChUk555K
# 096V1hE0yZIXe+giAwW00aHzrDchIc2bQhpp0IoKRR7YufAkprxMiXAJQ1XCmnCf
# gPf8+3mnAgMBAAGjggGVMIIBkTAMBgNVHRMBAf8EAjAAMB0GA1UdDgQWBBTkO/zy
# Me39/dfzkXFjGVBDz2GM6DAfBgNVHSMEGDAWgBTvb1NK6eQGfHrK4pBW9i/USezL
# TjAOBgNVHQ8BAf8EBAMCB4AwFgYDVR0lAQH/BAwwCgYIKwYBBQUHAwgwgZUGCCsG
# AQUFBwEBBIGIMIGFMCQGCCsGAQUFBzABhhhodHRwOi8vb2NzcC5kaWdpY2VydC5j
# b20wXQYIKwYBBQUHMAKGUWh0dHA6Ly9jYWNlcnRzLmRpZ2ljZXJ0LmNvbS9EaWdp
# Q2VydFRydXN0ZWRHNFRpbWVTdGFtcGluZ1JTQTQwOTZTSEEyNTYyMDI1Q0ExLmNy
# dDBfBgNVHR8EWDBWMFSgUqBQhk5odHRwOi8vY3JsMy5kaWdpY2VydC5jb20vRGln
# aUNlcnRUcnVzdGVkRzRUaW1lU3RhbXBpbmdSU0E0MDk2U0hBMjU2MjAyNUNBMS5j
# cmwwIAYDVR0gBBkwFzAIBgZngQwBBAIwCwYJYIZIAYb9bAcBMA0GCSqGSIb3DQEB
# CwUAA4ICAQBlKq3xHCcEua5gQezRCESeY0ByIfjk9iJP2zWLpQq1b4URGnwWBdEZ
# D9gBq9fNaNmFj6Eh8/YmRDfxT7C0k8FUFqNh+tshgb4O6Lgjg8K8elC4+oWCqnU/
# ML9lFfim8/9yJmZSe2F8AQ/UdKFOtj7YMTmqPO9mzskgiC3QYIUP2S3HQvHG1FDu
# +WUqW4daIqToXFE/JQ/EABgfZXLWU0ziTN6R3ygQBHMUBaB5bdrPbF6MRYs03h4o
# bEMnxYOX8VBRKe1uNnzQVTeLni2nHkX/QqvXnNb+YkDFkxUGtMTaiLR9wjxUxu2h
# ECZpqyU1d0IbX6Wq8/gVutDojBIFeRlqAcuEVT0cKsb+zJNEsuEB7O7/cuvTQasn
# M9AWcIQfVjnzrvwiCZ85EE8LUkqRhoS3Y50OHgaY7T/lwd6UArb+BOVAkg2oOvol
# /DJgddJ35XTxfUlQ+8Hggt8l2Yv7roancJIFcbojBcxlRcGG0LIhp6GvReQGgMgY
# xQbV1S3CrWqZzBt1R9xJgKf47CdxVRd/ndUlQ05oxYy2zRWVFjF7mcr4C34Mj3oc
# CVccAvlKV9jEnstrniLvUxxVZE/rptb7IRE2lskKPIJgbaP5t2nGj/ULLi49xTcB
# ZU8atufk+EMF/cWuiC7POGT75qaL6vdCvHlshtjdNXOCIUjsarfNZzCCB8MwggWr
# oAMCAQICEAZ11rWe8bCrMOXS4EbaJDEwDQYJKoZIhvcNAQELBQAwaTELMAkGA1UE
# BhMCVVMxFzAVBgNVBAoTDkRpZ2lDZXJ0LCBJbmMuMUEwPwYDVQQDEzhEaWdpQ2Vy
# dCBUcnVzdGVkIEc0IENvZGUgU2lnbmluZyBSU0E0MDk2IFNIQTM4NCAyMDIxIENB
# MTAeFw0yNDA3MjUwMDAwMDBaFw0yNzA2MDkyMzU5NTlaMIHLMRMwEQYLKwYBBAGC
# NzwCAQMTAlVTMRkwFwYLKwYBBAGCNzwCAQITCERlbGF3YXJlMR0wGwYDVQQPDBRQ
# cml2YXRlIE9yZ2FuaXphdGlvbjEQMA4GA1UEBRMHNjM5NzU4ODELMAkGA1UEBhMC
# VVMxDzANBgNVBAgTBk9yZWdvbjESMBAGA1UEBxMJQmVhdmVydG9uMRowGAYDVQQK
# ExFObWFwIFNvZnR3YXJlIExMQzEaMBgGA1UEAxMRTm1hcCBTb2Z0d2FyZSBMTEMw
# ggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDoD32B1DtufyfFqdZxv5K1
# u06+KasIc0GruUoYmGkznSkoJp/4oUKoMctsd+RfhpE3WuAJKA0UhFatf4F82W2L
# 6s0JmAdh/dmdjOsonctPDaQDDuumH88ifz5Cco49Vp/iORl9ROzztTKtEmz/mhWq
# /GaAe6nWN6o6XUq0UYm4NdFcy1UCUTsAuEI7PFNrS/O8Q3QYYjdgMiMUL2aIHrF/
# aZ+UZ/ZsgpNmuNZniLoSaMzayQniAk5TQTq+IDOCXI+UvcyW8UZNel47Cup6p+0t
# rrVXn0AnnE2HmuFn/H8GSlSn9HTPioWQ5vnHjvt/T205bMayPCPHWioK187RDp0Y
# 2INQigH4eswbs7wz21RkQyvl5QQqtOE47GRnsltTYszhqFb+0cjc06Hli019vjji
# y5qaD3r4jeWGeOlIwpXb8afzXUvhOJ7YArPRvJgsInLq8TqNoEwAXO8h/6x+spK9
# OEvTPHJrt/1Gm21ekmvUFyjwsWEaI3M0Y2hYrU91OTIj2TLMhX2GPo8irzvcOUNv
# oxzrbQPItlX9Ovs00WigkvtDSzJQYMzGTeCzmcrK3LoCQl9WQzIEvUTsLJJkU+FU
# 5z4zUcFsBvAV1S58KJs1P+XwgxnidLpjw7SN/NGxE4lkOOioFVLRp4RN64Fk2QOT
# oeE4l4fXWf5bzwzfsA+czwIDAQABo4ICAjCCAf4wHwYDVR0jBBgwFoAUaDfg67Y7
# +F8Rhvv+YXsIiGX0TkIwHQYDVR0OBBYEFHu1WsUGAQKH/u+t5UY4reZm/xufMD0G
# A1UdIAQ2MDQwMgYFZ4EMAQMwKTAnBggrBgEFBQcCARYbaHR0cDovL3d3dy5kaWdp
# Y2VydC5jb20vQ1BTMA4GA1UdDwEB/wQEAwIHgDATBgNVHSUEDDAKBggrBgEFBQcD
# AzCBtQYDVR0fBIGtMIGqMFOgUaBPhk1odHRwOi8vY3JsMy5kaWdpY2VydC5jb20v
# RGlnaUNlcnRUcnVzdGVkRzRDb2RlU2lnbmluZ1JTQTQwOTZTSEEzODQyMDIxQ0Ex
# LmNybDBToFGgT4ZNaHR0cDovL2NybDQuZGlnaWNlcnQuY29tL0RpZ2lDZXJ0VHJ1
# c3RlZEc0Q29kZVNpZ25pbmdSU0E0MDk2U0hBMzg0MjAyMUNBMS5jcmwwgZQGCCsG
# AQUFBwEBBIGHMIGEMCQGCCsGAQUFBzABhhhodHRwOi8vb2NzcC5kaWdpY2VydC5j
# b20wXAYIKwYBBQUHMAKGUGh0dHA6Ly9jYWNlcnRzLmRpZ2ljZXJ0LmNvbS9EaWdp
# Q2VydFRydXN0ZWRHNENvZGVTaWduaW5nUlNBNDA5NlNIQTM4NDIwMjFDQTEuY3J0
# MAkGA1UdEwQCMAAwDQYJKoZIhvcNAQELBQADggIBAHwAekesQiThjV0MenlfhxgH
# C4+9Wbri+kkmApzEZMvKN+9wxoPMF2JlX0qR+urJ3jBKQZMUitgHg1oIQ4nvJII3
# o3TCSNphIERto5wQpGhS6PwqWUwDHS3mwZ6w7mtNqLUVnOmUerW5d/gFk0rvEcy5
# j8G24Z6kE4Te4bvL7yyK9dJnCYZi+NcvgrmLGAvifz0CiUadJ8xpgfZ7wHU2kycn
# hsy7SQl8iGabag2w31zaBDRwTFeFQYncqow4c/+hcvdX7yh4RELAg575LGLKcxTW
# gErUoovDksh+xZKiB+SYFRNnfi9/KU2w9hCbWoDZ0E02QCLM4eCq8p3lX64HVsh8
# 0cFH5mMWilGM4t5enk3pmxw1DShCd8xb0V/Li6kvmu5s82MunouXL3rLOMjOTkQC
# sbJqlPfLCejs17gX7SLi5MH681IsI4RZsf1Ce158hO/jIUtkQiP2UDkpKMgVM2Jk
# lh6r2hcvCJjrSkLuqgM8TwrekGjn4/lksveIujwTqhwjaa/MrFgQ4WbCrurrtkiv
# KHZz/j38bQooWXt9L+XcRVL37h0BgAmGjraWfFc0jvCqhK9+f3423K7apay4cbQX
# KS1yeOwxSZ4AAVNY1eTcTygNZW7LoY/nrFue5VKHSv2/p7ZFIafvlivYtsFh8vTE
# lDS6TitAblSNuq7JtmS5MYIGWTCCBlUCAQEwfTBpMQswCQYDVQQGEwJVUzEXMBUG
# A1UEChMORGlnaUNlcnQsIEluYy4xQTA/BgNVBAMTOERpZ2lDZXJ0IFRydXN0ZWQg
# RzQgQ29kZSBTaWduaW5nIFJTQTQwOTYgU0hBMzg0IDIwMjEgQ0ExAhAGdda1nvGw
# qzDl0uBG2iQxMA0GCWCGSAFlAwQCAQUAoIGEMBgGCisGAQQBgjcCAQwxCjAIoAKA
# AKECgAAwGQYJKoZIhvcNAQkDMQwGCisGAQQBgjcCAQQwHAYKKwYBBAGCNwIBCzEO
# MAwGCisGAQQBgjcCARUwLwYJKoZIhvcNAQkEMSIEIEwm6jZgTgKl93mRaGxU+RPF
# EtT8hYcmKZ52UCy4UHcFMA0GCSqGSIb3DQEBAQUABIICAIBIXDFpG72P9Gwx58w3
# k3DSz6y9wMIb6cAVkoq8iwMslUmBwNnw4fnDh8C/yp732+pTE6cLSJIpJ3GmPxNY
# wZQMLMslqwvxuIiQXKP+H6fpTVROUyb1E78p675+1oD5BE9/oM5smG/PeMZl/8x8
# 5Ur0iQHy7AKYWB1WH2Q7ewtlxietHGY95Jthm2VYInUojmhzFPDLmBJAJU+dwi/f
# JSjtiOKU4FEFdfnYBrhfuX5wnGESpAJVwkEZW9Uu8FFpNIFuc+CrcsA1YAntffNz
# 2TJgP7TMYG0ziDhCuMiZnylbH/T4/kptvb9vAW+aYlS/xAkOns4moL7T+7pkYn8k
# cx7cRRJEt2m0BV+CH8zenrQbMDI1hqGkUaeMjW2UKp8m+EHgbPsga/HeUy6fNwSg
# EgHRDRHebCtGqqIXFVPru/TtoJL73KdXM6bIFaOzUT3F83BR1SPSbfYSS4IQM5rx
# PvpR8wIXdXICc5wEgE4nOG2t3K9E0ZcRvbUxOAEy/RSsmm7wf0okmk07jYGftN6I
# U42I/Rl+P2I9F5ivQVtsRlRWs5To2AZzv2/U+JZSg2W0H+thL8yOcDjbPjgR8sNI
# NGdAKNMnMqL8LmFZFOsW+UsJgYTNiFBzMVxD77s0h6iaV45RaBl+eTsUd44c98jj
# JMdspRIhWGu2KHkpBnugGlWSoYIDJjCCAyIGCSqGSIb3DQEJBjGCAxMwggMPAgEB
# MH0waTELMAkGA1UEBhMCVVMxFzAVBgNVBAoTDkRpZ2lDZXJ0LCBJbmMuMUEwPwYD
# VQQDEzhEaWdpQ2VydCBUcnVzdGVkIEc0IFRpbWVTdGFtcGluZyBSU0E0MDk2IFNI
# QTI1NiAyMDI1IENBMQIQCoDvGEuN8QWC0cR2p5V0aDANBglghkgBZQMEAgEFAKBp
# MBgGCSqGSIb3DQEJAzELBgkqhkiG9w0BBwEwHAYJKoZIhvcNAQkFMQ8XDTI1MDky
# NjE1NTIyNVowLwYJKoZIhvcNAQkEMSIEIM7PeEYxOZ1aYcQ3cPw2oToQ5sNp1Twv
# dxpJOWaoJTI5MA0GCSqGSIb3DQEBAQUABIICAG+k8vS1/n/jk2e5kWfDNZ4ZPEqR
# hK+McYhc5yRQwkilIxg7QzicWxWpu4i7q5SAwXnFmBm3XrpywAkqJ2cJeqz79sZS
# /XRKuMDxNTjXx7LCOZuLiEusJpaUSNpUA34gZSLxny1XoUQzemO9d4jHX5D+S3nZ
# LRmJ3nzczmGexZYOvDcRDFP1E1u44N+rbxCPR65CGimz3JDL0D9n1eyqI9A1FLV+
# AnAuv8VASqHSRjS8SOD1dHE/FZiaF1qC80ua2/1f/kpHISonIvD8k9ymY41JbcsT
# 2ogYZ4To7+iSCSVbl7Rb1bN9mgnDGsezmcKbRk/7clGyrC9ef6tJuZl0RNaqsQJL
# gNujdE7ciMNs3qke6q2IcxAx+N8XT6G5beEVGtD6j/Y5txKFFalQr/hXlo2YoAFi
# d5rjyDjCYBP7qPYxvM0iV/OXMILRjoC+l7Q6mqXt7MZiE4On4JT757G4/7e8ZBtS
# SMMsC6SjMeW2NDAmAVM+XIYxDYxAmuW+yd3CeNLZvtaXmPj8M4BfADaV/hskPh9R
# 6ZW+H4iWPepngK1UqczhwZ16FafkiPBPympH9f5d7fBPnqWboneYblIDJ19izugG
# qvdBnpYloinhwEwF5EpnN+7ZU+Nn0PTsnf0AzEBl3Qb8K4VBLcBajLt7Vx1cz64E
# PDeHUAqnC4YfQJ4Q
# SIG # End signature block

```

`installer/FixInstall.bat`:

```bat
@echo off
rem Start type auto will start the Npcap service at boot. Set this to "demand" for demand start instead.
set START_TYPE=system

setlocal ENABLEEXTENSIONS

rem Get the installed configuration
set KEY_NAME=HKLM\SYSTEM\CurrentControlSet\Services\npcap\Parameters
for /F "usebackq tokens=1,2*" %%A IN (`reg query "%KEY_NAME%" /v "Dot11Support" 2^>nul ^| find "Dot11Support"`) do (
	set Dot11Support=%%C
)
echo Dot11Support = %Dot11Support%
for /F "usebackq tokens=1,2*" %%A IN (`reg query "%KEY_NAME%" /v "LoopbackAdapter" 2^>nul ^| find "LoopbackAdapter"`) do (
	set LoopbackAdapter=%%C
)
echo LoopbackAdapter = %LoopbackAdapter%

rem Make sure we can find where Npcap is installed
set KEY_NAME=HKLM\Software\WOW6432Node\Npcap
for /F "usebackq tokens=1,2*" %%A IN (`reg query "%KEY_NAME%" /ve 2^>nul ^| find "REG_SZ"`) do (
	set NPCAP_DIR=%%C
)
if defined NPCAP_DIR (goto DO_FIX)
set KEY_NAME=HKLM\Software\Npcap
for /F "usebackq tokens=1,2*" %%A IN (`reg query "%KEY_NAME%" /ve 2^>nul ^| find "REG_SZ"`) do (
	set NPCAP_DIR=%%C
)
if defined NPCAP_DIR (goto DO_FIX) else (goto ABORT)

:DO_FIX
echo NPCAP_DIR = "%NPCAP_DIR%"
rem Stop the services and set their start types properly
net stop npcap
sc.exe config npcap start= %START_TYPE%
if %Dot11Support% == 0x1 (
	net stop npcap_wifi
	rem *_wifi service is disabled at install
	sc.exe config npcap_wifi start= disabled
)

rem Remove and reinstall loopback adapters
if not %LoopbackAdapter% == "" (
"%NPCAP_DIR%\NPFInstall.exe" -ul
rem )
rem TODO Remove any leftover adapters in any case
rem netsh interface show interface | find "Npcap Loopback Adapter"
rem if NOT ERRORLEVEL 1 (
rem 	echo Some Npcap Loopback Adapter was not removed. Remove it manually:
rem 	echo 1. In the Device Manager, open 'Network adapters'
rem 	echo 2. Right-click any 'Npcap Loopback Adapter' and choose 'Uninstall device'
rem 	echo 3. Repeat until all Npcap Loopback Adapters are removed
rem 	start devmgmt.msc
rem 	pause
rem )
rem
rem if not %LoopbackAdapter% == "" (
"%NPCAP_DIR%\NPFInstall.exe" -il
)

rem Start the Base Filtering Engine in case it was disabled
sc.exe config bfe start= auto
net start bfe

rem Restart the services
net start npcap

rem Rebind the filters to all adapters
if %Dot11Support% == 0x1 (
	"%NPCAP_DIR%\NPFInstall.exe" -r2
) else (
	"%NPCAP_DIR%\NPFInstall.exe" -r
)

rem Done!
goto EOF

:ABORT
echo "Unable to find or fix your installation"
exit /b 1

:EOF
exit /b 0

```

`installer/manifest.txt`:

```txt
INSTDIR\DiagReport.bat
INSTDIR\DiagReport.ps1
INSTDIR\FixInstall.bat
INSTDIR\CheckStatus.bat
INSTDIR\LICENSE
INSTDIR\NPFInstall.exe
INSTDIR\Uninstall.exe
INSTDIR\DriverQuery.exe
INSTDIR\npcap.sys
INSTDIR\npcap.cat
INSTDIR\npcap.inf
INSTDIR\npcap_wfp.inf
SYSDIR\wpcap.dll
SYSDIR\Packet.dll
SYSDIR\NpcapHelper.exe
SYSDIR\WlanHelper.exe

```

`packetWin7/Dll/AdInfo.cpp`:

```cpp
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
/*
 * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)
 * Copyright (c) 2005 - 2010 CACE Technologies, Davis (California)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Politecnico di Torino, CACE Technologies 
 * nor the names of its contributors may be used to endorse or promote 
 * products derived from this software without specific prior written 
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/*
 This file contains the support functions used by packet.dll to retrieve information about installed 
 adapters, like

	- the adapter list
	- the device associated to any adapter and the description of the adapter
	- physical parameters like the linkspeed or the link layer type
	- the IP and link layer addresses  */

#define UNICODE 1

#include "Packet32-Int.h"

#include <iphlpapi.h>
#include <strsafe.h>
#include <WpcapNames.h>


extern BOOLEAN g_bLoopbackSupport;

ADINFO_LIST g_AdaptersInfoList = {0, 0, 0, NULL}; /// Head of the adapter information list.
HANDLE g_AdaptersInfoMutex = NULL; /// Mutex that protects the adapter information list.

#ifdef HAVE_AIRPCAP_API
extern AirpcapGetDeviceListHandler g_PAirpcapGetDeviceList;
extern AirpcapFreeDeviceListHandler g_PAirpcapFreeDeviceList;
#endif /* HAVE_AIRPCAP_API */

/*!
  \brief Adds an entry to the adapter description list.
  \return If the function succeeds, the return value is nonzero.

  Used by PacketGetAdaptersNPF(). Queries the driver to fill the PADAPTER_INFO describing the new adapter.
*/
_Success_(return != 0)
static BOOLEAN PacketAddAdapterNPF(_In_ PIP_ADAPTER_ADDRESSES pAdapterAddr,
		_Outptr_result_nullonfailure_ PADAPTER_INFO *ppAdInfo
		)
{
	LONG		Status;
	HANDLE hAdapter = INVALID_HANDLE_VALUE;
	PADAPTER_INFO	TmpAdInfo;
	PCHAR NameEnd = NULL;
	HRESULT hrStatus = S_OK;
	
	TRACE_ENTER();
	assert(pAdapterAddr != NULL);
	assert(ppAdInfo != NULL);
 	TRACE_PRINT1("Trying to add adapter %hs", pAdapterAddr->AdapterName);
	*ppAdInfo = NULL;
	
	if (strlen(pAdapterAddr->AdapterName) > ADAPTER_NAME_LENGTH) {
		TRACE_PRINT("PacketAddAdapterNPF: adapter name is too long to be stored into ADAPTER_INFO::Name, simply skip it");
		TRACE_EXIT();
		return FALSE;
	}

	TRACE_PRINT("Trying to open the NPF adapter and see if it's available...");

	// Try to Open the adapter
	hAdapter = PacketGetAdapterHandle(pAdapterAddr->AdapterName, 0);

	if(hAdapter == INVALID_HANDLE_VALUE)
	{
		TRACE_PRINT("NPF Adapter not available, do not add it to the global list");
		// We are not able to open this adapter. Skip to the next one.
		TRACE_EXIT();
		return FALSE;
	}

	CloseHandle(hAdapter);
	
	//
	// PacketOpenAdapter was succesful. Consider this a valid adapter and allocate an entry for it
	// In the adapter list
	//
	
	TmpAdInfo = (PADAPTER_INFO) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(ADAPTER_INFO));
	if (TmpAdInfo == NULL) 
	{
		TRACE_PRINT("AddAdapter: HeapAlloc Failed allocating the buffer for the AdInfo to be added to the global list. Returning.");
		TRACE_EXIT();
		return FALSE;
	}
	
	// Copy the device name
	hrStatus = StringCchCopyExA(TmpAdInfo->Name, sizeof(TmpAdInfo->Name), pAdapterAddr->AdapterName, &NameEnd, NULL, 0);
	if (FAILED(hrStatus)) {
		HeapFree(GetProcessHeap(), 0, TmpAdInfo);
		TRACE_EXIT();
		return FALSE;
	}
	TmpAdInfo->NameLen = (ULONG)(NameEnd - TmpAdInfo->Name);

	//we do not need to terminate the string TmpAdInfo->Name, since we have left a char at the end, and
	//the memory for TmpAdInfo was zeroed upon allocation

	// Copy the description
	// -1 for cchWideChar means returned length will _include_ null terminator
	Status = WideCharToMultiByte(CP_ACP, 0, pAdapterAddr->Description, -1, TmpAdInfo->Description, ADAPTER_DESC_LENGTH, NULL, NULL);
	// Conversion error? ensure it's terminated and ignore.
	if (Status <= 0) {
		TmpAdInfo->Description[ADAPTER_DESC_LENGTH] = '\0';
		Status = 0; // Length at this point includes the null terminator
	}
	TmpAdInfo->DescLen = Status - 1; // ADAPTER_INFO lengths do *not* include null terminator.

	// Update the AdaptersInfo list
	*ppAdInfo = TmpAdInfo;
	
	TRACE_PRINT("PacketAddAdapterNPF: Adapter successfully added to the list");
	TRACE_EXIT();
	return TRUE;
}

_Success_(return != 0)
static BOOLEAN PacketAddLoopbackAdapter(
		_Outptr_result_nullonfailure_ PADAPTER_INFO *ppAdInfo
		)
{
	PADAPTER_INFO TmpAdInfo = NULL;
	HRESULT hrStatus = S_OK;
	PCHAR NameEnd = NULL;

	TRACE_ENTER();
	assert(ppAdInfo != NULL);
	*ppAdInfo = NULL;

	TmpAdInfo = (PADAPTER_INFO)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(ADAPTER_INFO));
	if (TmpAdInfo == NULL)
	{
		TRACE_PRINT("AddAdapter: HeapAlloc Failed");
		return FALSE;
	}

	// Copy the device name
	hrStatus = StringCchCopyExA(TmpAdInfo->Name, sizeof(TmpAdInfo->Name), NPCAP_LOOPBACK_ADAPTER_BUILTIN, &NameEnd, NULL, 0);
	if (FAILED(hrStatus)) {
		HeapFree(GetProcessHeap(), 0, TmpAdInfo);
		TRACE_EXIT();
		return FALSE;
	}
	TmpAdInfo->NameLen = (ULONG)(NameEnd - TmpAdInfo->Name);
	hrStatus = StringCchCopyExA(TmpAdInfo->Description, sizeof(TmpAdInfo->Description), FAKE_LOOPBACK_ADAPTER_DESCRIPTION, &NameEnd, NULL, 0);
	if (FAILED(hrStatus)) {
		HeapFree(GetProcessHeap(), 0, TmpAdInfo);
		TRACE_EXIT();
		return FALSE;
	}
	TmpAdInfo->DescLen = (ULONG)(NameEnd - TmpAdInfo->Description);

	*ppAdInfo = TmpAdInfo;
	return TRUE;
}

/*!
  \brief Updates the list of the adapters querying the registry.
  \return If the function succeeds, the return value is nonzero.

  This function populates the list of adapter descriptions, retrieving the information from the registry. 
*/
_Success_(return != 0)
static BOOLEAN PacketGetAdaptersNPF()
{
	static ULONG MaxGAABufLen = ADAPTERS_ADDRESSES_INITIAL_BUFFER_SIZE;
	ULONG Iterations;
	ULONG BufLen;
	ULONG RetVal = ERROR_SUCCESS;
	PIP_ADAPTER_ADDRESSES AdBuffer, TmpAddr;
	PADAPTER_INFO TmpAdInfo = NULL;

	TRACE_ENTER();


	BufLen = MaxGAABufLen;
	AdBuffer = (PIP_ADAPTER_ADDRESSES)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, BufLen);
	if (AdBuffer == NULL)
	{
		TRACE_PRINT("PacketGetAdaptersNPF: HeapAlloc Failed");
		TRACE_EXIT();
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		return FALSE;
	}
	for (Iterations = 0; Iterations < ADAPTERS_ADDRESSES_MAX_TRIES; Iterations++)
	{

		RetVal = GetAdaptersAddresses(AF_UNSPEC, GAA_FLAG_INCLUDE_ALL_INTERFACES | // Get everything
			GAA_FLAG_SKIP_DNS_INFO | // Undocumented, reported to help avoid errors on Win10 1809
			// We don't use any of these features:
			GAA_FLAG_SKIP_DNS_SERVER |
			GAA_FLAG_SKIP_UNICAST | // We don't need any address info, just names
			GAA_FLAG_SKIP_ANYCAST |
			GAA_FLAG_SKIP_MULTICAST |
			GAA_FLAG_SKIP_FRIENDLY_NAME, NULL, AdBuffer, &BufLen);
		if (RetVal == ERROR_BUFFER_OVERFLOW)
		{
			TRACE_PRINT1("PacketGetAdaptersNPF: GetAdaptersAddresses Too small buffer (need %u)", BufLen);
			TmpAddr = (PIP_ADAPTER_ADDRESSES)HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, AdBuffer, BufLen);
			if (TmpAddr == NULL)
			{
				TRACE_PRINT("PacketGetAdaptersNPF: HeapReAlloc Failed");
				HeapFree(GetProcessHeap(), 0, AdBuffer);
				TRACE_EXIT();
				SetLastError(ERROR_NOT_ENOUGH_MEMORY);
				return FALSE;
			}
			AdBuffer = TmpAddr;
		}
		else
		{
			break;
		}
	}

	if (RetVal != ERROR_SUCCESS)
	{
		TRACE_PRINT("PacketGetAdaptersNPF: GetAdaptersAddresses Failed while retrieving the addresses");
		if (AdBuffer)
		{
			HeapFree(GetProcessHeap(), 0, AdBuffer);
		}
		TRACE_EXIT();
		SetLastError(RetVal);
		return FALSE;
	}

	// Stash the value that worked here
	InterlockedMax(&MaxGAABufLen, BufLen);

	for (TmpAddr=AdBuffer; TmpAddr != NULL; TmpAddr = TmpAddr->Next)
	{
		// If the adapter is valid, add it to the list.
		if (PacketAddAdapterNPF(TmpAddr, &TmpAdInfo)) {
			TmpAdInfo->Next = g_AdaptersInfoList.Adapters;
			g_AdaptersInfoList.Adapters = TmpAdInfo;
			// The info list lengths include the "\\Device\\NPF_" prefix and a null terminator.
			// Both of those are taken care of with this sizeof operator.
			g_AdaptersInfoList.NamesLen += TmpAdInfo->NameLen + sizeof(WINPCAP_COMPAT_DEVICE_PREFIX);
			g_AdaptersInfoList.DescsLen += TmpAdInfo->DescLen + 1;
		}
	}
	
	if (g_bLoopbackSupport && PacketAddLoopbackAdapter(&TmpAdInfo)) {
		TmpAdInfo->Next = g_AdaptersInfoList.Adapters;
		g_AdaptersInfoList.Adapters = TmpAdInfo;
		// The info list lengths include the "\\Device\\NPF_" prefix and a null terminator.
		// Both of those are taken care of with this sizeof operator.
		g_AdaptersInfoList.NamesLen += TmpAdInfo->NameLen + sizeof(WINPCAP_COMPAT_DEVICE_PREFIX);
		g_AdaptersInfoList.DescsLen += TmpAdInfo->DescLen + 1;
	}

	if (AdBuffer)
	{
		HeapFree(GetProcessHeap(), 0, AdBuffer);
	}
	TRACE_EXIT();
	return TRUE;
}

#ifdef HAVE_AIRPCAP_API
/*!
  \brief Add an airpcap adapter to the adapters info list, gathering information from the airpcap dll
  \param name Name of the adapter.
  \param description description of the adapter.
  \return If the function succeeds, the return value is nonzero.
*/
_Success_(return != 0)
static BOOLEAN PacketAddAdapterAirpcap(_In_ PCCH name, _In_ PCCH description,
		_Outptr_result_nullonfailure_ PADAPTER_INFO *ppAdInfo)
{
	PADAPTER_INFO TmpAdInfo = NULL;
	BOOLEAN Result = FALSE;
	HRESULT hrStatus = S_OK;
	PCHAR NameEnd = NULL;

	TRACE_ENTER();
	assert(ppAdInfo != NULL);
	*ppAdInfo = NULL;
	
	do
	{
		//
		// Allocate a descriptor for this adapter
		//			
		TmpAdInfo = (PADAPTER_INFO) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(ADAPTER_INFO));
		if (TmpAdInfo == NULL) 
		{
			TRACE_PRINT("PacketAddAdapterAirpcap: HeapAlloc Failed");
			break;
		}
		
		// Copy the device name and description
		hrStatus = StringCchCopyExA(TmpAdInfo->Name, sizeof(TmpAdInfo->Name), name, &NameEnd, NULL, 0);
		if (FAILED(hrStatus)) {
			break;
		}
		TmpAdInfo->NameLen = (ULONG)(NameEnd - TmpAdInfo->Name);
		
		hrStatus = StringCchCopyExA(TmpAdInfo->Description, sizeof(TmpAdInfo->Description), description, &NameEnd, NULL, 0);
		if (FAILED(hrStatus)) {
			break;
		}
		TmpAdInfo->DescLen = (ULONG)(NameEnd - TmpAdInfo->Description);
		
		Result = TRUE;
		*ppAdInfo = TmpAdInfo;
	}
	while(FALSE);

	if (!Result && TmpAdInfo) {
		HeapFree(GetProcessHeap(), 0, TmpAdInfo);
	}

	TRACE_EXIT();
	return Result;
}

/*!
  \brief Updates the list of the adapters using the airpcap dll.
  \return If the function succeeds, the return value is nonzero.

  This function populates the list of adapter descriptions, looking for AirPcap cards on the system. 
*/
_Success_(return != 0)
static BOOLEAN PacketGetAdaptersAirpcap()
{
	CHAR Ebuf[AIRPCAP_ERRBUF_SIZE];
	AirpcapDeviceDescription *Devs = NULL, *TmpDevs;
	
	TRACE_ENTER();

	if(!g_PAirpcapGetDeviceList(&Devs, Ebuf))
	{
		// No airpcap cards found on this system
		TRACE_PRINT1("No AirPcap adapters found: %s", Ebuf);
		TRACE_EXIT();
		return FALSE;
	}
	for(TmpDevs = Devs; TmpDevs != NULL; TmpDevs = TmpDevs->next)
	{
		PADAPTER_INFO TmpAdInfo = NULL;
		// If the adapter is valid, add it to the list.
		if (PacketAddAdapterAirpcap(TmpDevs->Name, TmpDevs->Description, &TmpAdInfo)) {
			TmpAdInfo->Next = g_AdaptersInfoList.Adapters;
			g_AdaptersInfoList.Adapters = TmpAdInfo;
			// The info list lengths *include* the null terminators.
			// We don't add any prefixes to Airpcap adapter names.
			g_AdaptersInfoList.NamesLen += TmpAdInfo->NameLen + 1;
			g_AdaptersInfoList.DescsLen += TmpAdInfo->DescLen + 1;
		}
	}
	
	g_PAirpcapFreeDeviceList(Devs);
	
	TRACE_EXIT();
	return TRUE;
}
#endif // HAVE_AIRPCAP_API


/*!
  \brief Populates the list of the adapters.

  This function populates the list of adapter descriptions, invoking PacketGetAdapters*()
*/
_Use_decl_annotations_
DWORD PacketPopulateAdaptersInfoList()
{
	PADAPTER_INFO TAdInfo;
	PVOID Mem2;
	DWORD dwError = ERROR_SUCCESS;
	ULONGLONG Now = GetTickCount64();

	TRACE_ENTER();

	WaitForSingleObject(g_AdaptersInfoMutex, INFINITE);

	if (Now - g_AdaptersInfoList.TicksLastUpdate < ADINFO_LIST_STALE_TICK_COUNT) {
		// Data is still valid
		ReleaseMutex(g_AdaptersInfoMutex);
		return ERROR_SUCCESS;
	}

	if(g_AdaptersInfoList.Adapters)
	{
		// Free the old list
		TAdInfo = g_AdaptersInfoList.Adapters;
		while(TAdInfo != NULL)
		{
			Mem2 = TAdInfo;
			TAdInfo = TAdInfo->Next;
			
			HeapFree(GetProcessHeap(), 0, Mem2);
		}
		
		g_AdaptersInfoList.Adapters = NULL;
	}
	// Each list is terminated with an empty string, so length of list is 1 + total length
	g_AdaptersInfoList.NamesLen = 1;
	g_AdaptersInfoList.DescsLen = 1;

	//
	// Fill the new list
	//
	if(!PacketGetAdaptersNPF())
	{
		dwError = GetLastError();
		// No info about adapters in the registry. (NDIS adapters, i.e. exported by NPF)
		TRACE_PRINT("PacketPopulateAdaptersInfoList: registry scan for adapters failed!");
	}

#ifdef HAVE_AIRPCAP_API
	if(g_PAirpcapGetDeviceList)	// Ensure that the airpcap dll is present
	{
		if(!PacketGetAdaptersAirpcap())
		{
			if (dwError == ERROR_SUCCESS) {
				dwError = GetLastError();
			}
			TRACE_PRINT("PacketPopulateAdaptersInfoList: lookup of airpcap adapters failed!");
		}
	}
#endif // HAVE_AIRPCAP_API

	if (g_AdaptersInfoList.Adapters == NULL && dwError == ERROR_SUCCESS) {
		dwError = ERROR_NO_MORE_ITEMS;
	}

	ReleaseMutex(g_AdaptersInfoMutex);
	TRACE_EXIT();
	return dwError;
}

```

`packetWin7/Dll/Packet.def`:

```def
LIBRARY packet

EXPORTS
		PacketLibraryVersion
		PacketGetVersion
		PacketGetDriverVersion
		PacketGetDriverName
		PacketOpenAdapter
		PacketSendPacket
		PacketSendPackets
		PacketAllocatePacket
		PacketInitPacket
		PacketFreePacket
		PacketReceivePacket
		PacketCloseAdapter
		PacketSetHwFilter
		PacketGetAdapterNames
		PacketRequest
		PacketSetBuff
		PacketSetBpf
		PacketSetSnapLen
		PacketGetStats
		PacketGetStatsEx
		PacketGetNetType
		PacketIsLoopbackAdapter
		PacketIsMonitorModeSupported
		PacketSetMonitorMode
		PacketGetMonitorMode
		PacketSetReadTimeout
		PacketSetMode
		PacketSetNumWrites
		PacketGetNetInfoEx
		PacketSetMinToCopy
		PacketGetReadEvent
		PacketStopDriver
		PacketSetDumpName
		PacketSetDumpLimits
		PacketIsDumpEnded
		PacketSetLoopbackBehavior
		PacketSetTimestampMode
		PacketGetTimestampModes
		PacketGetInfo
		PacketGetAirPcapHandle

```

`packetWin7/Dll/Packet32-Int.h`:

```h
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
/*
 * Copyright (c) 2006 - 2010
 * CACE Technologies Inc., Davis (CA)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the company (CACE Technologies Inc.) nor the 
 * names of its contributors may be used to endorse or promote products 
 * derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

//
// Internal constants
//
#define PACKET_DEPRECATED_INTERNAL_STRUCT_DEFINITIONS_OK
#include <Packet32.h>
#include "debug.h"

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <ntddndis.h>

#define ADAPTERS_ADDRESSES_INITIAL_BUFFER_SIZE 15000
#define ADAPTERS_ADDRESSES_MAX_TRIES 3

#define DEVICE_PREFIX "\\Device\\"
#define WINPCAP_COMPAT_DEVICE_PREFIX DEVICE_PREFIX "NPF_"
#define NPCAP_LOOPBACK_ADAPTER_BUILTIN "Loopback"

/*!
  \brief Contains comprehensive information about a network adapter.

  This structure is filled with all the accessory information that the user can need about an adapter installed
  on his system.
*/
typedef struct _ADAPTER_INFO  
{
	struct _ADAPTER_INFO *Next;				///< Pointer to the next adapter in the list.
	CHAR Name[ADAPTER_NAME_LENGTH + 1];		///< Name of the device representing the adapter.
	ULONG NameLen; // length of name
	CHAR Description[ADAPTER_DESC_LENGTH + 1];	///< Human understandable description of the adapter
	ULONG DescLen; // length of description
} ADAPTER_INFO, *PADAPTER_INFO;

typedef struct ADAPTERS_INFO_LIST
{
	ULONG NamesLen; // The length of all names and null terminators
	ULONG DescsLen; // The length of all descriptions and null terminators
	ULONGLONG TicksLastUpdate; // The tick count when the list was last updated.
	PADAPTER_INFO Adapters;
} ADINFO_LIST, *PADINFO_LIST;

// After this many ms, regen the list of adapters
#define ADINFO_LIST_STALE_TICK_COUNT 1000

/* Npcap's internal representation of an adapter object. This allows us to
 * extend the adapter struct without breaking the public API, since the WinPcap
 * API we inherited foolishly made the ADAPTER type a publicly-defined struct.
 */
typedef struct _ADAPTER_PRIV
{
	ADAPTER ad;
	ULONG ulConfig;
	int minToCopy;
	DWORD dwReadLength;
	int reduceCounter;
} ADAPTER_PRIV, *PADAPTER_PRIV;
#define LPAD_TO_ADAPTER_PRIV(_LPAD) \
	CONTAINING_RECORD(_LPAD, ADAPTER_PRIV, ad)

//
// Internal functions
//
_Success_(return == ERROR_SUCCESS)
DWORD PacketPopulateAdaptersInfoList();

#define NPF_OPEN_FLAG_WIFI 0x1
_Success_(return != INVALID_HANDLE_VALUE)
_Must_inspect_result_
HANDLE PacketGetAdapterHandle(_In_ PCCH AdapterNameA, _In_ ULONG NpfOpenFlags);

static inline VOID InterlockedMax(PULONG Location, ULONG NewValue)
{
	ULONG prev;
	// If NewValue is bigger, safely exchange value only if the value hasn't changed.
	// If it has changed, check it again.
	do {
		prev = *Location;
		if (prev >= NewValue)
			return;
	} while (InterlockedCompareExchange((PLONG)Location, NewValue, prev) != (LONG)prev); 
}

// 
// Definitions and functions specific to the CACETech airpcap API
//
#ifdef HAVE_AIRPCAP_API
typedef PCHAR (*AirpcapGetLastErrorHandler)(PAirpcapHandle Handle);
typedef BOOL (*AirpcapGetDeviceListHandler)(AirpcapDeviceDescription **AllDevsP, PCHAR Ebuf);		///< prototype used to dynamically load the dll
typedef VOID (*AirpcapFreeDeviceListHandler)(AirpcapDeviceDescription *AllDevsP);					///< prototype used to dynamically load the dll
typedef PAirpcapHandle (*AirpcapOpenHandler)(LPCSTR DeviceName, PCHAR Ebuf);							///< prototype used to dynamically load the dll	
typedef VOID (*AirpcapCloseHandler)(PAirpcapHandle Handle);											///< prototype used to dynamically load the dll
typedef BOOL (*AirpcapGetLinkTypeHandler)(PAirpcapHandle Handle, AirpcapLinkType* LinkLayer);		///< prototype used to dynamically load the dll
typedef BOOL (*AirpcapSetKernelBufferHandler)(PAirpcapHandle Handle, ULONG Size);					///< prototype used to dynamically load the dll
typedef BOOL (*AirpcapSetFilterHandler)(PAirpcapHandle Handle, void *Instructions, UINT Len);		///< prototype used to dynamically load the dll
typedef BOOL (*AirpcapSetMinToCopyHandler)(PAirpcapHandle Handle, ULONG Bytes);						///< prototype used to dynamically load the dll
typedef BOOL (*AirpcapGetReadEventHandler)(PAirpcapHandle Handle, HANDLE* PReadEvent);				///< prototype used to dynamically load the dll
typedef BOOL (*AirpcapReadHandler)(PAirpcapHandle Handle, PUCHAR BufferToFill, ULONG BufSize, PULONG ReceievedBytes);	///< prototype used to dynamically load the dll
typedef BOOL (*AirpcapGetStatsHandler)(PAirpcapHandle Handle, AirpcapStats *Stats);					///< prototype used to dynamically load the dll
typedef BOOL (*AirpcapWriteHandler)(PAirpcapHandle Handle, PCHAR TxPacket, ULONG PacketLen);		///< prototype used to dynamically load the dll

#endif // HAVE_AIRPCAP_API

```

`packetWin7/Dll/Packet32.cpp`:

```cpp
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
/*
 * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)
 * Copyright (c) 2005 - 2010 CACE Technologies, Davis (California)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Politecnico di Torino, CACE Technologies 
 * nor the names of its contributors may be used to endorse or promote 
 * products derived from this software without specific prior written 
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#define UNICODE 1

#include "Packet32-Int.h"
#include <tchar.h>
#include <strsafe.h>
#include <string>
#include <ntddndis.h>

#include "../npf/npf/ioctls.h"
#include "../../version.h"
#include <ws2ipdef.h>
#include <winternl.h>
#include <ip2string.h>

#include <map>
using namespace std;


#define BUFSIZE 512
#define MAX_TRY_TIME 50
#define SLEEP_TIME 50


HANDLE g_hNpcapHelperPipe				=	INVALID_HANDLE_VALUE;	// Handle for NpcapHelper named pipe.
HANDLE g_hDllHandle						=	NULL;					// The handle to this DLL.


CHAR g_strLoopbackAdapterName[ADAPTER_NAME_LENGTH] = "\0"; // The name of legacy "Npcap Loopback Adapter" from registry.
BOOLEAN g_bLoopbackSupport = TRUE;

map<string, int> g_nbAdapterMonitorModes;							// The states for all the wireless adapters that show whether it is in the monitor mode.

#define SERVICES_REG_KEY "SYSTEM\\CurrentControlSet\\Services\\"
#define NPCAP_SERVICE_REGISTRY_KEY SERVICES_REG_KEY NPF_DRIVER_NAME

#ifdef HAVE_AIRPCAP_API
#pragma message ("Compiling Packet.dll with support for AirPcap")
#endif

#if defined(HAVE_AIRPCAP_API)
#define LOAD_OPTIONAL_LIBRARIES
VOID PacketLoadLibrariesDynamically();
#endif

#ifndef UNUSED
#define UNUSED(_x) (_x)
#endif


#include <iphlpapi.h>

#include <WpcapNames.h>

/* Driver versions before 1.60 require a different OID buffer length
 * calculation. This is only relevant for /prior_driver=yes, which only affects
 * versions of Windows older than Windows 10. */
static bool bOidLenCompat = false;
#define PACKET_COMPAT_OID_LEN_DIFF (sizeof(PACKET_OID_DATA) - 1 - PACKET_OID_DATA_LENGTH(0))
#define PACKET_COMPAT_OID_LEN(_L) ( PACKET_OID_DATA_LENGTH(_L) + ( \
			bOidLenCompat ? PACKET_COMPAT_OID_LEN_DIFF : 0))

//
// Current packet.dll version. It can be retrieved directly or through the PacketGetVersion() function.
//
__declspec(dllexport) const char PacketLibraryVersion[] = WINPCAP_VER_STRING; 

//
// Current driver version. It can be retrieved directly or through the PacketGetDriverVersion() function.
//
static char PacketDriverVersion[64]; 

//
// Current driver name ("NPF" or "NPCAP"). It can be retrieved directly or through the PacketGetDriverName() function.
//
static const char PacketDriverName[] = NPF_DRIVER_NAME;


//
// Global adapters list related variables
//
extern ADINFO_LIST g_AdaptersInfoList;
extern HANDLE g_AdaptersInfoMutex;

#ifdef LOAD_OPTIONAL_LIBRARIES
//
// Dynamic dependencies variables and declarations
//
volatile LONG g_DynamicLibrariesLoaded = 0;
HANDLE g_DynamicLibrariesMutex;
#endif

#ifdef HAVE_AIRPCAP_API
// We dynamically load the Airpcap library in order link it only when it's present on the system
AirpcapGetLastErrorHandler g_PAirpcapGetLastError;
AirpcapGetDeviceListHandler g_PAirpcapGetDeviceList;
AirpcapFreeDeviceListHandler g_PAirpcapFreeDeviceList;
AirpcapOpenHandler g_PAirpcapOpen;
AirpcapCloseHandler g_PAirpcapClose;
AirpcapGetLinkTypeHandler g_PAirpcapGetLinkType;
AirpcapSetKernelBufferHandler g_PAirpcapSetKernelBuffer;
AirpcapSetFilterHandler g_PAirpcapSetFilter;
AirpcapSetMinToCopyHandler g_PAirpcapSetMinToCopy;
AirpcapGetReadEventHandler g_PAirpcapGetReadEvent;
AirpcapReadHandler g_PAirpcapRead;
AirpcapGetStatsHandler g_PAirpcapGetStats;
AirpcapWriteHandler g_PAirpcapWrite;
#endif // HAVE_AIRPCAP_API

//
// Additions for WinPcap OEM
//
#ifdef WPCAP_OEM_UNLOAD_H
typedef BOOL (*WoemLeaveDllHandler)(void);
WoemLeaveDllHandler	g_WoemLeaveDllH = NULL;

__declspec (dllexport) VOID PacketRegWoemLeaveHandler(PVOID Handler)
{
	g_WoemLeaveDllH = Handler;
}
#endif // WPCAP_OEM_UNLOAD_H

//---------------------------------------------------------------------------

_Success_(return != 0)
static BOOL PacketGetFileVersion(_In_ LPCTSTR FileName, _Out_writes_(VersionBuffLen) PCHAR VersionBuff, _In_ UINT VersionBuffLen);

_Success_(return == ERROR_SUCCESS)
static DWORD _PacketGetInfoPriv(
		_In_ HANDLE hFile, _In_ ULONG ulID, _Out_ PULONG ulInfo);

static BOOL NpcapCreatePipe(const char *pipeName, HANDLE moduleName)
{
	const int pid = GetCurrentProcessId();
	char params[BUFSIZE];
	SHELLEXECUTEINFOA shExInfo = {};
	DWORD nResult;
	char lpFilename[BUFSIZE];
	char szDrive[BUFSIZE];
	char szDir[BUFSIZE];

	TRACE_ENTER();

	// Get Path to This Module
	nResult = GetModuleFileNameA((HMODULE) moduleName, lpFilename, BUFSIZE);
	if (nResult == 0)
	{
		nResult = GetLastError();
		TRACE_PRINT1("GetModuleFileNameA failed. GLE=%d\n", nResult);
		TRACE_EXIT();
		SetLastError(nResult);
		return FALSE;
	}
	_splitpath_s(lpFilename, szDrive, BUFSIZE, szDir, BUFSIZE, NULL, 0, NULL, 0);
	_makepath_s(lpFilename, BUFSIZE, szDrive, szDir, "NpcapHelper", ".exe");

	nResult = GetFileAttributesA(lpFilename);
	if (nResult == INVALID_FILE_ATTRIBUTES)
	{
		nResult = GetLastError();
		TRACE_PRINT2("GetFileAttributesA(%s) failed: %d", lpFilename, nResult);
		TRACE_EXIT();
		SetLastError(nResult);
		return FALSE;
	}
	if (nResult & FILE_ATTRIBUTE_DIRECTORY)
	{
		TRACE_PRINT1("%s is a directory.", lpFilename);
		TRACE_EXIT();
		SetLastError(ERROR_DIRECTORY_NOT_SUPPORTED);
		return FALSE;
	}

	sprintf_s(params, BUFSIZE, "%s %d", pipeName, pid);

	shExInfo.cbSize = sizeof(shExInfo);
	shExInfo.fMask = SEE_MASK_NOCLOSEPROCESS;
	shExInfo.hwnd = 0;
	shExInfo.lpVerb = "runas";				// Operation to perform
	shExInfo.lpFile = lpFilename;			// Application to start
	shExInfo.lpParameters = params;			// Additional parameters
	shExInfo.lpDirectory = 0;
	shExInfo.nShow = SW_SHOW;
	shExInfo.hInstApp = 0;

	if (!ShellExecuteExA(&shExInfo))
	{
		const DWORD dwError = GetLastError();
		if (dwError == ERROR_CANCELLED)
		{
			// The user refused to allow privileges elevation.
			// Do nothing ...
		}
		TRACE_EXIT();
		SetLastError(dwError);
		return FALSE;
	}
	else
	{
		TRACE_EXIT();
		if (shExInfo.hProcess)
			CloseHandle(shExInfo.hProcess);
		return TRUE;
	}
}

static HANDLE NpcapConnect(const char *pipeName)
{
	HANDLE hPipe = INVALID_HANDLE_VALUE;
	int tryTime = 0;
	char lpszPipename[BUFSIZE];
	DWORD err = ERROR_SUCCESS;

	TRACE_ENTER();

	sprintf_s(lpszPipename, BUFSIZE, "\\\\.\\pipe\\%s", pipeName);

	// Try to open a named pipe; wait for it, if necessary.
	while (tryTime < MAX_TRY_TIME)
	{
		hPipe = CreateFileA(
			lpszPipename,   // pipe name
			GENERIC_READ |  // read and write access
			GENERIC_WRITE,
			0,              // no sharing
			NULL,           // default security attributes
			OPEN_EXISTING,  // opens existing pipe
			0,              // default attributes
			NULL);          // no template file

		// Break if the pipe handle is valid.

		if (hPipe != INVALID_HANDLE_VALUE)
		{
			err = ERROR_SUCCESS;
			break;
		}
		else
		{
			err = GetLastError();
			tryTime++;
			Sleep(SLEEP_TIME);
		}
	}

	TRACE_EXIT();
	SetLastError(err);
	return hPipe;
}

static HANDLE NpcapRequestHandle(const char *sMsg, DWORD *pdwError)
{
	HANDLE hd = INVALID_HANDLE_VALUE;
	LPCSTR lpvMessage = sMsg;
	char  chBuf[BUFSIZE] = { 0 };
	BOOL   fSuccess = FALSE;
	DWORD  cbRead, cbToWrite, cbWritten, dwMode;
	HANDLE hPipe = g_hNpcapHelperPipe;

	TRACE_ENTER();

	if (hPipe == INVALID_HANDLE_VALUE)
	{
		*pdwError = ERROR_PIPE_NOT_CONNECTED;
		goto Exit;
	}

	// The pipe connected; change to message-read mode.
	dwMode = PIPE_READMODE_MESSAGE;
	fSuccess = SetNamedPipeHandleState(
		hPipe,    // pipe handle
		&dwMode,  // new pipe mode
		NULL,     // don't set maximum bytes
		NULL);    // don't set maximum time
	if (!fSuccess)
	{
		*pdwError = GetLastError();
		TRACE_PRINT1("SetNamedPipeHandleState failed. GLE=%d\n", *pdwError);
		goto Exit;
	}

	// Send a message to the pipe server.

	cbToWrite = (DWORD) (strlen(lpvMessage) + 1)*sizeof(char);
	TRACE_PRINT2("\nSending %d byte message: \"%hs\"\n", cbToWrite, lpvMessage);

	fSuccess = WriteFile(
		hPipe,                  // pipe handle
		lpvMessage,             // message
		cbToWrite,              // message length
		&cbWritten,             // bytes written
		NULL);                  // not overlapped

	if (!fSuccess)
	{
		*pdwError = GetLastError();
		TRACE_PRINT1("WriteFile to pipe failed. GLE=%d\n", *pdwError);
		goto Exit;
	}

	// Read from the pipe.

	fSuccess = ReadFile(
			hPipe,    // pipe handle
			chBuf,    // buffer to receive reply
			BUFSIZE*sizeof(char),  // size of buffer
			&cbRead,  // number of bytes read
			NULL);    // not overlapped

	if (!fSuccess)
	{
		*pdwError = GetLastError();
		TRACE_PRINT1("ReadFile from pipe failed. GLE=%d\n", *pdwError);
		goto Exit;
	}

	if (cbRead == 0)
	{
		*pdwError = ERROR_NO_DATA;
		goto Exit;
	}

	int nFields = _snscanf_s(chBuf, cbRead, "%p,%lu", &hd, pdwError);
	if (nFields != 2)
	{
		*pdwError = ERROR_OPEN_FAILED;
		hd = INVALID_HANDLE_VALUE;
		goto Exit;
	}
	TRACE_PRINT1("Received Driver Handle: %0p\n", hd);
Exit:
	TRACE_EXIT();
	return hd;
}

static void NpcapGetLoopbackInterfaceName()
{
	TRACE_ENTER();

	HKEY hKey;
	DWORD type;
	char buffer[BUFSIZE];
	DWORD size = sizeof(buffer);
	if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, NPCAP_SERVICE_REGISTRY_KEY "\\Parameters", 0, KEY_READ, &hKey) == ERROR_SUCCESS)
	{
		if (RegQueryValueExA(hKey, "LoopbackSupport", 0, &type,  (LPBYTE)buffer, &size) == ERROR_SUCCESS && type == REG_DWORD)
		{
			g_bLoopbackSupport = (0 != *((DWORD *) buffer));
		}
		size = sizeof(buffer);
		// if we support loopback
		if (g_bLoopbackSupport
				// and there's a loopback adapter device name recorded
				&& RegQueryValueExA(hKey, "LoopbackAdapter", 0, &type,  (LPBYTE)buffer, &size) == ERROR_SUCCESS
				// and the type matches and it's an appropriate size
				&& type == REG_SZ && size < ADAPTER_NAME_LENGTH + sizeof(DEVICE_PREFIX) && size > sizeof(DEVICE_PREFIX))
		{
			// Try to copy the adapter ID (skip the "\\Device\\" prefix)
			if (FAILED(StringCchCopyA(g_strLoopbackAdapterName, sizeof(g_strLoopbackAdapterName), buffer + sizeof(DEVICE_PREFIX) - 1))) {
				// Failed? Null it out and ignore.
				g_strLoopbackAdapterName[0] = '\0';
			}
		}

		RegCloseKey(hKey);
	}

	TRACE_EXIT();
}

static BOOL NpcapIsAdminOnlyMode()
{
	TRACE_ENTER();

	static BOOLEAN cached = FALSE;
	static DWORD dwAdminOnlyMode = 0;
	DWORD size = sizeof(DWORD);
	LSTATUS status = ERROR_SUCCESS;

	if (!cached) {
		status = RegGetValue(HKEY_LOCAL_MACHINE, _T(NPCAP_SERVICE_REGISTRY_KEY "\\Parameters"), _T("AdminOnly"), RRF_RT_REG_DWORD, NULL, &dwAdminOnlyMode, &size);
		if (status != ERROR_SUCCESS) {
			TRACE_PRINT1("RegGetValue(Services\\Npcap\\Parameters\\AdminOnly) failed: %#x\n", status);
		}
		cached = TRUE;
	}
	TRACE_EXIT();
	return (dwAdminOnlyMode != 0);
}

static BOOL NpcapIsRunByAdmin()
{
	static BOOLEAN cached = FALSE;
	BOOL bIsRunAsAdmin = FALSE;
	DWORD dwError = ERROR_SUCCESS;
	PSID pAdministratorsGroup = NULL;
	// Allocate and initialize a SID of the administrators group.
	SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

	TRACE_ENTER();

	if (cached) {
		return bIsRunAsAdmin;
	}

	if (!AllocateAndInitializeSid(
		&NtAuthority,
		2,
		SECURITY_BUILTIN_DOMAIN_RID,
		DOMAIN_ALIAS_RID_ADMINS,
		0, 0, 0, 0, 0, 0,
		&pAdministratorsGroup))
	{
		dwError = GetLastError();
		goto Cleanup;
	}

	// Determine whether the SID of administrators group is enabled in
	// the primary access token of the process.
	if (!CheckTokenMembership(NULL, pAdministratorsGroup, &bIsRunAsAdmin))
	{
		dwError = GetLastError();
		goto Cleanup;
	}
	cached = TRUE;

Cleanup:
	// Centralized cleanup for all allocated resources.
	if (pAdministratorsGroup)
	{
		FreeSid(pAdministratorsGroup);
		pAdministratorsGroup = NULL;
	}

	// Throw the error if something failed in the function.
	if (ERROR_SUCCESS != dwError)
	{
		TRACE_PRINT1("IsProcessRunningAsAdminMode failed. GLE=%d\n", dwError);
	}

	TRACE_PRINT1("IsProcessRunningAsAdminMode result: %hs\n", bIsRunAsAdmin ? "yes" : "no");
	TRACE_EXIT();
	SetLastError(dwError);
	return bIsRunAsAdmin;
}

static void NpcapStartHelper()
{
	TRACE_ENTER();

	// Only run this function once.
	// This may be a mistake; what if the helper gets killed?
	static BOOL NpcapHelperTried = FALSE;

	if (NpcapHelperTried)
	{
		TRACE_PRINT("NpcapHelper already tried\n");
		TRACE_EXIT();
		return;
	}

	// Don't try again.
	NpcapHelperTried = TRUE;

	// If it's already started, use that instead
	if (g_hNpcapHelperPipe != INVALID_HANDLE_VALUE)
	{
		TRACE_PRINT("NpcapHelper already started\n");
		TRACE_EXIT();
		return;
	}


	// Check if this process is running in Administrator mode.
	if (NpcapIsRunByAdmin())
	{
		TRACE_PRINT("Already running as admin.\n");
		TRACE_EXIT();
		return;
	}

	char pipeName[BUFSIZE];
	const int pid = GetCurrentProcessId();
	sprintf_s(pipeName, BUFSIZE, "npcap-%d", pid);
	if (NpcapCreatePipe(pipeName, g_hDllHandle))
	{
		g_hNpcapHelperPipe = NpcapConnect(pipeName);
		if (g_hNpcapHelperPipe == INVALID_HANDLE_VALUE)
		{
			TRACE_PRINT("Failed to connect to NpcapHelper.\n");
		}
	}
	else
	{
		TRACE_PRINT("NpcapCreatePipe failed.\n");
	}

	TRACE_EXIT();
}

static void NpcapStopHelper()
{
	TRACE_ENTER();

	if (g_hNpcapHelperPipe != INVALID_HANDLE_VALUE)
	{
		CloseHandle(g_hNpcapHelperPipe);
		g_hNpcapHelperPipe = INVALID_HANDLE_VALUE;
	}

	TRACE_EXIT();
}

/* Copies the adapter ID (GUID, or whatever comes after "NPF_" in the name) to a new string.
 * Canonicalizes capitalization for the monitor-mode map (not needed otherwise).
 * Returned string is a dup and must be freed.
 * NpfOpenFlags will be set to an appropriate value based on any tags found (e.g. "WIFI_")
 */
_Success_(return != NULL)
_Must_inspect_result_
static PCHAR NpcapGetAdapterID(_In_ LPCSTR AdapterName, _Out_opt_ PULONG pNpfOpenFlags)
{
	PCHAR outstr = NULL;
	const char *src = NULL;
	ULONG NpfOpenFlags = 0;

	if (0 == _strnicmp(AdapterName, WINPCAP_COMPAT_DEVICE_PREFIX, sizeof(WINPCAP_COMPAT_DEVICE_PREFIX) - 1)) {
		src = AdapterName + sizeof(WINPCAP_COMPAT_DEVICE_PREFIX) - 1;
	}
	else if (0 == _strnicmp(AdapterName, NPF_DRIVER_COMPLETE_DEVICE_PREFIX, sizeof(NPF_DRIVER_COMPLETE_DEVICE_PREFIX) - 1)) {
		src = AdapterName + sizeof(NPF_DRIVER_COMPLETE_DEVICE_PREFIX) - 1;
	}
	else {
		// Not expected format
		SetLastError(ERROR_INVALID_NAME);
		return NULL;
	}

	// Look for tags (case sensitive)
	// First the most common case: no tag or it's loopback
	if (src[0] == '{' || 0 == _stricmp(src, NPCAP_LOOPBACK_ADAPTER_BUILTIN)) {
		;// Do nothing
	}
	// WIFI_ tag check
	else if (0 == strncmp(src, NPF_DEVICE_NAMES_TAG_WIFI, sizeof(NPF_DEVICE_NAMES_TAG_WIFI) - 1)) {
		src += sizeof(NPF_DEVICE_NAMES_TAG_WIFI) - 1;
		NpfOpenFlags |= NPF_OPEN_FLAG_WIFI;
	}

	size_t NameLen = strnlen(AdapterName, ADAPTER_NAME_LENGTH);
	if (NameLen >= ADAPTER_NAME_LENGTH) {
		TRACE_PRINT("Unterminated or too-long adapter name");
		SetLastError(ERROR_INVALID_NAME);
		return NULL;
	}
	outstr = (PCHAR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, NameLen + 1);
	if (!outstr) {
		TRACE_PRINT("HeapAlloc failed");
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		return NULL;
	}

	for (size_t i=0; i <= NameLen && src[i] != '\0'; i++) {
		outstr[i] = (char) toupper(src[i]);
	}

	if (pNpfOpenFlags != NULL) {
		*pNpfOpenFlags = NpfOpenFlags;
	}
	return outstr;
}

/*! 
  \brief The main dll function.
*/
struct PacketGlobalSettings {
	DWORD dwPageSize;
	BOOLEAN bInitialized:1;
	BOOLEAN bExperimentalOptimization:1;
	PacketGlobalSettings() :
		dwPageSize(0),
		bInitialized(0),
		bExperimentalOptimization(0)
	{};
};
static PacketGlobalSettings g_Settings;

BOOL APIENTRY DllMain(HANDLE DllHandle, DWORD Reason, LPVOID lpReserved)
{
	TRACE_ENTER();

	SYSTEM_INFO si = { 0 };
	PADAPTER_INFO NewAdInfo;
	g_hDllHandle = DllHandle;

    switch(Reason)
    {
	case DLL_PROCESS_ATTACH:

		TRACE_PRINT("************Packet32: DllMain************");
		if (!g_Settings.bInitialized) {
			GetNativeSystemInfo(&si);
			g_Settings.dwPageSize = si.dwPageSize;
			if (0 != GetEnvironmentVariable(_T("PACKET_EXPERIMENTAL_OPTIMIZATION"), NULL, 0)) {
				g_Settings.bExperimentalOptimization = TRUE;
			}
			g_Settings.bInitialized = TRUE;
		}


		// Create the mutex that will protect the adapter information list
		g_AdaptersInfoMutex = CreateMutex(NULL, FALSE, NULL);
		
#ifdef LOAD_OPTIONAL_LIBRARIES
		// Create the mutex that will protect the PacketLoadLibrariesDynamically() function		
		g_DynamicLibrariesMutex = CreateMutex(NULL, FALSE, NULL);
#endif
		//
		// Retrieve NPF.sys version information from the file
		// With any luck, this will be overwritten when the user calls
		// PacketGetDriverVersion(), but we can't call
		// _PacketGetInfoPriv() here in DllMain because it *may* call
		// ShellExecuteExA() due to admin-only mode, causing a deadlock.
		//
		// TODO fixme. Those hardcoded strings are terrible...
		PacketGetFileVersion(TEXT("drivers\\") TEXT(NPF_DRIVER_NAME) TEXT(".sys"), PacketDriverVersion, sizeof(PacketDriverVersion));
		// Check if older than 1.60
		if (PacketDriverVersion[0] == '1' && PacketDriverVersion[1] == '.'
			       	&& PacketDriverVersion[2] < '6') {
			bOidLenCompat = true;
		}

		// Get the name for "Npcap Loopback Adapter"
		NpcapGetLoopbackInterfaceName();
		
		break;
		
	case DLL_PROCESS_DETACH:

		CloseHandle(g_AdaptersInfoMutex);
		
		/* Per https://learn.microsoft.com/en-us/windows/win32/dlls/dllmain
		 * "If the process is terminating (the lpvReserved parameter is
		 * non-NULL), all threads in the process except the current
		 * thread have exited already which might leave some process
		 * resources such as heaps in an inconsistent state. In this
		 * case, the DLL should allow the operating system to reclaim
		 * the memory."
		 */
		if (lpReserved == NULL) {
			while(g_AdaptersInfoList.Adapters != NULL)
			{
				NewAdInfo = g_AdaptersInfoList.Adapters->Next;

				HeapFree(GetProcessHeap(), 0, g_AdaptersInfoList.Adapters);

				g_AdaptersInfoList.Adapters = NewAdInfo;
			}
		}

		// NpcapHelper De-Initialization.
		NpcapStopHelper();

#ifdef WPCAP_OEM_UNLOAD_H 
		if(g_WoemLeaveDllH)
		{
			g_WoemLeaveDllH();
		}
#endif // WPCAP_OEM_UNLOAD_H

		break;
		
	default:
		break;
    }
	
	TRACE_EXIT();
    return TRUE;
}


#ifdef LOAD_OPTIONAL_LIBRARIES
//
// This wrapper around loadlibrary appends the system folder (usually c:\windows\system32)
// to the relative path of the DLL, so that the DLL is always loaded from an absolute path
// (It's no longer possible to load airpcap.dll from the application folder).
// This solves the DLL Hijacking issue discovered in August 2010
// http://blog.metasploit.com/2010/08/exploiting-dll-hijacking-flaws.html
//
static HMODULE LoadLibrarySafe(LPCTSTR lpFileName)
{
  TRACE_ENTER();

  TCHAR path[MAX_PATH+1] = { 0 };
  TCHAR fullFileName[MAX_PATH+1];
  UINT res;
  HMODULE hModule = NULL;
  DWORD err = ERROR_SUCCESS;
  do
  {
	res = GetSystemDirectory(path, MAX_PATH);

	if (res == 0)
	{
		//
		// some bad failure occurred;
		//
		err = GetLastError();
		break;
	}
	
	if (res > MAX_PATH)
	{
		//
		// the buffer was not big enough
		//
		err = (ERROR_INSUFFICIENT_BUFFER);
		break;
	}

	if (_tcslen(lpFileName) + 1 + res + 1 < MAX_PATH)
	{
		memcpy(fullFileName, path, res * sizeof(TCHAR));
		fullFileName[res] = _T('\\');
		memcpy(&fullFileName[res + 1], lpFileName, (_tcslen(lpFileName) + 1) * sizeof(TCHAR));

		hModule = LoadLibrary(fullFileName);
		err = GetLastError();
	}
	else
	{
		err = (ERROR_INSUFFICIENT_BUFFER);
	}

  }while(FALSE);

  TRACE_EXIT();
  SetLastError(err);
  return hModule;
}

/*! 
  \brief This function is used to dynamically load some of the libraries winpcap depends on, 
   and that are not guaranteed to be in the system
  \param cp A string containing the address.
  \return the converted 32-bit numeric address.

   Doesn't check to make sure the address is valid.
*/
VOID PacketLoadLibrariesDynamically()
{
#ifdef HAVE_AIRPCAP_API
	HMODULE AirpcapLib;
#endif // HAVE_AIRPCAP_API	

	TRACE_ENTER();

	//
	// Acquire the global mutex, so we wait until other threads are done
	//
	WaitForSingleObject(g_DynamicLibrariesMutex, INFINITE);

	//
	// Only the first thread should do the initialization
	//
	g_DynamicLibrariesLoaded++;

	if(g_DynamicLibrariesLoaded != 1)
	{
		ReleaseMutex(g_DynamicLibrariesMutex);
		TRACE_EXIT();
		return;
	}

#ifdef HAVE_AIRPCAP_API
	/* We dinamically load the airpcap library in order link it only when it's present on the system */
	if((AirpcapLib =  LoadLibrarySafe(TEXT("airpcap.dll"))) == NULL)
	{
		// Report the error but go on
		TRACE_PRINT("AirPcap library not found on this system");
	}
	else
	{
		//
		// Find the exports
		//
		g_PAirpcapGetLastError = (AirpcapGetLastErrorHandler) GetProcAddress(AirpcapLib, "AirpcapGetLastError");
		g_PAirpcapGetDeviceList = (AirpcapGetDeviceListHandler) GetProcAddress(AirpcapLib, "AirpcapGetDeviceList");
		g_PAirpcapFreeDeviceList = (AirpcapFreeDeviceListHandler) GetProcAddress(AirpcapLib, "AirpcapFreeDeviceList");
		g_PAirpcapOpen = (AirpcapOpenHandler) GetProcAddress(AirpcapLib, "AirpcapOpen");
		g_PAirpcapClose = (AirpcapCloseHandler) GetProcAddress(AirpcapLib, "AirpcapClose");
		g_PAirpcapGetLinkType = (AirpcapGetLinkTypeHandler) GetProcAddress(AirpcapLib, "AirpcapGetLinkType");
		g_PAirpcapSetKernelBuffer = (AirpcapSetKernelBufferHandler) GetProcAddress(AirpcapLib, "AirpcapSetKernelBuffer");
		g_PAirpcapSetFilter = (AirpcapSetFilterHandler) GetProcAddress(AirpcapLib, "AirpcapSetFilter");
		g_PAirpcapSetMinToCopy = (AirpcapSetMinToCopyHandler) GetProcAddress(AirpcapLib, "AirpcapSetMinToCopy");
		g_PAirpcapGetReadEvent = (AirpcapGetReadEventHandler) GetProcAddress(AirpcapLib, "AirpcapGetReadEvent");
		g_PAirpcapRead = (AirpcapReadHandler) GetProcAddress(AirpcapLib, "AirpcapRead");
		g_PAirpcapGetStats = (AirpcapGetStatsHandler) GetProcAddress(AirpcapLib, "AirpcapGetStats");
		g_PAirpcapWrite = (AirpcapWriteHandler) GetProcAddress(AirpcapLib, "AirpcapWrite");

		//
		// Make sure that we found everything
		//
		if(g_PAirpcapGetLastError == NULL ||
			g_PAirpcapGetDeviceList == NULL ||
			g_PAirpcapFreeDeviceList == NULL ||
			g_PAirpcapClose == NULL ||
			g_PAirpcapGetLinkType == NULL ||
			g_PAirpcapSetKernelBuffer == NULL ||
			g_PAirpcapSetFilter == NULL ||
			g_PAirpcapSetMinToCopy == NULL ||
			g_PAirpcapGetReadEvent == NULL ||
			g_PAirpcapRead == NULL ||
			g_PAirpcapGetStats == NULL)
		{
			// No, something missing. A NULL g_PAirpcapOpen will disable airpcap adapters check
			g_PAirpcapOpen = NULL;
		}
	}
#endif // HAVE_AIRPCAP_API
	
	//
	// Done. Release the mutex and return
	//
	ReleaseMutex(g_DynamicLibrariesMutex);

	TRACE_EXIT();
	return;
}
#endif


/*! 
  \brief Converts an UNICODE string to ASCII. Uses the WideCharToMultiByte() system function.
  \param string The string to convert.
  \return The converted string.
*/
_Success_(return != NULL)
_Must_inspect_result_
static PCHAR WChar2SChar(_In_ LPCWCH string)
{
	PCHAR TmpStr;
	TmpStr = (CHAR*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (DWORD)(wcslen(string)+2));

	if (TmpStr == NULL) {
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		return NULL;
	}
	if (!WideCharToMultiByte(CP_ACP, 0, string, -1, TmpStr, (DWORD)(wcslen(string)+2), NULL, NULL)) {
		DWORD err = GetLastError();
		HeapFree(GetProcessHeap(), 0, TmpStr);
		SetLastError(err);
		return NULL;
	}

	return TmpStr;
}

/*! 
  \brief Sets the maximum possible lookahead buffer for the driver's Packet_tap() function.
  \param AdapterObject Handle to the service control manager.
  \return If the function succeeds, the return value is nonzero.

  The lookahead buffer is the portion of packet that Packet_tap() can access from the NIC driver's memory
  without performing a copy. This function tries to increase the size of that buffer.

  NOTE: this function is used for NPF adapters, only.
  Npcap NOTE: This may no longer be necessary. Testing required.
*/
static
BOOLEAN PacketSetMaxLookaheadsize (LPADAPTER AdapterObject)
{
	BOOLEAN    Status;
	CHAR IoCtlBuffer[PACKET_OID_DATA_LENGTH(sizeof(ULONG)) + PACKET_COMPAT_OID_LEN_DIFF] = { 0 };
	PPACKET_OID_DATA  OidData = (PPACKET_OID_DATA)IoCtlBuffer;
	DWORD err = ERROR_SUCCESS;

	TRACE_ENTER();
	assert(!(AdapterObject->Flags & INFO_FLAG_MASK_NOT_NPF));

	if (AdapterObject->Flags & INFO_FLAG_NPCAP_LOOPBACK) {
		// Loopback adapter doesn't support this; fake success
		TRACE_EXIT();
		SetLastError(ERROR_SUCCESS);
		return TRUE;
	}
	
	//set the size of the lookahead buffer to the maximum available by the the NIC driver
	OidData->Oid=OID_GEN_MAXIMUM_LOOKAHEAD;
	OidData->Length=sizeof(ULONG);
	Status=PacketRequest(AdapterObject,FALSE,OidData);
	if (!Status) {
		err = GetLastError();
		TRACE_EXIT();
		SetLastError(err);
		return FALSE;
	}

	OidData->Oid=OID_GEN_CURRENT_LOOKAHEAD;
	Status=PacketRequest(AdapterObject,TRUE,OidData);	
	if (!Status) {
		err = GetLastError();
	}

	TRACE_EXIT();
	SetLastError(err);
	return Status;
}

/*! 
  \brief Allocates the read event associated with the capture instance, passes it down to the kernel driver
  and stores it in an _ADAPTER structure.
  \param AdapterObject Handle to the adapter.
  \return If the function succeeds, the return value is nonzero.

  This function is used by PacketOpenAdapter() to allocate the read event and pass it to the driver by means of an ioctl
  call and set it in the _ADAPTER structure pointed by AdapterObject.

  NOTE: this function is used for NPF adapters, only.
*/
static
BOOLEAN PacketSetReadEvt(LPADAPTER AdapterObject)
{
	DWORD BytesReturned;
	HANDLE hEvent;
	DWORD err = ERROR_SUCCESS;

 	TRACE_ENTER();
	assert(!(AdapterObject->Flags & INFO_FLAG_MASK_NOT_NPF));

	if (AdapterObject->ReadEvent != NULL)
	{
		TRACE_PRINT("ReadEvent is not NULL");
		SetLastError(ERROR_INVALID_FUNCTION);
		return FALSE;
	}

 	hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

	if (hEvent == NULL)
	{
		err = GetLastError();
		TRACE_PRINT("Error in CreateEvent");
 		TRACE_EXIT();
		SetLastError(err);
		return FALSE;
	}

	if(DeviceIoControl(AdapterObject->hFile,
			BIOCSETEVENTHANDLE,
			&hEvent,
			sizeof(hEvent),
			NULL,
			0,
			&BytesReturned,
			NULL)==FALSE) 
	{
		err = GetLastError();
		TRACE_PRINT("Error in DeviceIoControl");

		CloseHandle(hEvent);

		TRACE_EXIT();
		SetLastError(err);
		return FALSE;
	}

	AdapterObject->ReadEvent = hEvent;
	AdapterObject->ReadTimeOut=0;

	TRACE_EXIT();
	return TRUE;
}

/*! 
  \brief Returns the version of a dll or exe file 
  \param FileName Name of the file whose version has to be retrieved.
  \param VersionBuff Buffer that will contain the string with the file version.
  \param VersionBuffLen Length of the buffer poited by VersionBuff.
  \return If the function succeeds, the return value is TRUE.

  \note uses the GetFileVersionInfoSize() and GetFileVersionInfo() WIN32 API functions
*/
_Use_decl_annotations_
static BOOL PacketGetFileVersion(LPCTSTR FileName, PCHAR VersionBuff, UINT VersionBuffLen)
{
    DWORD   dwVerInfoSize;  // Size of version information block
    DWORD   dwVerHnd=0;   // An 'ignored' parameter, always '0'
	LPTSTR   lpstrVffInfo;
	UINT	cbTranslate, dwBytes;
	TCHAR	SubBlock[64];
	PVOID	lpBuffer;
	PCHAR	TmpStr;
	DWORD err = ERROR_SUCCESS;
	
	// Structure used to store enumerated languages and code pages.
	struct LANGANDCODEPAGE {
	  WORD wLanguage;
	  WORD wCodePage;
	} *lpTranslate;

	TRACE_ENTER();
#ifndef _WIN64
	PVOID OldRedir = NULL;
#define PACKET_UNDO_WOW64FSREDIRECTION Wow64RevertWow64FsRedirection(OldRedir)
	if (!Wow64DisableWow64FsRedirection(&OldRedir))
	{
		err = GetLastError();
		TRACE_PRINT1("PacketGetFileVersion: failed to disable FS redirection: LastError = %8.8x", err);
		TRACE_EXIT();
		SetLastError(err);
		return FALSE;
	}
#else
#define PACKET_UNDO_WOW64FSREDIRECTION
#endif

	// Now lets dive in and pull out the version information:
	
    dwVerInfoSize = GetFileVersionInfoSize(FileName, &dwVerHnd);
	dwVerHnd = 0;
    if (dwVerInfoSize) 
	{
        lpstrVffInfo = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwVerInfoSize);
		if (lpstrVffInfo == NULL)
		{
			TRACE_PRINT("PacketGetFileVersion: failed to allocate memory");
			PACKET_UNDO_WOW64FSREDIRECTION;
			TRACE_EXIT();
			SetLastError(ERROR_NOT_ENOUGH_MEMORY);
			return FALSE;
		}

		if(!GetFileVersionInfo(FileName, dwVerHnd, dwVerInfoSize, lpstrVffInfo)) 
		{
			err = GetLastError();
			TRACE_PRINT1("PacketGetFileVersion: failed to call GetFileVersionInfo: %d", err);
			HeapFree(GetProcessHeap(), 0, lpstrVffInfo);
			PACKET_UNDO_WOW64FSREDIRECTION;
			TRACE_EXIT();
			SetLastError(err);
			return FALSE;
		}
		PACKET_UNDO_WOW64FSREDIRECTION;

		// Read the list of languages and code pages.
		if(!VerQueryValue(lpstrVffInfo,	TEXT("\\VarFileInfo\\Translation"),	(LPVOID*)&lpTranslate, &cbTranslate))
		{
			err = GetLastError();
			TRACE_PRINT1("PacketGetFileVersion: failed to call VerQueryValue: %d", err);
			HeapFree(GetProcessHeap(), 0, lpstrVffInfo);
			TRACE_EXIT();
			SetLastError(err);
			return FALSE;
		}
		
		// Create the file version string for the first (i.e. the only one) language.
		StringCchPrintf(SubBlock,
			sizeof(SubBlock)/sizeof(SubBlock[0]),
			(TCHAR*)TEXT("\\StringFileInfo\\%04x%04x\\FileVersion"),
			(*lpTranslate).wLanguage,
			(*lpTranslate).wCodePage);
		
		// Retrieve the file version string for the language.
		if(!VerQueryValue(lpstrVffInfo, SubBlock, &lpBuffer, &dwBytes))
		{
			err = GetLastError();
			TRACE_PRINT1("PacketGetFileVersion: failed to call VerQueryValue: %d", err);
			HeapFree(GetProcessHeap(), 0, lpstrVffInfo);
			TRACE_EXIT();
			SetLastError(err);
			return FALSE;
		}

		// Convert to ASCII
		TmpStr = WChar2SChar((PWCHAR) lpBuffer);
		if (TmpStr == NULL) {
			err = GetLastError();
			TRACE_PRINT1("PacketGetFileVersion: failed to convert name to ASCII: %d", err);
			HeapFree(GetProcessHeap(), 0, lpstrVffInfo);
			TRACE_EXIT();
			SetLastError(err);
			return FALSE;
		}

		if(strlen(TmpStr) >= VersionBuffLen)
		{
			TRACE_PRINT("PacketGetFileVersion: Input buffer too small");
			HeapFree(GetProcessHeap(), 0, lpstrVffInfo);
			HeapFree(GetProcessHeap(), 0, TmpStr);
			TRACE_EXIT();
			SetLastError(ERROR_BUFFER_OVERFLOW);
			return FALSE;
		}

		StringCchCopyA(VersionBuff, VersionBuffLen, TmpStr);

		HeapFree(GetProcessHeap(), 0, lpstrVffInfo);
		HeapFree(GetProcessHeap(), 0, TmpStr);
		
	  } 
	else 
	{
		err = GetLastError();
		TRACE_PRINT1("PacketGetFileVersion: failed to call GetFileVersionInfoSize, LastError = %8.8x", err);
		PACKET_UNDO_WOW64FSREDIRECTION;
		TRACE_EXIT();
		SetLastError(err);
		return FALSE;
	
	} 
	
	TRACE_EXIT();
	return TRUE;
}

static
BOOL PacketStartService()
{
	DWORD error = ERROR_SUCCESS;
	BOOL Result;
	SC_HANDLE svcHandle = NULL;
	SC_HANDLE scmHandle = NULL;
	LONG KeyRes;
	HKEY PathKey;
	SERVICE_STATUS SStat;
	BOOL QuerySStat;
	static BOOL ServiceStartAttempted = FALSE;

	TRACE_ENTER();
	if (ServiceStartAttempted) {
		TRACE_PRINT("PacketStartService: Already tried once.");
		TRACE_EXIT();
		return TRUE;
	}

	scmHandle = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);

	if (scmHandle == NULL)
	{
		error = GetLastError();
		TRACE_PRINT1("OpenSCManager failed! LastError=%8.8x", error);
		Result = FALSE;
	}
	else
	{
		// check if the NPF registry key is already present
		// this means that the driver is already installed and that we don't need to call PacketInstallDriver
		KeyRes = RegOpenKeyExA(HKEY_LOCAL_MACHINE,
			SERVICES_REG_KEY NPF_DRIVER_NAME,
			0,
			KEY_READ | KEY_WOW64_32KEY,
			&PathKey);

		if (KeyRes != ERROR_SUCCESS)
		{
			Result = FALSE;
#ifdef NPCAP_PACKET_INSTALL_SERVICE
			TRACE_PRINT("NPF registry key not present, trying to install the driver.");
			Result = InstallDriver();
#endif
		}
		else
		{
			TRACE_PRINT("NPF registry key present, driver is installed.");
			Result = TRUE;
			RegCloseKey(PathKey);
		}

		if (Result)
		{
			TRACE_PRINT("Trying to see if the NPF service is running...");
			svcHandle = OpenServiceA(scmHandle, NPF_DRIVER_NAME, SERVICE_START | SERVICE_QUERY_STATUS);

			if (svcHandle != NULL)
			{
				QuerySStat = QueryServiceStatus(svcHandle, &SStat);

#ifdef _DBG				
				switch (SStat.dwCurrentState)
				{
				case SERVICE_CONTINUE_PENDING:
					TRACE_PRINT("The status of the driver is: SERVICE_CONTINUE_PENDING");
					break;
				case SERVICE_PAUSE_PENDING:
					TRACE_PRINT("The status of the driver is: SERVICE_PAUSE_PENDING");
					break;
				case SERVICE_PAUSED:
					TRACE_PRINT("The status of the driver is: SERVICE_PAUSED");
					break;
				case SERVICE_RUNNING:
					TRACE_PRINT("The status of the driver is: SERVICE_RUNNING");
					break;
				case SERVICE_START_PENDING:
					TRACE_PRINT("The status of the driver is: SERVICE_START_PENDING");
					break;
				case SERVICE_STOP_PENDING:
					TRACE_PRINT("The status of the driver is: SERVICE_STOP_PENDING");
					break;
				case SERVICE_STOPPED:
					TRACE_PRINT("The status of the driver is: SERVICE_STOPPED");
					break;

				default:
					TRACE_PRINT("The status of the driver is: unknown");
					break;
				}
#endif

				if (!QuerySStat || SStat.dwCurrentState != SERVICE_RUNNING)
				{
					TRACE_PRINT("Driver NPF not running. Calling startservice");
					if (StartService(svcHandle, 0, NULL) == 0)
					{
						error = GetLastError();
						if (error != ERROR_SERVICE_ALREADY_RUNNING && error != ERROR_ALREADY_EXISTS)
						{
							TRACE_PRINT1("StartService failed, LastError=%8.8x", error);
							Result = FALSE;
						}
					}
				}

				CloseServiceHandle(svcHandle);
				svcHandle = NULL;

			}
			else
			{
				error = GetLastError();
				TRACE_PRINT1("OpenService failed! Error=%8.8x", error);
				Result = FALSE;
			}
		}
		else
		{
			error = GetLastError();
			TRACE_PRINT1("InstallDriver failed! Error=%8.8x", error);
			Result = FALSE;
		}
	}

	if (scmHandle != NULL) CloseServiceHandle(scmHandle);

	ServiceStartAttempted = TRUE;
	TRACE_EXIT();
	SetLastError(error);
	return Result;
}

static
PCCH NpfDeviceTag(_In_ ULONG NpfOpenFlags)
{
	if ((NpfOpenFlags & NPF_OPEN_FLAG_WIFI) > 0) {
		return NPF_DEVICE_NAMES_TAG_WIFI;
	}
	return "";
}

_Use_decl_annotations_
HANDLE PacketGetAdapterHandle(PCCH AdapterNameA, ULONG NpfOpenFlags)
{
	CHAR SymbolicLinkA[MAX_PATH] = {0};
	HRESULT hrStatus = S_OK;
	DWORD err = ERROR_SUCCESS;
	HANDLE hFile = INVALID_HANDLE_VALUE;


	// Create the NPF device name from the original device name
	TRACE_ENTER();

	TRACE_PRINT2("Trying to open adapter %hs (%#x)", AdapterNameA, NpfOpenFlags);

	hrStatus = StringCchPrintfA(SymbolicLinkA, MAX_PATH, "\\\\.\\Global\\%s%s%s",
			NPF_DEVICE_NAMES_PREFIX,
			NpfDeviceTag(NpfOpenFlags),
			AdapterNameA);
	if (FAILED(hrStatus))
	{
		TRACE_PRINT1("Failed to format symbolic link: %08x", hrStatus);
		TRACE_EXIT();
		// STRSAFE_E_INSUFFICIENT_BUFFER
		SetLastError(ERROR_BUFFER_OVERFLOW);
		return INVALID_HANDLE_VALUE;
	}

	// Start the driver service and/or Helper if needed
	PacketStartService();

	if (NpcapIsAdminOnlyMode() && g_hNpcapHelperPipe == INVALID_HANDLE_VALUE)
	{
		// NpcapHelper Initialization, used for accessing the driver with Administrator privilege.
		NpcapStartHelper();
	}

	// Try NpcapHelper to request handle if we have a valid pipe.
	if (g_hNpcapHelperPipe != INVALID_HANDLE_VALUE)
	{
		// err receives error code from NpcapHelper only if NpcapRequestHandle succeeds.
		hFile = NpcapRequestHandle(SymbolicLinkA, &err);
	}
	else
	{
		// Try if it is possible to open the adapter immediately
		hFile = CreateFileA(SymbolicLinkA, GENERIC_WRITE | GENERIC_READ,
				0, NULL, OPEN_EXISTING, 0, 0);
		err = GetLastError();
		TRACE_PRINT2("SymbolicLinkA = %hs, hFile = %08x", SymbolicLinkA, hFile);
	}

	TRACE_EXIT();
	SetLastError(err);
	return hFile;
}

_Success_(return == ERROR_SUCCESS)
static DWORD PacketRequestHelper(
	_In_ HANDLE hAdapter,
	_In_ BOOLEAN Set,
	_Inout_updates_bytes_(PACKET_OID_DATA_LENGTH(OidData->Length)) PPACKET_OID_DATA OidData)
{
	DWORD BytesReturned = 0;
	DWORD err = ERROR_SUCCESS;
	if (!DeviceIoControl(hAdapter, (DWORD)(Set ? BIOCSETOID : BIOCQUERYOID),
		OidData, PACKET_COMPAT_OID_LEN(OidData->Length),
		OidData, PACKET_COMPAT_OID_LEN(OidData->Length),
		&BytesReturned, NULL))
	{
		err = GetLastError();
	}
	if (BytesReturned > PACKET_COMPAT_OID_LEN(0)) {
		OidData->Length = BytesReturned - PACKET_COMPAT_OID_LEN(0);
	}
	else {
		OidData->Length = 0;
	}
	TRACE_PRINT4("PacketRequest: OID = 0x%.08x, Length = %d, Set = %d, ErrCode = 0x%.08x",
		OidData->Oid,
		OidData->Length,
		Set,
		err & ~(1 << 29));
	return err;
}

_Use_decl_annotations_
static DWORD _PacketGetInfoPriv(
		HANDLE hFile, ULONG ulID, PULONG ulInfo)
{
	CHAR IoCtlBuffer[PACKET_OID_DATA_LENGTH(sizeof(ULONG)) + PACKET_COMPAT_OID_LEN_DIFF] = { 0 };
	PPACKET_OID_DATA  OidData = (PPACKET_OID_DATA)IoCtlBuffer;
	DWORD dwResult = ERROR_INVALID_DATA;
	DWORD BytesReturned = 0;

	HANDLE hAdapter = hFile;
	if (hAdapter == INVALID_HANDLE_VALUE) {
		hAdapter = PacketGetAdapterHandle(NPCAP_LOOPBACK_ADAPTER_BUILTIN, 0);
	}

	if (hAdapter != INVALID_HANDLE_VALUE) {
		OidData->Oid = ulID;
		OidData->Length = sizeof(ULONG);
		if(!DeviceIoControl(hAdapter, BIOCGETINFO,
					OidData, PACKET_COMPAT_OID_LEN(OidData->Length),
					OidData, PACKET_COMPAT_OID_LEN(OidData->Length),
					&BytesReturned, NULL))
		{
			dwResult = GetLastError();
			TRACE_PRINT("_PacketGetInfoPriv failed, PacketRequest error");
		}
		else {
			dwResult = ERROR_SUCCESS;
			*ulInfo = *((ULONG*)OidData->Data);
		}

		if (hAdapter != hFile) {
			CloseHandle(hAdapter);
		}
	}

	TRACE_EXIT();
	SetLastError(dwResult);
	return dwResult;
}

/*!
  \brief Opens an adapter using the NPF device driver.
  \param AdapterName A string containing the name of the device to open.
  \return If the function succeeds, the return value is the pointer to a properly initialized ADAPTER object,
   otherwise the return value is NULL.

  \note internal function used by PacketOpenAdapter()
*/
_Ret_maybenull_
static
LPADAPTER PacketOpenAdapterNPF(_In_ PCCH AdapterID, ULONG NpfOpenFlags)
{
	DWORD error;
	LPADAPTER lpAdapter;
	PADAPTER_PRIV pAdPriv;

	TRACE_ENTER();

	pAdPriv = (PADAPTER_PRIV)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(ADAPTER_PRIV));
	if (pAdPriv == NULL)
	{
		TRACE_PRINT("PacketOpenAdapterNPF: HeapAlloc Failed to allocate the ADAPTER structure");
		TRACE_EXIT();
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		return NULL;
	}
	lpAdapter = &pAdPriv->ad;

	if ((NpfOpenFlags & NPF_OPEN_FLAG_WIFI) > 0) {
		lpAdapter->Flags |= INFO_FLAG_NPCAP_DOT11;
	}

	lpAdapter->hFile = PacketGetAdapterHandle(AdapterID, NpfOpenFlags);

	do {
		error=GetLastError();
		if (lpAdapter->hFile == INVALID_HANDLE_VALUE)
		{
			TRACE_PRINT("PacketOpenAdapterNPF: Failed to get adapter handle");
			break;
		}

		if(!PacketSetReadEvt(lpAdapter)) {
			error=GetLastError();
			TRACE_PRINT("PacketOpenAdapterNPF: Unable to open the read event");
			break;
		}

		if (!PacketSetMaxLookaheadsize(lpAdapter)) {
			// error=GetLastError();
			TRACE_PRINT("PacketOpenAdapterNPF: Unable to set lookahead");
			// We do not consider this a failure. Would like to avoid it for loopback, though.
			// break;
		}
		if (ERROR_SUCCESS != _PacketGetInfoPriv(lpAdapter->hFile,
					NPF_GETINFO_CONFIG, &pAdPriv->ulConfig))
		{
			pAdPriv->ulConfig = 0;
		}

		TRACE_PRINT("Successfully opened adapter");
		TRACE_EXIT();
		return lpAdapter;
	} while (FALSE);

	TRACE_PRINT1("PacketOpenAdapterNPF: LastError= %8.8x",error);
	PacketCloseAdapter(lpAdapter);

	//set the error to the one on which we failed
	TRACE_EXIT();
	SetLastError(error);
	return NULL;
}

/*! 
  \brief Opens an adapter using the aircap dll.
  \param AdapterName A string containing the name of the device to open. 
  \return If the function succeeds, the return value is the pointer to a properly initialized ADAPTER object,
   otherwise the return value is NULL.

  \note internal function used by PacketOpenAdapter()
*/
#ifdef HAVE_AIRPCAP_API
static BOOLEAN IsAirpcapName(LPCSTR AdapterName)
{
	static PCCH airpcap_prefix = "\\\\.\\airpcap";
	return (strncmp(AdapterName, airpcap_prefix, sizeof(airpcap_prefix) - 1) == 0);
}

static LPADAPTER PacketOpenAdapterAirpcap(LPCSTR AdapterName)
{
	CHAR Ebuf[AIRPCAP_ERRBUF_SIZE];
	LPADAPTER lpAdapter;
	PADAPTER_PRIV pAdPriv;

	TRACE_ENTER();

	//
	// Make sure that the airpcap API has been linked
	//
	if(!g_PAirpcapOpen)
	{
		TRACE_EXIT();
		return NULL;
	}
	
	pAdPriv = (PADAPTER_PRIV)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(ADAPTER_PRIV));
	if (pAdPriv == NULL)
	{
		TRACE_PRINT("PacketOpenAdapterAirPcap: HeapAlloc Failed to allocate the ADAPTER structure");
		TRACE_EXIT();
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		return NULL;
	}
	lpAdapter = &pAdPriv->ad;

	//
	// Indicate that this is a aircap card
	//
	lpAdapter->Flags = INFO_FLAG_AIRPCAP_CARD;
		  
	//
	// Open the adapter
	//
	lpAdapter->AirpcapAd = g_PAirpcapOpen(AdapterName, Ebuf);
	
	if(lpAdapter->AirpcapAd == NULL)
	{
		HeapFree(GetProcessHeap(), 0, pAdPriv);
		TRACE_EXIT();
		return NULL;					
	}
		  				
	TRACE_EXIT();
	return lpAdapter;
}
#endif // HAVE_AIRPCAP_API


//---------------------------------------------------------------------------
// PUBLIC API
//---------------------------------------------------------------------------

/** @ingroup packetapi
 *  @{
 */

/** @defgroup packet32 Packet.dll exported functions and variables
 *  @{
 */

/*! 
  \brief Return a string with the dll version.
  \return A char pointer to the version of the library.
*/
LPCSTR PacketGetVersion()
{
	TRACE_ENTER();
	TRACE_EXIT();
	return PacketLibraryVersion;
}

/*! 
  \brief Return a string with the version of the device driver.
  \return A char pointer to the version of the driver.
*/
LPCSTR PacketGetDriverVersion()
{
	TRACE_ENTER();
	ULONG DriverVersion = 0;
	static ULONG OldVersion = 0;
	// By checking every time, we allow long-running processes to notice if
	// the driver version is updated. Not likely, but possible.
	if (ERROR_SUCCESS == _PacketGetInfoPriv(INVALID_HANDLE_VALUE, NPF_GETINFO_VERSION, &DriverVersion)
			&& DriverVersion != OldVersion) {
		StringCchPrintfA(PacketDriverVersion, sizeof(PacketDriverVersion),
				"%u.%u.%u",
				(DriverVersion >> 24) & 0xff,
				(DriverVersion >> 16) & 0xff,
				DriverVersion & 0xffff);
		OldVersion = DriverVersion;
		// Check if older than 1.60
		bOidLenCompat = (DriverVersion < 0x013c0000);
	}
	TRACE_EXIT();
	return PacketDriverVersion;
}

/*!
\brief Return a string with the name of the device driver.
\return A char pointer to the version of the driver.
*/
LPCSTR PacketGetDriverName()
{
	TRACE_ENTER();
	TRACE_EXIT();
	return PacketDriverName;
}

/*! 
  \brief Stops and unloads the WinPcap device driver.
  \return If the function succeeds, the return value is nonzero, otherwise it is zero.

  This function can be used to unload the driver from memory when the application no more needs it.
  Note that the driver is physically stopped and unloaded only when all the files on its devices 
  are closed, i.e. when all the applications that use WinPcap close all their adapters.
*/
BOOL PacketStopDriver()
{
	SC_HANDLE		scmHandle;
    SC_HANDLE       schService;
    BOOL            ret;
    SERVICE_STATUS  serviceStatus;
    DWORD err = ERROR_SUCCESS;

 	TRACE_ENTER();
 
 	ret = FALSE;

	scmHandle = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
	
	if(scmHandle != NULL){
		
		TRACE_PRINT("Opened the SCM");
		
		schService = OpenServiceA (scmHandle,
			NPF_DRIVER_NAME,
			SERVICE_STOP
			);
		
		if (schService != NULL)
		{
			TRACE_PRINT("Opened the NPF service in the SCM");

			ret = ControlService (schService,
				SERVICE_CONTROL_STOP,
				&serviceStatus
				);
			if (!ret)
			{
				err = GetLastError();
				TRACE_PRINT("Failed to stop the NPF service");
			}
			else
			{
				TRACE_PRINT("NPF service stopped");
			}
			
			CloseServiceHandle (schService);
			
			CloseServiceHandle(scmHandle);
			
		}
		else {
			err = GetLastError();
		}
	}
	else {
		err = GetLastError();
	}
	
	TRACE_EXIT();
	SetLastError(err);
	return ret;
}

/*! 
  \brief Opens an adapter.
  \param AdapterName A string containing the name of the device to open. 
   Use the PacketGetAdapterNames() function to retrieve the list of available devices.
  \return If the function succeeds, the return value is the pointer to a properly initialized ADAPTER object,
   otherwise the return value is NULL.
*/
_Use_decl_annotations_
LPADAPTER PacketOpenAdapter(PCCH AdapterNameWA)
{
    LPADAPTER lpAdapter = NULL;
	PCHAR AdapterNameA = NULL;
	PCHAR AdapterID = NULL;
	
	DWORD dwLastError = ERROR_SUCCESS;
 
 	TRACE_ENTER();	
 
	TRACE_PRINT_OS_INFO();
	
	TRACE_PRINT2("Packet DLL version %hs, Driver version %hs", PacketLibraryVersion, PacketDriverVersion);

#ifdef LOAD_OPTIONAL_LIBRARIES
	//
	// Check the presence on some libraries we rely on, and load them if we found them
	//
	PacketLoadLibrariesDynamically();
#endif

	//
	// Ugly heuristic to detect if the adapter is ASCII
	//
	if(AdapterNameWA[1]==0)
	{	
		//
		// Unicode
		//
		const size_t bufferSize = wcslen((PCWCHAR)AdapterNameWA) + 1;
		
		AdapterNameA = (PCHAR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, bufferSize);

		if (AdapterNameA == NULL)
		{
			SetLastError(ERROR_NOT_ENOUGH_MEMORY);
			return NULL;
		}

		StringCchPrintfA(AdapterNameA, bufferSize, "%ws", (PWCHAR)AdapterNameWA);
		AdapterNameWA = AdapterNameA;
	}

	do
	{

#ifdef HAVE_AIRPCAP_API
		if(IsAirpcapName(AdapterNameWA))
		{
			//
			// This is an airpcap card. Open it using the airpcap api
			//								
			lpAdapter = PacketOpenAdapterAirpcap(AdapterNameWA);
			
			if(lpAdapter == NULL)
			{
				dwLastError = ERROR_BAD_UNIT;
				break;
			}

			//
			// Airpcap provides a read event
			//
			if(!g_PAirpcapGetReadEvent(lpAdapter->AirpcapAd, &lpAdapter->ReadEvent))
			{
				PacketCloseAdapter(lpAdapter);
				lpAdapter = NULL;
				dwLastError = ERROR_BAD_UNIT;
			}
			else
			{
				dwLastError = ERROR_SUCCESS;
			}
			
			break;
		}
#endif // HAVE_AIRPCAP_API

		ULONG NpfOpenFlags = 0;
		AdapterID = NpcapGetAdapterID(AdapterNameWA, &NpfOpenFlags);
		if (!AdapterID)
		{
			dwLastError = GetLastError();
			break;
		}


		// If there's no WIFI hint in the name, but we know it's in monitor mode, try the WIFI version
		if ((NpfOpenFlags & NPF_OPEN_FLAG_WIFI) == 0 && g_nbAdapterMonitorModes[AdapterID] != 0)
		{
			TRACE_PRINT("Try to open in monitor mode");
			lpAdapter = PacketOpenAdapterNPF(AdapterID, NPF_OPEN_FLAG_WIFI);
			if (lpAdapter == NULL)
			{
				dwLastError = GetLastError();
			}
			else
			{
				lpAdapter->Flags |= INFO_FLAG_NPCAP_DOT11;
				break;
			}
		}
		if (lpAdapter == NULL)
		{
			// Ordinary open
			TRACE_PRINT("Normal NPF adapter, trying to open it...");
			lpAdapter = PacketOpenAdapterNPF(AdapterID, NpfOpenFlags);
			if (lpAdapter == NULL)
			{
				dwLastError = GetLastError();
				break;
			}
		}
		if (g_bLoopbackSupport && PacketIsLoopbackAdapter(AdapterNameWA)) {
			lpAdapter->Flags |= INFO_FLAG_NPCAP_LOOPBACK;
		}

	}while(FALSE);

	if (lpAdapter && FAILED(StringCchCopyA(lpAdapter->Name, ADAPTER_NAME_LENGTH, AdapterNameWA)))
	{
		TRACE_PRINT("PacketOpenAdapter: Unable to copy adapter name");
		// Do not report error: this member is unused.
	}

	if (NULL != AdapterNameA) HeapFree(GetProcessHeap(), 0, AdapterNameA);
	if (NULL != AdapterID) HeapFree(GetProcessHeap(), 0, AdapterID);


	TRACE_EXIT();
	SetLastError(dwLastError);
	return lpAdapter;

}

/*! 
  \brief Closes an adapter.
  \param lpAdapter the pointer to the adapter to close. 

  PacketCloseAdapter closes the given adapter and frees the associated ADAPTER structure
*/
_Use_decl_annotations_
VOID PacketCloseAdapter(LPADAPTER lpAdapter)
{
	TRACE_ENTER();
	if(!lpAdapter)
	{
        TRACE_PRINT("PacketCloseAdapter: attempt to close a NULL adapter");
		TRACE_EXIT();
		return;
	}

#ifdef HAVE_AIRPCAP_API
	if(lpAdapter->Flags & INFO_FLAG_AIRPCAP_CARD)
		{
			g_PAirpcapClose(lpAdapter->AirpcapAd);
			HeapFree(GetProcessHeap(), 0, lpAdapter);
			TRACE_EXIT();
			return;
		}
#endif // HAVE_AIRPCAP_API

	if (lpAdapter->Flags & INFO_FLAG_MASK_NOT_NPF)
	{
		TRACE_PRINT1("Trying to close an unknown adapter type (%u)", lpAdapter->Flags);
	}
	else
	{
		if (lpAdapter->ReadEvent != NULL) {
			SetEvent(lpAdapter->ReadEvent);
			CloseHandle(lpAdapter->ReadEvent);
			lpAdapter->ReadEvent = NULL;
		}
		if (lpAdapter->hFile != INVALID_HANDLE_VALUE && lpAdapter->hFile != NULL) {
			CloseHandle(lpAdapter->hFile);
		}
		HeapFree(GetProcessHeap(), 0, LPAD_TO_ADAPTER_PRIV(lpAdapter));
	}

	TRACE_EXIT();
}

/*! 
  \brief Allocates a _PACKET structure.
  \return On succeess, the return value is the pointer to a _PACKET structure otherwise the 
   return value is NULL.

  The structure returned will be passed to the PacketReceivePacket() function to receive the
  packets from the driver.

  \warning The Buffer field of the _PACKET structure is not set by this function. 
  The buffer \b must be allocated by the application, and associated to the PACKET structure 
  with a call to PacketInitPacket.
*/
LPPACKET PacketAllocatePacket(void)
{
    LPPACKET    lpPacket;
    DWORD err = ERROR_SUCCESS;

	TRACE_ENTER();
    
	lpPacket=(LPPACKET)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(PACKET));
    if (lpPacket==NULL)
    {
	    err = ERROR_NOT_ENOUGH_MEMORY;
        TRACE_PRINT("PacketAllocatePacket: HeapAlloc Failed");
    }

	TRACE_EXIT();
	SetLastError(err);
	return lpPacket;
}

/*! 
  \brief Frees a _PACKET structure.
  \param lpPacket The structure to free. 

  \warning the user-allocated buffer associated with the _PACKET structure is not deallocated 
  by this function and \b must be explicitly deallocated by the programmer.

*/
_Use_decl_annotations_
VOID PacketFreePacket(LPPACKET lpPacket)

{
	TRACE_ENTER();
	HeapFree(GetProcessHeap(), 0, lpPacket);
	TRACE_EXIT();
}

/*! 
  \brief Initializes a _PACKET structure.
  \param lpPacket The structure to initialize. 
  \param Buffer A pointer to a user-allocated buffer that will contain the captured data.
  \param Length the length of the buffer. This is the maximum buffer size that will be 
   transferred from the driver to the application using a single read.

  \note the size of the buffer associated with the PACKET structure is a parameter that can sensibly 
  influence the performance of the capture process, since this buffer will contain the packets received
  from the the driver. The driver is able to return several packets using a single read call 
  (see the PacketReceivePacket() function for details), and the number of packets transferable to the 
  application in a call is limited only by the size of the buffer associated with the PACKET structure
  passed to PacketReceivePacket(). Therefore setting a big buffer with PacketInitPacket can noticeably 
  decrease the number of system calls, reducing the impcat of the capture process on the processor.
*/

_Use_decl_annotations_
VOID PacketInitPacket(LPPACKET lpPacket,PVOID Buffer,UINT Length)

{
	TRACE_ENTER();

	memset(lpPacket, 0, sizeof(PACKET));
    lpPacket->Buffer = Buffer;
    lpPacket->Length = Length;

	TRACE_EXIT();
}

#ifndef PAGE_ALIGN
#define PAGE_ALIGN(_VA) (((_VA)+(dwPageSize-1))&~(dwPageSize-1))
#endif
#define MIN_BUFFER 0x10000
static DWORD IncreaseReadLength(DWORD dwCurr, DWORD dwMax)
{
	DWORD dwNew = dwCurr;
	DWORD dwPageSize = g_Settings.dwPageSize;
	assert(dwPageSize > 0);
	if (dwNew == dwMax) {
		return dwMax;
	}
	if (dwNew >= 4 * MIN_BUFFER) {
		dwNew += MIN_BUFFER;
	}
	else {
		dwNew *= 2;
	}
	dwNew = PAGE_ALIGN(dwNew);
	return (dwNew > dwMax) ? dwMax : dwNew;
}

static DWORD DecreaseReadLength(DWORD dwMin, DWORD dwCurr, DWORD dwMax)
{
	DWORD dwNew = dwCurr / 2;
	DWORD dwPageSize = g_Settings.dwPageSize;
	assert(dwPageSize > 0);
	if (dwNew <= dwMin) {
		dwNew = dwMin;
	}
	dwNew = PAGE_ALIGN(dwNew);
	return (dwNew > dwMax) ? dwMax : dwNew;
}

/*! 
  \brief Read data (packets or statistics) from the NPF driver.
  \param AdapterObject Pointer to an _ADAPTER structure identifying the network adapter from which 
   the data is received.
  \param lpPacket Pointer to a PACKET structure that will contain the data.
  \param Sync This parameter is deprecated and will be ignored. It is present for compatibility with 
   older applications.
  \return If the function succeeds, the return value is nonzero.

  The data received with this function can be a group of packets or a static on the network traffic, 
  depending on the working mode of the driver. The working mode can be set with the PacketSetMode() 
  function. Give a look at that function if you are interested in the format used to return statistics 
  values, here only the normal capture mode will be described.

  The number of packets received with this function is variable. It depends on the number of packets 
  currently stored in the driver’s buffer, on the size of these packets and on the size of the buffer 
  associated to the lpPacket parameter. The following figure shows the format used by the driver to pass 
  packets to the application. 

  \image html encoding.gif "method used to encode the packets"

  Packets are stored in the buffer associated with the lpPacket _PACKET structure. The Length field of
  that structure is updated with the amount of data copied in the buffer. Each packet has a header
  consisting in a bpf_hdr structure that defines its length and contains its timestamp. A padding field 
  is used to word-align the data in the buffer (to speed up the access to the packets). The bh_datalen 
  and bh_hdrlen fields of the bpf_hdr structures should be used to extract the packets from the buffer. 
  
  Examples can be seen either in the TestApp sample application (see the \ref packetsamps page) provided
  in the developer's pack, or in the pcap_read() function of wpcap.
*/
_Use_decl_annotations_
BOOLEAN PacketReceivePacket(LPADAPTER AdapterObject,LPPACKET lpPacket,BOOLEAN Sync)
{
	BOOLEAN res;
	DWORD err = ERROR_SUCCESS;
	PADAPTER_PRIV pAdPriv = LPAD_TO_ADAPTER_PRIV(AdapterObject);

	UNUSED(Sync);

	TRACE_ENTER();

#ifdef HAVE_AIRPCAP_API
	if(AdapterObject->Flags & INFO_FLAG_AIRPCAP_CARD)
	{
		//
		// Wait for data, only if the user requested us to do that
		//
		if((int)AdapterObject->ReadTimeOut != -1)
		{
			WaitForSingleObject(AdapterObject->ReadEvent, (AdapterObject->ReadTimeOut==0)? INFINITE: AdapterObject->ReadTimeOut);
		}

		//
		// Read the data.
		// g_PAirpcapRead always returns immediately.
		//
		res = (BOOLEAN)g_PAirpcapRead(AdapterObject->AirpcapAd, 
				(PUCHAR) lpPacket->Buffer, 
				lpPacket->Length, 
				&lpPacket->ulBytesReceived);

		err = GetLastError();
		TRACE_EXIT();
		SetLastError(err);
		return res;
	}
#endif // HAVE_AIRPCAP_API

	if (AdapterObject->Flags & INFO_FLAG_MASK_NOT_NPF)
	{
		TRACE_PRINT1("Request to read on an unknown device type (%u)", AdapterObject->Flags);
		res = FALSE;
		err = ERROR_NOT_SUPPORTED;
	}
	else
	{
		DWORD Length = lpPacket->Length;
		if (g_Settings.bExperimentalOptimization) {
			if (pAdPriv->dwReadLength > 0 && pAdPriv->dwReadLength < Length) {
				Length = pAdPriv->dwReadLength;
			}
		}

		if((int)AdapterObject->ReadTimeOut != -1)
			WaitForSingleObject(AdapterObject->ReadEvent, (AdapterObject->ReadTimeOut==0)?INFINITE:AdapterObject->ReadTimeOut);
	
		res = (BOOLEAN)ReadFile(AdapterObject->hFile, lpPacket->Buffer, Length, &lpPacket->ulBytesReceived, NULL);
		if (g_Settings.bExperimentalOptimization) {
			DWORD dwMin = max(pAdPriv->minToCopy, MIN_BUFFER);
#ifdef _DBG				
			DWORD dwPageSize = g_Settings.dwPageSize;
			ULONG saved=0, wasted=0;
			static ULONG total_saved=0;
			static ULONG total_wasted=0;
			static const char did[4][4] = {
				"===", "...", "---", "+++" };
			int i = 0;
#define DID(_i) (i = _i)
#else
#define DID(_i) ((void)0)
#endif
			if (Length > dwMin && lpPacket->ulBytesReceived < Length / 4) {
				DID(1);
				// Too long, size down if allowed
				if (++pAdPriv->reduceCounter > 2) {
					DID(2);
					pAdPriv->dwReadLength = DecreaseReadLength(
							dwMin,
							Length,
							lpPacket->Length
							);
					pAdPriv->reduceCounter = 0;
				}
			}
			else if (Length < lpPacket->Length && Length - lpPacket->ulBytesReceived < 2048) {
				DID(3);
				// Too short, size up
				pAdPriv->dwReadLength = IncreaseReadLength(
						Length,
						lpPacket->Length
						);
			}
#ifdef _DBG
			saved = (lpPacket->Length - Length)/dwPageSize;
			wasted = PAGE_ALIGN(lpPacket->ulBytesReceived);
			wasted = (Length - min(wasted, Length))/dwPageSize;
			total_saved += saved;
			total_wasted += wasted;
			TRACE_PRINT10("got %u/%u (min:%u, max:%u) (saved:%u (%u), wasted: %u (%u)) %s = %u\n",
					lpPacket->ulBytesReceived, Length,
					pAdPriv->minToCopy, lpPacket->Length,
					saved, total_saved, wasted, total_wasted,
					did[i], pAdPriv->dwReadLength);
#endif
		}
		err = GetLastError();
	}
	
	TRACE_EXIT();
	SetLastError(err);
	return res;
}

/*! 
  \brief Sends one (or more) copies of a packet to the network.
  \param AdapterObject Pointer to an _ADAPTER structure identifying the network adapter that will 
   send the packets.
  \param lpPacket Pointer to a PACKET structure with the packet to send.
  \param Sync This parameter is deprecated and will be ignored. It is present for compatibility with 
   older applications.
  \return If the function succeeds, the return value is nonzero.

  This function is used to send a raw packet to the network. 'Raw packet' means that the programmer 
  will have to include the protocol headers, since the packet is sent to the network 'as is'. 
  The CRC needs not to be calculated and put at the end of the packet, because it will be transparently 
  added by the network interface.

  The behavior of this function is influenced by the PacketSetNumWrites() function. With PacketSetNumWrites(),
  it is possible to change the number of times a single write must be repeated. The default is 1, 
  i.e. every call to PacketSendPacket() will correspond to one packet sent to the network. If this number is
  greater than 1, for example 1000, every raw packet written by the application will be sent 1000 times on 
  the network. This feature mitigates the overhead of the context switches and therefore can be used to generate 
  high speed traffic. It is particularly useful for tools that test networks, routers, and servers and need 
  to obtain high network loads.
  The optimized sending process is still limited to one packet at a time: for the moment it cannot be used 
  to send a buffer with multiple packets.

  \note The ability to write multiple packets is currently present only in the Windows NTx version of the 
  packet driver. In Windows 95/98/ME it is emulated at user level in packet.dll. This means that an application
  that uses the multiple write method will run in Windows 9x as well, but its performance will be very low 
  compared to the one of WindowsNTx.
*/
_Use_decl_annotations_
BOOLEAN PacketSendPacket(LPADAPTER AdapterObject,LPPACKET lpPacket,BOOLEAN Sync)
{
    DWORD        BytesTransfered;
	BOOLEAN		Result;    
	DWORD err = ERROR_SUCCESS;
	TRACE_ENTER();

	UNUSED(Sync);

#ifdef HAVE_AIRPCAP_API
	if(AdapterObject->Flags & INFO_FLAG_AIRPCAP_CARD)
	{
		if(g_PAirpcapWrite)
		{
			Result = (BOOLEAN)g_PAirpcapWrite(AdapterObject->AirpcapAd, (PCHAR) lpPacket->Buffer, lpPacket->Length);
			
			err = GetLastError();
			TRACE_EXIT();
			SetLastError(err);
			return Result;
		}
		else
		{
			TRACE_PRINT("Transmission not supported with this version of AirPcap");

			TRACE_EXIT();
			SetLastError(ERROR_NOT_SUPPORTED);
			return FALSE;
		}
	}
#endif // HAVE_AIRPCAP_API

	if (AdapterObject->Flags & INFO_FLAG_MASK_NOT_NPF)
	{
		TRACE_PRINT1("Request to write on an unknown device type (%u)", AdapterObject->Flags);
		Result = FALSE;
		err = ERROR_NOT_SUPPORTED;
	}
	else
	{
		Result = (BOOLEAN)WriteFile(AdapterObject->hFile,lpPacket->Buffer,lpPacket->Length,&BytesTransfered,NULL);
		err = GetLastError();
	}

	TRACE_EXIT();
	SetLastError(err);
	return Result;
}

/*! 
  \brief Sends a buffer of packets to the network.
  \param AdapterObject Pointer to an _ADAPTER structure identifying the network adapter that will 
   send the packets.
  \param PacketBuff Pointer to buffer with the packets to send.
  \param Size Size of the buffer pointed by the PacketBuff argument.
  \param Sync if TRUE, the packets are sent respecting the timestamps. If FALSE, the packets are sent as
         fast as possible
  \return The amount of bytes actually sent. If the return value is smaller than the Size parameter, an
          error occurred during the send. The error can be caused by a driver/adapter problem or by an
		  inconsistent/bogus packet buffer.

  This function is used to send a buffer of raw packets to the network. The buffer can contain an arbitrary
  number of raw packets, each of which preceded by a dump_bpf_hdr structure. The dump_bpf_hdr is the same used
  by WinPcap and libpcap to store the packets in a file, therefore sending a capture file is straightforward.
  'Raw packets' means that the sending application will have to include the protocol headers, since every packet 
  is sent to the network 'as is'. The CRC of the packets needs not to be calculated, because it will be 
  transparently added by the network interface.

  \note Using this function if more efficient than issuing a series of PacketSendPacket(), because the packets are
  buffered in the kernel driver, so the number of context switches is reduced.

  \note When Sync is set to TRUE, the packets are synchronized in the kernel with a high precision timestamp.
  This requires a remarkable amount of CPU, but allows to send the packets with a precision of some microseconds
  (depending on the precision of the performance counter of the machine). Such a precision cannot be reached 
  sending the packets separately with PacketSendPacket().
*/
_Use_decl_annotations_
INT PacketSendPackets(LPADAPTER AdapterObject, PVOID PacketBuff, ULONG Size, BOOLEAN Sync)
{
    BOOLEAN			Res;
    C_ASSERT(sizeof(DWORD) == sizeof(ULONG));
    DWORD			BytesTransfered, TotBytesTransfered=0;
	struct timeval	BufStartTime = {};
	LARGE_INTEGER	StartTicks = {}, CurTicks = {}, TargetTicks = {}, TimeFreq = {};
	TIMECAPS tcap = {};
	DWORD err = ERROR_SUCCESS;
	struct dump_bpf_hdr *pHdr = NULL;
	LONGLONG prev_usec_diff = 0;

	TRACE_ENTER();

#ifdef HAVE_AIRPCAP_API
	if(AdapterObject->Flags & INFO_FLAG_AIRPCAP_CARD)
	{
		TRACE_PRINT("PacketSendPackets: packet sending not allowed on airpcap adapters");
		TRACE_EXIT();
		SetLastError(ERROR_NOT_SUPPORTED);
		return 0;
	}
#endif // HAVE_AIRPCAP_API

	if (AdapterObject->Flags & INFO_FLAG_MASK_NOT_NPF)
	{
		TRACE_PRINT1("Request to write on an unknown device type (%u)", AdapterObject->Flags);
		err = (ERROR_BAD_DEV_TYPE);
		TotBytesTransfered = 0;
	}
	else
	{
		pHdr = (struct dump_bpf_hdr *)PacketBuff;
		if (Sync)
		{
			// Obtain starting timestamp of the buffer
			BufStartTime.tv_sec = pHdr->ts.tv_sec;
			BufStartTime.tv_usec = pHdr->ts.tv_usec;

			// Request highest resolution of sleep timer
			if (MMSYSERR_NOERROR == timeGetDevCaps(&tcap, sizeof(tcap))) {
				timeBeginPeriod(tcap.wPeriodMin);
			}
			else {
				tcap.wPeriodMin = 0;
			}

			// Retrieve the reference time counters
			QueryPerformanceCounter(&StartTicks);
			QueryPerformanceFrequency(&TimeFreq);
		}

		do{
			// Send the data to the driver
			Res = (BOOLEAN)DeviceIoControl(AdapterObject->hFile,
				(Sync)?BIOCSENDPACKETSSYNC:BIOCSENDPACKETSNOSYNC,
				(PCHAR) pHdr,
				Size - TotBytesTransfered,
				NULL,
				0,
				&BytesTransfered,
				NULL);

			TotBytesTransfered += BytesTransfered;

			// Exit from the loop on error
			if(Res != TRUE) {
				err = GetLastError();
				if (err == RPC_S_INVALID_TIMEOUT) {
					err = ERROR_INVALID_TIME;
				}
				break;
			}

			// Exit from the loop if we have transferred everything
			if(TotBytesTransfered >= Size)
				break;

			// If there's less than a packet header remaining, exit and error
			if (Size < TotBytesTransfered + sizeof(struct dump_bpf_hdr)) {
				err = ERROR_INVALID_PARAMETER;
				break;
			}

			pHdr = (struct dump_bpf_hdr *)((PCHAR)pHdr + BytesTransfered);

			if (Sync)
			{
				QueryPerformanceCounter(&CurTicks);
				LONGLONG usec_diff = ((LONGLONG)pHdr->ts.tv_sec - BufStartTime.tv_sec) * 1000000
					+ pHdr->ts.tv_usec - BufStartTime.tv_usec;
				if (usec_diff < prev_usec_diff) {
					// Timestamps out of order
					err = ERROR_INVALID_TIME;
					break;
				}
				prev_usec_diff = usec_diff;

				// calculate the target QPC ticks to send the next packet
				TargetTicks.QuadPart = StartTicks.QuadPart + (usec_diff * TimeFreq.QuadPart) / 1000000;

				if (CurTicks.QuadPart < TargetTicks.QuadPart)
				{
					// calculate how much time is left to wait (milliseconds)
					LONGLONG msec_diff = (TargetTicks.QuadPart - CurTicks.QuadPart) * 1000 / TimeFreq.QuadPart;
					// Weirdly-huge intervals would lead to integer overflow or infinite sleep.
					if (msec_diff >= MAXDWORD || msec_diff == INFINITE) {
						err = ERROR_INVALID_TIME;
						break;
					}

					// Wait until the time interval has elapsed.  Intervals less than 1ms are assumed to be
					// lost in IRP processing, thread scheduling, and other jitter.
					if (msec_diff > 0) {
						Sleep((DWORD)msec_diff);
					}
				}
			}

		}
		while(TRUE);

		if (Sync && tcap.wPeriodMin > 0) {
			timeEndPeriod(tcap.wPeriodMin);
		}
	}

	TRACE_EXIT();
	SetLastError(err);
	return TotBytesTransfered;
}

/*! 
  \brief Defines the minimum amount of data that will be received in a read.
  \param AdapterObject Pointer to an _ADAPTER structure
  \param nbytes the minimum amount of data in the kernel buffer that will cause the driver to
   release a read on this adapter.
  \return If the function succeeds, the return value is nonzero.

  In presence of a large value for nbytes, the kernel waits for the arrival of several packets before 
  copying the data to the user. This guarantees a low number of system calls, i.e. lower processor usage, 
  i.e. better performance, which is a good setting for applications like sniffers. Vice versa, a small value 
  means that the kernel will copy the packets as soon as the application is ready to receive them. This is 
  suggested for real time applications (like, for example, a bridge) that need the better responsiveness from 
  the kernel.

  \b note: this function has effect only in Windows NTx. The driver for Windows 9x doesn't offer 
  this possibility, therefore PacketSetMinToCopy is implemented under these systems only for compatibility.
*/

_Use_decl_annotations_
BOOLEAN PacketSetMinToCopy(LPADAPTER AdapterObject,int nbytes)
{
	DWORD BytesReturned;
	BOOLEAN Result;
	DWORD err = ERROR_SUCCESS;
	PADAPTER_PRIV pAdPriv = LPAD_TO_ADAPTER_PRIV(AdapterObject);

	TRACE_ENTER();

	pAdPriv->minToCopy = nbytes;
	
#ifdef HAVE_AIRPCAP_API
	if(AdapterObject->Flags & INFO_FLAG_AIRPCAP_CARD)
	{
		Result = (BOOLEAN)g_PAirpcapSetMinToCopy(AdapterObject->AirpcapAd, nbytes);

		err = GetLastError();
		TRACE_EXIT();
		SetLastError(err);
		return Result;
	}
#endif // HAVE_AIRPCAP_API
	
	if (AdapterObject->Flags & INFO_FLAG_MASK_NOT_NPF)
	{
		TRACE_PRINT1("Request to set mintocopy on an unknown device type (%u)", AdapterObject->Flags);
		Result = FALSE;
		err = ERROR_NOT_SUPPORTED;
	}
	else
	{
		Result = (BOOLEAN)DeviceIoControl(AdapterObject->hFile,BIOCSMINTOCOPY,&nbytes,4,NULL,0,&BytesReturned,NULL);
		err = GetLastError();
	}
	
	TRACE_EXIT();
	SetLastError(err);
	return Result; 		
}

/*!
  \brief Sets the working mode of an adapter.
  \param AdapterObject Pointer to an _ADAPTER structure.
  \param mode The new working mode of the adapter.
  \return If the function succeeds, the return value is nonzero.

  The device driver of Npcap has 2 working modes:
  - Capture mode (mode = PACKET_MODE_CAPT): normal capture mode. The packets transiting on the wire are copied
   to the application when PacketReceivePacket() is called. This is the default working mode of an adapter.
  - Statistical mode (mode = PACKET_MODE_STAT): programmable statistical mode. PacketReceivePacket() returns, at
   precise intervals, statistics values on the network traffic. The interval between the statistic samples is 
   by default 1 second but it can be set to any other value (with a 1 ms precision) with the 
   PacketSetReadTimeout() function. The data returned by PacketReceivePacket() when the adapter is in statistical
   mode is shown in the following figure:<p>
   	 \image html stats.gif "data structure returned by statistical mode"
   Two 64-bit counters are provided: the number of packets and the amount of bytes that satisfy a filter 
   previously set with PacketSetBPF(). If no filter has been set, all the packets are counted. The counters are 
   encapsulated in a bpf_hdr structure, so that they will be parsed correctly by libpcap. Statistical mode has a 
   very low impact on system performance compared to capture mode. 
   Look at the NetMeter example in the 
   Npcap SDK to see how to use statistics mode.
*/
_Use_decl_annotations_
BOOLEAN PacketSetMode(LPADAPTER AdapterObject,int mode)
{
	DWORD BytesReturned;
	BOOLEAN Result;
	DWORD err = ERROR_SUCCESS;

   TRACE_ENTER();

#ifdef HAVE_AIRPCAP_API
   if (AdapterObject->Flags & INFO_FLAG_AIRPCAP_CARD)
   {
	   if (mode == PACKET_MODE_CAPT)
	   {
		   Result = TRUE;
	   }
	   else
	   {
		   Result = FALSE;
		   err = ERROR_NOT_SUPPORTED;
	   }

	   TRACE_EXIT();
	   SetLastError(err);
	   return Result;
   }
#endif //HAVE_AIRPCAP_API

   if (AdapterObject->Flags & INFO_FLAG_MASK_NOT_NPF)
   {
	   TRACE_PRINT1("Request to set mode on an unknown device type (%u)", AdapterObject->Flags);
	   Result = FALSE;
	   err = ERROR_NOT_SUPPORTED;
   }
   else
   {
		Result = (BOOLEAN)DeviceIoControl(AdapterObject->hFile,BIOCSMODE,&mode,4,NULL,0,&BytesReturned,NULL);
		err = GetLastError();
   }

   TRACE_EXIT();
   SetLastError(err);
   return Result;

}

/*!
  Dump mode functions not supported by Npcap
*/

BOOLEAN PacketSetDumpName(LPADAPTER AdapterObject, void *name, int len)
{
	TRACE_ENTER();
	UNREFERENCED_PARAMETER(AdapterObject);
	UNREFERENCED_PARAMETER(name);
	UNREFERENCED_PARAMETER(len);
	TRACE_EXIT();
	SetLastError(ERROR_NOT_SUPPORTED);
	return FALSE;
}
BOOLEAN PacketSetDumpLimits(LPADAPTER AdapterObject, UINT maxfilesize, UINT maxnpacks)
{
	TRACE_ENTER();
	UNREFERENCED_PARAMETER(AdapterObject);
	UNREFERENCED_PARAMETER(maxfilesize);
	UNREFERENCED_PARAMETER(maxnpacks);
	TRACE_EXIT();
	SetLastError(ERROR_NOT_SUPPORTED);
	return FALSE;
}
BOOLEAN PacketIsDumpEnded(LPADAPTER AdapterObject, BOOLEAN sync)
{
	TRACE_ENTER();
	UNREFERENCED_PARAMETER(AdapterObject);
	UNREFERENCED_PARAMETER(sync);
	TRACE_EXIT();
	SetLastError(ERROR_NOT_SUPPORTED);
	return FALSE;
}

/*!
  \brief Returns the notification event associated with the read calls on an adapter.
  \param AdapterObject Pointer to an _ADAPTER structure.
  \return The handle of the event that the driver signals when some data is available in the kernel buffer.

  The event returned by this function is signaled by the driver if:
  - The adapter pointed by AdapterObject is in capture mode and an amount of data greater or equal 
  than the one set with the PacketSetMinToCopy() function is received from the network.
  - The adapter is removed from the system.
  - The kernel buffer is full.

  As long as the event is in a signaled state, a call to PacketReceivePacket() will return immediately.
  Otherwise, PacketReceivePacket() itself will wait on the event to be signaled, until the timeout set by
  PacketSetReadTimeout() expires.
  The event can be passed to standard Win32 functions (like WaitForSingleObject or WaitForMultipleObjects) 
  to wait until the driver's buffer contains some data. It is particularly useful in GUI applications that 
  need to wait concurrently on several events.

*/
_Use_decl_annotations_
HANDLE PacketGetReadEvent(LPADAPTER AdapterObject)
{
	TRACE_ENTER();
	TRACE_EXIT();
    return AdapterObject->ReadEvent;
}

/*!
  \brief Sets the number of times a single packet written with PacketSendPacket() will be repeated on the network.
  \param AdapterObject Pointer to an _ADAPTER structure.
  \param nwrites Number of copies of a packet that will be physically sent by the interface.
  \return If the function succeeds, the return value is nonzero.

	See PacketSendPacket() for details.
*/
_Use_decl_annotations_
BOOLEAN PacketSetNumWrites(LPADAPTER AdapterObject,int nwrites)
{
	DWORD BytesReturned;
	BOOLEAN Result;
	DWORD err = ERROR_SUCCESS;

	TRACE_ENTER();

	if(AdapterObject->Flags & INFO_FLAG_MASK_NOT_NPF)
	{
		TRACE_PRINT("PacketSetNumWrites: not allowed on non-NPF adapters");
		TRACE_EXIT();
		SetLastError(ERROR_NOT_SUPPORTED);
		return FALSE;
	}

    Result = (BOOLEAN)DeviceIoControl(AdapterObject->hFile,BIOCSWRITEREP,&nwrites,4,NULL,0,&BytesReturned,NULL);
    err = GetLastError();

	TRACE_EXIT();
	SetLastError(err);
	return Result;
}

/*!
  \brief Sets the timeout after which a read on an adapter returns.
  \param AdapterObject Pointer to an _ADAPTER structure.
  \param timeout indicates the timeout, in milliseconds, after which a call to PacketReceivePacket() on 
  the adapter pointed by AdapterObject will be released, also if no packets have been captured by the driver. 
  Setting timeout to 0 means no timeout, i.e. PacketReceivePacket() never returns if no packet arrives.  
  A timeout of -1 causes PacketReceivePacket() to always return immediately.
  \return If the function succeeds, the return value is nonzero.

  \note This function works also if the adapter is working in statistics mode, and can be used to set the 
  time interval between two statistic reports.
*/
_Use_decl_annotations_
BOOLEAN PacketSetReadTimeout(LPADAPTER AdapterObject,int timeout)
{
	BOOLEAN Result;
	DWORD err = ERROR_SUCCESS;
	
	TRACE_ENTER();

	AdapterObject->ReadTimeOut = timeout;

#ifdef HAVE_AIRPCAP_API
	//
	// Timeout with AirPcap is handled at user level
	//
	if(AdapterObject->Flags & INFO_FLAG_AIRPCAP_CARD)
	{
		TRACE_EXIT();
		return TRUE;
	}
#endif // HAVE_AIRPCAP_API

	if(AdapterObject->Flags & INFO_FLAG_MASK_NOT_NPF)
	{
		//
		// if we are here, it's an unsupported ADAPTER type!
		//
		TRACE_PRINT1("Request to set read timeout on an unknown device type (%u)", AdapterObject->Flags);
		Result = FALSE;
		err = ERROR_NOT_SUPPORTED;
	}
	else
	{
		Result = TRUE;
	}

	TRACE_EXIT();
	SetLastError(err);
	return Result;
	
}

/*!
  \brief Sets the size of the kernel-level buffer associated with a capture.
  \param AdapterObject Pointer to an _ADAPTER structure.
  \param dim New size of the buffer, in \b kilobytes.
  \return The function returns TRUE if successfully completed, FALSE if there is not enough memory to 
   allocate the new buffer.

  When a new dimension is set, the data in the old buffer is discarded and the packets stored in it are 
  lost. 
  
  Note: the dimension of the kernel buffer affects heavily the performances of the capture process.
  An adequate buffer in the driver is able to keep the packets while the application is busy, compensating 
  the delays of the application and avoiding the loss of packets during bursts or high network activity. 
  The buffer size is set to 0 when an instance of the driver is opened: the programmer should remember to 
  set it to a proper value. As an example, wpcap sets the buffer size to 1MB at the beginning of a capture.
*/
_Use_decl_annotations_
BOOLEAN PacketSetBuff(LPADAPTER AdapterObject,int dim)
{
	DWORD BytesReturned;
	BOOLEAN Result;
	DWORD err = ERROR_SUCCESS;

	TRACE_ENTER();

#ifdef HAVE_AIRPCAP_API
	if(AdapterObject->Flags & INFO_FLAG_AIRPCAP_CARD)
	{
		Result = (BOOLEAN)g_PAirpcapSetKernelBuffer(AdapterObject->AirpcapAd, dim);
		err = GetLastError();
		
		TRACE_EXIT();
		SetLastError(err);
		return Result;
	}
#endif // HAVE_AIRPCAP_API

	if (AdapterObject->Flags & INFO_FLAG_MASK_NOT_NPF)
	{
		TRACE_PRINT1("Request to set buf size on an unknown device type (%u)", AdapterObject->Flags);
		Result = FALSE;
		err = ERROR_NOT_SUPPORTED;
	}
	else
	{
		Result = (BOOLEAN)DeviceIoControl(AdapterObject->hFile,BIOCSETBUFFERSIZE,&dim,sizeof(dim),NULL,0,&BytesReturned,NULL);
		err = GetLastError();
	}
	
	TRACE_EXIT();
	SetLastError(err);
	return Result;
}

/*!
  \brief Sets a kernel-level packet filter.
  \param AdapterObject Pointer to an _ADAPTER structure.
  \param fp Pointer to a filtering program that will be associated with this capture or monitoring 
  instance and that will be executed on every incoming packet.
  \return This function returns TRUE if the filter is set successfully, FALSE if an error occurs 
   or if the filter program is not accepted after a safeness check by the driver.  The driver performs 
   the check in order to avoid system crashes due to buggy or malicious filters, and it rejects non
   conformat filters.

  This function associates a new BPF filter to the adapter AdapterObject. The filter, pointed by fp, is a 
  set of bpf_insn instructions.

  A filter can be automatically created by using the pcap_compile() function of wpcap. This function 
  converts a human readable text expression with the tcpdump/libpcap syntax (see the manual of WinDump at 
  http://www.winpcap.org/windump for details) into a BPF program. If your program doesn't link wpcap, but 
  you need to know the code of a particular filter, you can run WinDump with the -d or -dd or -ddd 
  flags to obtain the pseudocode.

*/
_Use_decl_annotations_
BOOLEAN PacketSetBpf(LPADAPTER AdapterObject, struct bpf_program *fp)
{
	DWORD BytesReturned;
	BOOLEAN Result;
	DWORD err = ERROR_SUCCESS;
	
	TRACE_ENTER();
	
#ifdef HAVE_AIRPCAP_API
	if(AdapterObject->Flags & INFO_FLAG_AIRPCAP_CARD)
	{
		Result = (BOOLEAN)g_PAirpcapSetFilter(AdapterObject->AirpcapAd, 
			(char*)fp->bf_insns,
			fp->bf_len * sizeof(struct bpf_insn));
		err = GetLastError();

		TRACE_EXIT();
		SetLastError(err);
		return Result;
	}
#endif // HAVE_AIRPCAP_API

	if (AdapterObject->Flags & INFO_FLAG_MASK_NOT_NPF)
	{
		TRACE_PRINT1("Request to set BPF filter on an unknown device type (%u)", AdapterObject->Flags);
		Result = FALSE;
		err = ERROR_NOT_SUPPORTED;
	}
	else
	{
		Result = (BOOLEAN)DeviceIoControl(AdapterObject->hFile,BIOCSETF,(char*)fp->bf_insns,fp->bf_len*sizeof(struct bpf_insn),NULL,0,&BytesReturned,NULL);
		err = GetLastError();
	}
	
	TRACE_EXIT();
	SetLastError(err);
	return Result;
}

/*!
  \brief Sets the behavior of the NPF driver with packets sent by itself: capture or drop.
  \param AdapterObject Pointer to an _ADAPTER structure.
  \param LoopbackBehavior Can be one of the following:
	- \ref NPF_ENABLE_LOOPBACK
	- \ref NPF_DISABLE_LOOPBACK
  \return If the function succeeds, the return value is nonzero.

  \note: when opened, adapters have loopback capture \b enabled.
*/
_Use_decl_annotations_
BOOLEAN PacketSetLoopbackBehavior(LPADAPTER  AdapterObject, UINT LoopbackBehavior)
{
	DWORD BytesReturned;
	BOOLEAN result;
	DWORD err = ERROR_SUCCESS;

	TRACE_ENTER();

	if (AdapterObject->Flags & INFO_FLAG_MASK_NOT_NPF)
	{
		TRACE_PRINT("PacketSetLoopbackBehavior: not allowed on non-NPF adapters");
	
		TRACE_EXIT();
		SetLastError(ERROR_NOT_SUPPORTED);
		return FALSE;
	}


	result = (BOOLEAN)DeviceIoControl(AdapterObject->hFile,
		BIOCISETLOBBEH,
		&LoopbackBehavior,
		sizeof(UINT),
		NULL,
		0,
		&BytesReturned,
		NULL);
	err = GetLastError();

	TRACE_EXIT();
	SetLastError(err);
	return result;
}

/*!
\brief Sets the timestamp mode of an adapter handle.
\param AdapterObject Pointer to an _ADAPTER structure.
\param mode The new timestamp mode from the TIMESTAMPMODE_* definitions
\return TRUE if the function succeeds, FALSE otherwise.
*/
_Use_decl_annotations_
BOOLEAN PacketSetTimestampMode(LPADAPTER AdapterObject, ULONG mode)
{
	DWORD BytesReturned;
	BOOLEAN result;
	DWORD err = ERROR_SUCCESS;

	TRACE_ENTER();

	if (AdapterObject->Flags & INFO_FLAG_MASK_NOT_NPF)
	{
		TRACE_PRINT("PacketSetTimestampMode: not allowed on non-NPF adapters");
	
		TRACE_EXIT();
		SetLastError(ERROR_NOT_SUPPORTED);
		return FALSE;
	}


	result = (BOOLEAN)DeviceIoControl(AdapterObject->hFile,
		BIOCSTIMESTAMPMODE,
		&mode,
		sizeof(ULONG),
		NULL,
		0,
		&BytesReturned,
		NULL);
	err = GetLastError();

	TRACE_EXIT();
	SetLastError(err);
	return result;
}

/*!
  \brief Retrieve the list of supported timestamp modes on an adapter
  \param pModes User allocated array that will be filled with the available timestamp modes. First element is the length of the array.
  \return If the function succeeds, the return value is nonzero. If the return value is zero, pModes[0] contains 
          the number of ULONGs that are needed to contain the timestamp mode list.
	  */
_Use_decl_annotations_
BOOLEAN PacketGetTimestampModes(LPADAPTER AdapterObject, PULONG pModes)
{
	BOOLEAN result = FALSE;
	DWORD BytesReturned = 0;
	DWORD err = ERROR_SUCCESS;
	TRACE_ENTER();

	if (AdapterObject->Flags & INFO_FLAG_MASK_NOT_NPF)
	{
		*pModes = 0;
		TRACE_PRINT("PacketGetTimestampMode: not allowed on non-NPF adapters");
		TRACE_EXIT();
		SetLastError(ERROR_NOT_SUPPORTED);
		return FALSE;
	}

	result = (BOOLEAN)DeviceIoControl(AdapterObject->hFile,
			BIOCGTIMESTAMPMODES,
			NULL,
			0,
			pModes,
			pModes[0] * sizeof(ULONG),
			&BytesReturned,
			NULL);
	err = GetLastError();
	if (err != ERROR_MORE_DATA && BytesReturned != ((ULONGLONG)pModes[0] + 1) * sizeof(ULONG))
	{
		TRACE_PRINT2("PacketGetTimestampModes: Got %d bytes but expected %d!", BytesReturned, (pModes[0] + 1) * sizeof(ULONG));
		// Have to adjust to avoid reading bad data.
		pModes[0] = (BytesReturned / sizeof(ULONG)) - 1;
	}
	TRACE_EXIT();
	SetLastError(err);
	return result;
}

/*!
  \brief Sets the snap len on the adapters that allow it.
  \param AdapterObject Pointer to an _ADAPTER structure.
  \param snaplen Desired snap len for this capture.
  \return If the function succeeds, the return value is nonzero and specifies the actual snaplen that 
   the card is using. If the function fails or if the card does't allow to set sna length, the return 
   value is 0.

  The snap len is the amount of packet that is actually captured by the interface and received by the
  application. Some interfaces allow to capture only a portion of any packet for performance reasons.

  \note: the return value can be different from the snaplen parameter, for example some boards round the
  snaplen to 4 bytes.
*/
_Use_decl_annotations_
INT PacketSetSnapLen(LPADAPTER AdapterObject, int snaplen)
{
	INT Result;

	TRACE_ENTER();

	UNUSED(snaplen);
	UNUSED(AdapterObject);

	Result = 0;

	TRACE_EXIT();
	return Result;

}

/*!
  \brief Returns a couple of statistic values about the current capture session.
  \param AdapterObject Pointer to an _ADAPTER structure.
  \param s Pointer to a user provided bpf_stat structure that will be filled by the function.
  \return If the function succeeds, the return value is nonzero.

  With this function, the programmer can know the value of two internal variables of the driver:

  - the number of packets that have been received by the adapter AdapterObject, starting at the 
   time in which it was opened with PacketOpenAdapter. 
  - the number of packets that have been dropped by the driver. A packet is dropped when the kernel
   buffer associated with the adapter is full. 
*/
_Use_decl_annotations_
BOOLEAN PacketGetStats(LPADAPTER AdapterObject,struct bpf_stat *s)
{
	BOOLEAN Res;
	DWORD BytesReturned;
	DWORD err = ERROR_SUCCESS;
	struct bpf_stat tmpstat;	// We use a support structure to avoid kernel-level inconsistencies with old or malicious applications
	
	TRACE_ENTER();

#ifdef HAVE_AIRPCAP_API
	if(AdapterObject->Flags & INFO_FLAG_AIRPCAP_CARD)
	{
		AirpcapStats tas;

		Res = (BOOLEAN)g_PAirpcapGetStats(AdapterObject->AirpcapAd, &tas);
		
		if (Res)
		{
			//
			// Do NOT write this value. This function is probably called with a small structure, old style, containing only the first three fields recv, drop, ifdrop
			//
//			s->bs_capt = tas.Capt;
			s->bs_drop = tas.Drops;
			s->bs_recv = tas.Recvs;
			s->ps_ifdrop = tas.IfDrops;
		}
		else
		{
			err = GetLastError();
		}

		TRACE_EXIT();
		SetLastError(err);
		return Res;
	}
#endif // HAVE_AIRPCAP_API

	if (AdapterObject->Flags & INFO_FLAG_MASK_NOT_NPF)
	{	
		TRACE_PRINT1("Request to obtain statistics on an unknown device type (%u)", AdapterObject->Flags);
		Res = FALSE;
		err = ERROR_NOT_SUPPORTED;
	}
	else
	{
			Res = (BOOLEAN)DeviceIoControl(AdapterObject->hFile,
			BIOCGSTATS,
			NULL,
			0,
			&tmpstat,
			sizeof(struct bpf_stat),
			&BytesReturned,
			NULL);
		

		if (Res)
		{
			// Copy only the first two values retrieved from the driver
			s->bs_recv = tmpstat.bs_recv;
			s->bs_drop = tmpstat.bs_drop;
		}
		else
		{
			err = GetLastError();
		}

	}

	TRACE_EXIT();
	SetLastError(err);
	return Res;

}

/*!
  \brief Returns statistic values about the current capture session. Enhanced version of PacketGetStats().
  \param AdapterObject Pointer to an _ADAPTER structure.
  \param s Pointer to a user provided bpf_stat structure that will be filled by the function.
  \return If the function succeeds, the return value is nonzero.

  With this function, the programmer can retireve the sname values provided by PacketGetStats(), plus:

  - the number of drops by interface (not yet supported, always 0). 
  - the number of packets that reached the application, i.e that were accepted by the kernel filter and
  that fitted in the kernel buffer. 
*/
_Use_decl_annotations_
BOOLEAN PacketGetStatsEx(LPADAPTER AdapterObject,struct bpf_stat *s)
{
	BOOLEAN Res;
	DWORD BytesReturned;
	DWORD err = ERROR_SUCCESS;
	struct bpf_stat tmpstat;	// We use a support structure to avoid kernel-level inconsistencies with old or malicious applications

	TRACE_ENTER();

#ifdef HAVE_AIRPCAP_API
	if(AdapterObject->Flags & INFO_FLAG_AIRPCAP_CARD)
	{
		AirpcapStats tas;

		Res = (BOOLEAN)g_PAirpcapGetStats(AdapterObject->AirpcapAd, &tas);
		
		if (Res)
		{
			s->bs_capt = tas.Capt;
			s->bs_drop = tas.Drops;
			s->bs_recv = tas.Recvs;
			s->ps_ifdrop = tas.IfDrops;
		}
		else
		{
			err = GetLastError();
		}

		TRACE_EXIT();
		SetLastError(err);
		return Res;
	}
#endif // HAVE_AIRPCAP_API

	if (AdapterObject->Flags & INFO_FLAG_MASK_NOT_NPF)
	{	
		TRACE_PRINT1("Request to obtain statistics on an unknown device type (%u)", AdapterObject->Flags);
		Res = FALSE;
		err = ERROR_NOT_SUPPORTED;
	}
	else
	{
			Res = (BOOLEAN)DeviceIoControl(AdapterObject->hFile,
			BIOCGSTATS,
			NULL,
			0,
			&tmpstat,
			sizeof(struct bpf_stat),
			&BytesReturned,
			NULL);
		

		if (Res)
		{
			s->bs_recv = tmpstat.bs_recv;
			s->bs_drop = tmpstat.bs_drop;
			s->ps_ifdrop = tmpstat.ps_ifdrop;
			s->bs_capt = tmpstat.bs_capt;
		}
		else
		{
			err = GetLastError();
		}
	}

	TRACE_EXIT();
	SetLastError(err);
	return Res;

}

/*!
  \brief Performs a query/set operation on an internal variable of the network card driver.
  \param AdapterObject Pointer to an _ADAPTER structure.
  \param Set Determines if the operation is a set (Set=TRUE) or a query (Set=FALSE).
  \param OidData A pointer to a _PACKET_OID_DATA structure that contains or receives the data.
  \return If the function succeeds, the return value is nonzero.

  \note not all the network adapters implement all the query/set functions. There is a set of mandatory 
  OID functions that is granted to be present on all the adapters, and a set of facultative functions, not 
  provided by all the cards (see the Microsoft DDKs to see which functions are mandatory). If you use a 
  facultative function, be careful to enclose it in an if statement to check the result.
*/
_Use_decl_annotations_
BOOLEAN PacketRequest(LPADAPTER  AdapterObject,BOOLEAN Set,PPACKET_OID_DATA  OidData)
{
	DWORD err = ERROR_SUCCESS;
	TRACE_ENTER();

	if(AdapterObject->Flags & INFO_FLAG_MASK_NOT_NPF)
	{
		TRACE_PRINT("PacketRequest not supported on non-NPF adapters.");
		TRACE_EXIT();
		SetLastError(ERROR_NOT_SUPPORTED);
		return FALSE;
	}

	err = PacketRequestHelper(AdapterObject->hFile, Set, OidData);

	TRACE_EXIT();
	SetLastError(err);
	return (err == ERROR_SUCCESS);
}

/*!
  \brief Sets a hardware filter on the incoming packets.
  \param AdapterObject Pointer to an _ADAPTER structure.
  \param Filter The identifier of the filter.
  \return If the function succeeds, the return value is nonzero.

  The filter defined with this filter is evaluated by the network card, at a level that is under the NPF
  device driver. Here is a list of the most useful hardware filters (A complete list can be found in ntddndis.h):

  - NDIS_PACKET_TYPE_PROMISCUOUS: sets promiscuous mode. Every incoming packet is accepted by the adapter. 
  - NDIS_PACKET_TYPE_DIRECTED: only packets directed to the workstation's adapter are accepted. 
  - NDIS_PACKET_TYPE_BROADCAST: only broadcast packets are accepted. 
  - NDIS_PACKET_TYPE_MULTICAST: only multicast packets belonging to groups of which this adapter is a member are accepted. 
  - NDIS_PACKET_TYPE_ALL_MULTICAST: every multicast packet is accepted. 
  - NDIS_PACKET_TYPE_ALL_LOCAL: all local packets, i.e. NDIS_PACKET_TYPE_DIRECTED + NDIS_PACKET_TYPE_BROADCAST + NDIS_PACKET_TYPE_MULTICAST 
*/
_Use_decl_annotations_
BOOLEAN PacketSetHwFilter(LPADAPTER  AdapterObject,ULONG Filter)
{
    BOOLEAN    Status;
    DWORD err = ERROR_SUCCESS;
    CHAR IoCtlBuffer[PACKET_OID_DATA_LENGTH(sizeof(ULONG)) + PACKET_COMPAT_OID_LEN_DIFF] = { 0 };
    PPACKET_OID_DATA  OidData = (PPACKET_OID_DATA) IoCtlBuffer;
	
	TRACE_ENTER();

#ifdef HAVE_AIRPCAP_API
	if(AdapterObject->Flags & INFO_FLAG_AIRPCAP_CARD)
	{
		// Airpcap for the moment is always in promiscuous mode, and ignores any other filters
		return TRUE;
	}
#endif // HAVE_AIRPCAP_API

	if (AdapterObject->Flags & INFO_FLAG_MASK_NOT_NPF)
	{
		TRACE_PRINT1("Setting HW filter not supported on this adapter type (%u)", AdapterObject->Flags);
		Status = FALSE;
		err = ERROR_NOT_SUPPORTED;
	}
	else
	{
		OidData->Oid = OID_GEN_CURRENT_PACKET_FILTER;
		OidData->Length = sizeof(ULONG);
	    *((PULONG) OidData->Data) = Filter;
		Status = PacketRequest(AdapterObject, TRUE, OidData);
		err = GetLastError();
	}
	
	TRACE_EXIT();
	SetLastError(err);
    return Status;
}

/*!
  \brief Retrieve the list of available network adapters and their description.
  \param pStr User allocated string that will be filled with the names of the adapters.
  \param BufferSize Length of the buffer pointed by pStr. If the function fails, this variable contains the 
         number of bytes that are needed to contain the adapter list.
  \return If the function succeeds, the return value is nonzero. If the return value is zero, BufferSize contains 
          the number of bytes that are needed to contain the adapter list.

  Usually, this is the first function that should be used to communicate with the driver.
  It returns the names of the adapters installed on the system <B>and supported by WinPcap</B>. 
  After the names of the adapters, pStr contains a string that describes each of them.

  After a call to PacketGetAdapterNames pStr contains, in succession:
  - a variable number of ASCII strings, each with the names of an adapter, separated by a "\0"
  - a double "\0"
  - a number of ASCII strings, each with the description of an adapter, separated by a "\0". The number 
   of descriptions is the same of the one of names. The first description corresponds to the first name, and
   so on.
  - a double "\0". 
*/

_Use_decl_annotations_
BOOLEAN PacketGetAdapterNames(PCHAR pStr, PULONG  BufferSize)
{
	PADAPTER_INFO	TAdInfo;
	ULONG	SizeNeeded = 0;
	DWORD dwError = ERROR_SUCCESS;

	TRACE_ENTER();

	if (BufferSize == NULL) {
		SetLastError(ERROR_INVALID_PARAMETER);
		return FALSE;
	}

	TRACE_PRINT_OS_INFO();

	TRACE_PRINT2("Packet DLL version %hs, Driver version %hs", PacketLibraryVersion, PacketDriverVersion);

	TRACE_PRINT1("PacketGetAdapterNames: BufferSize=%u", *BufferSize);


#ifdef LOAD_OPTIONAL_LIBRARIES
	//
	// Check the presence on some libraries we rely on, and load them if we found them
	//f
	PacketLoadLibrariesDynamically();
#endif

	//d
	// Create the adapter information list
	//
	TRACE_PRINT("Populating the adapter list...");

	dwError = PacketPopulateAdaptersInfoList();

	if(dwError != ERROR_SUCCESS) 
	{
		*BufferSize = 0;

		TRACE_PRINT("No adapters found in the system. Failing.");
 	
 		TRACE_EXIT();
		SetLastError(dwError);
		return FALSE;		// No adapters to return
	}

	WaitForSingleObject(g_AdaptersInfoMutex, INFINITE);

	SizeNeeded = g_AdaptersInfoList.NamesLen + g_AdaptersInfoList.DescsLen;
	// Check that we don't overflow the buffer.
	if (pStr == NULL || SizeNeeded > *BufferSize)
	{
		ReleaseMutex(g_AdaptersInfoMutex);

		TRACE_PRINT2("PacketGetAdapterNames: input buffer too small (%u) need %u bytes", pStr ? *BufferSize : 0, SizeNeeded);
 
		*BufferSize = SizeNeeded;  // Report the required size

		TRACE_EXIT();
		SetLastError(ERROR_INSUFFICIENT_BUFFER);
		return FALSE;
	}

	// Leave 1 byte each for empty-string list terminators
	size_t cchNamesRemaining = g_AdaptersInfoList.NamesLen - 1;
	size_t cchDescsRemaining = g_AdaptersInfoList.DescsLen - 1;
	PCHAR pNames = pStr;
	PCHAR pDescs = pStr + g_AdaptersInfoList.NamesLen;
	HRESULT hrStatus = S_OK;
	// Copy the information
	for(TAdInfo = g_AdaptersInfoList.Adapters; TAdInfo != NULL; TAdInfo = TAdInfo->Next)
	{
		// Format the adapter name as "NPF_{XXX}" for compatibility with WinPcap, because some user softwares hard-coded the "NPF_" string
		hrStatus = StringCchPrintfExA(pNames, cchNamesRemaining,
				&pNames, // Receives pointer to null terminator at the end of the name
				&cchNamesRemaining, // Receives unused chars *including* null terminator.
				0,
#ifdef HAVE_AIRPCAP_API
				// Airpcap devices are reported as-is; all others get the WinPcap compatibility prefix.
				IsAirpcapName(TAdInfo->Name) ? "%s" :
#endif
				WINPCAP_COMPAT_DEVICE_PREFIX "%s",
				TAdInfo->Name);
		if (FAILED(hrStatus)) {
			break;
		}
		// skip null terminator
		pNames++;
		cchNamesRemaining--;

		// Copy the description
		hrStatus = StringCchCopyExA(
				pDescs,
				cchDescsRemaining,
				TAdInfo->Description,
				&pDescs,
				&cchDescsRemaining,
				0);
		if (FAILED(hrStatus)) {
			break;
		}
		// skip null terminator
		pDescs++;
		cchDescsRemaining--;
	}
	// Check that all copies succeeded
	if (FAILED(hrStatus)) {
		ReleaseMutex(g_AdaptersInfoMutex);

		TRACE_PRINT1("PacketGetAdapterNames: Copy of data failed: %08x", hrStatus);
 
		*BufferSize = SizeNeeded;  // Report the required size

		TRACE_EXIT();
		SetLastError(hrStatus == STRSAFE_E_INSUFFICIENT_BUFFER ? ERROR_INSUFFICIENT_BUFFER : ERROR_INVALID_PARAMETER);
		return FALSE;
	}

	// End each list with a null (empty string)
	*pNames = '\0';
	*pDescs = '\0';

	// There should be no reason for accounting errors in length of these strings.
	assert(cchDescsRemaining == 0);
	assert(cchNamesRemaining == 0);
// Save this code, but hope we never have to use it.
#define NAME_LENGTH_FIXUP 0
#if NAME_LENGTH_FIXUP
	// If we had leftover space for descriptions, adjust reported size (unexpected)
	SizeNeeded -= (ULONG) cchDescsRemaining;

	// If the names took up less space than we anticipated (due to adapters disappearing, etc.)
	// then we need to shift the descriptions to the left.
	if (cchNamesRemaining > 0) {
		// Copy from the original descriptions offset, shifting left by the remaining amount.
		for (ULONG i = g_AdaptersInfoList.NamesLen; i < SizeNeeded; i++) {
			pStr[i - cchNamesRemaining] = pStr[i];
		}
		// Adjust reported size
		SizeNeeded -= (ULONG) cchNamesRemaining;
	}
#endif

	ReleaseMutex(g_AdaptersInfoMutex);

	*BufferSize = SizeNeeded;  // Report the size we used

	TRACE_EXIT();
	return TRUE;
}

/*!
  \brief Returns comprehensive information the addresses of an adapter.
  \param AdapterName String that contains the name of the adapter.
  \param buffer A user allocated array of npf_if_addr that will be filled by the function.
  \param NEntries Size of the array (in npf_if_addr).
  \return If the function succeeds, the return value is nonzero.

  This function grabs from the registry information like the IP addresses, the netmasks 
  and the broadcast addresses of an interface. The buffer passed by the user is filled with 
  npf_if_addr structures, each of which contains the data for a single address. If the buffer
  is full, the reaming addresses are dropeed, therefore set its dimension to sizeof(npf_if_addr)
  if you want only the first address.
*/
_Use_decl_annotations_
BOOLEAN PacketGetNetInfoEx(PCCH AdapterName, npf_if_addr* buffer, PLONG NEntries)
{
	static ULONG MaxGAABufLen = ADAPTERS_ADDRESSES_INITIAL_BUFFER_SIZE;
	ULONG BufLen = MaxGAABufLen;
	PIP_ADAPTER_ADDRESSES AdBuffer = NULL, TmpAddr = NULL;
	PCHAR Tname = NULL;
	BOOLEAN Res = FALSE;
	DWORD err = ERROR_SUCCESS;

	TRACE_ENTER();

	if (!AdapterName || !buffer || *NEntries <= 0) {
		TRACE_EXIT();
		SetLastError(ERROR_INVALID_PARAMETER);
		return FALSE;
	}

	ZeroMemory(buffer, *NEntries * sizeof(npf_if_addr));

	// Provide conversion for backward compatibility
	if(AdapterName[1] == 0)
	{
		Tname = WChar2SChar((PWCHAR)AdapterName);
		if (Tname == NULL) {
			err = GetLastError();
			Res = FALSE;
			goto END_PacketGetNetInfoEx;
		}
		AdapterName = Tname;
	}

#ifdef HAVE_AIRPCAP_API
	// Airpcap devices don't have network addresses
	if (IsAirpcapName(AdapterName)) {
		*NEntries = 0;
		Res = TRUE;
		goto END_PacketGetNetInfoEx;
	}
#endif

	if (PacketIsLoopbackAdapter(AdapterName))
	{
		PCSTR end = NULL;
		struct sockaddr_in *pIPv4 = NULL;
		struct sockaddr_in6 *pIPv6 = NULL;
		NTSTATUS Status = 0;
		npf_if_addr* pIfAddr = NULL;

		*NEntries = min(2, *NEntries);
		switch (*NEntries) {
			case 2:
				// buffer[1] = ipv6;
				pIfAddr = &buffer[1];
				memset(pIfAddr, 0, sizeof(npf_if_addr));
				pIPv6 = (struct sockaddr_in6 *) &pIfAddr->IPAddress;
				Status = RtlIpv6StringToAddressA("::1", &end, &pIPv6->sin6_addr);
				if (!NT_SUCCESS(Status))
					break;
				pIPv6->sin6_family = AF_INET6;
				pIPv6 = (struct sockaddr_in6 *) &pIfAddr->SubnetMask;
				Status = RtlIpv6StringToAddressA("ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff", &end, &pIPv6->sin6_addr);
				if (!NT_SUCCESS(Status))
					break;
				pIPv6->sin6_family = AF_INET6;
			case 1:
				// buffer[0] = ipv4;
				pIfAddr = &buffer[0];
				memset(pIfAddr, 0, sizeof(npf_if_addr));
				pIPv4 = (struct sockaddr_in *) &pIfAddr->IPAddress;
				Status = RtlIpv4StringToAddressA("127.0.0.1", TRUE, &end, &pIPv4->sin_addr);
				if (!NT_SUCCESS(Status))
					break;
				pIPv4->sin_family = AF_INET;
				pIPv4 = (struct sockaddr_in *) &pIfAddr->SubnetMask;
				Status = RtlIpv4StringToAddressA("255.0.0.0", TRUE, &end, &pIPv4->sin_addr);
				if (!NT_SUCCESS(Status))
					break;
				pIPv4->sin_family = AF_INET;
			default:
				Res = TRUE;
				break;
		}
		if (!Res) {
			err = RtlNtStatusToDosError(Status);
		}
		goto END_PacketGetNetInfoEx;
	}

	PCCH AdapterGuid = strchr(AdapterName, '{');
	if (AdapterGuid == NULL)
	{
		err = ERROR_INVALID_NAME;
		goto END_PacketGetNetInfoEx;
	}

	AdBuffer = (PIP_ADAPTER_ADDRESSES)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, BufLen);
	if (AdBuffer == NULL)
	{
		err = ERROR_NOT_ENOUGH_MEMORY;
		goto END_PacketGetNetInfoEx;
	}
	ULONG RetVal = ERROR_SUCCESS;
	for (int i = 0; i < ADAPTERS_ADDRESSES_MAX_TRIES; i++)
	{

		RetVal = GetAdaptersAddresses(AF_UNSPEC,
			GAA_FLAG_SKIP_DNS_INFO | // Undocumented, reported to help avoid errors on Win10 1809
			// We don't use any of these features:
			GAA_FLAG_SKIP_DNS_SERVER |
			GAA_FLAG_SKIP_ANYCAST |
			GAA_FLAG_SKIP_MULTICAST |
			GAA_FLAG_SKIP_FRIENDLY_NAME, NULL, AdBuffer, &BufLen);
		if (RetVal == ERROR_BUFFER_OVERFLOW)
		{
			TRACE_PRINT("PacketGetNetInfoEx: GetAdaptersAddresses Too small buffer");
			TmpAddr = (PIP_ADAPTER_ADDRESSES)HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, AdBuffer, BufLen);
			if (TmpAddr == NULL)
			{
				err = ERROR_NOT_ENOUGH_MEMORY;
				goto END_PacketGetNetInfoEx;
			}
			AdBuffer = TmpAddr;
		}
		else
		{
			err = GetLastError();
			break;
		}
	}

	if (RetVal != ERROR_SUCCESS)
	{
		goto END_PacketGetNetInfoEx;
	}


	//
	// Now obtain the information about this adapter
	//
	for (TmpAddr=AdBuffer; TmpAddr != NULL; TmpAddr = TmpAddr->Next)
	{
		// If the adapter matches, stop
		if(_stricmp(TmpAddr->AdapterName, AdapterGuid) == 0)
		{
			break;
		}
	}
	if (TmpAddr == NULL)
	{
		// Not found
		goto END_PacketGetNetInfoEx;
	}

	// else found!
	Res = TRUE;
	PIP_ADAPTER_UNICAST_ADDRESS pAddr = TmpAddr->FirstUnicastAddress;
	LONG numEntries = 0;
	while (pAddr != NULL && numEntries < *NEntries)
	{
		ULONG ul = 0;
		npf_if_addr *pItem = &buffer[numEntries];

		// Copy the address (SOCKADDR, a.k.a. sockaddr_storage)
		memcpy(&pItem->IPAddress, pAddr->Address.lpSockaddr, pAddr->Address.iSockaddrLength);

		// Calculate subnet and broadcast
		if (pItem->IPAddress.ss_family == AF_INET && pAddr->OnLinkPrefixLength <= 32)
		{
			struct sockaddr_in* IfAddr = (struct sockaddr_in *)&pItem->IPAddress;
			struct sockaddr_in* Subnet = (struct sockaddr_in *)&pItem->SubnetMask;
			struct sockaddr_in* Broadcast = (struct sockaddr_in *)&pItem->Broadcast;
			Subnet->sin_family = Broadcast->sin_family = AF_INET;
			Subnet->sin_addr.S_un.S_addr = ul = _byteswap_ulong(0xffffffff << (32 - pAddr->OnLinkPrefixLength));
			Broadcast->sin_addr.S_un.S_addr = ~ul | IfAddr->sin_addr.S_un.S_addr;
		}
		else if (pItem->IPAddress.ss_family == AF_INET6 && pAddr->OnLinkPrefixLength <= 128)
		{
			struct sockaddr_in6* IfAddr = (struct sockaddr_in6 *)&pItem->IPAddress;
			struct sockaddr_in6* Subnet = (struct sockaddr_in6 *)&pItem->SubnetMask;
			struct sockaddr_in6* Broadcast = (struct sockaddr_in6 *)&pItem->Broadcast;
			Subnet->sin6_family = Broadcast->sin6_family = AF_INET6;
			memset(&Broadcast->sin6_addr, 0xff, sizeof(IN6_ADDR));
			for (int i = pAddr->OnLinkPrefixLength, j = 0; i > 0; i-=16, j++)
			{
				if (i > 16)
				{
					Subnet->sin6_addr.u.Word[j] = 0xffff;
					Broadcast->sin6_addr.u.Word[j] = IfAddr->sin6_addr.u.Word[j];
				}
				else
				{
					const WORD mask = _byteswap_ushort(0xffff << (16 - i));
					Subnet->sin6_addr.u.Word[j] = mask;
					Broadcast->sin6_addr.u.Word[j] = ~mask | IfAddr->sin6_addr.u.Word[j];
				}
			}
		}
		// else unsupported address family, no broadcast or netmask
		// Buffer is zeroed, so ss_family will be 0
		numEntries++;
		pAddr = pAddr->Next;
	}
	*NEntries = numEntries;
	
END_PacketGetNetInfoEx:
	if (!Res) {
		if (err == ERROR_SUCCESS)
			err = ERROR_BAD_UNIT;
		*NEntries = 0;
	}

	if(Tname)
		HeapFree(GetProcessHeap(), 0, Tname);
	if(AdBuffer)
		HeapFree(GetProcessHeap(), 0, AdBuffer);

	// Avoid minimizing buffer length in case new info is added.
	InterlockedMax(&MaxGAABufLen, BufLen);

	TRACE_EXIT();
	SetLastError(err);
	return Res;
}

/*! 
  \brief Returns information about the MAC type of an adapter.
  \param AdapterObject The adapter on which information is needed.
  \param type Pointer to a NetType structure that will be filled by the function.
  \return If the function succeeds, the return value is nonzero, otherwise the return value is zero.

  This function return the link layer and the speed (in bps) of an opened adapter.
  The LinkType field of the type parameter can have one of the following values:

  - NdisMedium802_3: Ethernet (802.3) 
  - NdisMediumWan: WAN 
  - NdisMedium802_5: Token Ring (802.5) 
  - NdisMediumFddi: FDDI 
  - NdisMediumAtm: ATM 
  - NdisMediumArcnet878_2: ARCNET (878.2) 
*/
_Use_decl_annotations_
BOOLEAN PacketGetNetType(LPADAPTER AdapterObject, NetType *type)
{
	DWORD err = ERROR_SUCCESS;
	CHAR IoCtlBuffer[PACKET_OID_DATA_LENGTH(sizeof(NDIS_LINK_SPEED)) + PACKET_COMPAT_OID_LEN_DIFF] = {0};

	TRACE_ENTER();
	if (type == NULL) {
		SetLastError(ERROR_INVALID_PARAMETER);
		return FALSE;
	}

#ifdef HAVE_AIRPCAP_API
	PAirpcapHandle AirpcapAd = PacketGetAirPcapHandle(AdapterObject);
#pragma warning(disable:26812)
	// Can't do anything about airpcap's enum type
	AirpcapLinkType AirpcapLinkLayer;
#pragma warning(default:26812)
	if (AirpcapAd)  {
		type->LinkType = (UINT)NdisMediumNull; // Note: custom linktype, NDIS doesn't provide an equivalent
		if (g_PAirpcapGetLinkType(AirpcapAd, &AirpcapLinkLayer)) {
			switch(AirpcapLinkLayer)
			{
				case AIRPCAP_LT_802_11:
					type->LinkType = (UINT)NdisMediumBare80211;
					break;
				case AIRPCAP_LT_802_11_PLUS_RADIO:
					type->LinkType = (UINT)NdisMediumRadio80211;
					break;
				case AIRPCAP_LT_802_11_PLUS_PPI:
					type->LinkType = (UINT)NdisMediumPpi;
					break;
				default:
					break;
			}
		}
	}
	else
#endif // HAVE_AIRPCAP_API
	{
		// If this is our loopback adapter, use static values.
		if (AdapterObject->Flags & INFO_FLAG_NPCAP_LOOPBACK) {
			type->LinkType = (UINT) NdisMediumNull;
		}
		// If this is a WIFI_ adapter, change the link type.
		else if (AdapterObject->Flags & INFO_FLAG_NPCAP_DOT11) {
			type->LinkType = (UINT)NdisMediumRadio80211;
		}
		else {
			//get the link-layer type
			PPACKET_OID_DATA OidData = (PPACKET_OID_DATA) IoCtlBuffer;

			OidData->Oid = OID_GEN_MEDIA_IN_USE;
			OidData->Length = sizeof (ULONG);
			if (!PacketRequest(AdapterObject, FALSE, OidData)) {
				err = GetLastError();
				TRACE_PRINT1("PacketGetLinkLayerFromRegistry error: %d", err);
			}
			else {
				type->LinkType=*((UINT*)OidData->Data);
			}
		}
	}

	// LinkSpeed is not supported
	type->LinkSpeed = 0;
	TRACE_EXIT();
	SetLastError(err);
	return (err == ERROR_SUCCESS);
}

/*! 
  \brief Returns whether an adapter is the Npcap Loopback Adapter
  \param AdapterObject The adapter on which information is needed.
  \return TRUE if yes, FALSE if no.

  Other software loopback adapters may exist, but they will not be identified with this function.
*/
_Use_decl_annotations_
BOOLEAN PacketIsLoopbackAdapter(PCCH AdapterName)
{
	BOOLEAN ret;
	PCCH AdapterGuid = AdapterName + sizeof(WINPCAP_COMPAT_DEVICE_PREFIX) - 1;

	TRACE_ENTER();

	if (0 != _strnicmp(AdapterName, WINPCAP_COMPAT_DEVICE_PREFIX, sizeof(WINPCAP_COMPAT_DEVICE_PREFIX) - 1)) {
		// The adapter name is too short or isn't a NPF device name
		ret = FALSE;
	}
	// Compare to NPF_Loopback
	else if (0 ==_stricmp(AdapterGuid, NPCAP_LOOPBACK_ADAPTER_BUILTIN) ||
			// or compare to value from Registry, if it was found.
			// Need to test explicitly for empty string, since we don't want to match an invalid device name.
			('\0' != g_strLoopbackAdapterName[0] &&
			 0 == _stricmp(g_strLoopbackAdapterName, AdapterGuid))
	   )
	{
		ret = TRUE;
	}
	else
	{
		ret = FALSE;
	}

	TRACE_EXIT();
	return ret;
}

/*!
\brief Returns whether a wireless adapter supports monitor mode.
\param AdapterObject The adapter on which information is needed.
\return 1 if yes, 0 if no, -1 if the function fails.
*/
_Use_decl_annotations_
int PacketIsMonitorModeSupported(PCCH AdapterName)
{
	HANDLE hAdapter;
	PCHAR AdapterID = NULL;
	CHAR IoCtlBuffer[PACKET_OID_DATA_LENGTH(sizeof(DOT11_OPERATION_MODE_CAPABILITY)) + PACKET_COMPAT_OID_LEN_DIFF] = { 0 };
	PPACKET_OID_DATA  OidData = (PPACKET_OID_DATA)IoCtlBuffer;
	PDOT11_OPERATION_MODE_CAPABILITY pOperationModeCapability;
	int mode;
	DWORD dwResult = ERROR_INVALID_DATA;

	TRACE_ENTER();

	AdapterID = NpcapGetAdapterID(AdapterName, NULL);
	if (AdapterID == NULL) {
		dwResult = GetLastError();
		TRACE_PRINT1("PacketIsMonitorModeSupported failed, NpcapGetAdapterID error %#x", dwResult);
		TRACE_EXIT();
		SetLastError(dwResult);
		return -1;
	}

	hAdapter = PacketGetAdapterHandle(AdapterID, NPF_OPEN_FLAG_WIFI);
	if (hAdapter == INVALID_HANDLE_VALUE)
	{
		dwResult = GetLastError();
		TRACE_PRINT("PacketIsMonitorModeSupported failed, PacketGetAdapterHandle error");
		TRACE_EXIT();
		HeapFree(GetProcessHeap(), 0, AdapterID);
		SetLastError(dwResult);
		return -1;
	}

	OidData->Oid = OID_DOT11_OPERATION_MODE_CAPABILITY;
	OidData->Length = sizeof(DOT11_OPERATION_MODE_CAPABILITY);
	dwResult = PacketRequestHelper(hAdapter, FALSE, OidData);
	if (dwResult == ERROR_SUCCESS)
	{
		pOperationModeCapability = (PDOT11_OPERATION_MODE_CAPABILITY) OidData->Data;
		if ((pOperationModeCapability->uOpModeCapability & DOT11_OPERATION_MODE_NETWORK_MONITOR) == DOT11_OPERATION_MODE_NETWORK_MONITOR)
		{
			mode = 1;
		}
		else
		{
			mode = 0;
		}
	}
	else
	{
		TRACE_PRINT("PacketIsMonitorModeSupported failed, PacketRequest error");
		mode = -1;
	}

	CloseHandle(hAdapter);
	HeapFree(GetProcessHeap(), 0, AdapterID);

	TRACE_PRINT2("PacketIsMonitorModeSupported: AdapterName = %hs, mode = %d", AdapterName, mode);

	TRACE_EXIT();
	SetLastError(dwResult);
	return mode;
}

/*!
\brief Sets the operation mode of an adapter.
\param AdapterObject Pointer to an _ADAPTER structure.
\param mode The new operation mode of the adapter, 1 for monitor mode, 0 for managed mode.
\return 1 if the function succeeds, 0 if monitor mode is not supported, -1 if the function fails with other errors.
*/
_Use_decl_annotations_
int PacketSetMonitorMode(PCCH AdapterName, int mode)
{
	int rval = 0;
	DWORD dwResult = ERROR_INVALID_DATA;
	PCHAR AdapterID = NULL;
	HANDLE hAdapter = INVALID_HANDLE_VALUE;
	CHAR IoCtlBuffer[PACKET_OID_DATA_LENGTH(sizeof(DOT11_CURRENT_OPERATION_MODE)) + PACKET_COMPAT_OID_LEN_DIFF] = { 0 };
	PPACKET_OID_DATA  OidData = (PPACKET_OID_DATA)IoCtlBuffer;
	PDOT11_CURRENT_OPERATION_MODE pOpMode = (PDOT11_CURRENT_OPERATION_MODE)OidData->Data;

	TRACE_ENTER();

	AdapterID = NpcapGetAdapterID(AdapterName, NULL);
	if (AdapterID == NULL) {
		dwResult = GetLastError();
		TRACE_PRINT1("PacketSetMonitorMode failed, NpcapGetAdapterID error %#x", dwResult);
		TRACE_EXIT();
		SetLastError(dwResult);
		return -1;
	}

	hAdapter = PacketGetAdapterHandle(AdapterID, NPF_OPEN_FLAG_WIFI);
	if (hAdapter == INVALID_HANDLE_VALUE)
	{
		dwResult = GetLastError();
		TRACE_PRINT("PacketSetMonitorMode failed, PacketGetAdapterHandle error");
		TRACE_EXIT();
		HeapFree(GetProcessHeap(), 0, AdapterID);
		SetLastError(dwResult);
		return -1;
	}

	const ULONG ulOperationMode = mode ? DOT11_OPERATION_MODE_NETWORK_MONITOR : DOT11_OPERATION_MODE_EXTENSIBLE_STATION;
	OidData->Oid = OID_DOT11_CURRENT_OPERATION_MODE;
	OidData->Length = sizeof(DOT11_CURRENT_OPERATION_MODE);
	pOpMode->uCurrentOpMode = ulOperationMode;
	dwResult = PacketRequestHelper(hAdapter, TRUE, OidData);

#ifndef NDIS_STATUS_INVALID_DATA
#define NDIS_STATUS_INVALID_DATA                ((NDIS_STATUS)0xC0010015L)
#define NDIS_STATUS_INVALID_OID                 ((NDIS_STATUS)0xC0010017L)
#endif
	switch ((NDIS_STATUS)dwResult)
	{
		case ERROR_SUCCESS:
			rval = 1;
			// Update the adapter's monitor mode in the global map.
			g_nbAdapterMonitorModes[AdapterID] = mode;
			break;
		case NDIS_STATUS_INVALID_DATA:
		case NDIS_STATUS_INVALID_OID:
			// Monitor mode is not supported.
			rval = 0;
			break;
		default:
			TRACE_PRINT("PacketSetMonitorMode failed, PacketRequest error");
			rval = -1;
			break;
	}

	HeapFree(GetProcessHeap(), 0, AdapterID);
	TRACE_EXIT();
	SetLastError(dwResult);
	return rval;
}

/*!
\brief Determine if the operation mode of an adapter is monitor mode.
\param AdapterObject Pointer to an _ADAPTER structure.
\param mode The new operation mode of the adapter, 1 for monitor mode, 0 for managed mode.
\return 1 if it's monitor mode, 0 if it's not monitor mode, -1 if the function fails.
*/
_Use_decl_annotations_
int PacketGetMonitorMode(PCCH AdapterName)
{
	int mode;
	HANDLE hAdapter = INVALID_HANDLE_VALUE;
	DWORD dwResult = ERROR_INVALID_DATA;
	CHAR IoCtlBuffer[PACKET_OID_DATA_LENGTH(sizeof(DOT11_CURRENT_OPERATION_MODE)) + PACKET_COMPAT_OID_LEN_DIFF] = { 0 };
	PPACKET_OID_DATA  OidData = (PPACKET_OID_DATA)IoCtlBuffer;
	PDOT11_CURRENT_OPERATION_MODE pOperationMode = (PDOT11_CURRENT_OPERATION_MODE)OidData->Data;
	PCHAR AdapterID = NULL;

	TRACE_ENTER();

	AdapterID = NpcapGetAdapterID(AdapterName, NULL);
	if (AdapterID == NULL) {
		dwResult = GetLastError();
		TRACE_PRINT1("PacketGetMonitorMode failed, NpcapGetAdapterID error %#x", dwResult);
		TRACE_EXIT();
		SetLastError(dwResult);
		return -1;
	}

	hAdapter = PacketGetAdapterHandle(AdapterID, NPF_OPEN_FLAG_WIFI);
	if (hAdapter == INVALID_HANDLE_VALUE)
	{
		dwResult = GetLastError();
		TRACE_PRINT("PacketSetMonitorMode failed, PacketGetAdapterHandle error");
		TRACE_EXIT();
		HeapFree(GetProcessHeap(), 0, AdapterID);
		SetLastError(dwResult);
		return -1;
	}

	OidData->Oid = OID_DOT11_CURRENT_OPERATION_MODE;
	OidData->Length = sizeof(DOT11_CURRENT_OPERATION_MODE);
	dwResult = PacketRequestHelper(hAdapter, FALSE, OidData);

	if (dwResult != ERROR_SUCCESS)
	{
		TRACE_PRINT("PacketGetMonitorMode failed, PacketRequest error");
		TRACE_EXIT();
		SetLastError(dwResult);
		return -1;
	}
	mode = (pOperationMode->uCurrentOpMode == DOT11_OPERATION_MODE_NETWORK_MONITOR) ? 1 : 0;

	// Update the adapter's monitor mode in the global map.
	g_nbAdapterMonitorModes[AdapterID] = mode;

	HeapFree(GetProcessHeap(), 0, AdapterID);
	TRACE_EXIT();
	return mode;
}

/*!
  \brief Returns the AirPcap handler associated with an adapter. This handler can be used to change
           the wireless-related settings of the CACE Technologies AirPcap wireless capture adapters.
  \param AdapterObject the open adapter whose AirPcap handler is needed.
  \return a pointer to an open AirPcap handle, used internally by the adapter pointed by AdapterObject.
          NULL if the libpcap adapter doesn't have wireless support through AirPcap.

  PacketGetAirPcapHandle() allows to obtain the airpcap handle of an open adapter. This handle can be used with
  the AirPcap API functions to perform wireless-releated operations, e.g. changing the channel or enabling 
  WEP decryption. For more details about the AirPcap wireless capture adapters, see 
  http://www.cacetech.com/products/airpcap.htm.
*/
_Use_decl_annotations_
PAirpcapHandle PacketGetAirPcapHandle(LPADAPTER AdapterObject)
{
	PAirpcapHandle handle = NULL;
	TRACE_ENTER();

#ifdef HAVE_AIRPCAP_API
	if (AdapterObject->Flags & INFO_FLAG_AIRPCAP_CARD)
	{
		handle = AdapterObject->AirpcapAd;
	}
#else
	UNUSED(AdapterObject);
#endif // HAVE_AIRPCAP_API

	TRACE_EXIT();
	return handle;
}

_Use_decl_annotations_
BOOLEAN PacketGetInfo(
		LPADAPTER AdapterObject,
		PPACKET_OID_DATA OidData)
{
	HANDLE hAdapter = INVALID_HANDLE_VALUE;
	BOOLEAN bCloseAdapter = FALSE;
	DWORD BytesReturned = 0;
	DWORD err = ERROR_SUCCESS;
	TRACE_ENTER();

	if (AdapterObject == NULL) {
		hAdapter = PacketGetAdapterHandle(NPCAP_LOOPBACK_ADAPTER_BUILTIN, 0);
		if (hAdapter == INVALID_HANDLE_VALUE) {
			return FALSE;
		}
		bCloseAdapter = TRUE;
	}
	else if(AdapterObject->Flags & INFO_FLAG_MASK_NOT_NPF)
	{
		TRACE_PRINT("PacketRequest not supported on non-NPF adapters.");
		TRACE_EXIT();
		SetLastError(ERROR_NOT_SUPPORTED);
		return FALSE;
	}
	else {
		hAdapter = AdapterObject->hFile;
	}

	if(!DeviceIoControl(hAdapter, BIOCGETINFO,
                           OidData, PACKET_COMPAT_OID_LEN(OidData->Length),
			   OidData, PACKET_COMPAT_OID_LEN(OidData->Length),
			   &BytesReturned, NULL))
	{
		err = GetLastError();
	}
	TRACE_PRINT3("PacketGetInfo: ID = 0x%.08x, Length = %d, ErrCode = 0x%.08x",
			OidData->Oid,
			OidData->Length,
			err);

	if (bCloseAdapter) {
		CloseHandle(hAdapter);
	}
	TRACE_EXIT();
	SetLastError(err);
	return (err == ERROR_SUCCESS);
}

/* @} */

```

`packetWin7/Dll/Project/Packet.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 2013
VisualStudioVersion = 12.0.40629.0
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Packet", "Packet.vcxproj", "{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug No AirPcap|Win32 = Debug No AirPcap|Win32
		Debug No AirPcap|x64 = Debug No AirPcap|x64
		Debug|Win32 = Debug|Win32
		Debug|x64 = Debug|x64
		OEM Release No AirPcap|Win32 = OEM Release No AirPcap|Win32
		OEM Release No AirPcap|x64 = OEM Release No AirPcap|x64
		Release LOG_TO_FILE|Win32 = Release LOG_TO_FILE|Win32
		Release LOG_TO_FILE|x64 = Release LOG_TO_FILE|x64
		Release No AirPcap|Win32 = Release No AirPcap|Win32
		Release No AirPcap|x64 = Release No AirPcap|x64
		Release|Win32 = Release|Win32
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Debug No AirPcap|Win32.ActiveCfg = Debug No AirPcap|Win32
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Debug No AirPcap|Win32.Build.0 = Debug No AirPcap|Win32
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Debug No AirPcap|x64.ActiveCfg = Debug No AirPcap|x64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Debug No AirPcap|x64.Build.0 = Debug No AirPcap|x64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Debug|Win32.ActiveCfg = Debug|Win32
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Debug|Win32.Build.0 = Debug|Win32
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Debug|x64.ActiveCfg = Debug|x64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Debug|x64.Build.0 = Debug|x64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.OEM Release No AirPcap|Win32.ActiveCfg = OEM Release No AirPcap|Win32
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.OEM Release No AirPcap|Win32.Build.0 = OEM Release No AirPcap|Win32
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.OEM Release No AirPcap|x64.ActiveCfg = OEM Release No AirPcap|x64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.OEM Release No AirPcap|x64.Build.0 = OEM Release No AirPcap|x64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Release LOG_TO_FILE|Win32.ActiveCfg = Release LOG_TO_FILE|Win32
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Release LOG_TO_FILE|Win32.Build.0 = Release LOG_TO_FILE|Win32
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Release LOG_TO_FILE|x64.ActiveCfg = Release LOG_TO_FILE|x64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Release LOG_TO_FILE|x64.Build.0 = Release LOG_TO_FILE|x64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Release No AirPcap|Win32.ActiveCfg = Release No AirPcap|Win32
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Release No AirPcap|Win32.Build.0 = Release No AirPcap|Win32
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Release No AirPcap|x64.ActiveCfg = Release No AirPcap|x64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Release No AirPcap|x64.Build.0 = Release No AirPcap|x64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Release|Win32.ActiveCfg = Release|Win32
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Release|Win32.Build.0 = Release|Win32
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Release|x64.ActiveCfg = Release|x64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`packetWin7/Dll/Project/Packet.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug No AirPcap|ARM64">
      <Configuration>Debug No AirPcap</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug No AirPcap|Win32">
      <Configuration>Debug No AirPcap</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug No AirPcap|x64">
      <Configuration>Debug No AirPcap</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="OEM Debug No AirPcap|ARM64">
      <Configuration>OEM Debug No AirPcap</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="OEM Debug No AirPcap|Win32">
      <Configuration>OEM Debug No AirPcap</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="OEM Debug No AirPcap|x64">
      <Configuration>OEM Debug No AirPcap</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="OEM Debug|ARM64">
      <Configuration>OEM Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="OEM Debug|Win32">
      <Configuration>OEM Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="OEM Debug|x64">
      <Configuration>OEM Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="OEM Release No AirPcap|ARM64">
      <Configuration>OEM Release No AirPcap</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="OEM Release No AirPcap|Win32">
      <Configuration>OEM Release No AirPcap</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="OEM Release No AirPcap|x64">
      <Configuration>OEM Release No AirPcap</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="OEM Release|ARM64">
      <Configuration>OEM Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="OEM Release|Win32">
      <Configuration>OEM Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="OEM Release|x64">
      <Configuration>OEM Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release LOG_TO_FILE|ARM64">
      <Configuration>Release LOG_TO_FILE</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release No AirPcap|ARM64">
      <Configuration>Release No AirPcap</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release No AirPcap|Win32">
      <Configuration>Release No AirPcap</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release No AirPcap|x64">
      <Configuration>Release No AirPcap</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release LOG_TO_FILE|Win32">
      <Configuration>Release LOG_TO_FILE</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release LOG_TO_FILE|x64">
      <Configuration>Release LOG_TO_FILE</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}</ProjectGuid>
    <RootNamespace>Packet</RootNamespace>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release No AirPcap|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release No AirPcap|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug No AirPcap|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release LOG_TO_FILE|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug No AirPcap|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release No AirPcap|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release No AirPcap|ARM64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release No AirPcap|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release|ARM64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release No AirPcap|ARM64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug No AirPcap|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug No AirPcap|ARM64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release LOG_TO_FILE|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release LOG_TO_FILE|ARM64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug No AirPcap|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug|ARM64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug No AirPcap|ARM64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release No AirPcap|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release No AirPcap|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug No AirPcap|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release LOG_TO_FILE|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug No AirPcap|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release No AirPcap|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release No AirPcap|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release No AirPcap|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release No AirPcap|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug No AirPcap|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug No AirPcap|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release LOG_TO_FILE|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release LOG_TO_FILE|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug No AirPcap|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug No AirPcap|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>10.0.40219.1</_ProjectFileVersion>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='OEM Debug|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='OEM Debug No AirPcap|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(Configuration)\</IntDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='OEM Debug|Win32'">$(Configuration)\</IntDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='OEM Debug No AirPcap|Win32'">$(Configuration)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='OEM Debug|Win32'">true</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='OEM Debug No AirPcap|Win32'">true</LinkIncremental>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='OEM Debug|x64'">$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='OEM Debug No AirPcap|x64'">$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='OEM Debug|ARM64'">$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='OEM Debug No AirPcap|ARM64'">$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(Platform)\$(Configuration)\</IntDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">$(Platform)\$(Configuration)\</IntDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='OEM Debug|x64'">$(Platform)\$(Configuration)\</IntDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='OEM Debug No AirPcap|x64'">$(Platform)\$(Configuration)\</IntDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='OEM Debug|ARM64'">$(Platform)\$(Configuration)\</IntDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='OEM Debug No AirPcap|ARM64'">$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">true</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='OEM Debug|x64'">true</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='OEM Debug No AirPcap|x64'">true</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='OEM Debug|ARM64'">true</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='OEM Debug No AirPcap|ARM64'">true</LinkIncremental>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(Configuration)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</LinkIncremental>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(Platform)\$(Configuration)\</IntDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">false</LinkIncremental>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release LOG_TO_FILE|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release LOG_TO_FILE|Win32'">$(Configuration)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release LOG_TO_FILE|Win32'">false</LinkIncremental>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release LOG_TO_FILE|x64'">$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release LOG_TO_FILE|ARM64'">$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release LOG_TO_FILE|x64'">$(Platform)\$(Configuration)\</IntDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release LOG_TO_FILE|ARM64'">$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release LOG_TO_FILE|x64'">false</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release LOG_TO_FILE|ARM64'">false</LinkIncremental>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug No AirPcap|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug No AirPcap|Win32'">$(Configuration)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug No AirPcap|Win32'">true</LinkIncremental>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug No AirPcap|x64'">$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug No AirPcap|ARM64'">$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug No AirPcap|x64'">$(Platform)\$(Configuration)\</IntDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug No AirPcap|ARM64'">$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug No AirPcap|x64'">true</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug No AirPcap|ARM64'">true</LinkIncremental>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release No AirPcap|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='OEM Release|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='OEM Release No AirPcap|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release No AirPcap|Win32'">$(Configuration)\</IntDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='OEM Release|Win32'">$(Configuration)\</IntDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='OEM Release No AirPcap|Win32'">$(Configuration)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release No AirPcap|Win32'">false</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='OEM Release|Win32'">false</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='OEM Release No AirPcap|Win32'">false</LinkIncremental>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release No AirPcap|x64'">$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release No AirPcap|ARM64'">$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='OEM Release|x64'">$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='OEM Release No AirPcap|x64'">$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='OEM Release|ARM64'">$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='OEM Release No AirPcap|ARM64'">$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release No AirPcap|x64'">$(Platform)\$(Configuration)\</IntDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release No AirPcap|ARM64'">$(Platform)\$(Configuration)\</IntDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='OEM Release|x64'">$(Platform)\$(Configuration)\</IntDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='OEM Release No AirPcap|x64'">$(Platform)\$(Configuration)\</IntDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='OEM Release|ARM64'">$(Platform)\$(Configuration)\</IntDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='OEM Release No AirPcap|ARM64'">$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release No AirPcap|x64'">false</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release No AirPcap|ARM64'">false</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='OEM Release|x64'">false</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='OEM Release No AirPcap|x64'">false</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='OEM Release|ARM64'">false</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='OEM Release No AirPcap|ARM64'">false</LinkIncremental>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug No AirPcap|Win32'">NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug No AirPcap|Win32'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug No AirPcap|Win32'" />
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug No AirPcap|x64'">NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug No AirPcap|ARM64'">NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug No AirPcap|x64'" />
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug No AirPcap|ARM64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug No AirPcap|x64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug No AirPcap|ARM64'" />
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='OEM Debug|Win32'">NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='OEM Debug No AirPcap|Win32'">NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='OEM Debug|Win32'" />
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='OEM Debug No AirPcap|Win32'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='OEM Debug|Win32'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='OEM Debug No AirPcap|Win32'" />
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='OEM Debug|x64'">NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='OEM Debug No AirPcap|x64'">NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='OEM Debug|ARM64'">NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='OEM Debug No AirPcap|ARM64'">NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" />
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='OEM Debug|x64'" />
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='OEM Debug No AirPcap|x64'" />
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='OEM Debug|ARM64'" />
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='OEM Debug No AirPcap|ARM64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='OEM Debug|x64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='OEM Debug No AirPcap|x64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='OEM Debug|ARM64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='OEM Debug No AirPcap|ARM64'" />
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release No AirPcap|Win32'">NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='OEM Release|Win32'">NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='OEM Release No AirPcap|Win32'">NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release No AirPcap|Win32'" />
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='OEM Release|Win32'" />
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='OEM Release No AirPcap|Win32'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release No AirPcap|Win32'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='OEM Release|Win32'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='OEM Release No AirPcap|Win32'" />
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release No AirPcap|x64'">NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release No AirPcap|ARM64'">NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='OEM Release|x64'">NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='OEM Release No AirPcap|x64'">NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='OEM Release|ARM64'">NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='OEM Release No AirPcap|ARM64'">NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release No AirPcap|x64'" />
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release No AirPcap|ARM64'" />
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='OEM Release|x64'" />
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='OEM Release No AirPcap|x64'" />
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='OEM Release|ARM64'" />
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='OEM Release No AirPcap|ARM64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release No AirPcap|x64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release No AirPcap|ARM64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='OEM Release|x64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='OEM Release No AirPcap|x64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='OEM Release|ARM64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='OEM Release No AirPcap|ARM64'" />
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release LOG_TO_FILE|Win32'">NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release LOG_TO_FILE|Win32'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release LOG_TO_FILE|Win32'" />
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release LOG_TO_FILE|x64'">NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release LOG_TO_FILE|ARM64'">NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release LOG_TO_FILE|x64'" />
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release LOG_TO_FILE|ARM64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release LOG_TO_FILE|x64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release LOG_TO_FILE|ARM64'" />
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|x64'">NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" />
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <AdditionalIncludeDirectories>..\..\..\Common;..\..\..\..\AirPcap_devpack\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>HAVE_AIRPCAP_API;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>version.lib;ntdll.lib;iphlpapi.lib;winmm.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ModuleDefinitionFile>..\packet.def</ModuleDefinitionFile>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <TargetMachine>MachineX86</TargetMachine>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug|Win32'">
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <AdditionalIncludeDirectories>..\..\..\Common;..\..\..\..\AirPcap_devpack\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NPCAP_OEM;HAVE_AIRPCAP_API;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>version.lib;ntdll.lib;iphlpapi.lib;winmm.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ModuleDefinitionFile>..\packet.def</ModuleDefinitionFile>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <TargetMachine>MachineX86</TargetMachine>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug No AirPcap|Win32'">
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <AdditionalIncludeDirectories>..\..\..\Common;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NPCAP_OEM;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>version.lib;ntdll.lib;iphlpapi.lib;winmm.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ModuleDefinitionFile>..\packet.def</ModuleDefinitionFile>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <TargetMachine>MachineX86</TargetMachine>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <AdditionalIncludeDirectories>..\..\..\Common;..\..\..\..\AirPcap_devpack\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>HAVE_AIRPCAP_API;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>version.lib;ntdll.lib;iphlpapi.lib;winmm.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ModuleDefinitionFile>..\packet.def</ModuleDefinitionFile>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <TargetMachine>MachineX64</TargetMachine>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Midl />
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <AdditionalIncludeDirectories>..\..\..\Common;..\..\..\..\AirPcap_devpack\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>HAVE_AIRPCAP_API;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>version.lib;ntdll.lib;iphlpapi.lib;winmm.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ModuleDefinitionFile>..\packet.def</ModuleDefinitionFile>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <AdditionalIncludeDirectories>..\..\..\Common;..\..\..\..\AirPcap_devpack\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NPCAP_OEM;HAVE_AIRPCAP_API;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>version.lib;ntdll.lib;iphlpapi.lib;winmm.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ModuleDefinitionFile>..\packet.def</ModuleDefinitionFile>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <TargetMachine>MachineX64</TargetMachine>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug No AirPcap|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <AdditionalIncludeDirectories>..\..\..\Common;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NPCAP_OEM;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>version.lib;ntdll.lib;iphlpapi.lib;winmm.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ModuleDefinitionFile>..\packet.def</ModuleDefinitionFile>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <TargetMachine>MachineX64</TargetMachine>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug|ARM64'">
    <Midl />
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <AdditionalIncludeDirectories>..\..\..\Common;..\..\..\..\AirPcap_devpack\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NPCAP_OEM;HAVE_AIRPCAP_API;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>version.lib;ntdll.lib;iphlpapi.lib;winmm.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ModuleDefinitionFile>..\packet.def</ModuleDefinitionFile>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug No AirPcap|ARM64'">
    <Midl />
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <AdditionalIncludeDirectories>..\..\..\Common;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NPCAP_OEM;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>version.lib;ntdll.lib;iphlpapi.lib;winmm.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ModuleDefinitionFile>..\packet.def</ModuleDefinitionFile>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <AdditionalIncludeDirectories>..\..\..\Common;..\..\..\..\AirPcap_devpack\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;HAVE_AIRPCAP_API;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>version.lib;ntdll.lib;iphlpapi.lib;winmm.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ModuleDefinitionFile>..\packet.def</ModuleDefinitionFile>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <TargetMachine>MachineX86</TargetMachine>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <AdditionalIncludeDirectories>..\..\..\Common;..\..\..\..\AirPcap_devpack\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;HAVE_AIRPCAP_API;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>version.lib;ntdll.lib;iphlpapi.lib;winmm.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ModuleDefinitionFile>..\packet.def</ModuleDefinitionFile>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <TargetMachine>MachineX64</TargetMachine>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Midl />
    <ClCompile>
      <AdditionalIncludeDirectories>..\..\..\Common;..\..\..\..\AirPcap_devpack\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;HAVE_AIRPCAP_API;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>version.lib;ntdll.lib;iphlpapi.lib;winmm.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ModuleDefinitionFile>..\packet.def</ModuleDefinitionFile>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release LOG_TO_FILE|Win32'">
    <ClCompile>
      <AdditionalIncludeDirectories>..\..\..\Common;..\..\..\..\AirPcap_devpack\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;HAVE_AIRPCAP_API;_DEBUG_TO_FILE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG_TO_FILE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>version.lib;ntdll.lib;iphlpapi.lib;winmm.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ModuleDefinitionFile>..\packet.def</ModuleDefinitionFile>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <TargetMachine>MachineX86</TargetMachine>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release LOG_TO_FILE|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <AdditionalIncludeDirectories>..\..\..\Common;..\..\..\..\AirPcap_devpack\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;HAVE_AIRPCAP_API;_DEBUG_TO_FILE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG_TO_FILE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>version.lib;ntdll.lib;iphlpapi.lib;winmm.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ModuleDefinitionFile>..\packet.def</ModuleDefinitionFile>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <TargetMachine>MachineX64</TargetMachine>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release LOG_TO_FILE|ARM64'">
    <Midl />
    <ClCompile>
      <AdditionalIncludeDirectories>..\..\..\Common;..\..\..\..\AirPcap_devpack\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;HAVE_AIRPCAP_API;_DEBUG_TO_FILE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG_TO_FILE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>version.lib;ntdll.lib;iphlpapi.lib;winmm.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ModuleDefinitionFile>..\packet.def</ModuleDefinitionFile>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug No AirPcap|Win32'">
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <WholeProgramOptimization>false</WholeProgramOptimization>
      <AdditionalIncludeDirectories>..\..\..\Common;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>version.lib;ntdll.lib;iphlpapi.lib;winmm.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>
      <ModuleDefinitionFile>..\packet.def</ModuleDefinitionFile>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>
      </OptimizeReferences>
      <EnableCOMDATFolding>
      </EnableCOMDATFolding>
      <LinkTimeCodeGeneration>
      </LinkTimeCodeGeneration>
      <TargetMachine>MachineX86</TargetMachine>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug No AirPcap|x64'">
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <WholeProgramOptimization>false</WholeProgramOptimization>
      <AdditionalIncludeDirectories>..\..\..\Common;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>version.lib;ntdll.lib;iphlpapi.lib;winmm.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ModuleDefinitionFile>..\packet.def</ModuleDefinitionFile>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <LinkTimeCodeGeneration>
      </LinkTimeCodeGeneration>
      <TargetMachine>MachineX64</TargetMachine>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug No AirPcap|ARM64'">
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <WholeProgramOptimization>false</WholeProgramOptimization>
      <AdditionalIncludeDirectories>..\..\..\Common;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>version.lib;ntdll.lib;iphlpapi.lib;winmm.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ModuleDefinitionFile>..\packet.def</ModuleDefinitionFile>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <LinkTimeCodeGeneration>
      </LinkTimeCodeGeneration>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release No AirPcap|Win32'">
    <ClCompile>
      <AdditionalIncludeDirectories>..\..\..\Common;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>version.lib;ntdll.lib;iphlpapi.lib;winmm.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ModuleDefinitionFile>..\packet.def</ModuleDefinitionFile>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <TargetMachine>MachineX86</TargetMachine>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release|Win32'">
    <ClCompile>
      <AdditionalIncludeDirectories>..\..\..\Common;..\..\..\..\AirPcap_devpack\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NPCAP_OEM;HAVE_AIRPCAP_API;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>version.lib;ntdll.lib;iphlpapi.lib;winmm.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ModuleDefinitionFile>..\packet.def</ModuleDefinitionFile>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <TargetMachine>MachineX86</TargetMachine>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release No AirPcap|Win32'">
    <ClCompile>
      <AdditionalIncludeDirectories>..\..\..\Common;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NPCAP_OEM;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>version.lib;ntdll.lib;iphlpapi.lib;winmm.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ModuleDefinitionFile>..\packet.def</ModuleDefinitionFile>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <TargetMachine>MachineX86</TargetMachine>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release No AirPcap|x64'">
    <ClCompile>
      <AdditionalIncludeDirectories>..\..\..\Common;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>version.lib;ntdll.lib;iphlpapi.lib;winmm.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ModuleDefinitionFile>..\packet.def</ModuleDefinitionFile>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <TargetMachine>MachineX64</TargetMachine>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release No AirPcap|ARM64'">
    <ClCompile>
      <AdditionalIncludeDirectories>..\..\..\Common;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>version.lib;ntdll.lib;iphlpapi.lib;winmm.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ModuleDefinitionFile>..\packet.def</ModuleDefinitionFile>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release|x64'">
    <ClCompile>
      <AdditionalIncludeDirectories>..\..\..\Common;..\..\..\..\AirPcap_devpack\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NPCAP_OEM;HAVE_AIRPCAP_API;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>version.lib;ntdll.lib;iphlpapi.lib;winmm.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ModuleDefinitionFile>..\packet.def</ModuleDefinitionFile>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <TargetMachine>MachineX64</TargetMachine>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release No AirPcap|x64'">
    <ClCompile>
      <AdditionalIncludeDirectories>..\..\..\Common;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NPCAP_OEM;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>version.lib;ntdll.lib;iphlpapi.lib;winmm.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ModuleDefinitionFile>..\packet.def</ModuleDefinitionFile>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <TargetMachine>MachineX64</TargetMachine>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release|ARM64'">
    <ClCompile>
      <AdditionalIncludeDirectories>..\..\..\Common;..\..\..\..\AirPcap_devpack\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NPCAP_OEM;HAVE_AIRPCAP_API;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>version.lib;ntdll.lib;iphlpapi.lib;winmm.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ModuleDefinitionFile>..\packet.def</ModuleDefinitionFile>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release No AirPcap|ARM64'">
    <ClCompile>
      <AdditionalIncludeDirectories>..\..\..\Common;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NPCAP_OEM;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>version.lib;ntdll.lib;iphlpapi.lib;winmm.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ModuleDefinitionFile>..\packet.def</ModuleDefinitionFile>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\AdInfo.cpp" />
    <ClCompile Include="..\Packet32.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\debug.h" />
    <ClInclude Include="..\Packet32-Int.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="..\version.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`packetWin7/Dll/Project/Packet.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\AdInfo.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\Packet32.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\debug.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\Packet32-Int.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="..\version.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`packetWin7/Dll/debug.h`:

```h
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
/*
 * Copyright (c) 2005 - 2006
 * CACE Technologies LLC, Davis (CA)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the company (CACE Technologies LLC) nor the 
 * names of its contributors may be used to endorse or promote products 
 * derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#ifndef __PACKET_DEBUG_393073863432093179878957
#define __PACKET_DEBUG_393073863432093179878957
#include <assert.h>
#if defined(_DBG) || defined(_DEBUG_TO_FILE)

#include <stdio.h>
#include <windows.h>

#include <tchar.h>

static VOID OutputDebugStringV(LPCTSTR Format, ...)
{
	FILE *f;
	SYSTEMTIME LocalTime;
	va_list Marker;
	DWORD dwThreadId;
	int loops = 0;
	const DWORD dwLastError = GetLastError();

	dwThreadId = GetCurrentThreadId();

	va_start(Marker, Format); /* Initialize variable arguments. */

	GetLocalTime(&LocalTime);

	do
	{

#ifdef _CONSOLE
		if (_tfopen_s(&f, _T("C:\\Program Files\\Npcap\\NPFInstall.log"), _T("a,ccs=UTF-8")) == 0)
#else
		if (_tfopen_s(&f, _T("C:\\Program Files\\Npcap\\Packet.log"), _T("a,ccs=UTF-8")) == 0)
#endif
			break;

		Sleep(0);
		loops++;
	} while (loops <= 10);

	if (loops > 10 || !f)
	{
		SetLastError(dwLastError);
		return;
	}

	_ftprintf(f, _T("[%.08X] %.04u-%.02u-%.02u %.02u:%02u:%02u "),
			dwThreadId,
			LocalTime.wYear,							
			LocalTime.wMonth,							
			LocalTime.wDay,								
			LocalTime.wHour,							
			LocalTime.wMinute,							
			LocalTime.wSecond);										
	_vftprintf(f, Format, Marker);
	
	fclose(f);											


	SetLastError(dwLastError);
}

#elif defined (_DBG)

#include <strsafe.h>

static VOID OutputDebugStringV(LPCTSTR Format, ...)
{
	va_list Marker;
	TCHAR string[1024];
	DWORD dwLastError = GetLastError();

	va_start(Marker, Format); /* Initialize variable arguments. */

	StringCchVPrintf(string, sizeof(string), Format, Marker);

	OutputDebugString(string);

	va_end(Marker);

	SetLastError(dwLastError);
}
#endif


#if defined(_DBG) || defined(_DEBUG_TO_FILE)

#define TRACE_ENTER()									OutputDebugStringV(_T("--> ") _T(__FUNCTION__) _T("\n"))
#define TRACE_EXIT()									OutputDebugStringV(_T("<-- ") _T(__FUNCTION__) _T("\n"))
#define TRACE_PRINT(_x)									OutputDebugStringV(_T("    ") _T(_x) _T("\n"))
#define TRACE_PRINT1(_x, _p1)							OutputDebugStringV(_T("    ") _T(_x) _T("\n"), _p1)
#define TRACE_PRINT2(_x, _p1, _p2)						OutputDebugStringV(_T("    ") _T(_x) _T("\n"), _p1, _p2)
#define TRACE_PRINT3(_x, _p1, _p2, _p3)					OutputDebugStringV(_T("    ") _T(_x) _T("\n"), _p1, _p2, _p3)
#define TRACE_PRINT4(_x, _p1, _p2, _p3, _p4)			OutputDebugStringV(_T("    ") _T(_x) _T("\n"), _p1, _p2, _p3, _p4)
#define TRACE_PRINT5(_x, _p1, _p2, _p3, _p4, _p5)		OutputDebugStringV(_T("    ") _T(_x) _T("\n"), _p1, _p2, _p3, _p4, _p5)
#define TRACE_PRINT6(_x, _p1, _p2, _p3, _p4, _p5, _p6)	OutputDebugStringV(_T("    ") _T(_x) _T("\n"), _p1, _p2, _p3, _p4, _p5, _p6)

static __forceinline void TRACE_PRINT_OS_INFO()
{
	HKEY	hKey;
	CHAR buffer[1024];
	DWORD size = sizeof(buffer);
	DWORD type;
	DWORD dwLastError;

	dwLastError = GetLastError();

	TRACE_PRINT("********************* OS info.*********************");
	buffer[size-1] = 0;
	if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment"), 0, KEY_READ, &hKey) == ERROR_SUCCESS)
	{
		if (RegQueryValueEx(hKey, _T("PROCESSOR_ARCHITECTURE"), 0, &type, (LPBYTE)buffer, &size) == ERROR_SUCCESS && type == REG_SZ)
		{
			OutputDebugStringV(_T("Architecture = %s\n"), buffer);
		}
		else
		{
			OutputDebugStringV(_T("Architecture = <UNKNOWN>\n"));
		}
		
		RegCloseKey(hKey);
	}
	else
	{
		OutputDebugStringV(_T("Architecture = <UNKNOWN>\n"));
	}

	size = sizeof(buffer);
	buffer[size-1] = 0;

	if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"), 0, KEY_READ, &hKey) == ERROR_SUCCESS)
	{
		if (RegQueryValueEx(hKey, _T("CurrentVersion"), 0, &type,  (LPBYTE)buffer, &size) == ERROR_SUCCESS && type == REG_SZ)
		{
			OutputDebugStringV(_T("Windows version = %s\n"), buffer);
		}
		else
		{
			OutputDebugStringV(_T("Windows version = <UNKNOWN>\n"));
		}
		
		RegCloseKey(hKey);
	}
	else
	{
		OutputDebugStringV(_T("Windows version = <UNKNOWN>\n"));
	}

	size = sizeof(buffer);
	buffer[size-1] = 0;
	if(	RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"), 0, KEY_READ, &hKey) == ERROR_SUCCESS)
	{
		if (RegQueryValueEx(hKey, _T("CurrentType"), 0, &type,  (LPBYTE)buffer, &size) == ERROR_SUCCESS && type == REG_SZ)
		{
			OutputDebugStringV(_T("Windows CurrentType = %s\n"), buffer);
		}
		else
		{
			OutputDebugStringV(_T("Windows CurrentType = <UNKNOWN>\n"));
		}
		
		RegCloseKey(hKey);
	}
	else
	{
		OutputDebugStringV(_T("Windows CurrentType = <UNKNOWN>\n"));
	}

	OutputDebugStringV(_T("*************************************************** \n"));

	SetLastError(dwLastError);
}
#else

#define TRACE_ENTER()
#define TRACE_EXIT()
#define TRACE_PRINT(_x)
#define TRACE_PRINT1(_x, _p1)
#define TRACE_PRINT2(_x, _p1, _p2)
#define TRACE_PRINT3(_x, _p1, _p2, _p3)
#define TRACE_PRINT4(_x, _p1, _p2, _p3, _p4)
#define TRACE_PRINT5(_x, _p1, _p2, _p3, _p4, _p5)
#define TRACE_PRINT6(_x, _p1, _p2, _p3, _p4, _p5, _p6)
#define TRACE_PRINT_WIDECHAR(_x)
#define TRACE_PRINT_OS_INFO()

#endif



#endif //__PACKET_DEBUG_393073863432093179878957

```

`packetWin7/Dll/version.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winresrc.h"
#ifndef IDC_STATIC
#define IDC_STATIC (-1)
#endif

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// Neutral resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_NEU)
#ifdef _WIN32
LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL
#pragma code_page(1252)
#endif //_WIN32

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""afxres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "#include ""version.rc2""\r\n"
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

#endif    // Neutral resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
#include "version.rc2"

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`packetWin7/Dll/version.rc2`:

```rc2
//
// version.rc2 - resources Microsoft Visual C++ does not edit directly
//

#ifdef APSTUDIO_INVOKED
	#error this file is not editable by Microsoft Visual C++
#endif //APSTUDIO_INVOKED


#include "..\..\version.h"

VS_VERSION_INFO VERSIONINFO
 FILEVERSION		WINPCAP_MAJOR,WINPCAP_MINOR,WINPCAP_REV,WINPCAP_BUILD
 PRODUCTVERSION		WINPCAP_MAJOR,WINPCAP_MINOR,WINPCAP_REV,WINPCAP_BUILD
 FILEFLAGSMASK VS_FFI_FILEFLAGSMASK
#if defined(_DEBUG) && defined(_DEBUG_TO_FILE)
 FILEFLAGS VS_FF_SPECIALBUILD | VS_FF_DEBUG
#elseif defined(_DEBUG)
 FILEFLAGS VS_FF_DEBUG
#elseif defined(_DEBUG_TO_FILE)
 FILEFLAGS VS_FF_SPECIALBUILD
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS_NT_WINDOWS32
 FILETYPE VFT_DLL
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "000004b0"
        BEGIN
			VALUE "CompanyName",       WINPCAP_COMPANY_NAME
			VALUE "FileDescription",   "The Packet API for Windows"
			VALUE "FileVersion",       WINPCAP_VER_STRING
			VALUE "InternalName",      "Packet.dll"
			VALUE "LegalCopyright",    WINPCAP_COPYRIGHT_STRING
			VALUE "LegalTrademarks",   ""
			VALUE "OriginalFilename",  "Packet.dll"
			VALUE "ProductName",       WINPCAP_PRODUCT_NAME
			VALUE "ProductVersion",    WINPCAP_VER_STRING
#ifdef _DEBUG_TO_FILE
			VALUE "SpecialBuild", "LOG_TO_FILE build"
#endif
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x0, 1200
    END
END

```

`packetWin7/DriverQuery/DriverQuery.c`:

```c
#include <stdio.h>
#define UM_NDIS685

#include <Packet32.h>
#pragma comment(lib, "packet.lib")

#include <ntddndis.h>
#include <tchar.h>
BOOL LoadNpcapDlls()
{
	TCHAR npcap_dir[512];
	UINT len;
	len = GetSystemDirectory(npcap_dir, 480);
	if (!len) {
		_ftprintf(stderr, _T("Error in GetSystemDirectory: %x"), GetLastError());
		return FALSE;
	}
	_tcscat_s(npcap_dir, 512, _T("\\Npcap"));
	if (SetDllDirectory(npcap_dir) == 0) {
		_ftprintf(stderr, _T("Error in SetDllDirectory: %x"), GetLastError());
		return FALSE;
	}
	return TRUE;
}

VOID hexDump(PVOID pMem, ULONG Len)
{
	PUCHAR data = (PUCHAR) pMem;
	for (ULONG i=0; i < Len; i++) {
		if (i % 4 == 0) {
			if (i % 8 == 0) {
				_tprintf(_T("\n%04X "), i);
			}
			else {
				_tprintf(_T(" "));
			}
		}
		_tprintf(_T(" %02x"), data[i]);
	}
	_tprintf(_T("\n"));
}

DWORD doPacketGetInfo(LPADAPTER pAd, ULONG ulID, PVOID pInfo, ULONG infoLen)
{
	PUCHAR IoCtlBuffer = NULL;
	PPACKET_OID_DATA  OidData = NULL;
	DWORD dwResult = ERROR_INVALID_DATA;

	// 0xffff is completely arbitrary, but works as a safeguard
	if (pInfo == NULL || infoLen < sizeof(ULONG) || infoLen > 0xffff) {
		return ERROR_INVALID_DATA;
	}

	IoCtlBuffer = (PUCHAR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
		       	PACKET_OID_DATA_LENGTH(infoLen));
	if (IoCtlBuffer == NULL) {
		return GetLastError();
	}

	OidData = (PPACKET_OID_DATA) IoCtlBuffer;
	OidData->Oid = ulID;
	OidData->Length = infoLen;
	CopyMemory(OidData->Data, pInfo, infoLen);
	if (!PacketGetInfo(pAd, OidData)) {
		HeapFree(GetProcessHeap(), 0, IoCtlBuffer);
		return GetLastError();
	}
	CopyMemory(pInfo, OidData->Data, infoLen);
	HeapFree(GetProcessHeap(), 0, IoCtlBuffer);
	return ERROR_SUCCESS;
}

VOID printAdapters()
{
	const char *name, *desc;
	char *AdapterNames;
	ULONG NameLength;

	NameLength = 0;
	if (!PacketGetAdapterNames(NULL, &NameLength))
	{
		DWORD last_error = GetLastError();

		if (last_error != ERROR_INSUFFICIENT_BUFFER)
		{
			_tprintf(_T("PacketGetAdapterNames(NULL) error: (%08x)\n"),
					last_error
				);
			return;
		}
	}

	if (NameLength <= 0)
		return;
	AdapterNames = (char*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, NameLength);
	if (AdapterNames == NULL)
	{
		_tprintf(_T("HeapAlloc error: (%08x)\n"),
				GetLastError()
			);
		return;
	}

	if (!PacketGetAdapterNames(AdapterNames, &NameLength)) {
		_tprintf(_T("PacketGetAdapterNames(NULL) error: (%08x)\n"),
				GetLastError()
			);
		HeapFree(GetProcessHeap(), 0, AdapterNames);
		return;
	}

	desc = AdapterNames;
	while (*desc != '\0' || *(desc + 1) != '\0')
		desc++;

	desc += 2;

	name = &AdapterNames[0];
	while (*name != '\0') {
		LPADAPTER dev = NULL;
		_tprintf(_T("%hs (%hs)\n"), name, desc);
		if (PacketIsLoopbackAdapter(name)) {
			goto next_name;
		}

		dev = PacketOpenAdapter(name);
		if (dev != NULL) {
			BOOLEAN Status = FALSE;
			size_t data_length = max(sizeof(NDIS_LINK_STATE), sizeof(NDIS_STATISTICS_INFO));
			data_length = max(data_length, sizeof(NDIS_RSC_STATISTICS_INFO));
			//data_length = max(data_length, sizeof(IP_OFFLOAD_STATS));
			data_length = max(data_length, sizeof(NDIS_OFFLOAD));
			//data_length = max(data_length, sizeof(NDIS_INTERRUPT_MODERATION_PARAMETERS));
			data_length = max(data_length, sizeof(NDIS_TIMESTAMP_CAPABILITIES));
			PPACKET_OID_DATA OidData = (PPACKET_OID_DATA) HeapAlloc(
					GetProcessHeap(),
					HEAP_ZERO_MEMORY,
					PACKET_OID_DATA_LENGTH(data_length)
					);
			if (OidData == NULL) {
				goto next_name;
			}

#define DO_OID_READ(_Oid, _StrOid, _Pre, _Block, _Length) do { \
	_Pre; \
	OidData->Oid = _Oid; \
	OidData->Length = _Length; \
	Status = PacketRequest(dev, FALSE, OidData); \
	if (Status) { \
		_tprintf(_T( _StrOid ": ")); \
		_Block; \
	} \
	else { \
		DWORD err = GetLastError(); \
		switch (err) { \
			case 0xe0010017: \
				_tprintf(_T( _StrOid " error: NDIS_STATUS_INVALID_OID\n")); \
				break; \
			case 0xe00000BB: \
				_tprintf(_T( _StrOid " error: STATUS_NOT_SUPPORTED\n")); \
				break; \
			case 0xe0000001: \
				_tprintf(_T( _StrOid " error: STATUS_INVALID_DEVICE_REQUEST\n")); \
				break; \
			case 0x00000001: \
				_tprintf(_T( _StrOid " error: ERROR_INVALID_FUNCTION\n")); \
				break; \
			default: \
				_tprintf(_T( _StrOid " error: %08x\n"), err); \
				break; \
		} \
	} \
} while (0);

#define DO_OID_READ_ULONG(_Oid) DO_OID_READ(_Oid, #_Oid, ZeroMemory(OidData->Data, data_length),  \
	       	_tprintf(_T("%08x\n"), *(ULONG *)OidData->Data), \
	       	sizeof(ULONG))

#define NOP (void)0
#define DO_OID_READ_HEXDUMP(_Oid, _Length, _Extra) DO_OID_READ(_Oid, #_Oid, do { \
	ZeroMemory(OidData->Data, data_length); \
	_Extra; \
	} while (0);, \
		hexDump(OidData->Data, OidData->Length), \
		_Length)

			DO_OID_READ_ULONG(OID_GEN_DRIVER_VERSION);
			USHORT NdisVersion = *(USHORT *)OidData->Data;
			DO_OID_READ_ULONG(OID_GEN_RCV_OK);
			DO_OID_READ_ULONG(OID_GEN_RCV_NO_BUFFER);
			DO_OID_READ_ULONG(OID_GEN_RECEIVE_BUFFER_SPACE);
			DO_OID_READ_ULONG(OID_GEN_RECEIVE_BLOCK_SIZE);
			DO_OID_READ_ULONG(OID_GEN_XMIT_OK);
			DO_OID_READ_ULONG(OID_GEN_TRANSMIT_BUFFER_SPACE);
			DO_OID_READ_ULONG(OID_GEN_TRANSMIT_QUEUE_LENGTH);
			DO_OID_READ_ULONG(OID_GEN_TRANSMIT_BLOCK_SIZE);

			DO_OID_READ_ULONG(OID_GEN_CURRENT_PACKET_FILTER);
			DO_OID_READ_ULONG(OID_GEN_MAXIMUM_TOTAL_SIZE);
			DO_OID_READ_ULONG(OID_GEN_CURRENT_LOOKAHEAD);

#define SET_NDIS_OBJ(_Type, _Rev, _Size) do { \
	((NDIS_OBJECT_HEADER *)(OidData->Data))->Type = _Type; \
	((NDIS_OBJECT_HEADER *)(OidData->Data))->Revision = _Rev; \
	((NDIS_OBJECT_HEADER *)(OidData->Data))->Size = _Size; \
} while (0);

			//DO_OID_READ_HEXDUMP(OID_IP4_OFFLOAD_STATS, sizeof(IP_OFFLOAD_STATS));
			//DO_OID_READ_HEXDUMP(OID_IP6_OFFLOAD_STATS, sizeof(IP_OFFLOAD_STATS));
			DO_OID_READ_HEXDUMP(OID_TCP_OFFLOAD_CURRENT_CONFIG,
					sizeof(NDIS_OFFLOAD),
					SET_NDIS_OBJ(NDIS_OBJECT_TYPE_OFFLOAD,
						NDIS_OFFLOAD_REVISION_6,
						NDIS_SIZEOF_NDIS_OFFLOAD_REVISION_6));

			DO_OID_READ_ULONG(OID_GEN_PHYSICAL_MEDIUM_EX);
			DO_OID_READ_HEXDUMP(OID_GEN_MEDIA_IN_USE, 3 * sizeof(ULONG), NOP);

			DO_OID_READ_HEXDUMP(OID_GEN_LINK_STATE,
					sizeof(NDIS_LINK_STATE),
					SET_NDIS_OBJ(NDIS_OBJECT_TYPE_DEFAULT,
						NDIS_LINK_STATE_REVISION_1,
						NDIS_SIZEOF_LINK_STATE_REVISION_1));

			DO_OID_READ_HEXDUMP(OID_GEN_STATISTICS,
					sizeof(NDIS_STATISTICS_INFO),
					SET_NDIS_OBJ(NDIS_OBJECT_TYPE_DEFAULT,
						NDIS_STATISTICS_INFO_REVISION_1,
						NDIS_SIZEOF_STATISTICS_INFO_REVISION_1));

			DO_OID_READ_HEXDUMP(OID_TCP_RSC_STATISTICS,
					sizeof(NDIS_RSC_STATISTICS_INFO),
					SET_NDIS_OBJ(NDIS_OBJECT_TYPE_DEFAULT,
						NDIS_RSC_STATISTICS_REVISION_1,
						NDIS_SIZEOF_RSC_STATISTICS_REVISION_1));

			/* // Always fails?
			DO_OID_READ_HEXDUMP(OID_GEN_INTERRUPT_MODERATION,
					sizeof(NDIS_INTERRUPT_MODERATION_PARAMETERS),
					SET_NDIS_OBJ(NDIS_OBJECT_TYPE_DEFAULT,
						NDIS_INTERRUPT_MODERATION_PARAMETERS_REVISION_1,
						NDIS_SIZEOF_INTERRUPT_MODERATION_PARAMETERS_REVISION_1));
						*/

			DO_OID_READ_HEXDUMP(OID_TIMESTAMP_CAPABILITY,
					sizeof(NDIS_TIMESTAMP_CAPABILITIES),
					SET_NDIS_OBJ(NDIS_OBJECT_TYPE_DEFAULT,
						NDIS_TIMESTAMP_CAPABILITIES_REVISION_1,
						NDIS_SIZEOF_TIMESTAMP_CAPABILITIES_REVISION_1));

#ifdef NPF_GETINFO_MODDBG
			ULONG ulInfo = 0;
			DWORD err = ERROR_SUCCESS;
#define MODDBG(_SubName) do { \
	ulInfo = _SubName; \
	err = doPacketGetInfo(dev, NPF_GETINFO_MODDBG, &ulInfo, sizeof(ulInfo)); \
	if (err == ERROR_SUCCESS) { \
		_tprintf(_T( #_SubName ": %08x\n"), ulInfo); \
	} \
	else { \
		_tprintf(_T("PacketGetInfo(NPF_GETINFO_MODDBG / " #_SubName ") error: %08x\n"), \
				GetLastError()); \
	} \
} while (0);

			MODDBG(NPF_MODDBG_PF_SUPPORTED);
			MODDBG(NPF_MODDBG_PF_MY);
			MODDBG(NPF_MODDBG_PF_HIGHER);
			MODDBG(NPF_MODDBG_LA_MY);
			MODDBG(NPF_MODDBG_LA_HIGHER);
			MODDBG(NPF_MODDBG_BITS);
			MODDBG(NPF_MODDBG_MAXFRAME);
			MODDBG(NPF_MODDBG_NUMOPENS);
#endif
			HeapFree(GetProcessHeap(), 0, OidData);
			PacketCloseAdapter(dev);
		}
		else {
			_tprintf(_T("\tFAILED: %08x\n"), GetLastError());
		}
next_name:
		name += strlen(name) + 1;
		desc += strlen(desc) + 1;
	}

	HeapFree(GetProcessHeap(), 0, AdapterNames);
	return;
}

int main()
{
	/* Load Npcap and its functions. */
	if (!LoadNpcapDlls())
	{
		_ftprintf(stderr, _T("Couldn't load Npcap\n"));
		exit(1);
	}

	//
	// Obtain the name of the adapters installed on this machine
	//

	_tprintf(_T("Packet.dll test application.\n"));
       	_tprintf(_T("Library version: %hs\n"), PacketGetVersion());
       	_tprintf(_T("Driver version: %hs\n"), PacketGetDriverVersion());
	
	ULONG ulInfo = 0;
	USHORT usStat[2] = {0};
	PULONG pulWhere = NULL;
	DWORD err = ERROR_SUCCESS;
	ULONG ulVersion = 0;

#define _GETINFO(_Name, _strName, _SubName, _strSubName, _Ptr, _Size, _Minver, _Block) do { \
	pulWhere = (ULONG *) _Ptr; \
	*pulWhere = _SubName; \
	err = doPacketGetInfo(NULL, _Name, pulWhere, _Size); \
	if (err == ERROR_SUCCESS) { \
		_Block; \
	} \
	else if (ulVersion > _Minver) { \
		_tprintf(_T("PacketGetInfo(" _strName " / " _strSubName ") error: %08x\n"), \
				GetLastError()); \
	} \
} while (0);

#define GETINFO(_Name, _Var) _GETINFO(_Name, #_Name, 0, "", &_Var, sizeof(ULONG), 0, \
		_tprintf(_T( #_Name ": %08x\n"), _Var) )

	GETINFO(NPF_GETINFO_VERSION, ulVersion);

	GETINFO(NPF_GETINFO_CONFIG, ulInfo);
	GETINFO(NPF_GETINFO_BPFEXT, ulInfo);
	GETINFO(NPF_GETINFO_MODES, ulInfo);

#define GETSTATS(_Name) _GETINFO(NPF_GETINFO_STATS, "NPF_GETINFO_STATS", \
		_Name, #_Name, usStat, 2 * sizeof(USHORT), 0x01540000, \
		_tprintf(_T( #_Name ": %hu, %hu\n"), usStat[0], usStat[1]) )

	GETSTATS(NPF_STATSINFO_RECVTIMES);
	GETSTATS(NPF_STATSINFO_SENDTIMES);
	GETSTATS(NPF_STATSINFO_DPCTIMES);

	_tprintf(_T("Adapters installed:\n"));
	printAdapters();

	return (0);
}

```

`packetWin7/DriverQuery/DriverQuery.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//

#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
#ifdef _WIN32
LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL
#pragma code_page(1252)
#endif //_WIN32

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE  
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE  
BEGIN
    "#include ""version.rc2""\r\n"
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
#include "version.rc2"


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED

```

`packetWin7/DriverQuery/DriverQuery.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{c87689c8-9cee-4e97-953c-7c981385522f}</ProjectGuid>
    <RootNamespace>DriverQuery</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>..\..\Common;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <DelayLoadDLLs>Packet.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>..\vs14\Release;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>..\..\Common;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <DelayLoadDLLs>Packet.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>..\vs14\Release;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>..\..\Common;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <DelayLoadDLLs>Packet.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>..\vs14\x64\Release;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>..\..\Common;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <DelayLoadDLLs>Packet.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>..\vs14\arm64\Release No AirPcap;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>..\..\Common;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <DelayLoadDLLs>Packet.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>..\vs14\x64\Release;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>..\..\Common;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <DelayLoadDLLs>Packet.dll</DelayLoadDLLs>
      <AdditionalLibraryDirectories>..\vs14\arm64\Release No AirPcap;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="DriverQuery.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="resource.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="DriverQuery.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`packetWin7/DriverQuery/DriverQuery.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="DriverQuery.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="DriverQuery.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`packetWin7/DriverQuery/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by DriverQuery.rc

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`packetWin7/DriverQuery/version.rc2`:

```rc2
//
// version.rc2 - resources Microsoft Visual C++ does not edit directly
//

#ifdef APSTUDIO_INVOKED
	#error this file is not editable by Microsoft Visual C++
#endif //APSTUDIO_INVOKED


#include "..\..\version.h"

VS_VERSION_INFO VERSIONINFO
 FILEVERSION		WINPCAP_MAJOR,WINPCAP_MINOR,WINPCAP_REV,WINPCAP_BUILD
 PRODUCTVERSION		WINPCAP_MAJOR,WINPCAP_MINOR,WINPCAP_REV,WINPCAP_BUILD
 FILEFLAGSMASK VS_FFI_FILEFLAGSMASK
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS_NT_WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "000004b0"
        BEGIN
			VALUE "CompanyName",       WINPCAP_COMPANY_NAME
			VALUE "FileDescription",   "Diagnostic and Debugging query tool for Npcap"
			VALUE "FileVersion",       WINPCAP_VER_STRING
			VALUE "InternalName",      "DriverQuery.exe"
			VALUE "LegalCopyright",    WINPCAP_COPYRIGHT_STRING
			VALUE "LegalTrademarks",   ""
			VALUE "OriginalFilename",  "DriverQuery.exe"
			VALUE "ProductName",       WINPCAP_PRODUCT_NAME
			VALUE "ProductVersion",    WINPCAP_VER_STRING
            VALUE "Build Description", WINPCAP_BUILD_DESCRIPTION
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x0, 1200
    END
END

```

`packetWin7/Helper/NpcapHelper.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 2013
VisualStudioVersion = 12.0.40629.0
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "NpcapHelper", "NpcapHelper\NpcapHelper.vcxproj", "{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "NpcapHelperTest", "NpcapHelperTest\NpcapHelperTest.vcxproj", "{3F697FA8-4C35-416C-A381-2631AAB79D39}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Debug|x64 = Debug|x64
		OEM Release|Win32 = OEM Release|Win32
		OEM Release|x64 = OEM Release|x64
		Release|Win32 = Release|Win32
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Debug|Win32.ActiveCfg = Debug|Win32
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Debug|Win32.Build.0 = Debug|Win32
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Debug|x64.ActiveCfg = Debug|x64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Debug|x64.Build.0 = Debug|x64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.OEM Release|Win32.ActiveCfg = OEM Release|Win32
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.OEM Release|Win32.Build.0 = OEM Release|Win32
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.OEM Release|x64.ActiveCfg = OEM Release|x64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.OEM Release|x64.Build.0 = OEM Release|x64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Release|Win32.ActiveCfg = Release|Win32
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Release|Win32.Build.0 = Release|Win32
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Release|x64.ActiveCfg = Release|x64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Release|x64.Build.0 = Release|x64
		{3F697FA8-4C35-416C-A381-2631AAB79D39}.Debug|Win32.ActiveCfg = Debug|Win32
		{3F697FA8-4C35-416C-A381-2631AAB79D39}.Debug|Win32.Build.0 = Debug|Win32
		{3F697FA8-4C35-416C-A381-2631AAB79D39}.Debug|x64.ActiveCfg = Debug|x64
		{3F697FA8-4C35-416C-A381-2631AAB79D39}.Debug|x64.Build.0 = Debug|x64
		{3F697FA8-4C35-416C-A381-2631AAB79D39}.OEM Release|Win32.ActiveCfg = Release|Win32
		{3F697FA8-4C35-416C-A381-2631AAB79D39}.OEM Release|Win32.Build.0 = Release|Win32
		{3F697FA8-4C35-416C-A381-2631AAB79D39}.OEM Release|x64.ActiveCfg = Release|x64
		{3F697FA8-4C35-416C-A381-2631AAB79D39}.OEM Release|x64.Build.0 = Release|x64
		{3F697FA8-4C35-416C-A381-2631AAB79D39}.Release|Win32.ActiveCfg = Release|Win32
		{3F697FA8-4C35-416C-A381-2631AAB79D39}.Release|Win32.Build.0 = Release|Win32
		{3F697FA8-4C35-416C-A381-2631AAB79D39}.Release|x64.ActiveCfg = Release|x64
		{3F697FA8-4C35-416C-A381-2631AAB79D39}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`packetWin7/Helper/NpcapHelper/NpcapHelper.cpp`:

```cpp
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
/***************************************************************************
 * NpcapHelper.cpp -- A program used to fetch driver handles for packet.dll*
 * , it is started by packet.dll and uses Named Pipe to communicate with   *
 * packet.dll. This is for "Admin-only mode", as packet.dll runs on        *
 * non-Admin level and NpcapHelper.exe runs on Admin level. If user denies *
 * the UAC prompt, NpcapHelper.exe will not start.                         *
 *                                                                         *
 * This program is based on Microsoft example:                             *
 * https://msdn.microsoft.com/en-us/library/windows/desktop/aa365592%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396
 * https://msdn.microsoft.com/en-us/library/windows/desktop/aa365588%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396
 ***************************************************************************/

#include <stdio.h>
#include <tchar.h>
#include <windows.h>
#include <strsafe.h>
//#define _DBG
#include "../debug.h"

#define BUFSIZE 512

#pragma comment(linker, "/subsystem:\"windows\" /entry:\"mainCRTStartup\"")

int g_sourcePID = 0;

typedef struct _DeviceCache
{
	CHAR SymbolicLinkA[BUFSIZE];
	HANDLE handle;
	_DeviceCache *next;
} DeviceCache;

DeviceCache *g_DeviceCache = NULL;

DWORD WINAPI InstanceThread(LPVOID);

VOID GetAnswerToRequest(_In_reads_bytes_(BUFSIZE) LPCSTR pchRequest,
	_Out_writes_bytes_to_(BUFSIZE, *pchBytes) LPSTR pchReply,
	LPDWORD pchBytes);


void terminateSelf() noexcept
{
	HANDLE hself = GetCurrentProcess();
	TerminateProcess(hself, 0);
}

_Must_inspect_result_
_Success_(return != INVALID_HANDLE_VALUE)
HANDLE getDeviceHandleInternal(_In_ LPCSTR SymbolicLinkA, _Out_ _On_failure_(_Out_range_(1,MAXDWORD)) DWORD *pdwError)
{
	HANDLE hFile = CreateFileA(SymbolicLinkA, GENERIC_WRITE | GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, 0);
	HANDLE hFileDup;
	BOOL bResult;
	HANDLE hClientProcess;

	TRACE_PRINT1("Original handle: %08p.\n", hFile);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		*pdwError = GetLastError();
		TRACE_PRINT1("CreateFileA failed, GLE=%d.\n", *pdwError);
		return INVALID_HANDLE_VALUE;
	}
	hClientProcess = OpenProcess(PROCESS_DUP_HANDLE, FALSE, g_sourcePID);
	if (hClientProcess == NULL)
	{
		*pdwError = GetLastError();
		TRACE_PRINT1("OpenProcess failed, GLE=%d.\n", *pdwError);
		CloseHandle(hFile);
		return INVALID_HANDLE_VALUE;
	}

	bResult = DuplicateHandle(GetCurrentProcess(), 
		hFile, 
		hClientProcess,
		&hFileDup, 
		GENERIC_WRITE | GENERIC_READ,
		FALSE,
		// hFile will be closed regardless of error:
		DUPLICATE_CLOSE_SOURCE);

	if (!bResult)
	{
		TRACE_PRINT1("DuplicateHandle failed, GLE=%d.\n", GetLastError());
		*pdwError = 1234;
		return INVALID_HANDLE_VALUE;
	}
	else
	{
		TRACE_PRINT1("Duplicated handle: %08p.\n", hFileDup);
		*pdwError = 0;
		return hFileDup;
	}
}

BOOL createPipe(LPCSTR pipeName) noexcept
{
	BOOL   fConnected = FALSE; 
	DWORD  dwThreadId = 0; 
	HANDLE hPipe = INVALID_HANDLE_VALUE, hThread = NULL; 
	HANDLE hHeap = GetProcessHeap();
	char lpszPipename[BUFSIZE];
	sprintf_s(lpszPipename, BUFSIZE, "\\\\.\\pipe\\%s", pipeName);
	
	// Create a DACL that allows only the same user as the PID we were given to access the pipe
	HANDLE hProc = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, g_sourcePID);
	if (hProc == NULL)
	{
		TRACE_PRINT1("OpenProcess(PROCESS_QUERY_INFORMATION) failed: %#x\n", GetLastError());
		return FALSE;
	}
	HANDLE hToken;
	if (!OpenProcessToken(hProc, TOKEN_READ, &hToken))
	{
		TRACE_PRINT1("OpenProcessToken(TOKEN_READ) failed: %#x\n", GetLastError());
		CloseHandle(hProc);
		return FALSE;
	}
	struct {
		TOKEN_USER tokenUser;
		BYTE buffer[SECURITY_MAX_SID_SIZE];
	} tokenInfoBuffer;
	DWORD dwTokenSize;
	ZeroMemory(&tokenInfoBuffer, sizeof(tokenInfoBuffer));
	if (!GetTokenInformation(hToken, TokenUser, &tokenInfoBuffer.tokenUser, sizeof(tokenInfoBuffer), &dwTokenSize))
	{
		TRACE_PRINT1("GetTokenInformation failed: %#x\n", GetLastError());
		CloseHandle(hToken);
		CloseHandle(hProc);
		return FALSE;
	}
	CloseHandle(hToken);
	CloseHandle(hProc);
	if (!IsValidSid(tokenInfoBuffer.tokenUser.User.Sid))
	{
		TRACE_PRINT("Invalid owner SID\n");
		return FALSE;
	}
	SECURITY_DESCRIPTOR sd;
	if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION))
	{
		TRACE_PRINT1("InitializeSecurityDescriptor failed: %#x\n", GetLastError());
		return FALSE;
	}
	DWORD cbDacl = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD);
	cbDacl += GetLengthSid(tokenInfoBuffer.tokenUser.User.Sid);
	PACL pDacl = (PACL) HeapAlloc(hHeap, 0, cbDacl);
	if (pDacl == NULL)
	{
		TRACE_PRINT("Allocate for DACL failed\n");
		return FALSE;
	}
	if (!InitializeAcl(pDacl,cbDacl,ACL_REVISION))
	{
		TRACE_PRINT1("InitializeACL failed: %#x\n", GetLastError());
		HeapFree(hHeap, 0, pDacl);
		return FALSE;
	}
	if (!AddAccessAllowedAce(pDacl, ACL_REVISION, GENERIC_ALL, tokenInfoBuffer.tokenUser.User.Sid))
	{
		TRACE_PRINT1("AddAccessAllowedAce failed: %#x\n", GetLastError());
		HeapFree(hHeap, 0, pDacl);
		return FALSE;
	}
	if (!SetSecurityDescriptorDacl(&sd, TRUE, pDacl, FALSE))
	{
		TRACE_PRINT1("SetSecurityDescriptorDacl failed: %#x\n", GetLastError());
		return FALSE;
	}
	SECURITY_ATTRIBUTES sa = { sizeof sa, &sd, FALSE };
	// The main loop creates an instance of the named pipe and 
	// then waits for a client to connect to it. When the client 
	// connects, a thread is created to handle communications 
	// with that client, and this loop is free to wait for the
	// next client connect request. It is an infinite loop.

	for (;;) 
	{ 

		TRACE_PRINT1("\nPipe Server: Main thread awaiting client connection on %s\n", lpszPipename);
		hPipe = CreateNamedPipeA( 
			lpszPipename,             // pipe name 
			PIPE_ACCESS_DUPLEX,       // read/write access 
			PIPE_TYPE_MESSAGE |       // message type pipe 
			PIPE_READMODE_MESSAGE |   // message-read mode 
			PIPE_WAIT,                // blocking mode 
			PIPE_UNLIMITED_INSTANCES, // max. instances  
			BUFSIZE,                  // output buffer size 
			BUFSIZE,                  // input buffer size 
			0,                        // client time-out 
			&sa);                    // default security attribute 

		if (hPipe == INVALID_HANDLE_VALUE) 
		{
			TRACE_PRINT1("CreateNamedPipe failed, GLE=%d.\n", GetLastError());
			return FALSE;
		}

		// Wait for the client to connect; if it succeeds, 
		// the function returns a nonzero value. If the function
		// returns zero, GetLastError returns ERROR_PIPE_CONNECTED. 

		fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED); 

		if (fConnected) 
		{ 
			TRACE_PRINT("Client connected, creating a processing thread.\n");

			// Create a thread for this client. 
			hThread = CreateThread( 
				NULL,              // no security attribute 
				0,                 // default stack size 
				InstanceThread,    // thread proc
				(LPVOID) hPipe,    // thread parameter 
				0,                 // not suspended 
				&dwThreadId);      // returns thread ID 

			if (hThread == NULL) 
			{
				TRACE_PRINT1("CreateThread failed, GLE=%d.\n", GetLastError());
				return FALSE;
			}
			else CloseHandle(hThread); 
		} 
		else 
			// The client could not connect, so close the pipe. 
			CloseHandle(hPipe); 
	}
	HeapFree(hHeap, 0, pDacl);
	return TRUE; 
}

DWORD WINAPI InstanceThread(LPVOID lpvParam)
// This routine is a thread processing function to read from and reply to a client
// via the open pipe connection passed from the main loop. Note this allows
// the main loop to continue executing, potentially creating more threads of
// of this procedure to run concurrently, depending on the number of incoming
// client connections.
{ 
	HANDLE hHeap      = GetProcessHeap();
	char* pchRequest = (char*) HeapAlloc(hHeap, 0, BUFSIZE * sizeof(TCHAR));
	char* pchReply   = (char*) HeapAlloc(hHeap, 0, BUFSIZE * sizeof(char));

	DWORD cbBytesRead = 0, cbReplyBytes = 0, cbWritten = 0; 
	BOOL fSuccess = FALSE;
	HANDLE hPipe  = NULL;
	TRACE_ENTER("InstanceThread");

	// Do some extra error checking since the app will keep running even if this
	// thread fails.

	if (lpvParam == NULL)
	{
		TRACE_PRINT( "\nERROR - Pipe Server Failure:\n");
		TRACE_PRINT( "   InstanceThread got an unexpected NULL value in lpvParam.\n");
		TRACE_PRINT( "   InstanceThread exitting.\n");
		if (pchReply != NULL) HeapFree(hHeap, 0, pchReply);
		if (pchRequest != NULL) HeapFree(hHeap, 0, pchRequest);
		return (DWORD)-1;
	}

	if (pchRequest == NULL)
	{
		TRACE_PRINT( "\nERROR - Pipe Server Failure:\n");
		TRACE_PRINT( "   InstanceThread got an unexpected NULL heap allocation.\n");
		TRACE_PRINT( "   InstanceThread exitting.\n");
		if (pchReply != NULL) HeapFree(hHeap, 0, pchReply);
		return (DWORD)-1;
	}

	if (pchReply == NULL)
	{
		TRACE_PRINT( "\nERROR - Pipe Server Failure:\n");
		TRACE_PRINT( "   InstanceThread got an unexpected NULL heap allocation.\n");
		TRACE_PRINT( "   InstanceThread exitting.\n");
		if (pchRequest != NULL) HeapFree(hHeap, 0, pchRequest);
		return (DWORD)-1;
	}

	// Print verbose messages. In production code, this should be for debugging only.
	TRACE_PRINT("InstanceThread created, receiving and processing messages.\n");

	// The thread's parameter is a handle to a pipe object instance. 

	hPipe = (HANDLE) lpvParam; 

	// Loop until done reading
	while (1) 
	{ 
		// Read client requests from the pipe. This simplistic code only allows messages
		// up to BUFSIZE characters in length.
		fSuccess = ReadFile( 
			hPipe,        // handle to pipe 
			pchRequest,    // buffer to receive data 
			BUFSIZE*sizeof(TCHAR), // size of buffer 
			&cbBytesRead, // number of bytes read 
			NULL);        // not overlapped I/O 

		if (!fSuccess || cbBytesRead == 0)
		{   
			if (GetLastError() == ERROR_BROKEN_PIPE)
			{
				TRACE_PRINT("InstanceThread: client disconnected.\n");
			}
			else
			{
				TRACE_PRINT1("InstanceThread ReadFile failed, GLE=%d.\n", GetLastError());
			}
			break;
		}

		// Process the incoming message.
		GetAnswerToRequest(pchRequest, pchReply, &cbReplyBytes); 

		// Write the reply to the pipe. 
		fSuccess = WriteFile( 
			hPipe,        // handle to pipe 
			pchReply,     // buffer to write from 
			cbReplyBytes, // number of bytes to write 
			&cbWritten,   // number of bytes written 
			NULL);        // not overlapped I/O 

		if (!fSuccess || cbReplyBytes != cbWritten)
		{   
			TRACE_PRINT1("InstanceThread WriteFile failed, GLE=%d.\n", GetLastError());
			break;
		}
	}

	// Flush the pipe to allow the client to read the pipe's contents 
	// before disconnecting. Then disconnect the pipe, and close the 
	// handle to this pipe instance. 

	FlushFileBuffers(hPipe); 
	DisconnectNamedPipe(hPipe); 
	CloseHandle(hPipe); 

	HeapFree(hHeap, 0, pchRequest);
	HeapFree(hHeap, 0, pchReply);

	TRACE_EXIT("InstanceThread");
	terminateSelf();
	return 1;
}

_Use_decl_annotations_
VOID GetAnswerToRequest( LPCSTR pchRequest,
						LPSTR pchReply, 
						LPDWORD pchBytes )
						// This routine is a simple function to print the client request to the console
						// and populate the reply buffer with a default data string. This is where you
						// would put the actual client request processing code that runs in the context
						// of an instance thread. Keep in mind the main thread will continue to wait for
						// and receive other client connections while the instance thread is working.
{
	TRACE_PRINT1("Client Request String:\"%s\"\n", pchRequest);

	DWORD dwError;
	HANDLE hFile = getDeviceHandleInternal(pchRequest, &dwError);
	TRACE_PRINT1("Driver Handle: %0p\n", hFile);
	if (hFile)
	{
		char buf[BUFSIZE];
		sprintf_s(buf, BUFSIZE, "%p,%lu", hFile, dwError);
		strcpy_s(pchReply, BUFSIZE, buf);
		*pchBytes = (DWORD) strlen(buf) * sizeof(char);
	}
	else
	{
		// Check the outgoing message to make sure it's not too long for the buffer.
		if (FAILED(StringCchCopyA( pchReply, BUFSIZE, "default answer from server")))
		{
			*pchBytes = 0;
			pchReply[0] = 0;
			TRACE_PRINT("StringCchCopy failed, no outgoing message.\n");
			return;
		}
		*pchBytes = (DWORD) (strlen(pchReply) + 1) * sizeof(char);
	}
}

int main(int argc, char* argv[])
{
	char *pipeName = NULL;
	if (argc != 3)
	{
		return -1;
	}
	else
	{
		pipeName = argv[1];
		g_sourcePID = atoi(argv[2]);
	}

	createPipe(pipeName);

#pragma warning(suppress: 6031)
	getchar();
	return 0;
}


```

`packetWin7/Helper/NpcapHelper/NpcapHelper.exe.manifest.in`:

```in
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!-- Windows 7 -->
      <supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}"/>
      <!-- Windows 8 -->
      <supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}"/>
      <!-- Windows 8.1 -->
      <supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}"/>
      <!-- Windows 10 -->
      <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
    </application>
  </compatibility>
</assembly>

```

`packetWin7/Helper/NpcapHelper/NpcapHelper.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="OEM Debug|ARM64">
      <Configuration>OEM Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="OEM Debug|Win32">
      <Configuration>OEM Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="OEM Debug|x64">
      <Configuration>OEM Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="OEM Release|ARM64">
      <Configuration>OEM Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="OEM Release|Win32">
      <Configuration>OEM Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="OEM Release|x64">
      <Configuration>OEM Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}</ProjectGuid>
    <RootNamespace>NpcapHelper</RootNamespace>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>10.0.40219.1</_ProjectFileVersion>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='OEM Debug|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(Configuration)\</IntDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='OEM Debug|Win32'">$(Configuration)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='OEM Debug|Win32'">true</LinkIncremental>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='OEM Debug|x64'">$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='OEM Debug|ARM64'">$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(Platform)\$(Configuration)\</IntDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">$(Platform)\$(Configuration)\</IntDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='OEM Debug|x64'">$(Platform)\$(Configuration)\</IntDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='OEM Debug|ARM64'">$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">true</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='OEM Debug|x64'">true</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='OEM Debug|ARM64'">true</LinkIncremental>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='OEM Release|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(Configuration)\</IntDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='OEM Release|Win32'">$(Configuration)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='OEM Release|Win32'">false</LinkIncremental>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='OEM Release|x64'">$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='OEM Release|ARM64'">$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(Platform)\$(Configuration)\</IntDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">$(Platform)\$(Configuration)\</IntDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='OEM Release|x64'">$(Platform)\$(Configuration)\</IntDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='OEM Release|ARM64'">$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">false</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='OEM Release|x64'">false</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='OEM Release|ARM64'">false</LinkIncremental>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='OEM Debug|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='OEM Debug|Win32'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='OEM Debug|Win32'" />
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">AllRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='OEM Debug|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='OEM Debug|ARM64'">AllRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" />
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='OEM Debug|x64'" />
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='OEM Debug|ARM64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='OEM Debug|x64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='OEM Debug|ARM64'" />
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='OEM Release|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='OEM Release|Win32'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='OEM Release|Win32'" />
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">AllRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='OEM Release|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='OEM Release|ARM64'">AllRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" />
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='OEM Release|x64'" />
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='OEM Release|ARM64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='OEM Release|x64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='OEM Release|ARM64'" />
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_DEBUG;_DEBUG_TO_FILE;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <TargetMachine>MachineX86</TargetMachine>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>NpcapHelper.exe.manifest.in;%(AdditionalManifestFiles)</AdditionalManifestFiles>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug|Win32'">
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_DEBUG;_DEBUG_TO_FILE;NPCAP_OEM;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <TargetMachine>MachineX86</TargetMachine>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>NpcapHelper.exe.manifest.in;%(AdditionalManifestFiles)</AdditionalManifestFiles>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_DEBUG;_DEBUG_TO_FILE;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <TargetMachine>MachineX64</TargetMachine>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>NpcapHelper.exe.manifest.in;%(AdditionalManifestFiles)</AdditionalManifestFiles>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Midl />
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_DEBUG;_DEBUG_TO_FILE;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>NpcapHelper.exe.manifest.in;%(AdditionalManifestFiles)</AdditionalManifestFiles>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_DEBUG;_DEBUG_TO_FILE;NPCAP_OEM;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <TargetMachine>MachineX64</TargetMachine>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>NpcapHelper.exe.manifest.in;%(AdditionalManifestFiles)</AdditionalManifestFiles>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug|ARM64'">
    <Midl />
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_DEBUG;_DEBUG_TO_FILE;NPCAP_OEM;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>NpcapHelper.exe.manifest.in;%(AdditionalManifestFiles)</AdditionalManifestFiles>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <TargetMachine>MachineX86</TargetMachine>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>NpcapHelper.exe.manifest.in;%(AdditionalManifestFiles)</AdditionalManifestFiles>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>NPCAP_OEM;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <TargetMachine>MachineX86</TargetMachine>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>NpcapHelper.exe.manifest.in;%(AdditionalManifestFiles)</AdditionalManifestFiles>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <TargetMachine>MachineX64</TargetMachine>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>NpcapHelper.exe.manifest.in;%(AdditionalManifestFiles)</AdditionalManifestFiles>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Midl />
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>NpcapHelper.exe.manifest.in;%(AdditionalManifestFiles)</AdditionalManifestFiles>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <PreprocessorDefinitions>NPCAP_OEM;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <TargetMachine>MachineX64</TargetMachine>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>NpcapHelper.exe.manifest.in;%(AdditionalManifestFiles)</AdditionalManifestFiles>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release|ARM64'">
    <Midl />
    <ClCompile>
      <PreprocessorDefinitions>NPCAP_OEM;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>NpcapHelper.exe.manifest.in;%(AdditionalManifestFiles)</AdditionalManifestFiles>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="NpcapHelper.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\debug.h" />
    <ClInclude Include="resource.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="version.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`packetWin7/Helper/NpcapHelper/NpcapHelper.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="NpcapHelper.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\debug.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="version.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`packetWin7/Helper/NpcapHelper/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by version.rc

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`packetWin7/Helper/NpcapHelper/version.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winresrc.h"
#ifndef IDC_STATIC
#define IDC_STATIC (-1)
#endif

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// Neutral resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_NEU)
#ifdef _WIN32
LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL
#pragma code_page(1252)
#endif //_WIN32

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""afxres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "#include ""version.rc2""\r\n"
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

#endif    // Neutral resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
#include "version.rc2"

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`packetWin7/Helper/NpcapHelper/version.rc2`:

```rc2
//
// version.rc2 - resources Microsoft Visual C++ does not edit directly
//

#ifdef APSTUDIO_INVOKED
	#error this file is not editable by Microsoft Visual C++
#endif //APSTUDIO_INVOKED


#include "..\..\..\version.h"

VS_VERSION_INFO VERSIONINFO
 FILEVERSION		WINPCAP_MAJOR,WINPCAP_MINOR,WINPCAP_REV,WINPCAP_BUILD
 PRODUCTVERSION		WINPCAP_MAJOR,WINPCAP_MINOR,WINPCAP_REV,WINPCAP_BUILD
 FILEFLAGSMASK VS_FFI_FILEFLAGSMASK
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS_NT_WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "000004b0"
        BEGIN
			VALUE "CompanyName",       WINPCAP_COMPANY_NAME
			VALUE "FileDescription",   "The helper program for \x22Admin-only Mode\x22"
			VALUE "FileVersion",       WINPCAP_VER_STRING
			VALUE "InternalName",      "NpcapHelper.exe"
			VALUE "LegalCopyright",    WINPCAP_COPYRIGHT_STRING
			VALUE "LegalTrademarks",   ""
			VALUE "OriginalFilename",  "NpcapHelper.exe"
			VALUE "ProductName",       WINPCAP_PRODUCT_NAME
			VALUE "ProductVersion",    WINPCAP_VER_STRING
            VALUE "Build Description", WINPCAP_BUILD_DESCRIPTION
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x0, 1200
    END
END

```

`packetWin7/Helper/NpcapHelperTest/NpcapHelperTest.c`:

```c
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
/***************************************************************************
 * NpcapHelperTest.c -- A program used to test NpcapHelper.exe             *
 * Note: this code is now integrated into packet.dll, this file is only    *
 * used for test. This is for "Admin-only mode", as packet.dll runs on     *
 * non-Admin level and NpcapHelper.exe runs on Admin level. If user denies *
 * the UAC prompt, NpcapHelper.exe will not start.                         *
 *                                                                         *
 * This program is based on Microsoft example:                             *
 * https://msdn.microsoft.com/en-us/library/windows/desktop/aa365592%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396
 * https://msdn.microsoft.com/en-us/library/windows/desktop/aa365588%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396
 ***************************************************************************/

#include <stdio.h>
#include <windows.h>
//#define _DBG
#include "../debug.h"

#define BUFSIZE 512
#define MAX_SEM_COUNT 10
#define MAX_TRY_TIME 50
#define SLEEP_TIME 50
// Handle for NpcapHelper named pipe.
HANDLE g_NpcapHelperPipe = INVALID_HANDLE_VALUE;
// Whether this process is running in Administrator mode.
BOOL g_IsAdminMode = FALSE;
// Whether we have already tried NpcapHelper.
BOOL g_NpcapHelperTried = FALSE;
// The handle to this DLL.
HANDLE g_DllHandle = NULL;

BOOL NPcapCreatePipe(char *pipeName, HANDLE moduleName)
{
	int pid = GetCurrentProcessId();
	char params[BUFSIZE];
	SHELLEXECUTEINFOA shExInfo = {0};
	DWORD nResult;
	char lpFilename[BUFSIZE];
	char szDrive[BUFSIZE];
	char szDir[BUFSIZE];

	TRACE_ENTER("NPcapCreatePipe");

	// Get Path to This Module
	nResult = GetModuleFileNameA((HMODULE) moduleName, lpFilename, BUFSIZE);
	if (nResult == 0)
	{
		TRACE_PRINT1("GetModuleFileNameA failed. GLE=%d\n", GetLastError() ); 
		TRACE_EXIT("NPcapCreatePipe");
		return FALSE;
	}
	_splitpath_s(lpFilename, szDrive, BUFSIZE, szDir, BUFSIZE, NULL, 0, NULL, 0);
	_makepath_s(lpFilename, BUFSIZE, szDrive, szDir, "NpcapHelper", ".exe");

	sprintf_s(params, BUFSIZE, "%s %d", pipeName, pid);

	shExInfo.cbSize = sizeof(shExInfo);
	shExInfo.fMask = SEE_MASK_NOCLOSEPROCESS;
	shExInfo.hwnd = 0;
	shExInfo.lpVerb = "runas";				// Operation to perform
	shExInfo.lpFile = lpFilename;			// Application to start    
	shExInfo.lpParameters = params;			// Additional parameters
	shExInfo.lpDirectory = 0;
	shExInfo.nShow = SW_SHOW;
	shExInfo.hInstApp = 0;  

	if (!ShellExecuteExA(&shExInfo))
	{
		DWORD dwError = GetLastError();
		if (dwError == ERROR_CANCELLED)
		{
			// The user refused to allow privileges elevation.
			// Do nothing ...
		}
		TRACE_EXIT("NPcapCreatePipe");
		return FALSE;
	}
	else
	{
		TRACE_EXIT("NPcapCreatePipe");
		return TRUE;
		//		hChildProcess = shExInfo.hProcess;
		// 		WaitForSingleObject(shExInfo.hProcess, INFINITE);
		// 		CloseHandle(shExInfo.hProcess);
	}
}

HANDLE NPcapConnect(char *pipeName)
{
	HANDLE hPipe = INVALID_HANDLE_VALUE;
	int tryTime = 0;
	char lpszPipename[BUFSIZE];

	TRACE_ENTER("NPcapConnect");

	sprintf_s(lpszPipename, BUFSIZE, "\\\\.\\pipe\\%s", pipeName);

	// Try to open a named pipe; wait for it, if necessary. 
	while (tryTime < MAX_TRY_TIME) 
	{ 
		hPipe = CreateFileA( 
			lpszPipename,   // pipe name 
			GENERIC_READ |  // read and write access 
			GENERIC_WRITE, 
			0,              // no sharing 
			NULL,           // default security attributes
			OPEN_EXISTING,  // opens existing pipe 
			0,              // default attributes 
			NULL);          // no template file 

		// Break if the pipe handle is valid. 

		if (hPipe != INVALID_HANDLE_VALUE)
		{
			break;
		}
		else
		{
			tryTime ++;
			Sleep(SLEEP_TIME);
		}

		// Exit if an error other than ERROR_PIPE_BUSY occurs. 

		// 		if (GetLastError() != ERROR_PIPE_BUSY) 
		// 		{
		// 			printf("Could not open pipe. GLE=%d\n", GetLastError());
		// 			return INVALID_HANDLE_VALUE;
		// 		}

		// 		// All pipe instances are busy, so wait for 20 seconds. 
		// 
		// 		if ( ! WaitNamedPipe(lpszPipename, 2000)) 
		// 		{ 
		// 			printf("Could not open pipe: 2 second wait timed out."); 
		// 			return INVALID_HANDLE_VALUE;
		// 		} 
	}

	TRACE_EXIT("NPcapConnect");
	return hPipe;
}

HANDLE NPcapRequestHandle(char *sMsg)
{
	LPSTR lpvMessage = sMsg; 
	char  chBuf[BUFSIZE]; 
	BOOL   fSuccess = FALSE; 
	DWORD  cbRead, cbToWrite, cbWritten, dwMode; 
	HANDLE hPipe = g_NpcapHelperPipe;

	TRACE_ENTER("NPcapRequestHandle");

	if (hPipe == INVALID_HANDLE_VALUE)
	{
		TRACE_EXIT("NPcapRequestHandle");
		return INVALID_HANDLE_VALUE;
	}

	// The pipe connected; change to message-read mode. 
	dwMode = PIPE_READMODE_MESSAGE; 
	fSuccess = SetNamedPipeHandleState( 
		hPipe,    // pipe handle 
		&dwMode,  // new pipe mode 
		NULL,     // don't set maximum bytes 
		NULL);    // don't set maximum time 
	if ( ! fSuccess) 
	{
		TRACE_PRINT1("SetNamedPipeHandleState failed. GLE=%d\n", GetLastError() ); 
		TRACE_EXIT("NPcapRequestHandle");
		return INVALID_HANDLE_VALUE;
	}

	// Send a message to the pipe server. 

	cbToWrite = (DWORD) (strlen(lpvMessage) + 1) * sizeof(char);
	TRACE_PRINT2("\nSending %d byte message: \"%s\"\n", cbToWrite, lpvMessage); 

	fSuccess = WriteFile( 
		hPipe,                  // pipe handle 
		lpvMessage,             // message 
		cbToWrite,              // message length 
		&cbWritten,             // bytes written 
		NULL);                  // not overlapped 

	if ( ! fSuccess) 
	{
		TRACE_PRINT1("WriteFile to pipe failed. GLE=%d\n", GetLastError() ); 
		TRACE_EXIT("NPcapRequestHandle");
		return INVALID_HANDLE_VALUE;
	}

	TRACE_PRINT("Message sent to server, receiving reply as follows:\n");

	do 
	{ 
		// Read from the pipe. 

		fSuccess = ReadFile( 
			hPipe,    // pipe handle 
			chBuf,    // buffer to receive reply 
			BUFSIZE*sizeof(char),  // size of buffer 
			&cbRead,  // number of bytes read 
			NULL);    // not overlapped 

		if ( ! fSuccess && GetLastError() != ERROR_MORE_DATA )
			break; 

		//printf("\"%s\"\n", chBuf ); 
	} while ( ! fSuccess);  // repeat loop if ERROR_MORE_DATA 

	if ( ! fSuccess)
	{
		TRACE_PRINT1("ReadFile from pipe failed. GLE=%d\n", GetLastError() );
		TRACE_EXIT("NPcapRequestHandle");
		return INVALID_HANDLE_VALUE;
	}

	//printf("\n<End of message, press ENTER to terminate connection and exit\n>");
	if (cbRead != 0)
	{
		//int hd = atoi(chBuf);
		HANDLE hd = (HANDLE) strtoul(chBuf, NULL, 16);
		TRACE_PRINT1("Received Driver Handle: 0x%08x\n", hd);
		TRACE_EXIT("NPcapRequestHandle");
		return hd;
	}
	else
	{
		TRACE_EXIT("NPcapRequestHandle");
		return INVALID_HANDLE_VALUE;
	}
}

BOOL NPcapIsAdminMode()
{
	BOOL bIsRunAsAdmin = FALSE;
	DWORD dwError = ERROR_SUCCESS;
	PSID pAdministratorsGroup = NULL;
	// Allocate and initialize a SID of the administrators group.
	SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

	TRACE_ENTER("NPcapIsAdminMode");

	if (!AllocateAndInitializeSid(
		&NtAuthority, 
		2, 
		SECURITY_BUILTIN_DOMAIN_RID, 
		DOMAIN_ALIAS_RID_ADMINS, 
		0, 0, 0, 0, 0, 0, 
		&pAdministratorsGroup))
	{
		dwError = GetLastError();
		goto Cleanup;
	}

	// Determine whether the SID of administrators group is enabled in 
	// the primary access token of the process.
	if (!CheckTokenMembership(NULL, pAdministratorsGroup, &bIsRunAsAdmin))
	{
		dwError = GetLastError();
		goto Cleanup;
	}

Cleanup:
	// Centralized cleanup for all allocated resources.
	if (pAdministratorsGroup)
	{
		FreeSid(pAdministratorsGroup);
		pAdministratorsGroup = NULL;
	}

	// Throw the error if something failed in the function.
	if (ERROR_SUCCESS != dwError)
	{
		TRACE_PRINT1("IsProcessRunningAsAdminMode failed. GLE=%d\n", dwError);
	}

	TRACE_PRINT1("IsProcessRunningAsAdminMode result: %s\n", bIsRunAsAdmin? "yes" : "no");
	TRACE_EXIT("NPcapIsAdminMode");
	return bIsRunAsAdmin;
}

void NPcapStartHelper()
{
	TRACE_ENTER("NPcapStartHelper");

	g_NpcapHelperTried = TRUE;

	// Check if this process is running in Administrator mode.
	g_IsAdminMode = NPcapIsAdminMode();

	if (!g_IsAdminMode)
	{
		char pipeName[BUFSIZE];
		int pid = GetCurrentProcessId();
		sprintf_s(pipeName, BUFSIZE, "npcap-%d", pid);
		if (NPcapCreatePipe(pipeName, g_DllHandle))
		{
			g_NpcapHelperPipe = NPcapConnect(pipeName);
			if (g_NpcapHelperPipe == INVALID_HANDLE_VALUE)
			{
				// NpcapHelper failed, let g_IsAdminMode be TRUE to avoid next requestHandleFromNpcapHelper() calls.
				g_IsAdminMode = TRUE;
			}
		}
		else
		{
			// NpcapHelper failed, let g_IsAdminMode be TRUE to avoid next requestHandleFromNpcapHelper() calls.
			g_IsAdminMode = TRUE;
		}
	}

	TRACE_EXIT("NPcapStartHelper");
}

void NPcapStopHelper()
{
	TRACE_ENTER("NPcapStopHelper");

	if (g_NpcapHelperPipe != INVALID_HANDLE_VALUE)
	{
		CloseHandle(g_NpcapHelperPipe);
		g_NpcapHelperPipe = INVALID_HANDLE_VALUE;
	}

	TRACE_EXIT("NPcapStopHelper");
}

int main(int argc, char* argv[])
{
	HANDLE hFile;
	char SymbolicLink1[BUFSIZE] = "\\\\.\\Global\\NPCAP_{14AFDBFA-FD9E-48D4-8FF5-C7FD0EB924A4}";
	char SymbolicLink2[BUFSIZE] = "\\\\.\\Global\\NPCAP_{14AFDBFA-FD9E-48D4-1111-C7FD0EB924A5}";

	//g_DllHandle = DllHandle;

	// NpcapHelper Initialization, used for accessing the driver with Administrator privilege.
	if (!g_NpcapHelperTried)
	{
		NPcapStartHelper();
	}

	// do the job
	if (!g_IsAdminMode)
	{
		hFile = NPcapRequestHandle(SymbolicLink1);
	}
	else
	{
		hFile = CreateFileA(SymbolicLink1,GENERIC_WRITE | GENERIC_READ,
			0,NULL,OPEN_EXISTING,0,0);
	}
	if (!g_IsAdminMode)
	{
		hFile = NPcapRequestHandle(SymbolicLink2);
	}
	else
	{
		hFile = CreateFileA(SymbolicLink2,GENERIC_WRITE | GENERIC_READ,
			0,NULL,OPEN_EXISTING,0,0);
	}

#pragma warning(suppress: 6031)
	getchar();

	if (!g_IsAdminMode)
	{
		// NpcapHelper De-Initialization.
		NPcapStopHelper();
	}

	return 0;
}


```

`packetWin7/Helper/NpcapHelperTest/NpcapHelperTest.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{3F697FA8-4C35-416C-A381-2631AAB79D39}</ProjectGuid>
    <RootNamespace>NpcapHelperTest</RootNamespace>
    <Keyword>Win32Proj</Keyword>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v120</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v120</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v120</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v120</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>10.0.40219.1</_ProjectFileVersion>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(Configuration)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</LinkIncremental>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</LinkIncremental>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(Configuration)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</LinkIncremental>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</LinkIncremental>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_DEBUG;_DEBUG_TO_FILE;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
      <TargetMachine>MachineX86</TargetMachine>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_DEBUG;_DEBUG_TO_FILE;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
      <TargetMachine>MachineX64</TargetMachine>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
      <TargetMachine>MachineX86</TargetMachine>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
      <TargetMachine>MachineX64</TargetMachine>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="NpcapHelperTest.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\debug.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`packetWin7/Helper/NpcapHelperTest/NpcapHelperTest.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="NpcapHelperTest.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\debug.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`packetWin7/Helper/debug.h`:

```h
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
/*
 * Copyright (c) 2005 - 2006
 * CACE Technologies LLC, Davis (CA)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the company (CACE Technologies LLC) nor the 
 * names of its contributors may be used to endorse or promote products 
 * derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#ifndef __PACKET_DEBUG_393073863432093179878957
#define __PACKET_DEBUG_393073863432093179878957

#ifdef _DEBUG_TO_FILE

#include <stdio.h>
#include <windows.h>

extern CHAR g_LogFileName[1024];

#pragma warning(push)
#pragma warning(disable : 4127)

static VOID OutputDebugStringVA(LPCSTR Format, ...)
{
	FILE *f;											
	SYSTEMTIME LocalTime;								
	va_list Marker;
	DWORD dwThreadId;
	int loops = 0;
	DWORD dwLastError = GetLastError();

	dwThreadId = GetCurrentThreadId();

	va_start( Marker, Format );     /* Initialize variable arguments. */
														
	GetLocalTime(&LocalTime);							
														
	do
	{
		if (fopen_s(&f, "C:\\Program Files\\Npcap\\NpcapHelper.log", "a") == 0)
			break;

		Sleep(0);
		loops++;
	}
	while(loops <= 10);

	if (loops > 10 || !f)
	{
		SetLastError(dwLastError);
		return;
	}

	fprintf(f, "[%.08X] %.04u-%.02u-%.02u %.02u:%02u:%02u ",
			dwThreadId,
			LocalTime.wYear,							
			LocalTime.wMonth,							
			LocalTime.wDay,								
			LocalTime.wHour,							
			LocalTime.wMinute,							
			LocalTime.wSecond);										
	vfprintf(f, Format, Marker);
	
	fclose(f);											


	SetLastError(dwLastError);
}

#pragma warning(pop)

#elif defined (_DBG)

#include <strsafe.h>

static VOID OutputDebugStringVA(LPCSTR Format, ...)
{
	va_list Marker;
	CHAR string[1024];
	DWORD dwLastError = GetLastError();

	va_start( Marker, Format );     /* Initialize variable arguments. */

	StringCchVPrintfA(string, sizeof(string), Format, Marker);

	OutputDebugStringA(string);

	va_end(Marker);

	SetLastError(dwLastError);
}
#endif


#if defined(_DBG) || defined(_DEBUG_TO_FILE)

#ifdef _DBG
#define TRACE_PRINT_DLLMAIN(_x)			OutputDebugStringVA ("    " _x "\n")
#else
#define TRACE_PRINT_DLLMAIN(_x)			//we cannot use the _DEBUG_TO_FILE stuff from DllMain!!
#endif

#define TRACE_ENTER(_x)					OutputDebugStringVA ("--> " _x "\n")
#define TRACE_EXIT(_x)					OutputDebugStringVA ("<-- " _x "\n")
#define TRACE_PRINT(_x)					OutputDebugStringVA ("    " _x "\n")
#define TRACE_PRINT1(_x, _y)			OutputDebugStringVA("    " _x "\n", _y)   		
#define TRACE_PRINT2(_x, _p1, _p2)		OutputDebugStringVA("    " _x "\n", _p1, _p2)   		
#define TRACE_PRINT4(_x, _p1, _p2, _p3, _p4) OutputDebugStringVA("    " _x "\n", _p1, _p2, _p3, _p4) 
#define TRACE_PRINT6(_x, _p1, _p2, _p3, _p4, _p5, _p6) OutputDebugStringVA("    " _x "\n", _p1, _p2, _p3, _p4, _p5, _p6 )

static __forceinline void TRACE_PRINT_OS_INFO()
{
	HKEY	hKey;
	CHAR buffer[1024];
	DWORD size = sizeof(buffer);
	DWORD type;
	DWORD dwLastError;

	dwLastError = GetLastError();

	TRACE_PRINT("********************* OS info.*********************");
	buffer[size-1] = 0;
	if(	RegOpenKeyExA(HKEY_LOCAL_MACHINE, "SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment", 0, KEY_READ, &hKey) == ERROR_SUCCESS)
	{
		if (RegQueryValueExA(hKey, "PROCESSOR_ARCHITECTURE", 0, &type, (LPBYTE)buffer, &size) == ERROR_SUCCESS && type == REG_SZ)
		{
			OutputDebugStringVA("Architecture = %s\n", buffer);
		}
		else
		{
			OutputDebugStringVA("Architecture = <UNKNOWN>\n");
		}
		
		RegCloseKey(hKey);
	}
	else
	{
		OutputDebugStringVA("Architecture = <UNKNOWN>\n");
	}

	size = sizeof(buffer);
	buffer[size-1] = 0;

	if(	RegOpenKeyExA(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion", 0, KEY_READ, &hKey) == ERROR_SUCCESS)
	{
		if (RegQueryValueExA(hKey, "CurrentVersion", 0, &type,  (LPBYTE)buffer, &size) == ERROR_SUCCESS && type == REG_SZ)
		{
			OutputDebugStringVA("Windows version = %s\n", buffer);
		}
		else
		{
			OutputDebugStringVA("Windows version = <UNKNOWN>\n");
		}
		
		RegCloseKey(hKey);
	}
	else
	{
		OutputDebugStringVA("Windows version = <UNKNOWN>\n");
	}

	size = sizeof(buffer);
	buffer[size-1] = 0;
	if(	RegOpenKeyExA(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion", 0, KEY_READ, &hKey) == ERROR_SUCCESS)
	{
		if (RegQueryValueExA(hKey, "CurrentType", 0, &type,  (LPBYTE)buffer, &size) == ERROR_SUCCESS && type == REG_SZ)
		{
			OutputDebugStringVA("Windows CurrentType = %s\n", buffer);
		}
		else
		{
			OutputDebugStringVA("Windows CurrentType = <UNKNOWN>\n");
		}
		
		RegCloseKey(hKey);
	}
	else
	{
		OutputDebugStringVA("Windows CurrentType = <UNKNOWN>\n");
	}

	OutputDebugStringVA("*************************************************** \n");

	SetLastError(dwLastError);
}
#else

#define TRACE_ENTER(_x)
#define TRACE_PRINT_DLLMAIN(_x)
#define TRACE_EXIT(_x) 
#define TRACE_PRINT(_x)
#define TRACE_PRINT1(_x, _y)
#define TRACE_PRINT2(_x, _p1, _p2)
#define TRACE_PRINT4(_x, _p1, _p2, _p3, _p4) 
#define TRACE_PRINT6(_x, _p1, _p2, _p3, _p4, _p5, _p6) 
#define TRACE_PRINT_OS_INFO()

#endif



#endif //__PACKET_DEBUG_393073863432093179878957

```

`packetWin7/NPFInstall/NPFInstall.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 2013
VisualStudioVersion = 12.0.40629.0
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "NPFInstall", "NPFInstall\NPFInstall.vcxproj", "{5D8A2717-4F35-4402-B868-45612D27291B}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Debug|x64 = Debug|x64
		OEM Release|Win32 = OEM Release|Win32
		OEM Release|x64 = OEM Release|x64
		Release|Win32 = Release|Win32
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{5D8A2717-4F35-4402-B868-45612D27291B}.Debug|Win32.ActiveCfg = Debug|Win32
		{5D8A2717-4F35-4402-B868-45612D27291B}.Debug|Win32.Build.0 = Debug|Win32
		{5D8A2717-4F35-4402-B868-45612D27291B}.Debug|x64.ActiveCfg = Debug|x64
		{5D8A2717-4F35-4402-B868-45612D27291B}.Debug|x64.Build.0 = Debug|x64
		{5D8A2717-4F35-4402-B868-45612D27291B}.OEM Release|Win32.ActiveCfg = OEM Release|Win32
		{5D8A2717-4F35-4402-B868-45612D27291B}.OEM Release|Win32.Build.0 = OEM Release|Win32
		{5D8A2717-4F35-4402-B868-45612D27291B}.OEM Release|x64.ActiveCfg = OEM Release|x64
		{5D8A2717-4F35-4402-B868-45612D27291B}.OEM Release|x64.Build.0 = OEM Release|x64
		{5D8A2717-4F35-4402-B868-45612D27291B}.Release|Win32.ActiveCfg = Release|Win32
		{5D8A2717-4F35-4402-B868-45612D27291B}.Release|Win32.Build.0 = Release|Win32
		{5D8A2717-4F35-4402-B868-45612D27291B}.Release|x64.ActiveCfg = Release|x64
		{5D8A2717-4F35-4402-B868-45612D27291B}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`packetWin7/NPFInstall/NPFInstall/CalloutInstall.cpp`:

```cpp
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
/*++

Module Name:

	CalloutInstall.cpp

Abstract:

	This is used for installing the Windows Filtering Platform (WFP) callout driver, for capturing the loopback traffic, the used INF file is: npf(npcap)_wfp.inf

--*/

#pragma comment(lib, "advpack.lib")

#include "CalloutInstall.h"
#include "ProtInstall.h"
#include "debug.h"

#include <advpub.h>
#include <tchar.h>

BOOL isFileExist(TCHAR szFileFullPath[])
{
	WIN32_FIND_DATA FindFileData;
	HANDLE hFind;

	TRACE_ENTER();

	hFind = FindFirstFile(szFileFullPath, &FindFileData);
	if (hFind == INVALID_HANDLE_VALUE)
	{
		TRACE_PRINT2("FindFirstFile: error, szFileFullPath = %s, errCode = 0x%08x.", szFileFullPath, GetLastError());
		TRACE_EXIT();
		return FALSE;
	}
	else
	{
		TRACE_PRINT1("FindFirstFile: succeed, szFileFullPath = %s.", szFileFullPath);
		FindClose(hFind);
		TRACE_EXIT();
		return TRUE;
	}
}

BOOL InstallWFPCallout()
{
	DWORD nResult;

	TRACE_ENTER();

	// Get Path to Service INF File
	// ----------------------------
	// The INF file is assumed to be in the same folder as this application...
	TCHAR szFileFullPath[_MAX_PATH];
	nResult = GetWFPCalloutInfFilePath(szFileFullPath, MAX_PATH);
	if (nResult == 0)
	{
		TRACE_PRINT("Unable to get WFP callout INF file path");
		TRACE_EXIT();
		return FALSE;
	}

	if (!isFileExist(szFileFullPath))
	{
		TRACE_PRINT("WFP callout INF file doesn't exist");
		TRACE_EXIT();
		return FALSE;
	}

	TCHAR szCmd[_MAX_PATH * 2];
	_stprintf_s(szCmd, _MAX_PATH * 2, TEXT("%s,DefaultInstall,,36,N"), szFileFullPath);
	TRACE_PRINT1("LaunchINFSectionEx: executing, szCmd = %s.", szCmd);
	if (LaunchINFSectionEx(NULL, NULL, szCmd, 0) == E_FAIL)
	{
		TRACE_PRINT("WFP INF install failed!");
		TRACE_EXIT();
		return FALSE;
	}

	TRACE_EXIT();
	return TRUE;
}

BOOL UninstallWFPCallout()
{
	DWORD nResult;

	TRACE_ENTER();

	// Get Path to Service INF File
	// ----------------------------
	// The INF file is assumed to be in the same folder as this application...
	TCHAR szFileFullPath[_MAX_PATH];
	nResult = GetWFPCalloutInfFilePath(szFileFullPath, MAX_PATH);
	if (nResult == 0)
	{
		TRACE_PRINT("Unable to get WFP callout INF file path");
		TRACE_EXIT();
		return FALSE;
	}

	if (!isFileExist(szFileFullPath))
	{
		TRACE_PRINT("WFP callout INF file doesn't exist");
		TRACE_EXIT();
		return FALSE;
	}

	TCHAR szCmd[_MAX_PATH * 2];
	_stprintf_s(szCmd, _MAX_PATH * 2, TEXT("%s,DefaultUninstall,,36,N"), szFileFullPath);
	TRACE_PRINT1("LaunchINFSectionEx: executing, szCmd = %s.", szCmd);
	if (LaunchINFSectionEx(NULL, NULL, szCmd, 0) == E_FAIL)
	{
		TRACE_PRINT("WFP INF removal failed!");
		TRACE_EXIT();
		return FALSE;
	}

	TRACE_EXIT();
	return TRUE;
}

```

`packetWin7/NPFInstall/NPFInstall/CalloutInstall.h`:

```h
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
/*++

Module Name:

	CalloutInstall.h

Abstract:

	This is used for installing the Windows Filtering Platform (WFP) callout driver, for capturing the loopback traffic, the used INF file is: npf(npcap)_wfp.inf

--*/
#include <windows.h>

BOOL isFileExist(TCHAR szFileFullPath[]);

BOOL InstallWFPCallout();

BOOL UninstallWFPCallout();

```

`packetWin7/NPFInstall/NPFInstall/DriverStoreClear.cpp`:

```cpp
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
/*++

Module Name:

DriverStoreClear.h

Abstract:

This is used to clear the cache of Npcap driver in the Driver Store.

--*/

#include <windows.h>

#include "DriverStoreClear.h"
#include "LoopbackRename2.h"

#include "debug.h"

// getInfNamesFromPnpUtilOutput() function is used to get INF filenames from string like below:
//
// Microsoft PnP Utility
//
// Published name : oem10.inf
// Driver package provider : Lenovo
// Class : System devices
// Driver date and version : 05 / 15 / 2015 13.52.34.549
// Signer name : Microsoft Windows Hardware Compatibility Publisher
//
// Published name : oem20.inf
// Driver package provider : Disc Soft Ltd
// Class : Storage controllers
// Driver date and version : 03 / 27 / 2015 5.24.0.0
// Signer name : Disc Soft Ltd
//
// Published name : oem44.inf
// Driver package provider : Nmap Project
// Class : Network Service
// Driver date and version : 04 / 13 / 2016 12.3.27.285
// Signer name : Insecure.Com LLC
//
vector<tstring> getInfNamesFromPnpUtilOutput(tstring strOutput)
{
	TRACE_ENTER();

	vector<tstring> nResults;

	size_t iStart = -1;
	size_t iEnd;
	size_t iTime = 0;
	tstring strInfFileName;

	while ((iStart = strOutput.find(_T(':'), iStart + 1)) != tstring::npos)
	{
		iStart = strOutput.find_first_not_of(_T(" \t\r\n"), iStart + 1);
		if (iStart == tstring::npos) {
			// No more lines
			break;
		}
		iEnd = strOutput.find_first_of(_T("\r\n"), iStart + 1);
		tstring strText = strOutput.substr(iStart,
				// No EOL found? take the whole thing.
				iEnd != tstring::npos
				? iEnd - iStart
				: tstring::npos);

		if (iTime == 0)
		{
			strInfFileName = strText;
		}
		else if (iTime == 1)
		{
			if (strText == _T("Nmap Project"))
			{
				TRACE_PRINT1("find: executing, strInfFileName = %s.", strInfFileName.c_str());
				nResults.push_back(strInfFileName);
			}
		}

		iTime ++;
		if (iTime == 5)
		{
			iTime = 0;
		}
	}

	TRACE_EXIT();
	return nResults;
}

BOOLEAN ClearDriverStore()
{
	TRACE_ENTER();

	TCHAR renameCmd[16+MAX_PATH] = _T("pnputil.exe -e");
	// "pnputil.exe -d oem1.inf"
	tstring cmd = executeCommand(renameCmd);
	vector<tstring> nInfFileNameList = getInfNamesFromPnpUtilOutput(cmd);

	// "pnputil.exe -d oem1.inf"
	for (size_t i = 0; i < nInfFileNameList.size(); i++)
	{
		_stprintf_s(renameCmd, MAX_PATH, _T("pnputil.exe -d %s"), nInfFileNameList[i].c_str());
		executeCommand(renameCmd);
	}

	TRACE_EXIT();
	return TRUE;
}

```

`packetWin7/NPFInstall/NPFInstall/DriverStoreClear.h`:

```h
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
/*++

Module Name:

DriverStoreClear.h

Abstract:

This is used to clear the cache of Npcap driver in the Driver Store.

--*/

BOOLEAN ClearDriverStore();

```

`packetWin7/NPFInstall/NPFInstall/LoopbackInstall.cpp`:

```cpp
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
/*++

Module Name:

    LoopbackInstall.cpp

Abstract:

    Device Console
    command-line interface for managing devices

--*/

#include "LoopbackInstall.h"
#include "LoopbackRecord.h"
#include "LoopbackRename2.h"

#include "debug.h"

#include <shlobj.h>
#include <ntddndis.h>
#include <VersionHelpers.h>

#define BUF_SIZE 255
#define ADAPTER_SIZE 255

#define FIND_DEVICE         0x00000001 // display device
#define FIND_STATUS         0x00000002 // display status of device
#define FIND_RESOURCES      0x00000004 // display resources of device
#define FIND_DRIVERFILES    0x00000008 // display drivers used by device
#define FIND_HWIDS          0x00000010 // display hw/compat id's used by device
#define FIND_DRIVERNODES    0x00000020 // display driver nodes for a device.
#define FIND_CLASS          0x00000040 // display device's setup class
#define FIND_STACK          0x00000080 // display device's driver-stack

#define INSTANCEID_PREFIX_CHAR TEXT('@') // character used to prefix instance ID's
#define CLASS_PREFIX_CHAR      TEXT('=') // character used to prefix class name
#define WILD_CHAR              TEXT('*') // wild character
#define QUOTE_PREFIX_CHAR      TEXT('\'') // prefix character to ignore wild characters
#define SPLIT_COMMAND_SEP      TEXT(":=") // whole word, indicates end of id's

struct GenericContext {
	DWORD count;
	DWORD control;
	BOOL  reboot;
	LPCTSTR strSuccess;
	LPCTSTR strReboot;
	LPCTSTR strFail;
};

struct IdEntry {
	LPCTSTR String;     // string looking for
	LPCTSTR Wild;       // first wild character if any
	BOOL    InstanceId;
};

int g_DevInstanceID = -1;

BOOL g_DevIDPreEnabled = TRUE;

int g_DevIDCount = 0;
int g_DevIDs[ADAPTER_SIZE] = {-1};

int g_DevIDCount_Pre = 0;
int g_DevIDs_Pre[ADAPTER_SIZE] = {-1};

void addDevID(int iDevID)
{
	if (g_DevIDCount < ADAPTER_SIZE - 1)
	{
		g_DevIDs[g_DevIDCount ++] = iDevID;
	}
}

void addDevID(TCHAR strDevID[]) //DevID is in form like: "ROOT\\NET\\0008"
{
	int iDevID;
	_stscanf_s(strDevID, _T("ROOT\\NET\\%04d"), &iDevID);
	addDevID(iDevID);
}

void addDevID_Pre(int iDevID)
{
	if (g_DevIDCount_Pre < ADAPTER_SIZE - 1)
	{
		g_DevIDs_Pre[g_DevIDCount_Pre ++] = iDevID;
	}
}

void addDevID_Pre(TCHAR strDevID[]) //DevID is in form like: "ROOT\\NET\\0008"
{
	int iDevID;
	_stscanf_s(strDevID, _T("ROOT\\NET\\%04d"), &iDevID);
	addDevID_Pre(iDevID);
}

int getNpcapLoopbackAdapterID()
{
	TRACE_ENTER();

	if (g_DevIDCount == g_DevIDCount_Pre)
	{
		TRACE_PRINT1("getNpcapLoopbackAdapterID: error, g_DevIDCount = g_DevIDCount_Pre = 0x%d.", g_DevIDCount);
		TRACE_EXIT();
		return -1;
	}

	for (int i = 0; i < g_DevIDCount; i ++)
	{
		int found = 0;
		for (int j = 0; j < g_DevIDCount_Pre; j ++)
		{
			if (g_DevIDs[i] == g_DevIDs_Pre[j])
			{
				found = 1;
				break;
			}
		}
		if (found == 0)
		{
			TRACE_PRINT1("getNpcapLoopbackAdapterID: succeed, g_DevIDs[i] = 0x%d.", g_DevIDs[i]);
			TRACE_EXIT();
			return g_DevIDs[i];
		}
	}

	TRACE_PRINT2("getNpcapLoopbackAdapterID: error, g_DevIDCount = 0x%d, g_DevIDCount_Pre = 0x%d.", g_DevIDCount, g_DevIDCount_Pre);
	TRACE_EXIT();
	return -1;
}

void FormatToStream(_In_ FILE * stream, _In_ DWORD fmt,...)
/*++

Routine Description:

    Format text to stream using a particular msg-id fmt
    Used for displaying localizable messages

Arguments:

    stream              - file stream to output to, stdout or stderr
    fmt                 - message id
    ...                 - parameters %1...

Return Value:

    none

--*/
{
    va_list arglist;
    LPTSTR locbuffer = NULL;
    DWORD count;

    va_start(arglist, fmt);
    count = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE|FORMAT_MESSAGE_ALLOCATE_BUFFER,
                          NULL,
                          fmt,
                          0,              // LANGID
                          (LPTSTR) &locbuffer,
                          0,              // minimum size of buffer
                          &arglist);

       if(count) {
            int c;
            int back = 0;
            //
            // strip any trailing "\r\n"s and replace by a single "\n"
            //
            while(((c = *CharPrev(locbuffer,locbuffer+count)) == TEXT('\r')) ||
                  (c == TEXT('\n'))) {
                count--;
                back++;
            }
            if(back) {
                locbuffer[count++] = TEXT('\n');
                locbuffer[count] = TEXT('\0');
            }
            //
            // now write to apropriate stream
            //
			_fputts(locbuffer, stream);
			LocalFree(locbuffer);
        }
}

IdEntry GetIdType(_In_ LPCTSTR Id)
/*++

Routine Description:

    Determine if this is instance id or hardware id and if there's any wildcards
    instance ID is prefixed by '@'
    wildcards are '*'


Arguments:

    Id - ptr to string to check

Return Value:

    IdEntry

--*/
{
    IdEntry Entry;

    Entry.InstanceId = FALSE;
    Entry.Wild = NULL;
    Entry.String = Id;

    if(Entry.String[0] == INSTANCEID_PREFIX_CHAR) {
        Entry.InstanceId = TRUE;
        Entry.String = CharNext(Entry.String);
    }
    if(Entry.String[0] == QUOTE_PREFIX_CHAR) {
        //
        // prefix to treat rest of string literally
        //
        Entry.String = CharNext(Entry.String);
    } else {
        //
        // see if any wild characters exist
        //
        Entry.Wild = _tcschr(Entry.String,WILD_CHAR);
    }
    return Entry;
}

__drv_allocatesMem(object)
LPTSTR * GetMultiSzIndexArray(_In_ __drv_aliasesMem LPTSTR MultiSz)
/*++

Routine Description:

    Get an index array pointing to the MultiSz passed in

Arguments:

    MultiSz - well formed multi-sz string

Return Value:

    array of strings. last entry+1 of array contains NULL
    returns NULL on failure

--*/
{
    LPTSTR scan;
    LPTSTR * array;
    int elements;

    for(scan = MultiSz, elements = 0; scan[0] ;elements++) {
        scan += _tcslen(scan)+1;
    }
    array = new LPTSTR[elements+2];
    if(!array) {
        return NULL;
    }
    array[0] = MultiSz;
    array++;
    if(elements) {
        for(scan = MultiSz, elements = 0; scan[0]; elements++) {
            array[elements] = scan;
            scan += _tcslen(scan)+1;
        }
    }
    array[elements] = NULL;
    return array;
}

BOOL WildCardMatch(_In_ LPCTSTR Item, _In_ const IdEntry & MatchEntry)
/*++

Routine Description:

    Compare a single item against wildcard
    I'm sure there's better ways of implementing this
    Other than a command-line management tools
    it's a bad idea to use wildcards as it implies
    assumptions about the hardware/instance ID
    eg, it might be tempting to enumerate root\* to
    find all root devices, however there is a CfgMgr
    API to query status and determine if a device is
    root enumerated, which doesn't rely on implementation
    details.

Arguments:

    Item - item to find match for eg a\abcd\c
    MatchEntry - eg *\*bc*\*

Return Value:

    TRUE if any match, otherwise FALSE

--*/
{
    LPCTSTR scanItem;
    LPCTSTR wildMark;
    LPCTSTR nextWild;
    size_t matchlen;

    //
    // before attempting anything else
    // try and compare everything up to first wild
    //
    if(!MatchEntry.Wild) {
        return _tcsicmp(Item,MatchEntry.String) ? FALSE : TRUE;
    }
    if(_tcsnicmp(Item,MatchEntry.String,MatchEntry.Wild-MatchEntry.String) != 0) {
        return FALSE;
    }
    wildMark = MatchEntry.Wild;
    scanItem = Item + (MatchEntry.Wild-MatchEntry.String);

    for(;wildMark[0];) {
        //
        // if we get here, we're either at or past a wildcard
        //
        if(wildMark[0] == WILD_CHAR) {
            //
            // so skip wild chars
            //
            wildMark = CharNext(wildMark);
            continue;
        }
        //
        // find next wild-card
        //
        nextWild = _tcschr(wildMark,WILD_CHAR);
        if(nextWild) {
            //
            // substring
            //
            matchlen = nextWild-wildMark;
        } else {
            //
            // last portion of match
            //
            size_t scanlen = _tcslen(scanItem);
            matchlen = _tcslen(wildMark);
            if(scanlen < matchlen) {
                return FALSE;
            }
            return _tcsicmp(scanItem+scanlen-matchlen,wildMark) ? FALSE : TRUE;
        }
        if(_istalpha(wildMark[0])) {
            //
            // scan for either lower or uppercase version of first character
            //

            //
            // the code suppresses the warning 28193 for the calls to _totupper
            // and _totlower.  This suppression is done because those functions
            // have a check return annotation on them.  However, they don't return
            // error codes and the check return annotation is really being used
            // to indicate that the return value of the function should be looked
            // at and/or assigned to a variable.  The check return annotation means
            // the return value should always be checked in all code paths.
            // We assign the return values to variables but the while loop does not 
            // examine both values in all code paths (e.g. when scanItem[0] == 0, 
            // neither u nor l will be examined) and it doesn't need to examine 
            // the values in all code paths.
            //
#pragma warning( suppress: 28193)
            TCHAR u = _totupper(wildMark[0]);
#pragma warning( suppress: 28193)
            TCHAR l = _totlower(wildMark[0]);
            while(scanItem[0] && scanItem[0]!=u && scanItem[0]!=l) {
                scanItem = CharNext(scanItem);
            }
            if(!scanItem[0]) {
                //
                // ran out of string
                //
                return FALSE;
            }
        } else {
            //
            // scan for first character (no case)
            //
            scanItem = _tcschr(scanItem,wildMark[0]);
            if(!scanItem) {
                //
                // ran out of string
                //
                return FALSE;
            }
        }
        //
        // try and match the sub-string at wildMark against scanItem
        //
        if(_tcsnicmp(scanItem,wildMark,matchlen)!=0) {
            //
            // nope, try again
            //
            scanItem = CharNext(scanItem);
            continue;
        }
        //
        // substring matched
        //
        scanItem += matchlen;
        wildMark += matchlen;
    }
    return (wildMark[0] ? FALSE : TRUE);
}

__drv_allocatesMem(object)
LPTSTR * GetDevMultiSz(_In_ HDEVINFO Devs, _In_ PSP_DEVINFO_DATA DevInfo, _In_ DWORD Prop)
/*++

Routine Description:

    Get a multi-sz device property
    and return as an array of strings

Arguments:

    Devs    - HDEVINFO containing DevInfo
    DevInfo - Specific device
    Prop    - SPDRP_HARDWAREID or SPDRP_COMPATIBLEIDS

Return Value:

    array of strings. last entry+1 of array contains NULL
    returns NULL on failure

--*/
{
    LPTSTR buffer;
    DWORD size;
    DWORD reqSize;
    DWORD dataType;
    LPTSTR * array;
    DWORD szChars;

    size = 8192; // initial guess, nothing magic about this
    buffer = new TCHAR[(size/sizeof(TCHAR))+2];
    if(!buffer) {
        return NULL;
    }
    while(!SetupDiGetDeviceRegistryProperty(Devs,DevInfo,Prop,&dataType,(LPBYTE)buffer,size,&reqSize)) {
        if(GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            goto failed;
        }
        if(dataType != REG_MULTI_SZ) {
            goto failed;
        }
        size = reqSize;
        delete [] buffer;
        buffer = new TCHAR[(size/sizeof(TCHAR))+2];
        if(!buffer) {
            goto failed;
        }
    }
    szChars = reqSize/sizeof(TCHAR);
    buffer[szChars] = TEXT('\0');
    buffer[szChars+1] = TEXT('\0');
    array = GetMultiSzIndexArray(buffer);
    if(array) {
        return array;
    }

failed:
    if(buffer) {
        delete [] buffer;
    }
    return NULL;
}

void DelMultiSz(_In_opt_ __drv_freesMem(object) PZPWSTR Array)
/*++

Routine Description:

    Deletes the string array allocated by GetDevMultiSz/GetRegMultiSz/GetMultiSzIndexArray

Arguments:

    Array - pointer returned by GetMultiSzIndexArray

Return Value:

    None

--*/
{
    if(Array) {
        Array--;
        if(Array[0]) {
            delete [] Array[0];
        }
        delete [] Array;
    }
}

BOOL WildCompareHwIds(_In_ PZPWSTR Array, _In_ const IdEntry & MatchEntry)
/*++

Routine Description:

    Compares all strings in Array against Id
    Use WildCardMatch to do real compare

Arguments:

    Array - pointer returned by GetDevMultiSz
    MatchEntry - string to compare against

Return Value:

    TRUE if any match, otherwise FALSE

--*/
{
    if(Array) {
        while(Array[0]) {
            if(WildCardMatch(Array[0],MatchEntry)) {
                return TRUE;
            }
            Array++;
        }
    }
    return FALSE;
}

int EnumerateDevices(_In_ LPCTSTR BaseName, _In_opt_ LPCTSTR Machine, _In_ DWORD Flags, _In_ int argc, _In_reads_(argc) PWSTR* argv, _In_ CallbackFunc Callback, _In_ LPVOID Context)
/*++

Routine Description:

    Generic enumerator for devices that will be passed the following arguments:
    <id> [<id>...]
    =<class> [<id>...]
    where <id> can either be @instance-id, or hardware-id and may contain wildcards
    <class> is a class name

Arguments:

    BaseName - name of executable
    Machine  - name of machine to enumerate
    Flags    - extra enumeration flags (eg DIGCF_PRESENT)
    argc/argv - remaining arguments on command line
    Callback - function to call for each hit
    Context  - data to pass function for each hit

Return Value:

    EXIT_xxxx

--*/
{
	TRACE_ENTER();

    HDEVINFO devs = INVALID_HANDLE_VALUE;
    IdEntry * templ = NULL;
    int failcode = EXIT_FAIL;
    int retcode;
    int argIndex;
    DWORD devIndex;
    SP_DEVINFO_DATA devInfo;
    SP_DEVINFO_LIST_DETAIL_DATA devInfoListDetail;
    BOOL doSearch = FALSE;
    BOOL match;
    BOOL all = FALSE;
    GUID cls;
    DWORD numClass = 0;
    int skip = 0;

    UNREFERENCED_PARAMETER(BaseName);

    if(!argc) {
		TRACE_EXIT();
        return EXIT_USAGE;
    }

    templ = new IdEntry[argc];
    if(!templ) {
        goto final;
    }

    //
    // determine if a class is specified
    //
    if(argc>skip && argv[skip][0]==CLASS_PREFIX_CHAR && argv[skip][1]) {
        if(!SetupDiClassGuidsFromNameEx(argv[skip]+1,&cls,1,&numClass,Machine,NULL) &&
            GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            goto final;
        }
        if(!numClass) {
            failcode = EXIT_OK;
            goto final;
        }
        skip++;
    }
    if(argc>skip && argv[skip][0]==WILD_CHAR && !argv[skip][1]) {
        //
        // catch convinient case of specifying a single argument '*'
        //
        all = TRUE;
        skip++;
    } else if(argc<=skip) {
        //
        // at least one parameter, but no <id>'s
        //
        all = TRUE;
    }

    //
    // determine if any instance id's were specified
    //
    // note, if =<class> was specified with no id's
    // we'll mark it as not doSearch
    // but will go ahead and add them all
    //
    for(argIndex=skip;argIndex<argc;argIndex++) {
        templ[argIndex] = GetIdType(argv[argIndex]);
        if(templ[argIndex].Wild || !templ[argIndex].InstanceId) {
            //
            // anything other than simple InstanceId's require a search
            //
            doSearch = TRUE;
        }
    }
    if(doSearch || all) {
        //
        // add all id's to list
        // if there's a class, filter on specified class
        //
        devs = SetupDiGetClassDevsEx(numClass ? &cls : NULL,
                                     NULL,
                                     NULL,
                                     (numClass ? 0 : DIGCF_ALLCLASSES) | Flags,
                                     NULL,
                                     Machine,
                                     NULL);

    } else {
        //
        // blank list, we'll add instance id's by hand
        //
        devs = SetupDiCreateDeviceInfoListEx(numClass ? &cls : NULL,
                                             NULL,
                                             Machine,
                                             NULL);
    }
    if(devs == INVALID_HANDLE_VALUE) {
        goto final;
    }
    for(argIndex=skip;argIndex<argc;argIndex++) {
        //
        // add explicit instances to list (even if enumerated all,
        // this gets around DIGCF_PRESENT)
        // do this even if wildcards appear to be detected since they
        // might actually be part of the instance ID of a non-present device
        //
        if(templ[argIndex].InstanceId) {
            SetupDiOpenDeviceInfo(devs,templ[argIndex].String,NULL,0,NULL);
        }
    }

    devInfoListDetail.cbSize = sizeof(devInfoListDetail);
    if(!SetupDiGetDeviceInfoListDetail(devs,&devInfoListDetail)) {
        goto final;
    }

    //
    // now enumerate them
    //
    if(all) {
        doSearch = FALSE;
    }

    devInfo.cbSize = sizeof(devInfo);
    for(devIndex=0;SetupDiEnumDeviceInfo(devs,devIndex,&devInfo);devIndex++) {

        if(doSearch) {
            for(argIndex=skip,match=FALSE;(argIndex<argc) && !match;argIndex++) {
                TCHAR devID[MAX_DEVICE_ID_LEN];
                LPTSTR *hwIds = NULL;
                LPTSTR *compatIds = NULL;
                //
                // determine instance ID
                //
                if(CM_Get_Device_ID_Ex(devInfo.DevInst,devID,MAX_DEVICE_ID_LEN,0,devInfoListDetail.RemoteMachineHandle)!=CR_SUCCESS) {
                    devID[0] = TEXT('\0');
                }

                if(templ[argIndex].InstanceId) {
                    //
                    // match on the instance ID
                    //
                    if(WildCardMatch(devID,templ[argIndex])) {
                        match = TRUE;
                    }
                } else {
                    //
                    // determine hardware ID's
                    // and search for matches
                    //
                    hwIds = GetDevMultiSz(devs,&devInfo,SPDRP_HARDWAREID);
                    compatIds = GetDevMultiSz(devs,&devInfo,SPDRP_COMPATIBLEIDS);

                    if(WildCompareHwIds(hwIds,templ[argIndex]) ||
                        WildCompareHwIds(compatIds,templ[argIndex])) {
                        match = TRUE;
                    }
                }
                DelMultiSz(hwIds);
                DelMultiSz(compatIds);
            }
        } else {
            match = TRUE;
        }
        if(match) {
            retcode = Callback(devs,&devInfo,devIndex,Context);
            if(retcode) {
                failcode = retcode;
                goto final;
            }
        }
    }

    failcode = EXIT_OK;

final:
    if(templ) {
        delete [] templ;
    }
    if(devs != INVALID_HANDLE_VALUE) {
        SetupDiDestroyDeviceInfoList(devs);
    }

	TRACE_PRINT1("EnumerateDevices: failcode = 0x%d.", failcode);
	TRACE_EXIT();
    return failcode;

}

BOOL DumpDeviceWithInfo(_In_ HDEVINFO Devs, _In_ PSP_DEVINFO_DATA DevInfo, _In_opt_ LPCTSTR Info)
/*++

Routine Description:

    Write device instance & info to stdout

Arguments:

    Devs    )_ uniquely identify device
    DevInfo )

Return Value:

    none

--*/
{
    TCHAR devID[MAX_DEVICE_ID_LEN];
    BOOL b = TRUE;
    SP_DEVINFO_LIST_DETAIL_DATA devInfoListDetail;

    devInfoListDetail.cbSize = sizeof(devInfoListDetail);
    if((!SetupDiGetDeviceInfoListDetail(Devs,&devInfoListDetail)) ||
            (CM_Get_Device_ID_Ex(DevInfo->DevInst,devID,MAX_DEVICE_ID_LEN,0,devInfoListDetail.RemoteMachineHandle)!=CR_SUCCESS)) {
        _tcscpy_s(devID, ARRAYSIZE(devID), TEXT("?"));
        b = FALSE;
    }

	if (g_DevIDPreEnabled)
	{
		addDevID_Pre(devID);
	}
	else
	{
		addDevID(devID);
	}

    if(Info) {
        _tprintf(TEXT("%-60s: %s\n"),devID,Info);
    } else {
        _tprintf(TEXT("%s\n"),devID);
    }
    return b;
}

int FindCallback(_In_ HDEVINFO Devs, _In_ PSP_DEVINFO_DATA DevInfo, _In_ DWORD Index, _In_ LPVOID Context)
/*++

Routine Description:

    Callback for use by Find/FindAll
    just simply display the device

Arguments:

    Devs    )_ uniquely identify the device
    DevInfo )
    Index    - index of device
    Context  - GenericContext

Return Value:

    EXIT_xxxx

--*/
{
    GenericContext *pFindContext = (GenericContext*)Context;

    UNREFERENCED_PARAMETER(Index);

//     if(!pFindContext->control) {
//         DumpDevice(Devs,DevInfo);
//         pFindContext->count++;
//         return EXIT_OK;
//     }
    if(!DumpDeviceWithInfo(Devs,DevInfo,NULL)) {
        return EXIT_OK;
    }
//     if(pFindContext->control&FIND_DEVICE) {
//         DumpDeviceDescr(Devs,DevInfo);
//     }
//     if(pFindContext->control&FIND_CLASS) {
//         DumpDeviceClass(Devs,DevInfo);
//     }
//     if(pFindContext->control&FIND_STATUS) {
//         DumpDeviceStatus(Devs,DevInfo);
//     }
//     if(pFindContext->control&FIND_RESOURCES) {
//         DumpDeviceResources(Devs,DevInfo);
//     }
//     if(pFindContext->control&FIND_DRIVERFILES) {
//         DumpDeviceDriverFiles(Devs,DevInfo);
//     }
//     if(pFindContext->control&FIND_STACK) {
//         DumpDeviceStack(Devs,DevInfo);
//     }
//     if(pFindContext->control&FIND_HWIDS) {
//         DumpDeviceHwIds(Devs,DevInfo);
//     }
//     if (pFindContext->control&FIND_DRIVERNODES) {
//         DumpDeviceDriverNodes(Devs,DevInfo);
//     }
    pFindContext->count++;
    return EXIT_OK;
}

int RemoveCallback(_In_ HDEVINFO Devs, _In_ PSP_DEVINFO_DATA DevInfo, _In_ DWORD Index, _In_ LPVOID Context)
/*++

Routine Description:

    Callback for use by Remove
    Invokes DIF_REMOVE
    uses SetupDiCallClassInstaller so cannot be done for remote devices
    Don't use CM_xxx API's, they bypass class/co-installers and this is bad.

Arguments:

    Devs    )_ uniquely identify the device
    DevInfo )
    Index    - index of device
    Context  - GenericContext

Return Value:

    EXIT_xxxx

--*/
{
    SP_REMOVEDEVICE_PARAMS rmdParams;
    GenericContext *pControlContext = (GenericContext*)Context;
    SP_DEVINSTALL_PARAMS devParams;
    LPCTSTR action = NULL;
    //
    // need hardware ID before trying to remove, as we wont have it after
    //
    TCHAR devID[MAX_DEVICE_ID_LEN];
    SP_DEVINFO_LIST_DETAIL_DATA devInfoListDetail;

    UNREFERENCED_PARAMETER(Index);

    devInfoListDetail.cbSize = sizeof(devInfoListDetail);
    if((!SetupDiGetDeviceInfoListDetail(Devs,&devInfoListDetail)) ||
            (CM_Get_Device_ID_Ex(DevInfo->DevInst,devID,MAX_DEVICE_ID_LEN,0,devInfoListDetail.RemoteMachineHandle)!=CR_SUCCESS)) {
        //
        // skip this
        //
        return EXIT_OK;
    }

    rmdParams.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    rmdParams.ClassInstallHeader.InstallFunction = DIF_REMOVE;
    rmdParams.Scope = DI_REMOVEDEVICE_GLOBAL;
    rmdParams.HwProfile = 0;
    if(!SetupDiSetClassInstallParams(Devs,DevInfo,&rmdParams.ClassInstallHeader,sizeof(rmdParams)) ||
       !SetupDiCallClassInstaller(DIF_REMOVE,Devs,DevInfo)) {
        //
        // failed to invoke DIF_REMOVE
        //
        action = pControlContext->strFail;
    } else {
        //
        // see if device needs reboot
        //
        devParams.cbSize = sizeof(devParams);
        if(SetupDiGetDeviceInstallParams(Devs,DevInfo,&devParams) && (devParams.Flags & (DI_NEEDRESTART|DI_NEEDREBOOT))) {
            //
            // reboot required
            //
            action = pControlContext->strReboot;
            pControlContext->reboot = TRUE;
        } else {
            //
            // appears to have succeeded
            //
            action = pControlContext->strSuccess;
        }
        pControlContext->count++;
    }
    _tprintf(TEXT("%-60s: %s\n"),devID,action);
    TRACE_PRINT2("RemoveCallback: devID=%s, action=%s\n",devID,action);

    return EXIT_OK;
}

// int cmdStatus(_In_ LPCTSTR BaseName, _In_opt_ LPCTSTR Machine, _In_ DWORD Flags, _In_ int argc, _In_reads_(argc) PTSTR argv[])
// /*++
// 
// Routine Description:
// 
//     STATUS <id> ...
//     use EnumerateDevices to do hardwareID matching
//     for each match, dump status to stdout
//     note that we only enumerate present devices
// 
// Arguments:
// 
//     BaseName  - name of executable
//     Machine   - if non-NULL, remote machine
//     argc/argv - remaining parameters - passed into EnumerateDevices
// 
// Return Value:
// 
//     EXIT_xxxx
// 
// --*/
// {
//     GenericContext context;
//     int failcode;
// 
//     UNREFERENCED_PARAMETER(Flags);
// 
//     if(!argc) {
//         return EXIT_USAGE;
//     }
// 
//     context.count = 0;
//     context.control = FIND_DEVICE | FIND_STATUS;
//     failcode = EnumerateDevices(BaseName,Machine,DIGCF_PRESENT,argc,argv,FindCallback,&context);
// 
//     if(failcode == EXIT_OK) {
// 
//         if(!context.count) {
//             FormatToStream(stdout,Machine?MSG_FIND_TAIL_NONE:MSG_FIND_TAIL_NONE_LOCAL,Machine);
//         } else {
//             FormatToStream(stdout,Machine?MSG_FIND_TAIL:MSG_FIND_TAIL_LOCAL,context.count,Machine);
//         }
//     }
//     return failcode;
// }

int cmdUpdate(_In_ LPCTSTR BaseName, _In_opt_ LPCTSTR Machine, _In_ DWORD Flags, _In_ int argc, _In_reads_(argc) PTSTR argv[])
/*++

Routine Description:
    UPDATE
    update driver for existing device(s)

Arguments:

    BaseName  - name of executable
    Machine   - machine name, must be NULL
    argc/argv - remaining parameters

Return Value:

    EXIT_xxxx

--*/
{
	TRACE_ENTER();

    HMODULE newdevMod = NULL;
    int failcode = EXIT_FAIL;
    UpdateDriverForPlugAndPlayDevicesProto UpdateFn;
    BOOL reboot = FALSE;
    LPCTSTR hwid = NULL;
    LPCTSTR inf = NULL;
    DWORD flags = 0;
    DWORD res;
    TCHAR InfPath[MAX_PATH];

    UNREFERENCED_PARAMETER(BaseName);
    UNREFERENCED_PARAMETER(Flags);

    if (Machine)
	{
        //
        // must be local machine
        //
		TRACE_PRINT1("cmdUpdate: error, Machine = %s.", Machine);
		TRACE_EXIT();
        return EXIT_USAGE;
    }
    if (argc < 2)
	{
        //
        // at least HWID required
        //
		TRACE_PRINT1("cmdUpdate: error, argc = %d.", argc);
		TRACE_EXIT();
        return EXIT_USAGE;
    }
    inf = argv[0];
    if (!inf[0])
	{
		TRACE_PRINT1("cmdUpdate: error, argv[0] = %s.", argv[0]);
		TRACE_EXIT();
        return EXIT_USAGE;
    }

    hwid = argv[1];
    if (!hwid[0])
	{
		TRACE_PRINT1("cmdUpdate: error, argv[1] = %s.", argv[1]);
		TRACE_EXIT();
        return EXIT_USAGE;
    }
    //
    // Inf must be a full pathname
    //
    res = GetFullPathName(inf, MAX_PATH, InfPath, NULL);
    if ((res >= MAX_PATH) || (res == 0))
	{
        //
        // inf pathname too long
        //
		TRACE_PRINT1("GetFullPathName: error, res = %d.", res);
		TRACE_EXIT();
        return EXIT_FAIL;
    }
    if (GetFileAttributes(InfPath) == (DWORD) (-1))
	{
        //
        // inf doesn't exist
        //
		TRACE_PRINT1("GetFileAttributes: error, InfPath = %s.", InfPath);
		TRACE_EXIT();
        return EXIT_FAIL;
    }
    inf = InfPath;
    flags |= INSTALLFLAG_FORCE;

    //
    // make use of UpdateDriverForPlugAndPlayDevices
    //
    newdevMod = LoadLibrary(TEXT("newdev.dll"));
    if (!newdevMod)
	{
		TRACE_PRINT1("LoadLibrary failed: %x", GetLastError());
        goto final;
    }
    UpdateFn = (UpdateDriverForPlugAndPlayDevicesProto) GetProcAddress(newdevMod, UPDATEDRIVERFORPLUGANDPLAYDEVICES);
    if (!UpdateFn)
    {
		TRACE_PRINT1("GetProcAddress failed to get UpdateDriverForPlugAndPlayDevices: %x", GetLastError());
        goto final;
    }

    FormatToStream(stdout, inf ? MSG_UPDATE_INF : MSG_UPDATE, hwid, inf);

    if (!UpdateFn(NULL, hwid, inf, flags, &reboot))
	{
		TRACE_PRINT1("UpdateFn failed: %x", GetLastError());
        goto final;
    }

    FormatToStream(stdout, MSG_UPDATE_OK);

    failcode = reboot ? EXIT_REBOOT : EXIT_OK;

final:

    if (newdevMod)
	{
        FreeLibrary(newdevMod);
    }

	TRACE_PRINT1("cmdUpdate: failcode = %d.", failcode);
	TRACE_EXIT();
    return failcode;
}

int cmdInstall(_In_ LPCTSTR BaseName, _In_opt_ LPCTSTR Machine, _In_ DWORD Flags, _In_ int argc, _In_reads_(argc) PTSTR argv[])
/*++

Routine Description:

CREATE
Creates a root enumerated devnode and installs drivers on it

Arguments:

BaseName  - name of executable
Machine   - machine name, must be NULL
argc/argv - remaining parameters

Return Value:

EXIT_xxxx

--*/
{
	TRACE_ENTER();

	HDEVINFO DeviceInfoSet = INVALID_HANDLE_VALUE;
	SP_DEVINFO_DATA DeviceInfoData;
	GUID ClassGUID;
	TCHAR ClassName[MAX_CLASS_NAME_LEN];
	TCHAR hwIdList[LINE_LEN + 4];
	TCHAR InfPath[MAX_PATH];
	int failcode = EXIT_FAIL;
	LPCTSTR hwid = NULL;
	DWORD res;
	LPCTSTR inf = NULL;

	if (Machine)
	{
		//
		// must be local machine
		//
		TRACE_PRINT1("cmdInstall: error, Machine = %s.", Machine);
		TRACE_EXIT();
		return EXIT_USAGE;
	}
	if (argc < 2)
	{
		//
		// at least HWID required
		//
		TRACE_PRINT1("cmdInstall: error, argc = %d.", argc);
		TRACE_EXIT();
		return EXIT_USAGE;
	}
	inf = argv[0];
	if (!inf[0])
	{
		TRACE_PRINT1("cmdUpdate: error, argv[0] = %s.", argv[0]);
		TRACE_EXIT();
		return EXIT_USAGE;
	}

	hwid = argv[1];
	if (!hwid[0])
	{
		TRACE_PRINT1("cmdUpdate: error, argv[1] = %s.", argv[1]);
		TRACE_EXIT();
		return EXIT_USAGE;
	}

	//
	// Inf must be a full pathname
	//
	res = GetFullPathName(inf, MAX_PATH, InfPath, NULL);
	if (res >= MAX_PATH || res == 0)
	{
		//
		// inf pathname too long
		// or other error (GetLastError)
		TRACE_PRINT1("GetFullPathName: error, res = %d.", res);
		TRACE_EXIT();
		return EXIT_FAIL;
	}

	//
	// List of hardware ID's must be double zero-terminated
	//
	ZeroMemory(hwIdList, sizeof(hwIdList));
	if (FAILED(_tcscpy_s(hwIdList, LINE_LEN, hwid)))
	{
		goto final;
	}

	//
	// Use the INF File to extract the Class GUID.
	//
	if (!SetupDiGetINFClass(InfPath, &ClassGUID, ClassName, sizeof(ClassName) / sizeof(ClassName[0]), 0))
	{
		goto final;
	}

	//
	// Create the container for the to-be-created Device Information Element.
	//
	DeviceInfoSet = SetupDiCreateDeviceInfoList(&ClassGUID, 0);
	if (DeviceInfoSet == INVALID_HANDLE_VALUE)
	{
		goto final;
	}

	//
	// Now create the element.
	// Use the Class GUID and Name from the INF file.
	//
	DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
	if (!SetupDiCreateDeviceInfo(DeviceInfoSet,
		ClassName,
		&ClassGUID,
		NULL,
		0,
		DICD_GENERATE_ID,
		&DeviceInfoData))
	{
		goto final;
	}

	//
	// Add the HardwareID to the Device's HardwareID property.
	//
	if (!SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
		&DeviceInfoData,
		SPDRP_HARDWAREID,
		(LPBYTE)hwIdList,
		(_tcslen(hwIdList) + 1 + 1) * sizeof(TCHAR)))
	{
		goto final;
	}

	//
	// Get the Device Instance ID for our adapter.
	//
	TCHAR DevInstanceID[BUF_SIZE];
	if (!SetupDiGetDeviceInstanceId(DeviceInfoSet,
		&DeviceInfoData,
		DevInstanceID,
		BUF_SIZE,
		NULL))
	{
		goto final;
	}
	g_DevInstanceID = getIntDevID(DevInstanceID);

	//
	// Transform the registry element into an actual devnode
	// in the PnP HW tree.
	//
	if (!SetupDiCallClassInstaller(DIF_REGISTERDEVICE,
		DeviceInfoSet,
		&DeviceInfoData))
	{
		goto final;
	}

	FormatToStream(stdout, MSG_INSTALL_UPDATE);

	// Mark device as an endpoint, not a network
	HKEY DevRegKey = SetupDiCreateDevRegKey(DeviceInfoSet,
		&DeviceInfoData,
		DICS_FLAG_GLOBAL,
		0,
		DIREG_DRV,
		NULL,
		NULL
		);
	if (DevRegKey != INVALID_HANDLE_VALUE)
	{
		// https://docs.microsoft.com/en-us/windows-hardware/drivers/network/keywords-not-displayed-in-the-user-interface
		DWORD devtype = NDIS_DEVICE_TYPE_ENDPOINT; // 1
		if (ERROR_SUCCESS != RegSetValueEx(DevRegKey,
			TEXT("*NdisDeviceType"), 0, REG_DWORD, (const BYTE *)&devtype, sizeof(devtype))) {
			TRACE_PRINT1("Couldn't set *NdisDeviceType: %x", GetLastError());// Oops. Hope this isn't a problem.
		}
#if 0
		// These values were causing problems.
		// https://msdn.microsoft.com/library/windows/hardware/ff565767
		devtype = IF_TYPE_SOFTWARE_LOOPBACK; // 24
		if (ERROR_SUCCESS != RegSetValueEx(DevRegKey,
			TEXT("*IfType"), 0, REG_DWORD, (const BYTE *)&devtype, sizeof(devtype))) {
			TRACE_PRINT1("Couldn't set *IfType: %x", GetLastError());// Oops. Hope this isn't a problem.
		}
		// https://docs.microsoft.com/en-us/windows-hardware/drivers/network/oid-gen-media-supported
		devtype = NdisMediumLoopback; // 17
		if (ERROR_SUCCESS != RegSetValueEx(DevRegKey,
			TEXT("*MediaType"), 0, REG_DWORD, (const BYTE *)&devtype, sizeof(devtype))) {
			TRACE_PRINT1("Couldn't set *MediaType: %x", GetLastError());// Oops. Hope this isn't a problem.
		}
		// https://docs.microsoft.com/en-us/windows-hardware/drivers/network/oid-gen-physical-medium
		devtype = NdisPhysicalMediumUnspecified; // 0
		if (ERROR_SUCCESS != RegSetValueEx(DevRegKey,
			TEXT("*PhysicalMediaType"), 0, REG_DWORD, (const BYTE *)&devtype, sizeof(devtype))) {
			TRACE_PRINT1("Couldn't set *PhysicalMediaType: %x", GetLastError());// Oops. Hope this isn't a problem.
		}
#endif
		RegCloseKey(DevRegKey);
	}
	else{ TRACE_PRINT1("Couldn't create/open dev reg key: %x", GetLastError()); }

	//
	// update the driver for the device we just created
	//
	failcode = cmdUpdate(BaseName, Machine, Flags, argc, argv);

	final:

	TRACE_PRINT1("cmdInstall: failcode = %d.", failcode);
	if (failcode == EXIT_FAIL)
	{
		TRACE_PRINT1("cmdInstall: GetLastError: %0x", GetLastError());
	}

	if (DeviceInfoSet != INVALID_HANDLE_VALUE)
	{
		SetupDiDestroyDeviceInfoList(DeviceInfoSet);
	}

	TRACE_EXIT();
    return failcode;
}

int cmdRemove(_In_ LPCTSTR BaseName, _In_opt_ LPCTSTR Machine, _In_ DWORD Flags, _In_ int argc, _In_reads_(argc) PTSTR argv[])
/*++

Routine Description:

    REMOVE
    remove devices

Arguments:

    BaseName  - name of executable
    Machine   - machine name, must be NULL
    argc/argv - remaining parameters

Return Value:

    EXIT_xxxx

--*/
{
	TRACE_ENTER();

    GenericContext context;
    TCHAR strRemove[80] = _T("Removed");
    TCHAR strReboot[80] = _T("Removed on reboot");
    TCHAR strFail[80] = _T("Remove failed");
    int failcode = EXIT_FAIL;

    UNREFERENCED_PARAMETER(Flags);

    if (!argc)
	{
        //
        // arguments required
        //
		TRACE_PRINT1("cmdRemove: error, argc = %d.", argc);
		TRACE_EXIT();
        return EXIT_USAGE;
    }
    if (Machine)
	{
        //
        // must be local machine as we need to involve class/co installers
        //
		TRACE_PRINT1("cmdRemove: error, Machine = %s.", Machine);
		TRACE_EXIT();
        return EXIT_USAGE;
    }

    context.reboot = FALSE;
    context.count = 0;
    context.strReboot = strReboot;
    context.strSuccess = strRemove;
    context.strFail = strFail;
    failcode = EnumerateDevices(BaseName, Machine, DIGCF_PRESENT, argc, argv, RemoveCallback, &context);

    if (failcode == EXIT_OK)
    {
	    TRACE_PRINT1("cmdRemove: %d devices removed", context.count);
	    if (!context.count)
	    {
		    FormatToStream(stdout, MSG_REMOVE_TAIL_NONE);
	    }
	    else if (!context.reboot)
	    {
		    FormatToStream(stdout, MSG_REMOVE_TAIL, context.count);
	    }
	    else
	    {
		    FormatToStream(stdout, MSG_REMOVE_TAIL_REBOOT, context.count);
		    TRACE_PRINT("cmdRemove: requires reboot.");
		    failcode = EXIT_REBOOT;
	    }
    }

    if (failcode != EXIT_OK)
	    TRACE_PRINT1("cmdRemove: failcode = %d.", failcode);
    TRACE_EXIT();
    return failcode;
}

// BOOL ListLoopbackAdapters()
// {
// 	TCHAR *strArgVs[1] = {_T("*msloop")}; // Hardware ID: *msloop
// 	if (cmdStatus(_T("devcon.exe"), NULL, 0, 1, strArgVs) == EXIT_OK)
// 	{
// 		return TRUE;
// 	}
// 	else
// 	{
// 		return FALSE;
// 	}
// }

BOOL GetLoopbackINFFilePath(TCHAR strLoopbackInfPath[])
{
	TRACE_ENTER();

	TCHAR tmp[MAX_PATH];
	if (!SHGetSpecialFolderPath(NULL, tmp, CSIDL_WINDOWS, FALSE))
	{
		TRACE_PRINT("SHGetSpecialFolderPath: error.");
		TRACE_EXIT();
		return FALSE;
	}
	_stprintf_s(strLoopbackInfPath, MAX_PATH + 30, _T("%s\\inf\\netloop.inf"), tmp);

	TRACE_PRINT1("SHGetSpecialFolderPath: succeed, strLoopbackInfPath = %s.", strLoopbackInfPath);
	TRACE_EXIT();
	return TRUE;
}

BOOL GetConfigFilePath(TCHAR strConfigPath[])
{
	TRACE_ENTER();

	TCHAR tmp[MAX_PATH];
	TCHAR drive[_MAX_DRIVE];
	TCHAR dir[_MAX_DIR];
	if (!GetModuleFileName(NULL, tmp, MAX_PATH))
	{
		TRACE_PRINT1("GetModuleFileName: error, errCode = 0x%08x.", GetLastError());
		TRACE_EXIT();
		return FALSE;
	}
	_tsplitpath_s(tmp, drive, _MAX_DRIVE, dir, _MAX_DIR, NULL, 0, NULL, 0);
	_stprintf_s(strConfigPath, MAX_PATH + 30, _T("%s%sloopback.ini"), drive, dir);

	TRACE_PRINT1("GetModuleFileName: succeed, strConfigPath = %s.", strConfigPath);
	TRACE_EXIT();
	return TRUE;
}

BOOL InstallLoopbackDeviceInternal()
{
	TRACE_ENTER();

	TCHAR strLoopbackInfPath[MAX_PATH + 30];
	if (!GetLoopbackINFFilePath(strLoopbackInfPath))
	{
		TRACE_PRINT("GetLoopbackINFFilePath: error.");
		TRACE_EXIT();
		return FALSE;
	}

	// devcon.exe install C:\Windows\inf\netloop.inf *msloop
	TCHAR *strArgVs[2] = {strLoopbackInfPath, _T("*msloop")}; // Inf File: netloop.inf, Hardware ID: *msloop
	if (cmdInstall(_T("devcon.exe"), NULL, 0, 2, strArgVs) == EXIT_OK)
	{
		TRACE_EXIT();
		return TRUE;
	}
	else
	{
		TRACE_PRINT("cmdInstall: error.");
		TRACE_EXIT();
		return FALSE;
	}
}

BOOL RemoveLoopbackDeviceInternal(int iDevID)
{
	TRACE_ENTER();

	TCHAR strDevID[BUF_SIZE];
	_stprintf_s(strDevID, BUF_SIZE, _T("@ROOT\\NET\\%04d"), iDevID);
	TRACE_PRINT1("Removing loopback device: %s\n", strDevID);

	// devcon.exe remove @ROOT\NET\000X
	TCHAR *strArgVs[1] = {strDevID}; // Device ID: @ROOT\NET\000X
	if (cmdRemove(_T("devcon.exe"), NULL, 0, 1, strArgVs) == EXIT_OK)
	{
		TRACE_EXIT();
		return TRUE;
	}
	else
	{
		TRACE_PRINT("cmdRemove: error.");
		TRACE_EXIT();
		return FALSE;
	}
}

BOOL SaveDevIDToFile(int iDevID)
{
	TRACE_ENTER();

	TCHAR strLoopbackIDFilePath[MAX_PATH + 30];
	if (!GetConfigFilePath(strLoopbackIDFilePath))
	{
		TRACE_PRINT("GetConfigFilePath: error.");
		TRACE_EXIT();
		return FALSE;
	}

	FILE *fp;
	if (_tfopen_s(&fp, strLoopbackIDFilePath, _T("w")) != 0 || !fp)
	{
		TRACE_PRINT1("_tfopen_s: error, errCode = 0x%08x.", errno);
		TRACE_EXIT();
		return FALSE;
	}
	_ftprintf(fp, _T("%d"), iDevID);
	fclose(fp);

	TRACE_EXIT();
	return TRUE;
}

BOOL DeleteDevIDFile()
{
	TRACE_ENTER();

	TCHAR strLoopbackIDFilePath[MAX_PATH + 30];
	if (!GetConfigFilePath(strLoopbackIDFilePath))
	{
		TRACE_PRINT("GetConfigFilePath: error.");
		TRACE_EXIT();
		return FALSE;
	}

	if (!DeleteFile(strLoopbackIDFilePath))
	{
		TRACE_PRINT("DeleteFile error: %08x", GetLastError());
		TRACE_EXIT();
		return FALSE;
	}

	TRACE_EXIT();
	return TRUE;
}

int LoadDevIDFromFile()
{
	TRACE_ENTER();

	TCHAR strLoopbackIDFilePath[MAX_PATH + 30];
	if (!GetConfigFilePath(strLoopbackIDFilePath))
	{
		TRACE_PRINT("GetConfigFilePath: error.");
		TRACE_EXIT();
		return FALSE;
	}

	FILE *fp;
	int iDevID;
	if (_tfopen_s(&fp, strLoopbackIDFilePath, _T("r")) != 0 || !fp)
	{
		TRACE_PRINT1("_tfopen_s: error, errCode = 0x%08x.", errno);
		TRACE_EXIT();
		return -1;
	}
	_ftscanf_s(fp, _T("%d"), &iDevID);
	fclose(fp);

	TRACE_EXIT();
	return iDevID;
}

BOOL InstallLoopbackAdapter()
{
	TRACE_ENTER();

	BOOL isWin10 = IsWindowsVersionOrGreater(10, 0, 0);

	if (isWin10)
	{
		PrepareRenameLoopbackNetwork2();
	}

	if (!InstallLoopbackDeviceInternal())
	{
		TRACE_PRINT("InstallLoopbackDeviceInternal: error.");
		TRACE_EXIT();
		return FALSE;
	}

	int iNpcapAdapterID = g_DevInstanceID;
	if (iNpcapAdapterID == -1)
	{
		TRACE_PRINT("iNpcapAdapterID == -1: error.");
		TRACE_EXIT();
		return FALSE;
	}

	if (!RecordLoopbackDevice(iNpcapAdapterID))
	{
		if (isWin10)
		{
			if (!DoRenameLoopbackNetwork2())
			{
				TRACE_PRINT("DoRenameLoopbackNetwork2: error.");
				TRACE_EXIT();
				return FALSE;
			}
		}
		else
		{
			TRACE_PRINT("RecordLoopbackDevice: error.");
			TRACE_EXIT();
			return FALSE;
		}
	}

	if (!SaveDevIDToFile(iNpcapAdapterID))
	{
		TRACE_PRINT("SaveDevIDToFile: error.");
		TRACE_EXIT();
		return FALSE;
	}

	TRACE_EXIT();
	return TRUE;
}

BOOL UninstallLoopbackAdapter()
{
	TRACE_ENTER();

	int iNpcapAdapterID = LoadDevIDFromFile();
	if (iNpcapAdapterID == -1)
	{
		TRACE_PRINT("iNpcapAdapterID == -1: error.");
		TRACE_EXIT();
		return FALSE;
	}

	if (!RemoveLoopbackDeviceInternal(iNpcapAdapterID))
	{
		TRACE_PRINT("RemoveLoopbackDeviceInternal: error.");
		TRACE_EXIT();
		return FALSE;
	}

  if (!EraseLoopbackRecord())
	{
		TRACE_PRINT("EraseLoopbackRecord: error.");
		TRACE_EXIT();
		return FALSE;
	}

  if (!DeleteDevIDFile())
	{
		TRACE_PRINT("DeleteDevIDFile: error.");
		TRACE_EXIT();
		return FALSE;
	}

	TRACE_EXIT();
	return TRUE;
}

```

`packetWin7/NPFInstall/NPFInstall/LoopbackInstall.h`:

```h
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
/*++

Module Name:

    LoopbackInstall.h

Abstract:

    Device Console header

--*/

#include <windows.h>
#include <tchar.h>
#include <stdlib.h>
#include <stdio.h>
#include <setupapi.h>
#include <regstr.h>
#include <infstr.h>
#include <cfgmgr32.h>
#include <string.h>
#include <malloc.h>
#include <newdev.h>
#include <objbase.h>

#include "msg.h"
#include "rc_ids.h"

//
// Devcon.exe command line flags
//
#define DEVCON_FLAG_FORCE       0x00000001

void FormatToStream(_In_ FILE * stream, _In_ DWORD fmt,...);

//
// UpdateDriverForPlugAndPlayDevices
//
typedef BOOL (WINAPI *UpdateDriverForPlugAndPlayDevicesProto)(_In_opt_ HWND hwndParent,
															  _In_ LPCTSTR HardwareId,
															  _In_ LPCTSTR FullInfPath,
															  _In_ DWORD InstallFlags,
															  _Out_opt_ PBOOL bRebootRequired
															  );

#ifdef _UNICODE
#define UPDATEDRIVERFORPLUGANDPLAYDEVICES "UpdateDriverForPlugAndPlayDevicesW"
#define SETUPUNINSTALLOEMINF "SetupUninstallOEMInfW"
#else
#define UPDATEDRIVERFORPLUGANDPLAYDEVICES "UpdateDriverForPlugAndPlayDevicesA"
#define SETUPUNINSTALLOEMINF "SetupUninstallOEMInfA"
#endif

//
// exit codes
//
#define EXIT_OK      (0)
#define EXIT_REBOOT  (1)
#define EXIT_FAIL    (2)
#define EXIT_USAGE   (3)

//
// Declarations
//
void FormatToStream(_In_ FILE * stream, _In_ DWORD fmt,...);
/*int cmdStatus(_In_ LPCTSTR BaseName, _In_opt_ LPCTSTR Machine, _In_ DWORD Flags, _In_ int argc, _In_reads_(argc) PTSTR argv[]);*/
int cmdUpdate(_In_ LPCTSTR BaseName, _In_opt_ LPCTSTR Machine, _In_ DWORD Flags, _In_ int argc, _In_reads_(argc) PTSTR argv[]);
int cmdInstall(_In_ LPCTSTR BaseName, _In_opt_ LPCTSTR Machine, _In_ DWORD Flags, _In_ int argc, _In_reads_(argc) PTSTR argv[]);
int cmdRemove(_In_ LPCTSTR BaseName, _In_opt_ LPCTSTR Machine, _In_ DWORD Flags, _In_ int argc, _In_reads_(argc) PTSTR argv[]);
typedef int (*CallbackFunc)(_In_ HDEVINFO Devs, _In_ PSP_DEVINFO_DATA DevInfo, _In_ DWORD Index, _In_ LPVOID Context);

/*BOOL ListLoopbackAdapters();*/
BOOL GetLoopbackINFFilePath(TCHAR strLoopbackInfPath[]);
BOOL GetConfigFilePath(TCHAR strConfigPath[]);
BOOL InstallLoopbackDeviceInternal();
BOOL RemoveLoopbackDeviceInternal(int iDevID);
BOOL SaveDevIDToFile(int iDevID);
int LoadDevIDFromFile();
BOOL InstallLoopbackAdapter();
BOOL UninstallLoopbackAdapter();

```

`packetWin7/NPFInstall/NPFInstall/LoopbackRecord.cpp`:

```cpp
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
/*++

Module Name:

	LoopbackRecord.cpp

Abstract:

	This is used for enumerating our "Npcap Loopback Adapter" using NetCfg API, if found, we changed its name from "Ethernet X" or "Local Network Area" to "Npcap Loopback Adapter".
	Also, we need to make a flag in registry to let the Npcap driver know that "this adapter is ours", so send the loopback traffic to it.

--*/

#include <Netcfgx.h>

#include <iostream>
#include <atlbase.h> // CComPtr
#include <devguid.h> // GUID_DEVCLASS_NET, ...

#include "LoopbackRecord.h"
#include "LoopbackRename.h"
#include "RegUtil.h"

#include "debug.h"

#define			NPCAP_LOOPBACK_ADAPTER_NAME				NPF_DRIVER_NAME_NORMAL_WIDECHAR L" Loopback Adapter"
#define			NPCAP_LOOPBACK_APP_NAME					NPF_DRIVER_NAME_NORMAL_WIDECHAR L"_Loopback"

#define BUFSIZE 512
int g_NpcapAdapterID = -1;

// RAII helper class
class COM
{
public:
	COM();
	~COM();
};

COM::COM()
{
	TRACE_ENTER();

	HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

	if(!SUCCEEDED(hr))
	{
		TRACE_PRINT1("CoInitializeEx: error, errCode = 0x%08x.", hr);
	}

	TRACE_EXIT();
}

COM::~COM()
{
	TRACE_ENTER();

	CoUninitialize();

	TRACE_EXIT();
}

// RAII helper class
class NetCfg
{
	CComPtr<INetCfg> m_pINetCfg;
	CComPtr<INetCfgLock> m_pLock;

public:
	NetCfg();
	~NetCfg();

	// Displays all network adapters, clients, transport protocols and services.
	// For each client, transport protocol and service (network features) 
	//    shows adpater(s) they are bound to.
	BOOL GetNetworkConfiguration(); 
};

NetCfg::NetCfg() : m_pINetCfg(0)
{
	TRACE_ENTER();

	HRESULT hr = S_OK;

	hr = m_pINetCfg.CoCreateInstance(CLSID_CNetCfg);

	if(!SUCCEEDED(hr))
	{
		TRACE_PRINT1("INetCfg::CoCreateInstance: error, errCode = 0x%08x.", hr);
		throw 1;
	}

	hr = m_pINetCfg.QueryInterface(&m_pLock);

	if (!SUCCEEDED(hr))
	{
		TRACE_PRINT1("INetCfg::QueryInterface: error, errCode = 0x%08x.", hr);
		throw 2;
	}

	// Note that this call can block.
	hr = m_pLock->AcquireWriteLock(INFINITE, NPCAP_LOOPBACK_APP_NAME, NULL);
	if (!SUCCEEDED(hr))
	{
		TRACE_PRINT1("INetCfgLock::AcquireWriteLock: error, errCode = 0x%08x.", hr);
		throw 3;
	}

	hr = m_pINetCfg->Initialize(NULL);

	if(!SUCCEEDED(hr))
	{
		TRACE_PRINT1("INetCfg::Initialize: error, errCode = 0x%08x.", hr);
		throw 4;
	}

	TRACE_EXIT();
}

NetCfg::~NetCfg()
{
	TRACE_ENTER();

	HRESULT hr = S_OK;

	if(m_pINetCfg)
	{
		hr = m_pINetCfg->Uninitialize();
		if(!SUCCEEDED(hr))
		{
			TRACE_PRINT1("INetCfg::Uninitialize: error, errCode = 0x%08x.", hr);
		}

		hr = m_pLock->ReleaseWriteLock();
		if (!SUCCEEDED(hr))
		{
			TRACE_PRINT1("INetCfgLock::ReleaseWriteLock: error, errCode = 0x%08x.", hr);
		}
	}

	TRACE_EXIT();
}

BOOL EnumerateComponents(CComPtr<INetCfg>& pINetCfg, const GUID* pguidClass)
{
	TRACE_ENTER();

	/*	cout << "\n\nEnumerating " << GUID2Str(pguidClass) << " class:\n" << endl;*/

	// IEnumNetCfgComponent provides methods that enumerate the INetCfgComponent interfaces 
	// for network components of a particular type installed on the operating system. 
	// Types of network components include network cards, protocols, services, and clients.
	CComPtr<IEnumNetCfgComponent> pIEnumNetCfgComponent;

	// get enumeration containing network components of the provided class (GUID)
	HRESULT hr = pINetCfg->EnumComponents(pguidClass, &pIEnumNetCfgComponent);

	if(!SUCCEEDED(hr))
	{
		TRACE_PRINT1("INetCfg::EnumComponents: error, errCode = 0x%08x.", hr);
		throw 1;
	} 

	// INetCfgComponent interface provides methods that control and retrieve 
	// information about a network component.
	CComPtr<INetCfgComponent> pINetCfgComponent;

	unsigned int nIndex = 1;
	BOOL bFound = FALSE;
	BOOL bFailed = FALSE;
	// retrieve the next specified number of INetCfgComponent interfaces in the enumeration sequence.
	while(pIEnumNetCfgComponent->Next(1, &pINetCfgComponent, 0) == S_OK)
	{
		/*		cout << GUID2Desc(pguidClass) << " "<< nIndex++ << ":\n";*/

// 		LPWSTR pszDisplayName = NULL;
// 		pINetCfgComponent->GetDisplayName(&pszDisplayName);
// 		wcout << L"\tDisplay name: " << wstring(pszDisplayName) << L'\n';
// 		CoTaskMemFree(pszDisplayName);

		LPWSTR pszBindName = NULL;
		pINetCfgComponent->GetBindName(&pszBindName);
//		wcout << L"\tBind name: " << wstring(pszBindName) << L'\n';

// 		DWORD dwCharacteristics = 0;
// 		pINetCfgComponent->GetCharacteristics(&dwCharacteristics);
// 		cout << "\tCharacteristics: " << dwCharacteristics << '\n';
// 
// 		GUID guid;  
// 		pINetCfgComponent->GetClassGuid(&guid);
// 		cout << "\tClass GUID: " << guid.Data1 << '-' << guid.Data2 << '-'
// 			<< guid.Data3 << '-' << (unsigned int) guid.Data4 << '\n';
// 
// 		ULONG ulDeviceStatus = 0;
// 		pINetCfgComponent->GetDeviceStatus(&ulDeviceStatus);
// 		cout << "\tDevice Status: " << ulDeviceStatus << '\n';
// 
// 		LPWSTR pszHelpText = NULL;
// 		pINetCfgComponent->GetHelpText(&pszHelpText);
// 		wcout << L"\tHelp Text: " << wstring(pszHelpText) << L'\n';
// 		CoTaskMemFree(pszHelpText);
// 
// 		LPWSTR pszID = NULL;
// 		pINetCfgComponent->GetId(&pszID);
// 		wcout << L"\tID: " << wstring(pszID) << L'\n';
// 		CoTaskMemFree(pszID);
// 
// 		pINetCfgComponent->GetInstanceGuid(&guid);
// 		cout << "\tInstance GUID: " << guid.Data1 << '-' << guid.Data2 << '-'
// 			<< guid.Data3 << '-' << (unsigned int) guid.Data4 << '\n';

		LPWSTR pszPndDevNodeId = NULL;
		hr = pINetCfgComponent->GetPnpDevNodeId(&pszPndDevNodeId);
		if (!SUCCEEDED(hr))
		{
			TRACE_PRINT1("GetPnpDevNodeId failed: %#x", hr);
			TRACE_EXIT();
			return FALSE;
		}
//		wcout << L"\tPNP Device Node ID: " << wstring(pszPndDevNodeId) << L'\n';

		int iDevID = getIntDevID(pszPndDevNodeId);
		TRACE_PRINT4("INetCfgComponent::GetPnpDevNodeId: executing, pszPndDevNodeId = %s, iDevID = %d, g_NpcapAdapterID = %d, pszBindName = %ws.",
			pszPndDevNodeId, iDevID, g_NpcapAdapterID, pszBindName);
		if (g_NpcapAdapterID == iDevID)
		{
			bFound = TRUE;

			TRACE_PRINT2("INetCfgComponent::SetDisplayName: executing, g_NpcapAdapterID = iDevID = %d, pszBindName = %ws.", g_NpcapAdapterID, pszBindName);
			hr = pINetCfgComponent->SetDisplayName(NPCAP_LOOPBACK_ADAPTER_NAME);

			if (hr != S_OK)
			{
				TRACE_PRINT1("INetCfgComponent::SetDisplayName: error, errCode = 0x%08x.", hr);
				bFailed = TRUE;
			}

			if (!AddFlagToRegistry(pszBindName))
			{
				TRACE_PRINT1("AddFlagToRegistry: error, pszBindName = %ws.", pszBindName);
				bFailed = TRUE;
			}

 			if (!AddFlagToRegistry_Service(pszBindName))
 			{
				TRACE_PRINT1("AddFlagToRegistry_Service: error, pszBindName = %ws.", pszBindName);
 				bFailed = TRUE;
 			}

			if (!RenameLoopbackNetwork(pszBindName))
			{
				TRACE_PRINT1("RenameLoopbackNetwork: error, pszBindName = %ws.", pszBindName);
				bFailed = TRUE;
			}
		}

		CoTaskMemFree(pszBindName);
		CoTaskMemFree(pszPndDevNodeId);
		pINetCfgComponent.Release();

		if (bFound)
		{
			TRACE_EXIT();
			return !bFailed;
		}
	}

	TRACE_EXIT();
	return FALSE;
}

BOOL NetCfg::GetNetworkConfiguration()
{
	TRACE_ENTER();
	// get enumeration containing GUID_DEVCLASS_NET class of network components
	TRACE_EXIT();
	return EnumerateComponents(m_pINetCfg, &GUID_DEVCLASS_NET);
}

int getIntDevID(TCHAR strDevID[]) //DevID is in form like: "ROOT\\NET\\0008"
{
	TRACE_ENTER();

	int iDevID = -1;
	int iMatched = _stscanf_s(strDevID, _T("ROOT\\NET\\%04d"), &iDevID);
	TRACE_PRINT2("_stscanf_s: iMatched = %d, iDevID = %d.", iMatched, iDevID);
	if (iMatched != 1)
		iDevID = -1;

	TRACE_EXIT();
	return iDevID;
}

BOOL AddFlagToRegistry(tstring strDeviceName)
{
	TRACE_ENTER();
	TRACE_EXIT();
	return WriteStrToRegistry(NPCAP_REG_KEY_NAME, NPCAP_REG_LOOPBACK_VALUE_NAME, tstring(_T("\\Device\\") + strDeviceName).c_str(), KEY_WRITE | KEY_WOW64_32KEY);
}

BOOL AddFlagToRegistry_Service(tstring strDeviceName)
{
	TRACE_ENTER();
	BOOL rv = TRUE;

	rv = WriteStrToRegistry(NPCAP_SERVICE_REG_KEY_NAME _T("\\Parameters"), NPCAP_REG_LOOPBACK_VALUE_NAME, tstring(_T("\\Device\\") + strDeviceName).c_str(), KEY_WRITE) && rv;

	TRACE_EXIT();
	return rv;
}

BOOL RecordLoopbackDevice(int iNpcapAdapterID)
{
	TRACE_ENTER();

	g_NpcapAdapterID = iNpcapAdapterID;

	try
	{
		COM com;
		NetCfg netCfg;
		if (!netCfg.GetNetworkConfiguration())
		{
			TRACE_PRINT("NetCfg::GetNetworkConfiguration: error.");
			TRACE_EXIT();
			return FALSE;
		}
	}
	catch(...)
	{
		TRACE_PRINT("NetCfg::GetNetworkConfiguration: error (exception).");
		TRACE_EXIT();
		return FALSE;
	}

	TRACE_EXIT();
	return TRUE;
}

BOOL EraseLoopbackRecord()
{
	TRACE_ENTER();
	BOOL rv = TRUE;

	if (!DeleteValueFromRegistry(NPCAP_REG_KEY_NAME, NPCAP_REG_LOOPBACK_VALUE_NAME))
	{
		rv = FALSE;
	}

	if (!DeleteValueFromRegistry(NPCAP_SERVICE_REG_KEY_NAME _T("\\Parameters"), NPCAP_REG_LOOPBACK_VALUE_NAME))
	{
		rv = FALSE;
	}

	TRACE_EXIT();
	return rv;
}

```

`packetWin7/NPFInstall/NPFInstall/LoopbackRecord.h`:

```h
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
/*++

Module Name:

	LoopbackRecord.h

Abstract:

	This is used for enumerating our "Npcap Loopback Adapter" using NetCfg API, if found, we changed its name from "Ethernet X" or "Local Network Area" to "Npcap Loopback Adapter".
	Also, we need to make a flag in registry to let the Npcap driver know that "this adapter is ours", so send the loopback traffic to it.

--*/

#include <vector>
#include <string>
using namespace std;

typedef std::basic_string<TCHAR> tstring;

int getIntDevID(TCHAR strDevID[]);
BOOL AddFlagToRegistry(tstring strDeviceName);
BOOL AddFlagToRegistry_Service(tstring strDeviceName);
BOOL RecordLoopbackDevice(int iNpcapAdapterID);
BOOL EraseLoopbackRecord();

```

`packetWin7/NPFInstall/NPFInstall/LoopbackRename.cpp`:

```cpp
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
/*++

Module Name:

    LoopbackRename.cpp

Abstract:

    This is used for enumerating our "Npcap Loopback Adapter" using NetCfg API, if found, we changed its name from "Ethernet X" to "Npcap Loopback Adapter".
    Also, we need to make a flag in registry to let the Npcap driver know that "this adapter is ours", so send the loopback traffic to it.

This code is modified based on example: https://msdn.microsoft.com/en-us/library/windows/desktop/aa364686.aspx
--*/

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <objbase.h>
#include <netcon.h>
#include <stdio.h>

#include "LoopbackRename.h"

#include "debug.h"

#pragma comment(lib, "ole32.lib")
#pragma comment(lib, "oleaut32.lib")

#define			NPCAP_LOOPBACK_INTERFACE_NAME			NPF_DRIVER_NAME_NORMAL_WIDECHAR L" Loopback Adapter"
#define			BUF_SIZE								255

BOOL DoTheWork(INetSharingManager *pNSM, TCHAR strDeviceName[])
{
	TRACE_ENTER();

	// add a port mapping to every firewalled or shared connection 
	BOOL bFound = FALSE;
	BOOL bError = FALSE;
	INetSharingEveryConnectionCollection * pNSECC = NULL;
	HRESULT hr = pNSM->get_EnumEveryConnection (&pNSECC);
	if (!SUCCEEDED(hr) || !pNSECC)
	{
		TRACE_PRINT1("INetSharingManager::get_EnumEveryConnection: error, errCode = 0x%08x.", hr);
	}
	else {

		// enumerate connections
		IEnumVARIANT * pEV = NULL;
		IUnknown * pUnk = NULL;
		hr = pNSECC->get__NewEnum (&pUnk);
		if (SUCCEEDED(hr) && pUnk) {
			hr = pUnk->QueryInterface (__uuidof(IEnumVARIANT),
				(void**)&pEV);
			pUnk->Release();
		}
		else
		{
			TRACE_PRINT1("INetSharingEveryConnectionCollection::get__NewEnum: error, errCode = 0x%08x.", hr);
		}

		if (pEV) {
			VARIANT v;
			VariantInit (&v);

			while ((S_OK == pEV->Next (1, &v, NULL)) && (bFound == FALSE)) {
				if (V_VT (&v) == VT_UNKNOWN) {
					INetConnection * pNC = NULL;
					V_UNKNOWN (&v)->QueryInterface (__uuidof(INetConnection),
						(void**)&pNC);
					if (pNC) {
						NETCON_PROPERTIES *pNETCON_PROPERTIES;
						hr = pNC->GetProperties(&pNETCON_PROPERTIES);
						if (SUCCEEDED(hr))
						{

							TCHAR currentGUID[BUF_SIZE];
							GUID guid = pNETCON_PROPERTIES->guidId;
							_stprintf_s(currentGUID, BUF_SIZE, _T("{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"),
								guid.Data1, guid.Data2, guid.Data3,
								guid.Data4[0], guid.Data4[1], guid.Data4[2], guid.Data4[3],
								guid.Data4[4], guid.Data4[5], guid.Data4[6], guid.Data4[7]);

							TRACE_PRINT2("IEnumVARIANT::Next: executing, currentGUID = %s, strDeviceName = %s.", currentGUID, strDeviceName);
							if (_tcscmp(currentGUID, strDeviceName) == 0)
							{
								TRACE_PRINT2("INetConnection::Rename: executing, currentGUID = strDeviceName = %s, pszwNewName = %s.", currentGUID, NPCAP_LOOPBACK_INTERFACE_NAME);

								hr = pNC->Rename(NPCAP_LOOPBACK_INTERFACE_NAME);
								bFound = TRUE;
								if (hr == HRESULT_FROM_WIN32(ERROR_TRANSACTIONAL_CONFLICT))
								{
									TRACE_PRINT1("INetConnection::Rename: error, errCode = 0x%08x.", hr);
									bError = TRUE;
								}
								else if (hr != S_OK)
								{
									TRACE_PRINT1("INetConnection::Rename: error, errCode = 0x%08x.", hr);
									bError = TRUE;
								}
								else
								{
									bError = FALSE;
								}
							}
						}
						pNC->Release();
					}
				}
				VariantClear(&v);
			}
			pEV->Release();
		}
		pNSECC->Release();
	}
	
	if (!bFound)
	{
		TRACE_PRINT("DoTheWork: error, bFound = 0.");
		TRACE_EXIT();
		return FALSE;
	}
	else
	{
		TRACE_EXIT();
		return !bError;
	}
}

BOOL RenameLoopbackNetwork(TCHAR strDeviceName[])
{
	TRACE_ENTER();

	BOOL bResult = FALSE;
	HRESULT hr = S_OK;
/*	CoInitialize (NULL);*/

	// init security to enum RAS connections
	hr = CoInitializeSecurity (NULL, -1, NULL, NULL, 
		RPC_C_AUTHN_LEVEL_PKT, 
		RPC_C_IMP_LEVEL_IMPERSONATE,
		NULL, EOAC_NONE, NULL);
	if (!SUCCEEDED(hr))
	{
		TRACE_PRINT1("CoInitializeSecurity: error, errCode = 0x%08x.", hr);
		TRACE_EXIT();
		return FALSE;
	}

	INetSharingManager * pNSM = NULL;    
	hr = ::CoCreateInstance (__uuidof(NetSharingManager),
		NULL,
		CLSCTX_ALL,
		__uuidof(INetSharingManager),
		(void**)&pNSM);
	if (!pNSM)
	{
		TRACE_PRINT1("CoCreateInstance: error, errCode = 0x%08x.", hr);
		TRACE_EXIT();
		return bResult;
	}
	else {

		// add a port mapping to every shared or firewalled connection.
		bResult = DoTheWork(pNSM, strDeviceName);

		pNSM->Release();
	}

/*	CoUninitialize ();*/

	TRACE_EXIT();
	return bResult;
}

```

`packetWin7/NPFInstall/NPFInstall/LoopbackRename.h`:

```h
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
/*++

Module Name:

    LoopbackRename.h

Abstract:

    This is used for enumerating our "Npcap Loopback Adapter" using NetCfg API, if found, we changed its name from "Ethernet X" to "Npcap Loopback Adapter".
    Also, we need to make a flag in registry to let the Npcap driver know that "this adapter is ours", so send the loopback traffic to it.

This code is modified based on example: https://msdn.microsoft.com/en-us/library/windows/desktop/aa364686.aspx
--*/

#include "..\..\Common\WpcapNames.h"

#include <tchar.h>

BOOL RenameLoopbackNetwork(TCHAR strDeviceName[]);

```

`packetWin7/NPFInstall/NPFInstall/LoopbackRename2.cpp`:

```cpp
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
/*++

Module Name:

    LoopbackRename2.cpp

Abstract:

    This is used for enumerating our "Npcap Loopback Adapter" using netsh.exe tool, if found, we changed its name from "Ethernet X" to "Npcap Loopback Adapter".

This code is based on the Windows built-in netsh.exe tool.
--*/

#include "LoopbackRename2.h"

#include "debug.h"

#ifdef _UNICODE
#define			NPCAP_LOOPBACK_INTERFACE_NAME				NPF_DRIVER_NAME_NORMAL_WIDECHAR L" Loopback Adapter"
#else
#define			NPCAP_LOOPBACK_INTERFACE_NAME				NPF_DRIVER_NAME_NORMAL " Loopback Adapter"
#endif
#define			NPCAP_LOOPBACK_INTERFACE_MTU				65536
#define			BUF_SIZE									255

vector<tstring> g_InterfaceNameList1;
vector<tstring> g_InterfaceNameList2;

tstring getNpcapLoopbackAdapterName()
{
	TRACE_ENTER();

	if (g_InterfaceNameList1.size() != g_InterfaceNameList2.size() - 1)
	{
		TRACE_PRINT2("getNpcapLoopbackAdapterName: error, g_InterfaceNameList1.size() = %d, g_InterfaceNameList2.size() = %d.",
			g_InterfaceNameList1.size(), g_InterfaceNameList2.size());
		TRACE_EXIT();
		return _T("");
	}

	for (size_t i = 0; i < g_InterfaceNameList2.size(); i ++)
	{
		int found = 0;
		for (size_t j = 0; j < g_InterfaceNameList1.size(); j ++)
		{
			if (g_InterfaceNameList2[i].compare(g_InterfaceNameList1[j]) == 0)
			{
				found = 1;
				break;
			}
		}
		if (found == 0)
		{
			TRACE_PRINT1("getNpcapLoopbackAdapterName: found the new interface, i = %d.", i);
			TRACE_EXIT();
			return g_InterfaceNameList2[i];
		}
	}

	TRACE_PRINT("getNpcapLoopbackAdapterName: unknown error.");
	TRACE_EXIT();
	return _T("");
}

wstring ANSIToUnicode(const string& str)
{
	size_t len = 0;
	len = str.length();
	int unicodeLen = ::MultiByteToWideChar(CP_ACP,
		0,
		str.c_str(),
		-1,
		NULL,
		0);
	wchar_t * pUnicode;
	pUnicode = new wchar_t[unicodeLen + 1];
	memset(pUnicode, 0, (unicodeLen + 1)*sizeof(wchar_t));
	::MultiByteToWideChar(CP_ACP,
		0,
		str.c_str(),
		-1,
		(LPWSTR) pUnicode,
		unicodeLen);
	wstring rt;
	rt = (wchar_t*) pUnicode;
	delete[] pUnicode;
	return rt;
}

tstring executeCommand(TCHAR* strCmd)
{
	TRACE_ENTER();
	TRACE_PRINT1("executeCommand: executing, strCmd = %s.", strCmd);

	tstring result;
	string tmp = "";
	HANDLE g_hChildStd_OUT_Wr = NULL;
	HANDLE g_hChildStd_OUT_Rd = NULL;
	STARTUPINFO si = { 0 };
	PROCESS_INFORMATION pi = { 0 };
	SECURITY_ATTRIBUTES saAttr;

	// Set the bInheritHandle flag so pipe handles can be inherited. 
	saAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
	saAttr.bInheritHandle = TRUE;
	saAttr.lpSecurityDescriptor = NULL;

	// Create a pipe for stdout
	if (!CreatePipe(&g_hChildStd_OUT_Rd, &g_hChildStd_OUT_Wr, &saAttr, 0))
	{
		DWORD error = ::GetLastError();
		TRACE_PRINT1("CreatePipe: error, errCode = 0x%08x.", error);
		TRACE_EXIT();
		return _T("");
	}

	// Set the read handle for stdout as not inheritable
	SetHandleInformation(g_hChildStd_OUT_Rd, HANDLE_FLAG_INHERIT, 0);

	// Set the process to use STD handles and the window to hidden
	si.cb = sizeof(STARTUPINFO);
	si.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;
	si.wShowWindow = SW_HIDE;
	si.hStdError = g_hChildStd_OUT_Wr;
	si.hStdOutput = g_hChildStd_OUT_Wr;
	si.hStdInput = GetStdHandle(STD_INPUT_HANDLE);

	// Create the process
	BOOL executed = ::CreateProcess(NULL, strCmd, NULL, NULL, TRUE, CREATE_NO_WINDOW, NULL, NULL, &si, &pi);
	if (executed == FALSE)
	{
		DWORD error = ::GetLastError();
		TRACE_PRINT1("CreateProcess: error, errCode = 0x%08x.", error);
		TRACE_EXIT();
		CloseHandle(g_hChildStd_OUT_Wr);
		CloseHandle(g_hChildStd_OUT_Rd);
		return _T("");
	}

	CloseHandle(pi.hThread);
	CloseHandle(pi.hProcess);

	// Release the write handle since we have handed it off
	CloseHandle(g_hChildStd_OUT_Wr);
	g_hChildStd_OUT_Wr = 0;

	// Read pipe
	char aBuf[2048 + 1];
	while (true)
	{
		DWORD dwRead = 0;
		BOOL status = ReadFile(g_hChildStd_OUT_Rd, aBuf, 2048, &dwRead, NULL);
		if (!status || dwRead == 0) {
			break;
		}
		aBuf[dwRead] = '\0';
		tmp += aBuf;
	}

	// Close read handle
	CloseHandle(g_hChildStd_OUT_Rd);

#ifdef _UNICODE
	result = ANSIToUnicode(tmp);
#else
	result = tmp;
#endif

	TRACE_PRINT1("executeCommand: result = %s.", result.c_str());

	TRACE_EXIT();
	return result;
}

// getInterfaceNamesFromNetshOutput() function is used to get interface names from string like below:
//
// Admin State    State          Type             Interface Name
// -------------------------------------------------------------------------
// Enabled        Connected      Dedicated        VMware Network Adapter VMnet1
// Enabled        Connected      Dedicated        VMware Network Adapter VMnet8
// Enabled        Connected      Dedicated        VMware Network Adapter VMnet2
// Enabled        Connected      Dedicated        VMware Network Adapter VMnet3
// Enabled        Connected      Dedicated        Wi-Fi
// Disabled       Disconnected   Dedicated        Ethernet
// Enabled        Connected      Dedicated        Npcap Loopback Adapter
//
vector<tstring> getInterfaceNamesFromNetshOutput(tstring strOutput)
{
	TRACE_ENTER();

	vector<tstring> nResults;
	size_t iLineStart;
	size_t iLineEnd = 0;
	size_t iStringStart;
	size_t iStringEnd;

	iLineEnd = strOutput.find(_T('-'), iLineEnd);
	if (iLineEnd == tstring::npos)
	{
		TRACE_EXIT();
		return nResults;
	}
	iLineEnd ++;

	iLineEnd = strOutput.find(_T('\n'), iLineEnd);
	if (iLineEnd == tstring::npos)
	{
		TRACE_EXIT();
		return nResults;
	}

	iLineEnd ++;
	iLineStart = iLineEnd;

	while ((iLineEnd = strOutput.find(_T('\n'), iLineEnd)) != tstring::npos)
	{
		iStringStart = strOutput.rfind(_T("    "), iLineEnd);
		if (iStringStart < iLineStart)
		{
			TRACE_EXIT();
			return nResults;
		}
		else
		{
			iStringStart += _tcslen(_T("    "));
		}
		iStringEnd = strOutput.find_first_of(_T("\r\n"), iStringStart);

		tstring strInterfaceName = strOutput.substr(iStringStart, iStringEnd - iStringStart);
		TRACE_PRINT1("getInterfaceNamesFromNetshOutput: executing, strInterfaceName = %s.", strInterfaceName.c_str());
		nResults.push_back(strInterfaceName);

		iLineEnd ++;
		iLineStart = iLineEnd;
	}

	TRACE_EXIT();
	return nResults;
}

// getMajorVersionNumberFromVerOutput() function is used to get Windows major version number from string like below:
//
// Microsoft Windows [Version 6.3.9600]
//
// OR
//
// Microsoft Windows [Version 10.0.10102]
//
// The "standard" GetWindowsVersionEx() way doesn't work out on Win10, because it returns 6.3 (Win8) on Win10.
// tstring getMajorVersionNumberFromVerOutput(tstring strOutput)
// {
// 	size_t iStringStart;
// 	size_t iStringEnd;
//
// 	iStringStart = strOutput.find(_T("Version"));
// 	if (iStringStart == tstring::npos)
// 	{
// 		return _T("");
// 	}
// 	iStringStart += 8;
//
// 	iStringEnd = strOutput.find(_T('.'), iStringStart);
// 	if (iStringEnd == tstring::npos)
// 	{
// 		return _T("");
// 	}
//
// 	tstring strNumber = strOutput.substr(iStringStart, iStringEnd - iStringStart);
// 	return strNumber;
// }

void snapshotInterfaceListBeforeInstall()
{
	TRACE_ENTER();

	TCHAR cmdLine[] = _T("netsh.exe interface show interface");
	tstring cmd = executeCommand(cmdLine);
	g_InterfaceNameList1 = getInterfaceNamesFromNetshOutput(cmd);

	TRACE_EXIT();
}

void snapshotInterfaceListAfterInstall()
{
	TRACE_ENTER();

	TCHAR cmdLine[] = _T("netsh.exe interface show interface");
	tstring cmd = executeCommand(cmdLine);
	g_InterfaceNameList2 = getInterfaceNamesFromNetshOutput(cmd);

	TRACE_EXIT();
}

void PrepareRenameLoopbackNetwork2()
{
	TRACE_ENTER();

	snapshotInterfaceListBeforeInstall();

	TRACE_EXIT();
}

void changeLoopbackInterfaceMTU(tstring strInterfaceName)
{
	TRACE_ENTER();

	TCHAR renameCmd[MAX_PATH];
	_stprintf_s(renameCmd, MAX_PATH, _T("netsh.exe interface ipv4 set subinterface \"%s\" mtu=%d store=persistent"), (LPCTSTR) strInterfaceName.c_str(), NPCAP_LOOPBACK_INTERFACE_MTU);
	executeCommand(renameCmd);
	_stprintf_s(renameCmd, MAX_PATH, _T("netsh.exe interface ipv6 set subinterface \"%s\" mtu=%d store=persistent"), (LPCTSTR) strInterfaceName.c_str(), NPCAP_LOOPBACK_INTERFACE_MTU);
	executeCommand(renameCmd);

	TRACE_EXIT();
}

void renameLoopbackInterface(tstring strInterfaceName)
{
	TRACE_ENTER();

	TCHAR renameCmd[MAX_PATH];
	_stprintf_s(renameCmd, MAX_PATH, _T("netsh.exe interface set interface name=\"%s\" newname=\"%s\""), (LPCTSTR) strInterfaceName.c_str(), NPCAP_LOOPBACK_INTERFACE_NAME);
	executeCommand(renameCmd);

	TRACE_EXIT();
}

BOOL DoRenameLoopbackNetwork2()
{
	TRACE_ENTER();

	snapshotInterfaceListAfterInstall();
	tstring strOriginalInterfaceName = getNpcapLoopbackAdapterName();
	TRACE_PRINT1("getNpcapLoopbackAdapterName: executing, strOriginalInterfaceName = %s.", strOriginalInterfaceName.c_str());
	if (strOriginalInterfaceName.compare(_T("")) == 0)
	{
		TRACE_PRINT("getNpcapLoopbackAdapterName: error, strOriginalInterfaceName = NULL.");
		TRACE_EXIT();
		return FALSE;
	}

	changeLoopbackInterfaceMTU(strOriginalInterfaceName);
	renameLoopbackInterface(strOriginalInterfaceName);

	TRACE_EXIT();
	return TRUE;
}

```

`packetWin7/NPFInstall/NPFInstall/LoopbackRename2.h`:

```h
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
/*++

Module Name:

    LoopbackRename2.h

Abstract:

    This is used for enumerating our "Npcap Loopback Adapter" using netsh.exe tool, if found, we changed its name from "Ethernet X" to "Npcap Loopback Adapter".

This code is based on the Windows built-in netsh.exe tool.
--*/

#include "..\..\Common\WpcapNames.h"

#include <windows.h>
#include <vector>
#include <string>
using namespace std;

typedef std::basic_string<TCHAR> tstring;
#include <tchar.h>

tstring executeCommand(TCHAR* strCmd);

void PrepareRenameLoopbackNetwork2();

BOOL DoRenameLoopbackNetwork2();

```

`packetWin7/NPFInstall/NPFInstall/NPFInstall.cpp`:

```cpp
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
#include <tchar.h>
#include <windows.h>

#include "..\..\..\version.h"

#include "ProtInstall.h"
#include "LoopbackInstall.h"
#include "CalloutInstall.h"
#include "DriverStoreClear.h"
#include "RegUtil.h"
#include "ProcessUtil.h"
#include <Netcfgx.h>

#include "debug.h"

extern BOOLEAN bWiFiService;

#define STR_COMMAND_USAGE \
_T("NPFInstall for Npcap ") _T(WINPCAP_VER_STRING) _T(" ( https://npcap.com )\n") \
_T("Usage: NPFInstall [Options]\n") \
_T("\n") \
_T("OPTIONS:\n") \
_T("  -i\t\t\t: Install the LWF driver\n") \
_T("  -i2\t\t\t: Install the LWF driver (with Wi-Fi support)\n") \
_T("  -u\t\t\t: Uninstall the LWF driver\n") \
_T("  -u2\t\t\t: Uninstall the LWF driver (with Wi-Fi support)\n") \
_T("  -iw\t\t\t: Install the WFP callout driver\n") \
_T("  -uw\t\t\t: Uninstall the WFP callout driver\n") \
_T("  -il\t\t\t: Install \"Npcap loopback adapter\"\n") \
_T("  -ul\t\t\t: Uninstall \"Npcap loopback adapter\"\n") \
_T("  -r\t\t\t: Restart all bindings\n") \
_T("  -r2\t\t\t: Restart all bindings (with Wi-Fi support)\n") \
_T("  -check_dll\t\t: Detect whether the Npcap DLLs are still used by any processes, will list them if yes\n") \
_T("  -kill_proc\t\t: Terminate all the processes that are still using Npcap DLLs\n") \
_T("  -kill_proc_soft\t: Gracefully terminate all the processes that are still using Npcap DLLs (only for GUI processes, CLI processes will not be terminated)\n") \
_T("  -kill_proc_polite\t: Politely terminate all the processes that are still using Npcap DLLs (wait for 15 seconds for GUI processes to close themselves, CLI processes will still be terminiated immediatelly)\n") \
_T("  -c\t\t\t: Clear all the driverstore cache for the driver\n") \
_T("  -n\t\t\t: Hide this window when executing the command\n") \
_T("  -h\t\t\t: Print this help summary page\n") \
_T("\n") \
_T("EXAMPLES:\n") \
_T("  NPFInstall -i\n") \
_T("  NPFInstall -iw\n") \
_T("\n") \
_T("SEE THE MAN PAGE (https://github.com/nmap/npcap) FOR MORE OPTIONS AND EXAMPLES\n")

#define STR_INVALID_PARAMETER _T("Error: invalid parameter, type in \"NPFInstall -h\" for help.\n")

static int trace_exit(_In_ int nStatus)
{
	TRACE_PRINT2("<-- _tmain: %s, nStatus = %d.", nStatus == 0 ? _T("succeed") : _T("error"), nStatus);
	return nStatus;
}

int _tmain(int argc, _TCHAR* argv[])
{
	TRACE_ENTER();

	BOOL bSuccess = FALSE;
	BOOL bNoWindow = FALSE;
	int nStatus = 0;

	SetConsoleTitle(_T("NPFInstall for Npcap ") _T(WINPCAP_VER_STRING) _T(" (https://npcap.com)"));
	bWiFiService = FALSE;
	PTSTR theArg = NULL;

	if (argc <= 1 || argc > 3)
	{
		_tprintf(STR_COMMAND_USAGE);
		return trace_exit(0);
	}

	for (int i = 1; i < argc; i++)
	{
		TRACE_PRINT2("_tmain: executing, argv[%d] = %s.", i, argv[i]);
		if (argv[i][0] == _T('-')) {
			if (argv[i][1] == _T('n') && argv[i][2] == _T('\0')) {
				// -n
				bNoWindow = TRUE;
			}
			else if (argv[i][1] != _T('\0')) {
				if (theArg != NULL) {
					// only one command at a time!
					nStatus = -1;
					break;
				}
				theArg = argv[i];
				if (theArg[2] == _T('2') && theArg[3] == _T('\0')) {
					// -i2, -r2, etc.
					bWiFiService = TRUE;
					theArg[2] = _T('\0');
				}
			}
		}
	}

	if (bNoWindow)
	{
		ShowWindow(GetConsoleWindow(), SW_HIDE);
	}

	if (!theArg || nStatus != 0)
	{
		_tprintf(STR_INVALID_PARAMETER);
		return trace_exit(-1);
	}

	// Guaranteed theArg starts with '-' now
	switch (theArg[1]) {
		case _T('i'):
			if (theArg[2] == _T('\0')) {
				// -i or -i2
				BOOL first_time = TRUE;
				BOOL try_again = FALSE;
				// Make sure NetCfg doesn't keep an old driver around
				UninstallDriver(); // Don't care about return value
				do {
					try_again = FALSE;
					if (InstallDriver())
					{
						_tprintf(_T("%s has been successfully installed!\n"),
								bWiFiService ? NPF_SERVICE_DESC_TCHAR_WIFI : NPF_SERVICE_DESC_TCHAR);
						break;
					}

					const DWORD err = GetLastError();
					if (err == NETCFG_S_REBOOT) {
						_tprintf(_T("%s will be installed after reboot.\n"),
								bWiFiService ? NPF_SERVICE_DESC_TCHAR_WIFI : NPF_SERVICE_DESC_TCHAR);
						nStatus = err;
					}
					else if (first_time && err == NETCFG_E_MAX_FILTER_LIMIT) {
						_tprintf(_T("Too many filters installed!\n"));
						if (IncrementRegistryDword(_T("SYSTEM\\CurrentControlSet\\Control\\Network"), _T("MaxNumFilters"), 14))
						{
							try_again = TRUE;
						}
						else {
							_tprintf(_T("Failed to increment MaxNumFilters: %x\n"), GetLastError());
						}
					}
					else {
						_tprintf(_T("Unknown error! %x\n"), err);
						_tprintf(_T("%s has failed to be installed.\n"),
								bWiFiService ? NPF_SERVICE_DESC_TCHAR_WIFI : NPF_SERVICE_DESC_TCHAR);
						nStatus = err ? err : -1;
					}
					first_time = FALSE;
				} while (try_again);
			}
			else if (theArg[3] == _T('\0')) {
				switch (theArg[2]) {
					case _T('l'):
						if (InstallLoopbackAdapter())
						{
							_tprintf(_T("Npcap Loopback adapter has been successfully installed!\n"));
						}
						else
						{
							const DWORD err = GetLastError();
							_tprintf(_T("Npcap Loopback adapter has failed to be installed.\n"));
							nStatus = err ? err : 1;
						}
						break;
					case _T('w'):
						if (InstallWFPCallout())
						{
							_tprintf(_T("Npcap WFP callout driver has been successfully installed!\n"));
						}
						else
						{
							const DWORD err = GetLastError();
							_tprintf(_T("Npcap WFP callout driver has failed to be installed.\n"));
							nStatus = err ? err : 1;
						}
						break;
					default:
						_tprintf(STR_INVALID_PARAMETER);
						nStatus = -1;
						break;
				}
			}
			else {
				_tprintf(STR_INVALID_PARAMETER);
				nStatus = -1;
			}
			break;
		case _T('u'):
			if (theArg[2] == _T('\0')) {
				bSuccess = UninstallDriver();
				if (bSuccess)
				{
					_tprintf(_T("%s has been successfully uninstalled!\n"),
							bWiFiService ? NPF_SERVICE_DESC_TCHAR_WIFI : NPF_SERVICE_DESC_TCHAR);
				}
				else
				{
					const DWORD err = GetLastError();
					_tprintf(_T("%s failed to be uninstalled.\n"),
							bWiFiService ? NPF_SERVICE_DESC_TCHAR_WIFI : NPF_SERVICE_DESC_TCHAR);
					nStatus = err ? err : -1;
				}
			}
			else if (theArg[3] == _T('\0')) {
				switch (theArg[2]) {
					case _T('l'):
						if (UninstallLoopbackAdapter())
						{
							_tprintf(_T("Npcap Loopback adapter has been successfully uninstalled!\n"));
						}
						else
						{
							const DWORD err = GetLastError();
							_tprintf(_T("Npcap Loopback adapter has failed to be uninstalled.\n"));
							nStatus = err ? err : 1;
						}
						break;
					case _T('w'):
						if (UninstallWFPCallout())
						{
							_tprintf(_T("Npcap WFP callout driver has been successfully uninstalled!\n"));
						}
						else
						{
							const DWORD err = GetLastError();
							_tprintf(_T("Npcap WFP callout driver has failed to be uninstalled.\n"));
							nStatus = err ? err : 1;
						}
						break;
					default:
						_tprintf(STR_INVALID_PARAMETER);
						nStatus = -1;
						break;
				}
			}
			else {
				_tprintf(STR_INVALID_PARAMETER);
				nStatus = -1;
			}
			break;
		case _T('r'):
			if (theArg[2] == _T('\0')) {
				if (RenableBindings())
				{
					_tprintf(_T("The bindings of %s have been successfully restarted!\n"),
							bWiFiService ? NPF_SERVICE_DESC_TCHAR_WIFI : NPF_SERVICE_DESC_TCHAR);
				}
				else
				{
					const DWORD err = GetLastError();
					_tprintf(_T("The bindings of %s have failed to be restarted.\n"),
							bWiFiService ? NPF_SERVICE_DESC_TCHAR_WIFI : NPF_SERVICE_DESC_TCHAR);
					nStatus = err ? err : 1;
				}
			}
			else {
				_tprintf(STR_INVALID_PARAMETER);
				nStatus = -1;
			}
			break;
		case _T('c'):
			if (theArg[2] == _T('\0'))
			{
				if (ClearDriverStore())
				{
					_tprintf(_T("Npcap driver cache in Driver Store has been successfully cleaned up!\n"));
				}
				else
				{
					const DWORD err = GetLastError();
					_tprintf(_T("Npcap driver cache in Driver Store has failed to be cleaned up.\n"));
					nStatus = err ? err : 1;
				}
			}
			else if (0 == _tcscmp(theArg, _T("-check_dll"))) {
				tstring strInUseProcesses = getInUseProcesses();
				if (strInUseProcesses == _T(""))
				{
					_tprintf(_T("<NULL>\n"));
				}
				else
				{
					_tprintf(_T("%s\n"), strInUseProcesses.c_str());
					nStatus = -1;
				}
			}
			else {
				_tprintf(STR_INVALID_PARAMETER);
				nStatus = -1;
			}
			break;
		case _T('k'):
			if (0 == _tcscmp(theArg, _T("-kill_proc")))
			{
				if (killInUseProcesses())
				{
					_tprintf(_T("All the processes that are still using Npcap DLLs have been successfully terminated!\n"));
				}
				else
				{
					_tprintf(_T("Some of the processes that are still using Npcap DLLs have failed to be terminated.\n"));
					nStatus = -1;
				}
			}
			else if (0 == _tcscmp(theArg, _T("-kill_proc_soft")))
			{
				if (killInUseProcesses_Soft())
				{
					_tprintf(_T("All the processes that are still using Npcap DLLs have been successfully terminated gracefully!\n"));
				}
				else
				{
					_tprintf(_T("Some of the processes that are still using Npcap DLLs have failed to be terminated gracefully.\n"));
					nStatus = -1;
				}
			}
			else if (0 == _tcscmp(theArg, _T("-kill_proc_polite")))
			{
				if (killInUseProcesses_Polite())
				{
					_tprintf(_T("All the processes that are still using Npcap DLLs have been successfully terminated politely!\n"));
				}
				else
				{
					_tprintf(_T("Some of the processes that are still using Npcap DLLs have failed to be terminated politely.\n"));
					nStatus = -1;
				}
			}
			else {
				_tprintf(STR_INVALID_PARAMETER);
				nStatus = -1;
			}
			break;
		case _T('h'):
			if (theArg[2] == _T('\0'))
			{
				_tprintf(STR_COMMAND_USAGE);
			}
			// else fall through to default invalid parameter
		default:
			_tprintf(STR_INVALID_PARAMETER);
			nStatus = -1;
			break;
	}

	return trace_exit(nStatus);
}

```

`packetWin7/NPFInstall/NPFInstall/NPFInstall.exe.manifest.in`:

```in
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!-- Windows 7 -->
      <supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}"/>
      <!-- Windows 8 -->
      <supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}"/>
      <!-- Windows 8.1 -->
      <supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}"/>
      <!-- Windows 10 -->
      <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
    </application>
  </compatibility>
</assembly>

```

`packetWin7/NPFInstall/NPFInstall/NPFInstall.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="OEM Debug|ARM64">
      <Configuration>OEM Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="OEM Debug|Win32">
      <Configuration>OEM Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="OEM Debug|x64">
      <Configuration>OEM Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="OEM Release|ARM64">
      <Configuration>OEM Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="OEM Release|Win32">
      <Configuration>OEM Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="OEM Release|x64">
      <Configuration>OEM Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{5D8A2717-4F35-4402-B868-45612D27291B}</ProjectGuid>
    <RootNamespace>NPFInstall</RootNamespace>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v143</PlatformToolset>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>10.0.40219.1</_ProjectFileVersion>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='OEM Debug|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(Configuration)\</IntDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='OEM Debug|Win32'">$(Configuration)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='OEM Debug|Win32'">true</LinkIncremental>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='OEM Debug|x64'">$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='OEM Debug|ARM64'">$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(Platform)\$(Configuration)\</IntDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">$(Platform)\$(Configuration)\</IntDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='OEM Debug|x64'">$(Platform)\$(Configuration)\</IntDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='OEM Debug|ARM64'">$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">true</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='OEM Debug|x64'">true</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='OEM Debug|ARM64'">true</LinkIncremental>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='OEM Release|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(Configuration)\</IntDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='OEM Release|Win32'">$(Configuration)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='OEM Release|Win32'">false</LinkIncremental>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='OEM Release|x64'">$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='OEM Release|ARM64'">$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(Platform)\$(Configuration)\</IntDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">$(Platform)\$(Configuration)\</IntDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='OEM Release|x64'">$(Platform)\$(Configuration)\</IntDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='OEM Release|ARM64'">$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">false</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='OEM Release|x64'">false</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='OEM Release|ARM64'">false</LinkIncremental>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='OEM Debug|Win32'">NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='OEM Debug|Win32'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='OEM Debug|Win32'" />
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='OEM Debug|x64'">NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='OEM Debug|ARM64'">NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" />
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='OEM Debug|x64'" />
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='OEM Debug|ARM64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='OEM Debug|x64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='OEM Debug|ARM64'" />
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='OEM Release|Win32'">NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='OEM Release|Win32'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='OEM Release|Win32'" />
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|x64'">NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='OEM Release|x64'">NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='OEM Release|ARM64'">NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" />
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='OEM Release|x64'" />
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='OEM Release|ARM64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='OEM Release|x64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='OEM Release|ARM64'" />
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <AdditionalIncludeDirectories>..\..\Dll;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>PSAPI_VERSION=1;_CONSOLE;_DEBUG_TO_FILE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>setupapi.lib;Rpcrt4.lib;version.lib;Psapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <TargetMachine>MachineX86</TargetMachine>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>NPFInstall.exe.manifest.in;%(AdditionalManifestFiles)</AdditionalManifestFiles>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug|Win32'">
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <AdditionalIncludeDirectories>..\..\Dll;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NPCAP_OEM;PSAPI_VERSION=1;_CONSOLE;_DEBUG_TO_FILE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>setupapi.lib;Rpcrt4.lib;version.lib;Psapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <TargetMachine>MachineX86</TargetMachine>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>NPFInstall.exe.manifest.in;%(AdditionalManifestFiles)</AdditionalManifestFiles>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <AdditionalIncludeDirectories>..\..\Dll;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>PSAPI_VERSION=1;_CONSOLE;_DEBUG_TO_FILE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>setupapi.lib;Rpcrt4.lib;version.lib;Psapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <TargetMachine>MachineX64</TargetMachine>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>NPFInstall.exe.manifest.in;%(AdditionalManifestFiles)</AdditionalManifestFiles>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <Midl />
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <AdditionalIncludeDirectories>..\..\Dll;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>PSAPI_VERSION=1;_CONSOLE;_DEBUG_TO_FILE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>setupapi.lib;Rpcrt4.lib;version.lib;Psapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>NPFInstall.exe.manifest.in;%(AdditionalManifestFiles)</AdditionalManifestFiles>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <AdditionalIncludeDirectories>..\..\Dll;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NPCAP_OEM;PSAPI_VERSION=1;_CONSOLE;_DEBUG_TO_FILE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>setupapi.lib;Rpcrt4.lib;version.lib;Psapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <TargetMachine>MachineX64</TargetMachine>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>NPFInstall.exe.manifest.in;%(AdditionalManifestFiles)</AdditionalManifestFiles>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug|ARM64'">
    <Midl />
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <AdditionalIncludeDirectories>..\..\Dll;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NPCAP_OEM;PSAPI_VERSION=1;_CONSOLE;_DEBUG_TO_FILE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>setupapi.lib;Rpcrt4.lib;version.lib;Psapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>NPFInstall.exe.manifest.in;%(AdditionalManifestFiles)</AdditionalManifestFiles>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <AdditionalIncludeDirectories>..\..\Dll;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>PSAPI_VERSION=1;NDEBUG;_CONSOLE;_DEBUG_TO_FILE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>setupapi.lib;Rpcrt4.lib;version.lib;Psapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <TargetMachine>MachineX86</TargetMachine>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>NPFInstall.exe.manifest.in;%(AdditionalManifestFiles)</AdditionalManifestFiles>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release|Win32'">
    <ClCompile>
      <AdditionalIncludeDirectories>..\..\Dll;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>PSAPI_VERSION=1;NPCAP_OEM;NDEBUG;_CONSOLE;_DEBUG_TO_FILE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>setupapi.lib;Rpcrt4.lib;version.lib;Psapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <TargetMachine>MachineX86</TargetMachine>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>NPFInstall.exe.manifest.in;%(AdditionalManifestFiles)</AdditionalManifestFiles>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <AdditionalIncludeDirectories>..\..\Dll;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>PSAPI_VERSION=1;NDEBUG;_CONSOLE;_DEBUG_TO_FILE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>setupapi.lib;Rpcrt4.lib;version.lib;Psapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <TargetMachine>MachineX64</TargetMachine>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>NPFInstall.exe.manifest.in;%(AdditionalManifestFiles)</AdditionalManifestFiles>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <Midl />
    <ClCompile>
      <AdditionalIncludeDirectories>..\..\Dll;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>PSAPI_VERSION=1;NDEBUG;_CONSOLE;_DEBUG_TO_FILE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>setupapi.lib;Rpcrt4.lib;version.lib;Psapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>NPFInstall.exe.manifest.in;%(AdditionalManifestFiles)</AdditionalManifestFiles>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <AdditionalIncludeDirectories>..\..\Dll;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>PSAPI_VERSION=1;NPCAP_OEM;NDEBUG;_CONSOLE;_DEBUG_TO_FILE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>setupapi.lib;Rpcrt4.lib;version.lib;Psapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <TargetMachine>MachineX64</TargetMachine>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>NPFInstall.exe.manifest.in;%(AdditionalManifestFiles)</AdditionalManifestFiles>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release|ARM64'">
    <Midl />
    <ClCompile>
      <AdditionalIncludeDirectories>..\..\Dll;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>PSAPI_VERSION=1;NPCAP_OEM;NDEBUG;_CONSOLE;_DEBUG_TO_FILE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>setupapi.lib;Rpcrt4.lib;version.lib;Psapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>NPFInstall.exe.manifest.in;%(AdditionalManifestFiles)</AdditionalManifestFiles>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="CalloutInstall.cpp" />
    <ClCompile Include="DriverStoreClear.cpp" />
    <ClCompile Include="LoopbackInstall.cpp" />
    <ClCompile Include="LoopbackRecord.cpp" />
    <ClCompile Include="LoopbackRename.cpp" />
    <ClCompile Include="LoopbackRename2.cpp" />
    <ClCompile Include="netcfgapi.cpp" />
    <ClCompile Include="NPFInstall.cpp" />
    <ClCompile Include="ProtInstall.cpp" />
    <ClCompile Include="ProcessUtil.cpp" />
    <ClCompile Include="RegUtil.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="CalloutInstall.h" />
    <ClInclude Include="DriverStoreClear.h" />
    <ClInclude Include="LoopbackInstall.h" />
    <ClInclude Include="LoopbackRecord.h" />
    <ClInclude Include="LoopbackRename.h" />
    <ClInclude Include="LoopbackRename2.h" />
    <ClInclude Include="msg.h" />
    <ClInclude Include="netcfgapi.h" />
    <ClInclude Include="ProtInstall.h" />
    <ClInclude Include="ProcessUtil.h" />
    <ClInclude Include="rc_ids.h" />
    <ClInclude Include="RegUtil.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="version.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`packetWin7/NPFInstall/NPFInstall/NPFInstall.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="CalloutInstall.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="LoopbackInstall.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="LoopbackRecord.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="LoopbackRename.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="LoopbackRename2.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="netcfgapi.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="NPFInstall.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ProtInstall.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="DriverStoreClear.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="RegUtil.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ProcessUtil.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="CalloutInstall.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="LoopbackInstall.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="LoopbackRecord.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="LoopbackRename.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="LoopbackRename2.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="msg.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="netcfgapi.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ProtInstall.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="rc_ids.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="DriverStoreClear.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="RegUtil.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ProcessUtil.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="version.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>

```

`packetWin7/NPFInstall/NPFInstall/ProcessUtil.cpp`:

```cpp
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
/*++

Module Name:

ProcessUtil.cpp

Abstract:

Get processes which are using Npcap DLLs.

--*/

#include <windows.h>
#include <psapi.h>
#include <TlHelp32.h>
#include <tchar.h>

#include <algorithm>
#include <iostream>
#include <string>
#include <set>
using namespace std;

#include "..\..\Common\WpcapNames.h"
#include "..\npf\npf\ioctls.h"

#include "ProcessUtil.h"
#include "LoopbackRename2.h"
#include "debug.h"

BOOL enableDebugPrivilege(BOOL bEnable)
{
	HANDLE hToken = nullptr;
	LUID luid;

	if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hToken)) return FALSE;
	if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &luid)) return FALSE;

	TOKEN_PRIVILEGES tokenPriv;
	tokenPriv.PrivilegeCount = 1;
	tokenPriv.Privileges[0].Luid = luid;
	tokenPriv.Privileges[0].Attributes = bEnable ? SE_PRIVILEGE_ENABLED : 0;

	if (!AdjustTokenPrivileges(hToken, FALSE, &tokenPriv, sizeof(TOKEN_PRIVILEGES), NULL, NULL)) return FALSE;

	return TRUE;
}

tstring getFileProductName(tstring strFilePath)
{
	DWORD dwLen, dwUseless;
	LPTSTR lpVI;
	HANDLE hHeap = NULL;
	tstring strProductName = _T("");

	TRACE_ENTER();

	dwLen = GetFileVersionInfoSize((LPTSTR) strFilePath.c_str(), &dwUseless);
	if (dwLen == 0)
	{
		TRACE_PRINT1("GetFileVersionInfoSize: error, errCode = 0x%08x.", GetLastError());
		TRACE_EXIT();
		return _T("");
	}

	hHeap = GetProcessHeap();
	if (!hHeap)
	{
		TRACE_PRINT1("GetProcessHeap: error, errCode = 0x%08x.", GetLastError());
		TRACE_EXIT();
		return _T("");
	}

	lpVI = (LPTSTR)HeapAlloc(hHeap, 0, dwLen);
	if (lpVI)
	{
		BOOL bRet = FALSE;
		WORD* langInfo;
		UINT cbLang;
		TCHAR tszVerStrName[128];
		LPVOID lpt;
		UINT cbBufSize;

		GetFileVersionInfo((LPTSTR) strFilePath.c_str(), NULL, dwLen, lpVI);

		// Get the Product Name.
		// First, to get string information, we need to get language information.
		if (VerQueryValue(lpVI, _T("\\VarFileInfo\\Translation"), (LPVOID*)&langInfo, &cbLang))
		{
			// Prepare the label -- default lang is bytes 0 & 1 of langInfo
			_stprintf_s(tszVerStrName, 128, _T("\\StringFileInfo\\%04x%04x\\%s"), langInfo[0], langInfo[1], _T("ProductName"));
			//Get the string from the resource data
			if (VerQueryValue(lpVI, tszVerStrName, &lpt, &cbBufSize))
			{
				strProductName.assign((LPTSTR)lpt);
			}
			else
			{
				TRACE_PRINT("VerQueryValue: error.");
			}
		}
		else
		{
			TRACE_PRINT("VerQueryValue: error.");
		}
		//Cleanup
		HeapFree(hHeap, 0, lpVI);

		TRACE_EXIT();
		return strProductName;
	}
	else
	{
		TRACE_PRINT1("HeapAlloc: error, errCode = 0x%08x.", GetLastError());
		TRACE_EXIT();
		return _T("");
	}
}

BOOL checkModulePathName(tstring strModulePathName)
{
	size_t iStart = strModulePathName.find_last_of(_T('\\'));
	if (iStart == tstring::npos)
	{
		TRACE_PRINT1("checkModulePathName::find_last_of: error, strModulePathName = %s.", strModulePathName.c_str());
		return FALSE;
	}
	else
	{
		iStart++;

		if (0 == strModulePathName.compare(iStart, 5, _T("wpcap"))) {
			iStart += 5;
		}
		else if (0 == strModulePathName.compare(iStart, 6, _T("packet"))) {
			iStart += 6;
		}
		else {
			return FALSE;
		}

#ifdef _M_ARM64
		// ARM64X pure forwarder DLL works with these two arch-specific DLLs
		if (0 == strModulePathName.compare(iStart, 4, _T("_x64"))) {
			iStart += 4;
		}
		else if (0 == strModulePathName.compare(iStart, 5, _T("_arm64"))) {
			iStart += 5;
		}
		// The forwarder itself is wpcap.dll or packet.dll, so no else statement here.
#endif

		// Uninstaller renames X.dll to X.dll.del to avoid race condition
		if (0 == strModulePathName.compare(iStart, tstring::npos, _T(".dll"))
			|| 0 == strModulePathName.compare(iStart, tstring::npos, _T(".dll.del"))) {
			return TRUE;
		}
	}
	return FALSE;
}

BOOL enumDLLs(tstring strProcessName, DWORD dwProcessID)
{
	BOOL bResult = FALSE;
	HMODULE hArrModules[1024];
	HANDLE hProcess;
	DWORD cbNeeded;

	// Print the process identifier.
	// _tprintf(_T("\nProcess ID: %u\n"), dwProcessID);

	// Get a list of all the modules in this process.

	hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, dwProcessID);
	if (!hProcess)
	{
		TRACE_PRINT3("enumDLLs::OpenProcess: error, errCode = 0x%08x, strProcessName = %s, dwProcessID = %d.", GetLastError(), strProcessName.c_str(), dwProcessID);
		// _tprintf(_T("enumDLLs::OpenProcess: error, errCode = 0x%08x, strProcessName = %s, dwProcessID = %d.\n"), GetLastError(), strProcessName.c_str(), dwProcessID);
		return FALSE;
	}

	if (EnumProcessModulesEx(hProcess, hArrModules, sizeof(hArrModules), &cbNeeded, LIST_MODULES_ALL))
	{
		for (DWORD i = 0; !bResult && i < cbNeeded / sizeof(HMODULE); i ++)
		{
			TCHAR szModName[MAX_PATH];

			// Get the full path to the module's file.
			// If we want to actually open the file to check something (like getFileProductName below),
			// we'll have to switch GetModuleFileNameEx for GetMappedFileName so that we get the correct
			// SysWOW64 path. For now, we'll just assume everything with a wpcap.dll or Packet.dll
			// is gonna need to be stopped.
			if (GetModuleFileNameEx(hProcess, hArrModules[i], szModName, MAX_PATH))
			{
				tstring strModulePathName = szModName;
				transform(strModulePathName.begin(), strModulePathName.end(), strModulePathName.begin(), ::tolower);

// 				transform(strProcessName.begin(), strProcessName.end(), strProcessName.begin(), ::tolower);
// 				if (strProcessName != _T("nmap.exe"))
// 					continue;

				if (checkModulePathName(strModulePathName))
					//&& (getFileProductName(strModulePathName) == _T(NPF_DRIVER_NAME_NORMAL)
					//|| getFileProductName(strModulePathName) == _T("WinPcap")
					//))
				{
					TRACE_PRINT2("enumDLLs: succeed, strProcessName = %s, strModulePathName = %s.", strProcessName.c_str(), strModulePathName.c_str());
					// _tprintf(_T("enumDLLs: succeed, strProcessName = %s, strModulePathName = %s.\n"), strProcessName.c_str(), strModulePathName.c_str());
					bResult = TRUE;
				}
				else
				{
					// TRACE_PRINT2("enumDLLs: negative, strProcessName = %s, strModulePathName = %s.", strProcessName.c_str(), strModulePathName.c_str());
					// _tprintf(_T("enumDLLs: negative, strProcessName = %s, strModulePathName = %s.\n"), strProcessName.c_str(), strModulePathName.c_str());
				}
			}
		}
	}
	else
	{
		TRACE_PRINT1("EnumProcessModulesEx: error, errCode = 0x%08x.", GetLastError());
		return FALSE;
	}

	CloseHandle(hProcess);

	return bResult;
}

set<ULONG> getNpcapPIDs()
{
	set<ULONG> empty;
	DWORD dwLen = 1024;
	DWORD BytesReturned = 0;
	DWORD lasterr;
	HANDLE hHeap = GetProcessHeap();
	if (!hHeap)
	{
		TRACE_PRINT1("GetProcessHeap: error, errCode = 0x%08x.", GetLastError());
		return empty;
	}
	TRACE_ENTER();

	// Npcap 0.9995 and later will support this with just '\\.\Global\NPCAP' name,
	// but that crashes Npcap 0.9985 and earlier due to #1924.
	// Loopback adapter ought to be safe and present since 0.9983
	HANDLE hFile = CreateFile(L"\\\\.\\Global\\NPCAP\\Loopback", GENERIC_WRITE|GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, 0);
	if (hFile != NULL && hFile != INVALID_HANDLE_VALUE)
	{
		TRACE_PRINT("Npcap handle opened");
		PULONG pids = (PULONG)HeapAlloc(hHeap, 0, dwLen);
		if (!pids)
		{
			TRACE_PRINT1("HeapAlloc error 0x%08x", GetLastError());
			CloseHandle(hFile);
			TRACE_EXIT();
			return empty;
		}
		if (!DeviceIoControl(hFile, BIOCGETPIDS, NULL, 0, pids, dwLen, &BytesReturned, NULL))
		{
			lasterr = GetLastError();
			TRACE_PRINT2("BIOCGETPIDS failed. err=%08x, bytes=%08x", lasterr, BytesReturned);
			if (BytesReturned >= sizeof(ULONG) && lasterr == ERROR_MORE_DATA)
			{
				dwLen = (pids[0] + 1) * sizeof(ULONG);
				HeapFree(hHeap, 0, pids);
				pids = (PULONG)HeapAlloc(hHeap, 0, dwLen);
				if (!pids)
				{
					TRACE_PRINT1("HeapAlloc error 0x%08x", GetLastError());
					CloseHandle(hFile);
					TRACE_EXIT();
					return empty;
				}
				if (!DeviceIoControl(hFile, BIOCGETPIDS, NULL, 0, pids, dwLen, &BytesReturned, NULL))
				{
					lasterr = GetLastError();
					TRACE_PRINT2("BIOCGETPIDS failed. err=%08x, bytes=%08x", lasterr, BytesReturned);
					HeapFree(hHeap, 0, pids);
					CloseHandle(hFile);
					TRACE_EXIT();
					return empty;
				}
			}
			else
			{
				HeapFree(hHeap, 0, pids);
				CloseHandle(hFile);
				TRACE_EXIT();
				return empty;
			}
		}

		TRACE_PRINT2("BIOCGETPIDS returned %lu bytes, %lu pids", BytesReturned, BytesReturned < sizeof(ULONG) ? 0 : pids[0]);
		if (BytesReturned < sizeof(ULONG) || BytesReturned < sizeof(ULONG) * (pids[0] + 1))
		{
			HeapFree(hHeap, 0, pids);
			CloseHandle(hFile);
			TRACE_EXIT();
			return empty;
		}
		set<ULONG> Ret(pids+1, pids+pids[0]);
		HeapFree(hHeap, 0, pids);
		CloseHandle(hFile);
		TRACE_EXIT();
		return Ret;
	}
	TRACE_EXIT();
	return empty;
}

vector<tstring> enumProcesses()
{
	TRACE_ENTER();

	vector<tstring> strArrProcessNames;
	set<ULONG> pids = getNpcapPIDs();
	DWORD my_pid = GetCurrentProcessId();

	enableDebugPrivilege(TRUE);

	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	if (hSnapshot != INVALID_HANDLE_VALUE)
	{
		PROCESSENTRY32 PEInfo;
		PEInfo.dwSize = sizeof(PEInfo);
		BOOL bHasNextProcess = Process32First(hSnapshot, &PEInfo);
		bool found = false;
		while (bHasNextProcess)
		{
			bHasNextProcess = Process32Next(hSnapshot, &PEInfo);
			if (PEInfo.th32ProcessID == my_pid)
			{
				continue;
			}
			tstring strProcessName = PEInfo.szExeFile;
			if (pids.find(PEInfo.th32ProcessID) != pids.end()
					|| enumDLLs(strProcessName, PEInfo.th32ProcessID))
			{
				strArrProcessNames.push_back(strProcessName);
			}
		}

		CloseHandle(hSnapshot);
	}
	else
	{
		TRACE_PRINT1("enumProcesses::CreateToolhelp32Snapshot: error, errCode = 0x%08x.", GetLastError());
		TRACE_EXIT();
		return strArrProcessNames;
	}

	TRACE_EXIT();
	return strArrProcessNames;
}

vector<DWORD> enumProcesses_PID()
{
	TRACE_ENTER();

	vector<DWORD> strArrProcessIDs;
	set<ULONG> pids = getNpcapPIDs();
	DWORD my_pid = GetCurrentProcessId();

	enableDebugPrivilege(TRUE);

	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	if (hSnapshot != INVALID_HANDLE_VALUE)
	{
		PROCESSENTRY32 PEInfo;
		PEInfo.dwSize = sizeof(PEInfo);
		BOOL bHasNextProcess = Process32First(hSnapshot, &PEInfo);
		bool found = false;
		while (bHasNextProcess)
		{
			bHasNextProcess = Process32Next(hSnapshot, &PEInfo);
			if (PEInfo.th32ProcessID == my_pid)
			{
				continue;
			}
			tstring strProcessName = PEInfo.szExeFile;
			if (pids.find(PEInfo.th32ProcessID) != pids.end()
					|| enumDLLs(strProcessName, PEInfo.th32ProcessID))
			{
				strArrProcessIDs.push_back(PEInfo.th32ProcessID);
			}
		}

		CloseHandle(hSnapshot);
	}
	else
	{
		TRACE_PRINT1("enumProcesses_PID::CreateToolhelp32Snapshot: error, errCode = 0x%08x.", GetLastError());
		TRACE_EXIT();
		return strArrProcessIDs;
	}

	TRACE_EXIT();
	return strArrProcessIDs;
}

tstring getInUseProcesses()
{
	TRACE_ENTER();

	tstring strResult;
	vector<tstring> strArrProcessNames;
	
	strArrProcessNames = enumProcesses();

	for (size_t i = 0; i < strArrProcessNames.size(); i++)
	{
		strResult += strArrProcessNames[i];
		if (i != strArrProcessNames.size() - 1)
		{
			strResult += _T(", ");
		}
	}

	TRACE_EXIT();
	return strResult;
}

BOOL killProcess(DWORD dwProcessID)
{
	TRACE_ENTER();

	// When the all operation fail this function terminate the "winlogon" Process for force exit the system.
	HANDLE hProcess = OpenProcess(PROCESS_TERMINATE, FALSE, dwProcessID);
	if (!hProcess)
	{
		DWORD dwError = GetLastError();
		if (dwError == ERROR_INVALID_PARAMETER)
		{
			TRACE_PRINT1("killProcess: the process terminates itself, dwProcessID = %d.", dwProcessID);
			return TRUE;
		}
		else
		{
			TRACE_PRINT2("killProcess::OpenProcess: error, errCode = 0x%08x, dwProcessID = %d.", dwError, dwProcessID);
			return FALSE;
		}
	}
	
	BOOL bRes = TerminateProcess(hProcess, 0);
	if (!bRes)
	{
		TRACE_PRINT2("killProcess::TerminateProcess: error, errCode = 0x%08x, dwProcessID = %d.", GetLastError(), dwProcessID);
		TRACE_EXIT();
		return FALSE;
	}
	else
	{
		WaitForSingleObject(hProcess, 5000); // Make sure the process has terminated.
		TRACE_PRINT1("killProcess::TerminateProcess: succeeds, dwProcessID = %d.", dwProcessID);
		TRACE_EXIT();
		return TRUE;
	}
}

BOOL killInUseProcesses()
{
	TRACE_ENTER();

	BOOL bResult = TRUE;
	vector<DWORD> strArrProcessIDs;

	strArrProcessIDs = enumProcesses_PID();

	for (size_t i = 0; i < strArrProcessIDs.size(); i++)
	{
		if (!killProcess(strArrProcessIDs[i]))
		{
			bResult = FALSE;
		}
	}

	TRACE_EXIT();
	return bResult;
}

BOOL killProcess_Soft(DWORD dwProcessID)
{
	TRACE_ENTER();

	TCHAR buf[256];
	int rc = _sntprintf_s(buf, _countof(buf), _T("taskkill /pid %ul"), dwProcessID);
	if (rc <= 0) {
		TRACE_PRINT1("Can't convert process ID %d to string.", dwProcessID);
		TRACE_EXIT();
		return FALSE;
	}

	tstring strResult = executeCommand(buf);

	if (strResult.compare(0, _tcslen(_T("SUCCESS")), _T("SUCCESS")) == 0)
	{
		TRACE_PRINT1("killProcess_Soft: gracefully kill process, bResult = 1, dwProcessID = %d.", dwProcessID);
		TRACE_EXIT();
		return TRUE;
	}
	else
	{
		TRACE_PRINT1("killProcess_Soft: gracefully kill process, bResult = 0, dwProcessID = %d.", dwProcessID);
		TRACE_EXIT();
		return FALSE;
	}
}

BOOL killInUseProcesses_Soft()
{
	TRACE_ENTER();

	BOOL bResult = TRUE;
	vector<DWORD> strArrProcessIDs;

	strArrProcessIDs = enumProcesses_PID();

	for (size_t i = 0; i < strArrProcessIDs.size(); i++)
	{
		if (!killProcess_Soft(strArrProcessIDs[i]))
		{
			bResult = FALSE;
		}
	}

	TRACE_EXIT();
	return bResult;
}

DWORD dwTimeout = 15000;

BOOL killProcess_Wait(DWORD dwProcessID)
{
	TRACE_ENTER();

	// When the all operation fail this function terminate the "winlogon" Process for force exit the system.
	HANDLE hProcess = OpenProcess(SYNCHRONIZE | PROCESS_TERMINATE, FALSE, dwProcessID);
	if (!hProcess)
	{
		DWORD dwError = GetLastError();
		if (dwError == ERROR_INVALID_PARAMETER)
		{
			TRACE_PRINT1("killProcess_Wait: the process terminates itself, dwProcessID = %d.", dwProcessID);
			return TRUE;
		}
		else
		{
			TRACE_PRINT2("killProcess_Wait::OpenProcess: error, errCode = 0x%08x, dwProcessID = %d.", dwError, dwProcessID);
			return FALSE;
		}
	}

	ULONGLONG ullTickBefore = GetTickCount64();
	if (WaitForSingleObject(hProcess, dwTimeout) != WAIT_OBJECT_0)
	{
		dwTimeout = 0;
		BOOL bRes = TerminateProcess(hProcess, 0);
		if (!bRes)
		{
			TRACE_PRINT2("killProcess_Wait::TerminateProcess: error, errCode = 0x%08x, dwProcessID = %d.", GetLastError(), dwProcessID);
			TRACE_EXIT();
			return FALSE;
		}
		else
		{
			WaitForSingleObject(hProcess, 5000); // Make sure the process has terminated.
			TRACE_PRINT1("killProcess_Wait::TerminateProcess: succeeds, dwProcessID = %d.", dwProcessID);
			TRACE_EXIT();
			return TRUE;
		}
	}

	ULONGLONG ullTickAfter = GetTickCount64();
	if (dwTimeout <= ullTickAfter - ullTickBefore)
	{
		dwTimeout = 0;
	}
	else
	{
		dwTimeout -= (ullTickAfter - ullTickBefore);
	}

	TRACE_PRINT2("killProcess_Wait: the process terminates itself, dwProcessID = %d, dwTimeout = %d.", dwProcessID, dwTimeout);
	TRACE_EXIT();
	return TRUE;
}

BOOL killInUseProcesses_Polite()
{
	TRACE_ENTER();

	BOOL bResult = TRUE;
	vector<DWORD> strArrProcessIDs;

	strArrProcessIDs = enumProcesses_PID();

	for (size_t i = 0; i < strArrProcessIDs.size(); i++)
	{
		if (!killProcess_Soft(strArrProcessIDs[i]))
		{
			killProcess(strArrProcessIDs[i]);
		}
	}

	for (size_t i = 0; i < strArrProcessIDs.size(); i++)
	{
		if (!killProcess_Wait(strArrProcessIDs[i]))
		{
			bResult = FALSE;
		}
	}

	TRACE_EXIT();
	return bResult;
}

```

`packetWin7/NPFInstall/NPFInstall/ProcessUtil.h`:

```h
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
/*++

Module Name:

ProcessUtil.h

Abstract:

Get processes which are using Npcap DLLs.

--*/

#include <vector>
#include <string>
using namespace std;

typedef std::basic_string<TCHAR> tstring;

tstring getInUseProcesses();

BOOL killInUseProcesses();

BOOL killInUseProcesses_Soft();

BOOL killInUseProcesses_Polite();

```

`packetWin7/NPFInstall/NPFInstall/ProtInstall.cpp`:

```cpp
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
// ProtInstall.cpp : Defines the entry point for the console application.
//

#include "netcfgapi.h"
#include "ProtInstall.h"

#include "debug.h"

// Copyright And Configuration Management ----------------------------------
//
//  			 NDISPROT Software Installer - ProtInstall.cpp
//
//  				Companion Sample Code for the Article
//
//  			  "Installing NDIS Protocols Programatically"
//  				   Published on http://www.ndis.com
//
//   Copyright (c) 2004-2006 Printing Communications Associates, Inc. (PCAUSA)
//  						http://www.pcausa.com
//
// GPL software is an abomination. Far from being free, it is available ONLY
// to members of the "GPL Club". If you don't want to join the club, then GPL
// software is poison.
//
// This software IS free software under the terms of a BSD-style license:
//
// The right to use this code in your own derivative works is granted so long
// as 1.) your own derivative works include significant modifications of your
// own, 2.) you retain the above copyright notices and this paragraph in its
// entirety within sources derived from this code.
//
// This product includes software developed by PCAUSA. The name of PCAUSA
// may not be used to endorse or promote products derived from this software
// without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
// WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
//
// End ---------------------------------------------------------------------

BOOLEAN bVerbose = TRUE;

BOOLEAN bWiFiService = FALSE;

//
// Function:  ErrMsg
//
// Purpose:   Insert text for each network component type.
//
// Arguments:
//    hr  [in]  Error code.
//
// Returns:   None.
//
// Notes:
//
VOID ErrMsg(HRESULT hr, LPCTSTR  lpFmt, ...)
{
#define ERRMSG_BUF_LEN 400
	LPTSTR lpSysMsg;
	TCHAR buf[ERRMSG_BUF_LEN];
	ULONG offset;
	va_list vArgList; 

	if (hr != 0)
	{
		_stprintf_s(buf, ERRMSG_BUF_LEN, _T("Error %#lx: "), hr);
	}
	else
	{
		buf[0] = 0;
	}

	offset = (ULONG) _tcslen(buf);

	va_start(vArgList, lpFmt);

	_vstprintf_s(buf + offset, ERRMSG_BUF_LEN - offset, lpFmt, vArgList);

	va_end(vArgList);

	if (hr != 0)
	{
		const DWORD fm = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, hr, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpSysMsg, 0, NULL);

		if (fm > 0 && lpSysMsg)
		{
			offset = (ULONG) _tcslen(buf);

			_stprintf_s(buf + offset, ERRMSG_BUF_LEN - offset, _T("\n\nPossible cause:\n\n"));

			offset = (ULONG) _tcslen(buf);

			_tcscat_s(buf + offset, ERRMSG_BUF_LEN - offset, lpSysMsg);

			LocalFree((HLOCAL)lpSysMsg);
		}
	}

	//_tprintf( buf );
	TRACE_PRINT1("%s", buf);

	return;
}

DWORD GetServiceInfFilePath(LPTSTR lpFilename, DWORD nSize)
{
	// Get Path to This Module
	DWORD nResult;
	TCHAR szDrive[_MAX_DRIVE];
	TCHAR szDir[_MAX_DIR];

	TRACE_ENTER();

	nResult = GetModuleFileName(NULL, lpFilename, nSize);

	if (nResult == 0)
	{
		return 0;
	}

	_tsplitpath_s(lpFilename, szDrive, _MAX_DRIVE, szDir, _MAX_DIR, NULL, 0, NULL, 0);

	_tmakepath_s(lpFilename, nSize, szDrive, szDir, NDISLWF_SERVICE_INF_FILE, _T(".inf"));
	TRACE_PRINT1("lpFilename = %s", lpFilename);

	TRACE_EXIT();

	return (DWORD)_tcslen(lpFilename);
}

DWORD GetWFPCalloutInfFilePath(LPTSTR lpFilename, DWORD nSize)
{
	// Get Path to This Module
	DWORD nResult;
	TCHAR szDrive[_MAX_DRIVE];
	TCHAR szDir[_MAX_DIR];

	TRACE_ENTER();

	nResult = GetModuleFileName(NULL, lpFilename, nSize);

	if (nResult == 0)
	{
		return 0;
	}

	_tsplitpath_s(lpFilename, szDrive, _MAX_DRIVE, szDir, _MAX_DIR, NULL, 0, NULL, 0);

	_tmakepath_s(lpFilename, nSize, szDrive, szDir, WFP_CALLOUT_INF_FILE, _T(".inf"));
	TRACE_PRINT1("lpFilename = %s", lpFilename);

	TRACE_EXIT();

	return (DWORD)_tcslen(lpFilename);
}

//
// Function:  InstallSpecifiedComponent
//
// Purpose:   Install a network component from an INF file.
//
// Arguments:
//    lpszInfFile [in]  INF file.
//    lpszPnpID   [in]  PnpID of the network component to install.
//    lpszAppName [in]  Application name.
//    pguidClass  [in]  Class GUID of the network component.
//
// Returns:   None.
//
// Notes:
//

HRESULT InstallSpecifiedComponent(LPCTSTR lpszInfFile, LPCTSTR lpszAppName, const GUID* pguidClass)
{
	INetCfg* pnc;
	LPTSTR lpszApp;
	HRESULT hr;

	TRACE_ENTER();

	hr = HrGetINetCfg(TRUE, lpszAppName, &pnc, &lpszApp);

	if (hr == S_OK)
	{
		//
		// Install the network component.
		//
		hr = HrInstallNetComponent(pnc, pguidClass, lpszInfFile);

		if ((hr == S_OK) || (hr == NETCFG_S_REBOOT))
		{
			// hr = pnc->Apply();
		}
		else
		{
			if (hr != HRESULT_FROM_WIN32(ERROR_CANCELLED))
			{
				ErrMsg(hr, _T("Couldn't install the network component."));
			}
		}

		HrReleaseINetCfg(pnc, TRUE);
	}
	else
	{
		if ((hr == NETCFG_E_NO_WRITE_LOCK) && lpszApp)
		{
			ErrMsg(hr, _T("%s currently holds the lock, try later."), lpszApp);

			CoTaskMemFree(lpszApp);
		}
		else
		{
			ErrMsg(hr, _T("Couldn't the get notify object interface."));
		}
	}

	TRACE_EXIT();
	return hr;
}

BOOL InstallDriver()
{
	TCHAR szFileFullPath[_MAX_PATH];
	HRESULT hr = S_OK;

	TRACE_ENTER();

	do
	{
		// Get Path to Service INF File
		// ----------------------------
		// The INF file is assumed to be in the same folder as this application...

		if (!(BOOL) GetServiceInfFilePath(szFileFullPath, MAX_PATH))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			TRACE_PRINT("Unable to get INF file path");
			break;
		}

		hr = InstallSpecifiedComponent(szFileFullPath, APP_NAME, &GUID_DEVCLASS_NETSERVICE);

		if (hr != S_OK)
		{
			ErrMsg(hr, _T("InstallSpecifiedComponent\n"));
			break;
		}

	} while (FALSE);

	TRACE_EXIT();
	SetLastError(hr);
	return SUCCEEDED(hr);
}

BOOL UninstallDriver()
{
	BOOL bSucceed = TRUE;
	INetCfg* pnc;
	LPTSTR lpszApp;
	HRESULT hr;

	TRACE_ENTER();

	hr = HrGetINetCfg(TRUE, APP_NAME, &pnc, &lpszApp);

	if (hr == S_OK)
	{
		TRACE_PRINT1("bWiFiService = %d.", bWiFiService);
		TRACE_PRINT1("HrUninstallNetComponent: executing, szComponentId = %s.", NDISLWF_SERVICE_PNP_DEVICE_ID);
		hr = HrUninstallNetComponent(pnc, NDISLWF_SERVICE_PNP_DEVICE_ID);

		if (hr != S_OK)
		{
			if (hr != HRESULT_FROM_WIN32(ERROR_CANCELLED))
			{
				bSucceed = FALSE;
				ErrMsg(hr, _T("Couldn't uninstall the network component."));
			}
		}

		if (bWiFiService)
		{
			TRACE_PRINT1("HrUninstallNetComponent: executing, szComponentId = %s.", NDISLWF_SERVICE_PNP_DEVICE_ID_WIFI);
			hr = HrUninstallNetComponent(pnc, NDISLWF_SERVICE_PNP_DEVICE_ID_WIFI);

			if (hr != S_OK)
			{
				if (hr != HRESULT_FROM_WIN32(ERROR_CANCELLED))
				{
					bSucceed = FALSE;
					ErrMsg(hr, _T("Couldn't uninstall the network component."));
				}
			}
		}

		HrReleaseINetCfg(pnc, TRUE);
	}
	else
	{
		bSucceed = FALSE;
		if ((hr == NETCFG_E_NO_WRITE_LOCK) && lpszApp)
		{
			ErrMsg(hr, _T("%s currently holds the lock, try later."), lpszApp);

			CoTaskMemFree(lpszApp);
		}
		else
		{
			ErrMsg(hr, _T("Couldn't get the notify object interface."));
		}
	}

	TRACE_EXIT();
	return bSucceed;
}

BOOL RenableBindings()
{
	CComPtr<INetCfg> netcfg;
	CComPtr<INetCfgLock> lock;
	HRESULT hr;

	TRACE_ENTER();

	hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
	if (FAILED(hr))
	{
		TRACE_PRINT1("CoInitializeEx: 0x%08x\n", hr);
		TRACE_EXIT();
		return 1;
	}

	BOOL bSucceed = ConnectToNetCfg(NDISLWF_SERVICE_PNP_DEVICE_ID, APP_NAME);
	if (!bSucceed)
	{
		TRACE_PRINT1("ConnectToNetCfg: error, PNP Device ID = %s.", NDISLWF_SERVICE_PNP_DEVICE_ID);
	}

	if (bWiFiService)
	{
		bSucceed = ConnectToNetCfg(NDISLWF_SERVICE_PNP_DEVICE_ID_WIFI, APP_NAME);
		if (!bSucceed)
		{
			TRACE_PRINT1("ConnectToNetCfg: error, PNP Device ID = %s.", NDISLWF_SERVICE_PNP_DEVICE_ID_WIFI);
		}
	}

	CoUninitialize();

	TRACE_EXIT();
	return bSucceed;
}

```

`packetWin7/NPFInstall/NPFInstall/ProtInstall.h`:

```h
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
#ifndef _PROTINSTALL_H_
#define _PROTINSTALL_H_

// Copyright And Configuration Management ----------------------------------
//
//  			  NDISLWF String Definitions - ProtInstall.h
//
//  				Companion Sample Code for the Article
//
//  			  "Installing NDIS Protocols Programatically"
//  				   Published on http://www.ndis.com
//
//   Copyright (c) 2004-2006 Printing Communications Associates, Inc. (PCAUSA)
//  						http://www.pcausa.com
//
// GPL software is an abomination. Far from being free, it is available ONLY
// to members of the "GPL Club". If you don't want to join the club, then GPL
// software is poison.
//
// This software IS free software under the terms of a BSD-style license:
//
// The right to use this code in your own derivative works is granted so long
// as 1.) your own derivative works include significant modifications of your
// own, 2.) you retain the above copyright notices and this paragraph in its
// entirety within sources derived from this code.
//
// This product includes software developed by PCAUSA. The name of PCAUSA
// may not be used to endorse or promote products derived from this software
// without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
// WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
//
// End ---------------------------------------------------------------------

//
// ATTENTION!!!
// ------------
// If you make changes to the NDISLWF string definitions you must also make
// matching changes in this file.
//

////////////////////////////////////////////////////////////////////////////
//// Device Naming String Definitions
//

#include "..\..\Common\WpcapNames.h"

//
// Driver INF File and PnP ID Names
//
#ifdef UNICODE
#define NDISLWF_SERVICE_PNP_DEVICE_ID		NPF_ORGAN_NAME_WIDECHAR L"_" NPF_DRIVER_NAME_WIDECHAR
#define NDISLWF_SERVICE_PNP_DEVICE_ID_WIFI	NDISLWF_SERVICE_PNP_DEVICE_ID L"_WIFI"

#define NDISLWF_SERVICE_INF_FILE			NPF_DRIVER_NAME_WIDECHAR
#define WFP_CALLOUT_INF_FILE				NDISLWF_SERVICE_INF_FILE L"_wfp"
#else
#define NDISLWF_SERVICE_PNP_DEVICE_ID		NPF_ORGAN_NAME "_" NPF_DRIVER_NAME
#define NDISLWF_SERVICE_PNP_DEVICE_ID_WIFI	NDISLWF_SERVICE_PNP_DEVICE_ID "_WIFI"

#define NDISLWF_SERVICE_INF_FILE			NPF_DRIVER_NAME
#define WFP_CALLOUT_INF_FILE				NDISLWF_SERVICE_INF_FILE "_wfp"
#endif

#define APP_NAME							_T(NPF_DRIVER_NAME)

#ifdef __cplusplus
extern "C"
{
#endif

	BOOL InstallDriver();
	BOOL UninstallDriver();
	BOOL RenableBindings();

#ifdef __cplusplus
}
#endif

VOID ErrMsg(HRESULT hr, LPCTSTR  lpFmt, ...);

/////////////////////////////////////////////////////////////////////////////
//// Registry Key Strings
//

DWORD GetServiceInfFilePath(LPTSTR lpFilename, DWORD nSize);
DWORD GetWFPCalloutInfFilePath(LPTSTR lpFilename, DWORD nSize);

#endif // _PROTINSTALL_H_

```

`packetWin7/NPFInstall/NPFInstall/RegUtil.cpp`:

```cpp
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
/*++

Module Name:

RegUtil.cpp

Abstract:

This is used for operating on registry.

--*/

#include <Netcfgx.h>

#include <iostream>
#include <atlbase.h> // CComPtr
#include <devguid.h> // GUID_DEVCLASS_NET, ...

#include "RegUtil.h"

#include "debug.h"

#define BUF_SIZE 255

BOOL WriteStrToRegistry(LPCTSTR strSubKey, LPCTSTR strValueName, LPCTSTR strDeviceName, DWORD dwSamDesired)
{
	LONG Status;
	HKEY hNpcapKey;

	TRACE_ENTER();
	TRACE_PRINT4("WriteStrToRegistry: executing, strSubKey = %s, strValueName = %s, strDeviceName = %s, dwSamDesired = 0x%08x.",
		strSubKey, strValueName, strDeviceName, dwSamDesired);

	Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, strSubKey, 0, dwSamDesired | KEY_WOW64_32KEY, &hNpcapKey);
	if (Status == ERROR_SUCCESS)
	{
		Status = RegSetValueEx(hNpcapKey, strValueName, 0, REG_SZ, (PBYTE)strDeviceName, (_tcslen(strDeviceName) + 1) * sizeof(TCHAR));
		if (Status != ERROR_SUCCESS)
		{
			TRACE_PRINT1("RegSetValueEx: error, errCode = 0x%08x.", Status);
			RegCloseKey(hNpcapKey);
			TRACE_EXIT();
			return FALSE;
		}
		RegCloseKey(hNpcapKey);
	}
	else
	{
		TRACE_PRINT1("RegOpenKeyEx: error, errCode = 0x%08x.", Status);
		TRACE_EXIT();
		return FALSE;
	}

	TRACE_EXIT();
	return TRUE;
}

BOOL IncrementRegistryDword(LPCTSTR strSubKey, LPCTSTR strValueName, DWORD maxValue)
{
	LONG Status;
	HKEY hNpcapKey;
	DWORD dwCurrent;
	DWORD dwSize;
	dwSize = sizeof(dwCurrent);

	TRACE_ENTER();
	TRACE_PRINT2("IncrementRegistryDword: executing, strSubKey = %s, strValueName = %s",
		strSubKey, strValueName);

	Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, strSubKey, 0, KEY_SET_VALUE | KEY_QUERY_VALUE | KEY_WOW64_32KEY, &hNpcapKey);
	if (Status == ERROR_SUCCESS)
	{
		Status = RegGetValue(hNpcapKey, NULL, strValueName, RRF_RT_REG_DWORD, NULL, &dwCurrent, &dwSize);
		if (Status != ERROR_SUCCESS)
		{
			TRACE_PRINT1("RegGetValue: error, errCode = 0x%08x.", Status);
			RegCloseKey(hNpcapKey);
			TRACE_EXIT();
			return FALSE;
		}
		if (dwCurrent >= maxValue)
		{
			TRACE_PRINT2("Current value %d is greater than max value %d", dwCurrent, maxValue);
			RegCloseKey(hNpcapKey);
			TRACE_EXIT();
			return FALSE;
		}
		dwCurrent += 1;
		Status = RegSetValueEx(hNpcapKey, strValueName, 0, REG_DWORD, (PBYTE)&dwCurrent, sizeof(dwCurrent));
		if (Status != ERROR_SUCCESS)
		{
			TRACE_PRINT1("RegSetValueEx: error, errCode = 0x%08x.", Status);
			RegCloseKey(hNpcapKey);
			TRACE_EXIT();
			return FALSE;
		}
		RegCloseKey(hNpcapKey);
	}
	else
	{
		TRACE_PRINT1("RegOpenKeyEx: error, errCode = 0x%08x.", Status);
		TRACE_EXIT();
		return FALSE;
	}

	TRACE_EXIT();
	return TRUE;
}

BOOL DeleteValueFromRegistry(LPCTSTR strSubKey, LPCTSTR strValueName)
{
	LONG Status;
	HKEY hNpcapKey;

	TRACE_ENTER();
	TRACE_PRINT2("DeleteValueFromRegistry: executing, strSubKey = %s, strValueName = %s.",
		strSubKey, strValueName);

	Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, strSubKey, 0, KEY_SET_VALUE | KEY_WOW64_32KEY, &hNpcapKey);
	if (Status == ERROR_SUCCESS)
	{
		Status = RegDeleteValue(hNpcapKey, strValueName);
		if (Status != ERROR_SUCCESS)
		{
			TRACE_PRINT1("RegDeleteValue: error, errCode = 0x%08x.", Status);
			RegCloseKey(hNpcapKey);
			TRACE_EXIT();
			return FALSE;
		}
		RegCloseKey(hNpcapKey);
	}
	else
	{
		TRACE_PRINT1("RegOpenKeyEx: error, errCode = 0x%08x.", Status);
		TRACE_EXIT();
		return FALSE;
	}

	TRACE_EXIT();
	return TRUE;
}

```

`packetWin7/NPFInstall/NPFInstall/RegUtil.h`:

```h
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
/*++

Module Name:

RegUtil.h

Abstract:

This is used for operating on registry.

--*/

#include "..\..\Common\WpcapNames.h"

#define		NPF_SOFT_REGISTRY_NAME_T			_T(NPF_SOFT_REGISTRY_NAME)
#define		NPF_DRIVER_NAME_SMALL_T				_T(NPF_DRIVER_NAME_SMALL)
#define		NPCAP_REG_KEY_NAME					_T("SOFTWARE\\") NPF_SOFT_REGISTRY_NAME_T
#define		NPCAP_SERVICE_REG_KEY_NAME			_T("SYSTEM\\CurrentControlSet\\Services\\") NPF_DRIVER_NAME_SMALL_T
#define		NPCAP_REG_LOOPBACK_VALUE_NAME		_T("LoopbackAdapter")

BOOL WriteStrToRegistry(LPCTSTR strSubKey, LPCTSTR strValueName, LPCTSTR strDeviceName, DWORD dwSamDesired);
BOOL DeleteValueFromRegistry(LPCTSTR strSubKey, LPCTSTR strValueName);
BOOL IncrementRegistryDword(LPCTSTR strSubKey, LPCTSTR strValueName, DWORD maxValue);

```

`packetWin7/NPFInstall/NPFInstall/msg.h`:

```h
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// General
//
//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: MSG_USAGE
//
// MessageText:
//
// %1 Usage: %1 [-r] [-m:\\<machine>] <command> [<arg>...]
// For more information, type: %1 help
//
#define MSG_USAGE                        0x0000EA60L

//
// MessageId: MSG_FAILURE
//
// MessageText:
//
// %1 failed.
//
#define MSG_FAILURE                      0x0000EA61L

//
// MessageId: MSG_COMMAND_USAGE
//
// MessageText:
//
// %1: Invalid use of %2.
// For more information, type: %1 help %2
//
#define MSG_COMMAND_USAGE                0x0000EA62L

//
// HELP
//
//
// MessageId: MSG_HELP_LONG
//
// MessageText:
//
// Device Console Help:
// %1 [-r] [-m:\\<machine>] <command> [<arg>...]
// -r           Reboots the system only when a restart or reboot is required.
// <machine>    Specifies a remote computer. 
// <command>    Specifies a Devcon command (see command list below).
// <arg>...     One or more arguments that modify a command.
// For help with a specific command, type: %1 help <command>
//
#define MSG_HELP_LONG                    0x0000EAC4L

//
// MessageId: MSG_HELP_SHORT
//
// MessageText:
//
// %1!-20s! Display Devcon help.
//
#define MSG_HELP_SHORT                   0x0000EAC5L

//
// MessageId: MSG_HELP_OTHER
//
// MessageText:
//
// Unknown command.
//
#define MSG_HELP_OTHER                   0x0000EAC6L

//
// CLASSES
//
//
// MessageId: MSG_CLASSES_LONG
//
// MessageText:
//
// Devcon Classes Command
// Lists all device setup classes. Valid on local and remote computers.
// %1 [-m:\\<machine>] %2
// <machine>    Specifies a remote computer.
// Class entries have the format <name>: <descr>
// where <name> is the class name and <descr> is the class description.
//
#define MSG_CLASSES_LONG                 0x0000EB28L

//
// MessageId: MSG_CLASSES_SHORT
//
// MessageText:
//
// %1!-20s! List all device setup classes.
//
#define MSG_CLASSES_SHORT                0x0000EB29L

//
// MessageId: MSG_CLASSES_HEADER
//
// MessageText:
//
// Listing %1!u! setup classes on %2.
//
#define MSG_CLASSES_HEADER               0x0000EB2AL

//
// MessageId: MSG_CLASSES_HEADER_LOCAL
//
// MessageText:
//
// Listing %1!u! setup classes.
//
#define MSG_CLASSES_HEADER_LOCAL         0x0000EB2BL

//
// LISTCLASS
//
//
// MessageId: MSG_LISTCLASS_LONG
//
// MessageText:
//
// Devcon Listclass Command
// Lists all devices in the specified setup classes. Valid on local and remote computers.
// %1 [-m:\\<machine>] %2 <class> [<class>...]
// <machine>    Specifies a remote computer.
// <class>      Specifies a device setup class.
// Device entries have the format <instance>: <descr>
// where <instance> is a unique instance of the device and <descr> is the device description.
//
#define MSG_LISTCLASS_LONG               0x0000EB8CL

//
// MessageId: MSG_LISTCLASS_SHORT
//
// MessageText:
//
// %1!-20s! List all devices in a setup class.
//
#define MSG_LISTCLASS_SHORT              0x0000EB8DL

//
// MessageId: MSG_LISTCLASS_HEADER
//
// MessageText:
//
// Listing %1!u! devices in setup class "%2" (%3) on %4.
//
#define MSG_LISTCLASS_HEADER             0x0000EB8EL

//
// MessageId: MSG_LISTCLASS_HEADER_LOCAL
//
// MessageText:
//
// Listing %1!u! devices in setup class "%2" (%3).
//
#define MSG_LISTCLASS_HEADER_LOCAL       0x0000EB8FL

//
// MessageId: MSG_LISTCLASS_NOCLASS
//
// MessageText:
//
// There is no "%1" setup class on %2.
//
#define MSG_LISTCLASS_NOCLASS            0x0000EB90L

//
// MessageId: MSG_LISTCLASS_NOCLASS_LOCAL
//
// MessageText:
//
// There is no "%1" setup class on the local machine.
//
#define MSG_LISTCLASS_NOCLASS_LOCAL      0x0000EB91L

//
// MessageId: MSG_LISTCLASS_HEADER_NONE
//
// MessageText:
//
// There are no devices in setup class "%1" (%2) on %3.
//
#define MSG_LISTCLASS_HEADER_NONE        0x0000EB92L

//
// MessageId: MSG_LISTCLASS_HEADER_NONE_LOCAL
//
// MessageText:
//
// There are no devices in setup class "%1" (%2).
//
#define MSG_LISTCLASS_HEADER_NONE_LOCAL  0x0000EB93L

//
// FIND
//
//
// MessageId: MSG_FIND_LONG
//
// MessageText:
//
// Devcon Find Command
// Finds devices with the specified hardware or instance ID. Valid on local and remote computers.
// %1 [-m:\\<machine>] %2 <id> [<id>...]
// %1 [-m:\\<machine>] %2 =<class> [<id>...]
// <machine>    Specifies a remote computer.
// <class>      Specifies a device setup class.
// Examples of <id>:
//  *              - All devices
//  ISAPNP\PNP0501 - Hardware ID
//  *PNP*          - Hardware ID with wildcards  (* matches anything)
//  @ISAPNP\*\*    - Instance ID with wildcards  (@ prefixes instance ID)
//  '*PNP0501      - Hardware ID with apostrophe (' prefixes literal match - matches exactly as typed,
//                                                including the asterisk.)
// Device entries have the format <instance>: <descr>
// where <instance> is the unique instance of the device and <descr> is the device description.
//
#define MSG_FIND_LONG                    0x0000EBF0L

//
// MessageId: MSG_FIND_SHORT
//
// MessageText:
//
// %1!-20s! Find devices.
//
#define MSG_FIND_SHORT                   0x0000EBF1L

//
// MessageId: MSG_FIND_TAIL_NONE
//
// MessageText:
//
// No matching devices found on %1.
//
#define MSG_FIND_TAIL_NONE               0x0000EBF2L

//
// MessageId: MSG_FIND_TAIL_NONE_LOCAL
//
// MessageText:
//
// No matching devices found.
//
#define MSG_FIND_TAIL_NONE_LOCAL         0x0000EBF3L

//
// MessageId: MSG_FIND_TAIL
//
// MessageText:
//
// %1!u! matching device(s) found on %2.
//
#define MSG_FIND_TAIL                    0x0000EBF4L

//
// MessageId: MSG_FIND_TAIL_LOCAL
//
// MessageText:
//
// %1!u! matching device(s) found.
//
#define MSG_FIND_TAIL_LOCAL              0x0000EBF5L

//
// MessageId: MSG_FINDALL_LONG
//
// MessageText:
//
// Devcon Findall Command
// Finds devices with the specified hardware or instance ID, including devices
// that are not currently attached. Valid on local and remote computers.
// %1 [-m:\\<machine>] %2 <id> [<id>...]
// %1 [-m:\\<machine>] %2 =<class> [<id>...]
// <machine>    Specifies a remote computer.
// <class>      Specifies a device setup class.
// Examples of <id>:
//  *              - All devices
//  ISAPNP\PNP0501 - Hardware ID
//  *PNP*          - Hardware ID with wildcards  (* matches anything)
//  @ISAPNP\*\*    - Instance ID with wildcards  (@ prefixes instance ID)
//  '*PNP0501      - Hardware ID with apostrophe (' prefixes literal match - matches exactly as typed,
//                                                including the asterisk.)
// Device entries have the format <instance>: <descr>
// where <instance> is the unique instance of the device and <descr> is the description.
//
#define MSG_FINDALL_LONG                 0x0000EBF6L

//
// MessageId: MSG_FINDALL_SHORT
//
// MessageText:
//
// %1!-20s! Find devices, including those that are not currently attached.
//
#define MSG_FINDALL_SHORT                0x0000EBF7L

//
// MessageId: MSG_STATUS_LONG
//
// MessageText:
//
// Devcon Status Command
// Lists the running status of devices with the specified hardware or instance ID.
// Valid on local and remote computers.
// %1 [-m:\\<machine>] %2 <id> [<id>...]
// %1 [-m:\\<machine>] %2 =<class> [<id>...]
// <machine>    Specifies a remote computer.
// <class>      Specifies a device setup class.
// Examples of <id>:
//  *              - All devices
//  ISAPNP\PNP0501 - Hardware ID
//  *PNP*          - Hardware ID with wildcards  (* matches anything)
//  @ISAPNP\*\*    - Instance ID with wildcards  (@ prefixes instance ID)
//  '*PNP0501      - Hardware ID with apostrophe (' prefixes literal match - matches exactly as typed,
//                                                including the asterisk.)
//
#define MSG_STATUS_LONG                  0x0000EBF8L

//
// MessageId: MSG_STATUS_SHORT
//
// MessageText:
//
// %1!-20s! List running status of devices.
//
#define MSG_STATUS_SHORT                 0x0000EBF9L

//
// MessageId: MSG_DRIVERFILES_LONG
//
// MessageText:
//
// Devcon Driverfiles Command
// List installed driver files for devices with the specified hardware or
// instance ID. Valid only on the local computer.
// %1 %2 <id> [<id>...]
// %1 %2 =<class> [<id>...]
// <class>      Specifies a device setup class.
// Examples of <id>:
//  *              - All devices
//  ISAPNP\PNP0501 - Hardware ID
//  *PNP*          - Hardware ID with wildcards  (* matches anything)
//  @ISAPNP\*\*    - Instance ID with wildcards  (@ prefixes instance ID)
//  '*PNP0501      - Hardware ID with apostrophe (' prefixes literal match - matches exactly as typed,
//                                                including the asterisk.)
//
#define MSG_DRIVERFILES_LONG             0x0000EBFAL

//
// MessageId: MSG_DRIVERFILES_SHORT
//
// MessageText:
//
// %1!-20s! List installed driver files for devices.
//
#define MSG_DRIVERFILES_SHORT            0x0000EBFBL

//
// MessageId: MSG_RESOURCES_LONG
//
// MessageText:
//
// Devcon Resources Command
// Lists hardware resources of devices with the specified hardware or instance ID.
// Valid on local and remote computers.
// %1 [-m:\\<machine>] %2 <id> [<id>...]
// %1 [-m:\\<machine>] %2 =<class> [<id>...]
// <machine>    Specifies a remote computer. 
// <class>      Specifies a device setup class.
// Examples of <id>:
// Examples of <id>:
//  *              - All devices
//  ISAPNP\PNP0501 - Hardware ID
//  *PNP*          - Hardware ID with wildcards  (* matches anything)
//  @ISAPNP\*\*    - Instance ID with wildcards  (@ prefixes instance ID)
//  '*PNP0501      - Hardware ID with apostrophe (' prefixes literal match - matches exactly as typed,
//                                                including the asterisk.)
//
#define MSG_RESOURCES_LONG               0x0000EBFCL

//
// MessageId: MSG_RESOURCES_SHORT
//
// MessageText:
//
// %1!-20s! List hardware resources for devices.
//
#define MSG_RESOURCES_SHORT              0x0000EBFDL

//
// MessageId: MSG_HWIDS_LONG
//
// MessageText:
//
// Devcon Hwids Command
// Lists hardware IDs of all devices with the specified hardware or instance ID.
// Valid on local and remote computers.
// %1 [-m:\\<machine>] %2 <id> [<id>...]
// %1 [-m:\\<machine>] %2 =<class> [<id>...]
// <machine>    Specifies a remote computer.
// <class>      Specifies a device setup class.
// Examples of <id>:
//  *              - All devices
//  ISAPNP\PNP0501 - Hardware ID
//  *PNP*          - Hardware ID with wildcards  (* matches anything)
//  @ISAPNP\*\*    - Instance ID with wildcards  (@ prefixes instance ID)
//  '*PNP0501      - Hardware ID with apostrophe (' prefixes literal match - matches exactly as typed,
//                                                including the asterisk.)
//
#define MSG_HWIDS_LONG                   0x0000EBFEL

//
// MessageId: MSG_HWIDS_SHORT
//
// MessageText:
//
// %1!-20s! List hardware IDs of devices.
//
#define MSG_HWIDS_SHORT                  0x0000EBFFL

//
// MessageId: MSG_STACK_LONG
//
// MessageText:
//
// Devcon Stack Command
// Lists the expected driver stack of devices with the specified hardware
// or instance ID. PnP calls each driver's AddDevice routine when building
// the device stack. Valid on local and remote computers.
// %1 [-m:\\<machine>] %2 <id> [<id>...]
// %1 [-m:\\<machine>] %2 =<class> [<id>...]
// <machine>    Specifies a remote computer.
// <class>      Specifies a device setup class.
// Examples of <id>:
//  *              - All devices
//  ISAPNP\PNP0501 - Hardware ID
//  *PNP*          - Hardware ID with wildcards  (* matches anything)
//  @ISAPNP\*\*    - Instance ID with wildcards  (@ prefixes instance ID)
//  '*PNP0501      - Hardware ID with apostrophe (' prefixes literal match - matches exactly as typed,
//                                                including the asterisk.)
//
#define MSG_STACK_LONG                   0x0000EC00L

//
// MessageId: MSG_STACK_SHORT
//
// MessageText:
//
// %1!-20s! List expected driver stack for devices.
//
#define MSG_STACK_SHORT                  0x0000EC01L

//
// ENABLE
//
//
// MessageId: MSG_ENABLE_LONG
//
// MessageText:
//
// Devcon Enable Command
// Enables devices with the specified hardware or instance ID. Valid only on
// the local computer. (To reboot when necessary, include -r.)
// %1 [-r] %2 <id> [<id>...]
// %1 [-r] %2 =<class> [<id>...]
// -r           Reboots the system only when a restart or reboot is required.
// <class>      Specifies a device setup class.
// Examples of <id>:
//  *              - All devices
//  ISAPNP\PNP0501 - Hardware ID
//  *PNP*          - Hardware ID with wildcards  (* matches anything)
//  @ISAPNP\*\*    - Instance ID with wildcards  (@ prefixes instance ID)
//  '*PNP0501      - Hardware ID with apostrophe (' prefixes literal match - matches exactly as typed,
//                                                including the asterisk.)
//
#define MSG_ENABLE_LONG                  0x0000EC54L

//
// MessageId: MSG_ENABLE_SHORT
//
// MessageText:
//
// %1!-20s! Enable devices.
//
#define MSG_ENABLE_SHORT                 0x0000EC55L

//
// MessageId: MSG_ENABLE_TAIL_NONE
//
// MessageText:
//
// No devices were enabled, either because the devices were not found, 
// or because the devices could not be enabled.
//
#define MSG_ENABLE_TAIL_NONE             0x0000EC56L

//
// MessageId: MSG_ENABLE_TAIL_REBOOT
//
// MessageText:
//
// The %1!u! device(s) are ready to be enabled. To enable the devices, restart the devices or
// reboot the system .
//
#define MSG_ENABLE_TAIL_REBOOT           0x0000EC57L

//
// MessageId: MSG_ENABLE_TAIL
//
// MessageText:
//
// %1!u! device(s) are enabled.
//
#define MSG_ENABLE_TAIL                  0x0000EC58L

//
// DISABLE
//
//
// MessageId: MSG_DISABLE_LONG
//
// MessageText:
//
// Devcon Disable Command
// Disables devices with the specified hardware or instance ID.
// Valid only on the local computer. (To reboot when necesary, Include -r .)
// %1 [-r] %2 <id> [<id>...]
// %1 [-r] %2 =<class> [<id>...]
// -r           Reboots the system only when a restart or reboot is required.
// <class>      Specifies a device setup class.
// Examples of <id>:
//  *              - All devices
//  ISAPNP\PNP0501 - Hardware ID
//  *PNP*          - Hardware ID with wildcards  (* matches anything)
//  @ISAPNP\*\*    - Instance ID with wildcards  (@ prefixes instance ID)
//  '*PNP0501      - Hardware ID with apostrophe (' prefixes literal match - matches exactly as typed,
//                                                including the asterisk.)
//
#define MSG_DISABLE_LONG                 0x0000ECB8L

//
// MessageId: MSG_DISABLE_SHORT
//
// MessageText:
//
// %1!-20s! Disable devices.
//
#define MSG_DISABLE_SHORT                0x0000ECB9L

//
// MessageId: MSG_DISABLE_TAIL_NONE
//
// MessageText:
//
// No devices were disabled, either because the devices were not found,
// or because the devices could not be disabled.
//
#define MSG_DISABLE_TAIL_NONE            0x0000ECBAL

//
// MessageId: MSG_DISABLE_TAIL_REBOOT
//
// MessageText:
//
// The %1!u! device(s) are ready to be disabled. To disable the devices, restart the
// devices or reboot the system .
//
#define MSG_DISABLE_TAIL_REBOOT          0x0000ECBBL

//
// MessageId: MSG_DISABLE_TAIL
//
// MessageText:
//
// %1!u! device(s) disabled.
//
#define MSG_DISABLE_TAIL                 0x0000ECBCL

//
// RESTART
//
//
// MessageId: MSG_RESTART_LONG
//
// MessageText:
//
// Devcon Restart Command
// Restarts devices with the specified hardware or instance ID.
// Valid only on the local computer. (To reboot when necesary, Include -r .)
// %1 [-r] %2 <id> [<id>...]
// %1 [-r] %2 =<class> [<id>...]
// <class>      Specifies a device setup class.
// Examples of <id>:
//  *              - All devices
//  ISAPNP\PNP0501 - Hardware ID
//  *PNP*          - Hardware ID with wildcards  (* matches anything)
//  @ISAPNP\*\*    - Instance ID with wildcards  (@ prefixes instance ID)
//  '*PNP0501      - Hardware ID with apostrophe (' prefixes literal match - matches exactly as typed,
//                                                including the asterisk.)
//
#define MSG_RESTART_LONG                 0x0000ED1CL

//
// MessageId: MSG_RESTART_SHORT
//
// MessageText:
//
// %1!-20s! Restart devices.
//
#define MSG_RESTART_SHORT                0x0000ED1DL

//
// MessageId: MSG_RESTART_TAIL_NONE
//
// MessageText:
//
// No devices were restarted, either because the devices were not found,
// or because the devices could not be restarted.
//
#define MSG_RESTART_TAIL_NONE            0x0000ED1EL

//
// MessageId: MSG_RESTART_TAIL_REBOOT
//
// MessageText:
//
// The %1!u! device(s) are ready to be restarted. To restart the devices, reboot the system.
//
#define MSG_RESTART_TAIL_REBOOT          0x0000ED1FL

//
// MessageId: MSG_RESTART_TAIL
//
// MessageText:
//
// %1!u! device(s) restarted.
//
#define MSG_RESTART_TAIL                 0x0000ED20L

//
// REBOOT
//
//
// MessageId: MSG_REBOOT_LONG
//
// MessageText:
//
// %1 %2
// Reboots the local computer as part of a planned hardware installation.
//
#define MSG_REBOOT_LONG                  0x0000ED80L

//
// MessageId: MSG_REBOOT_SHORT
//
// MessageText:
//
// %1!-20s! Reboot the local computer.
//
#define MSG_REBOOT_SHORT                 0x0000ED81L

//
// MessageId: MSG_REBOOT
//
// MessageText:
//
// Rebooting the local computer.
//
#define MSG_REBOOT                       0x0000ED82L

//
// DUMP
//
//
// MessageId: MSG_DUMP_PROBLEM
//
// MessageText:
//
// The device has the following problem: %1!02u!
//
#define MSG_DUMP_PROBLEM                 0x0000EDE8L

//
// MessageId: MSG_DUMP_PRIVATE_PROBLEM
//
// MessageText:
//
// The driver reported a problem with the device.
//
#define MSG_DUMP_PRIVATE_PROBLEM         0x0000EDE9L

//
// MessageId: MSG_DUMP_STARTED
//
// MessageText:
//
// Driver is running.
//
#define MSG_DUMP_STARTED                 0x0000EDEAL

//
// MessageId: MSG_DUMP_DISABLED
//
// MessageText:
//
// Device is disabled.
//
#define MSG_DUMP_DISABLED                0x0000EDEBL

//
// MessageId: MSG_DUMP_NOTSTARTED
//
// MessageText:
//
// Device is currently stopped.
//
#define MSG_DUMP_NOTSTARTED              0x0000EDECL

//
// MessageId: MSG_DUMP_NO_RESOURCES
//
// MessageText:
//
// Device is not using any resources.
//
#define MSG_DUMP_NO_RESOURCES            0x0000EDEDL

//
// MessageId: MSG_DUMP_NO_RESERVED_RESOURCES
//
// MessageText:
//
// Device has no reserved resources.
//
#define MSG_DUMP_NO_RESERVED_RESOURCES   0x0000EDEEL

//
// MessageId: MSG_DUMP_RESOURCES
//
// MessageText:
//
// Device is currently using the following resources:
//
#define MSG_DUMP_RESOURCES               0x0000EDEFL

//
// MessageId: MSG_DUMP_RESERVED_RESOURCES
//
// MessageText:
//
// Device has the following reserved resources:
//
#define MSG_DUMP_RESERVED_RESOURCES      0x0000EDF0L

//
// MessageId: MSG_DUMP_DRIVER_FILES
//
// MessageText:
//
// Driver installed from %2 [%3]. %1!u! file(s) used by driver:
//
#define MSG_DUMP_DRIVER_FILES            0x0000EDF1L

//
// MessageId: MSG_DUMP_NO_DRIVER_FILES
//
// MessageText:
//
// Driver installed from %2 [%3]. The driver is not using any files.
//
#define MSG_DUMP_NO_DRIVER_FILES         0x0000EDF2L

//
// MessageId: MSG_DUMP_NO_DRIVER
//
// MessageText:
//
// No driver information available for the device.
//
#define MSG_DUMP_NO_DRIVER               0x0000EDF3L

//
// MessageId: MSG_DUMP_HWIDS
//
// MessageText:
//
// Hardware IDs:
//
#define MSG_DUMP_HWIDS                   0x0000EDF4L

//
// MessageId: MSG_DUMP_COMPATIDS
//
// MessageText:
//
// Compatible IDs:
//
#define MSG_DUMP_COMPATIDS               0x0000EDF5L

//
// MessageId: MSG_DUMP_NO_HWIDS
//
// MessageText:
//
// No hardware/compatible IDs found for this device.
//
#define MSG_DUMP_NO_HWIDS                0x0000EDF6L

//
// MessageId: MSG_DUMP_NO_DRIVERNODES
//
// MessageText:
//
// No driver nodes found for this device.
//
#define MSG_DUMP_NO_DRIVERNODES          0x0000EDF7L

//
// MessageId: MSG_DUMP_DRIVERNODE_HEADER
//
// MessageText:
//
// Driver node #%1!u!:
//
#define MSG_DUMP_DRIVERNODE_HEADER       0x0000EDF8L

//
// MessageId: MSG_DUMP_DRIVERNODE_INF
//
// MessageText:
//
// Inf file is %1
//
#define MSG_DUMP_DRIVERNODE_INF          0x0000EDF9L

//
// MessageId: MSG_DUMP_DRIVERNODE_SECTION
//
// MessageText:
//
// Inf section is %1
//
#define MSG_DUMP_DRIVERNODE_SECTION      0x0000EDFAL

//
// MessageId: MSG_DUMP_DRIVERNODE_DESCRIPTION
//
// MessageText:
//
// Driver description is %1
//
#define MSG_DUMP_DRIVERNODE_DESCRIPTION  0x0000EDFBL

//
// MessageId: MSG_DUMP_DRIVERNODE_MFGNAME
//
// MessageText:
//
// Manufacturer name is %1
//
#define MSG_DUMP_DRIVERNODE_MFGNAME      0x0000EDFCL

//
// MessageId: MSG_DUMP_DRIVERNODE_PROVIDERNAME
//
// MessageText:
//
// Provider name is %1
//
#define MSG_DUMP_DRIVERNODE_PROVIDERNAME 0x0000EDFDL

//
// MessageId: MSG_DUMP_DRIVERNODE_DRIVERDATE
//
// MessageText:
//
// Driver date is %1
//
#define MSG_DUMP_DRIVERNODE_DRIVERDATE   0x0000EDFEL

//
// MessageId: MSG_DUMP_DRIVERNODE_DRIVERVERSION
//
// MessageText:
//
// Driver version is %1!u!.%2!u!.%3!u!.%4!u!
//
#define MSG_DUMP_DRIVERNODE_DRIVERVERSION 0x0000EDFFL

//
// MessageId: MSG_DUMP_DRIVERNODE_RANK
//
// MessageText:
//
// Driver node rank is %1!u!
//
#define MSG_DUMP_DRIVERNODE_RANK         0x0000EE00L

//
// MessageId: MSG_DUMP_DRIVERNODE_FLAGS
//
// MessageText:
//
// Driver node flags are %1!08X!
//
#define MSG_DUMP_DRIVERNODE_FLAGS        0x0000EE01L

//
// MessageId: MSG_DUMP_DRIVERNODE_FLAGS_OLD_INET_DRIVER
//
// MessageText:
//
// Inf came from the Internet
//
#define MSG_DUMP_DRIVERNODE_FLAGS_OLD_INET_DRIVER 0x0000EE02L

//
// MessageId: MSG_DUMP_DRIVERNODE_FLAGS_BAD_DRIVER
//
// MessageText:
//
// Driver node is marked "BAD"
//
#define MSG_DUMP_DRIVERNODE_FLAGS_BAD_DRIVER 0x0000EE03L

//
// MessageId: MSG_DUMP_DRIVERNODE_FLAGS_INF_IS_SIGNED
//
// MessageText:
//
// Inf is digitally signed
//
#define MSG_DUMP_DRIVERNODE_FLAGS_INF_IS_SIGNED 0x0000EE04L

//
// MessageId: MSG_DUMP_DRIVERNODE_FLAGS_OEM_F6_INF
//
// MessageText:
//
// Inf was installed by using F6 during text mode setup
//
#define MSG_DUMP_DRIVERNODE_FLAGS_OEM_F6_INF 0x0000EE05L

//
// MessageId: MSG_DUMP_DRIVERNODE_FLAGS_BASIC_DRIVER
//
// MessageText:
//
// Driver provides basic functionality when no signed driver is available.
//
#define MSG_DUMP_DRIVERNODE_FLAGS_BASIC_DRIVER 0x0000EE06L

//
// MessageId: MSG_DUMP_DEVICESTACK_UPPERCLASSFILTERS
//
// MessageText:
//
// Upper class filters:
//
#define MSG_DUMP_DEVICESTACK_UPPERCLASSFILTERS 0x0000EE07L

//
// MessageId: MSG_DUMP_DEVICESTACK_UPPERFILTERS
//
// MessageText:
//
// Upper filters:
//
#define MSG_DUMP_DEVICESTACK_UPPERFILTERS 0x0000EE08L

//
// MessageId: MSG_DUMP_DEVICESTACK_SERVICE
//
// MessageText:
//
// Controlling service:
//
#define MSG_DUMP_DEVICESTACK_SERVICE     0x0000EE09L

//
// MessageId: MSG_DUMP_DEVICESTACK_NOSERVICE
//
// MessageText:
//
// (none)
//
#define MSG_DUMP_DEVICESTACK_NOSERVICE   0x0000EE0AL

//
// MessageId: MSG_DUMP_DEVICESTACK_LOWERCLASSFILTERS
//
// MessageText:
//
// Class lower filters:
//
#define MSG_DUMP_DEVICESTACK_LOWERCLASSFILTERS 0x0000EE0BL

//
// MessageId: MSG_DUMP_DEVICESTACK_LOWERFILTERS
//
// MessageText:
//
// Lower filters:
//
#define MSG_DUMP_DEVICESTACK_LOWERFILTERS 0x0000EE0CL

//
// MessageId: MSG_DUMP_SETUPCLASS
//
// MessageText:
//
// Setup Class: %1 %2
//
#define MSG_DUMP_SETUPCLASS              0x0000EE0DL

//
// MessageId: MSG_DUMP_NOSETUPCLASS
//
// MessageText:
//
// Device is not set up.
//
#define MSG_DUMP_NOSETUPCLASS            0x0000EE0EL

//
// MessageId: MSG_DUMP_DESCRIPTION
//
// MessageText:
//
// Name: %1
//
#define MSG_DUMP_DESCRIPTION             0x0000EE0FL

//
// MessageId: MSG_DUMP_PHANTOM
//
// MessageText:
//
// Device is not present.
//
#define MSG_DUMP_PHANTOM                 0x0000EE10L

//
// MessageId: MSG_DUMP_STATUS_ERROR
//
// MessageText:
//
// Error retrieving the device's status.
//
#define MSG_DUMP_STATUS_ERROR            0x0000EE11L

//
// INSTALL
//
//
// MessageId: MSG_INSTALL_LONG
//
// MessageText:
//
// Devcon Install Command
// Installs the specified device manually. Valid only on the local computer. 
// (To reboot when necesary, Include -r .)
// %1 [-r] %2 <inf> <hwid>
// <inf>        Specifies an INF file with installation information for the device.
// <hwid>       Specifies a hardware ID for the device.
// -r           Reboots the system only when a restart or reboot is required.
//
#define MSG_INSTALL_LONG                 0x0000EE48L

//
// MessageId: MSG_INSTALL_SHORT
//
// MessageText:
//
// %1!-20s! Install a device manually.
//
#define MSG_INSTALL_SHORT                0x0000EE49L

//
// MessageId: MSG_INSTALL_UPDATE
//
// MessageText:
//
// Device node created. Install is complete when drivers are installed...
//
#define MSG_INSTALL_UPDATE               0x0000EE4AL

//
// UPDATE
//
//
// MessageId: MSG_UPDATE_LONG
//
// MessageText:
//
// Devcon Update Command
// Updates drivers for all devices with the specified hardware ID (<hwid>). 
// Valid only on the local computer. (To reboot when necesary, Include -r .)
// %1 [-r] %2 <inf> <hwid>
// -r           Reboots the system only when a restart or reboot is required.
// <inf>        Specifies an INF file with installation information for the devices.
// <hwid>       Specifies the hardware ID of the devices.
//
#define MSG_UPDATE_LONG                  0x0000EEACL

//
// MessageId: MSG_UPDATE_SHORT
//
// MessageText:
//
// %1!-20s! Update a device manually.
//
#define MSG_UPDATE_SHORT                 0x0000EEADL

//
// MessageId: MSG_UPDATE_INF
//
// MessageText:
//
// Updating drivers for %1 from %2.
//
#define MSG_UPDATE_INF                   0x0000EEAEL

//
// MessageId: MSG_UPDATE
//
// MessageText:
//
// Updating drivers for %1.
//
#define MSG_UPDATE                       0x0000EEAFL

//
// MessageId: MSG_UPDATENI_LONG
//
// MessageText:
//
// %1 [-r] %2 <inf> <hwid>
// Update drivers for devices (Non Interactive).
// This command will only work for local machine.
// Specify -r to reboot automatically if needed.
// <inf> is an INF to use to install the device.
// All devices that match <hwid> are updated.
// Unsigned installs will fail. No UI will be
// presented.
//
#define MSG_UPDATENI_LONG                0x0000EEB0L

//
// MessageId: MSG_UPDATENI_SHORT
//
// MessageText:
//
// %1!-20s! Manually update a device (non interactive).
//
#define MSG_UPDATENI_SHORT               0x0000EEB1L

//
// MessageId: MSG_UPDATE_OK
//
// MessageText:
//
// Drivers installed successfully.
//
#define MSG_UPDATE_OK                    0x0000EEB2L

//
// Driver Package (add/remove/enum)
//
//
// MessageId: MSG_DPADD_LONG
//
// MessageText:
//
// %1 %2 <inf>
// Adds (installs) a third-party (OEM) driver package.
// This command will only work on the local machine.
// <inf> is a full path to the INF of the Driver
// Package that will be installed on this machine.
//
#define MSG_DPADD_LONG                   0x0000EEB3L

//
// MessageId: MSG_DPADD_SHORT
//
// MessageText:
//
// %1!-20s! Adds (installs) a third-party (OEM) driver package.
//
#define MSG_DPADD_SHORT                  0x0000EEB4L

//
// MessageId: MSG_DPDELETE_LONG
//
// MessageText:
//
// %1 [-f] %2 <inf>
// Deletes a third-party (OEM) driver package.
// This command will only work on the local machine.
// [-f] will force delete the driver package, even
// if it is in use by a device.
// <inf> is the name of a published INF on the local
// machine.  This is the value returned from dp_add
// and dp_enum.
//
#define MSG_DPDELETE_LONG                0x0000EEB5L

//
// MessageId: MSG_DPDELETE_SHORT
//
// MessageText:
//
// %1!-20s! Deletes a third-party (OEM) driver package.
//
#define MSG_DPDELETE_SHORT               0x0000EEB6L

//
// MessageId: MSG_DPENUM_LONG
//
// MessageText:
//
// %1 %2
// Lists the third-party (OEM) driver packages installed on this machine.
// This command will only work on the local machine.
// Values returned from dp_enum can be sent to dp_delete 
// to be removed from the machine.
//
#define MSG_DPENUM_LONG                  0x0000EEB7L

//
// MessageId: MSG_DPENUM_SHORT
//
// MessageText:
//
// %1!-20s! Lists the third-party (OEM) driver packages installed on this machine.
//
#define MSG_DPENUM_SHORT                 0x0000EEB8L

//
// MessageId: MSG_DPADD_INVALID_INF
//
// MessageText:
//
// The specified INF path is not valid.
//
#define MSG_DPADD_INVALID_INF            0x0000EEB9L

//
// MessageId: MSG_DPADD_FAILED
//
// MessageText:
//
// Adding the specified driver package to the machine failed.
//
#define MSG_DPADD_FAILED                 0x0000EEBAL

//
// MessageId: MSG_DPADD_SUCCESS
//
// MessageText:
//
// Driver package '%1' added.
//
#define MSG_DPADD_SUCCESS                0x0000EEBBL

//
// MessageId: MSG_DPDELETE_FAILED
//
// MessageText:
//
// Deleting the specified driver package from the machine failed.
//
#define MSG_DPDELETE_FAILED              0x0000EEBCL

//
// MessageId: MSG_DPDELETE_FAILED_IN_USE
//
// MessageText:
//
// Deleting the specified driver package from the machine failed
// because it is in use by a device.
//
#define MSG_DPDELETE_FAILED_IN_USE       0x0000EEBDL

//
// MessageId: MSG_DPDELETE_FAILED_NOT_OEM_INF
//
// MessageText:
//
// Deleting the specified driver package from the machine failed
// because it is not an third-party package.
//
#define MSG_DPDELETE_FAILED_NOT_OEM_INF  0x0000EEBEL

//
// MessageId: MSG_DPDELETE_SUCCESS
//
// MessageText:
//
// Driver package '%1' deleted.
//
#define MSG_DPDELETE_SUCCESS             0x0000EEBFL

//
// MessageId: MSG_DPENUM_NO_OEM_INF
//
// MessageText:
//
// There are no third-party driver packages on this machine.
//
#define MSG_DPENUM_NO_OEM_INF            0x0000EEC0L

//
// MessageId: MSG_DPENUM_LIST_HEADER
//
// MessageText:
//
// The following third-party driver packages are installed on this computer:
//
#define MSG_DPENUM_LIST_HEADER           0x0000EEC1L

//
// MessageId: MSG_DPENUM_LIST_ENTRY
//
// MessageText:
//
// %1
//
#define MSG_DPENUM_LIST_ENTRY            0x0000EEC2L

//
// MessageId: MSG_DPENUM_DUMP_PROVIDER
//
// MessageText:
//
//     Provider: %1
//
#define MSG_DPENUM_DUMP_PROVIDER         0x0000EEC3L

//
// MessageId: MSG_DPENUM_DUMP_PROVIDER_UNKNOWN
//
// MessageText:
//
//     Provider: unknown
//
#define MSG_DPENUM_DUMP_PROVIDER_UNKNOWN 0x0000EEC4L

//
// MessageId: MSG_DPENUM_DUMP_CLASS
//
// MessageText:
//
//     Class: %1
//
#define MSG_DPENUM_DUMP_CLASS            0x0000EEC5L

//
// MessageId: MSG_DPENUM_DUMP_CLASS_UNKNOWN
//
// MessageText:
//
//     Class: unknown
//
#define MSG_DPENUM_DUMP_CLASS_UNKNOWN    0x0000EEC6L

//
// MessageId: MSG_DPENUM_DUMP_VERSION
//
// MessageText:
//
//     Version: %1
//
#define MSG_DPENUM_DUMP_VERSION          0x0000EEC7L

//
// MessageId: MSG_DPENUM_DUMP_VERSION_UNKNOWN
//
// MessageText:
//
//     Version: unknown
//
#define MSG_DPENUM_DUMP_VERSION_UNKNOWN  0x0000EEC8L

//
// MessageId: MSG_DPENUM_DUMP_DATE
//
// MessageText:
//
//     Date: %1
//
#define MSG_DPENUM_DUMP_DATE             0x0000EEC9L

//
// MessageId: MSG_DPENUM_DUMP_DATE_UNKNOWN
//
// MessageText:
//
//     Date: unknown
//
#define MSG_DPENUM_DUMP_DATE_UNKNOWN     0x0000EECAL

//
// MessageId: MSG_DPENUM_DUMP_SIGNER
//
// MessageText:
//
//     Signer: %1
//
#define MSG_DPENUM_DUMP_SIGNER           0x0000EECBL

//
// MessageId: MSG_DPENUM_DUMP_SIGNER_UNKNOWN
//
// MessageText:
//
//     Signer: unknown
//
#define MSG_DPENUM_DUMP_SIGNER_UNKNOWN   0x0000EECCL

//
// REMOVE
//
//
// MessageId: MSG_REMOVE_LONG
//
// MessageText:
//
// Devcon Remove Command
// Removes devices with the specified hardware or instance ID. Valid only on
// the local computer. (To reboot when necesary, Include -r .)
// %1 [-r] %2 <id> [<id>...]
// %1 [-r] %2 =<class> [<id>...]
// <class>      Specifies a device setup class.
// Examples of <id>:
//  *              - All devices
//  ISAPNP\PNP0501 - Hardware ID
//  *PNP*          - Hardware ID with wildcards  (* matches anything)
//  @ISAPNP\*\*    - Instance ID with wildcards  (@ prefixes instance ID)
//  '*PNP0501      - Hardware ID with apostrophe (' prefixes literal match - matches exactly as typed,
//                                                including the asterisk.)
//
#define MSG_REMOVE_LONG                  0x0000EF10L

//
// MessageId: MSG_REMOVE_SHORT
//
// MessageText:
//
// %1!-20s! Remove devices.
//
#define MSG_REMOVE_SHORT                 0x0000EF11L

//
// MessageId: MSG_REMOVE_TAIL_NONE
//
// MessageText:
//
// No devices were removed.
//
#define MSG_REMOVE_TAIL_NONE             0x0000EF12L

//
// MessageId: MSG_REMOVE_TAIL_REBOOT
//
// MessageText:
//
// The %1!u! device(s) are ready to be removed. To remove the devices, reboot the system.
//
#define MSG_REMOVE_TAIL_REBOOT           0x0000EF13L

//
// MessageId: MSG_REMOVE_TAIL
//
// MessageText:
//
// %1!u! device(s) were removed.
//
#define MSG_REMOVE_TAIL                  0x0000EF14L

//
// RESCAN
//
//
// MessageId: MSG_RESCAN_LONG
//
// MessageText:
//
// Devcon Rescan Command
// Directs Plug and Play to scan for new hardware. Valid on a local or remote computer.
// %1 [-m:\\<machine>]
// <machine>    Specifies a remote computer. 
//
#define MSG_RESCAN_LONG                  0x0000EF74L

//
// MessageId: MSG_RESCAN_SHORT
//
// MessageText:
//
// %1!-20s! Scan for new hardware.
//
#define MSG_RESCAN_SHORT                 0x0000EF75L

//
// MessageId: MSG_RESCAN_LOCAL
//
// MessageText:
//
// Scanning for new hardware.
//
#define MSG_RESCAN_LOCAL                 0x0000EF76L

//
// MessageId: MSG_RESCAN
//
// MessageText:
//
// Scanning for new hardware on %1.
//
#define MSG_RESCAN                       0x0000EF77L

//
// MessageId: MSG_RESCAN_OK
//
// MessageText:
//
// Scanning completed.
//
#define MSG_RESCAN_OK                    0x0000EF78L

//
// DRIVERNODES
//
//
// MessageId: MSG_DRIVERNODES_LONG
//
// MessageText:
//
// Devcon Drivernodes Command
// Lists driver nodes for devices with the specified hardware or instance ID.
// Valid only on the local computer.
// %1 %2 <id> [<id>...]
// %1 %2 =<class> [<id>...]
// <class>      Specifies a device setup class.
// Examples of <id>:
//  *              - All devices
//  ISAPNP\PNP0501 - Hardware ID
//  *PNP*          - Hardware ID with wildcards  (* matches anything)
//  @ISAPNP\*\*    - Instance ID with wildcards  (@ prefixes instance ID)
//  '*PNP0501      - Hardware ID with apostrophe (' prefixes literal match - matches exactly as typed,
//                                                including the asterisk.)
//
#define MSG_DRIVERNODES_LONG             0x0000EFD8L

//
// MessageId: MSG_DRIVERNODES_SHORT
//
// MessageText:
//
// %1!-20s! List driver nodes of devices.
//
#define MSG_DRIVERNODES_SHORT            0x0000EFD9L

//
// CLASSFILTER
//
//
// MessageId: MSG_CLASSFILTER_LONG
//
// MessageText:
//
// Devcon Classfilter Command
// 
// Lists, adds, deletes, and reorders upper and lower filter drivers for a device
// setup class. Changes do not take effect until the affected devices are restarted
// or the machine is rebooted.
// 
// %1 %2 [-r] <class> {upper | lower} [<operator><filter> [<operator><filter>...]]
// <class>      Specifies a device setup class.
// <operator>   Specifies an operation (listed below).
// <filter>     Specifies a class filter driver.
// upper        Identifies an upper filter driver.
// lower        Identifies a lower filter driver.
// 
// To list the upper/lower filter drivers for a class, 
// type:  devcon classfilter <class> {upper | lower}
// 
// The Devcon classfilter command uses subcommands, which consist of an 
// operator (=, @, -, +, !) and a filter driver name.
// 
// The Devcon classfilter command uses a virtual cursor to move through
// the list of filter drivers. The cursor starts at the beginning of the 
// list (before the first filter). Unless returned to the starting position,
// the cursor always moves forward.
// 
// Operators
//  =       Move the cursor to the beginning of the filter driver list (before the
//          first filter driver).
// 
//  @       Position the cursor on the next instance of the specified filter.
// 
//  -       Add before. Insert the specified filter before the filter on which the cursor
//          is positioned. If the cursor is not positioned on a filter, insert the
//          new filter at the beginning of the list. When the subcommand completes, the
//          cursor is positioned on the newly-added filter.
// 
//  +       Add after. Insert the specified filter after the filter on which the cursor
//          is positioned. If the cursor is not positioned on a filter, Devcon inserts the
//          new filter at the end of the list. When the subcommand completes, the cursor
//          cursor is positioned on the newly-added filter.       
// 
//  !       Deletes the next occurrence of the specified filter. When the subcommand 
//          completes, the cursor occupies the position of the deleted filter. 
//          Subsequent - or + subcommands insert a new filter at the cursor position.
// 
// 
// Examples:
// If the upper filters for setup class "foo" are A,B,C,B,D,B,E:
// %1 %2 foo upper @D !B    - deletes the third 'B'.
// %1 %2 foo upper !B !B !B - deletes all three instances of 'B'.
// %1 %2 foo upper =!B =!A  - deletes the first 'B' and the first 'A'.
// %1 %2 foo upper !C +CC   - replaces 'C' with 'CC'.
// %1 %2 foo upper @D -CC   - inserts 'CC' before 'D'.
// %1 %2 foo upper @D +CC   - inserts 'CC' after 'D'.
// %1 %2 foo upper -CC      - inserts 'CC' before 'A'.
// %1 %2 foo upper +CC      - inserts 'CC' after 'E'.
// %1 %2 foo upper @D +X +Y - inserts 'X' after 'D' and 'Y' after 'X'.
// %1 %2 foo upper @D -X -Y - inserts 'X' before 'D' and 'Y' before 'X'.
// %1 %2 foo upper @D -X +Y - inserts 'X' before 'D' and 'Y' between 'X' and 'D'.
//
#define MSG_CLASSFILTER_LONG             0x0000F03CL

//
// MessageId: MSG_CLASSFILTER_SHORT
//
// MessageText:
//
// %1!-20s! Add, delete, and reorder class filters.
//
#define MSG_CLASSFILTER_SHORT            0x0000F03DL

//
// MessageId: MSG_CLASSFILTER_CHANGED
//
// MessageText:
//
// Class filters changed. Restart the devices or reboot the system to make the change effective.
//
#define MSG_CLASSFILTER_CHANGED          0x0000F03EL

//
// MessageId: MSG_CLASSFILTER_UNCHANGED
//
// MessageText:
//
// Class filters unchanged.
//
#define MSG_CLASSFILTER_UNCHANGED        0x0000F03FL

//
// SETHWID
//
//
// MessageId: MSG_SETHWID_LONG
//
// MessageText:
//
// %1 [-m:\\<machine>] %2 <id> [<id>...] := <subcmds>
// %1 [-m:\\<machine>] %2 =<class> [<id>...] := <subcmds>
// Modifies the hardware ID's of the listed devices. This command will only work for root-enumerated devices.
// This command will work for a remote machine.
// Examples of <id> are:
// *                  - All devices (not recommended)
// ISAPNP\PNP0601     - Hardware ID
// *PNP*              - Hardware ID with wildcards (* matches anything)
// @ROOT\*\*          - Instance ID with wildcards (@ prefixes instance ID)
// <class> is a setup class name as obtained from the classes command.
// 
// <subcmds> consists of one or more:
// =hwid              - Clear hardware ID list and set it to hwid.
// +hwid              - Add or move hardware ID to head of list (better match).
// -hwid              - Add or move hardware ID to end of list (worse match).
// !hwid              - Remove hardware ID from list.
// hwid               - each additional hardware id is inserted after the previous.
//
#define MSG_SETHWID_LONG                 0x0000F0A0L

//
// MessageId: MSG_SETHWID_SHORT
//
// MessageText:
//
// %1!-20s! Modify Hardware ID's of listed root-enumerated devices.
//
#define MSG_SETHWID_SHORT                0x0000F0A1L

//
// MessageId: MSG_SETHWID_TAIL_NONE
//
// MessageText:
//
// No hardware ID's modified.
//
#define MSG_SETHWID_TAIL_NONE            0x0000F0A2L

//
// MessageId: MSG_SETHWID_TAIL_SKIPPED
//
// MessageText:
//
// Skipped %1!u! non-root device(s), modified the hardware ID on %2!u! device(s).
//
#define MSG_SETHWID_TAIL_SKIPPED         0x0000F0A3L

//
// MessageId: MSG_SETHWID_TAIL_MODIFIED
//
// MessageText:
//
// Modified the Hardware ID on %1!u! device(s).
//
#define MSG_SETHWID_TAIL_MODIFIED        0x0000F0A4L

//
// MessageId: MSG_SETHWID_NOTROOT
//
// MessageText:
//
// Skipping (Not root-enumerated).
//
#define MSG_SETHWID_NOTROOT              0x0000F0A5L


```

`packetWin7/NPFInstall/NPFInstall/netcfgapi.cpp`:

```cpp
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
#include "NetCfgAPI.h"
#include "ProtInstall.h"

#include "debug.h"

//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:   	N E T C F G A P I . C P P
//
//  Contents:   Functions to illustrate INetCfg API
//
//  Notes:  	
//
//  Author: 	Alok Sinha    15-May-01
//
//  Some revisions by PCAUSA (TFD) 03-Feb-06
//
//----------------------------------------------------------------------------


//
// Function:  HrGetINetCfg
//
// Purpose:   Get a reference to INetCfg.
//
// Arguments:
//    fGetWriteLock  [in]  If TRUE, Write lock.requested.
//    lpszAppName    [in]  Application name requesting the reference.
//    ppnc  		 [out] Reference to INetCfg.
//    lpszLockedBy   [in]  Optional. Application who holds the write lock.
//
// Returns:   S_OK on success, otherwise an error code.
//
// Notes:
//

extern BOOLEAN bWiFiService;

HRESULT HrGetINetCfg(IN BOOL fGetWriteLock, IN LPCTSTR lpszAppName, OUT INetCfg** ppnc, OUT LPTSTR* lpszLockedBy)
{
	TRACE_ENTER();

	INetCfg* pnc = NULL;
	INetCfgLock* pncLock = NULL;
	HRESULT hr = S_OK;
	BOOL selfStartedCom = FALSE;

	//
	// Initialize the output parameters.
	//

	*ppnc = NULL;

	if (lpszLockedBy)
	{
		*lpszLockedBy = NULL;
	}
	//
	// Initialize COM
	//

	hr = CoInitialize(NULL);

	if (hr == S_OK || hr == S_FALSE)
	{
		if (hr == S_OK)
		{
			selfStartedCom = TRUE;
		}
		//
		// Create the object implementing INetCfg.
		//

		hr = CoCreateInstance(CLSID_CNetCfg, NULL, CLSCTX_INPROC_SERVER, IID_INetCfg, (void**)&pnc);
		if (hr == S_OK)
		{
			if (fGetWriteLock)
			{
				//
				// Get the locking reference
				//

				hr = pnc->QueryInterface(IID_INetCfgLock, (LPVOID *)&pncLock);
				if (hr == S_OK)
				{
					//
					// Attempt to lock the INetCfg for read/write
					//

					hr = pncLock->AcquireWriteLock(LOCK_TIME_OUT, lpszAppName, lpszLockedBy);
					if (!SUCCEEDED(hr))
					{
						hr = NETCFG_E_NO_WRITE_LOCK;
					}
				}
			}

			if (hr == S_OK)
			{
				//
				// Initialize the INetCfg object.
				//

				hr = pnc->Initialize(NULL);

				if (hr == S_OK)
				{
					*ppnc = pnc;
					pnc->AddRef();
				}
				else
				{
					//
					// Initialize failed, if obtained lock, release it
					//

					if (pncLock)
					{
						pncLock->ReleaseWriteLock();
					}
				}
			}

			ReleaseRef(pncLock);
			ReleaseRef(pnc);
		}
		else
		{
			TRACE_PRINT1("CoCreateInstance: error, hr = 0x%08x.", hr);
			//
			// In case of error, uninitialize COM.
			//
			if (selfStartedCom)
			{
				CoUninitialize();
			}
		}
	}

	TRACE_EXIT();
	return hr;
}

//
// Function:  HrReleaseINetCfg
//
// Purpose:   Get a reference to INetCfg.
//
// Arguments:
//    pnc   		[in] Reference to INetCfg to release.
//    fHasWriteLock [in] If TRUE, reference was held with write lock.
//
// Returns:   S_OK on sucess, otherwise an error code.
//
// Notes:
//

HRESULT HrReleaseINetCfg(IN INetCfg* pnc, IN BOOL fHasWriteLock)
{
	TRACE_ENTER();

	INetCfgLock* pncLock = NULL;
	HRESULT hr = S_OK;

	//
	// Uninitialize INetCfg
	//

	hr = pnc->Uninitialize();

	//
	// If write lock is present, unlock it
	//

	if (hr == S_OK && fHasWriteLock)
	{
		//
		// Get the locking reference
		//

		hr = pnc->QueryInterface(IID_INetCfgLock, (LPVOID *)&pncLock);
		if (hr == S_OK)
		{
			hr = pncLock->ReleaseWriteLock();
			ReleaseRef(pncLock);
		}
	}

	ReleaseRef(pnc);

	//
	// Uninitialize COM.
	//

	CoUninitialize();

	TRACE_EXIT();
	return hr;
}

//
// Function:  HrInstallNetComponent
//
// Purpose:   Install a network component(protocols, clients and services)
//  		  given its INF file.
//
// Arguments:
//    pnc   		   [in] Reference to INetCfg.
//    lpszComponentId  [in] PnpID of the network component.
//    pguidClass	   [in] Class GUID of the network component.
//    lpszInfFullPath  [in] INF file to install from.
//
// Returns:   S_OK on sucess, otherwise an error code.
//
// Notes:
//

HRESULT HrInstallNetComponent(IN INetCfg* pnc, IN const GUID* pguidClass, IN LPCTSTR lpszInfFullPath)
{
	TRACE_ENTER();

	DWORD dwError;
	HRESULT hr = S_OK;
	TCHAR szDrive[_MAX_DRIVE];
	TCHAR szDir[_MAX_DIR];
	TCHAR szDirWithDrive[_MAX_DRIVE + _MAX_DIR];

	//
	// If full path to INF has been specified, the INF
	// needs to be copied using Setup API to ensure that any other files
	// that the primary INF copies will be correctly found by Setup API
	//
	if (lpszInfFullPath)
	{
		//
		// Get the path where the INF file is.
		//
		_tsplitpath_s(lpszInfFullPath, szDrive, _MAX_DRIVE, szDir, _MAX_DIR, NULL, 0, NULL, 0);

		_tcscpy_s(szDirWithDrive, _MAX_DRIVE + _MAX_DIR, szDrive);
		_tcscat_s(szDirWithDrive, _MAX_DRIVE + _MAX_DIR, szDir);

		//
		// Copy the Service INF file to the \Windows\Inf Folder
		//
		if (!SetupCopyOEMInfW(lpszInfFullPath, szDirWithDrive, // Other files are in the
			// same dir. as primary INF
			SPOST_PATH,    // First param is path to INF
			0,  		   // Default copy style
			NULL,   	   // Name of the INF after
			// it's copied to %windir%\inf
			0,  		   // Max buf. size for the above
			NULL,   	   // Required size if non-null
			NULL)   	   // Optionally get the filename
			// part of Inf name after it is copied.
		   )
		{
			dwError = GetLastError();
			hr = HRESULT_FROM_WIN32(dwError);
			TRACE_PRINT1("SetupCopyOEMInfW: error, errCode = 0x%08x.", hr);
		}
	}

	if (S_OK == hr)
	{
		//
		// Install the network component.
		//
		TRACE_PRINT1("bWiFiService = %d.", bWiFiService);
		TRACE_PRINT1("HrInstallComponent: executing, szComponentId = %s.", NDISLWF_SERVICE_PNP_DEVICE_ID);
		hr = HrInstallComponent(pnc, NDISLWF_SERVICE_PNP_DEVICE_ID, pguidClass);

		if (hr == S_OK)
		{
			if (bWiFiService)
			{
				TRACE_PRINT1("HrInstallComponent: executing, szComponentId = %s.", NDISLWF_SERVICE_PNP_DEVICE_ID_WIFI);
				hr = HrInstallComponent(pnc, NDISLWF_SERVICE_PNP_DEVICE_ID_WIFI, pguidClass);

				if (hr == S_OK)
				{
					//
					// On success, apply the changes
					//
					hr = pnc->Apply();
					if (hr != S_OK)
					{
						TRACE_PRINT1("INetCfg::Apply: error, errCode = 0x%08x.", hr);
					}
				}
				else
				{
					TRACE_PRINT1("HrInstallComponent: error, szComponentId = %s.", NDISLWF_SERVICE_PNP_DEVICE_ID_WIFI);
					// at least install the first service
					hr = pnc->Apply();
					if (hr != S_OK)
					{
						TRACE_PRINT1("INetCfg::Apply: error, errCode = 0x%08x.", hr);
					}
				}
			}
			else
			{
				//
				// On success, apply the changes
				//
				hr = pnc->Apply();
				if (hr != S_OK)
				{
					TRACE_PRINT1("INetCfg::Apply: error, errCode = 0x%08x.", hr);
				}
			}
		}
		else
		{
			TRACE_PRINT1("HrInstallComponent: error, szComponentId = %s.", NDISLWF_SERVICE_PNP_DEVICE_ID);
		}
	}

	TRACE_EXIT();
	return hr;
}

//
// Function:  HrInstallComponent
//
// Purpose:   Install a network component(protocols, clients and services)
//  		  given its INF file.
// Arguments:
//    pnc   		   [in] Reference to INetCfg.
//    lpszComponentId  [in] PnpID of the network component.
//    pguidClass	   [in] Class GUID of the network component.
//
// Returns:   S_OK on sucess, otherwise an error code.
//
// Notes:
//

HRESULT HrInstallComponent(IN INetCfg* pnc, IN LPCTSTR szComponentId, IN const GUID* pguidClass)
{
	TRACE_ENTER();

	INetCfgClassSetup* pncClassSetup = NULL;
	INetCfgComponent* pncc = NULL;
	OBO_TOKEN OboToken;
	HRESULT hr = S_OK;

	//
	// OBO_TOKEN specifies on whose behalf this
	// component is being installed.
	// Set it to OBO_USER so that szComponentId will be installed
	// on behalf of the user.
	//

	ZeroMemory(&OboToken, sizeof(OboToken));
	OboToken.Type = OBO_USER;

	//
	// Get component's setup class reference.
	//
	hr = pnc->QueryNetCfgClass(pguidClass, IID_INetCfgClassSetup, (void**)&pncClassSetup);

	if (hr == S_OK)
	{
		hr = pncClassSetup->Install(szComponentId, &OboToken, 0, 0,  	 // Upgrade from build number.
			NULL,    // Answerfile name
			NULL,    // Answerfile section name
			&pncc); // Reference after the component
		if (S_OK == hr)
		{
			// is installed.

			//
			// we don't need to use pncc (INetCfgComponent), release it
			//

			ReleaseRef(pncc);
		}
		else
		{
			TRACE_PRINT1("INetCfgClassSetup::Install: error, szComponentId = %s.", szComponentId);
		}

		ReleaseRef(pncClassSetup);
	}
	else
	{
		TRACE_PRINT1("INetCfg::QueryNetCfgClass: error, szComponentId = %s.", szComponentId);
	}

	TRACE_EXIT();
	return hr;
}

//
// Function:  HrUninstallNetComponent
//
// Purpose:   Uninstall a network component(protocols, clients and services).
//
// Arguments:
//    pnc   		[in] Reference to INetCfg.
//    szComponentId [in] PnpID of the network component to uninstall.
//
// Returns:   S_OK on sucess, otherwise an error code.
//
// Notes:
//

HRESULT HrUninstallNetComponent(IN INetCfg* pnc, IN LPCTSTR szComponentId)
{
	INetCfgComponent* pncc;
	INetCfgClass* pncClass;
	INetCfgClassSetup* pncClassSetup;
	GUID guidClass;
	OBO_TOKEN obo;
	HRESULT hr;

	TRACE_ENTER();

	//
	// Get a reference to the network component to uninstall.
	//
	hr = pnc->FindComponent(szComponentId, &pncc);

	if (hr == S_OK)
	{
		//
		// Get the class GUID.
		//
		hr = pncc->GetClassGuid(&guidClass);

		if (hr == S_OK)
		{
			//
			// Get a reference to component's class.
			//

			hr = pnc->QueryNetCfgClass(&guidClass, IID_INetCfgClass, (PVOID *)&pncClass);
			if (hr == S_OK)
			{
				//
				// Get the setup interface.
				//

				hr = pncClass->QueryInterface(IID_INetCfgClassSetup, (LPVOID *)&pncClassSetup);

				if (hr == S_OK)
				{
					//
					// Uninstall the component.
					//

					ZeroMemory(&obo, sizeof(OBO_TOKEN));

					obo.Type = OBO_USER;

					hr = pncClassSetup->DeInstall(pncc, &obo, NULL);
					if ((hr == S_OK) || (hr == NETCFG_S_REBOOT))
					{
						hr = pnc->Apply();

						if ((hr != S_OK) && (hr != NETCFG_S_REBOOT))
						{
							ErrMsg(hr, _T("Couldn't apply the changes after uninstalling %s."), szComponentId);
						}
					}
					else
					{
						ErrMsg(hr, _T("Failed to uninstall %s."), szComponentId);
					}

					ReleaseRef(pncClassSetup);
				}
				else
				{
					ErrMsg(hr, _T("Couldn't get an interface to setup class."));
				}

				ReleaseRef(pncClass);
			}
			else
			{
				ErrMsg(hr, _T("Couldn't get a pointer to class interface of %s."), szComponentId);
			}
		}
		else
		{
			ErrMsg(hr, _T("Couldn't get the class guid of %s."), szComponentId);
		}

		ReleaseRef(pncc);
	}
	else
	{
		ErrMsg(hr, _T("Couldn't get an interface pointer to %s."), szComponentId);
	}

	TRACE_EXIT();
	return hr;
}

//
// Function:  ReleaseRef
//
// Purpose:   Release reference.
//
// Arguments:
//    punk     [in]  IUnknown reference to release.
//
// Returns:   Reference count.
//
// Notes:
//

VOID ReleaseRef(IN IUnknown* punk)
{
	if (punk)
	{
		punk->Release();
	}

	return;
}

BOOL RestartAllBindings(INetCfg *netcfg, PCWSTR szComponentId)
{
	HRESULT hr;
	CComPtr<INetCfgComponent> comp;
	CComPtr<INetCfgComponentBindings> bindings;

	TRACE_ENTER();

	hr = netcfg->FindComponent(szComponentId, &comp);
	if (FAILED(hr) || !comp)
	{
		TRACE_PRINT1("INetCfg::FindComponent: error, hr = 0x%08x.", hr);
		TRACE_EXIT();
		return FALSE;
	}

	hr = comp.QueryInterface(&bindings);
	if (FAILED(hr))
	{
		TRACE_PRINT1("INetCfgComponent::QueryInterface: error, hr = 0x%08x.", hr);
		TRACE_EXIT();
		return FALSE;
	}

	CComPtr<IEnumNetCfgBindingPath> enumerator;
	hr = bindings->EnumBindingPaths(EBP_BELOW, &enumerator);
	if (FAILED(hr))
	{
		TRACE_PRINT1("INetCfgComponentBindings::EnumBindingPaths: error, hr = 0x%08x.", hr);
		TRACE_EXIT();
		return FALSE;
	}

	// Loop over all bindings that involve this component
	while (true)
	{
		CComPtr<INetCfgBindingPath> path;
		hr = enumerator->Next(1, &path, NULL);
		if (hr == S_FALSE)
		{
			// Reached end of list; quit.
			break;
		}
		if (FAILED(hr))
		{
			TRACE_PRINT1("IEnumNetCfgBindingPath::Next: error, hr = 0x%08x.", hr);
			TRACE_EXIT();
			return FALSE;
		}

		PWSTR token = NULL;
		hr = path->GetPathToken(&token);
		if (FAILED(hr))
		{
			TRACE_PRINT1("INetCfgBindingPath::GetPathToken: error, hr = 0x%08x.", hr);
			TRACE_EXIT();
			continue;
		}

		TRACE_PRINT1("Found binding %ws.", token);
		CoTaskMemFree(token);

		hr = path->IsEnabled();
		if (FAILED(hr))
		{
			TRACE_PRINT1("INetCfgBindingPath::IsEnabled: error, hr = 0x%08x.", hr);
			TRACE_EXIT();
			continue;
		}

		if (S_FALSE == hr)
		{
			TRACE_PRINT("Path is already disabled.  Skipping over it.");
			TRACE_EXIT();
			continue;
		}

		// Disable

		hr = path->Enable(FALSE);
		if (FAILED(hr))
		{
			TRACE_PRINT1("INetCfgBindingPath::Enable(FALSE): error, hr = 0x%08x.", hr);
			TRACE_EXIT();
			continue;
		}

		hr = netcfg->Apply();
		if (FAILED(hr))
		{
			TRACE_PRINT1("INetCfg::Apply: error, hr = 0x%08x.", hr);
			TRACE_EXIT();
			return FALSE;
		}

		TRACE_PRINT("Path disabled.");

		// Enable

		hr = path->Enable(TRUE);
		if (FAILED(hr))
		{
			TRACE_PRINT1("INetCfgBindingPath::Enable(TRUE): error, hr = 0x%08x.", hr);
			TRACE_EXIT();
			return FALSE;
		}

		hr = netcfg->Apply();
		if (FAILED(hr))
		{
			TRACE_PRINT1("INetCfg::Apply: error, hr = 0x%08x.", hr);
			TRACE_EXIT();
			return FALSE;
		}

		TRACE_PRINT("Path enabled.");
	}

	TRACE_EXIT();
	return TRUE;
}

BOOL ConnectToNetCfg(PCWSTR lpszPnpID, LPCTSTR lpszAppName)
{
	HRESULT hr;
	CComPtr<INetCfg> netcfg;
	CComPtr<INetCfgLock> lock;

	TRACE_ENTER();

	// Before we can get started, we need to do some initialization work.

	hr = netcfg.CoCreateInstance(CLSID_CNetCfg);
	if (FAILED(hr))
	{
		TRACE_PRINT1("CoCreateInstance(CLSID_CNetCfg): error, hr = 0x%08x.", hr);
		TRACE_EXIT();
		return FALSE;
	}

	hr = netcfg.QueryInterface(&lock);
	if (FAILED(hr))
	{
		TRACE_PRINT1("INetCfg::QueryInterface: error, hr = 0x%08x.", hr);
		TRACE_EXIT();
		return FALSE;
	}

	// Note that this call can block.
	hr = lock->AcquireWriteLock(INFINITE, lpszAppName, NULL);
	if (FAILED(hr))
	{
		TRACE_PRINT1("INetCfgLock::AcquireWriteLock: error, hr = 0x%08x.", hr);
		TRACE_EXIT();
		return FALSE;
	}

	hr = netcfg->Initialize(NULL);
	if (FAILED(hr))
	{
		TRACE_PRINT1("INetCfg::Initialize: error, hr = 0x%08x.", hr);
		TRACE_EXIT();
		return FALSE;
	}

	const BOOL ok = RestartAllBindings(netcfg.p, lpszPnpID);

	hr = netcfg->Uninitialize();
	if (FAILED(hr))
	{
		TRACE_PRINT1("INetCfg::Uninitialize: error, hr = 0x%08x.", hr);
	}

	hr = lock->ReleaseWriteLock();
	if (FAILED(hr))
	{
		TRACE_PRINT1("INetCfgLock::ReleaseWriteLock: error, hr = 0x%08x.", hr);
	}

	TRACE_EXIT();
	return ok;
}

```

`packetWin7/NPFInstall/NPFInstall/netcfgapi.h`:

```h
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:   	N E T C F G A P I . H
//
//  Contents:   Functions Prototypes
//
//  Notes:  	
//
//  Author: 	Alok Sinha    15-May-01
//
//----------------------------------------------------------------------------

#ifndef _NETCFGAPI_H_INCLUDED

#define _NETCFGAPI_H_INCLUDED

#include <iostream>
#include <tchar.h>


#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <wchar.h>
#include <netcfgx.h>
#include <netcfgn.h>
#include <setupapi.h>
#include <devguid.h>
#include <objbase.h>
#include <atlbase.h>

#define LOCK_TIME_OUT     5000

HRESULT HrGetINetCfg(IN BOOL fGetWriteLock, IN LPCTSTR lpszAppName, OUT INetCfg** ppnc, OUT LPTSTR* lpszLockedBy);

HRESULT HrReleaseINetCfg(INetCfg* pnc, BOOL fHasWriteLock);

HRESULT HrInstallNetComponent(IN INetCfg* pnc, IN const GUID* pguildClass, IN LPCTSTR lpszInfFullPath);

HRESULT HrInstallComponent(IN INetCfg* pnc, IN LPCTSTR szComponentId, IN const GUID* pguidClass);

HRESULT HrUninstallNetComponent(IN INetCfg* pnc, IN LPCTSTR szComponentId);

VOID ReleaseRef(IUnknown* punk);

BOOL RestartAllBindings(INetCfg *netcfg, PCWSTR szComponentId);

BOOL ConnectToNetCfg(PCWSTR lpszPnpID, LPCTSTR lpszAppName);

#endif

```

`packetWin7/NPFInstall/NPFInstall/rc_ids.h`:

```h
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    rc_ids.h

Abstract:

    Header for devcon resources

--*/

#define IDS_ENABLED         3000
#define IDS_ENABLED_REBOOT  3001
#define IDS_ENABLE_FAILED   3002
#define IDS_DISABLED        3003
#define IDS_DISABLED_REBOOT 3004
#define IDS_DISABLE_FAILED  3005
#define IDS_RESTARTED       3006
#define IDS_REQUIRES_REBOOT 3007
#define IDS_RESTART_FAILED  3008
#define IDS_REMOVED         3009
#define IDS_REMOVED_REBOOT  3010
#define IDS_REMOVE_FAILED   3011



```

`packetWin7/NPFInstall/NPFInstall/version.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winresrc.h"
#ifndef IDC_STATIC
#define IDC_STATIC (-1)
#endif

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// Neutral resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_NEU)
#ifdef _WIN32
LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL
#pragma code_page(1252)
#endif //_WIN32

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""afxres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "#include ""version.rc2""\r\n"
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

#endif    // Neutral resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
#include "version.rc2"

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`packetWin7/NPFInstall/NPFInstall/version.rc2`:

```rc2
//
// version.rc2 - resources Microsoft Visual C++ does not edit directly
//

#ifdef APSTUDIO_INVOKED
	#error this file is not editable by Microsoft Visual C++
#endif //APSTUDIO_INVOKED


#include "..\..\..\version.h"

VS_VERSION_INFO VERSIONINFO
 FILEVERSION		WINPCAP_MAJOR,WINPCAP_MINOR,WINPCAP_REV,WINPCAP_BUILD
 PRODUCTVERSION		WINPCAP_MAJOR,WINPCAP_MINOR,WINPCAP_REV,WINPCAP_BUILD
 FILEFLAGSMASK VS_FFI_FILEFLAGSMASK
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS_NT_WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "000004b0"
        BEGIN
			VALUE "CompanyName",       WINPCAP_COMPANY_NAME
			VALUE "FileDescription",   "A LWF & WFP driver installation tool"
			VALUE "FileVersion",       WINPCAP_VER_STRING
			VALUE "InternalName",      "NPFInstall.exe"
			VALUE "LegalCopyright",    WINPCAP_COPYRIGHT_STRING
			VALUE "LegalTrademarks",   ""
			VALUE "OriginalFilename",  "NPFInstall.exe"
			VALUE "ProductName",       WINPCAP_PRODUCT_NAME
			VALUE "ProductVersion",    WINPCAP_VER_STRING
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x0, 1200
    END
END

```

`packetWin7/WlanHelper/WlanHelper.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 2013
VisualStudioVersion = 12.0.40629.0
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "WlanHelper", "WlanHelper\WlanHelper.vcxproj", "{044CB4DC-827D-4134-B14B-DE114E884BB9}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Debug|x64 = Debug|x64
		OEM Release|Win32 = OEM Release|Win32
		OEM Release|x64 = OEM Release|x64
		Release|Win32 = Release|Win32
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Debug|Win32.ActiveCfg = Debug|Win32
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Debug|Win32.Build.0 = Debug|Win32
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Debug|x64.ActiveCfg = Debug|x64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Debug|x64.Build.0 = Debug|x64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.OEM Release|Win32.ActiveCfg = OEM Release|Win32
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.OEM Release|Win32.Build.0 = OEM Release|Win32
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.OEM Release|x64.ActiveCfg = OEM Release|x64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.OEM Release|x64.Build.0 = OEM Release|x64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Release|Win32.ActiveCfg = Release|Win32
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Release|Win32.Build.0 = Release|Win32
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Release|x64.ActiveCfg = Release|x64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`packetWin7/WlanHelper/WlanHelper/Tool.cpp`:

```cpp
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/

#include "..\..\..\Common\Packet32.h"

#include <windot11.h>
#include <tchar.h>
#include <algorithm>
#include "Tool.h"

#include "../../../Common/WpcapNames.h"
// "\\Device\\NPF_{%s}" or "\\Device\\NPCAP_{%s}"
#define NPF_DRIVER_FORMAT_STR	"\\Device\\" NPF_DEVICE_NAMES_PREFIX "{%s}"

vector<tstring> g_strAdapterNames;
vector<tstring> g_strAdapterGUIDs;

vector<tstring> g_nstrPhyTypes;

tstring OperationMode2String(ULONG OperationMode)
{
	if (OperationMode == DOT11_OPERATION_MODE_EXTENSIBLE_AP)
	{
		return _T("master");
	}
	else if (OperationMode == DOT11_OPERATION_MODE_EXTENSIBLE_STATION)
	{
		return _T("managed");
	}
	else if (OperationMode == DOT11_OPERATION_MODE_NETWORK_MONITOR)
	{
		return _T("monitor");
	}
	else if (OperationMode == DOT11_OPERATION_MODE_WFD_DEVICE)
	{
		return _T("wfd_device");
	}
	else if (OperationMode == DOT11_OPERATION_MODE_WFD_GROUP_OWNER)
	{
		return _T("wfd_owner");
	}
	else if (OperationMode == DOT11_OPERATION_MODE_WFD_CLIENT)
	{
		return _T("wfd_client");
	}
	else
	{
		return _T("unknown");
	}
}

ULONG String2OperationMode(tstring strOperationMode)
{
	if (strOperationMode == _T("master"))
	{
		return DOT11_OPERATION_MODE_EXTENSIBLE_AP;
	}
	else if (strOperationMode == _T("managed"))
	{
		return DOT11_OPERATION_MODE_EXTENSIBLE_STATION;
	}
	else if (strOperationMode == _T("monitor"))
	{
		return DOT11_OPERATION_MODE_NETWORK_MONITOR;
	}
	else if (strOperationMode == _T("wfd_device"))
	{
		return DOT11_OPERATION_MODE_WFD_DEVICE;
	}
	else if (strOperationMode == _T("wfd_owner"))
	{
		return DOT11_OPERATION_MODE_WFD_GROUP_OWNER;
	}
	else if (strOperationMode == _T("wfd_client"))
	{
		return DOT11_OPERATION_MODE_WFD_CLIENT;
	}
	else
	{
		return DOT11_OPERATION_MODE_UNKNOWN;
	}
}

tstring PhyType2String(ULONG PhyType)
{
	if (PhyType == dot11_phy_type_unknown)
	{
		return _T("unknown or any");
	}
	else if (PhyType == dot11_phy_type_fhss)
	{
		return _T("fhss");
	}
	else if (PhyType == dot11_phy_type_dsss)
	{
		return _T("dsss");
	}
	else if (PhyType == dot11_phy_type_irbaseband)
	{
		return _T("irbaseband");
	}
	else if (PhyType == dot11_phy_type_ofdm)
	{
		return _T("ofdm");
	}
	else if (PhyType == dot11_phy_type_hrdsss)
	{
		return _T("hrdsss");
	}
	else if (PhyType == dot11_phy_type_erp)
	{
		return _T("erp");
	}
	else if (PhyType == dot11_phy_type_ht)
	{
		return _T("ht");
	}
	else if (PhyType == dot11_phy_type_vht)
	{
		return _T("vht");
	}
	else if (dot11_phy_type_IHV_start <= PhyType && PhyType <= dot11_phy_type_IHV_end)
	{
		return _T("ihv (") + itos(PhyType) + _T(")");
	}
	else
	{
		return _T("");
	}
}

ULONG String2PhyType(tstring strPhyType)
{
	if (strPhyType == _T("fhss"))
	{
		return dot11_phy_type_fhss;
	}
	else if (strPhyType == _T("dsss"))
	{
		return dot11_phy_type_dsss;
	}
	else if (strPhyType == _T("irbaseband"))
	{
		return dot11_phy_type_irbaseband;
	}
	else if (strPhyType == _T("ofdm"))
	{
		return dot11_phy_type_ofdm;
	}
	else if (strPhyType == _T("hrdsss"))
	{
		return dot11_phy_type_hrdsss;
	}
	else if (strPhyType == _T("erp"))
	{
		return dot11_phy_type_erp;
	}
	else if (strPhyType == _T("ht"))
	{
		return dot11_phy_type_ht;
	}
	else if (strPhyType == _T("vht"))
	{
		return dot11_phy_type_vht;
	}
	else if (strPhyType.size() > 5 && strPhyType.substr(0, 5) == _T("ihv ("))
	{
		ULONG ulPhyType;
		_stscanf_s(strPhyType.c_str(), _T("ihv (%d)"), &ulPhyType);
		if (dot11_phy_type_IHV_start <= ulPhyType && ulPhyType <= dot11_phy_type_IHV_end)
		{
			return ulPhyType;
		}
		else
		{
			return dot11_phy_type_unknown;
		}
	}
	else
	{
		return dot11_phy_type_unknown;
	}
}

// NDIS_STATUS definitions returned by NdisOidRequest() from ndis.h in WDK.
#define NDIS_STATUS_NOT_RECOGNIZED              ((NDIS_STATUS)0x00010001L)
#define NDIS_STATUS_NOT_ACCEPTED                ((NDIS_STATUS)0x00010003L)
#define NDIS_STATUS_CLOSING                     ((NDIS_STATUS)0xC0010002L)
#define NDIS_STATUS_RESET_IN_PROGRESS           ((NDIS_STATUS)0xC001000DL)
#define NDIS_STATUS_CLOSING_INDICATING          ((NDIS_STATUS)0xC001000EL)
#define NDIS_STATUS_INVALID_LENGTH              ((NDIS_STATUS)0xC0010014L)
#define NDIS_STATUS_INVALID_DATA                ((NDIS_STATUS)0xC0010015L)
#define NDIS_STATUS_BUFFER_TOO_SHORT            ((NDIS_STATUS)0xC0010016L)
#define NDIS_STATUS_INVALID_OID                 ((NDIS_STATUS)0xC0010017L)

// The error messages are retrieved from: https://msdn.microsoft.com/en-us/library/windows/hardware/ff563710%28v=vs.85%29.aspx
tstring NdisStatus2Message(DWORD dwStatus)
{
	if (dwStatus == NDIS_STATUS_NOT_RECOGNIZED)
	{
		return _T("The underlying driver does not support the requested operation.");
	}
	else if (dwStatus == NDIS_STATUS_NOT_ACCEPTED)
	{
		return _T("The underlying driver attempted the requested operation, usually a set on a NIC, but it failed. For example, an attempt to set too many multicast addresses might cause the return of this value.");
	}
	else if (dwStatus == NDIS_STATUS_CLOSING || dwStatus == NDIS_STATUS_CLOSING_INDICATING)
	{
		return _T("The underlying driver failed the requested operation because a close operation is in progress.");
	}
	else if (dwStatus == NDIS_STATUS_RESET_IN_PROGRESS)
	{
		return _T("The underlying miniport driver cannot satisfy the request at this time because it is currently resetting the affected NIC. The caller's ProtocolStatusEx function was or will be called with NDIS_STATUS_RESET_START to indicate that a reset is in progress. This return value does not necessarily indicate that the same request, submitted later, will be failed for the same reason.");
	}
	else if (dwStatus == NDIS_STATUS_INVALID_LENGTH || dwStatus == NDIS_STATUS_BUFFER_TOO_SHORT)
	{
		return _T("The value specified in the InformationBufferLength member of the NDIS_OID_REQUEST-structured buffer at OidRequest does not match the requirements for the given OID_XXX code. If the information buffer is too small, the BytesNeeded member contains the correct value for InformationBufferLength on return from NdisOidRequest.");
	}
	else if (dwStatus == NDIS_STATUS_INVALID_DATA)
	{
		return _T("The data supplied at InformationBuffer in the given NDIS_OID_REQUEST structure is invalid for the given OID_XXX code.");
	}
	else if (dwStatus == NDIS_STATUS_INVALID_OID)
	{
		return _T("The OID_XXX code specified in the Oid member of the NDIS_OID_REQUEST-structured buffer at OidRequest is invalid or unsupported by the underlying driver.");
	}
	else
	{
		return _T("");
	}
}

tstring printArray(vector<tstring> nstr)
{
	tstring strResult;
	for (size_t i = 0; i < nstr.size(); i++)
	{
		if (i != 0)
		{
			strResult += _T(", ");
		}
		strResult += nstr[i];
	}
	return strResult;
}

tstring strToLower(const tstring &str)
{
	tstring strTmp = str;
	transform(strTmp.begin(), strTmp.end(), strTmp.begin(), tolower);
	return strTmp;
}

bool compareNoCase(const tstring &strA, const tstring &strB)
{
	tstring str1 = strToLower(strA);
	tstring str2 = strToLower(strB);
	return (str1 == str2);
}

BOOL string2wstring(const std::string &str, std::wstring &wstr)
{
	int nLen = (int)str.length();
	wstr.resize(nLen, L' ');

	int nResult = MultiByteToWideChar(CP_ACP, 0, (LPCSTR)str.c_str(), nLen, (LPWSTR)wstr.c_str(), nLen);

	if (nResult == 0)
	{
		return FALSE;
	}

	return TRUE;
}

BOOL wstring2string(const std::wstring &wstr, std::string &str)
{
	int nLen = (int)wstr.length();
	str.resize(nLen, ' ');

	int nResult = WideCharToMultiByte(CP_ACP, 0, (LPCWSTR)wstr.c_str(), nLen, (LPSTR)str.c_str(), nLen, NULL, NULL);

	if (nResult == 0)
	{
		return FALSE;
	}

	return TRUE;
}

wstring tstring2wstring(tstring &str)
{
#ifdef UNICODE
	return str;
#else
	wstring wstr;
	string2wstring(str, wstr);
	return wstr;
#endif
}

string tstring2string(tstring &str)
{
#ifdef UNICODE
	string astr;
	wstring2string(str, astr);
	return astr;
#else
	return str;
#endif
}

tstring itos(int i)
{
	TCHAR buf[_MAX_ITOSTR_BASE10_COUNT];
	_itot_s(i, buf, _countof(buf), 10);
	tstring res = buf;
	return res;
}

tstring executeCommand(LPCTSTR cmd)
{
	TCHAR buffer[128];
	tstring result;

	FILE* pipe = _tpopen(cmd, _T("r"));
	if (!pipe)
	{
		return _T("");
	}

	while (!feof(pipe))
	{
		if (_fgetts(buffer, 128, pipe) != NULL)
			result += buffer;
	}
	_pclose(pipe);

	return result;
}

// There is 1 interface on the system:
// 
//     Name                   : Wi-Fi
//     Description            : Qualcomm Atheros AR9485WB-EG Wireless Network Adapter
//     GUID                   : 42dfd47a-2764-43ac-b58e-3df569c447da
//     Physical address       : a4:db:30:d9:3a:9a
//     State                  : connected
//     SSID                   : LUO-PC_Network
//     BSSID                  : d8:15:0d:72:8c:18
//     Network type           : Infrastructure
//     Radio type             : 802.11n
//     Authentication         : WPA2-Personal
//     Cipher                 : CCMP
//     Connection mode        : Auto Connect
//     Channel                : 1
//     Receive rate (Mbps)    : 150
//     Transmit rate (Mbps)   : 150
//     Signal                 : 100%
//     Profile                : LUO-PC_Network
// 
//     Hosted network status  : Not available

void initAdapterList()
{
	size_t iStart = -1;
	size_t iEnd;
	tstring strAdapterName;
	tstring strGUID;

	tstring strOutput = executeCommand(_T("netsh wlan show interfaces"));
	
	iStart = strOutput.find(_T("\n\n"), iStart + 1);
	if (iStart == tstring::npos) return;
	while ((iStart = strOutput.find(_T(": "), iStart + 1)) != tstring::npos)
	{
		iStart += 2;
		iEnd = strOutput.find(_T('\n'), iStart + 1);
		if (iEnd == tstring::npos) return;
		strAdapterName = strOutput.substr(iStart, iEnd - iStart);
		
		iStart = strOutput.find(_T(": "), iStart + 1);
		if (iStart == tstring::npos) return;
		iStart = strOutput.find(_T(": "), iStart + 1);
		if (iStart == tstring::npos) return;
		iStart += 2;
		iEnd = strOutput.find(_T('\n'), iStart + 1);
		if (iEnd == tstring::npos) return;
		strGUID = strOutput.substr(iStart, iEnd - iStart);

		g_strAdapterNames.push_back(strAdapterName);
		g_strAdapterGUIDs.push_back(strGUID);

		iStart = strOutput.find(_T("\n\n"), iStart + 1);
		if (iStart == tstring::npos) return;
	}
}

tstring getGuidFromAdapterName(tstring strAdapterName)
{
	if (g_strAdapterNames.size() == 0)
	{
		initAdapterList();
	}

	for (size_t i = 0; i < g_strAdapterNames.size(); i++)
	{
		if (compareNoCase(g_strAdapterNames[i], strAdapterName))
		{
			return g_strAdapterGUIDs[i];
		}
	}

	return _T("");
}

tstring getAdapterNameFromGuid(tstring strGuid)
{
	if (g_strAdapterGUIDs.size() == 0)
	{
		initAdapterList();
	}

	for (size_t i = 0; i < g_strAdapterGUIDs.size(); i++)
	{
		if (compareNoCase(g_strAdapterGUIDs[i], strGuid))
		{
			return g_strAdapterNames[i];
		}
	}

	return _T("");
}

HINSTANCE hinstLib = NULL;
typedef LPADAPTER (*MY_PACKETOPENADAPTER) (PCHAR AdapterName);
typedef BOOLEAN(*MY_PACKETREQUEST) (LPADAPTER  AdapterObject, BOOLEAN Set, PPACKET_OID_DATA  OidData);
typedef VOID(*MY_PACKETCLOSEADAPTER) (LPADAPTER lpAdapter);
typedef int(*MY_PACKETGETMONITORMODE) (PCHAR AdapterName);
MY_PACKETOPENADAPTER My_PacketOpenAdapter = NULL;
MY_PACKETREQUEST My_PacketRequest = NULL;
MY_PACKETCLOSEADAPTER My_PacketCloseAdapter = NULL;
MY_PACKETGETMONITORMODE My_PacketGetMonitorMode = NULL;

BOOL initPacketFunctions()
{
	BOOL bRet;
	
	// Get a handle to the packet DLL module.
	hinstLib = LoadLibrary(TEXT("packet.dll"));

	// If the handle is valid, try to get the function address.  
	if (hinstLib != NULL)
	{
		My_PacketOpenAdapter = (MY_PACKETOPENADAPTER)GetProcAddress(hinstLib, "PacketOpenAdapter");
		My_PacketRequest = (MY_PACKETREQUEST)GetProcAddress(hinstLib, "PacketRequest");
		My_PacketCloseAdapter = (MY_PACKETCLOSEADAPTER)GetProcAddress(hinstLib, "PacketCloseAdapter");
		My_PacketGetMonitorMode = (MY_PACKETGETMONITORMODE)GetProcAddress(hinstLib, "PacketGetMonitorMode");
		// If the function address is valid, call the function.  

		if (My_PacketOpenAdapter != NULL && My_PacketRequest != NULL && My_PacketCloseAdapter != NULL && My_PacketGetMonitorMode != NULL)
		{
			bRet = TRUE;
		}
		else
		{
			bRet = FALSE;
		}

		
	}
	else
	{
		bRet = FALSE;
	}

	return bRet;
}

void freePacketFunctions()
{
	if (hinstLib)
	{
		// Free the DLL module.  
		FreeLibrary(hinstLib);
		My_PacketOpenAdapter = NULL;
		My_PacketRequest = NULL;
		My_PacketCloseAdapter = NULL;
		My_PacketGetMonitorMode = NULL;
	}
}

BOOL makeOIDRequest(tstring strAdapterGUID, ULONG iOid, BOOL bSet, PVOID pData, ULONG ulDataSize)
{
	BOOL Status;

	if (!initPacketFunctions())
	{
		_tprintf(_T("Error: makeOIDRequest::initPacketFunctions error\n"));
		Status = FALSE;
		goto makeOIDRequest_Exit3;
	}

	if (strAdapterGUID == _T(""))
	{
		_tprintf(_T("Error: makeOIDRequest::strAdapterGUID error, the adapter name is incorrect.\n"));
		Status = FALSE;
		goto makeOIDRequest_Exit3;
	}

	char strAdapterName[256];
	sprintf_s(strAdapterName, 256, NPF_DRIVER_FORMAT_STR, tstring2string(strAdapterGUID).c_str());
	// Need to call PacketGetMonitorMode otherwise adapter can't be opened via WiFi.
	My_PacketGetMonitorMode(strAdapterName);

	LPADAPTER pAdapter = My_PacketOpenAdapter(strAdapterName);
	if (pAdapter == NULL)
	{
		_tprintf(_T("Error: makeOIDRequest::My_PacketOpenAdapter(%S) error %#x\n(to use this function, you need to check the \"Support raw 802.11 traffic\" option when installing Npcap)\n"),
			strAdapterName, GetLastError());
		Status = FALSE;
		goto makeOIDRequest_Exit2;
	}

	
	ULONG IoCtlBufferLength = (sizeof(PACKET_OID_DATA) + ulDataSize - 1);
	PPACKET_OID_DATA OidData;
	OidData = (PPACKET_OID_DATA)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, IoCtlBufferLength);
	if (OidData == NULL)
	{
		_tprintf(_T("Error: makeOIDRequest::HeapAlloc error\n"));
		Status = FALSE;
		goto makeOIDRequest_Exit1;
	}

	OidData->Oid = iOid;
	OidData->Length = ulDataSize;

	if (bSet)
	{
		CopyMemory(OidData->Data, pData, ulDataSize);
	}
	Status = My_PacketRequest(pAdapter, bSet, OidData);
	if (!Status)
	{
		// Convert our NTSTATUS from a customer-defined value to a Microsoft-defined value.
		// Refer to: https://msdn.microsoft.com/en-us/library/windows/hardware/ff543026(v=vs.85).aspx
		DWORD dwErrorCode = GetLastError() & ~(1 << 29);

		LPTSTR strErrorText = NULL;
		HMODULE hModule = LoadLibrary(_T("NTDLL.DLL"));
		if (hModule)
		{
			FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_FROM_HMODULE,
				hModule, dwErrorCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&strErrorText, 0, NULL);
			if (strErrorText != NULL)
			{
				if (strErrorText[_tcslen(strErrorText) - 2] == _T('\r') && strErrorText[_tcslen(strErrorText) - 1] == _T('\n'))
				{
					strErrorText[_tcslen(strErrorText) - 2] = 0x0;
					strErrorText[_tcslen(strErrorText) - 1] = 0x0;
				}

				_tprintf(_T("Error: makeOIDRequest::My_PacketRequest error, NTSTATUS error code = 0x%x (%s)\n"), dwErrorCode, strErrorText);
				// Free the buffer allocated by the system.
				LocalFree(strErrorText);
				Status = TRUE;
			}
			else
			{
				tstring tstrErrorText = NdisStatus2Message(dwErrorCode);
				if (tstrErrorText != _T(""))
				{
					_tprintf(_T("Error: makeOIDRequest::My_PacketRequest error, NTSTATUS error code = 0x%x (%s)\n"), dwErrorCode, tstrErrorText.c_str());
					Status = TRUE;
				}
			}

			FreeLibrary(hModule);
		}

		if (!Status)
		{
			_tprintf(_T("Error: makeOIDRequest::My_PacketRequest error, NTSTATUS error code = 0x%x (NULL)\n%s0x%x or find its definition in your ndis.h if you installed WDK.\n"), dwErrorCode,
				_T("The error message can't be found, please google the error code: "), dwErrorCode);
		}
	}
	else
	{
		if (!bSet)
		{
			CopyMemory(pData, OidData->Data, ulDataSize);
		}
	}

	HeapFree(GetProcessHeap(), 0, OidData);
makeOIDRequest_Exit1:
	My_PacketCloseAdapter(pAdapter);
makeOIDRequest_Exit2:
	freePacketFunctions();
makeOIDRequest_Exit3:
	return Status;
}

BOOL GetCurrentOperationMode(tstring strGUID, tstring &strMode)
{
	BOOL bResult;
	DOT11_CURRENT_OPERATION_MODE CurrentOperationMode;

	bResult = makeOIDRequest(strGUID, OID_DOT11_CURRENT_OPERATION_MODE, FALSE, &CurrentOperationMode, sizeof(DOT11_CURRENT_OPERATION_MODE));
	if (bResult)
	{
		strMode = OperationMode2String(CurrentOperationMode.uCurrentOpMode);
	}
	else
	{
		strMode = _T("unknown (call failed)");
	}

	return bResult;
}

BOOL SetCurrentOperationMode(tstring strGUID, tstring strMode)
{
	BOOL bResult;
	DOT11_CURRENT_OPERATION_MODE CurrentOperationMode;

	CurrentOperationMode.uReserved = 0;
	CurrentOperationMode.uCurrentOpMode = String2OperationMode(strMode);
	if (CurrentOperationMode.uCurrentOpMode == DOT11_OPERATION_MODE_UNKNOWN)
	{
		_tprintf(_T("Error: SetCurrentOperationMode error, unknown mode: %s\n"), strMode.c_str());
		return FALSE;
	}

	bResult = makeOIDRequest(strGUID, OID_DOT11_CURRENT_OPERATION_MODE, TRUE, &CurrentOperationMode, sizeof(DOT11_CURRENT_OPERATION_MODE));
	return bResult;
}

BOOL GetOperationModeCapability(tstring strGUID, tstring &strModes)
{
	BOOL bResult;
	DOT11_OPERATION_MODE_CAPABILITY OperationModeCapability;

	bResult = makeOIDRequest(strGUID, OID_DOT11_OPERATION_MODE_CAPABILITY, FALSE, &OperationModeCapability, sizeof(DOT11_OPERATION_MODE_CAPABILITY));
	if (bResult)
	{
		strModes = _T("");
		if ((OperationModeCapability.uOpModeCapability & DOT11_OPERATION_MODE_EXTENSIBLE_AP) == DOT11_OPERATION_MODE_EXTENSIBLE_AP)
		{
			if (strModes != _T(""))
			{
				strModes += _T(", ");
			}
			strModes += _T("master");
		}
		if ((OperationModeCapability.uOpModeCapability & DOT11_OPERATION_MODE_EXTENSIBLE_STATION) == DOT11_OPERATION_MODE_EXTENSIBLE_STATION)
		{
			if (strModes != _T(""))
			{
				strModes += _T(", ");
			}
			strModes += _T("managed");
		}
		if ((OperationModeCapability.uOpModeCapability & DOT11_OPERATION_MODE_NETWORK_MONITOR) == DOT11_OPERATION_MODE_NETWORK_MONITOR)
		{
			if (strModes != _T(""))
			{
				strModes += _T(", ");
			}
			strModes += _T("monitor");
		}
	}
	else
	{
		strModes = _T("unknown (call failed)");
	}

	return bResult;
}

BOOL IsMonitorModeSupported(tstring strGUID)
{
	BOOL bResult;
	DOT11_OPERATION_MODE_CAPABILITY OperationModeCapability;

	bResult = makeOIDRequest(strGUID, OID_DOT11_OPERATION_MODE_CAPABILITY, FALSE, &OperationModeCapability, sizeof(DOT11_OPERATION_MODE_CAPABILITY));
	if (bResult)
	{
		if ((OperationModeCapability.uOpModeCapability & DOT11_OPERATION_MODE_NETWORK_MONITOR) == DOT11_OPERATION_MODE_NETWORK_MONITOR)
		{
			return TRUE;
		}
		else
		{
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}
}

BOOL GetCurrentChannel(tstring strGUID, ULONG &ulChannel)
{
	BOOL bResult;
	ULONG CurrentChannel;

	bResult = makeOIDRequest(strGUID, OID_DOT11_CURRENT_CHANNEL, FALSE, &CurrentChannel, sizeof(ULONG));
	if (bResult)
	{
		ulChannel = CurrentChannel;
	}
	else
	{
		ulChannel = 0;
	}

	return bResult;
}

BOOL SetCurrentChannel(tstring strGUID, ULONG ulChannel)
{
	BOOL bResult;
	ULONG CurrentChannel;

	CurrentChannel = ulChannel;
	bResult = makeOIDRequest(strGUID, OID_DOT11_CURRENT_CHANNEL, TRUE, &CurrentChannel, sizeof(ULONG));
	return bResult;
}

BOOL GetCurrentFrequency(tstring strGUID, ULONG &ulFrequency)
{
	BOOL bResult;
	ULONG CurrentFrequency;

	bResult = makeOIDRequest(strGUID, OID_DOT11_CURRENT_FREQUENCY, FALSE, &CurrentFrequency, sizeof(ULONG));
	if (bResult)
	{
		ulFrequency = CurrentFrequency;
	}
	else
	{
		ulFrequency = (ULONG) -1;
	}

	return bResult;
}

BOOL SetCurrentFrequency(tstring strGUID, ULONG ulFrequency)
{
	BOOL bResult;
	ULONG CurrentFrequency;

	CurrentFrequency = ulFrequency;
	bResult = makeOIDRequest(strGUID, OID_DOT11_CURRENT_FREQUENCY, TRUE, &CurrentFrequency, sizeof(ULONG));
	return bResult;
}

typedef struct _MY_DOT11_SUPPORTED_PHY_TYPES {
	ULONG uNumOfEntries;
	ULONG uTotalNumOfEntries;
	DOT11_PHY_TYPE dot11PHYType[64];
} MY_DOT11_SUPPORTED_PHY_TYPES, *PMY_DOT11_SUPPORTED_PHY_TYPES;

BOOL GetSupportedPhyTypes(tstring strGUID, vector<tstring> &nstrPhyTypes)
{
	BOOL bResult;
	MY_DOT11_SUPPORTED_PHY_TYPES SupportedPhyTypes;

	bResult = makeOIDRequest(strGUID, OID_DOT11_SUPPORTED_PHY_TYPES, FALSE, &SupportedPhyTypes, sizeof(MY_DOT11_SUPPORTED_PHY_TYPES));
	if (bResult)
	{
		nstrPhyTypes.clear();
		for (size_t i = 0; i < SupportedPhyTypes.uNumOfEntries; i++)
		{
			nstrPhyTypes.push_back(PhyType2String(SupportedPhyTypes.dot11PHYType[i]));
		}
	}

	g_nstrPhyTypes = nstrPhyTypes;
	return bResult;
}

typedef struct MY_DOT11_PHY_ID_LIST {
	NDIS_OBJECT_HEADER Header;
	ULONG uNumOfEntries;
	ULONG uTotalNumOfEntries;
	ULONG dot11PhyId[64];
} MY_DOT11_PHY_ID_LIST, *PMY_DOT11_PHY_ID_LIST;

BOOL GetDesiredPhyList(tstring strGUID, vector<tstring> &nstrPhyList)
{
	BOOL bResult;
	MY_DOT11_PHY_ID_LIST DesiredPhyList;

// 	if (g_nstrPhyTypes.size() == 0)
// 	{
// 		GetSupportedPhyTypes(strGUID, g_nstrPhyTypes);
// 	}

	bResult = makeOIDRequest(strGUID, OID_DOT11_DESIRED_PHY_LIST, FALSE, &DesiredPhyList, sizeof(MY_DOT11_PHY_ID_LIST));
	if (bResult)
	{
		nstrPhyList.clear();
		for (size_t i = 0; i < DesiredPhyList.uNumOfEntries; i++)
		{
			
			nstrPhyList.push_back(PhyType2String(DesiredPhyList.dot11PhyId[i]));
		}
	}

	return bResult;
}

BOOL GetCurrentPhyID(tstring strGUID, tstring &strPhyID)
{
	BOOL bResult;
	ULONG CurrentPhyID = 0x0fffffff;

	bResult = makeOIDRequest(strGUID, OID_DOT11_CURRENT_PHY_ID, FALSE, &CurrentPhyID, sizeof(ULONG));
	strPhyID = PhyType2String(CurrentPhyID);
	return bResult;
}

BOOL SetCurrentPhyID(tstring strGUID, tstring strPhyID)
{
	BOOL bResult;
	ULONG ulPhyID;

	ulPhyID = String2PhyType(strPhyID);
	bResult = makeOIDRequest(strGUID, OID_DOT11_CURRENT_PHY_ID, TRUE, &ulPhyID, sizeof(ULONG));
	return bResult;
}

```

`packetWin7/WlanHelper/WlanHelper/Tool.h`:

```h
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <vector>
#include <string>
using namespace std;

typedef std::basic_string<TCHAR> tstring;

#ifdef UNICODE
	#define RPC_TSTR RPC_WSTR
#else
	#define RPC_TSTR RPC_CSTR
#endif

tstring OperationMode2String(ULONG OperationMode);
ULONG String2OperationMode(tstring strOperationMode);

tstring PhyType2String(ULONG PhyType);
ULONG String2PhyType(tstring strPhyType);

tstring NdisStatus2Message(DWORD dwStatus);

tstring printArray(vector<tstring> nstr);

tstring itos(int i);

tstring executeCommand(TCHAR* cmd);

void initAdapterList();

tstring getGuidFromAdapterName(tstring strAdapterName);
tstring getAdapterNameFromGuid(tstring strGuid);

BOOL makeOIDRequest(tstring strAdapterGUID, ULONG iOid, BOOL bSet, PVOID pData, ULONG ulDataSize);

BOOL GetCurrentOperationMode(tstring strGUID, tstring &strMode);
BOOL SetCurrentOperationMode(tstring strGUID, tstring strMode);

BOOL GetOperationModeCapability(tstring strGUID, tstring &strModes);
BOOL IsMonitorModeSupported(tstring strGUID);

BOOL GetCurrentChannel(tstring strGUID, ULONG &ulChannel);
BOOL SetCurrentChannel(tstring strGUID, ULONG ulChannel);

BOOL GetCurrentFrequency(tstring strGUID, ULONG &ulFrequency);
BOOL SetCurrentFrequency(tstring strGUID, ULONG ulFrequency);

BOOL GetSupportedPhyTypes(tstring strGUID, vector<tstring> &strPhyTypes);
BOOL GetDesiredPhyList(tstring strGUID, vector<tstring> &nstrPhyList);
BOOL GetCurrentPhyID(tstring strGUID, tstring &strPhyID);
BOOL SetCurrentPhyID(tstring strGUID, tstring strPhyID);

```

`packetWin7/WlanHelper/WlanHelper/WlanHelper.cpp`:

```cpp
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
// WlanHelper.cpp : Defines the entry point for the console application.
//

// #include "stdafx.h"

#include "..\..\..\version.h"

#include <stdio.h>
#include <tchar.h>

#include <conio.h>
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <wlanapi.h>

#include "Tool.h"

// MAKEINTRESOURCE() returns an LPTSTR, but GetProcAddress()
// expects LPSTR even in UNICODE, so using MAKEINTRESOURCEA()...
#ifdef UNICODE
#define MAKEINTRESOURCEA_T(a, u) MAKEINTRESOURCEA(u)
#else
#define MAKEINTRESOURCEA_T(a, u) MAKEINTRESOURCEA(a)
#endif

BOOL myGUIDFromString(LPCTSTR psz, LPGUID pguid)
{
	BOOL bRet = FALSE;

	typedef BOOL(WINAPI *LPFN_GUIDFromString)(LPCTSTR, LPGUID);
	LPFN_GUIDFromString pGUIDFromString = NULL;

	HINSTANCE hInst = LoadLibrary(TEXT("shell32.dll"));
	if (hInst)
	{
		pGUIDFromString = (LPFN_GUIDFromString)GetProcAddress(hInst, MAKEINTRESOURCEA_T(703, 704));
		if (pGUIDFromString)
			bRet = pGUIDFromString(psz, pguid);
		FreeLibrary(hInst);
	}

	if (!pGUIDFromString)
	{
		hInst = LoadLibrary(TEXT("Shlwapi.dll"));
		if (hInst)
		{
			pGUIDFromString = (LPFN_GUIDFromString)GetProcAddress(hInst, MAKEINTRESOURCEA_T(269, 270));
			if (pGUIDFromString)
				bRet = pGUIDFromString(psz, pguid);
			FreeLibrary(hInst);
		}
	}

	return bRet;
}

#define WLAN_CLIENT_VERSION_VISTA 2

DWORD SetInterface(WLAN_INTF_OPCODE opcode, PVOID* pData, GUID* InterfaceGuid)
{
	DWORD dwResult = 0;
	HANDLE hClient = NULL;
	DWORD dwCurVersion = 0;
	DWORD outsize = 0;

	// Open Handle for the set operation
	dwResult = WlanOpenHandle(WLAN_CLIENT_VERSION_VISTA, NULL, &dwCurVersion, &hClient);
	dwResult = WlanSetInterface(hClient, InterfaceGuid, opcode, sizeof(ULONG), pData, NULL);
	WlanCloseHandle(hClient, NULL);

	return dwResult;
}

DWORD GetInterface(WLAN_INTF_OPCODE opcode, PVOID* pData, GUID* InterfaceGuid)
{
	DWORD dwResult = 0;
	HANDLE hClient = NULL;
	DWORD dwCurVersion = 0;
	DWORD outsize = 0;
	WLAN_OPCODE_VALUE_TYPE opCode = wlan_opcode_value_type_invalid;

	// Open Handle for the set operation
	dwResult = WlanOpenHandle(WLAN_CLIENT_VERSION_VISTA, NULL, &dwCurVersion, &hClient);
	dwResult = WlanQueryInterface(hClient, InterfaceGuid, opcode, NULL, &outsize, pData, &opCode);
	WlanCloseHandle(hClient, NULL);

	return dwResult;
}

// enumerate wireless interfaces
UINT EnumInterface(HANDLE hClient, WLAN_INTERFACE_INFO sInfo[64])
{
	DWORD dwError = ERROR_SUCCESS;
	PWLAN_INTERFACE_INFO_LIST pIntfList = NULL;
	UINT i = 0;

	__try
	{
		// enumerate wireless interfaces
		if ((dwError = WlanEnumInterfaces(
			hClient,
			NULL,               // reserved
			&pIntfList
			)) != ERROR_SUCCESS)
		{
			__leave;
		}

		// print out interface information
		for (i = 0; i < pIntfList->dwNumberOfItems; i++)
		{
			memcpy(&sInfo[i], &pIntfList->InterfaceInfo[i], sizeof(WLAN_INTERFACE_INFO));
		}
	}
	__finally
	{
		// clean up
		if (pIntfList != NULL)
		{
			WlanFreeMemory(pIntfList);
		}
	}
	return i;
}

// open a WLAN client handle and check version
DWORD
OpenHandleAndCheckVersion(
PHANDLE phClient
)
{
	DWORD dwError = ERROR_SUCCESS;
	DWORD dwServiceVersion;
	HANDLE hClient = NULL;

	__try
	{
		*phClient = NULL;

		// open a handle to the service
		if ((dwError = WlanOpenHandle(
			WLAN_API_VERSION,
			NULL,               // reserved
			&dwServiceVersion,
			&hClient
			)) != ERROR_SUCCESS)
		{
			__leave;
		}

		// check service version
		if (WLAN_API_VERSION_MAJOR(dwServiceVersion) < WLAN_API_VERSION_MAJOR(WLAN_API_VERSION_2_0))
		{
			// No-op, because the version check is for demonstration purpose only.
			// You can add your own logic here.
		}

		*phClient = hClient;

		// set hClient to NULL so it will not be closed
		hClient = NULL;
	}
	__finally
	{
		if (hClient != NULL)
		{
			// clean up
			WlanCloseHandle(
				hClient,
				NULL            // reserved
				);
		}
	}

	return dwError;
}

// get interface state string
LPTSTR
GetInterfaceStateString(__in WLAN_INTERFACE_STATE wlanInterfaceState)
{
	LPTSTR strRetCode;

	switch (wlanInterfaceState)
	{
	case wlan_interface_state_not_ready:
		strRetCode = _T("\"not ready\"");
		break;
	case wlan_interface_state_connected:
		strRetCode = _T("\"connected\"");
		break;
	case wlan_interface_state_ad_hoc_network_formed:
		strRetCode = _T("\"ad hoc network formed\"");
		break;
	case wlan_interface_state_disconnecting:
		strRetCode = _T("\"disconnecting\"");
		break;
	case wlan_interface_state_disconnected:
		strRetCode = _T("\"disconnected\"");
		break;
	case wlan_interface_state_associating:
		strRetCode = _T("\"associating\"");
		break;
	case wlan_interface_state_discovering:
		strRetCode = _T("\"discovering\"");
		break;
	case wlan_interface_state_authenticating:
		strRetCode = _T("\"authenticating\"");
		break;
	default:
		strRetCode = _T("\"invalid interface state\"");
	}

	return strRetCode;
}

// get interface operation mode string
LPTSTR
GetInterfaceOperationModeString(__in ULONG wlanInterfaceOperationMode)
{
	LPTSTR strRetCode;

	switch (wlanInterfaceOperationMode)
	{
	case DOT11_OPERATION_MODE_EXTENSIBLE_STATION:
		strRetCode = _T("\"Extensible Station (ExtSTA)\"");
		break;
	case DOT11_OPERATION_MODE_NETWORK_MONITOR:
		strRetCode = _T("\"Network Monitor (NetMon)\"");
		break;
	case DOT11_OPERATION_MODE_EXTENSIBLE_AP:
		strRetCode = _T("\"Extensible Access Point (ExtAP)\"");
		break;
	default:
		strRetCode = _T("\"invalid interface operation mode\"");
	}

	return strRetCode;
}

int MainInteractive()
{
	HANDLE hClient = NULL;
	WLAN_INTERFACE_INFO sInfo[64];
	RPC_TSTR strGuid = NULL;

	TCHAR szBuffer[256];
	DWORD dwRead;
	if (OpenHandleAndCheckVersion(&hClient) != ERROR_SUCCESS)
	{
		_tsystem(_T("PAUSE"));
		return -1;
	}

	UINT nCount = EnumInterface(hClient, sInfo);
	for (UINT i = 0; i < nCount; ++i)
	{
		if (UuidToString(&sInfo[i].InterfaceGuid, &strGuid) == RPC_S_OK)
		{
			ULONG ulOperationMode = -1;
			PULONG pOperationMode;
			DWORD dwResult = GetInterface(wlan_intf_opcode_current_operation_mode, (PVOID*)&pOperationMode, &sInfo[i].InterfaceGuid);
			if (dwResult != ERROR_SUCCESS)
			{
				_tprintf(_T("GetInterface error, error code = %d\n"), dwResult);
				_tsystem(_T("PAUSE"));
			}
			else
			{
				ulOperationMode = *pOperationMode;
				WlanFreeMemory(pOperationMode);
			}

			_tprintf(_T("%d. %s\n\tName: %s\n\tDescription: %s\n\tState: %s\n\tOperation Mode: %s\n"),
				i,
				(TCHAR *) strGuid,
				getAdapterNameFromGuid((TCHAR*) strGuid).c_str(),
				sInfo[i].strInterfaceDescription,
				GetInterfaceStateString(sInfo[i].isState),
				GetInterfaceOperationModeString(ulOperationMode));

			RpcStringFree(&strGuid);
		}
	}

	UINT nChoice = 0;
	GUID ChoiceGUID;
	LPGUID pChoiceGUID = NULL;
	_tprintf(_T("Enter the choice (0, 1,..) of the wireless card you want to operate on:\n"));

	if (ReadConsole(GetStdHandle(STD_INPUT_HANDLE), szBuffer, _countof(szBuffer), &dwRead, NULL) == FALSE)
	{
		_putts(_T("Error input."));
		_tsystem(_T("PAUSE"));
		return -1;
	}
	szBuffer[dwRead] = 0;

	// TCHAR *aaa = _T("42dfd47a-2764-43ac-b58e-3df569c447da");
	// dwRead = sizeof(aaa);

	TCHAR buf[256];
	_stprintf_s(buf, 256, _T("{%s}"), szBuffer);

	if (dwRead > 32)
	{
		if (myGUIDFromString(buf, &ChoiceGUID) != TRUE)
		{
			_tprintf(_T("UuidFromString error, error code = %d\n"), -1);
			_tsystem(_T("PAUSE"));
		}
		else
		{
			pChoiceGUID = &ChoiceGUID;
		}
	}
	else
	{
		nChoice = _ttoi(szBuffer);

		if (nChoice > nCount)
		{
			_putts(_T("No such index."));
			_tsystem(_T("PAUSE"));
			return -1;
		}

		pChoiceGUID = &sInfo[nChoice].InterfaceGuid;
	}

	UINT nSTate = 0;
	ULONG ulOperationMode = -1;
	_tprintf(_T("Enter the operation mode (0, 1 or 2) you want to switch to for the chosen wireless card:\n"));
	_tprintf(_T("0: Extensible Station (ExtSTA)\n1: Network Monitor (NetMon)\n2: Extensible Access Point (ExtAP)\n"));

	if (ReadConsole(GetStdHandle(STD_INPUT_HANDLE), szBuffer, _countof(szBuffer), &dwRead, NULL) == FALSE)
	{
		_putts(_T("Error input."));
		_tsystem(_T("PAUSE"));
		return -1;
	}
	szBuffer[dwRead] = 0;
	nSTate = _ttoi(szBuffer);

	if (nSTate != 0 && nSTate != 1 && nSTate != 2)
	{
		_putts(_T("Only 0, 1 and 2 are valid inputs."));
		_tsystem(_T("PAUSE"));
		return -1;
	}
	if (nSTate == 0)
	{
		ulOperationMode = DOT11_OPERATION_MODE_EXTENSIBLE_STATION;
	}
	else if (nSTate == 1)
	{
		ulOperationMode = DOT11_OPERATION_MODE_NETWORK_MONITOR;
	}
	else // nSTate == 2
	{
		ulOperationMode = DOT11_OPERATION_MODE_EXTENSIBLE_AP;
	}

	DWORD dwResult = SetInterface(wlan_intf_opcode_current_operation_mode, (PVOID*)&ulOperationMode, pChoiceGUID);
	if (dwResult != ERROR_SUCCESS)
	{
		_tprintf(_T("SetInterface error, error code = %d\n"), dwResult);
		_tsystem(_T("PAUSE"));
	}
	else
	{
		_tprintf(_T("SetInterface success!\n"));
	}

	return 0;
}

tstring getGuidFromAdapterName_Wrapper(tstring strGUID)
{
	if (_tcslen(strGUID.c_str()) == _tcslen(_T("42dfd47a-2764-43ac-b58e-3df569c447da")) && strGUID[8] == _T('-') && strGUID[13] == _T('-') && strGUID[18] == _T('-') && strGUID[23] == _T('-'))
	{
		return strGUID;
	}
	else
	{
		return getGuidFromAdapterName(strGUID);
	}
}

BOOL GetWlanOperationMode(tstring strGUID, tstring &strMode)
{
	strGUID = _T("{") + strGUID + _T("}");

	GUID ChoiceGUID;
	if (myGUIDFromString(strGUID.c_str(), &ChoiceGUID) != TRUE)
	{
		_tprintf(_T("Error: GetWlanOperationMode::myGUIDFromString error\n"));
		return FALSE;
	}

	ULONG ulOperationMode = -1;
	PULONG pOperationMode;
	DWORD dwResult = GetInterface(wlan_intf_opcode_current_operation_mode, (PVOID*)&pOperationMode, &ChoiceGUID);
	if (dwResult != ERROR_SUCCESS)
	{
		LPTSTR strErrorText = NULL;
		FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
			NULL, dwResult, 0, (PTSTR)&strErrorText, 0, NULL);
		if (strErrorText[_tcslen(strErrorText) - 2] == _T('\r') && strErrorText[_tcslen(strErrorText) - 1] == _T('\n'))
		{
			strErrorText[_tcslen(strErrorText) - 2] = 0x0;
			strErrorText[_tcslen(strErrorText) - 1] = 0x0;
		}

		_tprintf(_T("Error: GetWlanOperationMode::GetInterface error, error code = %d (%s)\n"), dwResult, strErrorText);
		return FALSE;
	}
	else
	{
		ulOperationMode = *pOperationMode;
		WlanFreeMemory(pOperationMode);
	}

	strMode = OperationMode2String(ulOperationMode);
	
	return TRUE;
}

BOOL SetWlanOperationMode(tstring strGUID, tstring strMode)
{
	strGUID = _T("{") + strGUID + _T("}");

	GUID ChoiceGUID;
	if (myGUIDFromString(strGUID.c_str(), &ChoiceGUID) != TRUE)
	{
		_tprintf(_T("Error: SetWlanOperationMode::myGUIDFromString error\n"));
		return FALSE;
	}

	ULONG ulOperationMode = String2OperationMode(strMode);
	if (ulOperationMode == DOT11_OPERATION_MODE_UNKNOWN)
	{
		_tprintf(_T("Error: SetWlanOperationMode::String2OperationMode error, unknown mode: %s\n"), strMode.c_str());
		return FALSE;
	}

	DWORD dwResult = SetInterface(wlan_intf_opcode_current_operation_mode, (PVOID*)&ulOperationMode, &ChoiceGUID);
	if (dwResult != ERROR_SUCCESS)
	{
		LPTSTR strErrorText = NULL;
		FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
			NULL, dwResult, 0, (PTSTR)&strErrorText, 0, NULL);
		if (strErrorText[_tcslen(strErrorText) - 2] == _T('\r') && strErrorText[_tcslen(strErrorText) - 1] == _T('\n'))
		{
			strErrorText[_tcslen(strErrorText) - 2] = 0x0;
			strErrorText[_tcslen(strErrorText) - 1] = 0x0;
		}

		_tprintf(_T("Error: SetWlanOperationMode::SetInterface error, error code = %d (%s)\n"), dwResult, strErrorText);
		return FALSE;
	}
	else
	{
		return TRUE;
	}
}

#define STR_COMMAND_USAGE \
_T("WlanHelper for Npcap ") _T(WINPCAP_VER_STRING) _T(" ( https://npcap.com )\n") \
_T("Usage: WlanHelper [Commands]\n") \
_T("   or: WlanHelper {Interface Name or GUID} [Options]\n") \
_T("\n") \
_T("OPTIONS:\n") \
_T("  mode\t\t\t\t\t: Get interface operation mode\n") \
_T("  mode <managed|monitor|master|..>\t: Set interface operation mode\n") \
_T("  modes\t\t\t\t\t: Get all operation modes supported by the interface, comma-separated\n") \
_T("  channel\t\t\t\t: Get interface channel\n") \
_T("  channel <1-14>\t\t\t: Set interface channel (only works in monitor mode)\n") \
_T("  freq\t\t\t\t\t: Get interface frequency\n") \
_T("  freq <VALUE>\t\t\t\t: Set interface frequency (only works in monitor mode)\n") \
_T("  modu\t\t\t\t\t: Get interface modulation\n") \
_T("  modu <dsss|fhss|irbaseband|ofdm|hrdsss|erp|ht|vht|ihv (VALUE)|..>\t: Set interface modulation\n") \
_T("  modus\t\t\t\t\t: Get all modulations supported by the interface, comma-separated\n") \
_T("\n") \
_T("COMMANDS:\n") \
_T("  -i\t\t\t\t\t: Enter the interactive mode\n") \
_T("  -h\t\t\t\t\t: Print this help summary page\n") \
_T("\n") \
_T("OPERATION MODES:\n") \
_T("  managed\t: The Extensible Station (ExtSTA) operation mode\n") \
_T("  monitor\t: The Network Monitor (NetMon) operation mode\n") \
_T("  master\t: The Extensible Access Point (ExtAP) operation mode (supported from Windows 7 and later)\n") \
_T("  wfd_device\t: The Wi-Fi Direct Device operation mode (supported from Windows 8 and later)\n") \
_T("  wfd_owner\t: The Wi-Fi Direct Group Owner operation mode (supported from Windows 8 and later)\n") \
_T("  wfd_client\t: The Wi-Fi Direct Client operation mode (supported from Windows 8 and later)\n") \
_T("\n") \
_T("802.11 MODULATIONS (https://en.wikipedia.org/wiki/IEEE_802.11):\n") \
_T("  802.11-1997\t: dsss, fhss\n") \
_T("  802.11a\t: ofdm\n") \
_T("  802.11b\t: dsss\n") \
_T("  802.11g\t: ofdm\n") \
_T("  802.11n\t: mimo-ofdm\n") \
_T("  802.11ac\t: mimo-ofdm\n") \
_T("\n") \
_T("EXAMPLES:\n") \
_T("  WlanHelper Wi-Fi mode\n") \
_T("  WlanHelper 42dfd47a-2764-43ac-b58e-3df569c447da channel 11\n") \
_T("  WlanHelper 42dfd47a-2764-43ac-b58e-3df569c447da freq 2\n") \
_T("  WlanHelper \"Wireless Network Connection\" mode monitor\n") \
_T("\n") \
_T("SEE THE MAN PAGE (https://github.com/nmap/npcap) FOR MORE OPTIONS AND EXAMPLES\n")

#define STR_INVALID_PARAMETER _T("Error: invalid parameter, type in \"WlanHelper -h\" for help.\n")

int _tmain(int argc, _TCHAR* argv[])
{
	SetConsoleTitle(_T("WlanHelper for Npcap ") _T(WINPCAP_VER_STRING) _T(" (https://npcap.com)"));
	vector<tstring> strArgs;
	for (int i = 0; i < argc; i++)
	{
		strArgs.push_back(argv[i]);
	}
	
	if (argc == 1)
	{
		_tprintf(STR_COMMAND_USAGE);
		return -1;
	}
	else if (argc == 2)
	{
		if (strArgs[1] ==_T("-h") || strArgs[1] == _T("--help"))
		{
			_tprintf(STR_COMMAND_USAGE);
			return -1;
		}
		else if (strArgs[1] == _T("-i"))
		{
			_tprintf(_T("WlanHelper [Interactive Mode]:\n****************************************************\n"));
			return MainInteractive();
		}
		else
		{
			_tprintf(STR_INVALID_PARAMETER);
			return -1;
		}
	}
	else if (argc == 3)
	{
		if (strArgs[2] == _T("mode"))
		{
			tstring strMode;
			if (GetCurrentOperationMode(getGuidFromAdapterName_Wrapper(strArgs[1]), strMode))
			{
				_tprintf(_T("%s\n"), strMode.c_str());
				return 0;
			}
			else
			{
				_tprintf(_T("Failure\n"));
				return -1;
			}
		}
		else if (strArgs[2] == _T("modes"))
		{
			tstring strModes;
			if (GetOperationModeCapability(getGuidFromAdapterName_Wrapper(strArgs[1]), strModes))
			{
				_tprintf(_T("%s\n"), strModes.c_str());
				return 0;
			}
			else
			{
				_tprintf(_T("Failure\n"));
				return -1;
			}
		}
		else if (strArgs[2] == _T("modes-monitor"))
		{
			tstring strModes;
			if (IsMonitorModeSupported(getGuidFromAdapterName_Wrapper(strArgs[1])))
			{
				_tprintf(_T("%d\n"), TRUE);
				return 0;
			}
			else
			{
				_tprintf(_T("%d\n"), FALSE);
				return 0;
			}
		}
		else if (strArgs[2] == _T("channel"))
		{
			ULONG ulChannel;
			if (GetCurrentChannel(getGuidFromAdapterName_Wrapper(strArgs[1]), ulChannel))
			{
				_tprintf(_T("%u\n"), ulChannel);
				return 0;
			}
			else
			{
				_tprintf(_T("Failure\n"));
				return -1;
			}
		}
		else if (strArgs[2] == _T("freq"))
		{
			ULONG ulFrequency;
			if (GetCurrentFrequency(getGuidFromAdapterName_Wrapper(strArgs[1]), ulFrequency))
			{
				_tprintf(_T("%u\n"), ulFrequency);
				return 0;
			}
			else
			{
				_tprintf(_T("Failure\n"));
				return -1;
			}
		}
		else if (strArgs[2] == _T("modus"))
		{
			vector<tstring> nstrPhyTypes;
			if (GetSupportedPhyTypes(getGuidFromAdapterName_Wrapper(strArgs[1]), nstrPhyTypes))
			{
				_tprintf(_T("%s\n"), printArray(nstrPhyTypes).c_str());
				return 0;
			}
			else
			{
				_tprintf(_T("Failure\n"));
				return -1;
			}
		}
		else if (strArgs[2] == _T("modus2"))
		{
			vector<tstring> nstrPhyList;
			if (GetDesiredPhyList(getGuidFromAdapterName_Wrapper(strArgs[1]), nstrPhyList))
			{
				_tprintf(_T("%s\n"), printArray(nstrPhyList).c_str());
				return 0;
			}
			else
			{
				_tprintf(_T("Failure\n"));
				return -1;
			}
		}
		else if (strArgs[2] == _T("modu"))
		{
			tstring ulPhyID;
			if (GetCurrentPhyID(getGuidFromAdapterName_Wrapper(strArgs[1]), ulPhyID))
			{
				_tprintf(_T("%s\n"), ulPhyID.c_str());
				return 0;
			}
			else
			{
				_tprintf(_T("Failure\n"));
				return -1;
			}
		}
		else
		{
			_tprintf(STR_INVALID_PARAMETER);
			return -1;
		}
	}
	else if (argc == 4)
	{
		if (strArgs[2] == _T("mode"))
		{
			if (SetWlanOperationMode(getGuidFromAdapterName_Wrapper(strArgs[1]), strArgs[3]))
			{
				_tprintf(_T("Success\n"));
				return 0;
			}
			else
			{
				_tprintf(_T("Failure\n"));
				return -1;
			}
		}
		else if (strArgs[2] == _T("channel"))
		{
			int ulChannel = _ttoi(strArgs[3].c_str());
			if (SetCurrentChannel(getGuidFromAdapterName_Wrapper(strArgs[1]), ulChannel))
			{
				_tprintf(_T("Success\n"));
				return 0;
			}
			else
			{
				_tprintf(_T("Failure\n"));
				return -1;
			}
		}
		else if (strArgs[2] == _T("freq"))
		{
			int ulFrequency = _ttoi(strArgs[3].c_str());
			if (SetCurrentFrequency(getGuidFromAdapterName_Wrapper(strArgs[1]), ulFrequency))
			{
				_tprintf(_T("Success\n"));
				return 0;
			}
			else
			{
				_tprintf(_T("Failure\n"));
				return -1;
			}
		}
		else if (strArgs[2] == _T("modu"))
		{
			if (SetCurrentPhyID(getGuidFromAdapterName_Wrapper(strArgs[1]), strArgs[3]))
			{
				_tprintf(_T("Success\n"));
				return 0;
			}
			else
			{
				_tprintf(_T("Failure\n"));
				return -1;
			}
		}
		else
		{
			_tprintf(STR_INVALID_PARAMETER);
			return -1;
		}
	}
	else
	{
		_tprintf(_T("Error: too many parameters.\n"));
		return -1;
	}

	return 0;
}


```

`packetWin7/WlanHelper/WlanHelper/WlanHelper.exe.manifest.in`:

```in
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!-- Windows 7 -->
      <supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}"/>
      <!-- Windows 8 -->
      <supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}"/>
      <!-- Windows 8.1 -->
      <supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}"/>
      <!-- Windows 10 -->
      <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
    </application>
  </compatibility>
</assembly>

```

`packetWin7/WlanHelper/WlanHelper/WlanHelper.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="OEM Debug|ARM64">
      <Configuration>OEM Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="OEM Debug|Win32">
      <Configuration>OEM Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="OEM Debug|x64">
      <Configuration>OEM Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="OEM Release|ARM64">
      <Configuration>OEM Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="OEM Release|Win32">
      <Configuration>OEM Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="OEM Release|x64">
      <Configuration>OEM Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{044CB4DC-827D-4134-B14B-DE114E884BB9}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>WlanHelper</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug|ARM64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release|ARM64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <ControlFlowGuard>Guard</ControlFlowGuard>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <SupportJustMyCode>false</SupportJustMyCode>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Rpcrt4.lib;wlanapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>WlanHelper.exe.manifest.in;%(AdditionalManifestFiles)</AdditionalManifestFiles>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>NPCAP_OEM;_DEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <ControlFlowGuard>Guard</ControlFlowGuard>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <SupportJustMyCode>false</SupportJustMyCode>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Rpcrt4.lib;wlanapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>WlanHelper.exe.manifest.in;%(AdditionalManifestFiles)</AdditionalManifestFiles>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <ControlFlowGuard>Guard</ControlFlowGuard>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <SupportJustMyCode>false</SupportJustMyCode>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Rpcrt4.lib;wlanapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>WlanHelper.exe.manifest.in;%(AdditionalManifestFiles)</AdditionalManifestFiles>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <ControlFlowGuard>Guard</ControlFlowGuard>
      <SupportJustMyCode>false</SupportJustMyCode>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Rpcrt4.lib;wlanapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>WlanHelper.exe.manifest.in;%(AdditionalManifestFiles)</AdditionalManifestFiles>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PreprocessorDefinitions>NPCAP_OEM;_DEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <ControlFlowGuard>Guard</ControlFlowGuard>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <SupportJustMyCode>false</SupportJustMyCode>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Rpcrt4.lib;wlanapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>WlanHelper.exe.manifest.in;%(AdditionalManifestFiles)</AdditionalManifestFiles>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='OEM Debug|ARM64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PreprocessorDefinitions>NPCAP_OEM;_DEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <ControlFlowGuard>Guard</ControlFlowGuard>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <SupportJustMyCode>false</SupportJustMyCode>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Rpcrt4.lib;wlanapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>WlanHelper.exe.manifest.in;%(AdditionalManifestFiles)</AdditionalManifestFiles>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <ControlFlowGuard>Guard</ControlFlowGuard>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>Rpcrt4.lib;wlanapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>WlanHelper.exe.manifest.in;%(AdditionalManifestFiles)</AdditionalManifestFiles>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PreprocessorDefinitions>NPCAP_OEM;NDEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <ControlFlowGuard>Guard</ControlFlowGuard>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>Rpcrt4.lib;wlanapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>WlanHelper.exe.manifest.in;%(AdditionalManifestFiles)</AdditionalManifestFiles>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <ControlFlowGuard>Guard</ControlFlowGuard>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>Rpcrt4.lib;wlanapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>WlanHelper.exe.manifest.in;%(AdditionalManifestFiles)</AdditionalManifestFiles>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <ControlFlowGuard>Guard</ControlFlowGuard>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>Rpcrt4.lib;wlanapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>WlanHelper.exe.manifest.in;%(AdditionalManifestFiles)</AdditionalManifestFiles>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PreprocessorDefinitions>NPCAP_OEM;NDEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <ControlFlowGuard>Guard</ControlFlowGuard>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>Rpcrt4.lib;wlanapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>WlanHelper.exe.manifest.in;%(AdditionalManifestFiles)</AdditionalManifestFiles>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='OEM Release|ARM64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PreprocessorDefinitions>NPCAP_OEM;NDEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <ControlFlowGuard>Guard</ControlFlowGuard>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>Rpcrt4.lib;wlanapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>WlanHelper.exe.manifest.in;%(AdditionalManifestFiles)</AdditionalManifestFiles>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Tool.cpp" />
    <ClCompile Include="WlanHelper.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Tool.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="version.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`packetWin7/WlanHelper/WlanHelper/WlanHelper.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="WlanHelper.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Tool.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Tool.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="version.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`packetWin7/WlanHelper/WlanHelper/version.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winresrc.h"
#ifndef IDC_STATIC
#define IDC_STATIC (-1)
#endif

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// Neutral resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_NEU)
#ifdef _WIN32
LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL
#pragma code_page(1252)
#endif //_WIN32

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE
BEGIN
"\r\n"
"\0"
END

2 TEXTINCLUDE
BEGIN
"#include ""afxres.h""\r\n"
"\0"
END

3 TEXTINCLUDE
BEGIN
"#include ""version.rc2""\r\n"
"\r\n"
"\0"
END

#endif    // APSTUDIO_INVOKED

#endif    // Neutral resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
#include "version.rc2"

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`packetWin7/WlanHelper/WlanHelper/version.rc2`:

```rc2
//
// version.rc2 - resources Microsoft Visual C++ does not edit directly
//

#ifdef APSTUDIO_INVOKED
	#error this file is not editable by Microsoft Visual C++
#endif //APSTUDIO_INVOKED


#include "..\..\..\version.h"

VS_VERSION_INFO VERSIONINFO
 FILEVERSION		WINPCAP_MAJOR,WINPCAP_MINOR,WINPCAP_REV,WINPCAP_BUILD
 PRODUCTVERSION		WINPCAP_MAJOR,WINPCAP_MINOR,WINPCAP_REV,WINPCAP_BUILD
 FILEFLAGSMASK VS_FFI_FILEFLAGSMASK
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS_NT_WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "000004b0"
        BEGIN
			VALUE "CompanyName",       WINPCAP_COMPANY_NAME
			VALUE "FileDescription",   "A tool for wireless adapter settings"
			VALUE "FileVersion",       WINPCAP_VER_STRING
			VALUE "InternalName",      "WlanHelper.exe"
			VALUE "LegalCopyright",    WINPCAP_COPYRIGHT_STRING
			VALUE "LegalTrademarks",   ""
			VALUE "OriginalFilename",  "WlanHelper.exe"
			VALUE "ProductName",       WINPCAP_PRODUCT_NAME
			VALUE "ProductVersion",    WINPCAP_VER_STRING
            VALUE "Build Description", WINPCAP_BUILD_DESCRIPTION
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x0, 1200
    END
END

```

`packetWin7/npf/npf Package/npf Package.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Win10 Debug|ARM64">
      <Configuration>Win10 Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win10 Debug|Win32">
      <Configuration>Win10 Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win10 Debug|x64">
      <Configuration>Win10 Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win10 OEM Debug|ARM64">
      <Configuration>Win10 OEM Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win10 OEM Debug|Win32">
      <Configuration>Win10 OEM Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win10 OEM Debug|x64">
      <Configuration>Win10 OEM Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win10 OEM Release|ARM64">
      <Configuration>Win10 OEM Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win10 OEM Release|Win32">
      <Configuration>Win10 OEM Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win10 OEM Release|x64">
      <Configuration>Win10 OEM Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win10 OEM RO Release|ARM64">
      <Configuration>Win10 OEM RO Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win10 OEM RO Release|Win32">
      <Configuration>Win10 OEM RO Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win10 OEM RO Release|x64">
      <Configuration>Win10 OEM RO Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win10 Release|ARM64">
      <Configuration>Win10 Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win10 Release|Win32">
      <Configuration>Win10 Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win10 Release|x64">
      <Configuration>Win10 Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 Debug|ARM64">
      <Configuration>Win7 Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 OEM Debug|ARM64">
      <Configuration>Win7 OEM Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 OEM Debug|Win32">
      <Configuration>Win7 OEM Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 OEM Debug|x64">
      <Configuration>Win7 OEM Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 OEM Release|ARM64">
      <Configuration>Win7 OEM Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 OEM Release|Win32">
      <Configuration>Win7 OEM Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 OEM Release|x64">
      <Configuration>Win7 OEM Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 OEM RO Release|ARM64">
      <Configuration>Win7 OEM RO Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 OEM RO Release|Win32">
      <Configuration>Win7 OEM RO Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 OEM RO Release|x64">
      <Configuration>Win7 OEM RO Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 Release SDV|ARM64">
      <Configuration>Win7 Release SDV</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 Release SDV|Win32">
      <Configuration>Win7 Release SDV</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 Release SDV|x64">
      <Configuration>Win7 Release SDV</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 Debug|Win32">
      <Configuration>Win7 Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 Release|ARM64">
      <Configuration>Win7 Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 Release|Win32">
      <Configuration>Win7 Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 Debug|x64">
      <Configuration>Win7 Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 Release|x64">
      <Configuration>Win7 Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win8 Debug|ARM64">
      <Configuration>Win8 Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win8 Debug|Win32">
      <Configuration>Win8 Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win8 Debug|x64">
      <Configuration>Win8 Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win8 OEM Release|ARM64">
      <Configuration>Win8 OEM Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win8 OEM Release|Win32">
      <Configuration>Win8 OEM Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win8 OEM Release|x64">
      <Configuration>Win8 OEM Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win8 OEM RO Release|ARM64">
      <Configuration>Win8 OEM RO Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win8 OEM RO Release|Win32">
      <Configuration>Win8 OEM RO Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win8 OEM RO Release|x64">
      <Configuration>Win8 OEM RO Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win8 Release|ARM64">
      <Configuration>Win8 Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win8 Release|Win32">
      <Configuration>Win8 Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win8 Release|x64">
      <Configuration>Win8 Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}</ProjectGuid>
    <TemplateGuid>{4605da2c-74a5-4865-98e1-152ef136825f}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>11.0</MinimumVisualStudioVersion>
    <Configuration>Win8 Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
  </PropertyGroup>
  <PropertyGroup Label="Globals">
    <RootNamespace>npf_Package</RootNamespace>
  </PropertyGroup>
  <PropertyGroup Label="PropertySheets">
    <ConfigurationType>Utility</ConfigurationType>
    <DriverType>Package</DriverType>
    <DisableFastUpToDateCheck>true</DisableFastUpToDateCheck>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release|Win32'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Release|Win32'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 OEM Release|Win32'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 OEM RO Release|Win32'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM RO Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM Release|Win32'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM RO Release|Win32'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release SDV|Win32'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Debug|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM Debug|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Release|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Debug|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 OEM Release|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 OEM RO Release|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 OEM Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 OEM RO Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM RO Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM RO Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM Release|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM RO Release|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM RO Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release SDV|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release SDV|ARM64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableDeployment>False</EnableDeployment>
    <RemoveDriver>True</RemoveDriver>
    <HardwareIdString />
    <CommandLine />
    <DeployFiles />
    <EnableVerifier>False</EnableVerifier>
    <AllDrivers>False</AllDrivers>
    <VerifyProjectOutput>True</VerifyProjectOutput>
    <VerifyDrivers />
    <VerifyFlags>133563</VerifyFlags>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Debug|Win32'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir>$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>7_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM Debug|Win32'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir>$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>7_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Debug|x64'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>7_$(DDKPlatform),Server2008R2_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Debug|ARM64'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>7_$(DDKPlatform),Server2008R2_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM Debug|x64'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>7_$(DDKPlatform),Server2008R2_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM Debug|ARM64'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>7_$(DDKPlatform),Server2008R2_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release|Win32'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir>$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>7_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Release|Win32'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir>$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>8_$(DDKPlatform),6_3_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Debug|Win32'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir>$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>8_$(DDKPlatform),6_3_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 OEM Release|Win32'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir>$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>8_$(DDKPlatform),6_3_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 OEM RO Release|Win32'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir>$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>8_$(DDKPlatform),6_3_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 Release|Win32'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir>$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>10_$(DDKPlatform),10_AU_$(DDKPlatform),10_RS2_$(DDKPlatform),10_RS3_$(DDKPlatform),10_RS4_$(DDKPlatform),10_RS5_$(DDKPlatform),10_19H1_$(DDKPlatform),10_VB_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 Debug|Win32'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir>$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>10_$(DDKPlatform),10_AU_$(DDKPlatform),10_RS2_$(DDKPlatform),10_RS3_$(DDKPlatform),10_RS4_$(DDKPlatform),10_RS5_$(DDKPlatform),10_19H1_$(DDKPlatform),10_VB_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM Debug|Win32'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir>$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>10_$(DDKPlatform),10_AU_$(DDKPlatform),10_RS2_$(DDKPlatform),10_RS3_$(DDKPlatform),10_RS4_$(DDKPlatform),10_RS5_$(DDKPlatform),10_19H1_$(DDKPlatform),10_VB_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM Release|Win32'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir>$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>10_$(DDKPlatform),10_AU_$(DDKPlatform),10_RS2_$(DDKPlatform),10_RS3_$(DDKPlatform),10_RS4_$(DDKPlatform),10_RS5_$(DDKPlatform),10_19H1_$(DDKPlatform),10_VB_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM RO Release|Win32'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir>$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>10_$(DDKPlatform),10_AU_$(DDKPlatform),10_RS2_$(DDKPlatform),10_RS3_$(DDKPlatform),10_RS4_$(DDKPlatform),10_RS5_$(DDKPlatform),10_19H1_$(DDKPlatform),10_VB_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM Release|Win32'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir>$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>7_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM RO Release|Win32'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir>$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>7_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release SDV|Win32'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir>$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>7_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release|x64'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>7_$(DDKPlatform),Server2008R2_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release|ARM64'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>7_$(DDKPlatform),Server2008R2_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Release|x64'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>8_$(DDKPlatform),6_3_$(DDKPlatform),Server8_$(DDKPlatform),Server6_3_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Debug|x64'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>8_$(DDKPlatform),6_3_$(DDKPlatform),Server8_$(DDKPlatform),Server6_3_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 OEM Release|x64'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>8_$(DDKPlatform),6_3_$(DDKPlatform),Server8_$(DDKPlatform),Server6_3_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 OEM RO Release|x64'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>8_$(DDKPlatform),6_3_$(DDKPlatform),Server8_$(DDKPlatform),Server6_3_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Release|ARM64'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>8_$(DDKPlatform),6_3_$(DDKPlatform),Server8_$(DDKPlatform),Server6_3_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Debug|ARM64'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>8_$(DDKPlatform),6_3_$(DDKPlatform),Server8_$(DDKPlatform),Server6_3_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 OEM Release|ARM64'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>8_$(DDKPlatform),6_3_$(DDKPlatform),Server8_$(DDKPlatform),Server6_3_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 OEM RO Release|ARM64'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>8_$(DDKPlatform),6_3_$(DDKPlatform),Server8_$(DDKPlatform),Server6_3_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 Release|x64'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>10_$(DDKPlatform),10_AU_$(DDKPlatform),10_RS2_$(DDKPlatform),10_RS3_$(DDKPlatform),10_RS4_$(DDKPlatform),10_RS5_$(DDKPlatform),10_19H1_$(DDKPlatform),10_VB_$(DDKPlatform),10_CO_$(DDKPlatform),Server10_$(DDKPlatform),SERVER2016_$(DDKPlatform),ServerRS5_$(DDKPlatform),ServerFE_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 Release|ARM64'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>10_RS3_$(DDKPlatform),10_RS4_$(DDKPlatform),10_RS5_$(DDKPlatform),10_19H1_$(DDKPlatform),10_VB_$(DDKPlatform),10_CO_$(DDKPlatform),Server10_$(DDKPlatform),ServerRS5_$(DDKPlatform),ServerFE_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 Debug|x64'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>10_$(DDKPlatform),10_AU_$(DDKPlatform),10_RS2_$(DDKPlatform),10_RS3_$(DDKPlatform),10_RS4_$(DDKPlatform),10_RS5_$(DDKPlatform),10_19H1_$(DDKPlatform),10_VB_$(DDKPlatform),10_CO_$(DDKPlatform),Server10_$(DDKPlatform),SERVER2016_$(DDKPlatform),ServerRS5_$(DDKPlatform),ServerFE_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 Debug|ARM64'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>10_RS3_$(DDKPlatform),10_RS4_$(DDKPlatform),10_RS5_$(DDKPlatform),10_19H1_$(DDKPlatform),10_VB_$(DDKPlatform),10_CO_$(DDKPlatform),Server10_$(DDKPlatform),ServerRS5_$(DDKPlatform),ServerFE_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM Debug|x64'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>10_$(DDKPlatform),10_AU_$(DDKPlatform),10_RS2_$(DDKPlatform),10_RS3_$(DDKPlatform),10_RS4_$(DDKPlatform),10_RS5_$(DDKPlatform),10_19H1_$(DDKPlatform),10_VB_$(DDKPlatform),10_CO_$(DDKPlatform),Server10_$(DDKPlatform),SERVER2016_$(DDKPlatform),ServerRS5_$(DDKPlatform),ServerFE_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM Debug|ARM64'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>10_RS3_$(DDKPlatform),10_RS4_$(DDKPlatform),10_RS5_$(DDKPlatform),10_19H1_$(DDKPlatform),10_VB_$(DDKPlatform),10_CO_$(DDKPlatform),Server10_$(DDKPlatform),ServerRS5_$(DDKPlatform),ServerFE_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM Release|x64'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>10_$(DDKPlatform),10_AU_$(DDKPlatform),10_RS2_$(DDKPlatform),10_RS3_$(DDKPlatform),10_RS4_$(DDKPlatform),10_RS5_$(DDKPlatform),10_19H1_$(DDKPlatform),10_VB_$(DDKPlatform),10_CO_$(DDKPlatform),Server10_$(DDKPlatform),SERVER2016_$(DDKPlatform),ServerRS5_$(DDKPlatform),ServerFE_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM Release|ARM64'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>10_RS3_$(DDKPlatform),10_RS4_$(DDKPlatform),10_RS5_$(DDKPlatform),10_19H1_$(DDKPlatform),10_VB_$(DDKPlatform),10_CO_$(DDKPlatform),Server10_$(DDKPlatform),ServerRS5_$(DDKPlatform),ServerFE_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM RO Release|x64'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>10_$(DDKPlatform),10_AU_$(DDKPlatform),10_RS2_$(DDKPlatform),10_RS3_$(DDKPlatform),10_RS4_$(DDKPlatform),10_RS5_$(DDKPlatform),10_19H1_$(DDKPlatform),10_VB_$(DDKPlatform),10_CO_$(DDKPlatform),Server10_$(DDKPlatform),SERVER2016_$(DDKPlatform),ServerRS5_$(DDKPlatform),ServerFE_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM RO Release|ARM64'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>10_RS3_$(DDKPlatform),10_RS4_$(DDKPlatform),10_RS5_$(DDKPlatform),10_19H1_$(DDKPlatform),10_VB_$(DDKPlatform),10_CO_$(DDKPlatform),Server10_$(DDKPlatform),ServerRS5_$(DDKPlatform),ServerFE_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM Release|x64'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>7_$(DDKPlatform),Server2008R2_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM Release|ARM64'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>7_$(DDKPlatform),Server2008R2_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM RO Release|x64'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>7_$(DDKPlatform),Server2008R2_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM RO Release|ARM64'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>7_$(DDKPlatform),Server2008R2_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release SDV|x64'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>7_$(DDKPlatform),Server2008R2_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release SDV|ARM64'">
    <EnableInf2cat>true</EnableInf2cat>
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <Inf2CatWindowsVersionList>7_$(DDKPlatform),Server2008R2_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release|Win32'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Release|Win32'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Debug|Win32'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win8 OEM Release|Win32'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win8 OEM RO Release|Win32'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win10 Release|Win32'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win10 Debug|Win32'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM Debug|Win32'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM Release|Win32'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM RO Release|Win32'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM Release|Win32'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM RO Release|Win32'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release SDV|Win32'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release|x64'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release|ARM64'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Release|x64'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Debug|x64'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win8 OEM Release|x64'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win8 OEM RO Release|x64'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Release|ARM64'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Debug|ARM64'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win8 OEM Release|ARM64'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win8 OEM RO Release|ARM64'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win10 Release|x64'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win10 Release|ARM64'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win10 Debug|x64'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win10 Debug|ARM64'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM Debug|x64'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM Debug|ARM64'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM Release|x64'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM Release|ARM64'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM RO Release|x64'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM RO Release|ARM64'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM Release|x64'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM Release|ARM64'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM RO Release|x64'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM RO Release|ARM64'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release SDV|x64'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release SDV|ARM64'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Debug|Win32'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM Debug|Win32'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Debug|x64'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Debug|ARM64'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM Debug|x64'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM Debug|ARM64'">
    <Inf2Cat>
      <UseLocalTime>true</UseLocalTime>
    </Inf2Cat>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="@(Inf->'%(CopyOutput)')" Condition="'@(Inf)'!=''" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\npf\npf.vcxproj">
      <Project>{3556f5bc-f8ec-437e-93e3-7cf2dc63ff61}</Project>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`packetWin7/npf/npf.sln`:

```sln
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 14
VisualStudioVersion = 14.0.25420.1
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "npf", "npf\npf.vcxproj", "{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "npf Package", "npf Package\npf Package.vcxproj", "{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}"
	ProjectSection(ProjectDependencies) = postProject
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61} = {3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}
	EndProjectSection
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Win7 Debug|Win32 = Win7 Debug|Win32
		Win7 Debug|x64 = Win7 Debug|x64
		Win7 OEM Release|Win32 = Win7 OEM Release|Win32
		Win7 OEM Release|x64 = Win7 OEM Release|x64
		Win7 Release SDV|Win32 = Win7 Release SDV|Win32
		Win7 Release SDV|x64 = Win7 Release SDV|x64
		Win7 Release|Win32 = Win7 Release|Win32
		Win7 Release|x64 = Win7 Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Win7 Debug|Win32.ActiveCfg = Win7 Debug|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Win7 Debug|Win32.Build.0 = Win7 Debug|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Win7 Debug|Win32.Deploy.0 = Win7 Debug|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Win7 Debug|x64.ActiveCfg = Win7 Debug|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Win7 Debug|x64.Build.0 = Win7 Debug|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Win7 Debug|x64.Deploy.0 = Win7 Debug|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Win7 OEM Release|Win32.ActiveCfg = Win7 OEM Release|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Win7 OEM Release|Win32.Build.0 = Win7 OEM Release|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Win7 OEM Release|Win32.Deploy.0 = Win7 OEM Release|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Win7 OEM Release|x64.ActiveCfg = Win7 OEM Release|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Win7 OEM Release|x64.Build.0 = Win7 OEM Release|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Win7 OEM Release|x64.Deploy.0 = Win7 OEM Release|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Win7 Release SDV|Win32.ActiveCfg = Win7 Release SDV|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Win7 Release SDV|Win32.Build.0 = Win7 Release SDV|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Win7 Release SDV|Win32.Deploy.0 = Win7 Release SDV|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Win7 Release SDV|x64.ActiveCfg = Win7 Release SDV|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Win7 Release SDV|x64.Build.0 = Win7 Release SDV|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Win7 Release SDV|x64.Deploy.0 = Win7 Release SDV|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Win7 Release|Win32.ActiveCfg = Win7 Release|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Win7 Release|Win32.Build.0 = Win7 Release|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Win7 Release|Win32.Deploy.0 = Win7 Release|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Win7 Release|x64.ActiveCfg = Win7 Release|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Win7 Release|x64.Build.0 = Win7 Release|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Win7 Release|x64.Deploy.0 = Win7 Release|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Win7 Debug|Win32.ActiveCfg = Win7 Debug|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Win7 Debug|Win32.Build.0 = Win7 Debug|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Win7 Debug|Win32.Deploy.0 = Win7 Debug|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Win7 Debug|x64.ActiveCfg = Win7 Debug|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Win7 Debug|x64.Build.0 = Win7 Debug|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Win7 Debug|x64.Deploy.0 = Win7 Debug|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Win7 OEM Release|Win32.ActiveCfg = Win7 OEM Release|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Win7 OEM Release|Win32.Build.0 = Win7 OEM Release|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Win7 OEM Release|Win32.Deploy.0 = Win7 OEM Release|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Win7 OEM Release|x64.ActiveCfg = Win7 OEM Release|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Win7 OEM Release|x64.Build.0 = Win7 OEM Release|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Win7 OEM Release|x64.Deploy.0 = Win7 OEM Release|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Win7 Release SDV|Win32.ActiveCfg = Win7 Release SDV|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Win7 Release SDV|Win32.Build.0 = Win7 Release SDV|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Win7 Release SDV|Win32.Deploy.0 = Win7 Release SDV|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Win7 Release SDV|x64.ActiveCfg = Win7 Release SDV|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Win7 Release SDV|x64.Build.0 = Win7 Release SDV|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Win7 Release SDV|x64.Deploy.0 = Win7 Release SDV|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Win7 Release|Win32.ActiveCfg = Win7 Release|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Win7 Release|Win32.Build.0 = Win7 Release|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Win7 Release|Win32.Deploy.0 = Win7 Release|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Win7 Release|x64.ActiveCfg = Win7 Release|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Win7 Release|x64.Build.0 = Win7 Release|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Win7 Release|x64.Deploy.0 = Win7 Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`packetWin7/npf/npf/Loopback.c`:

```c
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
/*
* Loopback.c
*
* Abstract:
* This file declares common functions used
* throughout loopback packets capturing.
*
* This code is based on Microsoft WFP Network Inspect sample.
*
*/

#ifdef HAVE_WFP_LOOPBACK_SUPPORT

#include "stdafx.h"

#include "Loopback.h"
#include "Packet.h"
#include "..\..\..\Common\WpcapNames.h"
#include "..\..\..\version.h"

#include <fwpsk.h>
#include <fwpmk.h>

#define INITGUID
#include <guiddef.h>

// 
// Global variables
//
extern PNPCAP_DRIVER_EXTENSION g_pDriverExtension;

// 
// Callout and sublayer GUIDs
//

// af617412-ce10-4058-8996-abc79fd805ff
DEFINE_GUID(
	NPF_FWPM_PROVIDER_GUID,
	0xaf617412,
	0xce10,
	0x4058,
	0x89, 0x96, 0xab, 0xc7, 0x9f, 0xd8, 0x05, 0xff
);

// ED7E5EB2-6B09-4783-961C-5495EAAD361F
DEFINE_GUID(
	NPF_INBOUND_IPPACKET_CALLOUT_V4,
	0xed7e5eb2,
	0x6b09,
	0x4783,
	0x96, 0x1c, 0x54, 0x95, 0xea, 0xad, 0x36, 0x1f
);
// 21022F40-9578-4C39-98A5-C97B8D834E28
DEFINE_GUID(
	NPF_INBOUND_IPPACKET_CALLOUT_V6,
	0x21022f40,
	0x9578,
	0x4c39,
	0x98, 0xa5, 0xc9, 0x7b, 0x8d, 0x83, 0x4e, 0x28
);

// 2F32C254-A054-469B-B99B-3E8810275A72
DEFINE_GUID(
	NPF_SUBLAYER,
	0x2f32c254,
	0xa054,
	0x469b,
	0xb9, 0x9b, 0x3e, 0x88, 0x10, 0x27, 0x5a, 0x72
);


// Send the loopback packets data to the user-mode code.
VOID
NPF_TapLoopback(
        _In_ PNPCAP_FILTER_MODULE pLoopbackFilter,
        _In_ BOOLEAN bIPv4,
        _In_ PNET_BUFFER_LIST pNetBufferList
        )
{
	UCHAR pPacketData[ETHER_HDR_LEN] = {0};
	UINT numBytes = 0;
    PUCHAR npBuff = NULL;
    PNET_BUFFER_LIST pFakeNbl = NULL;
    PNET_BUFFER pFakeNetBuffer = NULL;
    PNET_BUFFER pNetBuffer = NULL;
    ULONG Offset = 0;
    PUCHAR pOrigBuf = NULL;
    ULONG OrigLen = 0;
    ULONG FirstMDLLen = 0;
    PUCHAR pTmpBuf = NULL;
    PMDL pMdl = NULL;

	NT_ASSERT(pLoopbackFilter != NULL);
	do {
		/* Quick check to avoid extra work.
		 * Won't lock because we're not actually traversing. */
		if (NULL == pLoopbackFilter->OpenInstances.Next) {
			break;
		}
		if (g_pDriverExtension->bDltNullMode)
		{
			((PDLT_NULL_HEADER) pPacketData)->null_type = bIPv4 ? DLTNULLTYPE_IP : DLTNULLTYPE_IPV6;
			numBytes = DLT_NULL_HDR_LEN;
		}
		else
		{
			/* Addresses zero-initialized */
			((PETHER_HEADER) pPacketData)->ether_type = bIPv4 ? RtlUshortByteSwap(ETHERTYPE_IP) : RtlUshortByteSwap(ETHERTYPE_IPV6);
			numBytes = ETHER_HDR_LEN;
		}
		// TODO: use a lookahead list for npBuffs
		npBuff = (PUCHAR) NdisAllocateMemoryWithTagPriority(
				pLoopbackFilter->AdapterHandle, numBytes, NPF_LOOPBACK_COPY_TAG, NormalPoolPriority);
		if (npBuff == NULL)
		{
			WARNING_DBG("Failed to allocate buffer.\n");
			break;
		}
		RtlCopyMemory(npBuff, pPacketData, numBytes);

		pFakeNbl = NdisAllocateNetBufferAndNetBufferList(
				pLoopbackFilter->PacketPool, 0, 0, NULL, 0, 0);
		if (pFakeNbl == NULL)
		{
			WARNING_DBG("Failed to allocate NBL.\n");
			break;
		}
		pFakeNetBuffer = NET_BUFFER_LIST_FIRST_NB(pFakeNbl);
		/* Now loop through the original NBL, creating NBs in our fake NBL for each one. */
		pNetBuffer = NET_BUFFER_LIST_FIRST_NB(pNetBufferList);
		while (pNetBuffer)
		{
			Offset = NET_BUFFER_CURRENT_MDL_OFFSET(pNetBuffer);
			if (Offset >= numBytes) {
				QueryMdl(NET_BUFFER_CURRENT_MDL(pNetBuffer),
						&pOrigBuf,
						&OrigLen,
						NormalPagePriority);
				if (pOrigBuf == NULL) {
					WARNING_DBG("Failed to query MDL\n");
					break;
				}
				RtlCopyMemory(pOrigBuf + Offset - numBytes, pPacketData, numBytes);
				NET_BUFFER_FIRST_MDL(pFakeNetBuffer) =
					NET_BUFFER_CURRENT_MDL(pFakeNetBuffer) = NET_BUFFER_CURRENT_MDL(pNetBuffer);
				NET_BUFFER_DATA_OFFSET(pFakeNetBuffer) = 
					NET_BUFFER_CURRENT_MDL_OFFSET(pFakeNetBuffer) = Offset - numBytes;
				NET_BUFFER_DATA_LENGTH(pFakeNetBuffer) = numBytes + NET_BUFFER_DATA_LENGTH(pNetBuffer);
				// We didn't allocate a MDL, so make sure we don't free it.
				NET_BUFFER_PROTOCOL_RESERVED(pFakeNetBuffer)[0] = NULL;
			}
			else {
				if (Offset > 0) {
					/* Need to eliminate empty data prior to offset in our fake copy. */
					QueryMdl(NET_BUFFER_CURRENT_MDL(pNetBuffer),
							&pOrigBuf,
							&OrigLen,
							NormalPagePriority);
					if (pOrigBuf == NULL) {
						WARNING_DBG("Failed to query MDL\n");
						break;
					}
					/* Make a buffer big enough for our fake DLT header plus used
					 * data of first MDL */
					FirstMDLLen = numBytes + OrigLen - Offset;
					pTmpBuf = NdisAllocateMemoryWithTagPriority(
							pLoopbackFilter->AdapterHandle, FirstMDLLen, NPF_LOOPBACK_COPY_TAG, NormalPoolPriority);
					if (pTmpBuf == NULL)
					{
						WARNING_DBG("Failed to allocate buffer.\n");
						break;
					}
					RtlCopyMemory(pTmpBuf, pPacketData, numBytes);
					RtlCopyMemory(pTmpBuf + numBytes, pOrigBuf + Offset, OrigLen - Offset);
					pMdl = NdisAllocateMdl(pLoopbackFilter->AdapterHandle, pTmpBuf, FirstMDLLen);
					if (pMdl == NULL) {
						NdisFreeMemory(pTmpBuf, FirstMDLLen, 0);
						WARNING_DBG("Failed to allocate MDL.\n");
						break;
					}
					// WORKAROUND: We are calling NPF_AnalysisAssumeAliased here because the buffer address
					// is stored in the MDL and we retrieve it (via QueryMdl) in the cleanup block below.
					// Therefore, it is not leaking after this point.
					NPF_AnalysisAssumeAliased(pTmpBuf);

					pMdl->Next = NET_BUFFER_CURRENT_MDL(pNetBuffer)->Next;
				}
				else {
					/* Allocate a MDL for the remainder and chain to theirs */
					pMdl = NdisAllocateMdl(pLoopbackFilter->AdapterHandle, npBuff, numBytes);
					if (pMdl == NULL)
					{
						WARNING_DBG("Failed to allocate MDL.\n");
						break;
					}
					// No NPF_AnalysisAssumeAliased here because there is only one npBuff, and we keep it around until we free it below.
					FirstMDLLen = numBytes;
					pMdl->Next = NET_BUFFER_CURRENT_MDL(pNetBuffer);
				}
				NET_BUFFER_FIRST_MDL(pFakeNetBuffer) = pMdl;
				NET_BUFFER_DATA_LENGTH(pFakeNetBuffer) = numBytes + NET_BUFFER_DATA_LENGTH(pNetBuffer);
				NET_BUFFER_DATA_OFFSET(pFakeNetBuffer) = 0;
				NET_BUFFER_CURRENT_MDL(pFakeNetBuffer) = pMdl;
				NET_BUFFER_CURRENT_MDL_OFFSET(pFakeNetBuffer) = 0;
				// We use the ProtocolReserved field to indicate that the MDL needs to be freed.
				NET_BUFFER_PROTOCOL_RESERVED(pFakeNetBuffer)[0] = pMdl;
			}
			/* Move down the chain! */
			pNetBuffer = pNetBuffer->Next;
			if (pNetBuffer) {
				NET_BUFFER_NEXT_NB(pFakeNetBuffer) = NdisAllocateNetBuffer(
						pLoopbackFilter->PacketPool, NULL, 0, 0);
				pFakeNetBuffer = NET_BUFFER_NEXT_NB(pFakeNetBuffer);
				if (pFakeNetBuffer == NULL)
				{
					WARNING_DBG("Failed to allocate NB.\n");
					break;
				}
			}
		}


		// TODO: handle SkipSentPackets?
		NPF_DoTap(pLoopbackFilter, pFakeNbl, NULL, TRUE);
	} while (0);

	if (pFakeNbl != NULL) {
		/* cleanup */
		pFakeNetBuffer = NET_BUFFER_LIST_FIRST_NB(pFakeNbl);
		while (pFakeNetBuffer != NULL)
		{
			// If this field is not NULL, it points to the MDL we need to free
			pMdl = (PMDL)(NET_BUFFER_PROTOCOL_RESERVED(pFakeNetBuffer)[0]);

			if (pMdl != NULL) {
				/* If it's npBuff, we'll free it later.
				 * Otherwise it's unique and we should free it now. */
				QueryMdl(pMdl, &pTmpBuf, &FirstMDLLen, HighPagePriority|MdlMappingNoExecute);
				if (pTmpBuf != npBuff)
				{
					// See NPF_FreeNBCopies for TODO item related to this assert and
					// justification for HighPagePriority above.
					if (NT_VERIFY(pTmpBuf != NULL)) {
						NdisFreeMemory(pTmpBuf, FirstMDLLen, 0);
					}
					// else? No good way to recover, we've leaked the memory.
				}

				/* Regardless, free the MDL */
				NdisFreeMdl(pMdl);
			}

			/* Now stash the next NB and free this one. */
			pNetBuffer = NET_BUFFER_NEXT_NB(pFakeNetBuffer);
			/* First NB is pre-allocated, so we don't have to free it. */
			if (pFakeNetBuffer != NET_BUFFER_LIST_FIRST_NB(pFakeNbl)) {
				NdisFreeNetBuffer(pFakeNetBuffer);
			}
			pFakeNetBuffer = pNetBuffer;
		}

		NdisFreeNetBufferList(pFakeNbl);
	}

	if (npBuff != NULL) {
		NdisFreeMemory(npBuff, numBytes, 0);
	}
}

_Must_inspect_result_
BOOL NPF_ShouldProcess(
		_In_ const FWPS_INCOMING_VALUES* inFixedValues,
		_In_ const FWPS_INCOMING_METADATA_VALUES* inMetaValues,
		_Out_ PUCHAR puIPv4
		)
{
	UNREFERENCED_PARAMETER(inMetaValues);
	UINT32 layerFlags = 0;

	// Get the packet protocol (IPv4 or IPv6)
	switch (inFixedValues->layerId) {
		case FWPS_LAYER_INBOUND_IPPACKET_V4:
			*puIPv4 = NPF_INJECT_IPV4;
			layerFlags = inFixedValues->incomingValue[FWPS_FIELD_INBOUND_IPPACKET_V4_FLAGS].value.uint32;
			break;
		case FWPS_LAYER_INBOUND_IPPACKET_V6:
			*puIPv4 = NPF_INJECT_IPV6;
			layerFlags = inFixedValues->incomingValue[FWPS_FIELD_INBOUND_IPPACKET_V6_FLAGS].value.uint32;
			break;
		default:
			// This is not our layer! Bail.
			ERROR_DBG("uIPv4 cannot be determined, inFixedValues->layerId = %u\n", inFixedValues->layerId);
			*puIPv4 = 0;
			return FALSE;
			break;
	}

	// Filter out fragment packets and reassembled packets.
	if (layerFlags & FWP_CONDITION_FLAG_IS_FRAGMENT
			|| layerFlags & FWP_CONDITION_FLAG_IS_REASSEMBLED)
	{
		return FALSE;
	}
	return TRUE;
}

#if(NTDDI_VERSION < NTDDI_WIN7)
#error This version of Npcap is not supported on Windows versions older than Windows 7
#endif

/* ++

This is the classifyFn function for the Transport (v4 and v6) callout.
packets (inbound) are queued to the packet queue to be processed
by the worker thread.

-- */
#if(NTDDI_VERSION >= NTDDI_WIN8)
// FWPS_CALLOUT_CLASSIFY_FN2
_IRQL_requires_max_(DISPATCH_LEVEL)
void NPF_NetworkClassifyInbound(
	_In_ const FWPS_INCOMING_VALUES0 *inFixedValues,
	_In_ const FWPS_INCOMING_METADATA_VALUES0 *inMetaValues,
	_Inout_opt_ void *layerData,
	_In_opt_ const void *classifyContext,
	_In_ const FWPS_FILTER2 *filter,
	_In_ UINT64 flowContext,
	_Inout_ FWPS_CLASSIFY_OUT0 *classifyOut
	)
#elif(NTDDI_VERSION >= NTDDI_WIN7)
// FWPS_CALLOUT_CLASSIFY_FN1
_IRQL_requires_max_(DISPATCH_LEVEL)
void
NPF_NetworkClassifyInbound(
	_In_ const FWPS_INCOMING_VALUES0* inFixedValues,
	_In_ const FWPS_INCOMING_METADATA_VALUES0* inMetaValues,
	_Inout_opt_ void* layerData,
	_In_opt_ const void* classifyContext,
	_In_ const FWPS_FILTER1* filter,
	_In_ UINT64 flowContext,
	_Inout_ FWPS_CLASSIFY_OUT0* classifyOut
	)
#endif
{
	PNPCAP_DRIVER_EXTENSION pDrvExt = (PNPCAP_DRIVER_EXTENSION)filter->context;
	PNPCAP_FILTER_MODULE pLoopbackFilter = pDrvExt->pLoopbackFilter;
	NDIS_STATUS status = NDIS_STATUS_SUCCESS;
	UINT32				ipHeaderSize = 0;
	UINT32				bytesRetreated = 0;
	UCHAR uIPv4;
	PNET_BUFFER_LIST	pNetBufferList = (NET_BUFFER_LIST*) layerData;
	FWPS_PACKET_INJECTION_STATE injectionState = FWPS_PACKET_INJECTION_STATE_MAX;

	UNREFERENCED_PARAMETER(classifyContext);
	UNREFERENCED_PARAMETER(flowContext);

	// Make the default action.
	if (classifyOut->rights & FWPS_RIGHT_ACTION_WRITE)
		classifyOut->actionType = FWP_ACTION_CONTINUE;

	TRACE_ENTER();

	if (pLoopbackFilter == NULL || pLoopbackFilter->AdapterBindingStatus != FilterRunning)
	{
		WARNING_DBG("pLoopbackFilter invalid: %p (AdapterBindingStatus: %d)\n",
				pLoopbackFilter, pLoopbackFilter ? pLoopbackFilter->AdapterBindingStatus : 0);
		return;
	}

	if (pNetBufferList == NULL || !NPF_ShouldProcess(inFixedValues, inMetaValues, &uIPv4))
	{
		return;
	}

	if (inMetaValues->currentMetadataValues & FWPS_METADATA_FIELD_IP_HEADER_SIZE)
	{
		ipHeaderSize = inMetaValues->ipHeaderSize;
	}

	injectionState = FwpsQueryPacketInjectionState(pDrvExt->hInject[uIPv4],
		pNetBufferList,
		NULL);
	if (injectionState == FWPS_PACKET_INJECTED_BY_SELF ||
		injectionState == FWPS_PACKET_PREVIOUSLY_INJECTED_BY_SELF)
	{
		INFO_DBG("this packet is injected by ourself, let it go\n");

		TRACE_EXIT();
		return;
	}

	INFO_DBG("inFixedValues->layerId = %u, inMetaValues->currentMetadataValues = 0x%x, inMetaValues->ipHeaderSize = %u, inMetaValues->compartmentId = 0x%x\n",
		inFixedValues->layerId, inMetaValues->currentMetadataValues, inMetaValues->ipHeaderSize, inMetaValues->compartmentId);

	// Inbound: Initial offset is at the Transport Header, so retreat the size of the IP Header.
	// https://docs.microsoft.com/en-us/windows-hardware/drivers/network/data-offset-positions
	status = NdisRetreatNetBufferListDataStart(pNetBufferList,
			ipHeaderSize,
			0,
			NULL,
			NULL);
	bytesRetreated = ipHeaderSize;

	if (status != NDIS_STATUS_SUCCESS)
	{
		INFO_DBG("NdisRetreatNetBufferListDataStart(bytesRetreated) [status: %#x]\n", status);

		TRACE_EXIT();
		return;
	}

	NPF_TapLoopback(pLoopbackFilter, uIPv4 == NPF_INJECT_IPV4, pNetBufferList);

	if (bytesRetreated > 0)
	{
		NdisAdvanceNetBufferListDataStart(pNetBufferList,
				bytesRetreated,
				FALSE,
				0);
		bytesRetreated = 0;
	}

	TRACE_EXIT();
	return;
}

NTSTATUS
NPF_NetworkNotify(
	_In_ FWPS_CALLOUT_NOTIFY_TYPE notifyType,
	_In_ const GUID* filterKey,
	_Inout_ FWPS_FILTER* filter
	)
{
	UNREFERENCED_PARAMETER(filterKey);

	TRACE_ENTER();

	switch (notifyType)
	{
		case FWPS_CALLOUT_NOTIFY_ADD_FILTER:
			filter->context = (UINT64)g_pDriverExtension;
			INFO_DBG("ADD filter, context: %p\n", (PVOID)filter->context);
			break;
		case FWPS_CALLOUT_NOTIFY_DELETE_FILTER:
			INFO_DBG("REMOVE filter, context: %p\n", (PVOID)filter->context);
			break;
		default:
			INFO_DBG("Other notifyType: %d\n", notifyType);
			break;
	}

	TRACE_EXIT();
	return STATUS_SUCCESS;
}

// 
// Callout driver implementation
//
#define IF_ERR_LOG_AND_DO(_Func, _Do) \
	if (!NT_SUCCESS(status)) { \
		ERROR_DBG(#_Func "failed: %08x\n", status); \
		_Do; \
	}

#define IF_ERR_LOG_AND_SKIP(_Func, _Label) IF_ERR_LOG_AND_DO(_Func, goto _Label)

#define IF_ERR_LOG(_Func) IF_ERR_LOG_AND_DO(_Func, do {} while(0))

#define EXIT_IF_ERR(_Func) IF_ERR_LOG_AND_SKIP(_Func, Exit)

#define EXISTS_OR_EXIT_IF_ERR(_Func) \
	if (status == STATUS_FWP_ALREADY_EXISTS) { \
		WARNING_DBG(#_Func " returned STATUS_FWP_ALREADY_EXISTS\n"); \
	} else EXIT_IF_ERR(_Func)


NTSTATUS
NPF_AddFilter(
	_In_ HANDLE WFPEngineHandle,
	_In_ const GUID* layerKey,
	_In_ const GUID* calloutKey
	)
{
	TRACE_ENTER();
	NTSTATUS status = STATUS_SUCCESS;

	FWPM_FILTER filter = { 0 };
	FWPM_FILTER_CONDITION filterConditions[1] = { 0 };
	UINT conditionIndex;

	// Identify this filter so we don't add it multiple times.
	// At the moment, each FWPM callout has only 1 filter. If we add more, make each one unique.
	filter.filterKey = *calloutKey; // GUID matches our callout, but...
	filter.filterKey.Data4[7] = 1; // ...last byte is the ordinal number for this filter.

	filter.layerKey = *layerKey;
	filter.displayData.name = L"Network Npcap Filter (Loopback)";

	filter.action.calloutKey = *calloutKey;
	filter.filterCondition = filterConditions;
	filter.subLayerKey = NPF_SUBLAYER;
	filter.providerKey = (GUID *)&NPF_FWPM_PROVIDER_GUID;
	filter.rawContext = 0;
	conditionIndex = 0;

		filter.action.type = FWP_ACTION_CALLOUT_INSPECTION;
		filter.weight.type = FWP_EMPTY;
		filterConditions[conditionIndex].fieldKey = FWPM_CONDITION_FLAGS;
		filterConditions[conditionIndex].matchType = FWP_MATCH_FLAGS_ALL_SET;
		filterConditions[conditionIndex].conditionValue.type = FWP_UINT32;
		filterConditions[conditionIndex].conditionValue.uint32 = FWP_CONDITION_FLAG_IS_LOOPBACK;
		conditionIndex++;

	filter.numFilterConditions = conditionIndex;

	status = FwpmFilterAdd(
		WFPEngineHandle,
		&filter,
		NULL,
		NULL);
	EXISTS_OR_EXIT_IF_ERR(FwpmFilterAdd);

Exit:
	TRACE_EXIT();
	return status;
}

/*
This function adds callout objects and filters that reference the callout driver
*/
NTSTATUS
NPF_AddCallout(
	_In_ HANDLE WFPEngineHandle,
	_In_ const GUID* layerKey,
	_In_ const GUID* calloutKey
	)
{
	NTSTATUS status = STATUS_SUCCESS;
	FWPM_CALLOUT mCallout = { 0 };
	FWPM_DISPLAY_DATA displayData = { 0 };

	displayData.name = L"Npcap Network Callout";
	displayData.description = L"Npcap loopback network traffic";

	mCallout.calloutKey = *calloutKey;
	mCallout.providerKey = (GUID *)&NPF_FWPM_PROVIDER_GUID;
	mCallout.displayData = displayData;
	mCallout.applicableLayer = *layerKey;

	status = FwpmCalloutAdd(
		WFPEngineHandle,
		&mCallout,
		NULL,
		NULL
		);
	EXISTS_OR_EXIT_IF_ERR(FwpmCalloutAdd);

	status = NPF_AddFilter(WFPEngineHandle, layerKey, calloutKey);
	EXISTS_OR_EXIT_IF_ERR(NPF_AddFilter);

Exit:
	TRACE_EXIT();
	return status;
}

_IRQL_requires_(PASSIVE_LEVEL)
NTSTATUS
NPF_AddCalloutsAndFilters()
/* ++

This function registers dynamic callouts and filters that intercept
transport traffic at ALE AUTH_CONNECT/AUTH_RECV_ACCEPT and
INBOUND/OUTBOUND transport layers.

Callouts and filters will be removed during DriverUnload.

-- */
{
	TRACE_ENTER();
	NTSTATUS status = STATUS_SUCCESS;
	NTSTATUS err = STATUS_SUCCESS;
	HANDLE WFPEngineHandle = NULL;
	FWPM_SUBLAYER NPFSubLayer = {0};

	FWPM_SESSION session = { 0 };
	FWPM_PROVIDER provider = { 0 };

	session.displayData.name = L"Npcap AddCalloutsAndFilters session";

	status = FwpmEngineOpen(
		NULL,
		RPC_C_AUTHN_WINNT,
		NULL,
		&session,
		&WFPEngineHandle
		);
	EXIT_IF_ERR(FwpmEngineOpen);

	status = FwpmTransactionBegin(WFPEngineHandle, 0);
	EXIT_IF_ERR(FwpmTransactionBegin);

#define _WIDE(X) _WIDE2(X)
#define _WIDE2(X) L ## X
#define NPCAP_COMPANY_NAME_W _WIDE(WINPCAP_COMPANY_NAME)
	provider.providerKey = NPF_FWPM_PROVIDER_GUID;
	provider.displayData.name = NPCAP_COMPANY_NAME_W;
	provider.displayData.description = NPF_DRIVER_NAME_NORMAL_WIDECHAR;
	provider.serviceName = NPF_DRIVER_NAME_SMALL_WIDECHAR;
	status = FwpmProviderAdd(WFPEngineHandle, &provider, NULL);
	EXISTS_OR_EXIT_IF_ERR(FwpmProviderAdd);

	NPFSubLayer.subLayerKey = NPF_SUBLAYER;
	NPFSubLayer.displayData.name = L"Npcap Loopback Sub-Layer";
	NPFSubLayer.displayData.description = L"Sub-Layer for use by Npcap Loopback callouts";
	NPFSubLayer.providerKey = (GUID *)&NPF_FWPM_PROVIDER_GUID;
	NPFSubLayer.flags = 0;
	NPFSubLayer.weight = 0; // must be less than the weight of 
	// FWPM_SUBLAYER_UNIVERSAL to be
	// compatible with Vista's IpSec
	// implementation.

	status = FwpmSubLayerAdd(WFPEngineHandle, &NPFSubLayer, NULL);
	EXISTS_OR_EXIT_IF_ERR(FwpmSubLayerAdd);


	status = NPF_AddCallout( WFPEngineHandle,
			&FWPM_LAYER_INBOUND_IPPACKET_V4,
			&NPF_INBOUND_IPPACKET_CALLOUT_V4
			);
	EXISTS_OR_EXIT_IF_ERR(NPF_AddCallout);


	status = NPF_AddCallout( WFPEngineHandle,
			&FWPM_LAYER_INBOUND_IPPACKET_V6,
			&NPF_INBOUND_IPPACKET_CALLOUT_V6
			);
	EXISTS_OR_EXIT_IF_ERR(NPF_AddCallout);

	status = FwpmTransactionCommit(WFPEngineHandle);
	EXIT_IF_ERR(FwpmTransactionCommit);

Exit:
	/* "If this function is called with a transaction in progress, the transaction will be aborted."
	 */
	err = FwpmEngineClose(WFPEngineHandle);
	if (!NT_SUCCESS(err)) {
		ERROR_DBG("FwpmEngineClose: %#08x\n", err);
	}
	_Analysis_assume_lock_not_held_(WFPEngineHandle);

	TRACE_EXIT();
	return status;
}


// Unlike other functions, this one needs to continue even if it gets an error, in order to clean up any remaining items.
void NPF_DeleteFiltersForLayer(
		_In_ HANDLE WFPEngineHandle,
		_In_ const GUID *pLayerKey
		)
{
	// Enumerate and delete all filters
	NTSTATUS status = STATUS_SUCCESS;
	HANDLE hFilterEnum;
	FWPM_FILTER_ENUM_TEMPLATE tmplEnum = {0};
#define NUM_FILTERS_REQ 16
	UINT32 numFilters = 0;
	FWPM_FILTER **filterEntries = NULL;

	tmplEnum.providerKey = (GUID *)&NPF_FWPM_PROVIDER_GUID;
	tmplEnum.actionMask = 0xffffffff;
	tmplEnum.layerKey = *pLayerKey;

	status = FwpmFilterCreateEnumHandle(WFPEngineHandle, &tmplEnum, &hFilterEnum);
	EXIT_IF_ERR(FwpmFilterCreateEnumHandle);

	do {
		status = FwpmFilterEnum(WFPEngineHandle, hFilterEnum, NUM_FILTERS_REQ, &filterEntries, &numFilters);
		IF_ERR_LOG_AND_DO(FwpmFilterEnum, break);

		for (UINT32 i=0; i < numFilters; i++)
		{
			status = FwpmFilterDeleteByKey(WFPEngineHandle, &filterEntries[i]->filterKey);
			IF_ERR_LOG_AND_DO(FwpmFilterDeleteByKey, continue);
		}

		FwpmFreeMemory((VOID **)&filterEntries);
	} while (numFilters == NUM_FILTERS_REQ);

	status = FwpmFilterDestroyEnumHandle(WFPEngineHandle, hFilterEnum);
	IF_ERR_LOG(FwpmFilterDestroyEnumHandle);
Exit:
	return;
}

_IRQL_requires_max_(PASSIVE_LEVEL)
NTSTATUS
NPF_DeleteCalloutsAndFilters(
	_In_ BOOLEAN bUnload
	)
{
	NTSTATUS status = STATUS_SUCCESS;
	NTSTATUS err = STATUS_SUCCESS;
	HANDLE WFPEngineHandle;
	TRACE_ENTER();

	FWPM_SESSION session = { 0 };
	session.displayData.name = L"Npcap DeleteCalloutsAndFilters session";
	status = FwpmEngineOpen(
		NULL,
		RPC_C_AUTHN_WINNT,
		NULL,
		&session,
		&WFPEngineHandle
		);
	EXIT_IF_ERR(FwpmEngineOpen);

	status = FwpmTransactionBegin(WFPEngineHandle, 0);
	EXIT_IF_ERR(FwpmTransactionBegin);

	NPF_DeleteFiltersForLayer(WFPEngineHandle, &FWPM_LAYER_INBOUND_IPPACKET_V4);
	NPF_DeleteFiltersForLayer(WFPEngineHandle, &FWPM_LAYER_INBOUND_IPPACKET_V6);

	// Now all the filters are gone, we can delete the callouts

	status = FwpmCalloutDeleteByKey(WFPEngineHandle,
			&NPF_INBOUND_IPPACKET_CALLOUT_V4);
	IF_ERR_LOG(FwpmCalloutDeleteByKey);

	status = FwpmCalloutDeleteByKey(WFPEngineHandle,
			&NPF_INBOUND_IPPACKET_CALLOUT_V6);
	IF_ERR_LOG(FwpmCalloutDeleteByKey);

	// Provider and sublayer can persist and only have to be cleaned up at driver unload.
	if (bUnload)
	{
		status = FwpmSubLayerDeleteByKey(WFPEngineHandle, &NPF_SUBLAYER);
		IF_ERR_LOG(FwpmSubLayerDeleteByKey);

		status = FwpmProviderDeleteByKey(WFPEngineHandle, &NPF_FWPM_PROVIDER_GUID);
		IF_ERR_LOG(FwpmProviderDeleteByKey);
	}

	status = FwpmTransactionCommit(WFPEngineHandle);
	EXIT_IF_ERR(FwpmTransactionCommit);

Exit:
	err = FwpmEngineClose(WFPEngineHandle);
	if (!NT_SUCCESS(err)) {
		ERROR_DBG("FwpmEngineClose: %#08x\n", err);
	}
	_Analysis_assume_lock_not_held_(WFPEngineHandle);

	TRACE_EXIT();
	return status;
}

NTSTATUS
NPF_WFPCalloutRegister()
/* ++

Open injection handles (IPv4 and IPv6) for use with the various injection APIs.

injection handles will be removed during DriverUnload.

-- */
{
	NTSTATUS status = STATUS_SUCCESS;
	FWPS_CALLOUT sCallout = { 0 };

	TRACE_ENTER();

	status = FwpsInjectionHandleCreate(AF_INET,
			FWPS_INJECTION_TYPE_NETWORK,
			&g_pDriverExtension->hInject[NPF_INJECT_IPV4]);
	EXIT_IF_ERR(FwpsInjectionHandleCreate_V4);

	status = FwpsInjectionHandleCreate(AF_INET6,
			FWPS_INJECTION_TYPE_NETWORK,
			&g_pDriverExtension->hInject[NPF_INJECT_IPV6]);
	EXIT_IF_ERR(FwpsInjectionHandleCreate_V6);

	// These are the same for all callouts
	sCallout.notifyFn = NPF_NetworkNotify;
	sCallout.flags = FWP_CALLOUT_FLAG_ALLOW_OFFLOAD
#if(NTDDI_VERSION >= NTDDI_WIN8)
		| FWP_CALLOUT_FLAG_ALLOW_RSC
#if (NTDDI_VERSION >= NTDDI_WIN10_19H1)
		| FWP_CALLOUT_FLAG_ALLOW_USO
#if (NTDDI_VERSION >= NTDDI_WIN10_VB)
		| FWP_CALLOUT_FLAG_ALLOW_URO
#endif
#endif
#endif
		;

	// Inbound
	sCallout.classifyFn = NPF_NetworkClassifyInbound;
	// - IPv4
	sCallout.calloutKey = NPF_INBOUND_IPPACKET_CALLOUT_V4;
	status = FwpsCalloutRegister(
		g_pDriverExtension->pNpcapDeviceObject,
		&sCallout,
		&g_pDriverExtension->uCalloutInboundV4
		);
	EXISTS_OR_EXIT_IF_ERR(FwpsCalloutRegister);
	// - IPv6
	sCallout.calloutKey = NPF_INBOUND_IPPACKET_CALLOUT_V6;
	status = FwpsCalloutRegister(
		g_pDriverExtension->pNpcapDeviceObject,
		&sCallout,
		&g_pDriverExtension->uCalloutInboundV6
		);
	EXISTS_OR_EXIT_IF_ERR(FwpsCalloutRegister);

Exit:
	if (!NT_SUCCESS(status) && status != STATUS_FWP_ALREADY_EXISTS) {
		NPF_WFPCalloutUnregister();
	}

	TRACE_EXIT();
	return status;
}

VOID
NPF_WFPCalloutUnregister()
{
	NTSTATUS status = STATUS_SUCCESS;

	TRACE_ENTER();
#define _DESTROY_FWPS_OBJ(_Obj, _Dtor) \
	if (_Obj) { \
		status = _Dtor(_Obj); \
		INFO_DBG(#_Dtor "(" #_Obj "): %#08x\n", status); \
		_Obj = 0; \
	}

	_DESTROY_FWPS_OBJ(g_pDriverExtension->hInject[NPF_INJECT_IPV6], FwpsInjectionHandleDestroy);
	_DESTROY_FWPS_OBJ(g_pDriverExtension->hInject[NPF_INJECT_IPV4], FwpsInjectionHandleDestroy);
	_DESTROY_FWPS_OBJ(g_pDriverExtension->uCalloutInboundV4, FwpsCalloutUnregisterById);
	_DESTROY_FWPS_OBJ(g_pDriverExtension->uCalloutInboundV6, FwpsCalloutUnregisterById);

	TRACE_EXIT();
}

_Use_decl_annotations_
NTSTATUS
NPF_InitWFP()
{
	NTSTATUS status = KeWaitForMutexObject(&g_pDriverExtension->WFPInitMutex, Executive, KernelMode, FALSE, NULL);
	if (status != STATUS_SUCCESS)
	{
		ERROR_DBG("Failed to get WFPInitMutex: %#08x\n", status);
		// Failed to get the mutex. Report exact error unless it's a "success" value
		_Analysis_assume_lock_not_held_(g_pDriverExtension->WFPInitMutex);
		return NT_SUCCESS(status) ? STATUS_LOCK_NOT_GRANTED : status;
	}
	INFO_DBG("bWFPInit %u -> 1\n", g_pDriverExtension->bWFPInit);
	if (g_pDriverExtension->bWFPInit)
	{
		goto Exit;
	}

	status = NPF_AddCalloutsAndFilters();
	EXISTS_OR_EXIT_IF_ERR(NPF_AddCalloutsAndFilters);

	g_pDriverExtension->bWFPInit = 1;

Exit:
	KeReleaseMutex(&g_pDriverExtension->WFPInitMutex, FALSE);

	return status;
}

_Use_decl_annotations_
VOID
NPF_ReleaseWFP(BOOLEAN bUnload)
{
	NTSTATUS status = KeWaitForMutexObject(&g_pDriverExtension->WFPInitMutex, Executive, KernelMode, FALSE, NULL);
	if (status != STATUS_SUCCESS)
	{
		ERROR_DBG("Failed to get WFPInitMutex: %#08x\n", status);
		// Failed to get the mutex.
		_Analysis_assume_lock_not_held_(g_pDriverExtension->WFPInitMutex);
		return;
	}
	INFO_DBG("bWFPInit %u -> 0\n", g_pDriverExtension->bWFPInit);
	if (!g_pDriverExtension->bWFPInit)
	{
		goto Exit;
	}

	status = NPF_DeleteCalloutsAndFilters(bUnload);
	EXIT_IF_ERR(NPF_DeleteCalloutsAndFilters);

	g_pDriverExtension->bWFPInit = 0;

Exit:
	KeReleaseMutex(&g_pDriverExtension->WFPInitMutex, FALSE);

	return;
}

#endif // HAVE_WFP_LOOPBACK_SUPPORT

```

`packetWin7/npf/npf/Loopback.h`:

```h
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
/*
* Loopback.h
*
* Abstract:
* This file declares common data types and function prototypes used
* throughout loopback packets capturing.
*
* This code is based on Microsoft WFP Network Inspect sample.
*/

#ifndef __LOOPBACK
#define __LOOPBACK

#ifdef HAVE_WFP_LOOPBACK_SUPPORT

// Shared function prototypes

// Register callout driver callouts and init injection handles, once at driver load
NTSTATUS
NPF_WFPCalloutRegister();
// Unregister callout driver and free injection handles, once at driver unload
VOID
NPF_WFPCalloutUnregister();

// Add callout object and filter for loopback
_IRQL_requires_(PASSIVE_LEVEL)
NTSTATUS
NPF_InitWFP();

// Remove callout object and filter for loopback
_IRQL_requires_(PASSIVE_LEVEL)
VOID
NPF_ReleaseWFP(_In_ BOOLEAN bUnload);
#endif // HAVE_WFP_LOOPBACK_SUPPORT

#endif // __LOOPBACK

```

`packetWin7/npf/npf/Openclos.c`:

```c
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
/*
* Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)
* Copyright (c) 2005 - 2010 CACE Technologies, Davis (California)
* Copyright (c) 2010 - 2013 Riverbed Technology, San Francisco (California), Yang Luo (China)
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
*
* 1. Redistributions of source code must retain the above copyright
* notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
* notice, this list of conditions and the following disclaimer in the
* documentation and/or other materials provided with the distribution.
* 3. Neither the name of the Politecnico di Torino, CACE Technologies
* nor the names of its contributors may be used to endorse or promote
* products derived from this software without specific prior written
* permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
* A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
*/

#include "stdafx.h"

#include "Packet.h"
#include "Loopback.h"
#include "..\..\..\Common\WpcapNames.h"

extern PNPCAP_DRIVER_EXTENSION g_pDriverExtension;

/*!
  \brief Add the open context to the group open array of a filter module.
  \param pOpen Pointer to open context structure.
  \param pFiltMod Pointer to filter module context structure.

  This function is used by NPF_OpenAdapter to add a new open context to
  the group open array of a filter module, this array is designed to help find and clean the specific adapter context.
  A filter module context is generated by NPF_AttachAdapter(), it handles with NDIS.
  A open instance is generated by NPF_OpenAdapter(), it handles with the WinPcap
  up-level packet.dll and so on.
*/
_When_(bAtDispatchLevel != 0, _IRQL_requires_(DISPATCH_LEVEL))
void
NPF_AddToGroupOpenArray(
	_In_ POPEN_INSTANCE pOpen,
	_In_ PNPCAP_FILTER_MODULE pFiltMod,
	_In_ BOOLEAN bAtDispatchLevel
	);

/*!
  \brief Remove the filter module context from the global filter module array.
  \param pFiltMod Pointer to filter module context structure.

  This function is used by NPF_DetachAdapter(), NPF_Cleanup() and NPF_CleanupForUnclosed()
  to remove a filter module context from the global filter module array.
*/
void
NPF_RemoveFromFilterModuleArray(
	_Inout_ PNPCAP_FILTER_MODULE pFiltMod
	);

/*!
  \brief Get a pointer to filter module from the global array.
  \param pAdapterName The adapter name of the target filter module.
  \return Pointer to the filter module, or NULL if not found.

  This function is used to create a group member adapter for the group head one.
*/
_Ret_maybenull_
PNPCAP_FILTER_MODULE
NPF_GetFilterModuleByAdapterName(
	_In_ PNDIS_STRING pAdapterName
	);

/*!
  \brief Create a new Open instance
  \return Pointer to the new open instance.

*/

_Must_inspect_result_
_Success_(return != NULL)
__drv_allocatesMem(mem)
__declspec(restrict) POPEN_INSTANCE
NPF_CreateOpenObject(
	_In_ NDIS_HANDLE NdisHandle
	);

#ifdef HAVE_DOT11_SUPPORT
_IRQL_requires_(PASSIVE_LEVEL)
NTSTATUS NPF_GetDataRateMappingTable(
	_In_ PNPCAP_FILTER_MODULE pFiltMod
	);

_IRQL_requires_(PASSIVE_LEVEL)
NTSTATUS NPF_GetCurrentOperationMode(
	_In_ PNPCAP_FILTER_MODULE pFiltMod,
	_Out_ PDOT11_CURRENT_OPERATION_MODE pCurrentOperationMode);

_IRQL_requires_(PASSIVE_LEVEL)
ULONG NPF_GetCurrentOperationMode_Wrapper(
	_In_ PNPCAP_FILTER_MODULE pFiltMod);

#endif
//-------------------------------------------------------------------

_Use_decl_annotations_
BOOLEAN
NPF_IsOpenInstance(
	POPEN_INSTANCE pOpen
	)
{
	if (pOpen == NULL)
	{
		return FALSE;
	}
	if (pOpen->OpenSignature != OPEN_SIGNATURE)
	{
		return FALSE;
	}
	return TRUE;
}

_Use_decl_annotations_
BOOLEAN
NPF_StartUsingBinding(
	PNPCAP_FILTER_MODULE pFiltMod, BOOLEAN AtDispatchLevel
	)
{
	if (!pFiltMod) {
		return FALSE;
	}
	// NPF_OpenAdapter() is not called on PASSIVE_LEVEL, so the assertion will fail.
	// ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

	FILTER_ACQUIRE_LOCK(&pFiltMod->AdapterHandleLock, AtDispatchLevel);

	if (pFiltMod->AdapterBindingStatus != FilterRunning)
	{
		FILTER_RELEASE_LOCK(&pFiltMod->AdapterHandleLock, AtDispatchLevel);
		return FALSE;
	}

	pFiltMod->AdapterHandleUsageCounter++;

	FILTER_RELEASE_LOCK(&pFiltMod->AdapterHandleLock, AtDispatchLevel);

	return TRUE;
}

//-------------------------------------------------------------------

_Use_decl_annotations_
VOID
NPF_StopUsingBinding(
	PNPCAP_FILTER_MODULE pFiltMod, BOOLEAN AtDispatchLevel
	)
{
	NT_ASSERT(pFiltMod != NULL);
	//
	//  There is no risk in calling this function from abobe passive level
	//  (i.e. DISPATCH, in this driver) as we acquire a spinlock and decrement a
	//  counter.
	//
	//	ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

	FILTER_ACQUIRE_LOCK(&pFiltMod->AdapterHandleLock, AtDispatchLevel);

	NT_ASSERT(pFiltMod->AdapterHandleUsageCounter > 0);

	pFiltMod->AdapterHandleUsageCounter--;

	FILTER_RELEASE_LOCK(&pFiltMod->AdapterHandleLock, AtDispatchLevel);
}

//-------------------------------------------------------------------

_Use_decl_annotations_
VOID
NPF_ResetBufferContents(
	POPEN_INSTANCE Open,
	BOOLEAN AcquireLock
)
{
	LOCK_STATE_EX lockState;
	PLIST_ENTRY Curr;
	PNPF_CAP_DATA pCapData;

	if (AcquireLock)
		NdisAcquireRWLockWrite(Open->BufferLock, &lockState, 0);
	Open->Accepted = 0;
	Open->Dropped = 0;
	Open->Received = 0;

	// Clear packets from the buffer
	Curr = Open->PacketQueue.Flink;
	while (Curr != &Open->PacketQueue)
	{
		NT_ASSERT(Curr != NULL);
		pCapData = CONTAINING_RECORD(Curr, NPF_CAP_DATA, PacketQueueEntry);
		Curr = Curr->Flink;

		NPF_ReturnCapData(pCapData);
	}
	// Remove links
	InitializeListHead(&Open->PacketQueue);
	// Reset Free counter
	Open->Free = Open->Size;
	if (AcquireLock)
		NdisReleaseRWLock(Open->BufferLock, &lockState);
}

_Use_decl_annotations_
VOID NPF_ReturnNBCopies(PNPF_NB_COPIES pNBCopy)
{
	PVOID pDeleteMe = pNBCopy->Buffer;
	LONG refcount = NpfInterlockedDecrement(&pNBCopy->refcount);
	NT_ASSERT(refcount >= 0);
	if (refcount == 0)
	{
		if (pDeleteMe != NULL)
		{
			NT_ASSERT(pNBCopy->ulSize > 0);
			ExFreePoolWithTag(pDeleteMe, NPF_PACKET_DATA_TAG);
		}
		ExFreeToLookasideListEx(&g_pDriverExtension->NBCopiesPool, pNBCopy);
	}
}

_Use_decl_annotations_
VOID NPF_ReturnNBLCopy(PNPF_NBL_COPY pNBLCopy)
{
	PUCHAR pDot11RadiotapHeader = pNBLCopy->Dot11RadiotapHeader;
	LONG refcount = NpfInterlockedDecrement(&pNBLCopy->refcount);
	NT_ASSERT(refcount >= 0);
	if (refcount == 0)
	{
		ExFreeToLookasideListEx(&g_pDriverExtension->NBLCopyPool, pNBLCopy);
		if (pDot11RadiotapHeader != NULL)
		{
			ExFreeToLookasideListEx(&g_pDriverExtension->Dot11HeaderPool, pDot11RadiotapHeader);
		}
	}
}

_Use_decl_annotations_
VOID NPF_ReturnCapData(PNPF_CAP_DATA pCapData)
{
	PNPF_NB_COPIES pNBCopy = pCapData->pNBCopy;
	PNPF_NBL_COPY pNBLCopy = (pNBCopy ? pNBCopy->pNBLCopy : NULL);
	ExFreeToLookasideListEx(&g_pDriverExtension->CapturePool, pCapData);
	if (pNBLCopy)
	{
		NPF_ReturnNBLCopy(pNBLCopy);
	}
	if (pNBCopy)
	{
		NPF_ReturnNBCopies(pNBCopy);
	}
}

//-------------------------------------------------------------------

VOID
NPF_AddToAllOpensList(_In_ POPEN_INSTANCE pOpen)
{
	LOCK_STATE_EX lockState;

	NdisAcquireRWLockWrite(g_pDriverExtension->AllOpensLock, &lockState, 0);
	InsertTailList(&g_pDriverExtension->AllOpens, &pOpen->AllOpensEntry);
	NdisReleaseRWLock(g_pDriverExtension->AllOpensLock, &lockState);
}

VOID
NPF_RemoveFromAllOpensList(_In_ POPEN_INSTANCE pOpen)
{
	LOCK_STATE_EX lockState;

	NdisAcquireRWLockWrite(g_pDriverExtension->AllOpensLock, &lockState, 0);
	RemoveEntryList(&pOpen->AllOpensEntry);
	NdisReleaseRWLock(g_pDriverExtension->AllOpensLock, &lockState);
}

_Use_decl_annotations_
NTSTATUS
NPF_OpenAdapter(
	PDEVICE_OBJECT DeviceObject,
	PIRP Irp
	)
{
	PNPCAP_FILTER_MODULE			pFiltMod = NULL;
	POPEN_INSTANCE			Open;
	PIO_STACK_LOCATION		IrpSp;
	ULONG idx;
	PUNICODE_STRING FileName;
	NDIS_HANDLE NdisFilterHandle = g_pDriverExtension->FilterDriverHandle;

	TRACE_ENTER();

	IrpSp = IoGetCurrentIrpStackLocation(Irp);

	// I/O manager should not be handing us IRPs until DriverEntry returns,
	// but we can exercise healthy paranoia
	if (!NT_VERIFY(NdisFilterHandle) || !NT_VERIFY(g_pDriverExtension->AllOpensLock))
	{
		Irp->IoStatus.Status = STATUS_DEVICE_NOT_READY;
		IoCompleteRequest(Irp, IO_NO_INCREMENT);
		TRACE_EXIT();
		return STATUS_DEVICE_NOT_READY;
	}

	FileName = &IrpSp->FileObject->FileName;
	// Skip leading slashes
	for (idx = 0; idx < FileName->Length && FileName->Buffer[idx] == L'\\'; idx++);
	// If the filename is empty or all slashes, this is a request for the "root" device.
	// Otherwise, look for a filter module for it.
	if (idx != FileName->Length)
	{
		// Find the head adapter of the global array.
		pFiltMod = NPF_GetFilterModuleByAdapterName(&IrpSp->FileObject->FileName);

		if (pFiltMod == NULL)
		{
			// Can't find the adapter from the global open array.
			INFO_DBG(
				"NPF_GetFilterModuleByAdapterName error, pFiltMod=NULL, AdapterName=%ws",
				IrpSp->FileObject->FileName.Buffer);

			Irp->IoStatus.Status = STATUS_NDIS_INTERFACE_NOT_FOUND;
			Irp->IoStatus.Information = FILE_DOES_NOT_EXIST;
			IoCompleteRequest(Irp, IO_NO_INCREMENT);
			TRACE_EXIT();
			return STATUS_NDIS_INTERFACE_NOT_FOUND;
		}

		if (NPF_StartUsingBinding(pFiltMod, NPF_IRQL_UNKNOWN) == FALSE)
		{
			INFO_DBG(
				"NPF_StartUsingBinding error, AdapterName=%ws",
				IrpSp->FileObject->FileName.Buffer);

			Irp->IoStatus.Status = STATUS_NDIS_OPEN_FAILED;
			IoCompleteRequest(Irp, IO_NO_INCREMENT);
			TRACE_EXIT();
			return STATUS_NDIS_OPEN_FAILED;
		}

		NdisFilterHandle = pFiltMod->AdapterHandle;
	}

	// Create a group child adapter object from the head adapter.
	Open = NPF_CreateOpenObject(NdisFilterHandle);
	if (Open == NULL)
	{
		if (pFiltMod)
			NPF_StopUsingBinding(pFiltMod, NPF_IRQL_UNKNOWN);
		Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
		IoCompleteRequest(Irp, IO_NO_INCREMENT);
		TRACE_EXIT();
		return STATUS_INSUFFICIENT_RESOURCES;
	}
	Open->UserPID = IoGetRequestorProcessId(Irp);

	INFO_DBG(
		"Open(%p) name=%ws, Loopback=%d\n",
		Open,
		IrpSp->FileObject->FileName.Buffer,
		pFiltMod ? pFiltMod->Loopback : 0);

	IrpSp->FileObject->FsContext = Open;

	NPF_AddToAllOpensList(Open);

	//
	// complete the open
	//

	if (pFiltMod)
	{
		// Initializes pFiltMod, AdapterID, bDot11, bLoopback, OpenStatus
		NPF_AddToGroupOpenArray(Open, pFiltMod, FALSE);
		NPF_StopUsingBinding(pFiltMod, NPF_IRQL_UNKNOWN);
	}

	Irp->IoStatus.Status = STATUS_SUCCESS;
	Irp->IoStatus.Information = FILE_OPENED;
	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	TRACE_EXIT();
	return STATUS_SUCCESS;
}

//-------------------------------------------------------------------
_IRQL_requires_(PASSIVE_LEVEL)
NTSTATUS NPF_EnableOps(_In_ PNPCAP_FILTER_MODULE pFiltMod)
{
	NTSTATUS Status = STATUS_PENDING;
	NDIS_EVENT Event;

	if (pFiltMod == NULL)
	{
		return STATUS_INVALID_DEVICE_REQUEST;
	}

	NdisAcquireSpinLock(&pFiltMod->AdapterHandleLock);
	switch(pFiltMod->OpsState)
	{
		case OpsEnabled:
			// Already good to go;
			Status = STATUS_SUCCESS;
			break;
		case OpsEnabling:
		case OpsDisabling:
			NdisInitializeEvent(&Event);
			NdisResetEvent(&Event);
			// Wait for other thread to finish enabling
			while (pFiltMod->OpsState == OpsEnabling || pFiltMod->OpsState == OpsDisabling)
			{
				NdisReleaseSpinLock(&pFiltMod->AdapterHandleLock);
				NdisWaitEvent(&Event, 1);
				NdisAcquireSpinLock(&pFiltMod->AdapterHandleLock);
			}
			if (pFiltMod->OpsState == OpsEnabled)
			{
				Status = STATUS_SUCCESS;
				break;
			}
			else if (pFiltMod->OpsState != OpsDisabled)
			{
				Status = STATUS_DRIVER_INTERNAL_ERROR;
				break;
			}
			// else drop through to OpsDisabled:
		case OpsDisabled:
			// Time to get to work
			pFiltMod->OpsState = OpsEnabling;
			break;
		default:
			Status = STATUS_INVALID_DEVICE_STATE;
	}
	NdisReleaseSpinLock(&pFiltMod->AdapterHandleLock);

	if (Status != STATUS_PENDING)
	{
		return Status;
	}

	Status = STATUS_SUCCESS;
	do
	{

#ifdef HAVE_DOT11_SUPPORT
		// DataRateMappingTable
		if (pFiltMod->Dot11)
		{
			// Fetch the device's data rate mapping table with the OID_DOT11_DATA_RATE_MAPPING_TABLE OID.
			if (!NT_SUCCESS(NPF_GetDataRateMappingTable(pFiltMod)))
			{
				INFO_DBG("pFiltMod(%p) failed to fetch dot11 table.\n", pFiltMod);
			}
		}
#endif

#ifdef HAVE_WFP_LOOPBACK_SUPPORT
		if (pFiltMod->Loopback)
		{
			Status = NPF_InitWFP();
			if (!NT_SUCCESS(Status)) {
				break;
			}
		}
#endif
	} while (0);

	pFiltMod->OpsState = NT_SUCCESS(Status) ? OpsEnabled : OpsDisabled;
	return Status;
}

_Use_decl_annotations_
VOID
NPF_RegisterBpf(
	PNPCAP_FILTER_MODULE pFiltMod,
	PNPCAP_BPF_PROGRAM pBpfProgram)
{
	// Assert/verify pBpfProgram fields are set
	LOCK_STATE_EX lockState;

	NT_ASSERT(pBpfProgram->pOpen != NULL);
	NT_ASSERT(pBpfProgram->pOpen->pFiltMod == pFiltMod);

	PLIST_ENTRY pNewEntry = &pBpfProgram->BpfProgramsEntry;
	// If the program is already in the list, nothing more to do
	if (pNewEntry->Flink != NULL && NT_VERIFY(pNewEntry->Blink != NULL))
	{
		// In debug mode we can take the time to verify
#if defined(_DBG)
		for (PLIST_ENTRY Curr = pFiltMod->BpfPrograms.Flink;
				Curr != &pFiltMod->BpfPrograms;
				Curr = Curr->Flink)
		{
			if (Curr == pNewEntry)
			{
				return;
			}
		}
		NT_ASSERT(FALSE);
#endif
		return;
	}

	NT_ASSERT(pNewEntry->Flink == NULL && pNewEntry->Blink == NULL);

	// Lock the BpfPrograms list
	NdisAcquireRWLockWrite(pFiltMod->BpfProgramsLock, &lockState, 0);
	// Insert the bpf for this open instance
	InsertTailList(&pFiltMod->BpfPrograms, pNewEntry);
	// Update accounting
	NpfInterlockedIncrement(&pFiltMod->BpfCount);
	// Unlock the list
	NdisReleaseRWLock(pFiltMod->BpfProgramsLock, &lockState);
}

_Use_decl_annotations_
VOID
NPF_UnregisterBpf(
	PNPCAP_FILTER_MODULE pFiltMod,
	PNPCAP_BPF_PROGRAM pBpfProgram)
{
	LOCK_STATE_EX lockState;
	if (pBpfProgram == NULL ||
			(pBpfProgram->BpfProgramsEntry.Flink == NULL &&
			 NT_VERIFY(pBpfProgram->BpfProgramsEntry.Blink == NULL)))
	{
		return;
	}
	NT_ASSERT(pBpfProgram->BpfProgramsEntry.Blink != NULL);
	// Lock the BpfPrograms list
	NdisAcquireRWLockWrite(pFiltMod->BpfProgramsLock, &lockState, 0);
	// In debug mode we can take the time to verify
#if defined(_DBG)
	BOOLEAN bFound = FALSE;
	for (PLIST_ENTRY Curr = pFiltMod->BpfPrograms.Flink;
			Curr != &pFiltMod->BpfPrograms;
			Curr = Curr->Flink)
	{
		if (Curr == &pBpfProgram->BpfProgramsEntry)
		{
			bFound = TRUE;
			break;
		}
	}
	NT_ASSERT(bFound);
#endif
	// remove the bpf for this open instance
	RemoveEntryList(&pBpfProgram->BpfProgramsEntry);
	// Update accounting
	NpfInterlockedDecrement(&pFiltMod->BpfCount);
	// Unlock the list
	NdisReleaseRWLock(pFiltMod->BpfProgramsLock, &lockState);

	// Make sure we know this has been removed
	pBpfProgram->BpfProgramsEntry.Flink = NULL;
	pBpfProgram->BpfProgramsEntry.Blink = NULL;
}

/* State table. SUCCESS = PendingIrps[MaxState]++
 *               \  MaxState
 *                \ --------
 * OpenStatus      \  OpenRunning | OpenInitializing | OpenAttached | OpenDetached | OpenClosed
 * -----------------|-------------|------------------|--------------|--------------|-----------
 * OpenRunning      | SUCCESS     | BUG              | SUCCESS      | SUCCESS      | BUG
 * OpenInitializing | Wait        | BUG              | SUCCESS      | SUCCESS      | BUG
 * OpenAttached     | EnableOps   | BUG              | SUCCESS      | SUCCESS      | BUG
 * OpenDetached     | FAIL        | BUG              | FAIL         | SUCCESS      | BUG
 * OpenClosed       | FAIL        | BUG              | FAIL         | FAIL         | BUG
 */
_Use_decl_annotations_
BOOLEAN
NPF_StartUsingOpenInstance(
	POPEN_INSTANCE pOpen, OPEN_STATE MaxState, BOOLEAN AtDispatchLevel)
{
	BOOLEAN returnStatus = TRUE;
	BOOLEAN bAttached = FALSE;
	NDIS_EVENT Event;

	if (!NT_VERIFY(MaxState < OpenClosed && MaxState != OpenInitializing))
	{
		ERROR_DBG("Invalid MaxState: %d\n", MaxState);
		return FALSE;
	}

	// Check if it's closing; no need to lock for this, since aligned reads are atomic
	if (pOpen->OpenStatus >= OpenClosed)
	{
		WARNING_DBG("pOpen %p is closing (OpenStatus: %d)\n", pOpen, pOpen->OpenStatus);
		return FALSE;
	}

	// Have to hold this lock before checking/using pOpen->pFiltMod
	FILTER_ACQUIRE_LOCK(&pOpen->OpenInUseLock, AtDispatchLevel);

	// Do we need an attached adapter?
	if (MaxState <= OpenAttached)
	{
		bAttached = (pOpen->pFiltMod != NULL && NPF_StartUsingBinding(pOpen->pFiltMod, TRUE));
		if (!bAttached)
		{
			// Not attached, but need to be.
			FILTER_RELEASE_LOCK(&pOpen->OpenInUseLock, AtDispatchLevel);
			WARNING_DBG("Not attached: pFiltMod = %p\n", pOpen->pFiltMod);
			return FALSE;
		}
	}

	if (MaxState == OpenRunning)
	{
		// NPF_EnableOps must be called at PASSIVE_LEVEL. Release the lock first.
		NT_ASSERT(!AtDispatchLevel);
		if (AtDispatchLevel) {
			// This is really bad! We should never be able to get here.
			ERROR_DBG("CRITICAL ERROR: called at DISPATCH_LEVEL\n");
			returnStatus = FALSE;
		}
		else if (pOpen->OpenStatus == OpenAttached)
		{
			pOpen->OpenStatus = OpenInitializing;
			FILTER_RELEASE_LOCK(&pOpen->OpenInUseLock, AtDispatchLevel);
			returnStatus = NT_SUCCESS(NPF_EnableOps(pOpen->pFiltMod));
			FILTER_ACQUIRE_LOCK(&pOpen->OpenInUseLock, AtDispatchLevel);

			if (returnStatus)
			{
				// Get the absolute value of the system boot time.
				// This is used for timestamp conversion.
				TIME_SYNCHRONIZE(&pOpen->start);

				// Insert a null filter (accept all)
				NPF_RegisterBpf(pOpen->pFiltMod, pOpen->BpfProgram);
				pOpen->OpenStatus = OpenRunning;
			}
			else
			{
				pOpen->OpenStatus = OpenAttached;
			}
		}
		else if (pOpen->OpenStatus == OpenInitializing)
		{
			// Wait until it's ready...
			NdisInitializeEvent(&Event);
			NdisResetEvent(&Event);
			// Wait for other thread to finish enabling
			while (pOpen->OpenStatus == OpenInitializing)
			{
				FILTER_RELEASE_LOCK(&pOpen->OpenInUseLock, AtDispatchLevel);
				INFO_DBG("Waiting, OpenStatus = %d\n", pOpen->OpenStatus);
				NdisWaitEvent(&Event, 1);
				FILTER_ACQUIRE_LOCK(&pOpen->OpenInUseLock, AtDispatchLevel);
			}
		}
	}

	INFO_DBG("OpenStatus = %d; MaxState = %d\n", pOpen->OpenStatus, MaxState);
	returnStatus = returnStatus && (pOpen->OpenStatus <= MaxState);
	if (returnStatus)
	{
		NT_ASSERT(MaxState < OpenClosed); // No IRPs can be pending for OpenClosed or higher state.
		pOpen->PendingIrps[MaxState]++;
	}
	else if (bAttached)
	{
		// Failed to change OpenStatus, so have to release/deref the adapter binding, too.
		NPF_StopUsingBinding(pOpen->pFiltMod, TRUE);
	}
	FILTER_RELEASE_LOCK(&pOpen->OpenInUseLock, AtDispatchLevel);

	return returnStatus;
}

//-------------------------------------------------------------------

_Use_decl_annotations_
VOID
NPF_StopUsingOpenInstance(
	POPEN_INSTANCE pOpen,
	OPEN_STATE MaxState,
	BOOLEAN AtDispatchLevel
	)
{
	FILTER_ACQUIRE_LOCK(&pOpen->OpenInUseLock, AtDispatchLevel);
	NT_ASSERT(MaxState < OpenClosed);
	NT_ASSERT(pOpen->PendingIrps[MaxState] > 0);
	pOpen->PendingIrps[MaxState]--;

	if (MaxState <= OpenAttached)
	{
		NPF_StopUsingBinding(pOpen->pFiltMod, AtDispatchLevel);
	}
	FILTER_RELEASE_LOCK(&pOpen->OpenInUseLock, AtDispatchLevel);
}

//-------------------------------------------------------------------

_Use_decl_annotations_
OPEN_STATE
NPF_DemoteOpenStatus(
	POPEN_INSTANCE pOpen,
	OPEN_STATE NewState
	)
{
	if (pOpen->OpenStatus == OpenClosed) {
		// No change
		return OpenClosed;
	}
	OPEN_STATE OldState = InterlockedExchange((LONG *)&pOpen->OpenStatus, (LONG) NewState);

	NT_ASSERT(NewState > OldState);
	INFO_DBG("Open %p: %d -> %d\n", pOpen, OldState, NewState);
	if (OldState == OpenRunning)
	{
		NPF_UnregisterBpf(pOpen->pFiltMod, pOpen->BpfProgram);
	}

	return OldState;
}

//-------------------------------------------------------------------

_IRQL_requires_(PASSIVE_LEVEL)
VOID NPF_OpenWaitPendingIrps(
		_At_(pOpen->OpenStatus, _In_range_(OpenDetached,OpenClosed))
	_In_ POPEN_INSTANCE pOpen
	)
{
	NDIS_EVENT Event;
	OPEN_STATE state;

	NdisInitializeEvent(&Event);
	NdisResetEvent(&Event);

	NdisAcquireSpinLock(&pOpen->OpenInUseLock);
	NT_ASSERT(pOpen->OpenStatus <= OpenClosed);
	NT_ASSERT(pOpen->OpenStatus >= OpenDetached);

	// Wait for IRPs that require an attached adapter
	for (state = pOpen->OpenStatus - 1; state < pOpen->OpenStatus && state >= OpenRunning; state--)
	{
		while (pOpen->PendingIrps[state] > 0)
		{
			INFO_DBG("Open %p: %lu pending IRPS at %d\n", pOpen, pOpen->PendingIrps[state], state);
			NdisReleaseSpinLock(&pOpen->OpenInUseLock);
			NdisWaitEvent(&Event, 1);
			NdisAcquireSpinLock(&pOpen->OpenInUseLock);
		}
	}
	NdisReleaseSpinLock(&pOpen->OpenInUseLock);
}

//-------------------------------------------------------------------

_Use_decl_annotations_
VOID
NPF_ReleaseOpenInstanceResources(
	POPEN_INSTANCE pOpen
	)
{

	TRACE_ENTER();

	NT_ASSERT(pOpen != NULL);
	NT_ASSERT(pOpen->OpenStatus == OpenClosed);

	INFO_DBG("Open= %p\n", pOpen);


	//
	// Free the filter if it's present
	//
	if (pOpen->BpfProgram != NULL)
	{
		ExFreePool(pOpen->BpfProgram);
		pOpen->BpfProgram = NULL;
	}

	//
	// Dereference the read event.
	//

	if (pOpen->ReadEvent != NULL)
	{
		ObDereferenceObject(pOpen->ReadEvent);
		pOpen->ReadEvent = NULL;
	}

	//
	// free the buffer
	//
	if (pOpen->Size > 0)
	{
		// *should* be no need to acquire this lock, but better safe than sorry?
		NPF_ResetBufferContents(pOpen, TRUE);
	}

	NdisFreeRWLock(pOpen->BufferLock);
	NdisFreeSpinLock(&pOpen->CountersLock);
	NdisFreeSpinLock(&pOpen->OpenInUseLock);

	TRACE_EXIT();
}

//-------------------------------------------------------------------

_Use_decl_annotations_
VOID
NPF_ReleaseFilterModuleResources(
	PNPCAP_FILTER_MODULE pFiltMod
	)
{
	TRACE_ENTER();

	NT_ASSERT(pFiltMod != NULL);

	if (pFiltMod->PacketPool) // Release the packet buffer pool
	{
		NdisFreeNetBufferListPool(pFiltMod->PacketPool);
		pFiltMod->PacketPool = NULL;
	}

	// Release the adapter name
	if (pFiltMod->AdapterName.Buffer)
	{
		ExFreePool(pFiltMod->AdapterName.Buffer);
		pFiltMod->AdapterName.Buffer = NULL;
		pFiltMod->AdapterName.Length = 0;
		pFiltMod->AdapterName.MaximumLength = 0;
	}

#ifdef HAVE_DOT11_SUPPORT
	if (pFiltMod->DataRateMappingTable)
	{
		ExFreePoolWithTag(pFiltMod->DataRateMappingTable, NPF_DOT11_POOL_TAG);
		pFiltMod->DataRateMappingTable = NULL;
	}
#endif

	NdisFreeSpinLock(&pFiltMod->OIDLock);
	NdisFreeRWLock(pFiltMod->OpenInstancesLock);
	NdisFreeRWLock(pFiltMod->BpfProgramsLock);
	NdisFreeSpinLock(&pFiltMod->AdapterHandleLock);

	TRACE_EXIT();
}

//-------------------------------------------------------------------

/* Issue an OID query for a 4-byte value (ULONG). Address must be allocated
 * from nonpaged pool.
 */
_IRQL_requires_(PASSIVE_LEVEL)
NTSTATUS
NPF_OidGetUlongNonpagedPtr(
		_At_(pFiltMod->AdapterBindingStatus, _In_range_(FilterPausing, FilterRestarting))
	_In_ PNPCAP_FILTER_MODULE pFiltMod,
	_In_ NDIS_OID Oid,
	_Out_ PULONG pNonpagedUlong
	)
{
	if (!NT_VERIFY(pNonpagedUlong != NULL))
	{
		return STATUS_INVALID_PARAMETER;
	}
	ULONG BytesProcessed = 0;

	NTSTATUS Status = NPF_DoInternalRequest(pFiltMod,
		NdisRequestQueryInformation,
		Oid,
		pNonpagedUlong,
		sizeof(ULONG),
		0,
		0,
		&BytesProcessed
	);

	INFO_DBG("pFiltMod(%p) Oid %#x, Status %#x, %lu bytes\n",
			pFiltMod, Oid, Status, BytesProcessed);
	if (Status == NDIS_STATUS_SUCCESS)
	{
		NT_ASSERT(BytesProcessed == sizeof(ULONG));
	}
	return Status;
}

//-------------------------------------------------------------------
_IRQL_requires_(PASSIVE_LEVEL)
inline NTSTATUS
NPF_GetDeviceMTU(
	_In_ PNPCAP_FILTER_MODULE pFiltMod
	)
{
	NT_ASSERT(pFiltMod->AdapterBindingStatus == FilterRestarting);

	INFO_DBG("pFiltMod(%p) OID_GEN_MAXIMUM_TOTAL_SIZE (%#x)\n",
			pFiltMod, OID_GEN_MAXIMUM_TOTAL_SIZE);

	return NPF_OidGetUlongNonpagedPtr(pFiltMod,
		OID_GEN_MAXIMUM_TOTAL_SIZE,
		&pFiltMod->MaxFrameSize
	);
}

/*!
  \brief Get the packet filter of the adapter.
  \param FilterModuleContext Pointer to the filter context structure.
  \return the packet filter.

  This function is used to get the original adapter packet filter with
  a NPF_AttachAdapter(), it is stored in the HigherPacketFilter, the combination
  of HigherPacketFilter and MyPacketFilter will be the final packet filter
  the low-level adapter sees.
*/
_IRQL_requires_(PASSIVE_LEVEL)
inline NTSTATUS
NPF_GetPacketFilter(
	_In_ PNPCAP_FILTER_MODULE pFiltMod
	)
{
	// This can only be used before we start mucking with the packet filter.
	INFO_DBG("pFiltMod(%p) OID_GEN_CURRENT_PACKET_FILTER (%#x)\n",
			pFiltMod, OID_GEN_CURRENT_PACKET_FILTER);
	if (!pFiltMod->PacketFilterGetOK)
	{
		INFO_DBG("pFiltMod(%p) OID_GEN_CURRENT_PACKET_FILTER query not supported\n", pFiltMod);
		return STATUS_NOT_SUPPORTED;
	}
	NTSTATUS Status = NPF_OidGetUlongNonpagedPtr(pFiltMod,
		OID_GEN_CURRENT_PACKET_FILTER,
		&pFiltMod->HigherPacketFilter
	);

	if (Status == STATUS_SUCCESS)
	{
		pFiltMod->HigherPacketFilterSet = 1;
		pFiltMod->PacketFilterGetOK = 1;
	}
	else if (Status == NDIS_STATUS_INVALID_OID)
	{
		pFiltMod->PacketFilterGetOK = 0;
	}

	return Status;
}

//-------------------------------------------------------------------
#ifdef HAVE_DOT11_SUPPORT
_Use_decl_annotations_
NTSTATUS
NPF_GetDataRateMappingTable(
	PNPCAP_FILTER_MODULE pFiltMod
)
{
	TRACE_ENTER();
	NT_ASSERT(pFiltMod != NULL);

	// Check if it's already set
	if (pFiltMod->DataRateMappingTable != NULL)
	{
		TRACE_EXIT();
		return STATUS_SUCCESS;
	}

	// Not set, allocate a new one
	PDOT11_DATA_RATE_MAPPING_TABLE pDRMT = NPF_AllocateZeroNonpaged(sizeof(DOT11_DATA_RATE_MAPPING_TABLE), NPF_DOT11_POOL_TAG);
	if (pDRMT == NULL)
	{
		WARNING_DBG("Failed to allocate DOT11_DATA_RATE_MAPPING_TABLE\n");
		TRACE_EXIT();
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	// Interlocked op to avoid race condition.
	PDOT11_DATA_RATE_MAPPING_TABLE pOld = InterlockedCompareExchangePointer(&pFiltMod->DataRateMappingTable, pDRMT, NULL);
	// If the old value was not null, we lost the race and will leave it to the other thread to complete.
	if (pOld != NULL)
	{
		ExFreePoolWithTag(pDRMT, NPF_DOT11_POOL_TAG);
		TRACE_EXIT();
		return STATUS_SUCCESS;
	}

	// Otherwise we won the race and pFiltMod now points to our DRMT.
	// Using NPF_AnalysisAssumeAliased since InterlockedCompareExchangePointer does not have SAL annotations to note that pFiltMod->DataRateMappingTable now points to pDRMT.
	if (!NT_VERIFY(pFiltMod->DataRateMappingTable == pDRMT))
	{
		ExFreePoolWithTag(pDRMT, NPF_DOT11_POOL_TAG);
		TRACE_EXIT();
		return STATUS_INTERNAL_ERROR;
	}
	NPF_AnalysisAssumeAliased(pDRMT);

	ULONG BytesProcessed = 0;

	NDIS_STATUS Status = NPF_DoInternalRequest(pFiltMod,
		NdisRequestQueryInformation,
		OID_DOT11_DATA_RATE_MAPPING_TABLE,
		pDRMT,
		sizeof(DOT11_DATA_RATE_MAPPING_TABLE),
		0,
		0,
		&BytesProcessed
	);

	if (Status == NDIS_STATUS_SUCCESS && (
		BytesProcessed != sizeof(DOT11_DATA_RATE_MAPPING_TABLE)
		|| pDRMT->Header.Type != NDIS_OBJECT_TYPE_DEFAULT
		|| pDRMT->Header.Revision != DOT11_DATA_RATE_MAPPING_TABLE_REVISION_1
		|| pDRMT->Header.Size != sizeof(DOT11_DATA_RATE_MAPPING_TABLE)
		))
	{
		WARNING_DBG("pFiltMod(%p) DOT11_DATA_RATE_MAPPING_TABLE Status %#x, read %lu, expected %zu\n",
				pFiltMod, Status, BytesProcessed, sizeof(DOT11_DATA_RATE_MAPPING_TABLE));
		Status = NDIS_STATUS_INVALID_DATA;
		pFiltMod->DataRateMappingTable = NULL;
		ExFreePoolWithTag(pDRMT, NPF_DOT11_POOL_TAG);
	}
	TRACE_EXIT();
	return Status;
}

//-------------------------------------------------------------------

_Use_decl_annotations_
USHORT
NPF_LookUpDataRateMappingTable(
	PNPCAP_FILTER_MODULE pFiltMod,
	UCHAR ucDataRate
)
{
	UINT i;
	PDOT11_DATA_RATE_MAPPING_TABLE pTable = pFiltMod->DataRateMappingTable;
	USHORT usRetDataRateValue = 0;
	TRACE_ENTER();

	if (!pTable)
	{
		TRACE_EXIT();
		return usRetDataRateValue;
	}

	for (i = 0; i < pTable->uDataRateMappingLength; i ++)
	{
		if (pTable->DataRateMappingEntries[i].ucDataRateIndex == ucDataRate)
		{
			usRetDataRateValue = pTable->DataRateMappingEntries[i].usDataRateValue;
			break;
		}
	}

	TRACE_EXIT();
	return usRetDataRateValue;
}

//-------------------------------------------------------------------

_Use_decl_annotations_
NTSTATUS
NPF_GetCurrentOperationMode(
	PNPCAP_FILTER_MODULE pFiltMod,
	PDOT11_CURRENT_OPERATION_MODE pCurrentOperationMode
)
{
	TRACE_ENTER();
	NT_ASSERT(pFiltMod != NULL);
	NT_ASSERT(pCurrentOperationMode != NULL);

	DOT11_CURRENT_OPERATION_MODE CurrentOperationMode = { 0 };
	ULONG BytesProcessed = 0;
    PVOID pBuffer = NULL;

    pBuffer = NPF_AllocateZeroNonpaged(sizeof(CurrentOperationMode), NPF_INTERNAL_OID_TAG);
    if (pBuffer == NULL)
    {
        INFO_DBG("Allocate pBuffer failed\n");
            TRACE_EXIT();
        return STATUS_INSUFFICIENT_RESOURCES;
    }

	NPF_DoInternalRequest(pFiltMod,
		NdisRequestQueryInformation,
		OID_DOT11_CURRENT_OPERATION_MODE,
		pBuffer,
		sizeof(CurrentOperationMode),
		0,
		0,
		&BytesProcessed
	);

    CurrentOperationMode = *(DOT11_CURRENT_OPERATION_MODE *) pBuffer;
    ExFreePoolWithTag(pBuffer, NPF_INTERNAL_OID_TAG);

	if (BytesProcessed != sizeof(CurrentOperationMode))
	{
		TRACE_EXIT();
		return STATUS_UNSUCCESSFUL;
	}
	else
	{
		*pCurrentOperationMode = CurrentOperationMode;
		TRACE_EXIT();
		return STATUS_SUCCESS;
	}
}

//-------------------------------------------------------------------

_Use_decl_annotations_
ULONG
NPF_GetCurrentOperationMode_Wrapper(
	PNPCAP_FILTER_MODULE pFiltMod
)
{
	DOT11_CURRENT_OPERATION_MODE CurrentOperationMode;
	if (NPF_GetCurrentOperationMode(pFiltMod, &CurrentOperationMode) != STATUS_SUCCESS)
	{
		return DOT11_OPERATION_MODE_UNKNOWN;
	}
	else
	{
		// Possible return values are:
		// 1: DOT11_OPERATION_MODE_EXTENSIBLE_STATION
		// 2: DOT11_OPERATION_MODE_EXTENSIBLE_AP
		// 3: DOT11_OPERATION_MODE_NETWORK_MONITOR
		return CurrentOperationMode.uCurrentOpMode;
	}
}

//-------------------------------------------------------------------

// pCurrentChannel must point to nonpaged memory
_IRQL_requires_(PASSIVE_LEVEL)
inline NTSTATUS
NPF_GetCurrentChannel(
	_In_ PNPCAP_FILTER_MODULE pFiltMod,
	_Out_ PULONG pCurrentChannel
)
{
	return NPF_OidGetUlongNonpagedPtr(pFiltMod,
		OID_DOT11_CURRENT_CHANNEL,
		pCurrentChannel
	);
}

//-------------------------------------------------------------------

// pCurrentFrequency must point to nonpaged memory
_IRQL_requires_(PASSIVE_LEVEL)
inline NTSTATUS
NPF_GetCurrentFrequency(
	_In_ PNPCAP_FILTER_MODULE pFiltMod,
	_Out_ PULONG pCurrentFrequency
)
{
	return NPF_OidGetUlongNonpagedPtr(pFiltMod,
		OID_DOT11_CURRENT_FREQUENCY,
		pCurrentFrequency
	);
}

#endif
//-------------------------------------------------------------------

_Use_decl_annotations_
NTSTATUS
NPF_CloseAdapter(
	PDEVICE_OBJECT DeviceObject,
	PIRP Irp
	)
{
	POPEN_INSTANCE pOpen;
	PIO_STACK_LOCATION IrpSp;
	TRACE_ENTER();

	IrpSp = IoGetCurrentIrpStackLocation(Irp);
	pOpen = IrpSp->FileObject->FsContext;
	if (!NPF_IsOpenInstance(pOpen))
	{
		Irp->IoStatus.Status = STATUS_INVALID_HANDLE;
		Irp->IoStatus.Information = 0;
		IoCompleteRequest(Irp, IO_NO_INCREMENT);
		TRACE_EXIT();
		return STATUS_INVALID_HANDLE;
	}

	//
	// Free the open instance itself
	//
	NT_ASSERT(pOpen->OpenStatus == OpenClosed);
	ExFreePool(pOpen);

	Irp->IoStatus.Status = STATUS_SUCCESS;
	Irp->IoStatus.Information = 0;
	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	TRACE_EXIT();
	return STATUS_SUCCESS;
}

//-------------------------------------------------------------------

_Use_decl_annotations_
NTSTATUS
NPF_Cleanup(
	PDEVICE_OBJECT DeviceObject,
	PIRP Irp
	)
{
	POPEN_INSTANCE Open;
	NDIS_STATUS Status;
	PIO_STACK_LOCATION IrpSp;
	TRACE_ENTER();

	IrpSp = IoGetCurrentIrpStackLocation(Irp);
	Open = IrpSp->FileObject->FsContext;
	if (!NPF_IsOpenInstance(Open))
	{
		Irp->IoStatus.Status = STATUS_INVALID_HANDLE;
		Irp->IoStatus.Information = 0;
		IoCompleteRequest(Irp, IO_NO_INCREMENT);
		TRACE_EXIT();
		return STATUS_INVALID_HANDLE;
	}

	INFO_DBG("Open = %p\n", Open);

	NT_ASSERT(Open != NULL);

	OPEN_STATE OldState = NPF_DemoteOpenStatus(Open, OpenClosed);
	if (Open->ReadEvent != NULL)
		KeSetEvent(Open->ReadEvent, 0, FALSE);
	NPF_OpenWaitPendingIrps(Open);

	// If it was already marked as detached, don't try to detach it twice.
	if (OldState < OpenDetached) {
		NPF_RemoveFromGroupOpenArray(Open); //Remove the Open from the filter module's list
	}

	//
	// release all the resources
	//
	NPF_ReleaseOpenInstanceResources(Open);
	NPF_RemoveFromAllOpensList(Open);

	Status = STATUS_SUCCESS;

	//
	// and complete the IRP with status success
	//
	Irp->IoStatus.Information = 0;
	Irp->IoStatus.Status = Status;
	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	TRACE_EXIT();

	return Status;
}

//-------------------------------------------------------------------

_Use_decl_annotations_
void
NPF_AddToFilterModuleArray(
	PNPCAP_FILTER_MODULE pFiltMod
	)
{
	TRACE_ENTER();

	NdisAcquireSpinLock(&g_pDriverExtension->FilterArrayLock);
	PushEntryList(&g_pDriverExtension->arrFiltMod, &pFiltMod->FilterModulesEntry);
	NdisReleaseSpinLock(&g_pDriverExtension->FilterArrayLock);

	TRACE_EXIT();
}

//-------------------------------------------------------------------

_Use_decl_annotations_
void
NPF_AddToGroupOpenArray(
	POPEN_INSTANCE pOpen,
	PNPCAP_FILTER_MODULE pFiltMod,
	BOOLEAN bAtDispatchLevel
	)
{
	TRACE_ENTER();

	LOCK_STATE_EX lockState;

	FILTER_ACQUIRE_LOCK(&pOpen->OpenInUseLock, bAtDispatchLevel);

	NT_ASSERT(pOpen->OpenStatus >= OpenDetached);
	NT_ASSERT(pOpen->pFiltMod == NULL);
	NT_ASSERT(pOpen->OpenInstancesEntry.Next == NULL);

	// Acquire lock for writing (modify list)
	NdisAcquireRWLockWrite(pFiltMod->OpenInstancesLock, &lockState, NDIS_RWL_AT_DISPATCH_LEVEL);

	PushEntryList(&pFiltMod->OpenInstances, &pOpen->OpenInstancesEntry);

	// 'OR' in the open's filter
#ifdef HAVE_DOT11_SUPPORT
	if (pFiltMod->Dot11)
	{
		pOpen->MyPacketFilter |= NPCAP_DOT11_RAW_PACKET_FILTER;
	}
#endif
	pFiltMod->MyPacketFilter |= pOpen->MyPacketFilter;
	pFiltMod->MyLookaheadSize = max(pFiltMod->MyLookaheadSize, pOpen->MyLookaheadSize);

	NdisReleaseRWLock(pFiltMod->OpenInstancesLock, &lockState);

	pOpen->pFiltMod = pFiltMod;
	pOpen->AdapterID = pFiltMod->AdapterID;
	pOpen->bSendToRx = pFiltMod->SendToRxPath;
	pOpen->bDot11 = pFiltMod->Dot11;
	pOpen->bLoopback = pFiltMod->Loopback;
	pOpen->OpenStatus = OpenAttached;
	FILTER_RELEASE_LOCK(&pOpen->OpenInUseLock, bAtDispatchLevel);

	TRACE_EXIT();
}

//-------------------------------------------------------------------

_Use_decl_annotations_
void
NPF_RemoveFromFilterModuleArray(
	PNPCAP_FILTER_MODULE pFiltMod
	)
{
	PSINGLE_LIST_ENTRY Prev = NULL;
	PSINGLE_LIST_ENTRY Curr = NULL;

	TRACE_ENTER();
	NT_ASSERT(pFiltMod != NULL);

	NdisAcquireSpinLock(&g_pDriverExtension->FilterArrayLock);

	Prev = &g_pDriverExtension->arrFiltMod;
	Curr = Prev->Next;
	while (Curr != NULL)
	{
		if (Curr == &(pFiltMod->FilterModulesEntry)) {
			Prev->Next = Curr->Next;
			break;
		}
		Prev = Curr;
		Curr = Prev->Next;
	}

	NdisReleaseSpinLock(&g_pDriverExtension->FilterArrayLock);

	TRACE_EXIT();
}

//-------------------------------------------------------------------

_Use_decl_annotations_
void
NPF_RemoveFromGroupOpenArray(
	POPEN_INSTANCE pOpen
	)
{
	PNPCAP_FILTER_MODULE pFiltMod;
	PSINGLE_LIST_ENTRY Prev = NULL;
	PSINGLE_LIST_ENTRY Curr = NULL;
	POPEN_INSTANCE pCurrOpen = NULL;

	ULONG NewPacketFilter;
	ULONG NewLookaheadSize;
	BOOLEAN found = FALSE;
	BOOLEAN last = FALSE;
	LOCK_STATE_EX lockState;

	TRACE_ENTER();

	NdisAcquireSpinLock(&pOpen->OpenInUseLock);
	pFiltMod = pOpen->pFiltMod;
	if (!NT_VERIFY(pFiltMod)) {
		/* This adapter was already removed, so no filter module exists.
		 * Nothing left to do!
		 */
		if (!NT_VERIFY(pOpen->OpenStatus >= OpenDetached)) {
			pOpen->OpenStatus = OpenDetached;
		}
		NT_ASSERT(pOpen->OpenInstancesEntry.Next == NULL);
		NdisReleaseSpinLock(&pOpen->OpenInUseLock);
		return;
	}
	pOpen->OpenStatus = max(pOpen->OpenStatus, OpenDetached);
	NPF_UnregisterBpf(pOpen->pFiltMod, pOpen->BpfProgram);
	pOpen->pFiltMod = NULL;
	NdisReleaseSpinLock(&pOpen->OpenInUseLock);

	// Acquire lock for writing (modify list)
	NdisAcquireRWLockWrite(pFiltMod->OpenInstancesLock, &lockState, 0);

	/* Recalculate the combined tracked interface parameters */
	NewPacketFilter = 0;
	NewLookaheadSize = 0;

	Prev = &(pFiltMod->OpenInstances);
	Curr = Prev->Next;
	while (Curr != NULL)
	{
		if (Curr == &(pOpen->OpenInstancesEntry)) {
			/* This is the one to remove. Ignore its parameters. */
			Prev->Next = Curr->Next;
			found = TRUE;
		}
		else if (!pFiltMod->Loopback)
		{
			/* OR the filter in */
			pCurrOpen = CONTAINING_RECORD(Curr, OPEN_INSTANCE, OpenInstancesEntry);
			NewPacketFilter |= pCurrOpen->MyPacketFilter;
			NewLookaheadSize = max(NewLookaheadSize, pCurrOpen->MyLookaheadSize);
		}
		/* Regardless, keep traversing. */
		Prev = Curr;
		Curr = Prev->Next;
	}

	// Avoid multiple entry points to the list
	pOpen->OpenInstancesEntry.Next = NULL;

	if (!NT_VERIFY(found))
	{
		ERROR_DBG("the open isn't in the group open list.\n");
		NdisReleaseRWLock(pFiltMod->OpenInstancesLock, &lockState);
		TRACE_EXIT();
		return;
	}

#ifdef HAVE_WFP_LOOPBACK_SUPPORT
	// If this was the last loopback instance, get ready to release WFP resources.
	// Have to release all locks first so IRQL is PASSIVE_LEVEL
	if (pFiltMod->Loopback && pFiltMod->OpenInstances.Next == NULL)
	{
		FILTER_ACQUIRE_LOCK(&pFiltMod->AdapterHandleLock, TRUE);
		if(pFiltMod->OpsState == OpsEnabled)
		{
			// Ops enabled. Signal intent to disable.
			pFiltMod->OpsState = OpsDisabling;
			last = TRUE;
		}
		else {
			// Either someone else is disabling or it's already disabled
			NT_ASSERT(pFiltMod->OpsState == OpsDisabling || pFiltMod->OpsState == OpsDisabled);
		}
		FILTER_RELEASE_LOCK(&pFiltMod->AdapterHandleLock, TRUE);
	}
#endif

	NdisReleaseRWLock(pFiltMod->OpenInstancesLock, &lockState);

#ifdef HAVE_WFP_LOOPBACK_SUPPORT
	// No more loopback handles open, and it's our responsibility to clean up. Release WFP resources.
	if (last && !g_pDriverExtension->bTestMode) {
		NPF_ReleaseWFP(FALSE);

		FILTER_ACQUIRE_LOCK(&pFiltMod->AdapterHandleLock, FALSE);
		NT_ASSERT(pFiltMod->OpsState == OpsDisabling);
		pFiltMod->OpsState = OpsDisabled;
		FILTER_RELEASE_LOCK(&pFiltMod->AdapterHandleLock, FALSE);
	}
#endif

	/* If the packet filter has changed, originate an OID Request to set it to the new value */
	if (STATUS_SUCCESS != NPF_SetPacketFilter(pFiltMod, NewPacketFilter))
	{
		INFO_DBG("Failed to set resulting packet filter.\n");
	}
	// If the new lookahead value is different than the old one, originate an OID request to set to the new value
	if (STATUS_SUCCESS != NPF_SetLookaheadSize(pFiltMod, NewLookaheadSize))
	{
		INFO_DBG("Failed to set resulting lookahead.\n");
	}

	TRACE_EXIT();
}

//-------------------------------------------------------------------

/*!
  \brief Compare two NDIS strings.
  \param s1 The first string.
  \param s2 The second string.
  \param cchOffset *Character* offset into s2 where comparison should begin. NOT BYTE OFFSET.
  \return  TRUE if s1 contains s2 at Offset, FALSE otherwise

  This function is used to help decide whether two adapter names are the same.
  Tolerates differences in null-termination of either string.
*/
BOOLEAN
NPF_EqualAdapterName(
	_In_ PCNDIS_STRING s1,
	_In_ PCNDIS_STRING s2,
	_In_ USHORT cchOffset
	)
{
	USHORT i;
	USHORT compare_len;
	WCHAR wc1, wc2;
	BOOLEAN bResult = TRUE;
	// TRACE_ENTER();

	if (s1->Buffer == NULL || s2->Buffer == NULL) {
		INFO_DBG("null buffer\n");
		return FALSE;
	}

	compare_len = BYTES2CCH(s1->Length);
	// If it's null-terminated, don't compare null terminator since s2 might not be null-terminated.
	if (s1->Buffer[compare_len - 1] == UNICODE_NULL)
	{
		compare_len -= 1;
	}

	if (BYTES2CCH(s2->Length) - compare_len < cchOffset)
	{
		INFO_DBG("length too short\n");
		return FALSE;
	}

	for (i = 0; bResult && i < compare_len; i++)
	{
		wc1 = s1->Buffer[i];
		wc2 = s2->Buffer[cchOffset + i];
		switch(wc1 - wc2)
		{
			case 0:
				// Equal, same case
				break;
			case L'a' - L'A':
				// same iff wc1 is lower
				bResult = wc1 >= L'a' && wc1 <= L'z';
				break;
			case L'A' - L'a':
				// same iff wc1 is caps
				bResult = wc1 >= L'A' && wc1 <= L'Z';
				break;
			default:
				bResult = FALSE;
				break;
		}
	}

	// Now check that we didn't only find a prefix of s2
	bResult = bResult && ( // Matches up to compare_len AND
		BYTES2CCH(s2->Length) - compare_len == cchOffset // that's all there is
		|| s2->Buffer[cchOffset + compare_len] == UNICODE_NULL // OR s2 is null-terminated
		|| s2->Buffer[cchOffset + compare_len] == L';' // OR s2 is a list and the next one starts here
		);

	// Print unicode strings using %ws will cause page fault blue screen with IRQL = DISPATCH_LEVEL, so we disable the string print for now.
	// INFO_DBG("bResult = %d, s1 = %ws, s2 = %ws\n", i, bResult, s1->Buffer, s2->Buffer);
	INFO_DBG("bResult == %u\n", bResult);
	// TRACE_EXIT();
	return bResult;
}

/* Returns true if AdName is in the semicolon-separated list AdSet */
BOOLEAN
NPF_ContainsAdapterName(
	_In_ PCNDIS_STRING AdSet,
	_In_ PCNDIS_STRING AdName
	)
{
	USHORT i = 0;

	if (AdSet->Buffer == NULL || AdName->Buffer == NULL) {
		INFO_DBG("null buffer\n");
		return FALSE;
	}
	while (i < BYTES2CCH(AdSet->Length))
	{
		if (NPF_EqualAdapterName(AdName, AdSet, i))
		{
			return TRUE;
		}
		while (i < BYTES2CCH(AdSet->Length) && AdSet->Buffer[i] != L';')
		{
			i++;
		}
		i++;
	}
	return FALSE;
}

//-------------------------------------------------------------------
/* Ensure string "a" is long enough to contain "b" after the offset.
 * Length does not include the null terminator, so account for that with sizeof(WCHAR).
 * Then compare memory. Length is length in bytes, but buffer is a PWCHAR.
 */
#define PUNICODE_CONTAINS(a, b, byteoffset) ((a->Length >= byteoffset + CONST_WCHAR_BYTES(b)) && CONST_WCHAR_BYTES(b) == RtlCompareMemory(a->Buffer + BYTES2CCH(byteoffset), b, CONST_WCHAR_BYTES(b)))
_Use_decl_annotations_
PNPCAP_FILTER_MODULE
NPF_GetFilterModuleByAdapterName(
	PNDIS_STRING pAdapterName
	)
{
	PSINGLE_LIST_ENTRY Curr = NULL;
	PNPCAP_FILTER_MODULE pFiltMod = NULL;
	size_t i = 0;
	USHORT cchShrink = 0;
	BOOLEAN Dot11 = FALSE;
	BOOLEAN Found = FALSE;
	NDIS_STRING BaseName = {0};
	TRACE_ENTER();

	if (pAdapterName->Buffer == NULL || pAdapterName->Length == 0) {
		return NULL;
	}

	// strip off leading backslashes
	while (CCH2BYTES(cchShrink) < pAdapterName->Length && pAdapterName->Buffer[cchShrink] == L'\\') {
		cchShrink++;
	}


	// Make sure we can hold at least as long a name as requested.
	BaseName.MaximumLength = max(sizeof(L"Loopback"), pAdapterName->MaximumLength);
	BaseName.Buffer = NPF_AllocateZeroNonpaged(BaseName.MaximumLength, NPF_UNICODE_BUFFER_TAG);
	if (BaseName.Buffer == NULL) {
		INFO_DBG("failed to allocate BaseName.Buffer\n");
		TRACE_EXIT();
		return NULL;
	}

#ifdef HAVE_DOT11_SUPPORT
	// Check for WIFI_ prefix and strip it
	if (PUNICODE_CONTAINS(pAdapterName, NPF_DEVICE_NAMES_TAG_WIDECHAR_WIFI, CCH2BYTES(cchShrink))) {
		cchShrink += CONST_WCHAR_CCH(NPF_DEVICE_NAMES_TAG_WIDECHAR_WIFI);
		Dot11 = TRUE;
	}
#endif

	// Do the strip
	for (i=cchShrink; i < BYTES2CCH(pAdapterName->Length) && (i - cchShrink) < BYTES2CCH(BaseName.MaximumLength); i++) {
		BaseName.Buffer[i - cchShrink] = pAdapterName->Buffer[i];
	}
	BaseName.Length = pAdapterName->Length - CCH2BYTES(cchShrink);

#ifdef HAVE_WFP_LOOPBACK_SUPPORT
	if (!Dot11 // WIFI and Loopback are not compatible
		&& NPF_EqualAdapterName(&g_pDriverExtension->LoopbackAdapterName, &BaseName, 0)) // This is a request for legacy loopback
	{
		// Replace the name with the fake loopback adapter name
		RtlCopyMemory(BaseName.Buffer, L"Loopback", sizeof(L"Loopback"));
		BaseName.Length = CONST_WCHAR_BYTES(L"Loopback");
	}
#endif

	// Now go looking for the appropriate module
	NdisAcquireSpinLock(&g_pDriverExtension->FilterArrayLock);
	for (Curr = g_pDriverExtension->arrFiltMod.Next; Curr != NULL; Curr = Curr->Next)
	{
		pFiltMod = CONTAINING_RECORD(Curr, NPCAP_FILTER_MODULE, FilterModulesEntry);
		if (NPF_StartUsingBinding(pFiltMod, NPF_IRQL_UNKNOWN) == FALSE)
		{
			continue;
		}

		Found = (pFiltMod->Dot11 == Dot11 && NPF_EqualAdapterName(&pFiltMod->AdapterName, &BaseName, 0));

		NPF_StopUsingBinding(pFiltMod, NPF_IRQL_UNKNOWN);
		if (Found)
		{
			break;
		}
	}
	NdisReleaseSpinLock(&g_pDriverExtension->FilterArrayLock);
	ExFreePoolWithTag(BaseName.Buffer, NPF_UNICODE_BUFFER_TAG);
	if (!Found)
	{
		pFiltMod = NULL;
	}

	TRACE_EXIT();
	return pFiltMod;
}

//-------------------------------------------------------------------

#ifdef HAVE_WFP_LOOPBACK_SUPPORT
_Use_decl_annotations_
PNPCAP_FILTER_MODULE
NPF_GetLoopbackFilterModule()
{
	PSINGLE_LIST_ENTRY Curr = NULL;
	PNPCAP_FILTER_MODULE pFiltMod = NULL;
	TRACE_ENTER();

	NdisAcquireSpinLock(&g_pDriverExtension->FilterArrayLock);
	for (Curr = g_pDriverExtension->arrFiltMod.Next; Curr != NULL; Curr = Curr->Next)
	{
		pFiltMod = CONTAINING_RECORD(Curr, NPCAP_FILTER_MODULE, FilterModulesEntry);
		if (NPF_StartUsingBinding(pFiltMod, NPF_IRQL_UNKNOWN) == FALSE)
		{
			continue;
		}

		if (pFiltMod->Loopback)
		{
			NPF_StopUsingBinding(pFiltMod, NPF_IRQL_UNKNOWN);
			NdisReleaseSpinLock(&g_pDriverExtension->FilterArrayLock);
			return pFiltMod;
		}
		else
		{
			NPF_StopUsingBinding(pFiltMod, NPF_IRQL_UNKNOWN);
		}
	}
	NdisReleaseSpinLock(&g_pDriverExtension->FilterArrayLock);

	TRACE_EXIT();
	return NULL;
}
#endif
//-------------------------------------------------------------------

_Use_decl_annotations_
POPEN_INSTANCE
NPF_CreateOpenObject(NDIS_HANDLE NdisHandle)
{
	POPEN_INSTANCE Open;
	TRACE_ENTER();

	// allocate some memory for the open structure
	Open = NPF_AllocateZeroNonpaged(sizeof(OPEN_INSTANCE), NPF_OPEN_TAG);

	if (Open == NULL)
	{
		// no memory
		INFO_DBG("Failed to allocate memory pool\n");
		TRACE_EXIT();
		return NULL;
	}
	Open->BpfProgram = NPF_AllocateZeroNonpaged(sizeof(NPCAP_BPF_PROGRAM), NPF_BPF_TAG);
	if (Open->BpfProgram == NULL)
	{
		INFO_DBG("Failed to allocate BpfProgram\n");
		ExFreePool(Open);
		TRACE_EXIT();
		return NULL;
	}
	Open->BpfProgram->pOpen = Open;

	/* Buffer */
	Open->BufferLock = NdisAllocateRWLock(NdisHandle);
	if (Open->BufferLock == NULL)
	{
		INFO_DBG("Failed to allocate BufferLock\n");
		ExFreePool(Open->BpfProgram);
		ExFreePool(Open);
		TRACE_EXIT();
		return NULL;
	}

	InitializeListHead(&Open->PacketQueue);
	KeInitializeSpinLock(&Open->PacketQueueLock);
	Open->Accepted = 0;
	Open->Received = 0;
	Open->Dropped = 0;

	Open->OpenSignature = OPEN_SIGNATURE;
	Open->OpenStatus = OpenClosed;
	Open->ReattachStatus = OpenClosed;

	//
	// Initialize the open instance
	//
	//Open->BindContext = NULL;
	Open->TimestampMode = g_pDriverExtension->TimestampMode;
	Open->bModeCapt = 1;
	Open->Nbytes.QuadPart = 0;
	Open->Npackets.QuadPart = 0;
	Open->Nwrites = 1;
	Open->MinToCopy = 0;
	Open->Size = 0;
	Open->SkipSentPackets = FALSE;
	Open->MyPacketFilter = 0;
	Open->MyLookaheadSize = 0;
	Open->ReadEvent = NULL;

	//
	// we need to keep a counter of the pending IRPs
	// so that when the IRP_MJ_CLEANUP dispatcher gets called,
	// we can wait for those IRPs to be completed
	// NB: no IRPs can be pending for the OpenClosed state.
	for (OPEN_STATE state = 0; state < OpenClosed; state++)
	{
		Open->PendingIrps[state] = 0;
	}
	NdisAllocateSpinLock(&Open->OpenInUseLock);
	Open->OpenInstancesEntry.Next = NULL;

	//
	//allocate the spinlock for the statistic counters
	//
	NdisAllocateSpinLock(&Open->CountersLock);

	Open->OpenStatus = OpenDetached;

	TRACE_EXIT();
	return Open;
}

//-------------------------------------------------------------------

_Use_decl_annotations_
PNPCAP_FILTER_MODULE
NPF_CreateFilterModule(
	NDIS_HANDLE NdisFilterHandle,
	PNDIS_STRING AdapterName)
{
	PNPCAP_FILTER_MODULE pFiltMod;
	NET_BUFFER_LIST_POOL_PARAMETERS PoolParameters;
	BOOLEAN bAllocFailed = FALSE;

	// allocate some memory for the filter module structure
	pFiltMod = NPF_AllocateZeroNonpaged(sizeof(NPCAP_FILTER_MODULE), NPF_FILTMOD_TAG);

	if (pFiltMod == NULL)
	{
		// no memory
		INFO_DBG("Failed to allocate memory pool\n");
		return NULL;
	}

	pFiltMod->AdapterHandle = NdisFilterHandle;
	pFiltMod->AdapterBindingStatus = FilterDetached;
	pFiltMod->Loopback = FALSE;

	pFiltMod->SendToRxPath = FALSE;
	pFiltMod->BlockRxPath = FALSE;

	pFiltMod->Dot11 = FALSE;

	pFiltMod->FilterModulesEntry.Next = NULL;
	pFiltMod->OpenInstances.Next = NULL;
	InitializeListHead(&pFiltMod->BpfPrograms);

	// Pool sizes based on observations on a single-core Hyper-V VM while
	// running our test suite.

	//  Initialize the pools
	do {
		pFiltMod->OpenInstancesLock = NdisAllocateRWLock(NdisFilterHandle);
		if (pFiltMod->OpenInstancesLock == NULL)
		{
			INFO_DBG("Failed to allocate OpenInstancesLock\n");
			bAllocFailed = TRUE;
			break;
		}

		pFiltMod->BpfProgramsLock = NdisAllocateRWLock(NdisFilterHandle);
		if (pFiltMod->BpfProgramsLock == NULL)
		{
			INFO_DBG("Failed to allocate BpfProgramsLock\n");
			bAllocFailed = TRUE;
			break;
		}

		NdisZeroMemory(&PoolParameters, sizeof(NET_BUFFER_LIST_POOL_PARAMETERS));
		PoolParameters.Header.Type = NDIS_OBJECT_TYPE_DEFAULT;
		PoolParameters.Header.Revision = NET_BUFFER_LIST_POOL_PARAMETERS_REVISION_1;
		PoolParameters.Header.Size = NDIS_SIZEOF_NET_BUFFER_LIST_POOL_PARAMETERS_REVISION_1;
		PoolParameters.ProtocolId = NDIS_PROTOCOL_ID_DEFAULT;
		PoolParameters.fAllocateNetBuffer = TRUE;
		PoolParameters.ContextSize = sizeof(PACKET_RESERVED);
		PoolParameters.PoolTag = NPF_PACKET_POOL_TAG;
		PoolParameters.DataSize = 0;

		pFiltMod->PacketPool = NdisAllocateNetBufferListPool(NdisFilterHandle, &PoolParameters);
		if (pFiltMod->PacketPool == NULL)
		{
			INFO_DBG("Failed to allocate packet pool\n");
			bAllocFailed = TRUE;
			break;
		}

		pFiltMod->AdapterName.MaximumLength = AdapterName->MaximumLength - DEVICE_PATH_BYTES;
		pFiltMod->AdapterName.Buffer = NPF_AllocateZeroNonpaged(pFiltMod->AdapterName.MaximumLength, NPF_UNICODE_BUFFER_TAG);
		if (pFiltMod->AdapterName.Buffer == NULL)
		{
			INFO_DBG("Failed to allocate AdapterName buffer\n");
			bAllocFailed = TRUE;
			break;
		}
		pFiltMod->AdapterName.Length = 0;
		RtlAppendUnicodeToString(&pFiltMod->AdapterName, AdapterName->Buffer + DEVICE_PATH_CCH);
	} while (0);

	if (bAllocFailed) {
		if (pFiltMod->PacketPool)
			NdisFreeNetBufferListPool(pFiltMod->PacketPool);
		if (pFiltMod->OpenInstancesLock)
			NdisFreeRWLock(pFiltMod->OpenInstancesLock);
		if (pFiltMod->BpfProgramsLock)
			NdisFreeRWLock(pFiltMod->BpfProgramsLock);
		ExFreePool(pFiltMod);
		return NULL;
	}
	
	// Default; expect this will be overwritten in NPF_Restart,
	// or for Loopback when creating the fake module.
	pFiltMod->MaxFrameSize = 1514;

	//
	//allocate the spinlock for the OID requests
	//
	NdisAllocateSpinLock(&pFiltMod->OIDLock);

	//
	// set the proper binding flags before trying to open the MAC
	//
	pFiltMod->AdapterHandleUsageCounter = 0;
	NdisAllocateSpinLock(&pFiltMod->AdapterHandleLock);

	pFiltMod->OpsState = OpsDisabled;

	INFO_DBG("pFiltMod(%p) created for %ws\n", pFiltMod, pFiltMod->AdapterName.Buffer);
	return pFiltMod;
}

//-------------------------------------------------------------------

_Use_decl_annotations_
NDIS_STATUS
NPF_RegisterOptions(
	NDIS_HANDLE  NdisFilterHandle,
	NDIS_HANDLE  FilterDriverContext
	)
/*++

Routine Description:

	Register optional handlers with NDIS.  This sample does not happen to
	have any optional handlers to register, so this routine does nothing
	and could simply have been omitted.  However, for illustrative purposes,
	it is presented here.

Arguments:

	NdisFilterHandle - pointer the driver handle received from
							 NdisFRegisterFilterDriver

	FilterDriverContext    - pointer to our context passed into
							 NdisFRegisterFilterDriver

Return Value:

	NDIS_STATUS_SUCCESS

--*/
{
	UNREFERENCED_PARAMETER(NdisFilterHandle);
	TRACE_ENTER();

#ifdef HAVE_WFP_LOOPBACK_SUPPORT
	/* This callback is only for the NDIS LWF, not WFP/loopback */
	NT_ASSERT(!((PNPCAP_FILTER_MODULE) NdisFilterHandle)->Loopback);
#endif

	TRACE_EXIT();

	return NDIS_STATUS_SUCCESS;
}

//-------------------------------------------------------------------

struct MediaParams {
	BOOLEAN RawIP:1;
	BOOLEAN EtherHeader:1;
	BOOLEAN Dot11:1;
	BOOLEAN PacketFilterGetOK:1;
	BOOLEAN Fragile:1;
	BOOLEAN SplitMdls:1;
};

static NDIS_STATUS NPF_ValidateParameters(
	_Out_ struct MediaParams *pParams,
	_In_ NDIS_MEDIUM MiniportMediaType,
	_In_ NDIS_PHYSICAL_MEDIUM MiniportPhysicalMediaType,
	_In_opt_ NDIS_HANDLE MiniportMediaSpecificAttributes
        )
{
	NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
	// Defaults
	pParams->Fragile = 1;
	pParams->RawIP = 0;
	pParams->EtherHeader = 0;
	pParams->PacketFilterGetOK = 1;
    // Verify the media type is supported.  This is a last resort; the
    // the filter should never have been bound to an unsupported miniport
    // to begin with.  If this driver is marked as a Mandatory filter (which
    // is the default for this sample; see the INF file), failing to attach
    // here will leave the network adapter in an unusable state.
    //
	switch (MiniportMediaType)
	{
		case NdisMediumNative802_11:
			// The WiFi filter will only bind to the 802.11
			// wireless adapters that support NetworkMonitor mode.
			pParams->Dot11 = g_pDriverExtension->bDot11SupportMode;
			// NDIS always answers OID_GEN_CURRENT_PACKET_FILTER queries for
			// Wifi adapters with NDIS_STATUS_INVALID_OID
			pParams->PacketFilterGetOK = 0;
			pParams->Fragile = 0;
#ifdef HAVE_DOT11_SUPPORT
			if (pParams->Dot11 && MiniportMediaSpecificAttributes)
			{
				PNDIS_MINIPORT_ADAPTER_NATIVE_802_11_ATTRIBUTES pDot11Attrs = MiniportMediaSpecificAttributes;
				if (pDot11Attrs->Header.Type == NDIS_OBJECT_TYPE_MINIPORT_ADAPTER_NATIVE_802_11_ATTRIBUTES
						&& !(pDot11Attrs->OpModeCapability & DOT11_OPERATION_MODE_NETWORK_MONITOR))
				{
					INFO_DBG("Adapter does not support NetMon\n");
					Status = NDIS_STATUS_INVALID_PARAMETER;
				}
			}
#endif
			break;
		case NdisMedium802_3:
			pParams->Fragile = 0;
			pParams->EtherHeader = 1;
			break;
		case NdisMediumWan:
			pParams->EtherHeader = 1;
			pParams->Fragile = 1;
			break;
		case NdisMediumWirelessWan:
		case NdisMediumIP:
			pParams->RawIP = 1;
		default:
			pParams->Fragile = 1;
			break;
	}
	if (MiniportPhysicalMediaType == NdisPhysicalMediumBluetooth)
	{
		pParams->SplitMdls = 1;
	}
	return Status;
}

_Use_decl_annotations_
NDIS_STATUS
NPF_AttachAdapter(
	NDIS_HANDLE                     NdisFilterHandle,
	NDIS_HANDLE                     FilterDriverContext,
	PNDIS_FILTER_ATTACH_PARAMETERS  AttachParameters
	)
{
	PNPCAP_FILTER_MODULE pFiltMod = NULL;
	struct MediaParams params = {0};
	LOCK_STATE_EX lockState;
	NDIS_STATUS             Status;
	NDIS_STATUS				returnStatus;
	NDIS_FILTER_ATTRIBUTES	FilterAttributes;
	SINGLE_LIST_ENTRY ReattachOpens = {NULL};
	BOOLEAN					bFalse = FALSE;

	TRACE_ENTER();

	do
	{
		// FilterModuleGuidName = "{ADAPTER_GUID}-{FILTER_GUID}-0000"

		returnStatus = NPF_ValidateParameters(&params, AttachParameters->MiniportMediaType, AttachParameters->MiniportPhysicalMediaType, AttachParameters->MiniportMediaSpecificAttributes);
		INFO_DBG("FilterModuleGuidName=%ws, bDot11=%u, MediaType=%d\n",
			AttachParameters->FilterModuleGuidName->Buffer,
			params.Dot11, AttachParameters->MiniportMediaType);

		if (returnStatus != STATUS_SUCCESS)
			break;

#if NDIS_SUPPORT_NDIS630
		// If it's a SR-IOV virtual function driver, we're bound at the iovvf layer, so don't go mucking with packet filters!
		if (AttachParameters->Header.Revision >= NDIS_FILTER_ATTACH_PARAMETERS_REVISION_4
			&& AttachParameters->SriovCapabilities
			&& (AttachParameters->SriovCapabilities->SriovCapabilities & NDIS_SRIOV_CAPS_VF_MINIPORT) > 0
			) {
			params.Fragile = 1;
		}
#endif

		// Disable this code for now, because it invalidates most adapters to be bound, reason needs to be clarified.
// 		if (AttachParameters->LowerIfIndex != AttachParameters->BaseMiniportIfIndex)
// 		{
// 			INFO_DBG("Don't bind to other altitudes than exactly over the miniport: LowerIfIndex = %d, BaseMiniportIfIndex = %d.\n", AttachParameters->LowerIfIndex, AttachParameters->BaseMiniportIfIndex);
// 
// 			returnStatus = NDIS_STATUS_NOT_SUPPORTED;
// 			break;
// 		}

#ifdef HAVE_WFP_LOOPBACK_SUPPORT
		// Determine whether this is the legacy loopback adapter
		if (NPF_EqualAdapterName(&g_pDriverExtension->LoopbackAdapterName, AttachParameters->BaseMiniportName, DEVICE_PATH_CCH))
		{
			// This request is for the legacy loopback adapter listed in the Registry.
			// Since we now have a fake filter module for this, deny the binding.
			// We'll intercept open requests for this name elsewhere and redirect to the fake one.
			returnStatus = NDIS_STATUS_NOT_SUPPORTED;
			break;
		}
#endif

		// create the adapter object
		pFiltMod = NPF_CreateFilterModule(NdisFilterHandle, AttachParameters->BaseMiniportName);
		if (pFiltMod == NULL)
		{
			returnStatus = NDIS_STATUS_RESOURCES;
			TRACE_EXIT();
			return returnStatus;
		}
		pFiltMod->AdapterID = AttachParameters->BaseMiniportNetLuid;
		pFiltMod->AdapterBindingStatus = FilterAttaching;
		pFiltMod->RawIP = params.RawIP;
		pFiltMod->EtherHeader = params.EtherHeader;
		pFiltMod->Dot11 = params.Dot11;
		pFiltMod->PacketFilterGetOK = params.PacketFilterGetOK;
		pFiltMod->Fragile = params.Fragile;
		pFiltMod->SplitMdls = params.SplitMdls;

#ifdef HAVE_RX_SUPPORT
		// Determine whether this is our send-to-Rx adapter for the open_instance.
		if (NPF_ContainsAdapterName(&g_pDriverExtension->SendToRxAdapterName, &pFiltMod->AdapterName))
		{
			pFiltMod->SendToRxPath = TRUE;
		}
		// Determine whether this is our block-Rx adapter for the open_instance.
		if (NPF_ContainsAdapterName(&g_pDriverExtension->BlockRxAdapterName, &pFiltMod->AdapterName))
		{
			pFiltMod->BlockRxPath = TRUE;
		}
#endif

		NdisZeroMemory(&FilterAttributes, sizeof(NDIS_FILTER_ATTRIBUTES));
		FilterAttributes.Header.Type = NDIS_OBJECT_TYPE_FILTER_ATTRIBUTES;
		FilterAttributes.Header.Revision = NDIS_FILTER_ATTRIBUTES_REVISION_1;
		FilterAttributes.Header.Size = NDIS_SIZEOF_FILTER_ATTRIBUTES_REVISION_1;
		FilterAttributes.Flags = 0;

		NDIS_DECLARE_FILTER_MODULE_CONTEXT(NPCAP_FILTER_MODULE);
		Status = NdisFSetAttributes(NdisFilterHandle,
			pFiltMod,
			&FilterAttributes);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			returnStatus = Status;
			INFO_DBG("NdisFSetAttributes: error, Status=%x.\n", Status);
			break;
		}

		INFO_DBG(
			"Opened the device %ws, BindingContext=%p, dot11=%u",
			pFiltMod->AdapterName.Buffer,
			pFiltMod,
			pFiltMod->Dot11);


		// Initial attach may be done before driver has finished loading and device is created, so be safe.
		// When this runs during DriverEntry, this lock may not be set up yet.
		if ( NULL != g_pDriverExtension->AllOpensLock
				// Pretty sure this can't happen, but it'd be bad to proceed here if it did.
				&& pFiltMod->AdapterID.Value != 0) {
			// Traverse the AllOpens list looking for detached instances.
			NdisAcquireRWLockRead(g_pDriverExtension->AllOpensLock, &lockState, 0);
			for (PLIST_ENTRY Curr = g_pDriverExtension->AllOpens.Flink; Curr != &(g_pDriverExtension->AllOpens); Curr = Curr->Flink)
			{
				POPEN_INSTANCE pOpen = CONTAINING_RECORD(Curr, OPEN_INSTANCE, AllOpensEntry);
				// If it doesn't already have a filter module and it's not Loopback (since this is for NDIS only)
				if (pOpen->OpenStatus == OpenDetached && pOpen->pFiltMod == NULL && !pOpen->bLoopback
						// and its Dot11 status matches
						&& pOpen->bDot11 == pFiltMod->Dot11
						// and the AdapterID matches
					       	&& pOpen->AdapterID.Value == pFiltMod->AdapterID.Value)
				{
					// add it to this filter module's list.
					PushEntryList(&ReattachOpens, &pOpen->OpenInstancesEntry);
				}
			}
			NdisReleaseRWLock(g_pDriverExtension->AllOpensLock, &lockState);
			// For each of the discovered instances, start it up again
			PSINGLE_LIST_ENTRY Curr = PopEntryList(&ReattachOpens);
			while (Curr != NULL)
			{
				POPEN_INSTANCE pOpen = CONTAINING_RECORD(Curr, OPEN_INSTANCE, OpenInstancesEntry);
				// NPF_AddToGroupOpenArray handles updating MyPacketFilter and MyLookaheadSize
				NPF_AddToGroupOpenArray(pOpen, pFiltMod, 0);
				if (pOpen->ReattachStatus < OpenAttached)
				{
					NPF_RegisterBpf(pOpen->pFiltMod, pOpen->BpfProgram);
				}
				pOpen->OpenStatus = pOpen->ReattachStatus;
				Curr = PopEntryList(&ReattachOpens);
			}
		}

		returnStatus = STATUS_SUCCESS;
		pFiltMod->AdapterBindingStatus = FilterPaused;
		NPF_AddToFilterModuleArray(pFiltMod);
		// If any handles are running, enable ops again.
		if (pFiltMod->BpfCount > 0)
		{
			NPF_EnableOps(pFiltMod);
		}
	}
	while (bFalse);

	if (!NT_SUCCESS(returnStatus) && pFiltMod != NULL) {
		NPF_ReleaseFilterModuleResources(pFiltMod);
		//
		// Free the object itself
		//
		ExFreePool(pFiltMod);
		pFiltMod = NULL;
	}
	INFO_DBG("returnStatus=%x\n", returnStatus);
	TRACE_EXIT();
	return returnStatus;
}

//-------------------------------------------------------------------

_Use_decl_annotations_
NDIS_STATUS
NPF_Pause(
	NDIS_HANDLE                     FilterModuleContext,
	PNDIS_FILTER_PAUSE_PARAMETERS   PauseParameters
	)
{
	PNPCAP_FILTER_MODULE pFiltMod = (PNPCAP_FILTER_MODULE)FilterModuleContext;
	NDIS_STATUS             Status = NDIS_STATUS_SUCCESS;
	NDIS_EVENT Event;

	UNREFERENCED_PARAMETER(PauseParameters);
	TRACE_ENTER();

#ifdef HAVE_WFP_LOOPBACK_SUPPORT
	/* This callback is only for the NDIS LWF, not WFP/loopback */
	NT_ASSERT(!pFiltMod->Loopback);
#endif

	NdisInitializeEvent(&Event);
	NdisResetEvent(&Event);

	NdisAcquireSpinLock(&pFiltMod->AdapterHandleLock);
	NT_ASSERT(pFiltMod->AdapterBindingStatus == FilterRunning);
	pFiltMod->AdapterBindingStatus = FilterPausing;
	
	while (pFiltMod->AdapterHandleUsageCounter > 0)
	{
		NdisReleaseSpinLock(&pFiltMod->AdapterHandleLock);
		NdisWaitEvent(&Event, 1);
		NdisAcquireSpinLock(&pFiltMod->AdapterHandleLock);
	}

	pFiltMod->AdapterBindingStatus = FilterPaused;
	NdisReleaseSpinLock(&pFiltMod->AdapterHandleLock);

	Status = NDIS_STATUS_SUCCESS;
	
	TRACE_EXIT();
	return Status;
}

//-------------------------------------------------------------------

_Use_decl_annotations_
NDIS_STATUS
NPF_Restart(
	NDIS_HANDLE                     FilterModuleContext,
	PNDIS_FILTER_RESTART_PARAMETERS RestartParameters
	)
{

	PNPCAP_FILTER_MODULE pFiltMod = (PNPCAP_FILTER_MODULE)FilterModuleContext;
	NDIS_STATUS		Status;
	NTSTATUS ntStatus;
	ULONG ulTmp = 0;
	PNDIS_RESTART_ATTRIBUTES Curr = RestartParameters->RestartAttributes;
	PNDIS_RESTART_GENERAL_ATTRIBUTES GenAttr = NULL;
	struct MediaParams params = {0};

	TRACE_ENTER();

#ifdef HAVE_WFP_LOOPBACK_SUPPORT
	/* This callback is only for the NDIS LWF, not WFP/loopback */
	NT_ASSERT(!pFiltMod->Loopback);
#endif

	if (RestartParameters == NULL)
	{
		// Can't validate, but probably fine. Also, I don't think this is possible.
		return NDIS_STATUS_SUCCESS;
	}

	NdisAcquireSpinLock(&pFiltMod->AdapterHandleLock);
	NT_ASSERT(pFiltMod->AdapterBindingStatus == FilterPaused);
	pFiltMod->AdapterBindingStatus = FilterRestarting;
	NdisReleaseSpinLock(&pFiltMod->AdapterHandleLock);

	Status = NPF_ValidateParameters(&params, RestartParameters->MiniportMediaType, RestartParameters->MiniportPhysicalMediaType, NULL);
	if (Status != NDIS_STATUS_SUCCESS) {
		goto NPF_Restart_End;
	}
	pFiltMod->RawIP = params.RawIP;
	pFiltMod->EtherHeader = params.EtherHeader;
	pFiltMod->Dot11 = params.Dot11;
	pFiltMod->PacketFilterGetOK = params.PacketFilterGetOK;
	pFiltMod->Fragile = params.Fragile;

	while (Curr) {
		INFO_DBG("pFiltMod(%p) NDIS_RESTART_ATTRIBUTES Oid = %#x\n", pFiltMod, Curr->Oid);
		switch (Curr->Oid) {
			case OID_GEN_MINIPORT_RESTART_ATTRIBUTES:
				GenAttr = (PNDIS_RESTART_GENERAL_ATTRIBUTES) Curr->Data;
				// MtuSize is actually OID_GEN_MAXIMUM_FRAME_SIZE and does not include link header
				// We'll grab it because it's available, but we'll try to get something better
				pFiltMod->MaxFrameSize = GenAttr->MtuSize;
				INFO_DBG("pFiltMod(%p) NDIS_RESTART_ATTRIBUTES MtuSize = %lu\n", pFiltMod, GenAttr->MtuSize);
				pFiltMod->SupportedPacketFilters = GenAttr->SupportedPacketFilters;
#ifdef HAVE_DOT11_SUPPORT
				if (pFiltMod->Dot11)
				{
					// This is not reported in SupportedPacketFilters. Have to override it here.
					pFiltMod->SupportedPacketFilters |= NPCAP_DOT11_RAW_PACKET_FILTER;
				}
#endif
				INFO_DBG("pFiltMod(%p) NDIS_RESTART_ATTRIBUTES SupportedPacketFilters = %#x\n", pFiltMod, GenAttr->SupportedPacketFilters);
				pFiltMod->HigherLookaheadSize = GenAttr->LookaheadSize;
				INFO_DBG("pFiltMod(%p) NDIS_RESTART_ATTRIBUTES LookaheadSize = %lu\n", pFiltMod, GenAttr->LookaheadSize);
				break;
			// These have not been seen before, but worth a shot to save an OID request later:
			case OID_GEN_CURRENT_PACKET_FILTER:
				pFiltMod->HigherPacketFilter = *(PULONG) Curr->Data;
				pFiltMod->HigherPacketFilterSet = 1;
				break;
		}
		Curr = Curr->Next;
	}
	if (!NT_VERIFY(GenAttr != NULL))
	{
		ERROR_DBG("Did not find OID_GEN_MINIPORT_RESTART_ATTRIBUTES in RestartAttributes!");
	}

	// Now try OID_GEN_MAXIMUM_TOTAL_SIZE, including link header
	// If it fails, no big deal; we have the MTU at least.
	ulTmp = pFiltMod->MaxFrameSize;
	ntStatus = NPF_GetDeviceMTU(pFiltMod);
	if (!NT_SUCCESS(ntStatus))
	{
		pFiltMod->MaxFrameSize = ulTmp;
	}

	// Now that we have SupportedPacketFilters, we can set our own PacketFilter if necessary
	ulTmp = pFiltMod->MyPacketFilter;
	// Force NPF_SetPacketFilter to send the OID in case the filter was reset while we were detached.
	pFiltMod->MyPacketFilter = 0;
	ntStatus = NPF_SetPacketFilter(pFiltMod, ulTmp);
	if (!NT_SUCCESS(ntStatus))
	{
		WARNING_DBG("NPF_SetPacketFilter: error, Status=%x.\n", ntStatus);
	}

	// And we may have to set the lookahead size if this is a reattach
	ulTmp = pFiltMod->MyLookaheadSize;
	pFiltMod->MyLookaheadSize = 0;
	ntStatus = NPF_SetLookaheadSize(pFiltMod, ulTmp);
	if (!NT_SUCCESS(ntStatus))
	{
		WARNING_DBG("NPF_SetLookaheadSize: error, Status=%x.\n", ntStatus);
	}


NPF_Restart_End:
	NdisAcquireSpinLock(&pFiltMod->AdapterHandleLock);
	pFiltMod->AdapterBindingStatus = NDIS_STATUS_SUCCESS == Status ? FilterRunning : FilterPaused;
	NdisReleaseSpinLock(&pFiltMod->AdapterHandleLock);

	TRACE_EXIT();
	return Status;
}

//-------------------------------------------------------------------

_Use_decl_annotations_
VOID
NPF_DetachAdapter(
	NDIS_HANDLE     FilterModuleContext
	)
/*++

Routine Description:

	Filter detach routine.
	This is a required function that will deallocate all the resources allocated during
	FilterAttach. NDIS calls FilterDetach to remove a filter instance from a filter stack.

Arguments:

	FilterModuleContext - pointer to the filter context area.

Return Value:
	None.

NOTE: Called at PASSIVE_LEVEL and the filter is in paused state

--*/
{
	PNPCAP_FILTER_MODULE pFiltMod = (PNPCAP_FILTER_MODULE)FilterModuleContext;
	PSINGLE_LIST_ENTRY Curr = NULL;
	SINGLE_LIST_ENTRY DetachedOpens = {NULL};
	POPEN_INSTANCE pOpen = NULL;
	LOCK_STATE_EX lockState;

	TRACE_ENTER();

	/* This callback is called for loopback module by NPF_Unload. */
	NT_ASSERT(pFiltMod->AdapterBindingStatus == FilterPaused || pFiltMod->Loopback);

	NdisAcquireRWLockWrite(pFiltMod->OpenInstancesLock, &lockState, 0);
	Curr = PopEntryList(&pFiltMod->OpenInstances);
	while (Curr != NULL)
	{
		pOpen = CONTAINING_RECORD(Curr, OPEN_INSTANCE, OpenInstancesEntry);
		pOpen->ReattachStatus = NPF_DemoteOpenStatus(pOpen, OpenDetached);
		// If it's closed, ignore it. Someone else will take it from here.
		if (pOpen->ReattachStatus != OpenClosed) {
			PushEntryList(&DetachedOpens, Curr);

			if (pOpen->ReadEvent != NULL)
				KeSetEvent(pOpen->ReadEvent, 0, FALSE);
		}

		Curr = PopEntryList(&pFiltMod->OpenInstances);
	}
	NdisReleaseRWLock(pFiltMod->OpenInstancesLock, &lockState);
	NT_ASSERT(pFiltMod->BpfCount == 0);

	// Restore original filter and lookahead value
	NPF_SetPacketFilter(pFiltMod, 0);
	NPF_SetLookaheadSize(pFiltMod, 0);
	// Ensure demotions complete before we wait for pending irps
	KeMemoryBarrier();

	// for each of the instances, wait for pending irps
	Curr = PopEntryList(&DetachedOpens);
	while (Curr != NULL)
	{
		pOpen = CONTAINING_RECORD(Curr, OPEN_INSTANCE, OpenInstancesEntry);
		NPF_OpenWaitPendingIrps(pOpen);
		NdisAcquireSpinLock(&pOpen->OpenInUseLock);
		pOpen->pFiltMod = NULL;
		pOpen->OpenInstancesEntry.Next = NULL;
		NdisReleaseSpinLock(&pOpen->OpenInUseLock);
		Curr = PopEntryList(&DetachedOpens);
	}

	INFO_DBG("pFiltMod(%p)->AdapterHandleUsageCounter == %lu\n", pFiltMod, pFiltMod->AdapterHandleUsageCounter);
	while (pFiltMod->AdapterHandleUsageCounter > 0)
	{
		NdisMSleep(100);
	}
	pFiltMod->AdapterBindingStatus = FilterDetached;

	NPF_RemoveFromFilterModuleArray(pFiltMod); // Must add this, if not, SYSTEM_SERVICE_EXCEPTION BSoD will occur.
	NPF_ReleaseFilterModuleResources(pFiltMod);
	ExFreePool(pFiltMod);

	TRACE_EXIT();
	return;
}

//-------------------------------------------------------------------

_Use_decl_annotations_
NDIS_STATUS
NPF_OidRequest(
	NDIS_HANDLE         FilterModuleContext,
	PNDIS_OID_REQUEST   Request
	)
/*++

Routine Description:

	Request handler
	Handle requests from upper layers

Arguments:

	FilterModuleContext   - our filter
	Request               - the request passed down


Return Value:

	 NDIS_STATUS_SUCCESS
	 NDIS_STATUS_PENDING
	 NDIS_STATUS_XXX

NOTE: Called at <= DISPATCH_LEVEL  (unlike a miniport's MiniportOidRequest)

--*/
{
	PNPCAP_FILTER_MODULE pFiltMod = (PNPCAP_FILTER_MODULE) FilterModuleContext;
	NDIS_STATUS             Status;
	PNDIS_OID_REQUEST       ClonedRequest=NULL;
	BOOLEAN                 bSubmitted = FALSE;
	PFILTER_REQUEST_CONTEXT Context;
	BOOLEAN                 bFalse = FALSE;
    PVOID pBuffer = NULL;

	TRACE_ENTER();

#ifdef HAVE_WFP_LOOPBACK_SUPPORT
	/* This callback is only for the NDIS LWF, not WFP/loopback */
	NT_ASSERT(!pFiltMod->Loopback);
#endif

	do
	{
		if (!NT_VERIFY(Request) ||
				!NT_VERIFY(Request->Header.Type == NDIS_OBJECT_TYPE_OID_REQUEST) ||
				!NT_VERIFY(Request->Header.Revision >= NDIS_OID_REQUEST_REVISION_1) ||
				!NT_VERIFY(Request->Header.Size >= NDIS_SIZEOF_OID_REQUEST_REVISION_1)
		   ) {
			Status = NDIS_STATUS_INVALID_OID;
			break;
		}
		Status = NdisAllocateCloneOidRequest(pFiltMod->AdapterHandle,
											Request,
											NPF_CLONE_OID_TAG,
											&ClonedRequest);
		if (Status != NDIS_STATUS_SUCCESS)
		{
			INFO_DBG("FilterOidRequest: Cannot Clone Request\n");
			break;
		}

		if (!pFiltMod->Fragile && Request->RequestType == NdisRequestSetInformation &&
				(Request->DATA.SET_INFORMATION.Oid == OID_GEN_CURRENT_PACKET_FILTER
				 || Request->DATA.SET_INFORMATION.Oid == OID_GEN_CURRENT_LOOKAHEAD))
		{
			// ExAllocatePoolWithTag is permitted to be used at DISPATCH_LEVEL iff allocating from NPF_NONPAGED
#pragma warning(suppress: 28118)
			pBuffer = NPF_AllocateZeroNonpaged(sizeof(ULONG), NPF_CLONE_OID_TAG);
			if (pBuffer == NULL)
			{
				INFO_DBG("Allocate pBuffer failed, cannot modify OID value.\n");
			}
			else
			{

				switch (Request->DATA.SET_INFORMATION.Oid)
				{
					case OID_GEN_CURRENT_PACKET_FILTER:
						pFiltMod->HigherPacketFilter = *(ULONG *) Request->DATA.SET_INFORMATION.InformationBuffer;
						pFiltMod->HigherPacketFilterSet = 1;
#if DBG
						if (pFiltMod->AdapterBindingStatus == FilterRunning
								&& *(PULONG) pBuffer & ~pFiltMod->SupportedPacketFilters)
							WARNING_DBG("Upper driver setting unsupported packet filter: %#x\n", *(PULONG) pBuffer);
#endif
						*(PULONG) pBuffer = pFiltMod->HigherPacketFilter | pFiltMod->MyPacketFilter;
						break;
					case OID_GEN_CURRENT_LOOKAHEAD:
						pFiltMod->HigherLookaheadSize = *(ULONG *) Request->DATA.SET_INFORMATION.InformationBuffer;
						// We already checked for <= earlier, but better to be clear:
						*(PULONG) pBuffer = max(pFiltMod->HigherLookaheadSize, pFiltMod->MyLookaheadSize);
						break;
					default:
						NT_ASSERT(FALSE && "UNREACHABLE");
						break;
				}
				ClonedRequest->DATA.SET_INFORMATION.InformationBuffer = pBuffer;
			}
		}

		Context = (PFILTER_REQUEST_CONTEXT)(&ClonedRequest->SourceReserved[0]);
		*Context = Request; //SourceReserved != NULL indicates that this is other module's request

		bSubmitted = TRUE;

		//
		// Use same request ID
		//
		ClonedRequest->RequestId = Request->RequestId;

		pFiltMod->PendingOidRequest = ClonedRequest;

		Status = NdisFOidRequest(pFiltMod->AdapterHandle, ClonedRequest);

		if (Status != NDIS_STATUS_PENDING)
		{
			NPF_OidRequestComplete(pFiltMod, ClonedRequest, Status);
			// We return PENDING here because NPF_OidRequestComplete called
			// NdisFOidRequestComplete, which is only allowed if this function returns PENDING.
			Status = NDIS_STATUS_PENDING;
		}


	}while (bFalse);

	if (bSubmitted == FALSE)
	{
		switch(Request->RequestType)
		{
			case NdisRequestMethod:
				Request->DATA.METHOD_INFORMATION.BytesRead = 0;
				Request->DATA.METHOD_INFORMATION.BytesNeeded = 0;
				Request->DATA.METHOD_INFORMATION.BytesWritten = 0;
				break;

			case NdisRequestSetInformation:
				Request->DATA.SET_INFORMATION.BytesRead = 0;
				Request->DATA.SET_INFORMATION.BytesNeeded = 0;
				break;

			case NdisRequestQueryInformation:
			case NdisRequestQueryStatistics:
			default:
				Request->DATA.QUERY_INFORMATION.BytesWritten = 0;
				Request->DATA.QUERY_INFORMATION.BytesNeeded = 0;
				break;
		}

	}

	TRACE_EXIT();
	return Status;

}

//-------------------------------------------------------------------

_Use_decl_annotations_
VOID
NPF_CancelOidRequest(
	NDIS_HANDLE             FilterModuleContext,
	PVOID                   RequestId
	)
/*++

Routine Description:

	Cancels an OID request

	If your filter driver does not intercept and hold onto any OID requests,
	then you do not need to implement this routine.  You may simply omit it.
	Furthermore, if the filter only holds onto OID requests so it can pass
	down a clone (the most common case) the filter does not need to implement
	this routine; NDIS will then automatically request that the lower-level
	filter/miniport cancel your cloned OID.

	Most filters do not need to implement this routine.

Arguments:

	FilterModuleContext   - our filter
	RequestId             - identifies the request(s) to cancel

--*/
{
	PNPCAP_FILTER_MODULE pFiltMod = (PNPCAP_FILTER_MODULE) FilterModuleContext;
	PNDIS_OID_REQUEST                   Request = NULL;
	PFILTER_REQUEST_CONTEXT             Context;
	PNDIS_OID_REQUEST                   OriginalRequest = NULL;

#ifdef HAVE_WFP_LOOPBACK_SUPPORT
	/* This callback is only for the NDIS LWF, not WFP/loopback */
	NT_ASSERT(!pFiltMod->Loopback);
#endif

	FILTER_ACQUIRE_LOCK(&pFiltMod->OIDLock, NPF_IRQL_UNKNOWN);

	Request = pFiltMod->PendingOidRequest;

	if (Request != NULL)
	{
		Context = (PFILTER_REQUEST_CONTEXT)(&Request->SourceReserved[0]);

		OriginalRequest = (*Context);
	}

	if ((OriginalRequest != NULL) && (OriginalRequest->RequestId == RequestId))
	{
		FILTER_RELEASE_LOCK(&pFiltMod->OIDLock, NPF_IRQL_UNKNOWN);

		NdisFCancelOidRequest(pFiltMod->AdapterHandle, RequestId);
	}
	else
	{
		FILTER_RELEASE_LOCK(&pFiltMod->OIDLock, NPF_IRQL_UNKNOWN);
	}
}

//-------------------------------------------------------------------

_Use_decl_annotations_
VOID
NPF_OidRequestComplete(
	NDIS_HANDLE         FilterModuleContext,
	PNDIS_OID_REQUEST   Request,
	NDIS_STATUS         Status
	)
/*++

Routine Description:

	Notification that an OID request has been completed

	If this filter sends a request down to a lower layer, and the request is
	pended, the FilterOidRequestComplete routine is invoked when the request
	is complete.  Most requests we've sent are simply clones of requests
	received from a higher layer; all we need to do is complete the original
	higher request.

	However, if this filter driver sends original requests down, it must not
	attempt to complete a pending request to the higher layer.

Arguments:

	FilterModuleContext   - our filter context area
	NdisRequest           - the completed request
	Status                - completion status

--*/
{
	PNPCAP_FILTER_MODULE pFiltMod = (PNPCAP_FILTER_MODULE) FilterModuleContext;
	PNDIS_OID_REQUEST                   OriginalRequest;
	PFILTER_REQUEST_CONTEXT             Context;

	TRACE_ENTER();

#ifdef HAVE_WFP_LOOPBACK_SUPPORT
	/* This callback is only for the NDIS LWF, not WFP/loopback */
	NT_ASSERT(!pFiltMod->Loopback);
#endif

	Context = (PFILTER_REQUEST_CONTEXT)(&Request->SourceReserved[0]);
	OriginalRequest = (*Context);

	//
	// This is an internal request
	//
	if (OriginalRequest == NULL)
	{
		INFO_DBG("pFiltMod(%p) INTERNAL_REQUEST Oid %#x, Status %x\n", pFiltMod, Request->DATA.Oid, Status);
		PINTERNAL_REQUEST pRequest = CONTAINING_RECORD(Request, INTERNAL_REQUEST, Request);
		NT_ASSERT(pRequest->pFiltMod == pFiltMod);
		// Set the request result
		pRequest->RequestStatus = Status;
		// and awake the caller
		NdisSetEvent(&pRequest->InternalRequestCompletedEvent);
		TRACE_EXIT();
		return;
	}


	FILTER_ACQUIRE_LOCK(&pFiltMod->OIDLock, NPF_IRQL_UNKNOWN);

	NT_ASSERT(pFiltMod->PendingOidRequest == Request);
	pFiltMod->PendingOidRequest = NULL;

	FILTER_RELEASE_LOCK(&pFiltMod->OIDLock, NPF_IRQL_UNKNOWN);


	//
	// Copy the information from the returned request to the original request
	//
	switch(Request->RequestType)
	{
		case NdisRequestMethod:
			OriginalRequest->DATA.METHOD_INFORMATION.OutputBufferLength =  Request->DATA.METHOD_INFORMATION.OutputBufferLength;
			OriginalRequest->DATA.METHOD_INFORMATION.BytesRead = Request->DATA.METHOD_INFORMATION.BytesRead;
			OriginalRequest->DATA.METHOD_INFORMATION.BytesNeeded = Request->DATA.METHOD_INFORMATION.BytesNeeded;
			OriginalRequest->DATA.METHOD_INFORMATION.BytesWritten = Request->DATA.METHOD_INFORMATION.BytesWritten;
			break;

		case NdisRequestSetInformation:
			OriginalRequest->DATA.SET_INFORMATION.BytesRead = Request->DATA.SET_INFORMATION.BytesRead;
			OriginalRequest->DATA.SET_INFORMATION.BytesNeeded = Request->DATA.SET_INFORMATION.BytesNeeded;
            if (OriginalRequest->DATA.SET_INFORMATION.InformationBuffer != Request->DATA.SET_INFORMATION.InformationBuffer)
            {
                /* We modified the data on clone, e.g. OID_GEN_CURRENT_PACKET_FILTER */
                ExFreePoolWithTag(Request->DATA.SET_INFORMATION.InformationBuffer, NPF_CLONE_OID_TAG);
            }
			break;

		case NdisRequestQueryInformation:
		case NdisRequestQueryStatistics:
		default:
			OriginalRequest->DATA.QUERY_INFORMATION.BytesWritten = Request->DATA.QUERY_INFORMATION.BytesWritten;
			OriginalRequest->DATA.QUERY_INFORMATION.BytesNeeded = Request->DATA.QUERY_INFORMATION.BytesNeeded;
			break;
	}



	(*Context) = NULL;

	NdisFreeCloneOidRequest(pFiltMod->AdapterHandle, Request);

	NdisFOidRequestComplete(pFiltMod->AdapterHandle, OriginalRequest, Status);

	TRACE_EXIT();
}

//-------------------------------------------------------------------

_Use_decl_annotations_
VOID
NPF_Status(
	NDIS_HANDLE             FilterModuleContext,
	PNDIS_STATUS_INDICATION StatusIndication
	)
/*++

Routine Description:

	Status indication handler

Arguments:

	FilterModuleContext     - our filter context
	StatusIndication        - the status being indicated

NOTE: called at <= DISPATCH_LEVEL

  FILTER driver may call NdisFIndicateStatus to generate a status indication to
  all higher layer modules.

--*/
{
	PNPCAP_FILTER_MODULE pFiltMod = (PNPCAP_FILTER_MODULE) FilterModuleContext;

#ifdef HAVE_WFP_LOOPBACK_SUPPORT
	/* This callback is only for the NDIS LWF, not WFP/loopback */
	NT_ASSERT(!pFiltMod->Loopback);
#endif

// 	TRACE_ENTER();
// 	INFO_DBG("NPF: Status Indication\n");

	INFO_DBG("status %x\n", StatusIndication->StatusCode);

	// We can use this if we haven't mucked with it yet.
	if (StatusIndication->StatusCode == NDIS_STATUS_PACKET_FILTER
			&& pFiltMod->MyPacketFilter != 0
			&& !pFiltMod->HigherPacketFilterSet)
	{
		NT_ASSERT(StatusIndication->StatusBufferSize >= sizeof(ULONG));
		pFiltMod->HigherPacketFilter = *(PULONG)StatusIndication->StatusBuffer;
		pFiltMod->HigherPacketFilterSet = 1;
	}

	// If it's ours, drop it here. Otherwise, pass it on.
	if (StatusIndication->SourceHandle != pFiltMod->AdapterHandle)
	{
		NdisFIndicateStatus(pFiltMod->AdapterHandle, StatusIndication);
	}

/*	TRACE_EXIT();*/
}

//-------------------------------------------------------------------

_Use_decl_annotations_
VOID
NPF_DevicePnPEventNotify(
	NDIS_HANDLE             FilterModuleContext,
	PNET_DEVICE_PNP_EVENT   NetDevicePnPEvent
	)
/*++

Routine Description:

	Device PNP event handler

Arguments:

	FilterModuleContext         - our filter context
	NetDevicePnPEvent           - a Device PnP event

NOTE: called at PASSIVE_LEVEL

--*/
{
	PNPCAP_FILTER_MODULE pFiltMod = (PNPCAP_FILTER_MODULE) FilterModuleContext;
	NDIS_DEVICE_PNP_EVENT  DevicePnPEvent = NetDevicePnPEvent->DevicePnPEvent;

#ifdef HAVE_WFP_LOOPBACK_SUPPORT
	/* This callback is only for the NDIS LWF, not WFP/loopback */
	NT_ASSERT(!pFiltMod->Loopback);
#endif

/*	TRACE_ENTER();*/

	//
	// The filter may do processing on the event here, including intercepting
	// and dropping it entirely.  However, the sample does nothing with Device
	// PNP events, except pass them down to the next lower* layer.  It is more
	// efficient to omit the FilterDevicePnPEventNotify handler entirely if it
	// does nothing, but it is included in this sample for illustrative purposes.
	//
	// * Trivia: Device PNP events percolate DOWN the stack, instead of upwards
	// like status indications and Net PNP events.  So the next layer is the
	// LOWER layer.
	//

	switch (DevicePnPEvent)
	{

		case NdisDevicePnPEventQueryRemoved:
		case NdisDevicePnPEventRemoved:
		case NdisDevicePnPEventSurpriseRemoved:
		case NdisDevicePnPEventQueryStopped:
		case NdisDevicePnPEventStopped:
		case NdisDevicePnPEventPowerProfileChanged:
		case NdisDevicePnPEventFilterListChanged:
			break;

		default:
			INFO_DBG("FilterDevicePnPEventNotify: Invalid event.\n");
			break;
	}

	NdisFDevicePnPEventNotify(pFiltMod->AdapterHandle, NetDevicePnPEvent);

/*	TRACE_EXIT();*/
}

//-------------------------------------------------------------------

_Use_decl_annotations_
NDIS_STATUS
NPF_NetPnPEvent(
	NDIS_HANDLE              FilterModuleContext,
	PNET_PNP_EVENT_NOTIFICATION NetPnPEventNotification
	)
/*++

Routine Description:

	Net PNP event handler

Arguments:

	FilterModuleContext         - our filter context
	NetPnPEventNotification     - a Net PnP event

NOTE: called at PASSIVE_LEVEL

--*/
{
	PNPCAP_FILTER_MODULE pFiltMod = (PNPCAP_FILTER_MODULE) FilterModuleContext;
	NDIS_STATUS               Status = NDIS_STATUS_SUCCESS;

	TRACE_ENTER();

#ifdef HAVE_WFP_LOOPBACK_SUPPORT
	/* This callback is only for the NDIS LWF, not WFP/loopback */
	NT_ASSERT(!pFiltMod->Loopback);
#endif

	//
	// The filter may do processing on the event here, including intercepting
	// and dropping it entirely.  However, the sample does nothing with Net PNP
	// events, except pass them up to the next higher layer.  It is more
	// efficient to omit the FilterNetPnPEvent handler entirely if it does
	// nothing, but it is included in this sample for illustrative purposes.
	//

	Status = NdisFNetPnPEvent(pFiltMod->AdapterHandle, NetPnPEventNotification);

	TRACE_EXIT();
	return Status;
}

//-------------------------------------------------------------------

_Use_decl_annotations_
VOID
NPF_ReturnEx(
	NDIS_HANDLE         FilterModuleContext,
	PNET_BUFFER_LIST    NetBufferLists,
	ULONG               ReturnFlags
	)
/*++

Routine Description:

	FilterReturnNetBufferLists handler.
	FilterReturnNetBufferLists is an optional function. If provided, NDIS calls
	FilterReturnNetBufferLists to return the ownership of one or more NetBufferLists
	and their embedded NetBuffers to the filter driver. If this handler is NULL, NDIS
	will skip calling this filter when returning NetBufferLists to the underlying
	miniport and will call the next lower driver in the stack. A filter that doesn't
	provide a FilterReturnNetBufferLists handler cannot originate a receive indication
	on its own.

Arguments:

	FilterInstanceContext       - our filter context area
	NetBufferLists              - a linked list of NetBufferLists that this
								  filter driver indicated in a previous call to
								  NdisFIndicateReceiveNetBufferLists
	ReturnFlags                 - flags specifying if the caller is at DISPATCH_LEVEL

--*/
{
	PNPCAP_FILTER_MODULE pFiltMod = (PNPCAP_FILTER_MODULE) FilterModuleContext;
	BOOLEAN bAtDispatchLevel = NDIS_TEST_RETURN_AT_DISPATCH_LEVEL(ReturnFlags);

#ifdef HAVE_WFP_LOOPBACK_SUPPORT
	/* This callback is only for the NDIS LWF, not WFP/loopback */
	NT_ASSERT(!pFiltMod->Loopback);
#endif

	NetBufferLists = NPF_CleanupNBLs(pFiltMod, NetBufferLists, bAtDispatchLevel);

	if (NetBufferLists != NULL) {
		// Return the received NBLs.  If you removed any NBLs from the chain, make
		// sure the chain isn't empty (i.e., NetBufferLists!=NULL).
		NdisFReturnNetBufferLists(pFiltMod->AdapterHandle, NetBufferLists, ReturnFlags);
	}

/*	TRACE_EXIT();*/
}

_Use_decl_annotations_
PNET_BUFFER_LIST
NPF_CleanupNBLs(
	PNPCAP_FILTER_MODULE pFiltMod,
	PNET_BUFFER_LIST NetBufferLists,
	BOOLEAN bAtDispatchLevel
	)
{
	PNET_BUFFER_LIST pNetBufList = NetBufferLists;
	PNET_BUFFER_LIST pPrevNetBufList = NULL;

	while (pNetBufList != NULL)
	{
		// Keep track of this one
		PNET_BUFFER_LIST pNBL = pNetBufList;
		// Point to the next one
		pNetBufList = NET_BUFFER_LIST_NEXT_NBL(pNetBufList);
		PPACKET_RESERVED pRsvd = RESERVED(pNBL);

		// Only remove packets if we originated them on the receive path
		if (pNBL->SourceHandle != pFiltMod->AdapterHandle
				|| pRsvd == NULL || !pRsvd->bReceivePath)
		{
			// No match, just move down.
			pPrevNetBufList = pNBL;
			continue;
		}
		// this is our self-sent packets

		// Remove this one from the chain and move down.
		if (pPrevNetBufList == NULL) {
			// head of list, repoint NetBufferLists
			NetBufferLists = pNetBufList;
		}
		else {
			NET_BUFFER_LIST_NEXT_NBL(pPrevNetBufList) = pNetBufList;
		}
		NET_BUFFER_LIST_NEXT_NBL(pNBL) = NULL;

		NPF_FreePackets(pFiltMod, pNBL, bAtDispatchLevel);
	}
	return NetBufferLists;
}

//-------------------------------------------------------------------

_Use_decl_annotations_
VOID
NPF_CancelSendNetBufferLists(
	NDIS_HANDLE             FilterModuleContext,
	PVOID                   CancelId
	)
/*++

Routine Description:

	This function cancels any NET_BUFFER_LISTs pended in the filter and then
	calls the NdisFCancelSendNetBufferLists to propagate the cancel operation.

	If your driver does not queue any send NBLs, you may omit this routine.
	NDIS will propagate the cancelation on your behalf more efficiently.

Arguments:

	FilterModuleContext      - our filter context area.
	CancelId                 - an identifier for all NBLs that should be dequeued

Return Value:

	None

*/
{
	PNPCAP_FILTER_MODULE pFiltMod = (PNPCAP_FILTER_MODULE) FilterModuleContext;

#ifdef HAVE_WFP_LOOPBACK_SUPPORT
	/* This callback is only for the NDIS LWF, not WFP/loopback */
	NT_ASSERT(!pFiltMod->Loopback);
#endif

	NdisFCancelSendNetBufferLists(pFiltMod->AdapterHandle, CancelId);
}

//-------------------------------------------------------------------

_Use_decl_annotations_
NDIS_STATUS
NPF_SetModuleOptions(
	NDIS_HANDLE             FilterModuleContext
	)
/*++

Routine Description:

	This function set the optional handlers for the filter

Arguments:

	FilterModuleContext: The FilterModuleContext given to NdisFSetAttributes

Return Value:

	NDIS_STATUS_SUCCESS
	NDIS_STATUS_RESOURCES
	NDIS_STATUS_FAILURE

--*/
{
   NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
   UNREFERENCED_PARAMETER(FilterModuleContext);

#ifdef HAVE_WFP_LOOPBACK_SUPPORT
	/* This callback is only for the NDIS LWF, not WFP/loopback */
	NT_ASSERT(!((PNPCAP_FILTER_MODULE)FilterModuleContext)->Loopback);
#endif

   return Status;
}

//-------------------------------------------------------------------

_Use_decl_annotations_
NDIS_STATUS
NPF_SetPacketFilter(
	PNPCAP_FILTER_MODULE pFiltMod,
	ULONG PacketFilter
)
{
	PVOID pBuffer = NULL;
	NDIS_STATUS Status = STATUS_SUCCESS;
	ULONG BytesProcessed = 0;
	LOCK_STATE_EX lockState;
	ULONG NewPF = 0, OldPF = 0;
	BOOLEAN bail_early = FALSE;

	TRACE_DBG("pFiltMod=%p, PacketFilter=%#lx\n", pFiltMod, PacketFilter);

	if (pFiltMod->Fragile || pFiltMod->Loopback)
	{
		// Fake it
		bail_early = TRUE;
	}

	if (!pFiltMod->HigherPacketFilterSet)
	{
		Status = NPF_GetPacketFilter(pFiltMod);
		if (Status != NDIS_STATUS_SUCCESS)
		{
			INFO_DBG("pFiltMod(%p) can't set PacketFilter; no valid HigherPacketFilter present.\n", pFiltMod);
			// Have to fake success; many miniport types don't like queries to OID_GEN_CURRENT_PACKET_FILTER.
			Status = STATUS_SUCCESS;
			bail_early = TRUE;
		}
	}

	if (bail_early)
	{
		pFiltMod->MyPacketFilter = PacketFilter;
		return Status;
	}

	// Only set packet filter if we know what it was previously and can revert to that.
	NT_ASSERT(pFiltMod->HigherPacketFilterSet);

	NdisAcquireRWLockWrite(pFiltMod->OpenInstancesLock, &lockState, 0);

	// Calculate old and new effective filters
	OldPF = pFiltMod->SupportedPacketFilters & (pFiltMod->HigherPacketFilter | pFiltMod->MyPacketFilter);
	NewPF = pFiltMod->SupportedPacketFilters & (pFiltMod->HigherPacketFilter | PacketFilter);

	// If the new effective filter is the same as the old one, nothing left to do.
	bail_early = (OldPF == NewPF);

	// Regardless, track our current preferred packet filter.
	pFiltMod->MyPacketFilter = PacketFilter;

	NdisReleaseRWLock(pFiltMod->OpenInstancesLock, &lockState);

	if (bail_early)
	{
		return NDIS_STATUS_SUCCESS;
	}

	pBuffer = NPF_AllocateZeroNonpaged(sizeof(PacketFilter), NPF_INTERNAL_OID_TAG);
	if (pBuffer == NULL)
	{
		INFO_DBG("Allocate pBuffer failed\n");
			TRACE_EXIT();
		return NDIS_STATUS_RESOURCES;
	}
	// Init the buffer
	*(PULONG) pBuffer = NewPF;
	INFO_DBG("New packet filter: %#lx\n", NewPF);

	// set the PacketFilter
	Status = NPF_DoInternalRequest(pFiltMod,
		NdisRequestSetInformation,
		OID_GEN_CURRENT_PACKET_FILTER,
		pBuffer,
		sizeof(PacketFilter),
		0,
		0,
		&BytesProcessed
	);
	// Some drivers do not set BytesRead for Set requests
	UNREFERENCED_PARAMETER(BytesProcessed);

	ExFreePoolWithTag(pBuffer, NPF_INTERNAL_OID_TAG);

	TRACE_EXIT();
	return Status;
}

_Use_decl_annotations_
NDIS_STATUS
NPF_SetLookaheadSize(
	PNPCAP_FILTER_MODULE pFiltMod,
	ULONG LookaheadSize
)
{
	PVOID pBuffer = NULL;
	NDIS_STATUS Status = STATUS_SUCCESS;
	ULONG BytesProcessed = 0;
	ULONG OldValue = pFiltMod->MyLookaheadSize;

	TRACE_ENTER();
	pFiltMod->MyLookaheadSize = LookaheadSize;

	if (pFiltMod->Fragile || pFiltMod->Loopback)
	{
		// Fake it
		return NDIS_STATUS_SUCCESS;
	}

	// If neither the new or the old value is greater than the upper value,
	if (LookaheadSize <= pFiltMod->HigherLookaheadSize
			&& OldValue <= pFiltMod->HigherLookaheadSize)
	{
		// Nothing left to do!
		return NDIS_STATUS_SUCCESS;
	}
	// If the new value is the same as the old one,
	if (LookaheadSize == OldValue)
	{
		// Nothing left to do!
		return NDIS_STATUS_SUCCESS;
	}
	// Otherwise, we have to update the stack with our new max value.

	pBuffer = NPF_AllocateZeroNonpaged(sizeof(ULONG), NPF_INTERNAL_OID_TAG);
	if (pBuffer == NULL)
	{
		INFO_DBG("Allocate pBuffer failed\n");
			TRACE_EXIT();
		return NDIS_STATUS_RESOURCES;
	}
	*(PULONG) pBuffer = max(pFiltMod->HigherLookaheadSize, LookaheadSize);

	// set the LookaheadSize
	Status = NPF_DoInternalRequest(pFiltMod,
		NdisRequestSetInformation,
		OID_GEN_CURRENT_LOOKAHEAD,
		pBuffer,
		sizeof(ULONG),
		0,
		0,
		&BytesProcessed
	);

	ExFreePoolWithTag(pBuffer, NPF_INTERNAL_OID_TAG);

	// Some drivers do not set BytesRead for Set requests
	UNREFERENCED_PARAMETER(BytesProcessed);
	TRACE_EXIT();
	return Status;
}

//-------------------------------------------------------------------

_Use_decl_annotations_
NDIS_STATUS NPF_DoInternalRequest(
	PNPCAP_FILTER_MODULE pFiltMod,
	NDIS_REQUEST_TYPE RequestType,
	NDIS_OID Oid,
	PVOID InformationBuffer,
	ULONG InformationBufferLength,
	ULONG OutputBufferLength,
	ULONG MethodId,
	PULONG pBytesProcessed)
{
	TRACE_ENTER();
	// NdisFOidRequest requires Restarting, Running, Pausing, or Paused state.
	NT_ASSERT(pFiltMod->AdapterBindingStatus >= FilterPausing && pFiltMod->AdapterBindingStatus <= FilterRestarting);

	NDIS_STATUS                 Status = NDIS_STATUS_FAILURE;

	*pBytesProcessed = 0;

	PINTERNAL_REQUEST pInternalRequest = ExAllocateFromLookasideListEx(&g_pDriverExtension->InternalRequestPool);
	if (pInternalRequest == NULL)
	{
		ERROR_DBG("Failed to allocate pInternalRequest\n");
		Status = NDIS_STATUS_RESOURCES;
		goto InternalRequestExit;
	}
	RtlZeroMemory(pInternalRequest, sizeof(INTERNAL_REQUEST));

	PNDIS_OID_REQUEST NdisRequest = &pInternalRequest->Request;

	pInternalRequest->pFiltMod = pFiltMod;
	pInternalRequest->RequestStatus = NDIS_STATUS_PENDING;

	NdisInitializeEvent(&pInternalRequest->InternalRequestCompletedEvent);
	NdisResetEvent(&pInternalRequest->InternalRequestCompletedEvent);

	NdisRequest->Header.Type = NDIS_OBJECT_TYPE_OID_REQUEST;
#if NDIS_SUPPORT_NDIS650
	if (g_pDriverExtension->NdisVersion >= NDIS_RUNTIME_VERSION_650) {
		NdisRequest->Header.Revision = NDIS_OID_REQUEST_REVISION_2;
		NdisRequest->Header.Size = NDIS_SIZEOF_OID_REQUEST_REVISION_2;
	} else
#endif
	{
		NdisRequest->Header.Revision = NDIS_OID_REQUEST_REVISION_1;
		NdisRequest->Header.Size = NDIS_SIZEOF_OID_REQUEST_REVISION_1;
	}

	NdisRequest->RequestType = RequestType;
	NdisRequest->RequestHandle = pFiltMod->AdapterHandle;
	*(PVOID *)NdisRequest->SourceReserved = NULL; //indicates this is a self-sent request
	NdisRequest->DATA.Oid = Oid;

	switch (RequestType)
	{
		case NdisRequestQueryInformation:
			NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer = InformationBuffer;
			NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength = InformationBufferLength;
			break;

		case NdisRequestSetInformation:
			NdisRequest->DATA.SET_INFORMATION.InformationBuffer = InformationBuffer;
			NdisRequest->DATA.SET_INFORMATION.InformationBufferLength = InformationBufferLength;
			break;

		case NdisRequestMethod:
			NdisRequest->DATA.METHOD_INFORMATION.MethodId = MethodId;
			NdisRequest->DATA.METHOD_INFORMATION.InformationBuffer = InformationBuffer;
			NdisRequest->DATA.METHOD_INFORMATION.InputBufferLength = InformationBufferLength;
			NdisRequest->DATA.METHOD_INFORMATION.OutputBufferLength = OutputBufferLength;
			break;

		default:
			INFO_DBG("Unsupported RequestType: %d\n", RequestType);
			TRACE_EXIT();
			Status = NDIS_STATUS_INVALID_PARAMETER;
			goto InternalRequestExit;
			break;
	}

	NdisRequest->RequestId = (PVOID)NPF_REQUEST_ID;

	Status = NdisFOidRequest(pFiltMod->AdapterHandle, NdisRequest);

	if (Status == NDIS_STATUS_PENDING)
	{
		// Wait for this event which is signaled by NPF_OidRequestComplete,
		// which also sets RequestStatus appropriately
		NdisWaitEvent(&pInternalRequest->InternalRequestCompletedEvent, 0);
		Status = pInternalRequest->RequestStatus;
	}

	if (Status == NDIS_STATUS_SUCCESS)
	{
		// The driver below should set the correct value to BytesWritten
		// or BytesRead. But now, we just truncate the value to InformationBufferLength
		// due to bug in Nortel driver ipsecw2k.sys v. 4.10.0.0 that doesn't set the BytesWritten correctly
		// The driver is the one shipped with Nortel client Contivity VPN Client V04_65.18, and the MD5 for the buggy (unsigned) driver
		// is 3c2ff8886976214959db7d7ffaefe724 *ipsecw2k.sys (there are multiple copies of this binary with the same exact version info!)
		// The (certified) driver shipped with Nortel client Contivity VPN Client V04_65.320 doesn't seem affected by the bug.
		switch (RequestType)
		{
			case NdisRequestSetInformation:
				*pBytesProcessed = min(NdisRequest->DATA.SET_INFORMATION.BytesRead, InformationBufferLength);
				break;
			case NdisRequestQueryInformation:
				*pBytesProcessed = min(NdisRequest->DATA.QUERY_INFORMATION.BytesWritten, InformationBufferLength);
				break;
			case NdisRequestMethod:
				*pBytesProcessed = min(NdisRequest->DATA.METHOD_INFORMATION.BytesWritten, OutputBufferLength);
				break;
			default:
				NT_ASSERT(RequestType && FALSE);
				Status = NDIS_STATUS_INVALID_PARAMETER;
				goto InternalRequestExit;
				break;
		}
	}
	else if (Status == NDIS_STATUS_INDICATION_REQUIRED)
	{
		// We don't handle this currently
		WARNING_DBG("pFiltMod(%p) OID %#x NDIS_STATUS_INDICATION_REQUIRED\n", pFiltMod, Oid);
	}

InternalRequestExit:

	if (pInternalRequest)
	{
		ExFreeToLookasideListEx(&g_pDriverExtension->InternalRequestPool, pInternalRequest);
	}
	INFO_DBG("pFiltMod(%p) OID %s %#x: Status = %#x; Bytes = %lu\n", pFiltMod, RequestType == NdisRequestQueryInformation ? "GET" : "SET", Oid, Status, *pBytesProcessed);
	TRACE_EXIT();
	return Status;
}

```

`packetWin7/npf/npf/Packet.c`:

```c
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
/*
 * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)
 * Copyright (c) 2005 - 2010 CACE Technologies, Davis (California)
 * Copyright (c) 2010 - 2013 Riverbed Technology, San Francisco (California), Yang Luo (China)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Politecnico di Torino, CACE Technologies
 * nor the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include "stdafx.h"

#include "Packet.h"
#include "Loopback.h"
#include "win_bpf.h"
#include "ioctls.h"

#include "..\..\..\version.h"
#include "..\..\..\Common\WpcapNames.h"

#include <minwindef.h>

#ifdef ALLOC_PRAGMA
#pragma NDIS_INIT_FUNCTION(DriverEntry)
#endif // ALLOC_PRAGMA

PNPCAP_DRIVER_EXTENSION g_pDriverExtension = NULL;
LARGE_INTEGER TimeFreq = {0};

UNICODE_STRING deviceSymLink = RTL_CONSTANT_STRING(L"\\DosDevices\\" NPF_DRIVER_NAME_WIDECHAR);


#ifdef NPCAP_READ_ONLY
// For read-only Npcap, we want an explicit denial function for the Write call.
// The IOCTLs will be rejected as "invalid request"
_Dispatch_type_(IRP_MJ_WRITE)
DRIVER_DISPATCH NPF_Deny;

_Use_decl_annotations_
NTSTATUS NPF_Deny(
		IN PDEVICE_OBJECT DeviceObject,
		IN PIRP Irp
		)
{
	UNREFERENCED_PARAMETER(DeviceObject);
	TRACE_ENTER();
	Irp->IoStatus.Information = 0;
	Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	TRACE_EXIT();
	return STATUS_UNSUCCESSFUL;
}
#endif

/*!
  \brief The initialization routine of the LWF data structure.
  \param pFChars The LWF data structure.
  \param bWiFiOrNot Whether the LWF is registered as a WiFi one or standard one.
  \return NULL
*/
VOID
NPF_registerLWF(
	_Out_ PNDIS_FILTER_DRIVER_CHARACTERISTICS pFChars,
	_In_ UINT NdisVersion,
	_In_ BOOLEAN bWiFiOrNot
	);

/*!
  \brief read Npcap software's registry, get the option.

  If the registry key doesn't exist, we view the result as 0.
*/
_IRQL_requires_(PASSIVE_LEVEL)
ULONG
NPF_GetRegistryOption_Integer(
	_In_ PUNICODE_STRING RegistryPath,
	_In_ PUNICODE_STRING RegValueName
	);

/*!
  \brief read Npcap software's registry, get the option

  If NPF_GetLoopbackAdapterName() fails, g_LoopbackAdapterName will be NULL.
*/
_IRQL_requires_(PASSIVE_LEVEL)
VOID
NPF_GetRegistryOption_String(
	_In_ PUNICODE_STRING RegistryPath,
	_In_ PUNICODE_STRING RegValueName,
	_Inout_ PNDIS_STRING OutputString
	);

// This will get a list of adapter names, strip out any \Device\ prefix.
_IRQL_requires_(PASSIVE_LEVEL)
static VOID
NPF_GetRegistryOption_AdapterName(
	_In_ PUNICODE_STRING pRegistryPath,
	_In_ PUNICODE_STRING pRegValueName,
	_Inout_ PNDIS_STRING pOutputString
	)
{
	USHORT i=0, j=0;
	NPF_GetRegistryOption_String(pRegistryPath, pRegValueName, pOutputString);
	if (pOutputString->Buffer == NULL)
	{
		// Not found, that's fine.
		pOutputString->Length = 0;
		pOutputString->MaximumLength = 0;
		return;
	}
	// We don't actually want the "\\Device\\" prefix.
	j = DEVICE_PATH_CCH;
	while (j < BYTES2CCH(pOutputString->Length))
	{
		pOutputString->Buffer[i] = pOutputString->Buffer[j];
		if(pOutputString->Buffer[i] == L';') {
			// Separator found, need to jump over another prefix
			j += DEVICE_PATH_CCH;
		}
		i++;
		j++;
	}
	// Fix up the length to the number of bytes we actually copied.
	pOutputString->Length = CCH2BYTES(i);
}
//-------------------------------------------------------------------
//
//  Packet Driver's entry routine.
//
_Use_decl_annotations_
NTSTATUS
DriverEntry(
	IN PDRIVER_OBJECT DriverObject,
	IN PUNICODE_STRING RegistryPath
	)
{
	NDIS_FILTER_DRIVER_CHARACTERISTICS FChars; // The specification for the filter.
	NDIS_FILTER_DRIVER_CHARACTERISTICS FChars_WiFi; // The specification for the WiFi filter.
	UNICODE_STRING parametersPath;
	NTSTATUS Status = STATUS_SUCCESS;
	// https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/sddl-for-device-objects
#define SDDL_ALLOW_ALL_SYSTEM_ADMIN L"D:P(A;;GA;;;SY)(A;;GA;;;BA)"
#ifndef NPCAP_READ_ONLY
	UNICODE_STRING sddl = RTL_CONSTANT_STRING(SDDL_ALLOW_ALL_SYSTEM_ADMIN L"(A;;GRGW;;;WD)");
#else
	// For convenience and clarity, deny write access (GW) here. In reality, we
	// remove any code that injects packets in this configuration
	UNICODE_STRING sddl = RTL_CONSTANT_STRING(SDDL_ALLOW_ALL_SYSTEM_ADMIN L"(A;;GR;;;WD)");
#endif
	UNICODE_STRING sddl_admin_only = RTL_CONSTANT_STRING(SDDL_ALLOW_ALL_SYSTEM_ADMIN);
	const GUID guidClassNPF = { 0x26e0d1e0L, 0x8189, 0x12e0, { 0x99, 0x14, 0x08, 0x00, 0x22, 0x30, 0x19, 0x04 } };
	UNICODE_STRING AdapterName = RTL_CONSTANT_STRING(DEVICE_PATH_PREFIX NPF_DRIVER_NAME_WIDECHAR);

	TRACE_ENTER();
	// global config info, could use IoAllocateDriverObjectExtension, but
	// that would require access to DRIVER_OBJECT to retrieve.
	g_pDriverExtension = NPF_AllocateZeroNonpaged(sizeof(NPCAP_DRIVER_EXTENSION), NPF_DRIVER_EXTENSION_TAG);
	if (g_pDriverExtension == NULL)
	{
		ERROR_DBG("Failed to alloc g_pDriverExtension.\n");
		TRACE_EXIT();
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	g_pDriverExtension->NdisVersion = NdisGetVersion();
	if (!NT_VERIFY(g_pDriverExtension->NdisVersion >= MAKELONG(
					NDIS_FILTER_MINIMUM_MINOR_VERSION, NDIS_FILTER_MINIMUM_MAJOR_VERSION))) {
		ERROR_DBG("Incompatible NDIS version (too low).\n");
		TRACE_EXIT();
		return STATUS_NDIS_BAD_VERSION;
	}
	if (g_pDriverExtension->NdisVersion > MAKELONG(NDIS_FILTER_MINOR_VERSION, NDIS_FILTER_MAJOR_VERSION)) {
		g_pDriverExtension->NdisVersion = MAKELONG(NDIS_FILTER_MINOR_VERSION, NDIS_FILTER_MAJOR_VERSION);
	}

	RtlInitUnicodeString(&parametersPath, NULL);
	parametersPath.MaximumLength=RegistryPath->Length+sizeof(L"\\Parameters");
	parametersPath.Buffer=NPF_AllocateZeroPaged(parametersPath.MaximumLength, NPF_UNICODE_BUFFER_TAG);
	if (!parametersPath.Buffer) {
		ERROR_DBG("Paged alloc of parametersPath failed.\n");
		ExFreePool(g_pDriverExtension);
		TRACE_EXIT();
		return STATUS_INSUFFICIENT_RESOURCES;
	}
	RtlCopyUnicodeString(&parametersPath, RegistryPath);
	RtlAppendUnicodeToString(&parametersPath, L"\\Parameters");

	Status = RtlCheckRegistryKey(RTL_REGISTRY_ABSOLUTE,
			parametersPath.Buffer);
	if (NT_SUCCESS(Status)) {
		// Get the AdminOnly option, if AdminOnly=1, devices will be created with the safe SDDL, to make sure only Administrators can use Npcap driver.
		// If the registry key doesn't exist, we view it as AdminOnly=0, so no protect to the driver access.
		NDIS_STRING AdminOnlyRegValueName = NDIS_STRING_CONST("AdminOnly");
		g_pDriverExtension->bAdminOnlyMode = !!NPF_GetRegistryOption_Integer(&parametersPath, &AdminOnlyRegValueName);
		INFO_DBG("g_AdminOnlyMode = %lu\n", g_pDriverExtension->bAdminOnlyMode);

		// Get the DltNull option, if DltNull=1, loopback traffic will be DLT_NULL/DLT_LOOP style, including captured and sent packets.
		// If the registry key doesn't exist, we view it as DltNull=0, so loopback traffic are Ethernet packets.
		NDIS_STRING DltNullRegValueName = NDIS_STRING_CONST("DltNull");
		g_pDriverExtension->bDltNullMode = !!NPF_GetRegistryOption_Integer(&parametersPath, &DltNullRegValueName);
		INFO_DBG("g_DltNullMode = %lu\n", g_pDriverExtension->bDltNullMode);

		// Get the Dot11Support option, if Dot11Support=1, Npcap driver will enable the raw 802.11 functions.
		// If the registry key doesn't exist, we view it as Dot11Support=0, so no raw 802.11 support.
		NDIS_STRING Dot11SupportRegValueName = NDIS_STRING_CONST("Dot11Support");
		g_pDriverExtension->bDot11SupportMode = !!NPF_GetRegistryOption_Integer(&parametersPath, &Dot11SupportRegValueName);
		INFO_DBG("g_Dot11SupportMode = %lu\n", g_pDriverExtension->bDot11SupportMode);

		// Get the TimestampMode option. The meanings of its values is described in time_calls.h.
		// If the registry key doesn't exist, we view it as TimestampMode=0, so the default "QueryPerformanceCounter" timestamp gathering method.
		NDIS_STRING TimestampRegValueName = NDIS_STRING_CONST("TimestampMode");
		g_pDriverExtension->TimestampMode = NPF_GetRegistryOption_Integer(&parametersPath, &TimestampRegValueName);
		INFO_DBG("g_TimestampMode = %lu\n", g_pDriverExtension->TimestampMode);
		if (!NPF_TimestampModeSupported(g_pDriverExtension->TimestampMode)) {
			g_pDriverExtension->TimestampMode = DEFAULT_TIMESTAMPMODE;
		}

		// Get the TestMode option, if TestMode!=0, WFP callbacks will be registered regardless of whether any open instance needs it.
		// This is for WHQL testing.
		NDIS_STRING TestModeRegValueName = NDIS_STRING_CONST("TestMode");
		g_pDriverExtension->bTestMode = !!NPF_GetRegistryOption_Integer(&parametersPath, &TestModeRegValueName);
		INFO_DBG("g_TestMode = %lu\n", g_pDriverExtension->bTestMode);

#ifdef HAVE_WFP_LOOPBACK_SUPPORT
		NDIS_STRING LoopbackSupportRegValueName = NDIS_STRING_CONST("LoopbackSupport");
		g_pDriverExtension->bLoopbackSupportMode = !!NPF_GetRegistryOption_Integer(&parametersPath, &LoopbackSupportRegValueName);
		INFO_DBG("g_LoopbackSupportMode = %lu\n", g_pDriverExtension->bLoopbackSupportMode);
		if (g_pDriverExtension->bLoopbackSupportMode) {
			NDIS_STRING LoopbackRegValueName = NDIS_STRING_CONST("LoopbackAdapter");
			NPF_GetRegistryOption_AdapterName(&parametersPath, &LoopbackRegValueName, &g_pDriverExtension->LoopbackAdapterName);
		}
#endif
#ifdef HAVE_RX_SUPPORT
		NDIS_STRING SendToRxRegValueName = NDIS_STRING_CONST("SendToRxAdapters");
		NPF_GetRegistryOption_AdapterName(&parametersPath, &SendToRxRegValueName, &g_pDriverExtension->SendToRxAdapterName);
		NDIS_STRING BlockRxRegValueName = NDIS_STRING_CONST("BlockRxAdapters");
		NPF_GetRegistryOption_AdapterName(&parametersPath, &BlockRxRegValueName, &g_pDriverExtension->BlockRxAdapterName);
#endif
	}
	if (parametersPath.Buffer) ExFreePool(parametersPath.Buffer);

	//
	// Register as a service with NDIS
	//
	NPF_registerLWF(&FChars, g_pDriverExtension->NdisVersion, FALSE);
	if (g_pDriverExtension->bDot11SupportMode)
		NPF_registerLWF(&FChars_WiFi, g_pDriverExtension->NdisVersion, TRUE);

	DriverObject->DriverUnload = NPF_Unload;

	//
	// Standard device driver entry points stuff.
	//
	DriverObject->MajorFunction[IRP_MJ_CREATE] = NPF_OpenAdapter;
	DriverObject->MajorFunction[IRP_MJ_CLOSE] = NPF_CloseAdapter;
	DriverObject->MajorFunction[IRP_MJ_CLEANUP] = NPF_Cleanup;
	DriverObject->MajorFunction[IRP_MJ_READ] = NPF_Read;
#ifndef NPCAP_READ_ONLY
	DriverObject->MajorFunction[IRP_MJ_WRITE] = NPF_Write;
#else
	// Explicitly reject write calls
	DriverObject->MajorFunction[IRP_MJ_WRITE] = NPF_Deny;
#endif
	DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = NPF_IoControl;

	// Create the "NPCAP" device itself:
	Status = IoCreateDeviceSecure(DriverObject, sizeof(PVOID), &AdapterName, FILE_DEVICE_UNKNOWN,
			FILE_DEVICE_SECURE_OPEN, FALSE, (g_pDriverExtension->bAdminOnlyMode ? &sddl_admin_only : &sddl), (LPCGUID)&guidClassNPF, &g_pDriverExtension->pNpcapDeviceObject);
	if (!NT_SUCCESS(Status))
	{
		ERROR_DBG("IoCreateDevice failed: %#08x\n", Status);

		ExFreePool(g_pDriverExtension);
		TRACE_EXIT();
		return Status;
	}

	*(PNPCAP_DRIVER_EXTENSION *)g_pDriverExtension->pNpcapDeviceObject->DeviceExtension = g_pDriverExtension;

	g_pDriverExtension->pNpcapDeviceObject->Flags |= DO_DIRECT_IO;

	Status = IoCreateSymbolicLink(&deviceSymLink, &AdapterName);
	if (!NT_SUCCESS(Status))
	{
		ERROR_DBG("IoCreateSymbolicLink(%ws) failed: %#08x\n", deviceSymLink.Buffer, Status);

		IoDeleteDevice(g_pDriverExtension->pNpcapDeviceObject);

		ExFreePool(g_pDriverExtension);
		TRACE_EXIT();
		return Status;
	}

	// Initialize DEVICE_EXTENSION
	do {
		Status = STATUS_INSUFFICIENT_RESOURCES; // Status for any of the below failures
		InitializeListHead(&g_pDriverExtension->AllOpens);

		Status = ExInitializeLookasideListEx(&g_pDriverExtension->NBLCopyPool, NULL, NULL, NPF_NONPAGED, 0, sizeof(NPF_NBL_COPY), NPF_NBLC_POOL_TAG, 0);
		if (Status != STATUS_SUCCESS)
		{
			ERROR_DBG("Failed to allocate NBLCopyPool\n");
			break;
		}
		g_pDriverExtension->bNBLCopyPoolInit = 1;

		Status = ExInitializeLookasideListEx(&g_pDriverExtension->NBCopiesPool, NULL, NULL, NPF_NONPAGED, 0, sizeof(NPF_NB_COPIES), NPF_NBC_POOL_TAG, 0);
		if (Status != STATUS_SUCCESS)
		{
			ERROR_DBG("Failed to allocate NBCopiesPool\n");
			break;
		}
		g_pDriverExtension->bNBCopiesPoolInit = 1;

		Status = ExInitializeLookasideListEx(&g_pDriverExtension->SrcNBPool, NULL, NULL, NPF_NONPAGED, 0, sizeof(NPF_SRC_NB), NPF_SRCNB_POOL_TAG, 0);
		if (Status != STATUS_SUCCESS)
		{
			ERROR_DBG("Failed to allocate SrcNBPool\n");
			break;
		}
		g_pDriverExtension->bSrcNBPoolInit = 1;

		Status = ExInitializeLookasideListEx(&g_pDriverExtension->InternalRequestPool, NULL, NULL, NPF_NONPAGED, 0, sizeof(INTERNAL_REQUEST), NPF_REQ_POOL_TAG, 0);
		if (Status != STATUS_SUCCESS)
		{
			ERROR_DBG("Failed to allocate InternalRequestPool\n");
			break;
		}
		g_pDriverExtension->bInternalRequestPoolInit = 1;

		Status = ExInitializeLookasideListEx(&g_pDriverExtension->CapturePool, NULL, NULL, NPF_NONPAGED, 0, sizeof(NPF_CAP_DATA), NPF_CAP_POOL_TAG, 0);
		if (Status != STATUS_SUCCESS)
		{
			ERROR_DBG("Failed to allocate CapturePool\n");
			break;
		}
		g_pDriverExtension->bCapturePoolInit = 1;

#ifdef HAVE_DOT11_SUPPORT
		if (g_pDriverExtension->bDot11SupportMode)
		{
			Status = ExInitializeLookasideListEx(&g_pDriverExtension->Dot11HeaderPool, NULL, NULL, NPF_NONPAGED, 0, SIZEOF_RADIOTAP_BUFFER, NPF_DOT11_POOL_TAG, 0);
			if (Status != STATUS_SUCCESS)
			{
				ERROR_DBG("Failed to allocate Dot11HeaderPool\n");
				break;
			}
			g_pDriverExtension->bDot11HeaderPoolInit = 1;
		}
#endif

#ifdef HAVE_WFP_LOOPBACK_SUPPORT
		KeInitializeMutex(&g_pDriverExtension->WFPInitMutex, 0);
		Status = NPF_WFPCalloutRegister();
		if (!NT_SUCCESS(Status))
		{
			ERROR_DBG("NPF_WFPCalloutRegister failed: %#08x\n", Status);
			break;
		}
#endif

		/* Have to set this up before NdisFRegisterFilterDriver, since we can get Attach calls immediately after that! */
		NdisAllocateSpinLock(&g_pDriverExtension->FilterArrayLock);
		g_pDriverExtension->pNpcapDeviceObject = g_pDriverExtension->pNpcapDeviceObject;
		KeMemoryBarrier();

		// Register the filter to NDIS.
		Status = NdisFRegisterFilterDriver(DriverObject,
				(NDIS_HANDLE) g_pDriverExtension,
				&FChars,
				&g_pDriverExtension->FilterDriverHandle);
		if (Status != NDIS_STATUS_SUCCESS)
		{
			ERROR_DBG("NdisFRegisterFilterDriver failed: %#08x\n", Status);
			break;
		}
		INFO_DBG("FilterDriverHandle = %p\n", g_pDriverExtension->FilterDriverHandle);

		// Now that we have a NDIS handle, we can allocate this lock.
		// Win8 and up allow NULL instead, but Win7 does not, and SAL complains anyway.
		g_pDriverExtension->AllOpensLock = NdisAllocateRWLock(g_pDriverExtension->FilterDriverHandle);
		if (g_pDriverExtension->AllOpensLock == NULL)
		{
			ERROR_DBG("Failed to allocate AllOpensLock\n");
			Status = STATUS_INSUFFICIENT_RESOURCES;
			break;
		}
		Status = STATUS_SUCCESS;
	} while (0);

	if (!NT_SUCCESS(Status))
	{
		if (g_pDriverExtension->FilterDriverHandle)
			NdisFDeregisterFilterDriver(g_pDriverExtension->FilterDriverHandle);

#ifdef HAVE_WFP_LOOPBACK_SUPPORT
		NPF_WFPCalloutUnregister();
#endif

#ifdef HAVE_DOT11_SUPPORT
		if (g_pDriverExtension->bDot11HeaderPoolInit)
			ExDeleteLookasideListEx(&g_pDriverExtension->Dot11HeaderPool);
#endif
		if (g_pDriverExtension->bCapturePoolInit)
			ExDeleteLookasideListEx(&g_pDriverExtension->CapturePool);
		if (g_pDriverExtension->bInternalRequestPoolInit)
			ExDeleteLookasideListEx(&g_pDriverExtension->InternalRequestPool);
		if (g_pDriverExtension->bNBCopiesPoolInit)
			ExDeleteLookasideListEx(&g_pDriverExtension->NBCopiesPool);
		if (g_pDriverExtension->bNBLCopyPoolInit)
			ExDeleteLookasideListEx(&g_pDriverExtension->NBLCopyPool);
		if (g_pDriverExtension->bSrcNBPoolInit)
			ExDeleteLookasideListEx(&g_pDriverExtension->SrcNBPool);
		if (g_pDriverExtension->AllOpensLock)
			NdisFreeRWLock(g_pDriverExtension->AllOpensLock);
		NdisFreeSpinLock(&g_pDriverExtension->FilterArrayLock);
		IoDeleteSymbolicLink(&deviceSymLink);
		IoDeleteDevice(g_pDriverExtension->pNpcapDeviceObject);

		if (g_pDriverExtension->LoopbackAdapterName.Buffer != NULL)
		{
			ExFreePool(g_pDriverExtension->LoopbackAdapterName.Buffer);
			g_pDriverExtension->LoopbackAdapterName.Buffer = NULL;
		}
		if (g_pDriverExtension->SendToRxAdapterName.Buffer != NULL)
		{
			ExFreePool(g_pDriverExtension->SendToRxAdapterName.Buffer);
			g_pDriverExtension->SendToRxAdapterName.Buffer = NULL;
		}
		if (g_pDriverExtension->BlockRxAdapterName.Buffer != NULL)
		{
			ExFreePool(g_pDriverExtension->BlockRxAdapterName.Buffer);
			g_pDriverExtension->BlockRxAdapterName.Buffer = NULL;
		}

		ExFreePool(g_pDriverExtension);
		TRACE_EXIT();
		return Status;
	}


#ifdef HAVE_WFP_LOOPBACK_SUPPORT
	if (g_pDriverExtension->bLoopbackSupportMode) {
		do {
			// Create the fake "filter module" for loopback capture
			// This is a hack to let NPF_CreateFilterModule create "\Device\NPCAP\Loopback" just like it usually does with a GUID
			NDIS_STRING LoopbackDeviceName = NDIS_STRING_CONST("\\Device\\Loopback");
			PNPCAP_FILTER_MODULE pFiltMod = NPF_CreateFilterModule(g_pDriverExtension->FilterDriverHandle, &LoopbackDeviceName);
			if (pFiltMod == NULL)
			{
				WARNING_DBG("Could not create filter module for loopback.\n");
				break;
			}
			pFiltMod->Loopback = TRUE;
			pFiltMod->EtherHeader = !g_pDriverExtension->bDltNullMode;
			pFiltMod->AdapterBindingStatus = FilterRunning;
			pFiltMod->MaxFrameSize = NPF_LOOPBACK_INTERFACR_MTU + (
					pFiltMod->EtherHeader ? ETHER_HDR_LEN : DLT_NULL_HDR_LEN
					);
			g_pDriverExtension->pLoopbackFilter = pFiltMod;

			// No need to mess with SendToRx/BlockRx, packet filters, NDIS filter characteristics, Dot11, etc.
			NPF_AddToFilterModuleArray(pFiltMod);
		} while (0);

	}
#endif

	if (g_pDriverExtension->bDot11SupportMode)
	{
		// Register the WiFi filter to NDIS.
		Status = NdisFRegisterFilterDriver(DriverObject,
			(NDIS_HANDLE) g_pDriverExtension,
			&FChars_WiFi,
			&g_pDriverExtension->FilterDriverHandle_WiFi);
		if (Status != NDIS_STATUS_SUCCESS)
		{
			ERROR_DBG("NdisFRegisterFilterDriver(WiFi) failed: %#08x\n", Status);
			// We still run the driver even with the 2nd filter doesn't work.
		}
		INFO_DBG("FilterDriverHandle_WiFi = %p\n", g_pDriverExtension->FilterDriverHandle_WiFi);
	}

	TRACE_EXIT();
	return STATUS_SUCCESS;
}

//-------------------------------------------------------------------
_Use_decl_annotations_
VOID
NPF_registerLWF(
	PNDIS_FILTER_DRIVER_CHARACTERISTICS pFChars,
	UINT NdisVersion,
	BOOLEAN bWiFiOrNot
	)
{
	NDIS_STRING FriendlyName = RTL_CONSTANT_STRING(NPF_SERVICE_DESC_WIDECHAR); // display name
	NDIS_STRING UniqueName = RTL_CONSTANT_STRING(FILTER_UNIQUE_NAME); // unique name, quid name
	NDIS_STRING ServiceName = RTL_CONSTANT_STRING(NPF_DRIVER_NAME_SMALL_WIDECHAR); // this to match the service name in the INF
	NDIS_STRING FriendlyName_WiFi = RTL_CONSTANT_STRING(NPF_SERVICE_DESC_WIDECHAR_WIFI); // display name
	NDIS_STRING UniqueName_WiFi = RTL_CONSTANT_STRING(FILTER_UNIQUE_NAME_WIFI); // unique name, quid name
	NDIS_STRING ServiceName_WiFi = RTL_CONSTANT_STRING(NPF_DRIVER_NAME_SMALL_WIDECHAR_WIFI); // this to match the service name in the INF

	NdisZeroMemory(pFChars, sizeof(NDIS_FILTER_DRIVER_CHARACTERISTICS));
	pFChars->Header.Type = NDIS_OBJECT_TYPE_FILTER_DRIVER_CHARACTERISTICS;

#if NDIS_SUPPORT_NDIS61
	pFChars->DirectOidRequestHandler = NULL;
	pFChars->DirectOidRequestCompleteHandler = NULL;
	pFChars->CancelDirectOidRequestHandler = NULL;
#if NDIS_SUPPORT_NDIS680
	pFChars->SynchronousOidRequestHandler = NULL;
	pFChars->SynchronousOidRequestCompleteHandler = NULL;
	if (NdisVersion >= NDIS_RUNTIME_VERSION_680) {
		pFChars->Header.Revision = NDIS_FILTER_CHARACTERISTICS_REVISION_3;
		pFChars->Header.Size = NDIS_SIZEOF_FILTER_DRIVER_CHARACTERISTICS_REVISION_3;
	} else
#endif
	if (NT_VERIFY(NdisVersion >= NDIS_RUNTIME_VERSION_61)) {
		pFChars->Header.Revision = NDIS_FILTER_CHARACTERISTICS_REVISION_2;
		pFChars->Header.Size = NDIS_SIZEOF_FILTER_DRIVER_CHARACTERISTICS_REVISION_2;
	} else
#else
# error NDIS 6.20 or later required
#endif
	{
		pFChars->Header.Revision = NDIS_FILTER_CHARACTERISTICS_REVISION_1;
		pFChars->Header.Size = NDIS_SIZEOF_FILTER_DRIVER_CHARACTERISTICS_REVISION_1;
	}

	pFChars->MajorNdisVersion = (UCHAR)((NdisVersion >> 16) & 0xff);
	pFChars->MinorNdisVersion = (UCHAR)(NdisVersion & 0xff);
	// WINPCAP_MAJOR is 5 for Npcap
	pFChars->MajorDriverVersion = WINPCAP_MINOR;
	pFChars->MinorDriverVersion = WINPCAP_REV;
	pFChars->Flags = 0;

	// Use different names for the WiFi driver.
	if (bWiFiOrNot)
	{
		pFChars->FriendlyName = FriendlyName_WiFi;
		pFChars->UniqueName = UniqueName_WiFi;
		pFChars->ServiceName = ServiceName_WiFi;
	}
	else
	{
		pFChars->FriendlyName = FriendlyName;
		pFChars->UniqueName = UniqueName;
		pFChars->ServiceName = ServiceName;
	}

	pFChars->SetOptionsHandler = NPF_RegisterOptions;
	pFChars->AttachHandler = NPF_AttachAdapter;
	pFChars->DetachHandler = NPF_DetachAdapter;
	pFChars->RestartHandler = NPF_Restart;
	pFChars->PauseHandler = NPF_Pause;
	pFChars->SetFilterModuleOptionsHandler = NPF_SetModuleOptions;
	pFChars->OidRequestHandler = NPF_OidRequest;
	pFChars->OidRequestCompleteHandler = NPF_OidRequestComplete;
	pFChars->CancelOidRequestHandler = NPF_CancelOidRequest;

	pFChars->SendNetBufferListsHandler = NPF_SendEx;
	pFChars->ReturnNetBufferListsHandler = NPF_ReturnEx;
	pFChars->SendNetBufferListsCompleteHandler = NPF_SendCompleteEx;
	pFChars->ReceiveNetBufferListsHandler = NPF_TapEx;
	pFChars->DevicePnPEventNotifyHandler = NPF_DevicePnPEventNotify;
	pFChars->NetPnPEventHandler = NPF_NetPnPEvent;
	pFChars->StatusHandler = NPF_Status;
	pFChars->CancelSendNetBufferListsHandler = NPF_CancelSendNetBufferLists;


}

//-------------------------------------------------------------------

#define ABSOLUTE(wait)				(wait)
#define RELATIVE(wait)				(-(wait))
#define NANOSECONDS(nanos)			(((signed __int64)(nanos)) / 100L)
#define MICROSECONDS(micros)		(((signed __int64)(micros)) * NANOSECONDS(1000L))
#define MILLISECONDS(milli)			(((signed __int64)(milli)) * MICROSECONDS(1000L))
#define SECONDS(seconds)			(((signed __int64)(seconds)) * MILLISECONDS(1000L))


_Ret_maybenull_
static PKEY_VALUE_PARTIAL_INFORMATION
NPF_GetRegistryOption(
	_In_ PUNICODE_STRING RegistryPath,
	_In_ PUNICODE_STRING RegValueName
	)
{
	OBJECT_ATTRIBUTES objAttrs;
	NTSTATUS status;
	HANDLE keyHandle;
	PKEY_VALUE_PARTIAL_INFORMATION valueInfoP = NULL;
	SHORT retries = 2;

	TRACE_ENTER();
	INFO_DBG("\nRegistryPath: %ws, RegValueName: %ws\n", RegistryPath->Buffer, RegValueName->Buffer);

	InitializeObjectAttributes(&objAttrs, RegistryPath, OBJ_CASE_INSENSITIVE, NULL, NULL);
	status = ZwOpenKey(&keyHandle, KEY_READ, &objAttrs);
	if (!NT_SUCCESS(status))
	{
		WARNING_DBG("ZwOpenKey failed: %#08x\n", status);
	}
	else //OK
	{
		ULONG resultLength;
		do
		{
			status = ZwQueryValueKey(keyHandle,
				RegValueName,
				KeyValuePartialInformation,
				NULL,
				0,
				&resultLength);

			if (NT_SUCCESS(status) || status == STATUS_BUFFER_OVERFLOW || status == STATUS_BUFFER_TOO_SMALL)
			{

				valueInfoP = (PKEY_VALUE_PARTIAL_INFORMATION)NPF_AllocateZeroPaged(resultLength, NPF_SHORT_TERM_TAG);
				if (valueInfoP != NULL)
				{
					status = ZwQueryValueKey(keyHandle,
						RegValueName,
						KeyValuePartialInformation,
						valueInfoP,
						resultLength,
						&resultLength);
					if (!NT_SUCCESS(status))
					{
						WARNING_DBG("ZwQueryValueKey failed: %#08x\n", status);
					}
					else
					{
						break;
					}
					ExFreePool(valueInfoP);
					valueInfoP = NULL;
				}
				else
				{
					WARNING_DBG("Paged alloc of valueInfoP failed.\n");
				}
			}
			else
			{
				WARNING_DBG("ZwQueryValueKey(NULL buffer) failed: %#08x\n", status);
				break;
			}
		} while (--retries > 0 && (status == STATUS_BUFFER_TOO_SMALL || status == STATUS_BUFFER_OVERFLOW));

		ZwClose(keyHandle);
	}

	TRACE_EXIT();
	return valueInfoP;
}

//-------------------------------------------------------------------
_Use_decl_annotations_
ULONG
NPF_GetRegistryOption_Integer(
	PUNICODE_STRING RegistryPath,
	PUNICODE_STRING RegValueName
	)
{
	ULONG returnValue = 0;
	PKEY_VALUE_PARTIAL_INFORMATION valueInfoP = NULL;

	TRACE_ENTER();

	valueInfoP = NPF_GetRegistryOption(RegistryPath, RegValueName);

	if (valueInfoP != NULL)
	{
		if (valueInfoP->Type == REG_DWORD && valueInfoP->DataLength == 4)
		{
			returnValue = *((ULONG *) valueInfoP->Data);
			INFO_DBG("\"%ws\" Key = %08x\n", RegValueName->Buffer, *((ULONG *)valueInfoP->Data));
		}
		else
		{
			WARNING_DBG("\"%ws\" Key invalid type (%lu) or length (%lu)\n", RegValueName->Buffer, valueInfoP->Type, valueInfoP->DataLength);
		}
		ExFreePool(valueInfoP);
	}

	TRACE_EXIT();
	return returnValue;
}

//-------------------------------------------------------------------
_Use_decl_annotations_
VOID
NPF_GetRegistryOption_String(
	PUNICODE_STRING RegistryPath,
	PUNICODE_STRING RegValueName,
	PNDIS_STRING OutputString
	)
{
	PKEY_VALUE_PARTIAL_INFORMATION valueInfoP = NULL;

	TRACE_ENTER();

	valueInfoP = NPF_GetRegistryOption(RegistryPath, RegValueName);

	if (valueInfoP != NULL)
	{
		if (valueInfoP->Type == REG_SZ && valueInfoP->DataLength > 1)
		{
			INFO_DBG("\"%ws\" Key = %ws\n", RegValueName->Buffer, (PWSTR)valueInfoP->Data);

			OutputString->Length = (USHORT)(valueInfoP->DataLength - sizeof(UNICODE_NULL));
			OutputString->MaximumLength = (USHORT)(valueInfoP->DataLength);
			OutputString->Buffer = NPF_AllocateZeroNonpaged(OutputString->MaximumLength, NPF_UNICODE_BUFFER_TAG);

			if (OutputString->Buffer)
			{
				RtlCopyMemory(OutputString->Buffer, valueInfoP->Data, valueInfoP->DataLength);
			}
			else
			{
				WARNING_DBG("Nonpaged alloc of OutputString failed\n");
				OutputString->Length = OutputString->MaximumLength = 0;
			}
		}
		else
		{
			WARNING_DBG("\"%ws\" Key invalid type (%lu) or length (%lu)\n", RegValueName->Buffer, valueInfoP->Type, valueInfoP->DataLength);
		}
		ExFreePool(valueInfoP);
	}

	TRACE_EXIT();
}

//-------------------------------------------------------------------

_Use_decl_annotations_
VOID
NPF_Unload(
	IN PDRIVER_OBJECT      DriverObject
)
/*++

Routine Description:

Filter driver's unload routine.
	Deregister the driver from NDIS.

Arguments:

	DriverObject - pointer to the system's driver object structure
				   for this driver

Return Value:

	NONE

--*/
{
	PLIST_ENTRY CurrEntry = NULL;
	PDEVICE_OBJECT DeviceObject;
	PDEVICE_OBJECT OldDeviceObject;
	PNPCAP_FILTER_MODULE pFiltMod = NULL;
	PSINGLE_LIST_ENTRY Prev = NULL;
	PSINGLE_LIST_ENTRY Curr = NULL;
	NDIS_EVENT Event;
	LOCK_STATE_EX lockState, lockState2;

	TRACE_ENTER();

	NdisInitializeEvent(&Event);
	NdisResetEvent(&Event);

	// Undo all setup steps from DriverEntry in reverse order:
	// Deregister filter drivers with NDIS
	if (g_pDriverExtension->FilterDriverHandle_WiFi)
	{
		INFO_DBG("NdisFDeregisterFilterDriver: Deleting Filter Handle (WiFi) = %p\n", g_pDriverExtension->FilterDriverHandle_WiFi);
		NdisFDeregisterFilterDriver(g_pDriverExtension->FilterDriverHandle_WiFi);
		g_pDriverExtension->FilterDriverHandle_WiFi = NULL;
	}
	else
	{
		INFO_DBG("NdisFDeregisterFilterDriver: Filter Handle (WiFi) = NULL, no need to delete.\n");
	}

	if (g_pDriverExtension->FilterDriverHandle)
	{
		INFO_DBG("NdisFDeregisterFilterDriver: Deleting Filter Handle = %p\n", g_pDriverExtension->FilterDriverHandle);
		NdisFDeregisterFilterDriver(g_pDriverExtension->FilterDriverHandle);
		g_pDriverExtension->FilterDriverHandle = NULL;
	}
	else
	{
		INFO_DBG("NdisFDeregisterFilterDriver: Filter Handle = NULL, no need to delete.\n");
	}

#ifdef HAVE_WFP_LOOPBACK_SUPPORT
	// Free Loopback filter module
	if (g_pDriverExtension->pLoopbackFilter)
	{
		NPF_DetachAdapter(g_pDriverExtension->pLoopbackFilter);
		g_pDriverExtension->pLoopbackFilter = NULL;
	}
#endif

	// NdisFDeregisterFilterDriver ought to have called FilterDetach, but something is leaking. Let's force a wait:
	NdisAcquireSpinLock(&g_pDriverExtension->FilterArrayLock);
	while (g_pDriverExtension->arrFiltMod.Next != NULL) {
		// Wait for NDIS to release it
		NdisReleaseSpinLock(&g_pDriverExtension->FilterArrayLock);
		NdisWaitEvent(&Event, 1);
		NdisAcquireSpinLock(&g_pDriverExtension->FilterArrayLock);
	}
	NdisReleaseSpinLock(&g_pDriverExtension->FilterArrayLock);

#ifdef HAVE_WFP_LOOPBACK_SUPPORT
	// Release WFP resources.
	NPF_ReleaseWFP(TRUE);
	NPF_WFPCalloutUnregister();
#endif

	// Must still acquire this lock because NDIS could still be doing things with filter modules
	// Specifically, NPF_AttachAdapter acquires this for Read.
	NdisAcquireRWLockWrite(g_pDriverExtension->AllOpensLock, &lockState, 0);
	CurrEntry = RemoveHeadList(&g_pDriverExtension->AllOpens);
	while (CurrEntry != &g_pDriverExtension->AllOpens)
	{
		POPEN_INSTANCE pOpen = CONTAINING_RECORD(CurrEntry, OPEN_INSTANCE, AllOpensEntry);
		// Pretty sure we don't get here unless all this is already closed up, but better to be thorough.
		OPEN_STATE OldState = NPF_DemoteOpenStatus(pOpen, OpenClosed);
		// Just unlink it; other cleanup is handled already.
		if (NULL != (pFiltMod = pOpen->pFiltMod))
		{
			NdisAcquireRWLockWrite(pFiltMod->OpenInstancesLock, &lockState2, NDIS_RWL_AT_DISPATCH_LEVEL);
			Prev = &(pFiltMod->OpenInstances);
			Curr = Prev->Next;
			while (Curr != NULL)
			{
				if (Curr == &(pOpen->OpenInstancesEntry)) {
					Prev->Next = Curr->Next;
					Curr->Next = NULL;
					break;
				}
				Prev = Curr;
				Curr = Prev->Next;
			}
			NdisReleaseRWLock(pFiltMod->OpenInstancesLock, &lockState2);
		}
		NPF_ReleaseOpenInstanceResources(pOpen);
		ExFreePool(pOpen);
		CurrEntry = RemoveHeadList(&g_pDriverExtension->AllOpens);
	}
	NdisReleaseRWLock(g_pDriverExtension->AllOpensLock, &lockState);

	if (g_pDriverExtension->bCapturePoolInit)
		ExDeleteLookasideListEx(&g_pDriverExtension->CapturePool);
	if (g_pDriverExtension->bInternalRequestPoolInit)
		ExDeleteLookasideListEx(&g_pDriverExtension->InternalRequestPool);
	if (g_pDriverExtension->bNBCopiesPoolInit)
		ExDeleteLookasideListEx(&g_pDriverExtension->NBCopiesPool);
	if (g_pDriverExtension->bNBLCopyPoolInit)
		ExDeleteLookasideListEx(&g_pDriverExtension->NBLCopyPool);
	if (g_pDriverExtension->bSrcNBPoolInit)
		ExDeleteLookasideListEx(&g_pDriverExtension->SrcNBPool);
#ifdef HAVE_DOT11_SUPPORT
	if (g_pDriverExtension->bDot11HeaderPoolInit)
		ExDeleteLookasideListEx(&g_pDriverExtension->Dot11HeaderPool);
#endif

	NdisFreeRWLock(g_pDriverExtension->AllOpensLock);
	NdisFreeSpinLock(&g_pDriverExtension->FilterArrayLock);

	IoDeleteSymbolicLink(&deviceSymLink);

	DeviceObject = DriverObject->DeviceObject;

	// We only have 1 device, but this loop is future-proof.
	while (DeviceObject != NULL)
	{
		OldDeviceObject = DeviceObject;

		DeviceObject = DeviceObject->NextDevice;

		IoDeleteDevice(OldDeviceObject);
	}

	if (g_pDriverExtension->LoopbackAdapterName.Buffer != NULL)
	{
		ExFreePool(g_pDriverExtension->LoopbackAdapterName.Buffer);
		g_pDriverExtension->LoopbackAdapterName.Buffer = NULL;
	}
	if (g_pDriverExtension->SendToRxAdapterName.Buffer != NULL)
	{
		ExFreePool(g_pDriverExtension->SendToRxAdapterName.Buffer);
		g_pDriverExtension->SendToRxAdapterName.Buffer = NULL;
	}
	if (g_pDriverExtension->BlockRxAdapterName.Buffer != NULL)
	{
		ExFreePool(g_pDriverExtension->BlockRxAdapterName.Buffer);
		g_pDriverExtension->BlockRxAdapterName.Buffer = NULL;
	}

	ExFreePool(g_pDriverExtension);
	TRACE_EXIT();
}

#define SET_RESULT_SUCCESS(__a__) do{\
	Information = __a__;	\
	Status = STATUS_SUCCESS;	\
} while(FALSE)

#define SET_FAILURE_BUFFER(__len__) do {\
	Information = __len__; \
	Status = STATUS_BUFFER_TOO_SMALL; \
} while(FALSE)

#define SET_FAILURE(__STATUS_CODE) do{\
	Information = 0; \
	Status = __STATUS_CODE; \
} while(FALSE)

#define SET_FAILURE_CUSTOM(__b__) do{\
	Information = 0; \
	Status = __b__; \
	Status |= 1 << 29; \
} while(FALSE)

//-------------------------------------------------------------------

/* DO_DIRECT_IO */
_Use_decl_annotations_
NTSTATUS NPF_ValidateIoIrp(
		PIRP pIrp,
		POPEN_INSTANCE *ppOpen,
		PVOID* ppBuf,
		PULONG pBufLen)
{
	PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(pIrp);
	POPEN_INSTANCE pOpen = IrpSp->FileObject->FsContext;
	PVOID pBuf = NULL;
	ULONG BufLen = 0;
	NTSTATUS Status = STATUS_UNSUCCESSFUL;

	TRACE_ENTER();

	// Validation done for Direct IO only
	NT_ASSERT(!(pIrp->Flags & IRP_BUFFERED_IO));

	do /* Validate */
	{
		/* Context is an Open instance (also checks for NULL) */
		if (!NPF_IsOpenInstance(pOpen))
		{
			Status = STATUS_INVALID_HANDLE;
			break;
		}

		/* output buffer exists (If buffer is 0-length, I/O manager passes NULL here) */
		if (!pIrp->MdlAddress)
		{
			Status = STATUS_INVALID_PARAMETER;
			break;
		}

		// Has this IRP been canceled?
		if (pIrp->Cancel)
		{
			Status = STATUS_CANCELLED;
			break;
		}

		QueryMdl(pIrp->MdlAddress, &pBuf, &BufLen, NormalPagePriority | MdlMappingNoExecute);
		if (pBuf == NULL)
		{
			Status = STATUS_INSUFFICIENT_RESOURCES;
			break;
		}

		// The subsequent assertions only make sense for both Read and Write if
		// the Length field is in the same place in the Parameters union.
		// We'll verify that with a compile-time assertion here.
		C_ASSERT(FIELD_OFFSET(IO_STACK_LOCATION, Parameters.Read.Length) == FIELD_OFFSET(IO_STACK_LOCATION, Parameters.Write.Length));

		// Make sure the buffer length is correct.
		// This should be guaranteed by the I/O manager, but it'd be bad if we're wrong about that.
		NT_ASSERT(BufLen == IrpSp->Parameters.Read.Length);
		NT_ASSERT(BufLen == IrpSp->Parameters.Write.Length);

		// Success! Fill out the output parameters.
		Status = STATUS_SUCCESS;
	} while (FALSE);

	INFO_DBG("IRP %p status %#08x; pOpen = %p, pBuf = %p, BufLen = %lu\n", pIrp, Status, pOpen, pBuf, BufLen);
	if (Status != STATUS_SUCCESS)
	{
		// Ensure output param is NULL on failure
		pOpen = NULL;
		pBuf = NULL;
		BufLen = 0;
	}

	if (ppOpen)
		*ppOpen = pOpen;
	if (ppBuf)
		*ppBuf = pBuf;
	if (pBufLen)
		*pBufLen = BufLen;

	TRACE_EXIT();
	return Status;
}

_Must_inspect_result_
static NTSTATUS funcBIOCGSTATS(_In_ POPEN_INSTANCE pOpen,
	       	_Out_writes_bytes_(ulBufLen) PVOID pBuf,
	       	_In_ ULONG ulBufLen,
	       	_Out_ PULONG_PTR Info)
{
	static const ULONG uNeeded = sizeof(struct bpf_stat);
	struct bpf_stat *pStats = pBuf;

	*Info = 0;
	if (ulBufLen < uNeeded)
	{
		return STATUS_BUFFER_TOO_SMALL;
	}

	if (!NPF_StartUsingOpenInstance(pOpen, OpenDetached, NPF_IRQL_UNKNOWN))
	{
		return STATUS_CANCELLED;
	}

	pStats->bs_recv = pOpen->Received;
	pStats->bs_drop = pOpen->Dropped + pOpen->ResourceDropped;
	pStats->ps_ifdrop = 0; // Not yet supported
	pStats->bs_capt = pOpen->Accepted;

	NPF_StopUsingOpenInstance(pOpen, OpenDetached, NPF_IRQL_UNKNOWN);

	*Info = uNeeded;
	return STATUS_SUCCESS;
}

_Must_inspect_result_
static NTSTATUS funcBIOCSETF(_In_ POPEN_INSTANCE pOpen,
	       	_In_reads_bytes_(ulBufLen) LPCVOID pBuf,
	       	_In_ ULONG ulBufLen,
	       	_Out_ PULONG_PTR Info)
{
	LOCK_STATE_EX lockState;
	static const ULONG uNeeded = sizeof(struct bpf_insn);
	struct bpf_insn *NewBpfProgram = (struct bpf_insn *) pBuf;
	*Info = 0;

	if (ulBufLen < uNeeded)
	{
		return STATUS_BUFFER_TOO_SMALL;
	}

	if (!NPF_StartUsingOpenInstance(pOpen, OpenDetached, NPF_IRQL_UNKNOWN))
	{
		return STATUS_CANCELLED;
	}

	// Validate the new program (valid instructions, only forward jumps, etc.)
	ULONG insns = ulBufLen / sizeof(struct bpf_insn);
	if (insns > BPF_MAXINSNS || !bpf_validate(NewBpfProgram, insns))
	{
		WARNING_DBG("BPF filter invalid.\n");
		return STATUS_INVALID_DEVICE_REQUEST;
	}

	// Truncate buf to last entire instruction
	ulBufLen = insns * sizeof(struct bpf_insn);

	// Allocate the memory to contain the new filter program
	PNPCAP_BPF_PROGRAM TmpBPFProgram = NPF_AllocateZeroNonpaged(
			FIELD_OFFSET(NPCAP_BPF_PROGRAM, bpf_program) + (SIZE_T)ulBufLen, NPF_BPF_TAG);
	if (TmpBPFProgram == NULL)
	{
		WARNING_DBG("Failed to alloc TmpBPFProgram.\n");
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	//copy the program in the new buffer
	RtlCopyMemory(TmpBPFProgram->bpf_program, NewBpfProgram, ulBufLen);
	TmpBPFProgram->nInsns = insns;
	TmpBPFProgram->pOpen = pOpen;

	PVOID pOld = InterlockedExchangePointer(&pOpen->BpfProgram, TmpBPFProgram);
	NPF_UnregisterBpf(pOpen->pFiltMod, pOld);

	// Register the new BPF program if the Open is Running
	if (NPF_StartUsingOpenInstance(pOpen, OpenRunning, NPF_IRQL_UNKNOWN)) {
		NPF_RegisterBpf(pOpen->pFiltMod, TmpBPFProgram);
		NPF_StopUsingOpenInstance(pOpen, OpenRunning, NPF_IRQL_UNKNOWN);
	}
	else {
		// After InterlockedExchangePointer above, the memory at TmpBPFProgram
		// is pointed to by pOpen->BpfProgram, so there is no memory leak here.
		NPF_AnalysisAssumeAliased(TmpBPFProgram);
	}

	// Free the previous buffer if it was present
	if (pOld != NULL)
	{
		ExFreePool(pOld);
	}

	// release the machine lock and then reset the buffer
	NPF_ResetBufferContents(pOpen, TRUE);

	NPF_StopUsingOpenInstance(pOpen, OpenDetached, NPF_IRQL_UNKNOWN);

	return STATUS_SUCCESS;
}

_Must_inspect_result_
static NTSTATUS funcBIOCSULONG(_In_ POPEN_INSTANCE pOpen,
	    _In_reads_bytes_(ulBufLen) PULONG pBuf,
	    _In_ ULONG ulBufLen,
	    _Out_ PULONG_PTR Info,
		_In_ OPEN_STATE MaxState,
	    _Out_ PULONG pulOut)
{
	static const ULONG uNeeded = sizeof(ULONG);

	*Info = 0;
	if (ulBufLen < uNeeded)
	{
		return STATUS_BUFFER_TOO_SMALL;
	}

	if (!NPF_StartUsingOpenInstance(pOpen, MaxState, NPF_IRQL_UNKNOWN))
	{
		return (pOpen->OpenStatus == OpenDetached
				? STATUS_DEVICE_REMOVED
				: STATUS_CANCELLED);
	}

	*pulOut = *pBuf;

	NPF_StopUsingOpenInstance(pOpen, MaxState, NPF_IRQL_UNKNOWN);
	return STATUS_SUCCESS;
}

_Must_inspect_result_
static NTSTATUS funcBIOCSMODE(_In_ POPEN_INSTANCE pOpen,
	       _In_reads_bytes_(ulBufLen) PULONG pBuf,
	       _In_ ULONG ulBufLen,
	       _Out_ PULONG_PTR Info)
{
	static const ULONG uNeeded = sizeof(ULONG);
	ULONG mode = 0;

	*Info = 0;
	if (ulBufLen < uNeeded)
	{
		return STATUS_BUFFER_TOO_SMALL;
	}

	mode = *pBuf;

	// Compile-time assertion to ensure that MODE_CAPT and MODE_STAT are mutually exclusive.
	C_ASSERT(MODE_CAPT == 0 && MODE_STAT == 1);

	// Check for invalid modes
	if ((mode & (~SUPPORTED_MODES)) // No unsupported bits
		|| ((mode & MODE_SENDTORX) && (
			pOpen->bLoopback // SendToRx not supported for Loopback
			|| mode & MODE_SENDTORX_CLEAR)) // Mutually exclusive
	   )
	{
		return STATUS_INVALID_DEVICE_REQUEST;
	}

	if (!NPF_StartUsingOpenInstance(pOpen, OpenRunning, NPF_IRQL_UNKNOWN))
	{
		return (pOpen->OpenStatus <= OpenDetached
				? STATUS_DEVICE_REMOVED
				: STATUS_CANCELLED);
	}

	if (mode & MODE_STAT)
	{
		pOpen->bModeCapt = 0;
		NdisAcquireSpinLock(&pOpen->CountersLock);
		pOpen->Nbytes.QuadPart = 0;
		pOpen->Npackets.QuadPart = 0;
		NdisReleaseSpinLock(&pOpen->CountersLock);
	}
	else // MODE_CAPT
	{
		pOpen->bModeCapt = 1;
	}

	if (pOpen->pFiltMod->SendToRxPath) {
		pOpen->bSendToRx = (mode & MODE_SENDTORX_CLEAR) != 0;
	}
	else
	{
		pOpen->bSendToRx = (mode & MODE_SENDTORX) != 0;
	}

	pOpen->bNano = (mode & MODE_NANO) != 0;

	NPF_StopUsingOpenInstance(pOpen, OpenRunning, NPF_IRQL_UNKNOWN);
	return STATUS_SUCCESS;
}


_Must_inspect_result_
static NTSTATUS funcBIOCISETLOBBEH(_In_ POPEN_INSTANCE pOpen,
	       _In_reads_bytes_(ulBufLen) PULONG pBuf,
	       _In_ ULONG ulBufLen,
	       _Out_ PULONG_PTR Info)
{
	static const ULONG uNeeded = sizeof(ULONG);
	BOOLEAN SkipSent = FALSE;

	*Info = 0;
	if (ulBufLen < uNeeded)
	{
		return STATUS_BUFFER_TOO_SMALL;
	}

	switch (*pBuf)
	{
		case NPF_DISABLE_LOOPBACK:
			SkipSent = TRUE;
			break;
		case NPF_ENABLE_LOOPBACK:
			SkipSent = FALSE;
			break;
		default:
			return STATUS_INVALID_DEVICE_REQUEST;
			break;
	}

	if (!NPF_StartUsingOpenInstance(pOpen, OpenDetached, NPF_IRQL_UNKNOWN))
	{
		return STATUS_CANCELLED;
	}

	// Set the new value. If it's different than before,
	if (pOpen->SkipSentPackets != SkipSent)
	{
		pOpen->SkipSentPackets = SkipSent;
		// and they want to start skipping packets,
		if (SkipSent)
		{
			// clear out any packets from the buffer that would have been skipped
			// TODO: Change this to actually traverse the PacketQueue and
			// remove only injected packets. Will need to extend
			// NPF_CAP_DATA to hold this info.
			NPF_ResetBufferContents(pOpen, TRUE);
		}
	}

	NPF_StopUsingOpenInstance(pOpen, OpenDetached, NPF_IRQL_UNKNOWN);
	return STATUS_SUCCESS;
}

_Must_inspect_result_
static NTSTATUS funcBIOCSETEVENTHANDLE(_In_ POPEN_INSTANCE pOpen,
	       _In_reads_bytes_(ulBufLen) PVOID pBuf,
	       _In_ ULONG ulBufLen,
	       _In_ BOOLEAN is32bit,
	       _In_ KPROCESSOR_MODE kMode,
	       _Out_ PULONG_PTR Info)
{
	HANDLE hUserEvent = INVALID_HANDLE_VALUE;
	PKEVENT pKernelEvent = NULL;
	NTSTATUS Status = STATUS_UNSUCCESSFUL;
	ULONG uNeeded = is32bit ? sizeof(VOID * POINTER_32) : sizeof(VOID * POINTER_64);

	*Info = 0;
	// We don't currently support overwriting the existing event.
	if (pOpen->ReadEvent != NULL)
	{
		return STATUS_OBJECT_NAME_EXISTS;
	}

	if (ulBufLen < uNeeded)
	{
		return STATUS_BUFFER_TOO_SMALL;
	}
	else if (ulBufLen > uNeeded)
	{
		return STATUS_INVALID_PARAMETER;
	}

#ifndef _WIN64
	// WIN32
	NT_ASSERT(is32bit);
#else
	// WIN64
	if (!is32bit)
	{
	       	// 64-bit process
		// HANDLE is 64-bit address
		hUserEvent = *(PHANDLE) pBuf;
	}
	else
#endif
	{
		// 32-bit process
		// Convert to native handle if necessary
		hUserEvent = Handle32ToHandle(*(VOID * POINTER_32 *) pBuf);
	}

	Status = ObReferenceObjectByHandle(hUserEvent,
			EVENT_MODIFY_STATE,
			*ExEventObjectType,
			kMode,
			(PVOID *) &pKernelEvent,
			NULL);

	if (!NT_SUCCESS(Status))
	{
		return Status;
	}

	if (!NPF_StartUsingOpenInstance(pOpen, OpenDetached, NPF_IRQL_UNKNOWN))
	{
		ObDereferenceObject(pKernelEvent);
		return STATUS_CANCELLED;
	}

	// If the event is NULL, replace it. This returns the previous value, so if it's not NULL,
	// we don't replace it and need to bail.
	if (InterlockedCompareExchangePointer(&pOpen->ReadEvent, pKernelEvent, NULL) != NULL)
	{
		// dereference the new pointer
		ObDereferenceObject(pKernelEvent);
		NPF_StopUsingOpenInstance(pOpen, OpenDetached, NPF_IRQL_UNKNOWN);
		return STATUS_OBJECT_NAME_EXISTS;
	}

	KeResetEvent(pOpen->ReadEvent);

	NPF_StopUsingOpenInstance(pOpen, OpenDetached, NPF_IRQL_UNKNOWN);
	return STATUS_SUCCESS;
}

_Must_inspect_result_
static NTSTATUS funcBIOCSETBUFFERSIZE(_In_ POPEN_INSTANCE pOpen,
	       _In_reads_bytes_(ulBufLen) PULONG pBuf,
	       _In_ ULONG ulBufLen,
	       _Out_ PULONG_PTR Info)
{
	static const ULONG uNeeded = sizeof(ULONG);
	LOCK_STATE_EX lockState;
	ULONG dim = 0;

	*Info = 0;
	if (ulBufLen < uNeeded)
	{
		return STATUS_BUFFER_TOO_SMALL;
	}

	dim = *(PULONG) pBuf;

	// verify that the provided size value is sensible
	if (dim > NPF_MAX_BUFFER_SIZE)
	{
		return STATUS_INSUFFICIENT_RESOURCES;
	} 

	if (!NPF_StartUsingOpenInstance(pOpen, OpenRunning, NPF_IRQL_UNKNOWN))
	{
		return (pOpen->OpenStatus <= OpenDetached
				? STATUS_DEVICE_REMOVED
				: STATUS_CANCELLED);
	}

	// Acquire buffer lock
	NdisAcquireRWLockWrite(pOpen->BufferLock, &lockState, 0);

	do
	{
		// If there's no change, we're done!
		if ((LONG)dim == pOpen->Size) {
			break;
		}

		// TODO: Could we avoid clearing the buffer but instead allow a
		// negative Free count or maybe just clear out the amount that
		// exceeds Size?
		pOpen->Size = dim;
		NPF_ResetBufferContents(pOpen, FALSE);
	} while (FALSE);

	NdisReleaseRWLock(pOpen->BufferLock, &lockState);

	NPF_StopUsingOpenInstance(pOpen, OpenRunning, NPF_IRQL_UNKNOWN);
	return STATUS_SUCCESS;
}

_Must_inspect_result_
static NTSTATUS funcBIOC_OID(_In_ POPEN_INSTANCE pOpen,
	       _Inout_updates_bytes_(ulBufLenIn) PPACKET_OID_DATA OidData,
	       _In_ ULONG ulBufLenIn,
	       _In_ ULONG ulBufLenOut,
	       _In_ BOOLEAN bSetOid,
	       _Out_ PULONG_PTR Info)
{
	PVOID OidBuffer = NULL;
	LOCK_STATE_EX lockState;
	ULONG ulTmp = 0;
	NTSTATUS Status = STATUS_UNSUCCESSFUL;

	*Info = 0;
	// NDIS OID requests use the same buffer for in/out, so the caller must supply the same size buffers, too.
	if (ulBufLenIn != ulBufLenOut ||
			ulBufLenIn < sizeof(PACKET_OID_DATA) || // check before dereferencing OidData
			ulBufLenIn < (FIELD_OFFSET(PACKET_OID_DATA, Data) + OidData->Length) ||
			OidData->Length == 0
		)
	{
		return STATUS_BUFFER_TOO_SMALL;
	}

	INFO_DBG("%s Request: Oid=%08lx, Length=%08lx\n", bSetOid ? "BIOCSETOID" : "BIOCQUERYOID", OidData->Oid, OidData->Length);

	if (!NPF_StartUsingOpenInstance(pOpen, OpenAttached, NPF_IRQL_UNKNOWN))
	{
		return (pOpen->OpenStatus == OpenDetached
				? STATUS_DEVICE_REMOVED
				: STATUS_CANCELLED);
	}

		// We don't really support OID requests on our fake loopback
		// adapter, but we can pretend.
	if (bSetOid && (pOpen->pFiltMod->Loopback || pOpen->pFiltMod->Fragile))
	{
		switch (OidData->Oid) {
			// Backwards compatibility: libpcap can't handle adapters that do not support setting packet filter.
			case OID_GEN_CURRENT_PACKET_FILTER:
				Status = STATUS_SUCCESS;
				break;
			default:
				INFO_DBG("pFiltMod(%p) BIOCSETOID not supported. Loopback: %u, Fragile: %u\n",
						pOpen->pFiltMod, pOpen->pFiltMod->Loopback, pOpen->pFiltMod->Fragile);
				Status = STATUS_INVALID_DEVICE_REQUEST;
				break;
		}
		goto OID_REQUEST_DONE;
	}
#ifdef HAVE_WFP_LOOPBACK_SUPPORT
	if (!bSetOid && pOpen->pFiltMod->Loopback)
	{
		PNDIS_LINK_STATE pLinkState = NULL;
		switch (OidData->Oid)
		{
			case OID_GEN_MAXIMUM_TOTAL_SIZE:
			case OID_GEN_TRANSMIT_BUFFER_SPACE:
			case OID_GEN_RECEIVE_BUFFER_SPACE:
				if (OidData->Length < sizeof(UINT))
				{
					Status = STATUS_BUFFER_TOO_SMALL;
					break;
				}
				*Info = FIELD_OFFSET(PACKET_OID_DATA, Data) + sizeof(UINT);
				*((PUINT)OidData->Data) = pOpen->pFiltMod->MaxFrameSize;
				OidData->Length = sizeof(UINT);
				INFO_DBG("Loopback: get MTU = %u\n", *((PUINT)OidData->Data));
				Status = STATUS_SUCCESS;
				break;

			case OID_GEN_TRANSMIT_BLOCK_SIZE:
			case OID_GEN_RECEIVE_BLOCK_SIZE:
				if (OidData->Length < sizeof(UINT))
				{
					Status = STATUS_BUFFER_TOO_SMALL;
					break;
				}
				*Info = FIELD_OFFSET(PACKET_OID_DATA, Data) + sizeof(UINT);
				*((PUINT)OidData->Data) = 1;
				OidData->Length = sizeof(UINT);
				INFO_DBG("Loopback: get OID_GEN_*_BLOCK_SIZE = %u\n", *((PUINT)OidData->Data));
				Status = STATUS_SUCCESS;
				break;
			case OID_GEN_MEDIA_IN_USE:
			case OID_GEN_MEDIA_SUPPORTED:
				if (OidData->Length < sizeof(UINT))
				{
					Status = STATUS_BUFFER_TOO_SMALL;
					break;
				}
				*Info = FIELD_OFFSET(PACKET_OID_DATA, Data) + sizeof(UINT);
				*((PUINT)OidData->Data) = g_pDriverExtension->bDltNullMode ? NdisMediumNull : NdisMedium802_3;
				OidData->Length = sizeof(UINT);
				INFO_DBG("Loopback: get OID_GEN_MEDIA_IN_USE = %u\n", *((PUINT)OidData->Data));
				Status = STATUS_SUCCESS;
				break;
			case OID_GEN_LINK_STATE:
				if (OidData->Length < sizeof(NDIS_LINK_STATE))
				{
					Status = STATUS_BUFFER_TOO_SMALL;
					break;
				}
				*Info = FIELD_OFFSET(PACKET_OID_DATA, Data) + sizeof(NDIS_LINK_STATE);
				pLinkState = (PNDIS_LINK_STATE) OidData->Data;
				pLinkState->MediaConnectState = MediaConnectStateConnected;
				pLinkState->MediaDuplexState = MediaDuplexStateFull;
				pLinkState->XmitLinkSpeed = NDIS_LINK_SPEED_UNKNOWN;
				pLinkState->RcvLinkSpeed = NDIS_LINK_SPEED_UNKNOWN;
				pLinkState->PauseFunctions = NdisPauseFunctionsUnsupported;
				OidData->Length = sizeof(NDIS_LINK_STATE);
				Status = STATUS_SUCCESS;
				break;
			default:
				WARNING_DBG("Unsupported BIOCQUERYOID for Loopback\n");
				Status = STATUS_INVALID_DEVICE_REQUEST;
				break;
		}
		goto OID_REQUEST_DONE;
	}
#endif
	NT_ASSERT(!pOpen->pFiltMod->Loopback);
	NT_ASSERT(!(pOpen->pFiltMod->Fragile && bSetOid));

#ifdef HAVE_DOT11_SUPPORT
	if (pOpen->pFiltMod->Dot11 && (OidData->Oid == OID_GEN_MEDIA_IN_USE || OidData->Oid == OID_GEN_MEDIA_SUPPORTED))
	{
		if (bSetOid)
		{
			INFO_DBG("Dot11: AdapterName=%ws, OID_GEN_MEDIA_IN_USE & BIOCSETOID, fail it\n", pOpen->pFiltMod->AdapterName.Buffer);
			Status = STATUS_NOT_SUPPORTED;
		}
		else
		{
			INFO_DBG("Dot11: AdapterName=%ws, OID_GEN_MEDIA_IN_USE & BIOCGETOID, OidData->Data = %d\n", pOpen->pFiltMod->AdapterName.Buffer, NdisMediumRadio80211);
			if (OidData->Length < sizeof(UINT))
			{
				Status = STATUS_BUFFER_TOO_SMALL;
			}
			else
			{
				*Info = FIELD_OFFSET(PACKET_OID_DATA, Data) + sizeof(UINT);
				OidData->Length = sizeof(UINT);
				*((PUINT)OidData->Data) = (UINT)NdisMediumRadio80211;
				Status = STATUS_SUCCESS;
			}
		}

		goto OID_REQUEST_DONE;
	}
#endif

	// OID_GEN_CURRENT_PACKET_FILTER requires additional checks
	if (bSetOid && OidData->Oid == OID_GEN_CURRENT_PACKET_FILTER)
	{
		NT_ASSERT(pOpen->pFiltMod != NULL);

		if (OidData->Length != sizeof(ULONG))
		{
			Status = STATUS_BUFFER_TOO_SMALL;
			goto OID_REQUEST_DONE;
		}
		*Info = FIELD_OFFSET(PACKET_OID_DATA, Data) + sizeof(ULONG);

#ifdef HAVE_DOT11_SUPPORT
		// Disable setting Packet Filter for wireless adapters, because this will cause limited connectivity.
		if (pOpen->bDot11)
		{
			INFO_DBG("pFiltMod(%p) (Dot11) does not support OID_GEN_CURRENT_PACKET_FILTER\n", pOpen->pFiltMod);
			Status = STATUS_SUCCESS;
			goto OID_REQUEST_DONE;
		}
#endif

		// Stash the old packet filter...
		ulTmp = pOpen->MyPacketFilter;
		// Store the requested packet filter for *this* Open instance
		pOpen->MyPacketFilter = *(ULONG*)OidData->Data;

		/* We don't want NDIS_PACKET_TYPE_ALL_LOCAL, since that may cause NDIS to loop
		 * packets back that shouldn't be. WinPcap had to do this as a protocol driver,
		 * but Npcap sees outgoing packets from all protocols already.  We'll clear this
		 * bit, but instead turn on the other aspects that it covers: packets that would
		 * be indicated by the NIC anyway.
		 */
		if (pOpen->MyPacketFilter & NDIS_PACKET_TYPE_ALL_LOCAL) {
			pOpen->MyPacketFilter ^= NDIS_PACKET_TYPE_ALL_LOCAL;
			pOpen->MyPacketFilter |= NDIS_PACKET_TYPE_DIRECTED | NDIS_PACKET_TYPE_MULTICAST | NDIS_PACKET_TYPE_BROADCAST;
		}

		// If the new packet filter is the same as the old one
		if (pOpen->MyPacketFilter == ulTmp)
		{
			// Nothing left to do!
			Status = STATUS_SUCCESS;
			goto OID_REQUEST_DONE;
		}

		// Start clean
		ulTmp = 0;
		// Set the filter module's packet filter to the union of all instances' filters
		NdisAcquireRWLockRead(pOpen->pFiltMod->OpenInstancesLock, &lockState, 0);
		for (PSINGLE_LIST_ENTRY Curr = pOpen->pFiltMod->OpenInstances.Next; Curr != NULL; Curr = Curr->Next)
		{
			ulTmp |= CONTAINING_RECORD(Curr, OPEN_INSTANCE, OpenInstancesEntry)->MyPacketFilter;
		}
		NdisReleaseRWLock(pOpen->pFiltMod->OpenInstancesLock, &lockState);

		// Now ulTmp is the new effective filter
		// NPF_SetPacketFilter will take care of any short-circuits and all the request stuff
		Status = NPF_SetPacketFilter(pOpen->pFiltMod, ulTmp);
		goto OID_REQUEST_MAP_STATUS;
	}
	else if (bSetOid && OidData->Oid == OID_GEN_CURRENT_LOOKAHEAD)
	{
		// Stash the old lookahead
		ulTmp = pOpen->MyLookaheadSize;
		pOpen->MyLookaheadSize = *(PULONG) OidData->Data;
		// If it didn't change, or
		if (pOpen->MyLookaheadSize == ulTmp ||
			// if it got bigger but would not increase the current value, or
			(pOpen->MyLookaheadSize > ulTmp && pOpen->MyLookaheadSize <= pOpen->pFiltMod->MyLookaheadSize) ||
			// if it got smaller, but the old value was smaller than the current max,
			(pOpen->MyLookaheadSize < ulTmp && ulTmp < pOpen->pFiltMod->MyLookaheadSize))
		{
			// Nothing left to do!
			Status = STATUS_SUCCESS;
			goto OID_REQUEST_DONE;
		}
		// Remaining possibilities:
		// 1. It got smaller and will decrease the current value
		if (pOpen->MyLookaheadSize < ulTmp) {
			// Figure out the max of all open instances' lookaheads
			NdisAcquireRWLockRead(pOpen->pFiltMod->OpenInstancesLock, &lockState, 0);
			// Start clean
			ulTmp = 0;
			for (PSINGLE_LIST_ENTRY Curr = pOpen->pFiltMod->OpenInstances.Next; Curr != NULL; Curr = Curr->Next)
			{
				ulTmp = max(pOpen->pFiltMod->MyLookaheadSize,
						CONTAINING_RECORD(Curr, OPEN_INSTANCE, OpenInstancesEntry)->MyLookaheadSize);
			}
			NdisReleaseRWLock(pOpen->pFiltMod->OpenInstancesLock, &lockState);
		}
		// 2. It got bigger and will increase the current value.
		else {
			ulTmp = pOpen->MyLookaheadSize;
		}
		// Now ulTmp is the new max value. Let NPF_SetLookaheadSize handle request if needed
		Status = NPF_SetLookaheadSize(pOpen->pFiltMod, ulTmp);
		goto OID_REQUEST_DONE;
	}

	//  The buffer is valid

	/* NDIS_OID_REQUEST.InformationBuffer must be non-paged */
	// TODO: Test whether this copy needs to happen. Buffered I/O ought to
	// mean AssociatedIrp.SystemBuffer is non-paged already and is not
	// freed until we complete the IRP.
	OidBuffer = NPF_AllocateZeroNonpaged(OidData->Length, NPF_USER_OID_TAG);
	if (OidBuffer == NULL)
	{
		INFO_DBG("Failed to allocate OidBuffer\n");
		Status = STATUS_INSUFFICIENT_RESOURCES;
		goto OID_REQUEST_DONE;
	}
	RtlCopyMemory(OidBuffer, OidData->Data, OidData->Length);

	Status = NPF_DoInternalRequest(pOpen->pFiltMod,
			bSetOid ? NdisRequestSetInformation : NdisRequestQueryInformation,
			OidData->Oid,
			OidBuffer,
			OidData->Length,
			0, 0,
			&ulTmp);


	//
	// Complete the request
	//
	if (bSetOid)
	{
		OidData->Length = ulTmp;
		INFO_DBG("BIOCSETOID completed, BytesRead = %u\n", OidData->Length);
		*Info = FIELD_OFFSET(PACKET_OID_DATA, Data);
	}
	else
	{
		// Don't trust that the length fits in the output buffer
		if (FIELD_OFFSET(PACKET_OID_DATA, Data) + ulTmp > ulBufLenOut)
		{
			ulTmp = ulBufLenOut - FIELD_OFFSET(PACKET_OID_DATA, Data);
			Status = NDIS_STATUS_INVALID_DATA;
		}
		RtlCopyMemory(OidData->Data, OidBuffer, ulTmp);
		OidData->Length = ulTmp;

		INFO_DBG("BIOCQUERYOID completed, BytesWritten = %u\n", OidData->Length);
		*Info = (ULONG_PTR) FIELD_OFFSET(PACKET_OID_DATA, Data) + ulTmp;
	}


OID_REQUEST_MAP_STATUS:

	if (Status == NDIS_STATUS_SUCCESS)
	{
		// Note: NDIS_STATUS_SUCCESS is defined to be the
		// same value as STATUS_SUCCESS in ndis.h.
		Status = STATUS_SUCCESS;
	}
	else
	{
		// Return the error code of NdisFOidRequest() to the application.
		INFO_DBG("Original NdisFOidRequest() Status = %#x\n", Status);
		//
		// Set the customer code flag (C-bit) to mark this status as customer-defined;
		// that avoids NTSTATUS-to-Win32 error code translation.
		// This allows consumers like libpcap to distinguish passthrough
		// errors (C-bit set) from Npcap-originated errors (Win32 errors).
		//
		// Examples:
		// * Issue #303: WWAN adapters return STATUS_NOT_SUPPORTED for
		//   OID_GEN_CURRENT_PACKET_FILTER. libpcap now checks for 0xE00000BB,
		//   which is (STATUS_NOT_SUPPORTED | C-bit).
		//
		// * Issue #628: Code change resulted in this mask not being applied,
		//   so STATUS_NOT_SUPPORTED was translated to ERROR_GEN_FAILURE,
		//   resulting in "failed to set hardware filter to promiscuous mode"
		//   errors in Wireshark. Restored and added this comment.
		//
		Status = (1 << 29) | Status;
		INFO_DBG("Custom NdisFOidRequest() Status = %#x\n", Status);
	}

OID_REQUEST_DONE:

	if (OidBuffer != NULL)
	{
		ExFreePoolWithTag(OidBuffer, NPF_USER_OID_TAG);
	}

	NPF_StopUsingOpenInstance(pOpen, OpenAttached, NPF_IRQL_UNKNOWN);
	return Status;
}

_Must_inspect_result_
static NTSTATUS funcBIOCSTIMESTAMPMODE(_In_ POPEN_INSTANCE pOpen,
	       _In_reads_bytes_(ulBufLen) PULONG pBuf,
	       _In_ ULONG ulBufLen,
	       _Out_ PULONG_PTR Info)
{
	static const ULONG uNeeded = sizeof(ULONG);
	ULONG mode = 0, oldmode = 0;

	*Info = 0;
	if (ulBufLen < uNeeded)
	{
		return STATUS_BUFFER_TOO_SMALL;
	}

	mode = *(PULONG) pBuf;

	// verify that the provided mode is supported
	if (!NPF_TimestampModeSupported(mode))
	{
		return STATUS_INVALID_DEVICE_REQUEST;
	} 

	if (!NPF_StartUsingOpenInstance(pOpen, OpenDetached, NPF_IRQL_UNKNOWN))
	{
		return STATUS_CANCELLED;
	}

	oldmode = InterlockedExchange(&pOpen->TimestampMode, mode);
	if (oldmode != mode)
	{
		if (pOpen->OpenStatus <= OpenRunning)
		{
			if (oldmode == TIMESTAMPMODE_QUERYSYSTEMTIME_PRECISE) {
				NpfInterlockedDecrement(&pOpen->pFiltMod->nTimestampQST_Precise);
			}
			else if (mode == TIMESTAMPMODE_QUERYSYSTEMTIME_PRECISE) {
				NpfInterlockedIncrement(&pOpen->pFiltMod->nTimestampQST_Precise);
			}
		}
		/* Reset buffer, since contents have differing timestamps */
		NPF_ResetBufferContents(pOpen, TRUE);
	}

	NPF_StopUsingOpenInstance(pOpen, OpenDetached, NPF_IRQL_UNKNOWN);
	return STATUS_SUCCESS;
}

_Must_inspect_result_
static NTSTATUS funcBIOCGTIMESTAMPMODES(_In_ POPEN_INSTANCE pOpen,
	       _Out_writes_bytes_(ulBufLen) PVOID pBuf,
	       _In_ ULONG ulBufLen,
	       _Out_ PULONG_PTR Info)
{
	// Need to at least deliver the number of modes
	ULONG uNeeded = sizeof(ULONG);
	static ULONG SupportedModes[] = {
		0, // count of modes, 0 means not initialized yet
		TIMESTAMPMODE_SINGLE_SYNCHRONIZATION,
		TIMESTAMPMODE_QUERYSYSTEMTIME,
#if (NTDDI_VERSION >= NTDDI_WIN8)
		// This is last and is not reported if not different than QST
		TIMESTAMPMODE_QUERYSYSTEMTIME_PRECISE
#endif
	};

	// Initialize the count if not already done.
	if (SupportedModes[0] == 0)
	{
		// Count is length minus 1 for the count element.
		SupportedModes[0] = sizeof(SupportedModes) / sizeof(ULONG) - 1;
	}

	*Info = 0;
	if (ulBufLen < uNeeded)
	{
		return STATUS_BUFFER_TOO_SMALL;
	}

	uNeeded = (SupportedModes[0] + 1) * sizeof(ULONG);
	if (ulBufLen < uNeeded)
	{
		*Info = ulBufLen;
		RtlCopyMemory(pBuf, SupportedModes, ulBufLen);
		return STATUS_BUFFER_OVERFLOW;
	}
	else
	{
		*Info = uNeeded;
		RtlCopyMemory(pBuf, SupportedModes, uNeeded);
		return STATUS_SUCCESS;
	}
}

_Must_inspect_result_
static NTSTATUS funcBIOCGETPIDS(_In_ POPEN_INSTANCE pOpen,
	       _Out_writes_bytes_(ulBufLen) PULONG pBuf,
	       _In_ ULONG ulBufLen,
	       _Out_ PULONG_PTR Info)
{
	LOCK_STATE_EX lockState;
	ULONG cnt = 0;
	ULONG ulWritten = 0;
	// Need to at least deliver the number of PIDS
	static const ULONG uNeeded = sizeof(ULONG);

	*Info = 0;
	if (ulBufLen < uNeeded)
	{
		return STATUS_BUFFER_TOO_SMALL;
	}

	if (!NPF_StartUsingOpenInstance(pOpen, OpenDetached, NPF_IRQL_UNKNOWN))
	{
		return STATUS_CANCELLED;
	}

	ulWritten = sizeof(ULONG);
	NdisAcquireRWLockRead(g_pDriverExtension->AllOpensLock, &lockState, 0);

	for (PLIST_ENTRY CurrEntry = g_pDriverExtension->AllOpens.Flink;
			CurrEntry != &g_pDriverExtension->AllOpens;
			CurrEntry = CurrEntry->Flink)
	{
		POPEN_INSTANCE pOpenTmp = CONTAINING_RECORD(CurrEntry, OPEN_INSTANCE, AllOpensEntry);
		cnt++;
		if (ulWritten <= ulBufLen - sizeof(ULONG))
		{
			pBuf[cnt] = pOpenTmp->UserPID;
			ulWritten += sizeof(ULONG);
		}
	}
	NdisReleaseRWLock(g_pDriverExtension->AllOpensLock, &lockState);

	NPF_StopUsingOpenInstance(pOpen, OpenDetached, NPF_IRQL_UNKNOWN);
	pBuf[0] = cnt;
	*Info = ulWritten;
	if (ulWritten / (ULONG) sizeof(ULONG) < (1 + cnt))
	{
		return STATUS_BUFFER_OVERFLOW;
	}
	return STATUS_SUCCESS;
}

_Must_inspect_result_
static NTSTATUS funcBIOCGETINFO(_In_ POPEN_INSTANCE pOpen,
	       _Inout_updates_bytes_(ulBufLenIn) PPACKET_OID_DATA OidData,
	       _In_ ULONG ulBufLenIn,
	       _In_ ULONG ulBufLenOut,
	       _Out_ PULONG_PTR Info)
{
	NTSTATUS Status = STATUS_UNSUCCESSFUL;
	PSINGLE_LIST_ENTRY Curr = NULL;
	PNPCAP_FILTER_MODULE pFiltMod = pOpen->pFiltMod;
	ULONG ulTmp = 0;
	ULONG ulInput = 0;

	*Info = 0;
	// NDIS OID requests use the same buffer for in/out, so the caller must supply the same size buffers, too.
	if (ulBufLenIn != ulBufLenOut ||
			ulBufLenIn < sizeof(PACKET_OID_DATA) || // check before dereferencing OidData
			ulBufLenIn < (FIELD_OFFSET(PACKET_OID_DATA, Data) + OidData->Length) ||
			OidData->Length < sizeof(ULONG)
		)
	{
		return STATUS_BUFFER_TOO_SMALL;
	}

	// Now Length is at least sizeof(ULONG)
	INFO_DBG("BIOCGETINFO: ID=%08lx, Length=%08lx\n", OidData->Oid, OidData->Length);

	ulInput = *((PULONG)OidData->Data);
	USHORT *puStat = NULL;
	C_ASSERT(sizeof(ULONG) >= 2 * sizeof(USHORT));
	switch (OidData->Oid) {
		case NPF_GETINFO_VERSION:
			*((PULONG)OidData->Data) = 
				((WINPCAP_MINOR & 0xff) << 24) |
				((WINPCAP_REV & 0xff) << 16) |
				((WINPCAP_BUILD & 0xffff));
			OidData->Length = sizeof(ULONG);
			*Info = FIELD_OFFSET(PACKET_OID_DATA, Data) + sizeof(ULONG);
			Status = STATUS_SUCCESS;
			break;

		case NPF_GETINFO_CONFIG:
			ulTmp = (0
#ifdef NPCAP_OEM
					| NPF_CONFIG_OEM
#endif
#ifndef NPCAP_READ_ONLY
					| NPF_CONFIG_INJECT
#endif
				);
			if (g_pDriverExtension->bAdminOnlyMode)
				ulTmp |= NPF_CONFIG_ADMINONLY;
			if (g_pDriverExtension->bDltNullMode)
				ulTmp |= NPF_CONFIG_DLTNULL;
#ifdef HAVE_DOT11_SUPPORT
			if (g_pDriverExtension->bDot11SupportMode)
				ulTmp |= NPF_CONFIG_WIFI;
#endif
#ifdef HAVE_WFP_LOOPBACK_SUPPORT
			if (g_pDriverExtension->bLoopbackSupportMode)
				ulTmp |= NPF_CONFIG_LOOPBACK;
#endif
			if (g_pDriverExtension->bTestMode)
				ulTmp |= NPF_CONFIG_TESTMODE;

			*((PULONG)OidData->Data) = ulTmp;
			OidData->Length = sizeof(ULONG);
			*Info = FIELD_OFFSET(PACKET_OID_DATA, Data) + sizeof(ULONG);
			Status = STATUS_SUCCESS;
			break;

		case NPF_GETINFO_BPFEXT:
			*((PULONG)OidData->Data) = NPCAP_AD_MAX;
			OidData->Length = sizeof(ULONG);
			*Info = FIELD_OFFSET(PACKET_OID_DATA, Data) + sizeof(ULONG);
			Status = STATUS_SUCCESS;
			break;

		case NPF_GETINFO_MODES:
			*((PULONG)OidData->Data) = SUPPORTED_MODES;
			OidData->Length = sizeof(ULONG);
			*Info = FIELD_OFFSET(PACKET_OID_DATA, Data) + sizeof(ULONG);
			Status = STATUS_SUCCESS;
			break;

		case NPF_GETINFO_STATS:
			if (pOpen->OpenStatus > OpenAttached || !pFiltMod) {
				Status = STATUS_CANCELLED;
				break;
			}
			Status = STATUS_SUCCESS;
			switch (ulInput) {
				case NPF_STATSINFO_RECVTIMES:
					puStat = pFiltMod->TimeInRecv;
					break;
				case NPF_STATSINFO_SENDTIMES:
					puStat = pFiltMod->TimeInSend;
					break;
				case NPF_STATSINFO_DPCTIMES:
					puStat = pFiltMod->TimeAtDPC;
					break;
				default:
					Status = STATUS_INVALID_DEVICE_REQUEST;
					break;
			}
			if (puStat != NULL) {
				((PUSHORT)OidData->Data)[0] = puStat[0];
				((PUSHORT)OidData->Data)[1] = puStat[1];
				OidData->Length = 2 * sizeof(USHORT);
				*Info = FIELD_OFFSET(PACKET_OID_DATA, Data) + 2 * sizeof(USHORT);
			}
			break;
		case NPF_GETINFO_MODDBG:
			if (pOpen->OpenStatus > OpenAttached || !pFiltMod) {
				Status = STATUS_CANCELLED;
				break;
			}
			Status = STATUS_SUCCESS;
			switch (ulInput) {
				case NPF_MODDBG_PF_SUPPORTED:
					*((PULONG)OidData->Data) = pFiltMod->SupportedPacketFilters;
					break;
				case NPF_MODDBG_PF_MY:
					*((PULONG)OidData->Data) = pFiltMod->MyPacketFilter;
					break;
				case NPF_MODDBG_PF_HIGHER:
					*((PULONG)OidData->Data) = pFiltMod->HigherPacketFilter;
					break;
				case NPF_MODDBG_LA_MY:
					*((PULONG)OidData->Data) = pFiltMod->MyLookaheadSize;
					break;
				case NPF_MODDBG_LA_HIGHER:
					*((PULONG)OidData->Data) = pFiltMod->HigherLookaheadSize;
					break;
				case NPF_MODDBG_BITS:
					*((PULONG)OidData->Data) =  (
						(pFiltMod->Loopback ? 0x1 : 0) |
						(pFiltMod->RawIP ? 0x2 : 0) |
						(pFiltMod->EtherHeader ? 0x4 : 0) |
						(pFiltMod->SplitMdls ? 0x8 : 0) |
						(pFiltMod->SendToRxPath ? 0x10 : 0) |
						(pFiltMod->BlockRxPath ? 0x20 : 0) |
						(pFiltMod->Dot11 ? 0x40 : 0) |
						(pFiltMod->PacketFilterGetOK ? 0x80 : 0) |
						(pFiltMod->HigherPacketFilterSet ? 0x100 : 0) |
						(pFiltMod->Fragile ? 0x200 : 0) );
					break;
				case NPF_MODDBG_MAXFRAME:
					*((PULONG)OidData->Data) = pFiltMod->MaxFrameSize;
					break;
				case NPF_MODDBG_NUMOPENS:
					*((PULONG)OidData->Data) = pFiltMod->BpfCount;
					break;
				default:
					Status = STATUS_INVALID_DEVICE_REQUEST;
					break;
			}
			if (Status == STATUS_SUCCESS) {
				OidData->Length = sizeof(ULONG);
				*Info = FIELD_OFFSET(PACKET_OID_DATA, Data) + sizeof(ULONG);
			}
			break;
		default:
			Status = STATUS_INVALID_DEVICE_REQUEST;
			break;
	}
	return Status;
}

_Use_decl_annotations_
NTSTATUS
NPF_IoControl(
	IN PDEVICE_OBJECT DeviceObject,
	IN PIRP Irp
	)
{
	ULONG_PTR Information = 0;
	PVOID pBuf = Irp->AssociatedIrp.SystemBuffer;
	PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
	POPEN_INSTANCE Open = IrpSp->FileObject->FsContext;
	NTSTATUS Status = STATUS_SUCCESS;
	ULONG InputBufferLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
	ULONG OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
	ULONG FunctionCode = IrpSp->Parameters.DeviceIoControl.IoControlCode;

	// general flag for a couple of ioctls
	BOOLEAN bFlag = FALSE;

	UNREFERENCED_PARAMETER(DeviceObject);
	TRACE_ENTER();

	if (!NPF_IsOpenInstance(Open))
	{
		Status = STATUS_INVALID_HANDLE;
		goto NPF_IoControl_End;
	}

	// Has this IRP been canceled?
	if (Irp->Cancel)
	{
		Status = STATUS_CANCELLED;
		goto NPF_IoControl_End;
	}

	/* All our ioctls use METHOD_BUFFERED currently. Verify that here so
	 * that handler functions don't have to. If this changes in the future,
	 * we'll have to split this check by ioctl code.
	 */
	if (METHOD_FROM_CTL_CODE(FunctionCode) != METHOD_BUFFERED ||
			// Make sure at least one buffer is valid and not 0-length.
			pBuf == NULL || InputBufferLength + OutputBufferLength == 0)
	{
		Status = STATUS_INVALID_PARAMETER;
		goto NPF_IoControl_End;
	}

	INFO_DBG(
		"Function code is %08lx Input size=%08lx Output size %08lx",
		FunctionCode,
		InputBufferLength,
		OutputBufferLength);

	switch (FunctionCode)
	{
		// OPEN_STATE must be OpenRunning:
#ifndef NPCAP_READ_ONLY
		case BIOCSENDPACKETSSYNC:
			bFlag = TRUE;
		case BIOCSENDPACKETSNOSYNC:
			Status = NPF_BufferedWrite(Open, pBuf, InputBufferLength, bFlag, &Information);
			break;
		case BIOCSWRITEREP:
			Status = funcBIOCSULONG(Open, pBuf, InputBufferLength, &Information, OpenRunning, &Open->Nwrites);
			break;
#endif // NPCAP_READ_ONLY

		// BIOCSETBUFFERSIZE and BIOCSMODE do not technically require
		// an attached adapter, but NPF_StartUsingOpenInstance(x, OpenRunning)
		// does some initialization that is needed to start actually
		// processing packets
		case BIOCSETBUFFERSIZE:
			Status = funcBIOCSETBUFFERSIZE(Open, pBuf, InputBufferLength, &Information);
			break;
		case BIOCSMODE:
			Status = funcBIOCSMODE(Open, pBuf, InputBufferLength, &Information);
			break;

		// OPEN_STATE must be OpenAttached
		case BIOCSETOID:
			bFlag = TRUE;
		case BIOCQUERYOID:
			Status = funcBIOC_OID(Open, pBuf, InputBufferLength, OutputBufferLength, bFlag, &Information);
			break;

		// OPEN_STATE can be OpenDetached
		case BIOCGSTATS:
			Status = funcBIOCGSTATS(Open, pBuf, OutputBufferLength, &Information);
			break;

		case BIOCSETF:
			Status = funcBIOCSETF(Open, pBuf, InputBufferLength, &Information);
			break;
		case BIOCSMINTOCOPY:
			Status = funcBIOCSULONG(Open, pBuf, InputBufferLength, &Information, OpenDetached, &Open->MinToCopy);
			break;
		case BIOCISETLOBBEH:
			Status = funcBIOCISETLOBBEH(Open, pBuf, InputBufferLength, &Information);
			break;
		case BIOCSETEVENTHANDLE:
#ifdef _WIN64
			bFlag = IoIs32bitProcess(Irp);
#else
			bFlag = TRUE;
#endif
			Status = funcBIOCSETEVENTHANDLE(Open, pBuf, InputBufferLength, bFlag, Irp->RequestorMode, &Information);
			break;
		case BIOCSTIMESTAMPMODE:
			Status = funcBIOCSTIMESTAMPMODE(Open, pBuf, InputBufferLength, &Information);
			break;
		case BIOCGETPIDS:
			Status = funcBIOCGETPIDS(Open, pBuf, OutputBufferLength, &Information);
			break;

		// OPEN_STATE doesn't matter for now, since it's global for the whole driver.
		case BIOCGTIMESTAMPMODES:
			Status = funcBIOCGTIMESTAMPMODES(Open, pBuf, OutputBufferLength, &Information);
			break;
		case BIOCGETINFO:
			Status = funcBIOCGETINFO(Open, pBuf, InputBufferLength, OutputBufferLength, &Information);
			break;

#if DBG
		/* Deprecated codes */
		case BIOCGEVNAME:
		case BIOCSETDUMPFILENAME:
		case BIOCSETDUMPLIMITS:
		case BIOCISDUMPENDED:
		case BIOCSRTIMEOUT:
#endif
		default:
			WARNING_DBG("Unknown IOCTL code: %#08x\n", FunctionCode);
			Status = STATUS_INVALID_DEVICE_REQUEST;
			break;
	}

NPF_IoControl_End:
	//
	// complete the IRP
	//
	Irp->IoStatus.Information = Information;
	Irp->IoStatus.Status = Status;
	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	INFO_DBG("Status = %#08x\n", Status);
	TRACE_EXIT();
	return Status;
}

```

`packetWin7/npf/npf/Packet.h`:

```h
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
/*
 * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)
 * Copyright (c) 2005 - 2010 CACE Technologies, Davis (California)
 * Copyright (c) 2010 - 2013 Riverbed Technology, San Francisco (California), Yang Luo (China)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Politecnico di Torino, CACE Technologies
 * nor the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/** @addtogroup NPF
 *  @{
 */

/** @defgroup NPF_include NPF structures and definitions
 *  @{
 */
#include "stdafx.h"

#ifndef __PACKET_INCLUDE______
#define __PACKET_INCLUDE______

#include <wdm.h>
#include "win_bpf.h"
#include "../../../Common/npcap-defs.h"

/* If DISPATCH_LEVEL can be determined, use that in the FILTER_*_LOCK macros
 * Otherwise, use NPF_IRQL_UNKNOWN so we can find and update them as we add more tracking
 */
#define NPF_IRQL_UNKNOWN FALSE
#define FILTER_ACQUIRE_LOCK(_pLock, DispatchLevel) if (DispatchLevel) { \
	NdisDprAcquireSpinLock(_pLock); \
} else { \
	NdisAcquireSpinLock(_pLock); \
}
#define FILTER_RELEASE_LOCK(_pLock, DispatchLevel) if (DispatchLevel) { \
	NdisDprReleaseSpinLock(_pLock); \
} else { \
	NdisReleaseSpinLock(_pLock); \
}

typedef struct _NDIS_OID_REQUEST *FILTER_REQUEST_CONTEXT,**PFILTER_REQUEST_CONTEXT;

// Minimum supported NDIS version: 6.20 (Windows 7)
#ifndef NDIS_SUPPORT_NDIS620
#error NDIS 6.20 required
#endif

#define Packet_ALIGNMENT sizeof(int) ///< Alignment macro. Defines the alignment size.
#define Packet_WORDALIGN(x) (((x)+(Packet_ALIGNMENT-1))&~(Packet_ALIGNMENT-1))	///< Alignment macro. Rounds up to the next
///< even multiple of Packet_ALIGNMENT.


// Working modes
// WinPcap legacy modes:
#define MODE_CAPT 0x00  /// Capture working mode
#define MODE_STAT 0x01  /// Statistical working mode
#define MODE_MON  0x02  /// Kernel monitoring mode
#define MODE_DUMP 0x10  /// Kernel dump working mode
// Npcap extension modes:
#define MODE_SENDTORX       0x0100 /// SendToRx mode
#define MODE_SENDTORX_CLEAR 0x0200 /// disable SendToRx mode
#define MODE_NANO           0x0400 /// Nanosecond precision timestamps
#define SUPPORTED_MODES (MODE_CAPT | MODE_STAT \
			| MODE_SENDTORX | MODE_SENDTORX_CLEAR \
			| MODE_NANO)


#define IMMEDIATE 1			///< Immediate timeout. Forces a read call to return immediately.

// Loopback behaviour definitions
#define NPF_DISABLE_LOOPBACK				1	///< Tells the driver to drop the packets sent by itself. This is usefult when building applications like bridges.
#define NPF_ENABLE_LOOPBACK					2	///< Tells the driver to capture the packets sent by itself.

// Admin only mode definition
//#define NPF_ADMIN_ONLY_MODE			///< Tells the driver to restrict its access only to Administrators. This is used to support "Admin-only Mode" for Npcap.

// Loopback interface MTU definition
#define NPF_LOOPBACK_INTERFACR_MTU			65536	///< The MTU of the "Npcap Loopback Adapter", this value adopts Linux's "lo" MTU and can't be modified.

// Custom link type, originally defined in Packet32.h, NDIS doesn't provide an equivalent for some of values
#define NdisMediumNull						-1		///< The link type of the "Npcap Loopback Adapter", this value will be recognized by packet.dll code.
#define NdisMediumCHDLC						-2		///< Custom linktype: NDIS doesn't provide an equivalent
#define NdisMediumPPPSerial					-3		///< Custom linktype: NDIS doesn't provide an equivalent
#define NdisMediumBare80211					-4		///< The link type of the Native WiFi adapters, Npcap versions with Native WiFi feature enabled will support this value.
#define NdisMediumRadio80211				-5		///< Custom linktype: NDIS doesn't provide an equivalent
#define NdisMediumPpi						-6		///< Custom linktype: NDIS doesn't provide an equivalent

#define CCH2BYTES(_cch) ((_cch) * sizeof(WCHAR))
#define BYTES2CCH(_bytes) ((_bytes) / sizeof(WCHAR))
/* Length of a string literal minus the terminating null */
#define CONST_WCHAR_BYTES(_A) (sizeof(_A) - sizeof(WCHAR))
#define CONST_WCHAR_CCH(_A) BYTES2CCH(CONST_WCHAR_BYTES(_A))
// The GUID for the filters
#define				FILTER_UNIQUE_NAME			L"{7daf2ac8-e9f6-4765-a842-f1f5d2501341}"
#define				FILTER_UNIQUE_NAME_WIFI		L"{7daf2ac8-e9f6-4765-a842-f1f5d2501351}"

#define DEVICE_PATH_PREFIX L"\\Device\\"
#define DEVICE_PATH_BYTES CONST_WCHAR_BYTES(DEVICE_PATH_PREFIX)
#define DEVICE_PATH_CCH CONST_WCHAR_CCH(DEVICE_PATH_PREFIX)

// format: {ADAPTER_GUID}-{FILTER_GUID}
// guid * 2 + 1 ("-") - 3 ("XX}")
#define SECOND_LAST_HEX_INDEX_OF_FILTER_UNIQUE_NAME (2*CONST_WCHAR_CCH(FILTER_UNIQUE_NAME) + 1 - 3)

// Maximum pool size allowed in bytes (defence against bad BIOCSETBUFFERSIZE calls)
#define NPF_MAX_BUFFER_SIZE 0x40000000L

#ifdef HAVE_DOT11_SUPPORT
#include "ieee80211_radiotap.h"
/* These are the fields we support, hence the max size
 * of radiotap header buffer */
#define SIZEOF_RADIOTAP_BUFFER sizeof(IEEE80211_RADIOTAP_HEADER) \
			+ 8 /* TSFT */ \
			+ 1 /* Flags */ \
			+ 1 /* Rate */ \
			+ 2 + 2 /* Channel */ \
			+ 1 /* Antenna signal */ \
			+ 3 /* MCS */ \
			+ 12 /* VHT */
#define NPCAP_DOT11_RAW_PACKET_FILTER (NDIS_PACKET_TYPE_802_11_RAW_DATA | NDIS_PACKET_TYPE_802_11_RAW_MGMT)
#endif

typedef struct _NPCAP_FILTER_MODULE NPCAP_FILTER_MODULE, * PNPCAP_FILTER_MODULE;

/*!
  \brief Stores an OID request.

  This structure is used by the driver to perform OID query or set operations on the underlying NIC driver.
  The OID operations be performed usually only by network drivers, but NPF exports this mechanism to user-level
  applications through an IOCTL interface. The driver uses this structure to wrap a NDIS_REQUEST structure.
  This allows to handle correctly the callback structure of NdisRequest(), handling multiple requests and
  maintaining information about the IRPs to complete.
*/
typedef struct _INTERNAL_REQUEST
{
	PNPCAP_FILTER_MODULE pFiltMod;
	NDIS_EVENT			InternalRequestCompletedEvent;
	NDIS_OID_REQUEST	Request;			///< The structure with the actual request, that will be passed to NdisRequest().
	NDIS_STATUS			RequestStatus;
} INTERNAL_REQUEST, *PINTERNAL_REQUEST;

/*!
  \brief Port device extension.

  Structure containing some data relative to every device NPF exposes
*/
typedef struct _NPCAP_DRIVER_EXTENSION
{
	PDEVICE_OBJECT pNpcapDeviceObject;
	NDIS_HANDLE FilterDriverHandle;
	NDIS_HANDLE FilterDriverHandle_WiFi;
	UINT NdisVersion;

	SINGLE_LIST_ENTRY arrFiltMod; //Adapter filter module list head
	NDIS_SPIN_LOCK FilterArrayLock; //The lock for adapter filter module list.
	LIST_ENTRY AllOpens;
	PNDIS_RW_LOCK_EX AllOpensLock;

	LOOKASIDE_LIST_EX NBLCopyPool; // Pool of NPF_NBL_COPY, NPF_NB_COPIES, NPF_SRC_NB objects
	LOOKASIDE_LIST_EX NBCopiesPool; // Pool of NPF_NB_COPIES objects
	LOOKASIDE_LIST_EX SrcNBPool; // Pool of NPF_SRC_NB objects
	LOOKASIDE_LIST_EX InternalRequestPool; // Pool of INTERNAL_REQUEST structures that wrap every single OID request.
	LOOKASIDE_LIST_EX CapturePool; // Pool of NPF_CAP_DATA objects
#ifdef HAVE_DOT11_SUPPORT
	LOOKASIDE_LIST_EX Dot11HeaderPool; // Pool of Radiotap header buffers
#endif
	BOOLEAN bNBLCopyPoolInit:1;
	BOOLEAN bNBCopiesPoolInit:1;
	BOOLEAN bSrcNBPoolInit:1;
	BOOLEAN bInternalRequestPoolInit:1;
	BOOLEAN bCapturePoolInit:1;
	BOOLEAN bDot11HeaderPoolInit:1;
	// WFP context
	BOOLEAN bWFPInit:1;
	KMUTEX WFPInitMutex;
	PNPCAP_FILTER_MODULE pLoopbackFilter;
#define NPF_INJECT_OTHER -1
#define NPF_INJECT_IPV6 0
#define NPF_INJECT_IPV4 1
	HANDLE hInject[2];
	UINT32 uCalloutInboundV4;
	UINT32 uCalloutInboundV6;

	// Registry config variables
	BOOLEAN bLoopbackSupportMode:1;
	BOOLEAN bAdminOnlyMode:1;
	BOOLEAN bDltNullMode:1;
	BOOLEAN bDot11SupportMode:1;
	BOOLEAN bTestMode:1;

	ULONG TimestampMode;

#ifdef HAVE_WFP_LOOPBACK_SUPPORT
	NDIS_STRING LoopbackAdapterName;
#endif

#ifdef HAVE_RX_SUPPORT
	NDIS_STRING SendToRxAdapterName;
	NDIS_STRING BlockRxAdapterName;
#endif

} NPCAP_DRIVER_EXTENSION, *PNPCAP_DRIVER_EXTENSION;

typedef enum _FILTER_STATE
{
    FilterDetached,
    FilterAttaching,
    FilterPausing,
    FilterPaused,
    FilterRunning,
    FilterRestarting
} FILTER_STATE;

typedef enum _OPEN_STATE
{
	OpenRunning, // All features available
	OpenInitializing, // A thread is initializing features
	OpenAttached, // Some features need to be initialized.
	OpenDetached, // No NDIS adapter associated, most features unavailable
	OpenClosed, // No features available, about to shut down. New IRPs rejected.
	OpenInvalidStateMax // all valid states are less than this
} OPEN_STATE;

typedef enum _FILTER_OPS_STATE
{
	OpsDisabled,
	OpsDisabling,
	OpsEnabling,
	OpsFailed,
	OpsEnabled
} FILTER_OPS_STATE;

#define OPEN_SIGNATURE 'NPFO'

/* Filter module (per-adapter) */
typedef struct _NPCAP_FILTER_MODULE
{
	SINGLE_LIST_ENTRY FilterModulesEntry;
	// List of open instances needs to be write-locked only when inserting/removing.
	// Ordinary traversal can use faster and concurrent read-lock.
	SINGLE_LIST_ENTRY OpenInstances; //GroupHead
	PNDIS_RW_LOCK_EX OpenInstancesLock; // Also protects MyPacketFilter and MyLookaheadSize
	LIST_ENTRY BpfPrograms;
	PNDIS_RW_LOCK_EX BpfProgramsLock;
	LONG BpfCount; // Number of BPF filters, equivalent to number of OpenRunning
	LONG nTimestampQST_Precise;

	NDIS_STRING				AdapterName;
	NET_LUID AdapterID;

	/* Config booleans as a bitfield */
	BOOLEAN Loopback:1;
	BOOLEAN RawIP:1; // does this miniport require us to sniff the IP version of each packet?
	BOOLEAN EtherHeader:1; // Does this adapter use Ethernet headers?
	BOOLEAN SplitMdls:1; // Do we need to split the L2 header into a separate MDL?
	BOOLEAN SendToRxPath:1;
	BOOLEAN BlockRxPath:1;
	BOOLEAN Dot11:1;
	BOOLEAN PacketFilterGetOK:1; // Can we issue OID_GEN_CURRENT_PACKET_FILTER queries?
	BOOLEAN HigherPacketFilterSet:1; // Have we correctly set HigherPacketFilter yet?
	BOOLEAN Fragile:1; // Avoid OID set operations on these adapters

	ULONG SupportedPacketFilters;
	ULONG					MyPacketFilter;
	ULONG					HigherPacketFilter;
	ULONG MyLookaheadSize;
	ULONG HigherLookaheadSize;
#ifdef HAVE_DOT11_SUPPORT
	PDOT11_DATA_RATE_MAPPING_TABLE DataRateMappingTable;
#endif

	NDIS_SPIN_LOCK			OIDLock;		///< Lock for protection of state and outstanding sends and recvs
	PNDIS_OID_REQUEST		PendingOidRequest;

	NDIS_HANDLE				AdapterHandle;	///< NDIS idetifier of the adapter used by this instance.
	NDIS_HANDLE				PacketPool;		///< Pool of NDIS_PACKET structures used to transfer the packets from and to the NIC driver.
	UINT					MaxFrameSize;	///< Maximum frame size that the underlying MAC acceptes. Used to perform a check on the
											///< size of the frames sent with NPF_Write() or NPF_BufferedWrite().
	ULONG					AdapterHandleUsageCounter;
	NDIS_SPIN_LOCK			AdapterHandleLock;
	FILTER_STATE					AdapterBindingStatus;	///< Specifies if NPF is still bound to the adapter used by this instance, it's unbinding or it's not bound.
	FILTER_OPS_STATE OpsState; // Whether all operations are enabled
	// Exponential Moving Average processing time per call
	// (last 20 packets, alpha=0.1; last 20K packets, alpha=0.0001)
	USHORT TimeInSend[2]; // send path
	USHORT TimeInRecv[2]; // receive path
	USHORT TimeAtDPC[2]; // both paths
} 
NPCAP_FILTER_MODULE, *PNPCAP_FILTER_MODULE;

typedef struct _OPEN_INSTANCE* POPEN_INSTANCE;
typedef struct _NPCAP_BPF_PROGRAM
{
	LIST_ENTRY BpfProgramsEntry;
	POPEN_INSTANCE pOpen;
	ULONG nInsns;
	struct bpf_insn bpf_program[1];
}
NPCAP_BPF_PROGRAM, *PNPCAP_BPF_PROGRAM;

VOID
NPF_RegisterBpf(
	_In_ PNPCAP_FILTER_MODULE pFiltMod,
	_In_ __drv_aliasesMem PNPCAP_BPF_PROGRAM pBpfProgram);
VOID
NPF_UnregisterBpf(
	_In_ PNPCAP_FILTER_MODULE pFiltMod,
	_In_ PNPCAP_BPF_PROGRAM pBpfProgram);

/* Open instance
 * Represents an open device handle by a process
 */
typedef struct _OPEN_INSTANCE
{
	ULONG OpenSignature;
    SINGLE_LIST_ENTRY OpenInstancesEntry; //GroupNext
    LIST_ENTRY AllOpensEntry;
    PNPCAP_FILTER_MODULE pFiltMod;
	NET_LUID AdapterID;

	ULONG					MyPacketFilter;
	ULONG					MyLookaheadSize;
	PKEVENT					ReadEvent;		///< Pointer to the event on which the read calls on this instance must wait.
	PNPCAP_BPF_PROGRAM BpfProgram; ///< Contains a pointer to the filtering pseudo-code associated with current handle.
	UINT					MinToCopy;		///< Minimum amount of data in the circular buffer that unlocks a read. Set with the
											///< BIOCSMINTOCOPY IOCTL.
	LARGE_INTEGER			Nbytes;			///< Amount of bytes accepted by the filter when this instance is in statistical mode.
	LARGE_INTEGER			Npackets;		///< Number of packets accepted by the filter when this instance is in statistical mode.
	NDIS_SPIN_LOCK			CountersLock;	///< SpinLock that protects the statistical mode counters.
	UINT					Nwrites;		///< Number of times a single write must be physically repeated. See \ref NPF for an
											///< explanation

	/* Config booleans as a bitfield */
	// working modes, see PacketSetMode():
	BOOLEAN bModeCapt:1; // MODE_CAPT (1) vs MODE_STAT (0)
	// BOOLEAN bModeMon:1; // MODE_MON not supported
	BOOLEAN bSendToRx:1;
	BOOLEAN bNano:1;
	// Loopback Behavior:
	BOOLEAN SkipSentPackets:1; ///< True if this instance should not capture back the packets that it transmits.
	// Info used to match a FilterModule when reattaching:
	BOOLEAN bDot11:1; // pFiltMod->Dot11
	BOOLEAN bLoopback:1; // pFiltMod->Loopback

	/* Buffer */
	PNDIS_RW_LOCK_EX BufferLock; // Lock for modifying the buffer size/configuration
	LIST_ENTRY PacketQueue; // Head of packet buffer queue
	KSPIN_LOCK PacketQueueLock; // Lock controlling buffer queue
	LONG Free; // Bytes of buffer free for writing
	LONG Size; ///< Size of the kernel buffer

	/* Stats */
	ULONG Accepted; /// A packet is accepted if it passes the filter and
			//  fits in the buffer. Accepted packets are the
			//  ones that reach the application.
	ULONG Received; /// number of packet received by the network adapter
                        //  since the beginning of the capture session.
	ULONG Dropped; /// A packet is dropped if there is no more space to
		       //  store it in the circular buffer.
	ULONG ResourceDropped; /// A packet is resource-dropped if there is
		       //  insufficient memory to allocate a copy.

	ULONG PendingIrps[OpenClosed]; //Counters for pending IRPs at each state. No IRPs are accepted at OpenClosed and greater.

	OPEN_STATE OpenStatus;
	OPEN_STATE ReattachStatus;
	NDIS_SPIN_LOCK			OpenInUseLock;
	ULONG TimestampMode;
	struct timeval start; // Time synchronization of QPC with last boot
			      // This is now always in nanosecond precision
	ULONG UserPID; // A PID associated with this handle
}
OPEN_INSTANCE, *POPEN_INSTANCE;

/* Packet metadata that is the same for every NET_BUFFER in the NET_BUFFER_LIST
 * and that we need until all related captures are retrieved. */
typedef struct _NPF_NBL_COPY
{
	SINGLE_LIST_ENTRY NBCopiesHead;
	SINGLE_LIST_ENTRY NBLCopyEntry;
	LARGE_INTEGER PerfCount;
	LARGE_INTEGER SystemTime;
	NDIS_NET_BUFFER_LIST_8021Q_INFO qInfo;
	BOOLEAN bQinfoPresent;
#ifdef HAVE_DOT11_SUPPORT
	PUCHAR Dot11RadiotapHeader;
#endif
	LONG refcount;
} NPF_NBL_COPY, *PNPF_NBL_COPY;


/* Packet data and metadata that is unique to each packet, but common to every
 * capture of that packet, and which we need to keep until all related captures
 * are retrieved. */
typedef struct _NPF_NB_COPIES
{
	PNPF_NBL_COPY pNBLCopy;
	ULONG ulSize; // Size of data in Buffer
	ULONG ulPacketSize; // Size of the original packet
	LONG refcount;
	PUCHAR Buffer; // packet data
} NPF_NB_COPIES, *PNPF_NB_COPIES;

/* Packet metadata that we only need prior to putting the NPF_CAP_DATA in the
 * queue. Only lives as long as the call to NPF_DoTap. */
typedef struct _NPF_SRC_NB
{
	SINGLE_LIST_ENTRY CopiesEntry;
	PNPF_NB_COPIES pNBCopy;
	PNET_BUFFER pNetBuffer; // source NET_BUFFER
	ULONG ulDesired; // How much data we want from the packet
	BOOLEAN bVlanHeaderInPacket:1; // Is there a 802.1q VLAN header in the packet data?
	BOOLEAN bVlanHeaderAdded:1; // Was a VLAN header added to the pNBCopy, increasing size by 4 bytes?
} NPF_SRC_NB, *PNPF_SRC_NB;

// so we can use the same lookaside list for all these things
typedef union _NPF_NB_STORAGE
{
	NPF_NBL_COPY NBLCopy;
	NPF_SRC_NB SrcNB;
	NPF_NB_COPIES NBCopy;
} NPF_NB_STORAGE, *PNPF_NB_STORAGE;

/* Structure of a captured packet data description */
typedef struct _NPF_CAP_DATA
{
	union {
		// When in the packet queue:
		LIST_ENTRY PacketQueueEntry;
		// When DoTap is waiting to dispatch this to an instance:
		struct {
			struct _NPF_CAP_DATA *Next;
			POPEN_INSTANCE pOpen;
			PNPF_SRC_NB pSrcNB;
		};
	};
	PNPF_NB_COPIES pNBCopy;
	ULONG ulCaplen;
}
NPF_CAP_DATA, *PNPF_CAP_DATA;

#define NPF_CAP_SIZE(_CapLen) (sizeof(struct bpf_hdr) + _CapLen)

#ifdef HAVE_DOT11_SUPPORT
#define NPF_CAP_RADIOTAP(_P) ((_P)->pNBCopy->pNBLCopy->Dot11RadiotapHeader)
#define NPF_CAP_RADIOTAP_SIZE(_R) ((_R) != NULL ? ((PIEEE80211_RADIOTAP_HEADER)(_R))->it_len : 0)
#define NPF_CAP_OBJ_SIZE(_P) NPF_CAP_SIZE( \
		(_P)->ulCaplen \
		+ NPF_CAP_RADIOTAP_SIZE(NPF_CAP_RADIOTAP(_P)))
#else
#define NPF_CAP_OBJ_SIZE(_P) NPF_CAP_SIZE((_P)->ulCaplen)
#endif

_When_(AcquireLock == FALSE, _Requires_lock_held_(Open->BufferLock))
VOID
NPF_ResetBufferContents(
	_Inout_ POPEN_INSTANCE Open,
	_In_ BOOLEAN AcquireLock
);

VOID NPF_ReturnNBCopies(
	_In_ PNPF_NB_COPIES pNBCopy
	);

VOID NPF_ReturnNBLCopy(
	_In_ PNPF_NBL_COPY pNBLCopy
	);

VOID NPF_ReturnCapData(
	_In_ PNPF_CAP_DATA pCapData
	);

/*!
  \brief Function to free the Net Buffer Lists initiated by ourself.
*/
VOID
_When_(AtDispatchLevel != FALSE, _IRQL_requires_(DISPATCH_LEVEL))
NPF_FreePackets(
	_In_ PNPCAP_FILTER_MODULE pFiltMod,
	_In_ __drv_freesMem(mem) PNET_BUFFER_LIST    NetBufferLists,
	_In_ BOOLEAN AtDispatchLevel
	);

// This function exists only to suppress C6014 regarding memory leak.
// Be very suspicious of any use of it!
// MUST be accompanied by a well-researched justification.
inline VOID
#pragma warning(suppress: 28194) // We aren't really aliasing it here, but we know that it's aliased for some other reason.
NPF_AnalysisAssumeAliased(_In_ __drv_aliasesMem PVOID p)
{
	UNREFERENCED_PARAMETER(p);
	return;
}

// This function exists only to suppress C6014 regarding memory leak.
// Be very suspicious of any use of it!
// MUST be accompanied by a well-researched justification.
inline VOID
#pragma warning(suppress: 6014)
NPF_AnalysisAssumeFreed(_In_ __drv_freesMem(mem) PVOID p)
{
	UNREFERENCED_PARAMETER(p);
	return;
}

// This wrapper is just so we can declare some constraints with SAL
_Success_(*ppBuf != NULL)
inline VOID QueryMdl(
	_In_ PMDL p,
	_Outptr_result_bytebuffer_all_(*pLen) PVOID* ppBuf,
	_Out_ PUINT pLen,
	_In_ ULONG Priority)
{
	NdisQueryMdl(p, ppBuf, pLen, Priority);
}


typedef __declspec(align(4)) struct _NPF_BUFFERED_WRITE_STATE
{
	LONG PacketsPending;
	NDIS_EVENT WriteCompleteEvent;
}
NPF_BUFFERED_WRITE_STATE, *PNPF_BUFFERED_WRITE_STATE;

/*!
\brief Context information for originated sent packets
*/
typedef __declspec(align(MEMORY_ALLOCATION_ALIGNMENT)) struct _PACKET_RESERVED
{
	PIRP pIrp;
	BOOLEAN FreeBufAfterWrite:1; // True if the memory buffer associated with the packet must be freed.
				   // This is currently only true if there was a VLAN header in the original user buffer.
	BOOLEAN FreeMdlAfterWrite:1; // True if the MDL chain must be freed (always true if FreeBufAfterWrite is true)
	BOOLEAN bReceivePath:1; // True if this was indicated as a receive (bSendToRx).
				// Otherwise, its presence on the receive path
				// is only due to NDIS loopback.
	PNPF_BUFFERED_WRITE_STATE pState;
}  PACKET_RESERVED, *PPACKET_RESERVED;

// Macro to obtain a PACKET_RESERVED from a NET_BUFFER_LIST
#define RESERVED(_p) ( (_p)->Context ? \
		((PPACKET_RESERVED)NET_BUFFER_LIST_CONTEXT_DATA_START(_p)) \
		: NULL)


/// Macro used in the I/O routines to return the control to user-mode with a success status.
#define EXIT_SUCCESS(quantity) Irp->IoStatus.Information=quantity;\
	Irp->IoStatus.Status = STATUS_SUCCESS;\
	IoCompleteRequest(Irp, IO_NO_INCREMENT);\
	return STATUS_SUCCESS;\

/// Macro used in the I/O routines to return the control to user-mode with a failure status.
#define EXIT_FAILURE(quantity) Irp->IoStatus.Information=quantity;\
	Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;\
	IoCompleteRequest(Irp, IO_NO_INCREMENT);\
	return STATUS_UNSUCCESSFUL;\

/*!
  \brief Utility routine that forms and sends an NDIS_OID_REQUEST to the miniport adapter.
  \param FilterModuleContext Pointer to the filter context structure.
  \param RequestType NdisRequest[Set|Query|method]Information.
  \param Oid The object being set/queried.
  \param InformationBuffer Data for the request.
  \param InformationBufferLength Length of the above.
  \param OutputBufferLength Valid only for method request.
  \param MethodId Valid only for method request.
  \param pBytesProcessed Place to return bytes read/written.
  \return Status of the set/query request.

  Utility routine that forms and sends an NDIS_OID_REQUEST to the miniport,
  waits for it to complete, and returns status to the caller.
  NOTE: this assumes that the calling routine ensures validity
  of the filter handle until this returns.
*/
_IRQL_requires_(PASSIVE_LEVEL)
NDIS_STATUS
NPF_DoInternalRequest(
		_At_(pFiltMod->AdapterBindingStatus, _In_range_(FilterPausing, FilterRestarting))
	_In_ PNPCAP_FILTER_MODULE pFiltMod,
	_In_ NDIS_REQUEST_TYPE				RequestType,
	_In_ NDIS_OID						Oid,
	_When_(RequestType == NdisRequestQueryInformation, _Out_writes_bytes_to_(InformationBufferLength, *pBytesProcessed))
	_When_(RequestType == NdisRequestSetInformation, _In_reads_bytes_(InformationBufferLength))
	_When_(RequestType == NdisRequestMethod, _Inout_updates_bytes_to_(InformationBufferLength, *pBytesProcessed))
	PVOID								InformationBuffer,
	_In_ ULONG							InformationBufferLength,
	_In_ ULONG							OutputBufferLength,
	_In_ ULONG							MethodId,
	_Out_ PULONG						pBytesProcessed
	);


PNET_BUFFER_LIST
NPF_CleanupNBLs(
	_In_ PNPCAP_FILTER_MODULE pFiltMod,
	_In_ PNET_BUFFER_LIST NetBufferLists,
	_In_ BOOLEAN bAtDispatchLevel
	);
/**
 *  @}
 */


/***************************/
/*  	 Prototypes 	   */
/***************************/

/** @defgroup NPF_code NPF functions
 *  @{
 */

FILTER_SET_OPTIONS NPF_RegisterOptions;


/*!
  \brief Callback for NDIS AttachHandler. Not used by NPF.
  \param NdisFilterHandle Specify a handle identifying this instance of the filter. FilterAttach
   should save this handle. It is a required  parameter in subsequent calls to NdisFxxx functions.
  \param FilterDriverContext Filter driver context passed to NdisFRegisterFilterDriver.
  \param AttachParameters attach parameters.
  \return NDIS_STATUS_SUCCESS: FilterAttach successfully allocated and initialize data structures for this filter instance.
		  NDIS_STATUS_RESOURCES: FilterAttach failed due to insufficient resources.
		  NDIS_STATUS_FAILURE: FilterAttach could not set up this instance of this filter and it has called

  Function called by NDIS when a new adapter is installed on the machine With Plug and Play.
*/
FILTER_ATTACH NPF_AttachAdapter;
// NDIS_STATUS
// NPF_AttachAdapter(
// 	NDIS_HANDLE                     NdisFilterHandle,
// 	NDIS_HANDLE                     FilterDriverContext,
// 	PNDIS_FILTER_ATTACH_PARAMETERS  AttachParameters
// 	);


/*!
  \brief Callback for NDIS DetachHandler.
  \param FilterModuleContext Pointer to the filter context area.

  Function called by NDIS when a new adapter is removed from the machine without shutting it down.
  NPF_DetachAdapter closes the adapter calling NdisCloseAdapter() and frees the memory and the structures
  associated with it.
*/
FILTER_DETACH NPF_DetachAdapter;
// VOID
// NPF_DetachAdapter(
// 	NDIS_HANDLE     FilterModuleContext
// 	);


/*!
  \brief Function called by the OS when NPF is unloaded.
  \param DriverObject The driver object of NPF created by the system.

  This is the last function executed when the driver is unloaded from the system. It frees global resources,
  delete the devices and deregisters the filter. The driver can be unloaded by the user stopping the NPF
  service (from control panel or with a console 'net stop npf').
*/
DRIVER_UNLOAD NPF_Unload;
// VOID
// NPF_Unload(
// 	IN PDRIVER_OBJECT DriverObject
// 	);


/*!
  \brief Filter restart routine, callback for NDIS RestartHandler.
  \param FilterModuleContext Pointer to the filter context structure.
  \param RestartParameters Additional information about the restart operation.
  \return NDIS_STATUS_SUCCESS: if filter restarts successfully
		  NDIS_STATUS_XXX: Otherwise.

  Start the datapath - begin sending and receiving NBLs.
*/
FILTER_RESTART NPF_Restart;
// NDIS_STATUS
// NPF_Restart(
// 	NDIS_HANDLE                     FilterModuleContext,
// 	PNDIS_FILTER_RESTART_PARAMETERS RestartParameters
// 	);

/*!
  \brief Filter pause routine, Callback for NDIS PauseHandler.
  \param FilterModuleContext Pointer to the filter context structure.
  \param PauseParameters Additional information about the pause operation.
  \return NDIS_STATUS_SUCCESS if filter pauses successfully, NDIS_STATUS_PENDING if not.
   No other return value is allowed (pause must succeed, eventually).

   Complete all the outstanding sends and queued sends,
   wait for all the outstanding recvs to be returned
   and return all the queued receives.
   N.B.: When the filter is in Pausing state, it can still process OID requests,
   complete sending, and returning packets to NDIS, and also indicate status.
   After this function completes, the filter must not attempt to send or
   receive packets, but it may still process OID requests and status
   indications.
*/
FILTER_PAUSE NPF_Pause;
// NDIS_STATUS
// NPF_Pause(
// 	NDIS_HANDLE                     FilterModuleContext,
// 	PNDIS_FILTER_PAUSE_PARAMETERS   PauseParameters
// 	);


FILTER_OID_REQUEST NPF_OidRequest;

FILTER_CANCEL_OID_REQUEST NPF_CancelOidRequest;

FILTER_OID_REQUEST_COMPLETE NPF_OidRequestComplete;

/*!
  \brief Callback for NDIS StatusHandler. Not used by NPF
*/
FILTER_STATUS NPF_Status;
// VOID
// NPF_Status(
// 	NDIS_HANDLE             FilterModuleContext,
// 	PNDIS_STATUS_INDICATION StatusIndication
// 	);


/*!
  \brief Device PNP event handler.
  \param FilterModuleContext Pointer to the filter context structure.
  \param NetDevicePnPEvent A Device PnP event.

  Callback for NDIS DevicePnPEventNotifyHandler. Not used by NPF
*/
FILTER_DEVICE_PNP_EVENT_NOTIFY NPF_DevicePnPEventNotify;
// VOID
// NPF_DevicePnPEventNotify(
// 	NDIS_HANDLE             FilterModuleContext,
// 	PNET_DEVICE_PNP_EVENT   NetDevicePnPEvent
// 	);


/*!
  \brief Net PNP event handler.
  \param FilterModuleContext Pointer to the filter context structure.
  \param NetPnPEventNotification A Net PnP event.
  \return NDIS_STATUS_XXX

  Callback for NDIS NetPnPEventHandler. Not used by NPF
*/
FILTER_NET_PNP_EVENT NPF_NetPnPEvent;
// NDIS_STATUS
// NPF_NetPnPEvent(
// 	NDIS_HANDLE					FilterModuleContext,
// 	PNET_PNP_EVENT_NOTIFICATION NetPnPEventNotification
// 	);


/*!
  \brief Callback for NDIS SendNetBufferListsHandler.
  \param FilterModuleContext Pointer to the filter context structure.
  \param NetBufferLists A List of NetBufferLists to send.
  \param PortNumber Port Number to which this send is targeted.
  \param SendFlags Specifies if the call is at DISPATCH_LEVEL.

  This function is an optional function for filter drivers. If provided, NDIS
  will call this function to transmit a linked list of NetBuffers, described by a
  NetBufferList, over the network. If this handler is NULL, NDIS will skip calling
  this filter when sending a NetBufferList and will call the next lower
  driver in the stack.  A filter that doesn't provide a FilerSendNetBufferList
  handler can not originate a send on its own.
*/
FILTER_SEND_NET_BUFFER_LISTS NPF_SendEx;
// VOID
// NPF_SendEx(
// 	NDIS_HANDLE         FilterModuleContext,
// 	PNET_BUFFER_LIST    NetBufferLists,
// 	NDIS_PORT_NUMBER    PortNumber,
// 	ULONG               SendFlags
// 	);


/*!
  \brief Callback for NDIS ReturnNetBufferListsHandler.
  \param FilterModuleContext Pointer to the filter context structure.
  \param NetBufferLists A linked list of NetBufferLists that this
						filter driver indicated in a previous call to
						NdisFIndicateReceiveNetBufferLists.
  \param ReturnFlags Flags specifying if the caller is at DISPATCH_LEVEL.

  FilterReturnNetBufferLists is an optional function. If provided, NDIS calls
  FilterReturnNetBufferLists to return the ownership of one or more NetBufferLists
  and their embedded NetBuffers to the filter driver. If this handler is NULL, NDIS
  will skip calling this filter when returning NetBufferLists to the underlying
  miniport and will call the next lower driver in the stack. A filter that doesn't
  provide a FilterReturnNetBufferLists handler cannot originate a receive indication
  on its own.
*/
FILTER_RETURN_NET_BUFFER_LISTS NPF_ReturnEx;
// VOID
// NPF_ReturnEx(
// 	NDIS_HANDLE         FilterModuleContext,
// 	PNET_BUFFER_LIST    NetBufferLists,
// 	ULONG               ReturnFlags
// 	);

/*!
  \brief Callback for NDIS SendNetBufferListsCompleteHandler.
  \param FilterModuleContext Pointer to the filter context structure.
  \param NetBufferLists A chain of NBLs that are being returned to you.
  \param SendCompleteFlags Flags (see documentation).

  This routine is invoked whenever the lower layer is finished processing
  sent NET_BUFFER_LISTs.  If the filter does not need to be involved in the
  send path, you should remove this routine and the FilterSendNetBufferLists
  routine.  NDIS will pass along send packets on behalf of your filter more
  efficiently than the filter can.
*/
FILTER_SEND_NET_BUFFER_LISTS_COMPLETE NPF_SendCompleteEx;
// VOID
// NPF_SendCompleteEx(
// 	NDIS_HANDLE         FilterModuleContext,
// 	PNET_BUFFER_LIST    NetBufferLists,
// 	ULONG               SendCompleteFlags
// 	);


/*!
  \brief Callback for NDIS ReceiveNetBufferListsHandler.
  \param FilterModuleContext Pointer to the filter context structure.
  \param NetBufferLists A linked list of NetBufferLists.
  \param PortNumber Port on which the receive is indicated.
  \param NumberOfNetBufferLists Number of NetBufferLists.
  \param ReceiveFlags Flags (see documentation).

  FilerReceiveNetBufferLists is an optional function for filter drivers.
  If provided, this function processes receive indications made by underlying
  NIC or lower level filter drivers. This function  can also be called as a
  result of loopback. If this handler is NULL, NDIS will skip calling this
  filter when processing a receive indication and will call the next higher
  driver in the stack. A filter that doesn't provide a
  FilterReceiveNetBufferLists handler cannot provide a
  FilterReturnNetBufferLists handler and cannot a initiate an original receive
  indication on its own.
  N.B.: It is important to check the ReceiveFlags in NDIS_TEST_RECEIVE_CANNOT_PEND.
  This controls whether the receive indication is an synchronous or
  asynchronous function call.
*/
FILTER_RECEIVE_NET_BUFFER_LISTS NPF_TapEx;
// VOID
// NPF_TapEx(
// 	NDIS_HANDLE         FilterModuleContext,
// 	PNET_BUFFER_LIST    NetBufferLists,
// 	NDIS_PORT_NUMBER    PortNumber,
// 	ULONG               NumberOfNetBufferLists,
// 	ULONG               ReceiveFlags
// 	);


/*!
  \brief Callback for NDIS CancelSendNetBufferListsHandler.
  \param FilterModuleContext Pointer to the filter context structure.
  \param CancelId An identifier for all NBLs that should be dequeued.

  This function cancels any NET_BUFFER_LISTs pended in the filter and then
  calls the NdisFCancelSendNetBufferLists to propagate the cancel operation.
  If your driver does not queue any send NBLs, you may omit this routine.
  NDIS will propagate the cancelation on your behalf more efficiently.
*/
FILTER_CANCEL_SEND_NET_BUFFER_LISTS NPF_CancelSendNetBufferLists;
// VOID
// NPF_CancelSendNetBufferLists(
// 	NDIS_HANDLE             FilterModuleContext,
// 	PVOID                   CancelId
// 	);


/*!
  \brief Callback for NDIS SetFilterModuleOptionsHandler.
  \param FilterModuleContext Pointer to the filter context structure.
  \return NDIS_STATUS_SUCCESS
		  NDIS_STATUS_RESOURCES
		  NDIS_STATUS_FAILURE

  This function set the optional handlers for the filter. Not used by NPF
*/
FILTER_SET_MODULE_OPTIONS NPF_SetModuleOptions;
// NDIS_STATUS
// 	NPF_SetModuleOptions(
// 	NDIS_HANDLE             FilterModuleContext
// 	);

/* Validate I/O IRP parameters and do boilerplate init.
 * Suitable for IRP_MJ_READ and IRP_MJ_WRITE with DO_DIRECT_IO
 */
_IRQL_requires_max_(PASSIVE_LEVEL)
NTSTATUS NPF_ValidateIoIrp(
	_In_ PIRP pIrp,
	_Outptr_result_nullonfailure_ POPEN_INSTANCE* ppOpen,
	_Outptr_result_nullonfailure_ PVOID* ppBuf,
	_Out_ PULONG pBufLen
);

/*!
  \brief The initialization routine of the driver.
  \param DriverObject The driver object of NPF created by the system.
  \param RegistryPath The registry path containing the keys related to the driver.
  \return STATUS_SUCCESS
		  STATUS_UNSUCCESSFUL.

  DriverEntry is a mandatory function in a device driver. Like the main() of a user level program, it is called
  by the system when the driver is loaded in memory and started. Its purpose is to initialize the driver,
  performing all the allocations and the setup. In particular, DriverEntry registers all the driver's I/O
  callbacks, creates the devices, defines NPF as a protocol inside NDIS.
*/
DRIVER_INITIALIZE DriverEntry;
// NTSTATUS
// DriverEntry(
// 	IN PDRIVER_OBJECT DriverObject,
// 	IN PUNICODE_STRING RegistryPath
// 	);

/*!
  \brief Opens a new instance of the driver.
  \param DeviceObject Pointer to the device object utilized by the user.
  \param Irp Pointer to the IRP containing the user request.
  \return The status of the operation. See ntstatus.h in the DDK.

  This function is called by the OS when a new instance of the driver is opened, i.e. when a user application
  performs a CreateFile on a device created by NPF. NPF_Open allocates and initializes variables, objects
  and buffers needed by the new instance, fills the OPEN_INSTANCE structure associated with it and opens the
  adapter with a call to NdisOpenAdapter.
*/
_Dispatch_type_(IRP_MJ_CREATE)
_IRQL_requires_max_(PASSIVE_LEVEL)
DRIVER_DISPATCH NPF_OpenAdapter;
// NTSTATUS
// NPF_OpenAdapter(
// 	IN PDEVICE_OBJECT DeviceObject,
// 	IN PIRP Irp
// 	);


/*!
  \brief Closes an instance of the driver.
  \param DeviceObject Pointer to the device object utilized by the user.
  \param Irp Pointer to the IRP containing the user request.
  \return The status of the operation. See ntstatus.h in the DDK.

  This function is called when a running instance of the driver is closed by the user with a CloseHandle().
  Used together with NPF_CloseAdapter().
  It stops the capture process, deallocates the memory and the objects associated with the
  instance and closing the files.
*/
_Dispatch_type_(IRP_MJ_CLEANUP)
_IRQL_requires_max_(PASSIVE_LEVEL)
DRIVER_DISPATCH NPF_Cleanup;
// NTSTATUS
// NPF_Cleanup(
// 	IN PDEVICE_OBJECT DeviceObject,
// 	IN PIRP Irp
// 	);


/*!
  \brief Closes an instance of the driver.
  \param DeviceObject Pointer to the device object utilized by the user.
  \param Irp Pointer to the IRP containing the user request.
  \return The status of the operation. See ntstatus.h in the DDK.

  This function is called when a running instance of the driver is closed by the user with a CloseHandle().
  Used together with NPF_Cleanup().
  It stops the capture process, deallocates the memory and the objects associated with the
  instance and closing the files. The network adapter is then closed with a call to NdisCloseAdapter.
*/
_Dispatch_type_(IRP_MJ_CLOSE)
_IRQL_requires_max_(PASSIVE_LEVEL)
DRIVER_DISPATCH NPF_CloseAdapter;
// NTSTATUS
// NPF_CloseAdapter(
// 	IN PDEVICE_OBJECT DeviceObject,
// 	IN PIRP Irp
// 	);


/*!
  \brief Capture a NBL for all OpenInstances on an adapter.
  \param pFiltMod Pointer to a filter module where the packets should be captured
  \param pNetBufferLists A List of NetBufferLists to receive.
  \param pOpenOriginating A pointer to the OpenInstance that originated/injected these packets so SkipSentPackets can be honored. NULL if not applicable.
  \param AtDispatchLevel Set to TRUE if the caller knows they are at DISPATCH_LEVEL.

  NPF_DoTap() is called for every incoming and outgoing packet. It is the most important and one of
  the most complex functions of NPF: it executes the filter, runs the statistical engine (if the instance is in
  statistical mode), gathers the timestamp, moves the packet in the buffer. NPF_DoTap() is the only function,
  along with the filtering ones, that is executed for every incoming packet, therefore it is carefully
  optimized.
*/
VOID
_When_(AtDispatchLevel != FALSE, _IRQL_requires_(DISPATCH_LEVEL))
NPF_DoTap(
	_In_ PNPCAP_FILTER_MODULE pFiltMod,
	_In_ const PNET_BUFFER_LIST NetBufferLists,
	_In_opt_ POPEN_INSTANCE pOpenOriginating,
	_In_ BOOLEAN AtDispatchLevel
	);

/*!
  \brief Handles the IOCTL calls.
  \param DeviceObject Pointer to the device object utilized by the user.
  \param Irp Pointer to the IRP containing the user request.
  \return The status of the operation. See ntstatus.h in the DDK.

  Once the packet capture driver is opened it can be configured from user-level applications with IOCTL commands
  using the DeviceIoControl() system call. NPF_IoControl receives and serves all the IOCTL calls directed to NPF.
  The following commands are recognized:
  - #BIOCSETBUFFERSIZE
  - #BIOCSETF
  - #BIOCGSTATS
  - #BIOCSRTIMEOUT
  - #BIOCSMODE
  - #BIOCSWRITEREP
  - #BIOCSMINTOCOPY
  - #BIOCSETOID
  - #BIOCQUERYOID
  - #BIOCGEVNAME
  -	#BIOCSENDPACKETSSYNC
  -	#BIOCSENDPACKETSNOSYNC
*/
_Dispatch_type_(IRP_MJ_DEVICE_CONTROL)
_IRQL_requires_max_(PASSIVE_LEVEL)
DRIVER_DISPATCH NPF_IoControl;
// NTSTATUS
// NPF_IoControl(
// 	IN PDEVICE_OBJECT DeviceObject,
// 	IN PIRP Irp
// );


/*!
  \brief Writes a raw packet to the network.
  \param DeviceObject Pointer to the device object on which the user wrote the packet.
  \param Irp Pointer to the IRP containing the user request.
  \return The status of the operation. See ntstatus.h in the DDK.

  This function is called by the OS in consequence of user WriteFile() call, with the data of the packet that must
  be sent on the net. The data is contained in the buffer associated with Irp, NPF_Write takes it and
  delivers it to the NIC driver via the NdisSend() function. The Nwrites field of the OPEN_INSTANCE structure
  associated with Irp indicates the number of copies of the packet that will be sent: more than one copy of the
  packet can be sent for performance reasons.
*/
_Dispatch_type_(IRP_MJ_WRITE)
_IRQL_requires_max_(PASSIVE_LEVEL)
DRIVER_DISPATCH NPF_Write;
// NTSTATUS
// NPF_Write(
// 	IN PDEVICE_OBJECT DeviceObject,
// 	IN PIRP Irp
// 	);


/*!
  \brief Writes a buffer of raw packets to the network.
  \param Open Pointer to the open instance performing this write
  \param UserBuff Pointer to the buffer containing the packets to send.
  \param UserBuffSize Size of the buffer with the packets.
  \param sync If set to TRUE, the packets are transmitted respecting their timestamps.
  \param Written The amount of bytes actually sent.
  \return NTSTATUS value indicating success or error.

  This function is called by the OS in consequence of a BIOCSENDPACKETSNOSYNC or a BIOCSENDPACKETSSYNC IOCTL.
  The buffer received as input parameter contains an arbitrary number of packets, each of which preceded by a
  dump_bpf_hdr structure. NPF_BufferedWrite() scans the buffer and sends every packet via the NdisSend() function.
  When Sync is set to TRUE, the packets are synchronized with the KeQueryPerformanceCounter() function.
  This requires a remarkable amount of CPU, but allows to respect the timestamps associated with packets with a precision
  of some microseconds (depending on the precision of the performance counter of the machine).
  If Sync is false, the timestamps are ignored and the packets are sent as fat as possible.
*/
_IRQL_requires_(PASSIVE_LEVEL)
NTSTATUS NPF_BufferedWrite(
	_In_ POPEN_INSTANCE Open,
	_In_reads_bytes_(UserBuffSize) PUCHAR UserBuff,
	_In_ ULONG UserBuffSize,
	_In_ BOOLEAN Sync,
	_Out_ PULONG_PTR Written
	);

/*!
  \brief Function that serves the user's reads.
  \param DeviceObject Pointer to the device used by the user.
  \param Irp Pointer to the IRP containing the user request.
  \return The status of the operation. See ntstatus.h in the DDK.

  This function is called by the OS in consequence of user ReadFile() call. It moves the data present in the
  kernel buffer to the user buffer associated with Irp.
  Any available packets are transferred regardless of MinToCopy. Statistics are
  delivered regardless of PacketSetReadTimeout. These values are handled in
  user-mode by Packet.dll. The Read call will return as quickly as possible
  without waiting on the ReadEvent.
*/
_Dispatch_type_(IRP_MJ_READ)
_IRQL_requires_max_(PASSIVE_LEVEL)
DRIVER_DISPATCH NPF_Read;
// NTSTATUS
// NPF_Read(
// 	IN PDEVICE_OBJECT DeviceObject,
// 	IN PIRP Irp
// 	);


/*!
  \brief Add the filter module context to the global filter module array.
  \param pFiltMod Pointer to filter module context structure.

  This function is used by NPF_AttachAdapter() and NPF_OpenAdapter() to add a new open context to
  the global open array, this array is designed to help find and clean the specific adapter context.
*/
void
NPF_AddToFilterModuleArray(
	_In_ PNPCAP_FILTER_MODULE pFiltMod
	);

/*!
  \brief Get the filter module for the loopback adapter
  \return Pointer to the loopback filter module.
 */
_Ret_maybenull_
PNPCAP_FILTER_MODULE
NPF_GetLoopbackFilterModule();


/*!
  \brief Create a filter module.
  \param AdapterName The adapter name of the target filter module.
  \param SelectedIndex The medium of the filter module.
  \return Pointer to the new filter module.

  This function is used to create a filter module context object
*/
_Ret_maybenull_
__declspec(restrict) PNPCAP_FILTER_MODULE
NPF_CreateFilterModule(
	_In_ NDIS_HANDLE NdisFilterHandle,
	_In_ PNDIS_STRING AdapterName
	);

_IRQL_requires_(PASSIVE_LEVEL)
VOID
NPF_RemoveFromGroupOpenArray( _Inout_ POPEN_INSTANCE pOpen);

VOID
NPF_ReleaseOpenInstanceResources(_Inout_ POPEN_INSTANCE pOpen);

_IRQL_requires_(PASSIVE_LEVEL)
VOID
NPF_ReleaseFilterModuleResources(_Inout_ PNPCAP_FILTER_MODULE pFiltMod);

BOOLEAN NPF_IsOpenInstance(_In_ POPEN_INSTANCE pOpen);

_When_(AtDispatchLevel != FALSE, _IRQL_requires_(DISPATCH_LEVEL))
BOOLEAN NPF_StartUsingBinding(_Inout_ PNPCAP_FILTER_MODULE pFiltMod, _In_ BOOLEAN AtDispatchLevel);

_When_(AtDispatchLevel != FALSE, _IRQL_requires_(DISPATCH_LEVEL))
VOID NPF_StopUsingBinding(_Inout_ PNPCAP_FILTER_MODULE pFiltMod, _In_ BOOLEAN AtDispatchLevel);

_When_(AtDispatchLevel != FALSE, _IRQL_requires_(DISPATCH_LEVEL))
_When_(MaxOpen == OpenRunning, _IRQL_requires_(PASSIVE_LEVEL))
BOOLEAN NPF_StartUsingOpenInstance(_Inout_ POPEN_INSTANCE pOpen, _In_range_(OpenRunning,OpenDetached) OPEN_STATE MaxOpen, _In_ BOOLEAN AtDispatchLevel);

_When_(AtDispatchLevel != FALSE, _IRQL_requires_(DISPATCH_LEVEL))
VOID NPF_StopUsingOpenInstance(_Inout_ POPEN_INSTANCE pOpen, _In_range_(OpenRunning,OpenDetached) OPEN_STATE MaxOpen, _In_ BOOLEAN AtDispatchLevel);

OPEN_STATE
NPF_DemoteOpenStatus(
	_Inout_ POPEN_INSTANCE pOpen,
	_In_range_(OpenDetached,OpenClosed) OPEN_STATE NewState
	);

_IRQL_requires_(PASSIVE_LEVEL)
NDIS_STATUS
NPF_SetPacketFilter(
	_In_ PNPCAP_FILTER_MODULE pFiltMod,
	_In_ ULONG PacketFilter
);
_IRQL_requires_(PASSIVE_LEVEL)
NDIS_STATUS
NPF_SetLookaheadSize(
	_In_ PNPCAP_FILTER_MODULE pFiltMod,
	_In_ ULONG LookaheadSize
);

#ifdef HAVE_DOT11_SUPPORT
USHORT NPF_LookUpDataRateMappingTable(
	       _In_ PNPCAP_FILTER_MODULE pFiltMod,
	       _In_ UCHAR ucDataRate
	       );
#endif

VOID NPF_UpdateTimestampModeCounts(
		_Inout_opt_ PNPCAP_FILTER_MODULE pFiltMod,
		_In_ ULONG newmode,
		_In_ ULONG oldmode
		);
/**
 *  @}
 */

#endif  /*main ifndef/define*/

```

`packetWin7/npf/npf/Read.c`:

```c
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
/*
 * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)
 * Copyright (c) 2005 - 2010 CACE Technologies, Davis (California)
 * Copyright (c) 2010 - 2013 Riverbed Technology, San Francisco (California), Yang Luo (China)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Politecnico di Torino, CACE Technologies
 * nor the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include "stdafx.h"

#include "Packet.h"
#include "win_bpf.h"
#include "time_calls.h"
#if DBG
#include <limits.h> // MAX_LONG
#endif

 //
 // Global variables
 //
extern PNPCAP_DRIVER_EXTENSION g_pDriverExtension;

_Must_inspect_result_
_Success_(return == ulDesiredLen)
ULONG
NPF_CopyFromNBCopyToBuffer(
		_In_ PNPF_NB_COPIES pNBCopy,
		_Out_writes_(ulDesiredLen) PUCHAR __restrict pDstBuf,
		_In_ ULONG ulDesiredLen
		)
{
	if (!NT_VERIFY(ulDesiredLen <= pNBCopy->ulSize))
	{
		return 0;
	}
	RtlCopyMemory(pDstBuf, pNBCopy->Buffer, ulDesiredLen);

	return ulDesiredLen;
}

//-------------------------------------------------------------------

_Use_decl_annotations_
NTSTATUS
NPF_Read(
	PDEVICE_OBJECT DeviceObject,
	PIRP Irp
	)
{
	POPEN_INSTANCE			Open;
	PUCHAR packp = NULL;
	struct bpf_hdr*			header;
	ULONG copied=0;
	ULONG plen, available;
	LOCK_STATE_EX lockState;
	NTSTATUS Status = STATUS_SUCCESS;

	UNREFERENCED_PARAMETER(DeviceObject);
	TRACE_ENTER();

	/* Validate */
	Status = NPF_ValidateIoIrp(Irp, &Open, &packp, &available);
	if (Status != STATUS_SUCCESS)
	{
		goto NPF_Read_End;
	}

	// Note a pending IRP at OpenDetached state
	if (!NPF_StartUsingOpenInstance(Open, OpenDetached, FALSE))
	{
		// Instance is being closed
		Status = STATUS_CANCELLED;
		goto NPF_Read_End;
	}

	// Failures after this point must call NPF_StopUsingOpenInstance
	do
	{
		if (Open->Size == 0)
		{
			Status = STATUS_UNSUCCESSFUL;
			break;
		}

		if (packp == NULL)
		{
			Status = STATUS_INSUFFICIENT_RESOURCES;
			break;
		}

		// Capture mode: need at least a bpf_hdr
		plen = sizeof(struct bpf_hdr);

		// Stat mode needs 2 LONGLONGs
		if (!Open->bModeCapt)
		{
			plen += 2 * sizeof(LONGLONG);
		}

		if (available < plen)
		{
			Status = STATUS_BUFFER_TOO_SMALL;
			copied = plen; // report how much we need.
			break;
		}
	} while (FALSE);

	if (Status != STATUS_SUCCESS)
	{
		NPF_StopUsingOpenInstance(Open, OpenDetached, NPF_IRQL_UNKNOWN);
		goto NPF_Read_End;
	}

	// Reset the event; all paths forward are STATUS_SUCCESS
	if (Open->ReadEvent != NULL)
		KeClearEvent(Open->ReadEvent);

	// Stats mode returns and resets stats every time it is called.
	// Packet.dll uses ReadEvent to time the read calls so they happen at
	// regular intervals. bModeCapt prevents TapExForEachOpen from setting
	// the event, so it's strictly a timed wait.
	if (!Open->bModeCapt)
	{
		//this capture instance is in statistics mode
		LONGLONG *Stats = (LONGLONG *)(packp + sizeof(struct bpf_hdr));
		copied = plen; // Set above during size validation
		plen -= sizeof(struct bpf_hdr);

		//fill the bpf header for this packet
		header = (struct bpf_hdr *)packp;
		GET_TIME(&header->bh_tstamp, &Open->start, Open->TimestampMode);
		header->bh_caplen = plen;
		header->bh_datalen = plen;
		header->bh_hdrlen = sizeof(struct bpf_hdr);

		Stats[0] = Open->Npackets.QuadPart;
		Stats[1] = Open->Nbytes.QuadPart;

		//reset the countetrs
		FILTER_ACQUIRE_LOCK(&Open->CountersLock, NPF_IRQL_UNKNOWN);
		Open->Npackets.QuadPart = 0;
		Open->Nbytes.QuadPart = 0;
		FILTER_RELEASE_LOCK(&Open->CountersLock, NPF_IRQL_UNKNOWN);

		NPF_StopUsingOpenInstance(Open, OpenDetached, NPF_IRQL_UNKNOWN);

		Status = STATUS_SUCCESS;
		goto NPF_Read_End;
	}

	//------------------------------------------------------------------------------
	copied = 0;

	// Lock this so we don't increment Free during a buffer reset
	NdisAcquireRWLockRead(Open->BufferLock, &lockState, 0);

	// Ensure we have enough space left for at least a bpf_hdr
	while (available > copied + NPF_CAP_SIZE(0))
	{
		//there are some packets in the buffer
		PLIST_ENTRY pCapDataEntry = ExInterlockedRemoveHeadList(&Open->PacketQueue, &Open->PacketQueueLock);
		if (pCapDataEntry == NULL)
		{
			// Done (empty buffer)
			break;
		}
		PNPF_CAP_DATA pCapData = CONTAINING_RECORD(pCapDataEntry, NPF_CAP_DATA, PacketQueueEntry);

		/* Any NPF_CAP_DATA in the queue must be initialized and point to valid data. */
		NT_ASSERT(pCapData->pNBCopy);
		NT_ASSERT(pCapData->pNBCopy->pNBLCopy);
		NT_ASSERT(pCapData->pNBCopy->ulPacketSize < 0xffffffff);

#ifdef HAVE_DOT11_SUPPORT
		PIEEE80211_RADIOTAP_HEADER pRadiotapHeader = (PIEEE80211_RADIOTAP_HEADER) pCapData->pNBCopy->pNBLCopy->Dot11RadiotapHeader;
#endif
		ULONG ulCapSize = NPF_CAP_OBJ_SIZE(pCapData);
		if (ulCapSize > available - copied)
		{
			//if the packet does not fit into the user buffer, we've ended copying packets
			if (copied == 0)
			{
				// This packet is too large for the entire buffer. Truncate it.
				plen = available - (ulCapSize - pCapData->ulCaplen);
			}
			else
			{
				// Put this packet back.
				ExInterlockedInsertHeadList(&Open->PacketQueue, pCapDataEntry, &Open->PacketQueueLock);
				break;
			}
		}
		else
		{
			plen = pCapData->ulCaplen;
		}

		header = (struct bpf_hdr *) (packp + copied);
		switch (Open->TimestampMode)
		{
			case TIMESTAMPMODE_QUERYSYSTEMTIME:
			case TIMESTAMPMODE_QUERYSYSTEMTIME_PRECISE:
				NT_ASSERT(pCapData->pNBCopy->pNBLCopy->SystemTime.QuadPart > 0);
				GetTimevalFromSystemTime(&header->bh_tstamp, pCapData->pNBCopy->pNBLCopy->SystemTime, Open->bNano);
				break;
			default:
				NT_ASSERT(Open->TimestampMode == TIMESTAMPMODE_SINGLE_SYNCHRONIZATION);
				NT_ASSERT(pCapData->pNBCopy->pNBLCopy->PerfCount.QuadPart > 0);
				GetTimevalFromPerfCount(&header->bh_tstamp, &Open->start, pCapData->pNBCopy->pNBLCopy->PerfCount, Open->bNano);
				break;
		}
		NT_ASSERT(header->bh_tstamp.tv_sec > 0 || header->bh_tstamp.tv_usec > 0);
		header->bh_caplen = 0;
		header->bh_datalen = pCapData->pNBCopy->ulPacketSize;
		header->bh_hdrlen = sizeof(struct bpf_hdr);

		copied += sizeof(struct bpf_hdr);

#ifdef HAVE_DOT11_SUPPORT
		if (pRadiotapHeader != NULL)
		{
			RtlCopyMemory(packp + copied, pRadiotapHeader, pRadiotapHeader->it_len);
			header->bh_caplen += pRadiotapHeader->it_len;
			header->bh_datalen += pRadiotapHeader->it_len;
			copied += pRadiotapHeader->it_len;
		}
#endif

		ULONG ulCopied = NPF_CopyFromNBCopyToBuffer(pCapData->pNBCopy, packp + copied, plen);
		if (ulCopied < plen) {
			INFO_DBG("NetBuffer missing %lu bytes\n", plen - ulCopied);
		}
		header->bh_caplen += ulCopied;

		// Fix up alignment
		copied += ulCopied;
		copied = Packet_WORDALIGN(copied);

		// Return this capture data
		// MUST be done BEFORE incrementing free space, otherwise we risk runaway allocations while this is stalled.
		NPF_ReturnCapData(pCapData);

		// Increase free space by the amount that it was reduced before
		NpfInterlockedExchangeAdd(&Open->Free, ulCapSize);
		NT_ASSERT(Open->Free <= Open->Size);
	}

	NdisReleaseRWLock(Open->BufferLock, &lockState);
	NPF_StopUsingOpenInstance(Open, OpenDetached, NPF_IRQL_UNKNOWN);

	if (copied == 0 && Open->OpenStatus == OpenDetached)
	{
		// Filter module is detached and there are no more packets in the buffer
		Status = STATUS_DEVICE_REMOVED;
	}
	else
	{
		Status = STATUS_SUCCESS;
	}

NPF_Read_End:
	Irp->IoStatus.Information = copied;
	Irp->IoStatus.Status = Status;
	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	TRACE_EXIT();
	return Status;
}

VOID
NPF_AlignProtocolField(
	_In_ UINT Alignment,
	_Inout_ PUINT pCur
)
{
	*pCur = (*pCur + Alignment - 1);
	*pCur = *pCur - *pCur % Alignment;
}

/* Returns the number of NET_BUFFERs that couldn't be processed because of
 * insufficient resources (resdropped)
 */
ULONG NPF_GetMetadata(
	_In_ const PNET_BUFFER_LIST pNetBufferLists,
	_Inout_ PSINGLE_LIST_ENTRY NBLCopyHead,
	_In_ PNPCAP_FILTER_MODULE pFiltMod
	)
{
	PNPF_NBL_COPY pNBLCopy = NULL;
	PSINGLE_LIST_ENTRY pNBLCopyPrev = NBLCopyHead;
	ULONG resdropped = 0;
	for (PNET_BUFFER_LIST pNetBufList = pNetBufferLists;
			pNetBufList != NULL;
			pNetBufList = NET_BUFFER_LIST_NEXT_NBL(pNetBufList))
	{
#ifdef HAVE_DOT11_SUPPORT
		PIEEE80211_RADIOTAP_HEADER pRadiotapHeader = NULL;
#endif

		NT_ASSERT(pNBLCopyPrev);
		NT_ASSERT(pNBLCopyPrev->Next == NULL);
		// Add another NBL copy to the chain
		pNBLCopy = (PNPF_NBL_COPY) ExAllocateFromLookasideListEx(&g_pDriverExtension->NBLCopyPool);
		if (pNBLCopy == NULL)
		{
			//Insufficient resources.
			for (PNET_BUFFER pNetBuf = pNetBufList->FirstNetBuffer;
					pNetBuf != NULL;
					pNetBuf = NET_BUFFER_NEXT_NB(pNetBuf))
			{
				resdropped++;
			}
			continue;
		}
		RtlZeroMemory(pNBLCopy, sizeof(NPF_NBL_COPY));
		pNBLCopy->refcount = 1;
		PSINGLE_LIST_ENTRY pSrcNBPrev = &pNBLCopy->NBCopiesHead;


		for (PNET_BUFFER pNetBuf = pNetBufList->FirstNetBuffer;
				pNetBuf != NULL;
				pNetBuf = NET_BUFFER_NEXT_NB(pNetBuf))
		{
			// Some checks for malformed packets that we've seen other drivers produce.
			// If Npcap is implicated in crashes, use the debug build to turn these into assertion failures.
			// DRIVER_IRQL_NOT_LESS_OR_EQUAL (d1) referencing addr 000a indicates null ptr deref.
			if (!NT_VERIFY(NULL != NET_BUFFER_CURRENT_MDL(pNetBuf))
					|| !NT_VERIFY(NULL != NET_BUFFER_FIRST_MDL(pNetBuf)))
			{
				// Skip this one, let someone else crash.
				// We could drop it, but it's not our job to police the NDIS stack.
				continue;
			}
			// Add another copy to the chain
			PNPF_SRC_NB pSrcNB = (PNPF_SRC_NB) ExAllocateFromLookasideListEx(&g_pDriverExtension->SrcNBPool);
			if (pSrcNB == NULL)
			{
				//Insufficient resources.
				resdropped++;
				continue;
			}
			RtlZeroMemory(pSrcNB, sizeof(NPF_SRC_NB));
			pSrcNB->pNBCopy = (PNPF_NB_COPIES) ExAllocateFromLookasideListEx(&g_pDriverExtension->NBCopiesPool);
			if (pSrcNB->pNBCopy == NULL)
			{
				// Out of resources
				resdropped++;
				ExFreeToLookasideListEx(&g_pDriverExtension->SrcNBPool, pSrcNB);
				continue;
			}
			RtlZeroMemory(pSrcNB->pNBCopy, sizeof(NPF_NB_COPIES));
			// OK, all allocations succeeded; now fill out the info.
			pSrcNBPrev->Next = &pSrcNB->CopiesEntry;
			pSrcNBPrev = pSrcNBPrev->Next;
			pSrcNB->pNetBuffer = pNetBuf;
			pSrcNB->pNBCopy->pNBLCopy = pNBLCopy;
			pSrcNB->pNBCopy->ulPacketSize = NET_BUFFER_DATA_LENGTH(pNetBuf);
			pSrcNB->pNBCopy->refcount = 1;
		}

		// If no NBCopies were added, drop this NBLCopy also.
		if (pNBLCopy->NBCopiesHead.Next == NULL) {
			ExFreeToLookasideListEx(&g_pDriverExtension->NBLCopyPool, pNBLCopy);
			continue;
		}

		// Otherwise, gather the appropriate metadata
		pNBLCopy->qInfo.Value = NET_BUFFER_LIST_INFO(pNetBufList, Ieee8021QNetBufferListInfo);
		// We can't distinguish VLAN 0 from no VLAN tag, so we try this:
		// If it's one of our own injected packets,
		if (pNetBufList->SourceHandle == pFiltMod->AdapterHandle
				&& RESERVED(pNetBufList) != NULL) {
			// then FreeBufAfterWrite means the Ethernet header is a replacement
			// and we can infer that the original packet had a VLAN header.
			pNBLCopy->bQinfoPresent = RESERVED(pNetBufList)->FreeBufAfterWrite;
		}
#ifdef HAVE_DOT11_SUPPORT
			// Handle native 802.11 media specific OOB data here.
			// This code will help provide the radiotap header for 802.11 packets, see http://www.radiotap.org for details.
			if (pFiltMod->Dot11 && (NET_BUFFER_LIST_INFO(pNetBufList, MediaSpecificInformation) != 0))
			{
				PDOT11_EXTSTA_RECV_CONTEXT  pwInfo;

				UINT cur = 0;

				pwInfo = NET_BUFFER_LIST_INFO(pNetBufList, MediaSpecificInformation);
				if (pwInfo->Header.Type != NDIS_OBJECT_TYPE_DEFAULT
					|| pwInfo->Header.Revision != DOT11_EXTSTA_RECV_CONTEXT_REVISION_1
					|| pwInfo->Header.Size != sizeof(DOT11_EXTSTA_RECV_CONTEXT)) {
					// This isn't the information we're looking for. Move along.
					goto RadiotapDone;
				}

				pNBLCopy->Dot11RadiotapHeader = (PUCHAR) ExAllocateFromLookasideListEx(&g_pDriverExtension->Dot11HeaderPool);
				if (pNBLCopy->Dot11RadiotapHeader == NULL)
				{
					// Insufficient memory
					// TODO: Count this as a drop?
					goto RadiotapDone;
				}
				RtlZeroMemory(pNBLCopy->Dot11RadiotapHeader, SIZEOF_RADIOTAP_BUFFER);
				pRadiotapHeader = (PIEEE80211_RADIOTAP_HEADER) pNBLCopy->Dot11RadiotapHeader;

				// The radiotap header is also placed in the buffer.
				cur += sizeof(IEEE80211_RADIOTAP_HEADER) / sizeof(UCHAR);

				// [Radiotap] "TSFT" field.
				// Size: 8 bytes, Alignment: 8 bytes.
				if ((pwInfo->uReceiveFlags & DOT11_RECV_FLAG_RAW_PACKET_TIMESTAMP) == DOT11_RECV_FLAG_RAW_PACKET_TIMESTAMP)
				{
					pRadiotapHeader->it_present |= BIT(IEEE80211_RADIOTAP_TSFT);
					RtlCopyMemory((PUCHAR)pRadiotapHeader + cur, &pwInfo->ullTimestamp, sizeof(INT64) / sizeof(UCHAR));
					cur += sizeof(INT64) / sizeof(UCHAR);
				}

				// [Radiotap] "Flags" field.
				// Size: 1 byte, Alignment: 1 byte.
				if ((pwInfo->uReceiveFlags & DOT11_RECV_FLAG_RAW_PACKET) != DOT11_RECV_FLAG_RAW_PACKET) // The packet doesn't have FCS. We always have no FCS for all packets currently.
				{
					pRadiotapHeader->it_present |= BIT(IEEE80211_RADIOTAP_FLAGS);
					*((PUCHAR)pRadiotapHeader + cur) = 0x0; // 0x0: none
					cur += sizeof(UCHAR) / sizeof(UCHAR);
				}
				else // The packet has FCS.
				{
					pRadiotapHeader->it_present |= BIT(IEEE80211_RADIOTAP_FLAGS);
					*((PUCHAR)pRadiotapHeader + cur) = IEEE80211_RADIOTAP_F_FCS; // 0x10: frame includes FCS

					// FCS check fails.
					if ((pwInfo->uReceiveFlags & DOT11_RECV_FLAG_RAW_PACKET_FCS_FAILURE) == DOT11_RECV_FLAG_RAW_PACKET_FCS_FAILURE)
					{
						*((PUCHAR)pRadiotapHeader + cur) |= IEEE80211_RADIOTAP_F_BADFCS; // 0x40: frame failed FCS check
					}

					cur += sizeof(UCHAR) / sizeof(UCHAR);
				}

				// [Radiotap] "Rate" field.
				// Size: 1 byte, Alignment: 1 byte.
				// Looking up the ucDataRate field's value in the data rate mapping table.
				// If not found, return 0.
				INFO_DBG("pwInfo->ucDataRate = %u\n", pwInfo->ucDataRate);
				USHORT usDataRateValue = NPF_LookUpDataRateMappingTable(pFiltMod, pwInfo->ucDataRate);
				if (usDataRateValue != 0) {
					pRadiotapHeader->it_present |= BIT(IEEE80211_RADIOTAP_RATE);
					// The miniport might be providing data rate values > 127.5 Mb/s, but radiotap's "Rate" field is only 8 bits,
					// so we at least make it the maximum value instead of overflowing it.
					if (usDataRateValue > 255)
					{
						usDataRateValue = 255;
					}
					*((PUCHAR)pRadiotapHeader + cur) = (UCHAR) usDataRateValue;
					cur += sizeof(UCHAR) / sizeof(UCHAR);
				}

				if (pwInfo->uPhyId || pwInfo->uChCenterFrequency)
				{
					USHORT flags = 0;
					NPF_AlignProtocolField(2, &cur);
					// [Radiotap] "Channel" field.
					// Size: 2 bytes + 2 bytes, Alignment: 2 bytes.
					INFO_DBG("pwInfo->uPhyId = %x\n", pwInfo->uPhyId);
					if (pwInfo->uPhyId == dot11_phy_type_fhss)
					{
						flags = IEEE80211_CHAN_GFSK; // 0x0800
					}
					else if (pwInfo->uPhyId == dot11_phy_type_ofdm)
					{
						flags = IEEE80211_CHAN_OFDM; // 0x0040
					}
					else if (pwInfo->uPhyId == dot11_phy_type_hrdsss)
					{
						flags = IEEE80211_CHAN_CCK; // 0x0020
					}
					else if (pwInfo->uPhyId == dot11_phy_type_erp)
					{
						flags = IEEE80211_CHAN_OFDM; // 0x0040
					}
					else if (pwInfo->uPhyId != dot11_phy_type_irbaseband)
					{
						// 2484 is cutoff value used by Wireshark for CommView files, we follow this design here.
						if (pwInfo->uChCenterFrequency > 2484) // 5 GHz
						{
							flags = IEEE80211_CHAN_5GHZ; // 0x0100
						}
						else // 2.4 GHz
						{
							flags = IEEE80211_CHAN_2GHZ; // 0x0080
						}
					}

					// If the frequency is higher than 65535, radiotap can't hold this value because "Frequency" field is only 16 bits, we just leave it the maximum value 65535.
					INFO_DBG("pwInfo->uChCenterFrequency = %lu\n", pwInfo->uChCenterFrequency);
					if (pwInfo->uChCenterFrequency <= 65535)
					{
						*((USHORT*)pRadiotapHeader + cur) = (USHORT) pwInfo->uChCenterFrequency;
					}
					else
					{
						*((USHORT*)pRadiotapHeader + cur) = 65535;
					}
					cur += sizeof(USHORT) / sizeof(UCHAR);

					pRadiotapHeader->it_present |= BIT(IEEE80211_RADIOTAP_CHANNEL);
					*((USHORT*)pRadiotapHeader + cur) = flags;
					cur += sizeof(USHORT) / sizeof(UCHAR);
				}

				// [Radiotap] "Antenna signal" field, 1 byte.
				// Size: 1 byte, Alignment: 1 byte.
				if (TRUE)
				{
					pRadiotapHeader->it_present |= BIT(IEEE80211_RADIOTAP_DBM_ANTSIGNAL);
					// We don't need to worry about that lRSSI value doesn't fit in 8 bits based on practical use.
					*((UCHAR*)pRadiotapHeader + cur) = (UCHAR) pwInfo->lRSSI;
					cur += sizeof(UCHAR) / sizeof(UCHAR);
				}

				// [Radiotap] "MCS" field.
				// Size: 1 byte + 1 byte + 1 byte, Alignment: 1 byte.
				if (pwInfo->uPhyId == dot11_phy_type_ht)
				{
					pRadiotapHeader->it_present |= BIT(IEEE80211_RADIOTAP_MCS);
					RtlZeroMemory((PUCHAR)pRadiotapHeader + cur, 3 * sizeof(UCHAR) / sizeof(UCHAR));
					cur += 3 * sizeof(UCHAR) / sizeof(UCHAR);
				}
				// [Radiotap] "VHT" field, 12 bytes.
				// Size: 2 bytes + 1 byte + 1 byte + 4 * 1 byte + 1 byte + 1 byte + 2 bytes, Alignment: 2 bytes.
				else if (pwInfo->uPhyId == dot11_phy_type_vht)
				{
					// Before putting the VHT field into the packet, because the VHT field has to be aligned on a 2-byte boundary,
					// and the antenna field is on a 2-byte boundary but is only 1 byte long.
					// (The MCS field, however, doesn't have to be aligned on a 2-byte boundary, so you *don't* need to pad anything for HT frames.)
					// cur += sizeof(UCHAR) / sizeof(UCHAR);
					NPF_AlignProtocolField(2, &cur);

					pRadiotapHeader->it_present |= BIT(IEEE80211_RADIOTAP_VHT);
					RtlZeroMemory((PUCHAR)pRadiotapHeader + cur, 12 * sizeof(UCHAR) / sizeof(UCHAR));
					cur += 12 * sizeof(UCHAR) / sizeof(UCHAR);
				}

				pRadiotapHeader->it_version = 0x0;
				pRadiotapHeader->it_len = (USHORT) cur;
			}
		RadiotapDone:;
#endif

		NT_ASSERT(pNBLCopy->NBLCopyEntry.Next == NULL);
		pNBLCopyPrev->Next = &pNBLCopy->NBLCopyEntry;
		pNBLCopyPrev = pNBLCopyPrev->Next;
	}
	return resdropped;
}

//-------------------------------------------------------------------
_When_(AtDispatchLevel != FALSE, _IRQL_requires_(DISPATCH_LEVEL))
BOOLEAN
NPF_TapExForEachOpen(
	_Inout_ POPEN_INSTANCE Open,
	_Inout_ PNPF_CAP_DATA pCapData,
	_In_ BOOLEAN AtDispatchLevel
	);

_Must_inspect_result_
_Success_(return != 0)
BOOLEAN
NPF_CopyFromNetBufferToNBCopy(
	_Inout_ PNPF_SRC_NB pSrcNB
);

_Must_inspect_result_
_Success_(return != NULL)
__drv_allocatesMem(mem)
__declspec(restrict) PNPF_CAP_DATA
NPF_GetCapData(
	_Inout_ PLOOKASIDE_LIST_EX pPool,
	_Inout_ PNPF_NB_COPIES pNBCopy,
	_In_ PNPF_NBL_COPY pNBLCopy,
	_In_range_(1, 0xffffffff) UINT uCapLen
);

VOID
NPF_HandleVlanHeader(
		_Inout_ PNPF_CAP_DATA pCapData,
		_In_ const NPCAP_FILTER_MODULE *pFiltMod
		)
{
	PNPF_NB_COPIES pNBCopy = pCapData->pNBCopy;
	PNPF_SRC_NB pSrcNB = pCapData->pSrcNB;
	const NDIS_NET_BUFFER_LIST_8021Q_INFO *pQinfo = &pNBCopy->pNBLCopy->qInfo;
	// Reasons to quit early:
	if (
		// the adapter doesn't use Ethernet headers
		!pFiltMod->EtherHeader
		// there's less than an Ethernet header captured
		|| pNBCopy->ulSize < ETHER_HDR_LEN
		// there's no VLAN metadata
		|| (pQinfo->Value == 0
			&& !pNBCopy->pNBLCopy->bQinfoPresent)
	   )
	{
		return;
	}
	// The packet has VLAN metadata, so it needs to have a 802.1q header
	// Check if we know it's already there.
	if (!pSrcNB->bVlanHeaderInPacket) {
#define ETHERTYPE_OFFSET FIELD_OFFSET(ETHER_HEADER, ether_type)
		PVLAN_HEADER pVlan = (PVLAN_HEADER)(pNBCopy->Buffer + ETHERTYPE_OFFSET);
		// If it's not already there, add one.
		if (!VLAN_HEADER_VALID(pVlan)) {
			// Shift the packet data down 4 bytes
			RtlMoveMemory(pNBCopy->Buffer + ETHERTYPE_OFFSET + VLAN_HDR_LEN,
					pNBCopy->Buffer + ETHERTYPE_OFFSET,
					pNBCopy->ulSize - ETHERTYPE_OFFSET);
			// Add the VLAN header
			QINFO_TO_VLAN_HEADER(pQinfo, pVlan);

			// Update accounting for the new packet length
			pNBCopy->ulSize += VLAN_HDR_LEN;
			pNBCopy->ulPacketSize += VLAN_HDR_LEN;
			pSrcNB->bVlanHeaderAdded = TRUE;
		}
		// Now we know for sure the header is present.
		pSrcNB->bVlanHeaderInPacket = TRUE;
	}

	// If we added the header ourselves, adjust the capture length.
	if (pSrcNB->bVlanHeaderAdded) {
		pCapData->ulCaplen += VLAN_HDR_LEN;
	}
}

_Use_decl_annotations_
VOID
NPF_DoTap(
	PNPCAP_FILTER_MODULE pFiltMod,
	const PNET_BUFFER_LIST NetBufferLists,
	POPEN_INSTANCE pOpenOriginating,
	BOOLEAN AtDispatchLevel
	)
{
	PSINGLE_LIST_ENTRY Curr;
	LOCK_STATE_EX lockState;
	PNPF_NBL_COPY pNBLCopy = NULL;
	SINGLE_LIST_ENTRY NBLCopiesHead = { 0 };
	NBLCopiesHead.Next = NULL;
	PNPF_SRC_NB pSrcNB = NULL;
	PLIST_ENTRY CurrFilter;
	PNPF_CAP_DATA pCaptures = NULL;

	/* Get relevant timestamps */
	if (pFiltMod->BpfCount == 0)
	{
		// No instances at OpenRunning
		return;
	}

	/* If we got this far, there is at least 1 instance at OpenRunning,
	 * so gather metadata before locking the list. */
	ULONG resdropped = NPF_GetMetadata(NetBufferLists, &NBLCopiesHead, pFiltMod);
	BOOLEAN firstpass = resdropped > 0;
	/* Lock the filter programs */
	// Read-only lock since list is not being modified.
	NdisAcquireRWLockRead(pFiltMod->BpfProgramsLock, &lockState,
			AtDispatchLevel ? NDIS_RWL_AT_DISPATCH_LEVEL : 0);

	if (NBLCopiesHead.Next == NULL) {
		// No packets, all resdropped!
		// Have to deal with this here, since otherwise the next loop won't be entered.
		for (CurrFilter = pFiltMod->BpfPrograms.Flink; CurrFilter != &pFiltMod->BpfPrograms; CurrFilter = CurrFilter->Flink)
		{
			PNPCAP_BPF_PROGRAM pBpf = CONTAINING_RECORD(CurrFilter, NPCAP_BPF_PROGRAM, BpfProgramsEntry);
			POPEN_INSTANCE pOpen = pBpf->pOpen;
			if (!NT_VERIFY(pOpen != NULL)) {
				continue;
			}
			// If this instance originated the packet and doesn't want to see it, don't capture.
			if (pOpen == pOpenOriginating && pOpen->SkipSentPackets)
			{
				continue;
			}
			// Account for packets lost due to inadequate resources earlier
			NpfInterlockedExchangeAdd(&(LONG)pOpen->ResourceDropped, resdropped);
		}
		NdisReleaseRWLock(pFiltMod->BpfProgramsLock, &lockState);
		return;
	}

	PNPF_CAP_DATA pCapPrev = pCaptures;
	for (Curr = NBLCopiesHead.Next; Curr != NULL; Curr = Curr->Next)
	{
		pNBLCopy = CONTAINING_RECORD(Curr, NPF_NBL_COPY, NBLCopyEntry);
		PSINGLE_LIST_ENTRY CurrSrcNB = pNBLCopy->NBCopiesHead.Next;
		for (; CurrSrcNB != NULL; CurrSrcNB = CurrSrcNB->Next)
		{
			pSrcNB = CONTAINING_RECORD(CurrSrcNB, NPF_SRC_NB, CopiesEntry);
			ULONG maxFres = 0;
			for (CurrFilter = pFiltMod->BpfPrograms.Flink; CurrFilter != &pFiltMod->BpfPrograms; CurrFilter = CurrFilter->Flink)
			{
				PNPCAP_BPF_PROGRAM pBpf = CONTAINING_RECORD(CurrFilter, NPCAP_BPF_PROGRAM, BpfProgramsEntry);
				POPEN_INSTANCE pOpen = pBpf->pOpen;
				// If this instance originated the packet and doesn't want to see it, don't capture.
				if (pOpen == pOpenOriginating && pOpen->SkipSentPackets)
				{
					continue;
				}
				if (firstpass)
				{
					// Account for packets lost due to inadequate resources earlier
					NpfInterlockedExchangeAdd(&(LONG)pOpen->ResourceDropped, resdropped);
				}

				ULONG TotalPacketSize = pSrcNB->pNBCopy->ulPacketSize;
				UINT fres = bpf_filter(pBpf->bpf_program, pBpf->nInsns, pSrcNB->pNetBuffer, pNBLCopy);
				if (fres == 0)
				{
					// Packet not accepted by the filter, ignore it.
					continue;
				}
				// We have a packet to record. OpenDetached is the highest needed level here.
				if (!NPF_StartUsingOpenInstance(pOpen, OpenDetached, TRUE))
				{
					continue;
				}

				NpfInterlockedIncrement(&(LONG)pOpen->Received);

				//if the filter returns -1 the whole packet must be accepted
				if (fres > TotalPacketSize || fres == -1)
					fres = TotalPacketSize;

				if (fres > maxFres)
					maxFres = fres;

				PNPF_CAP_DATA pCapData = NPF_GetCapData(&g_pDriverExtension->CapturePool, pSrcNB->pNBCopy, pNBLCopy, fres);
				if (pCapData == NULL)
				{
					// Insufficient memory
					// Don't free pNBCopy; that's done later
					NpfInterlockedIncrement(&(LONG)pOpen->ResourceDropped);
					NPF_StopUsingOpenInstance(pOpen, OpenDetached, TRUE);
					continue;
				}

				// Stash this cap data to process later
				if (pCaptures == NULL)
				{
					pCaptures = pCapData;
				}
				else
				{
					pCapPrev->Next = pCapData;
				}
				pCapData->pOpen = pOpen;
				pCapData->pSrcNB = pSrcNB;
				pCapData->Next = NULL;
				pCapPrev = pCapData;
			}
			// Copy maxFres of data from the packet
			pSrcNB->ulDesired = maxFres;
			firstpass = FALSE;
		}
	}
	/* Release the spin lock no matter what. */
	NdisReleaseRWLock(pFiltMod->BpfProgramsLock, &lockState);

	// Now go through all the captures and dispatch them.
	PNPF_CAP_DATA pCapData = NULL;
	while (NULL != (pCapData = pCaptures)) {
		pCaptures = pCapData->Next;
		if (pCapData->pNBCopy->ulSize < pCapData->pSrcNB->ulDesired)
		{
			// The data hasn't been copied yet
			if (!NPF_CopyFromNetBufferToNBCopy(pCapData->pSrcNB))
			{
				// Failed to copy. Drop it!
				NpfInterlockedIncrement(&(LONG)pCapData->pOpen->ResourceDropped);
				NPF_ReturnCapData(pCapData);
				continue;
			}
		}

		// Deal with VLAN header if needed
		NPF_HandleVlanHeader(pCapData, pFiltMod);

		// Have to cache this value; it may be overwritten by NPF_TapExForEachOpen.
		POPEN_INSTANCE pOpen = pCapData->pOpen;
		BOOLEAN accepted = NPF_TapExForEachOpen(pOpen, pCapData, AtDispatchLevel);
		NPF_StopUsingOpenInstance(pOpen, OpenDetached, AtDispatchLevel);
		if (!accepted)
		{
			// Didn't accept it. Clean up!
			NPF_ReturnCapData(pCapData);
		}
	}

	// Now release/return the copies
	Curr = NBLCopiesHead.Next;
	while (Curr != NULL)
	{
		pNBLCopy = CONTAINING_RECORD(Curr, NPF_NBL_COPY, NBLCopyEntry); 
		Curr = Curr->Next;

		PSINGLE_LIST_ENTRY pNBCopiesEntry = pNBLCopy->NBCopiesHead.Next;
		while (pNBCopiesEntry != NULL)
		{
			pSrcNB = CONTAINING_RECORD(pNBCopiesEntry, NPF_SRC_NB, CopiesEntry);
			pNBCopiesEntry = pNBCopiesEntry->Next;

			if (pSrcNB->pNBCopy)
			{
				NPF_ReturnNBCopies(pSrcNB->pNBCopy);
			}
			ExFreeToLookasideListEx(&g_pDriverExtension->SrcNBPool, pSrcNB);
		}

		NPF_ReturnNBLCopy(pNBLCopy);
	}

	return;
}

#define EMA_SCALE 24
#define ALPHA_SHORT_TERM (1677722) // 0.1 * 2^24
#define ONE_MINUS_ALPHA_SHORT_TERM (15100100) // 0.9 * 2^24

#define ALPHA_LONG_TERM (16) // 0.000001 * 2^24
#define ONE_MINUS_ALPHA_LONG_TERM (16777199) // 0.999999 * 2^24

static VOID CalculateEMA(_Inout_updates_(2) PUSHORT pStat, _In_ LARGE_INTEGER value)
{
	USHORT capped = MAXUSHORT;
	if (value.QuadPart < MAXUSHORT) {
		capped = (USHORT)value.QuadPart;
	}

	if (pStat[0] == 0) {
		// Initialize both short-term and long-term averages
		pStat[0] = capped;
		pStat[1] = capped;
	}
	else {
		// Short-term EMA calculation using scaled integers
		LONGLONG tempAvg0 = (LONGLONG)capped * ALPHA_SHORT_TERM + (LONGLONG)pStat[0] * ONE_MINUS_ALPHA_SHORT_TERM;
		pStat[0] = (USHORT)(tempAvg0 >> EMA_SCALE);

		// Long-term EMA calculation using scaled integers
		LONGLONG tempAvg1 = (LONGLONG)capped * ALPHA_LONG_TERM + (LONGLONG)pStat[1] * ONE_MINUS_ALPHA_LONG_TERM;
		pStat[1] = (USHORT)(tempAvg1 >> EMA_SCALE);
	}
}

_Use_decl_annotations_
VOID
NPF_SendEx(
	NDIS_HANDLE         FilterModuleContext,
	PNET_BUFFER_LIST    NetBufferLists,
	NDIS_PORT_NUMBER    PortNumber,
	ULONG               SendFlags
	)
{
	PNPCAP_FILTER_MODULE pFiltMod = (PNPCAP_FILTER_MODULE) FilterModuleContext;
	LARGE_INTEGER PTime = KeQueryPerformanceCounter(NULL);
	BOOLEAN bAtDispatchLevel = NDIS_TEST_SEND_AT_DISPATCH_LEVEL(SendFlags);


	TRACE_ENTER();

	if (pFiltMod->OpsState == OpsEnabled
#ifdef HAVE_WFP_LOOPBACK_SUPPORT
		&& NT_VERIFY(!pFiltMod->Loopback)
#endif
	   )
	{
		NPF_DoTap(pFiltMod, NetBufferLists, NULL, bAtDispatchLevel);
	}

	NdisFSendNetBufferLists(pFiltMod->AdapterHandle, NetBufferLists, PortNumber, SendFlags);

	LARGE_INTEGER EndTime = KeQueryPerformanceCounter(NULL);
	PTime.QuadPart = EndTime.QuadPart - PTime.QuadPart;
	CalculateEMA(pFiltMod->TimeInSend, PTime);
	if (bAtDispatchLevel) {
		CalculateEMA(pFiltMod->TimeAtDPC, PTime);
	}
	TRACE_EXIT();
}

//-------------------------------------------------------------------

_Use_decl_annotations_
VOID
NPF_TapEx(
	NDIS_HANDLE         FilterModuleContext,
	PNET_BUFFER_LIST    NetBufferLists,
	NDIS_PORT_NUMBER    PortNumber,
	ULONG               NumberOfNetBufferLists,
	ULONG               ReceiveFlags
	)
{

	PNPCAP_FILTER_MODULE pFiltMod = (PNPCAP_FILTER_MODULE) FilterModuleContext;
	BOOLEAN bAtDispatchLevel = NDIS_TEST_RECEIVE_AT_DISPATCH_LEVEL(ReceiveFlags);
	LARGE_INTEGER PTime = KeQueryPerformanceCounter(NULL);

	TRACE_ENTER();

	UNREFERENCED_PARAMETER(PortNumber);

	if (pFiltMod->OpsState == OpsEnabled
		// If this is a Npcap-sent packet being looped back, then it has already been captured.
#ifdef HAVE_WFP_LOOPBACK_SUPPORT
		&& NT_VERIFY(!pFiltMod->Loopback)
#endif
		&& !(NdisTestNblFlag(NetBufferLists, NDIS_NBL_FLAGS_IS_LOOPBACK_PACKET)
			&& NetBufferLists->SourceHandle == pFiltMod->AdapterHandle)

	   )
	{
		NPF_DoTap(pFiltMod, NetBufferLists, NULL, NDIS_TEST_RECEIVE_AT_DISPATCH_LEVEL(ReceiveFlags));
	}

	/* NdisFIndicateReceiveNetBufferLists only if not BlockRxPath
	 *			|CAN_PEND	|CANNOT_PEND
	 * BlockRxPath yes	|no		| no
	 * BlockRxPath no	|yes		| yes
	 */
#ifdef HAVE_RX_SUPPORT
	if (!pFiltMod->BlockRxPath)
	{
#endif
		NdisFIndicateReceiveNetBufferLists(
			pFiltMod->AdapterHandle,
			NetBufferLists,
			PortNumber,
			NumberOfNetBufferLists,
			ReceiveFlags);
		// No need to call CleanupNBLs/NPF_FreePackets because we're
		// just passing this indication along.


#ifdef HAVE_RX_SUPPORT
	}
	/* NdisFReturnNetBufferLists can only be called if NDIS_TEST_RECEIVE_CAN_PEND
	 *			|CAN_PEND	|CANNOT_PEND
	 * BlockRxPath yes	|yes		| no
	 * BlockRxPath no	|no		| no
	 */
	else if (NDIS_TEST_RECEIVE_CAN_PEND(ReceiveFlags))
	{
		// no NDIS_RECEIVE_FLAGS_RESOURCES in ReceiveFlags
		NdisFReturnNetBufferLists(
				pFiltMod->AdapterHandle,
				NetBufferLists,
				bAtDispatchLevel ? NDIS_RETURN_FLAGS_DISPATCH_LEVEL : 0);
	}
#endif
	LARGE_INTEGER EndTime = KeQueryPerformanceCounter(NULL);
	PTime.QuadPart = EndTime.QuadPart - PTime.QuadPart;
	CalculateEMA(pFiltMod->TimeInRecv, PTime);
	if (bAtDispatchLevel) {
		CalculateEMA(pFiltMod->TimeAtDPC, PTime);
	}

	TRACE_EXIT();
}


//-------------------------------------------------------------------

_Use_decl_annotations_
PNPF_CAP_DATA NPF_GetCapData(
		PLOOKASIDE_LIST_EX pPool,
		PNPF_NB_COPIES pNBCopy,
		PNPF_NBL_COPY pNBLCopy,
		UINT uCapLen
		)
{
	NT_ASSERT(pNBLCopy);
	NT_ASSERT(pNBCopy->pNBLCopy == pNBLCopy);
	NT_ASSERT(pNBCopy->ulPacketSize < 0xffffffff);

	PNPF_CAP_DATA pCapData = (PNPF_CAP_DATA) ExAllocateFromLookasideListEx(pPool);
	if (pCapData == NULL)
	{
		return NULL;
	}
	RtlZeroMemory(pCapData, sizeof(NPF_CAP_DATA));

	// Increment refcounts on relevant structures
	pCapData->pNBCopy = pNBCopy;
	NpfInterlockedIncrement(&pNBCopy->refcount);
	NpfInterlockedIncrement(&pNBLCopy->refcount);

	pCapData->ulCaplen = uCapLen;

	return pCapData;
}

_Use_decl_annotations_
BOOLEAN
NPF_CopyFromNetBufferToNBCopy(
		PNPF_SRC_NB pSrcNB
		)
{
	PVOID pSrcBuf = NULL;
	ULONG ulDesired = pSrcNB->ulDesired;

	PNPF_NB_COPIES pNBCopy = pSrcNB->pNBCopy;

	// pNBCopy must be set up correctly
	NT_ASSERT(pNBCopy->ulSize == 0);
	NT_ASSERT(pNBCopy->Buffer == NULL);
	NT_ASSERT(ulDesired > 0);
	NT_ASSERT(ulDesired <= NET_BUFFER_DATA_LENGTH(pSrcNB->pNetBuffer));

	// Allocate enough space to add the VLAN header if necessary
	pNBCopy->Buffer = NPF_AllocateZeroNonpaged((SIZE_T)ulDesired + VLAN_HDR_LEN, NPF_PACKET_DATA_TAG);
	if (pNBCopy->Buffer == NULL)
	{
		INFO_DBG("Failed to allocate Buffer\n");
		return FALSE;
	}

	// Map or copy a contiguous buffer
	pSrcBuf = NdisGetDataBuffer(pSrcNB->pNetBuffer, ulDesired, pNBCopy->Buffer, 1, 0);
	if (pSrcBuf == NULL)
	{
		INFO_DBG("Failed to map NET_BUFFER\n");
		ExFreePoolWithTag(pNBCopy->Buffer, NPF_PACKET_DATA_TAG);
		pNBCopy->Buffer = NULL;
		return FALSE;
	}
	else if (pSrcBuf != pNBCopy->Buffer)
	{
		// Data was contiguous; we are responsible for copying it
		RtlCopyMemory(pNBCopy->Buffer, pSrcBuf, ulDesired);
	}

	pNBCopy->ulSize = ulDesired;
	return TRUE;
}

_Use_decl_annotations_
BOOLEAN
NPF_TapExForEachOpen(
	POPEN_INSTANCE Open,
	PNPF_CAP_DATA pCapData,
	BOOLEAN AtDispatchLevel
)
{
	LOCK_STATE_EX lockState;

	PNPF_NB_COPIES pNBCopy = pCapData->pNBCopy;
	PNPF_NBL_COPY pNBLCopy = pNBCopy->pNBLCopy;
	ULONG TotalPacketSize = pNBCopy->ulPacketSize;
	BOOLEAN bEnqueued = FALSE;

	if (!Open->bModeCapt)
	{
		// we are in statistics mode
		FILTER_ACQUIRE_LOCK(&Open->CountersLock, AtDispatchLevel);

		Open->Npackets.QuadPart++;

		if (TotalPacketSize < 60)
			Open->Nbytes.QuadPart += 60;
		else
			Open->Nbytes.QuadPart += TotalPacketSize;
		// add preamble+SFD+FCS to the packet
		// these values must be considered because are not part of the packet received from NDIS
		Open->Nbytes.QuadPart += 12;

		FILTER_RELEASE_LOCK(&Open->CountersLock, AtDispatchLevel);

		return FALSE;
	}

	// Special case: zero-length buffer or negative free space can be checked without locking buffer
	if (Open->Size <= 0)
	{
		NpfInterlockedIncrement(&(LONG)Open->Dropped);
		return FALSE;
	}

	// Special case: negative free space can be checked without locking buffer
	if (Open->Free <= 0)
	{
		NpfInterlockedIncrement(&(LONG)Open->Dropped);
		// Wake the application
		if (Open->ReadEvent != NULL)
			KeSetEvent(Open->ReadEvent, 0, FALSE);
		return FALSE;
	}

	LONG lCapSize = NPF_CAP_OBJ_SIZE(pCapData);
	NT_ASSERT(lCapSize > 0);
	if (lCapSize < 0)
	{
		// Overflow; this is an impossibly large packet
		NpfInterlockedIncrement(&(LONG)Open->Dropped);
		return FALSE;
	}

	// Lock "buffer" whenever checking Size/Free
	NdisAcquireRWLockRead(Open->BufferLock, &lockState,
			AtDispatchLevel ? NDIS_RWL_AT_DISPATCH_LEVEL : 0);
	do {
		// Subtract capture size from Free; if it's less than 0, we didn't have enough space.
		if (0 > NpfInterlockedExchangeAdd(&Open->Free, -lCapSize))
		{
			NpfInterlockedIncrement(&(LONG)Open->Dropped);
			INFO_DBG("Dropped++, lCapSize = %ld, Open->Free = %d\n", lCapSize, Open->Free);
			// May as well tell the application, even if MinToCopy is not met,
			// to avoid dropping further packets
			if (Open->ReadEvent != NULL)
				KeSetEvent(Open->ReadEvent, 0, FALSE);

			break;
		}

		/* Any NPF_CAP_DATA in the queue must be initialized and point to valid data. */
		NT_ASSERT(pCapData->pNBCopy);
		NT_ASSERT(pCapData->pNBCopy->pNBLCopy);
		/* This should never happen, but has happened due to
		 * bugs in NPF_CopyFromNetBufferToNBCopy. Handle the
		 * consequences here, but bail if we're debugging
		 * because this is a big deal. */
		if (!NT_VERIFY(NPF_CAP_OBJ_SIZE(pCapData) == lCapSize))
		{
			// Add the difference back, otherwise we never recover it.
			NpfInterlockedExchangeAdd(&Open->Free, lCapSize - NPF_CAP_OBJ_SIZE(pCapData));
		}
		// Great, it passed! Make sure we have a timestamp.
		if (Open->TimestampMode == TIMESTAMPMODE_SINGLE_SYNCHRONIZATION) {
			if (pNBLCopy->PerfCount.QuadPart == 0) {
				pNBLCopy->PerfCount = KeQueryPerformanceCounter(NULL);
			}
		}
		else if (pNBLCopy->SystemTime.QuadPart == 0) {
			if (Open->TimestampMode == TIMESTAMPMODE_QUERYSYSTEMTIME_PRECISE
					|| Open->pFiltMod->nTimestampQST_Precise > 0) {
				BestQuerySystemTime(&pNBLCopy->SystemTime);
			}
			else {
				KeQuerySystemTime(&pNBLCopy->SystemTime);
			}
		}
		ExInterlockedInsertTailList(&Open->PacketQueue, &pCapData->PacketQueueEntry, &Open->PacketQueueLock);
		// We successfully put this into the queue
		bEnqueued = TRUE;
		lCapSize = 0;
		NpfInterlockedIncrement(&(LONG)Open->Accepted);

		if (Open->Size - Open->Free >= (LONG) Open->MinToCopy
				&& Open->ReadEvent != NULL)
		{
			KeSetEvent(Open->ReadEvent, 0, FALSE);
		}

	} while (0);
	if (!bEnqueued && lCapSize > 0)
	{
		// something went wrong and we didn't enqueue this, so reverse it.
		NpfInterlockedExchangeAdd(&Open->Free, lCapSize);
	}
	NdisReleaseRWLock(Open->BufferLock, &lockState);

	return bEnqueued;
	//TRACE_EXIT();
}

```

`packetWin7/npf/npf/Write.c`:

```c
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
/*
 * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)
 * Copyright (c) 2005 - 2010 CACE Technologies, Davis (California)
 * Copyright (c) 2010 - 2013 Riverbed Technology, San Francisco (California), Yang Luo (China)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Politecnico di Torino, CACE Technologies 
 * nor the names of its contributors may be used to endorse or promote 
 * products derived from this software without specific prior written 
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include "stdafx.h"

#include "Packet.h"
#include <fwpsk.h>

extern PNPCAP_DRIVER_EXTENSION g_pDriverExtension;

typedef struct {
	PVOID DriverContext[4];
} IRP_TAIL_OVERLAY;

typedef struct {
	ULONG ulRefcount;
} WRITE_IRP_CONTEXT, *PWRITE_IRP_CONTEXT;

C_ASSERT(sizeof(WRITE_IRP_CONTEXT) <= sizeof(IRP_TAIL_OVERLAY));

#define GET_WRITE_IRP_CONTEXT(_Irp) ((PWRITE_IRP_CONTEXT)_Irp->Tail.Overlay.DriverContext)

#ifdef HAVE_WFP_LOOPBACK_SUPPORT
/*!
  \brief Send a loopback NBL.
  \param NetBufferList Pointer to NBL.

  Alternative to NdisFSendNetBufferLists, use the same NBL parameter, but it calls Winsock Kernel to send packet instead
  of NDIS functions.
*/
_At_(NetBufferList, __drv_aliasesMem)
NTSTATUS
NPF_LoopbackSendNetBufferLists(
	_In_ POPEN_INSTANCE pOpen,
	_In_ PNET_BUFFER_LIST NetBufferList
	);

#endif

inline
__drv_allocatesMem(mem)
PVOID
#pragma warning(suppress: 28195) // We aren't really allocating it here, but we know that it was allocated in some other un-annotated function.
NPF_AnalysisAssumeAllocated(_In_ PVOID *p)
{
	return *p;
}

static USHORT NPF_GetIPVersion(
		_In_ PNPCAP_FILTER_MODULE pFiltMod,
		_In_reads_(buflen) PUCHAR pBuf,
		_In_ ULONG buflen);

_Must_inspect_result_
_Success_(return != NULL)
PMDL
NPF_BufferToMdl(
	_In_ PNPCAP_FILTER_MODULE pFiltMod,
	_In_reads_(ulLen) PUCHAR pBuf,
	_In_ ULONG ulLen,
	_In_opt_ PMDL pMdlOrig,
	_Out_ PULONG pPktlen,
	_Out_ PNDIS_NET_BUFFER_LIST_8021Q_INFO pQinfo,
	_Out_ PUSHORT pEthType,
	_Out_ PBOOLEAN pbFreeBuf
	)
{
	BOOLEAN bSuccess = FALSE;
	PMDL TmpMdl = NULL;
	ULONG ulPktlen = ulLen;
	ULONG ulRemainder = ulLen;
	PUCHAR pEthHdr = NULL;
	PUCHAR pVA = pMdlOrig ? MmGetMdlVirtualAddress(pMdlOrig) : pBuf;

	*pPktlen = ulLen;
	pQinfo->Value = 0;
	*pEthType = NPF_GetIPVersion(pFiltMod, pBuf, ulLen);
	*pbFreeBuf = FALSE;

	do {
		// Check for VLAN header. If it's there, we'll strip it and end up
		// with Ethernet header in one MDL and payload in the next one.
		if (pFiltMod->EtherHeader
				&& ulLen >= (ETHER_HDR_LEN + VLAN_HDR_LEN)
				&& *pEthType == 0x8100) {
			PETHER_VLAN_HEADER pHeader = (PETHER_VLAN_HEADER) pBuf;
			// Turn it into NDIS metadata
			VLAN_HEADER_TO_QINFO(&pHeader->vlan, pQinfo);

			// Strip the tag:
			// 1. Copy the Ethernet header with inner EtherType to a new buffer.
			pEthHdr = NPF_AllocateZeroNonpaged(ETHER_HDR_LEN, NPF_BUFFERED_WRITE_TAG);
			if (pEthHdr == NULL) {
				break;
			}

			TmpMdl = IoAllocateMdl(pEthHdr, ETHER_HDR_LEN, FALSE, FALSE, NULL);
			if (TmpMdl == NULL) {
				break;
			}
			MmBuildMdlForNonPagedPool(TmpMdl);

			RtlCopyMemory(pEthHdr, pBuf, ETHER_ADDR_LEN * 2);
			((PETHER_HEADER)pEthHdr)->ether_type = pHeader->ether_type;

			// 2. Map the remainder of the packet to a new MDL
			ulPktlen -= VLAN_HDR_LEN;
			pVA += sizeof(ETHER_VLAN_HEADER);
			ulRemainder -= sizeof(ETHER_VLAN_HEADER);

			// 3. Get the new, real EthType
			*pEthType = RtlUshortByteSwap(pHeader->ether_type);
		}
		else if (pFiltMod->SplitMdls && ulLen > ETHER_HDR_LEN) {
			// As a workaround for a bug in bthpan.sys, we need to define
			// separate MDLs for the Eth header and payload. See #708
			TmpMdl = IoAllocateMdl(pVA, ETHER_HDR_LEN, FALSE, FALSE, NULL);
			if (TmpMdl == NULL)
			{
				break;
			}
			if (pMdlOrig == NULL) {
				MmBuildMdlForNonPagedPool(TmpMdl);
			}
			else {
				IoBuildPartialMdl(pMdlOrig, TmpMdl, pVA, ETHER_HDR_LEN);
			}

			pVA += ETHER_HDR_LEN;
			ulRemainder -= ETHER_HDR_LEN;
		}

		// In both these cases we need to make a new MDL:
		if (TmpMdl || pMdlOrig == NULL) {
			PMDL NewMdl = IoAllocateMdl(pVA, ulRemainder,
					FALSE, FALSE, NULL);
			if (NewMdl == NULL)
			{
				break;
			}

			if (pMdlOrig == NULL) {
				// Easy case: just make a new MDL for the remainder of the buffer
				MmBuildMdlForNonPagedPool(NewMdl);
				if (TmpMdl) {
					TmpMdl->Next = NewMdl;
				}
				else {
					TmpMdl = NewMdl;
				}
			}
			else {
				// Make the remainder a partial MDL. The caller will be
				// responsible for freeing the original one.
				IoBuildPartialMdl(pMdlOrig, NewMdl,
						pVA, ulRemainder);
				TmpMdl->Next = NewMdl;
			}
		}
		else {
			// Nothing special to be done.
			// Return the original MDL
			TmpMdl = pMdlOrig;
		}
		bSuccess = TRUE;
	} while (FALSE);
	if (!bSuccess) {
		if (TmpMdl) {
			IoFreeMdl(TmpMdl);
		}
		if (pEthHdr) {
			ExFreePoolWithTag(pEthHdr, NPF_BUFFERED_WRITE_TAG);
		}
		return NULL;
	}

	*pbFreeBuf = (pEthHdr != NULL);
	*pPktlen = ulPktlen;
	NT_ASSERT(TmpMdl != NULL);
	// Since we don't append new data to the end of the MDL chain, any
	// allocated buffer must be prepended to the chain. Therefore we can't
	// have allocated a new buffer and also return the original MDL.
	NT_ASSERT(!(TmpMdl == pMdlOrig && *pbFreeBuf));
	return TmpMdl;
}

// Frees an entire chain of MDLs and optionally the buffer mapped by the first of them.
VOID
NPF_FreeMdlAndBuffer(_In_ __drv_freesMem(mem) PMDL pMdl, _In_ BOOLEAN FreeBuf)
{
	PMDL pNext = NULL;
	if (FreeBuf)
	{
		PVOID npBuff = MmGetSystemAddressForMdlSafe(pMdl, HighPagePriority|MdlMappingNoExecute);
		if (npBuff != NULL) {
			ExFreePoolWithTag(npBuff, NPF_BUFFERED_WRITE_TAG);
		}
	}
	while (pMdl != NULL) {
		pNext = pMdl->Next;
		IoFreeMdl(pMdl); //Free MDL
		pMdl = pNext;
	}
}

NTSTATUS
_At_(*ppNBL, __drv_allocatesMem(mem))
NPF_AllocateNBL(
	_In_ PNPCAP_FILTER_MODULE pFiltMod,
	_In_ __drv_aliasesMem PMDL pMdl,
	_In_ SIZE_T uDataLen,
	_Outptr_result_nullonfailure_ PNET_BUFFER_LIST *ppNBL
       )
{
	NTSTATUS Status = STATUS_SUCCESS;
#ifdef HAVE_WFP_LOOPBACK_SUPPORT
	if (pFiltMod->Loopback)
	{
		Status = FwpsAllocateNetBufferAndNetBufferList(pFiltMod->PacketPool,
			sizeof(PACKET_RESERVED),
			0,
			pMdl,
			0,
			uDataLen,
			ppNBL);
		if (NT_SUCCESS(Status) && *ppNBL)
		{
			// WORKAROUND: We are calling NPF_AnalysisAssumeAliased here because the annotations for
			// FwpsAllocateNetBufferAndNetBufferList do not use __drv_aliasesMem for the 4th parameter,
			// even though it is just a wrapper for NdisAllocateNetBufferAndNetBufferList, which does alias the MDL.
			NPF_AnalysisAssumeAliased(pMdl);
			// WORKAROUND: FwpsAllocateNetBufferAndNetBufferList also does not have annotations for
			// allocating the NBL. This fake function will suppress the warning about it.
			*ppNBL = NPF_AnalysisAssumeAllocated(ppNBL);
			(*ppNBL)->ChildRefCount = 0;
		}
		else
		{
			// Can't indicate success if it didn't actually succeed.
			Status = NT_SUCCESS(Status) ? STATUS_INSUFFICIENT_RESOURCES : Status;
			*ppNBL = NULL;
		}
	}
	else
#endif
	{
		*ppNBL = NdisAllocateNetBufferAndNetBufferList(pFiltMod->PacketPool,
			sizeof(PACKET_RESERVED),
			0,
			pMdl,
			0,
			uDataLen);
		if (*ppNBL) {
			Status = STATUS_SUCCESS;
			(*ppNBL)->ChildRefCount = 0;
		}
		else {
			Status = STATUS_INSUFFICIENT_RESOURCES;
		}
	}
	if (*ppNBL
		&& !NT_VERIFY(RESERVED(*ppNBL) != NULL
		&& NET_BUFFER_LIST_CONTEXT_DATA_SIZE(*ppNBL) >= sizeof(PACKET_RESERVED)))
	{
		NPF_FreePackets(pFiltMod, *ppNBL, NPF_IRQL_UNKNOWN);
		*ppNBL = NULL;
		Status = STATUS_FAIL_CHECK;
	}
	return Status;
}
//-------------------------------------------------------------------

_Use_decl_annotations_
static USHORT NPF_GetIPVersion(
		PNPCAP_FILTER_MODULE pFiltMod,
		PUCHAR pBuf,
		ULONG buflen)
{
	if (pFiltMod->EtherHeader)
	{
		if (buflen < sizeof(ETHER_HEADER))
			return 0;
		return RtlUshortByteSwap(((PETHER_HEADER)pBuf)->ether_type);
	}
	else if (pFiltMod->RawIP)
	{
		if (buflen < 1)
			return 0;
		switch (*(PUCHAR)pBuf & 0xf0)
		{
			case 0x40:
				return ETHERTYPE_IP;
			case 0x60:
				return ETHERTYPE_IPV6;
		}
	}
	else if (pFiltMod->Loopback && g_pDriverExtension->bDltNullMode)
	{
		if (buflen < sizeof(DLT_NULL_HEADER))
			return 0;
		switch(((PDLT_NULL_HEADER)pBuf)->null_type)
		{
			case DLTNULLTYPE_IP:
				return ETHERTYPE_IP;
			case DLTNULLTYPE_IPV6:
				return ETHERTYPE_IPV6;
		}
	}

	// Unknown/unhandled DLT or packet type
	return 0;
}

_Use_decl_annotations_
NTSTATUS
NPF_Write(
	PDEVICE_OBJECT DeviceObject,
	PIRP Irp
	)
{
	POPEN_INSTANCE		Open;
	ULONG				SendFlags = 0;
	PNET_BUFFER_LIST	pNetBufferList = NULL;
	ULONG				NumSends;
	ULONG buflen = 0;
	PVOID pBuf = NULL;
	NTSTATUS Status = STATUS_SUCCESS;
	PMDL TmpMdl = NULL;
	PWRITE_IRP_CONTEXT pContext = GET_WRITE_IRP_CONTEXT(Irp);
	BOOLEAN IrpWasPended = FALSE;
	BOOLEAN bCompleteIrp = TRUE;
	BOOLEAN bFreeBuf = FALSE;
	BOOLEAN bFreeMdl = FALSE;

	UNREFERENCED_PARAMETER(DeviceObject);
	TRACE_ENTER();

	/* Validate */
	Status = NPF_ValidateIoIrp(Irp, &Open, &pBuf, &buflen);
	if (Status != STATUS_SUCCESS)
	{
		Open = NULL;
		goto NPF_Write_End;
	}

	if (!NPF_StartUsingOpenInstance(Open, OpenRunning, NPF_IRQL_UNKNOWN))
	{
		// Write requires an attached adapter.
		Status = (Open->OpenStatus <= OpenDetached
					? STATUS_DEVICE_REMOVED
					: STATUS_CANCELLED);
		Open = NULL;
		goto NPF_Write_End;
	}

	// Failures after this point must call NPF_StopUsingOpenInstance
	NumSends = Open->Nwrites;
	if (NumSends == 0)
	{
		Status = STATUS_SUCCESS;
		goto NPF_Write_End;
	}

	if (buflen == 0)
	{
		Status = STATUS_INVALID_PARAMETER;
		goto NPF_Write_End;
	}

	// Check that the MaxFrameSize is correctly initialized
	if (Open->pFiltMod->MaxFrameSize == 0)
	{
		// TODO: better status code
		Status = STATUS_UNSUCCESSFUL;
		goto NPF_Write_End;
	}

	INFO_DBG(
		"Max frame size = %u, packet size = %u",
		Open->pFiltMod->MaxFrameSize,
		buflen);

	// WinPcap emulation: loop back injected packets if anyone's listening.
	// Except when NPF_DISABLE_LOOPBACK is chosen, then don't loop back.
	if (!Open->SkipSentPackets)
	{
		SendFlags |= NDIS_SEND_FLAGS_CHECK_FOR_LOOPBACK;
	}

	USHORT EthType = 0;
	NDIS_NET_BUFFER_LIST_8021Q_INFO Qinfo;
	ULONG pktlen = 0;
	TmpMdl = NPF_BufferToMdl(Open->pFiltMod, pBuf, buflen, Irp->MdlAddress,
			&pktlen, &Qinfo, &EthType, &bFreeBuf);
	if (TmpMdl == NULL) {
		Status = STATUS_INSUFFICIENT_RESOURCES;
		goto NPF_Write_End;
	}
	if (TmpMdl != Irp->MdlAddress) {
		bFreeMdl = TRUE;
	}

	// If bFreeBuf, then also bFreeMdl.
	NT_ASSERT_ASSUME(bFreeMdl || !bFreeBuf);

	// Check that the frame size is smaller than the MTU
	if (pktlen > Open->pFiltMod->MaxFrameSize)
	{
		Status = NDIS_STATUS_INVALID_LENGTH;
		goto NPF_Write_End;
	}

	pContext->ulRefcount = NumSends;

	// Pend the IRP
	IoMarkIrpPending(Irp);
	IrpWasPended = TRUE;
	// Now we shouldn't complete the IRP unless we're the one to decrement
	// ulRefcount to 0.
	bCompleteIrp = FALSE;

	while (NumSends > 0)
	{
		Status = NPF_AllocateNBL(Open->pFiltMod,
				TmpMdl,
				pktlen,
				&pNetBufferList);

		if (!NT_SUCCESS(Status))
		{
			// Alloc failure, abandon ship
			break;
		}
		NT_ASSERT(RESERVED(pNetBufferList) != NULL);
		NT_ASSERT(NET_BUFFER_LIST_CONTEXT_DATA_SIZE(pNetBufferList) >= sizeof(PACKET_RESERVED));

		// Mark packet as necessary
		if (EthType == ETHERTYPE_IP)
		{
			NdisSetNblFlag(pNetBufferList, NDIS_NBL_FLAGS_IS_IPV4);
		}
		else if (EthType == ETHERTYPE_IPV6)
		{
			NdisSetNblFlag(pNetBufferList, NDIS_NBL_FLAGS_IS_IPV6);
		}
		NET_BUFFER_LIST_INFO(pNetBufferList, NetBufferListFrameType) = (PVOID)RtlUshortByteSwap(EthType);
		NET_BUFFER_LIST_INFO(pNetBufferList, Ieee8021QNetBufferListInfo) = Qinfo.Value;

		RESERVED(pNetBufferList)->pIrp = Irp;
		RESERVED(pNetBufferList)->pState = NULL;
		RESERVED(pNetBufferList)->FreeBufAfterWrite = bFreeBuf;
		RESERVED(pNetBufferList)->FreeMdlAfterWrite = bFreeMdl;
		pNetBufferList->SourceHandle = Open->pFiltMod->AdapterHandle;

		//receive the packets before sending them

		// Used to avoid capturing loopback injected traffic here because it's captured later, but now I do it here and avoid capturing it later.
		NPF_DoTap(Open->pFiltMod, pNetBufferList, Open, NPF_IRQL_UNKNOWN);

		//
		//  Call the MAC
		//
		INFO_DBG("NBL %p send: Open = %p, Irp = %p\n", pNetBufferList, Open, Irp);
#ifdef HAVE_WFP_LOOPBACK_SUPPORT
		if (Open->pFiltMod->Loopback)
		{
			NdisSetNblFlag(pNetBufferList, NDIS_NBL_FLAGS_IS_LOOPBACK_PACKET);
			Status = NPF_LoopbackSendNetBufferLists(Open,
				pNetBufferList);
			if (!NT_SUCCESS(Status))
			{
				break;
			}
		}
		else
#endif
#ifdef HAVE_RX_SUPPORT
			if (Open->bSendToRx)
			{
				INFO_DBG("NPF_Write::SendToRxPath, Open->pFiltMod->AdapterHandle=%p, pNetBufferList=%p\n", Open->pFiltMod->AdapterHandle, pNetBufferList);
				// pretend to receive these packets from network and indicate them to upper layers
				RESERVED(pNetBufferList)->bReceivePath = Open->bSendToRx;
				NdisFIndicateReceiveNetBufferLists(
					Open->pFiltMod->AdapterHandle,
					pNetBufferList,
					NDIS_DEFAULT_PORT_NUMBER,
					1,
					0); // If NDIS_RECEIVE_FLAGS_RESOURCES, would need to free pNetBufferList after this.
				// WORKAROUND: We are calling NPF_AnalysisAssumeAliased here because the annotations for
				// NdisFIndicateReceiveNetBufferLists do not use __drv_aliasesMem for the 2nd parameter.
				// When Flags (5th parameter) do *not* have NDIS_RECEIVE_FLAGS_RESOURCES set, the NBL is
				// owned by NDIS until it is returned via NPF_ReturnEx (FilterReturnNetBufferLists handler)
				// Therefore we must not free it, and it is not leaking here.
				NPF_AnalysisAssumeAliased(pNetBufferList);
			}
			else
#endif
			{
				NdisFSendNetBufferLists(Open->pFiltMod->AdapterHandle,
					pNetBufferList,
					NDIS_DEFAULT_PORT_NUMBER,
					SendFlags);
			}

		pNetBufferList = NULL;
		NumSends--;
	}


NPF_Write_End:
	// If Status is success, all intended sends have been initiated and
	// SendCompleteEx can be trusted to clean up.
	if (Open && !NT_SUCCESS(Status))
	{
		WARNING_DBG("NBL %p failed: %#08x\n", pNetBufferList, Status);
		// Failed somehow. Clean up.
		// If we allocated a NBL and failed to send it, free it.
		if (pNetBufferList)
		{
			NT_ASSERT(IrpWasPended);
			NT_ASSERT(NumSends > 0);
			// This call might complete the IRP, but we don't care.
			// Treat it as though SendCompleteEx completed it.
			NPF_FreePackets(Open->pFiltMod, pNetBufferList, NPF_IRQL_UNKNOWN);
			NumSends--;
		}
		// If the IRP was pended, only the one who decrements ulRefcount
		// to 0 can free the MDL and buffer.
		if (IrpWasPended) {
			// If there are any sends left after an error,
			// we need to remove them from ulRefcount
			while (NumSends > 0) {
				NumSends--;
				if (0 == NpfInterlockedDecrement(&pContext->ulRefcount))
				{
					// This was the last reference. It's our job to free it!
					NT_ASSERT(TmpMdl != NULL);
					if (bFreeMdl)
					{
						NPF_FreeMdlAndBuffer(TmpMdl, bFreeBuf);
					}
					// Make sure we don't free it again later
					bFreeBuf = FALSE;
					bFreeMdl = FALSE;
					// SendCompleteEx will not complete this IRP
					bCompleteIrp = TRUE;
					NT_ASSERT(NumSends == 0);
					break;
				}
			}
		}
		// If the IRP wasn't pended, SendCompleteEx will never be
		// called, so do our own cleanup.
		else if (bFreeMdl)
		{
			NPF_FreeMdlAndBuffer(TmpMdl, bFreeBuf);
			NT_ASSERT(bCompleteIrp);
		}
	}

	if (bCompleteIrp) {
		if (Open) {
			NPF_StopUsingOpenInstance(Open, OpenRunning, NPF_IRQL_UNKNOWN);
		}
		Irp->IoStatus.Status = Status;
		Irp->IoStatus.Information = NT_SUCCESS(Status) ? buflen : 0;
		IoCompleteRequest(Irp, IO_NO_INCREMENT);
	}
	TRACE_EXIT();
	// We have to return STATUS_PENDING if we pended the IRP, even if we
	// also completed it due to a later error.
	return (IrpWasPended ? STATUS_PENDING : Status);
}

//-------------------------------------------------------------------

_Use_decl_annotations_
NTSTATUS NPF_BufferedWrite(
	POPEN_INSTANCE Open,
	PUCHAR UserBuff,
	ULONG UserBuffSize,
	BOOLEAN Sync,
	PULONG_PTR Written)
{
	NTSTATUS Status = STATUS_SUCCESS;
	PNET_BUFFER_LIST		pNetBufferList = NULL;
	ULONG					SendFlags = 0;
	UINT					i;
	LARGE_INTEGER			StartTicks = { 0 };
	struct timeval			BufStartTime = { 0 };
	LONGLONG prev_usec_diff = 0;
	struct dump_bpf_hdr* pHdr = NULL;
	PMDL					TmpMdl;

	TRACE_ENTER();

	INFO_DBG("NPF: BufferedWrite, UserBuff=%p, Size=%u\n", UserBuff, UserBuffSize);

	*Written = 0;

	if (!NPF_StartUsingOpenInstance(Open, OpenRunning, NPF_IRQL_UNKNOWN))
	{
		TRACE_EXIT();
		return (Open->OpenStatus <= OpenDetached
					? STATUS_DEVICE_REMOVED
					: STATUS_CANCELLED);
	}
	NT_ASSERT(Open->pFiltMod != NULL);

	// Sanity check on the user buffer
	if (!NT_VERIFY(UserBuff != NULL) || UserBuffSize < sizeof(struct dump_bpf_hdr))
	{
		Status = STATUS_INVALID_PARAMETER;
		goto NPF_BufferedWrite_End;
	}

	// Check that the MaxFrameSize is correctly initialized
	if (Open->pFiltMod->MaxFrameSize == 0)
	{
		INFO_DBG("NPF_BufferedWrite: Open->MaxFrameSize not initialized, probably because of a problem in the OID query\n");
		Status = STATUS_UNSUCCESSFUL;
		goto NPF_BufferedWrite_End;
	}

	PNPF_BUFFERED_WRITE_STATE pState = NPF_AllocateZeroNonpaged(sizeof(NPF_BUFFERED_WRITE_STATE), NPF_BUFFERED_WRITE_TAG);
	if (!pState)
	{
		Status = STATUS_INSUFFICIENT_RESOURCES;
		goto NPF_BufferedWrite_End;
	}
	pState->PacketsPending = 0;
	NdisInitializeEvent(&pState->WriteCompleteEvent);
	NdisResetEvent(&pState->WriteCompleteEvent);

	// WinPcap emulation: loop back injected packets if anyone's listening.
	// Except when NPF_DISABLE_LOOPBACK is chosen, then don't loop back.
	if (!Open->SkipSentPackets)
	{
		SendFlags |= NDIS_SEND_FLAGS_CHECK_FOR_LOOPBACK;
	}


	pHdr = (struct dump_bpf_hdr *)(UserBuff);

	//
	// Main loop: send the buffer to the wire
	//
	ULONG Pos = 0;
	while (TRUE)
	{
		if (Pos >= UserBuffSize)
		{
			// end of buffer
			break;
		}

		if (UserBuffSize - Pos < sizeof(*pHdr))
		{
			// Missing header
			INFO_DBG("NPF_BufferedWrite: not enough data for a dump_bpf_hdr, aborting write.\n");

			Status = STATUS_INVALID_USER_BUFFER;
			break;
		}
		pHdr = (struct dump_bpf_hdr *)(UserBuff + Pos);
		ULONG ulDataOffset = Pos + sizeof(*pHdr);

		if (pHdr->caplen == 0)
		{
			// Malformed header
			INFO_DBG("NPF_BufferedWrite: invalid caplen, aborting write.\n");

			Status = STATUS_INVALID_PARAMETER;
			break;
		}
		if (pHdr->caplen > (UserBuffSize - ulDataOffset))
		{
			Status = NDIS_STATUS_BUFFER_TOO_SHORT;
			break;
		}

		USHORT EthType = 0;
		NDIS_NET_BUFFER_LIST_8021Q_INFO Qinfo;
		ULONG pktlen = 0;
		BOOLEAN bFreeBuf = FALSE;
		TmpMdl = NPF_BufferToMdl(Open->pFiltMod, UserBuff + ulDataOffset, pHdr->caplen,
				NULL, // No existing MDL because METHOD_BUFFERED
				&pktlen, &Qinfo, &EthType, &bFreeBuf);

		if (TmpMdl == NULL)
		{
			// Unable to map the memory: packet lost
			INFO_DBG("NPF_BufferedWrite: unable to allocate the MDL.\n");

			Status = STATUS_INSUFFICIENT_RESOURCES;
			break;
		}
		if (pktlen > Open->pFiltMod->MaxFrameSize)
		{
			Status = NDIS_STATUS_INVALID_LENGTH;
			break;
		}

		// Allocate a packet from our free list
		Status = NPF_AllocateNBL(Open->pFiltMod,
				TmpMdl,
				pktlen,
				&pNetBufferList);
		if (!NT_SUCCESS(Status))
		{
			//  No more free packets
			
			INFO_DBG("NPF_BufferedWrite: no more free packets, returning.\n");

			NPF_FreeMdlAndBuffer(TmpMdl, bFreeBuf);

			break;
		}
		NT_ASSERT(pNetBufferList != NULL);
		NT_ASSERT(RESERVED(pNetBufferList) != NULL);
		NT_ASSERT(NET_BUFFER_LIST_CONTEXT_DATA_SIZE(pNetBufferList) >= sizeof(PACKET_RESERVED));

		// Mark packet as necessary
		if (EthType == ETHERTYPE_IP)
		{
			NdisSetNblFlag(pNetBufferList, NDIS_NBL_FLAGS_IS_IPV4);
		}
		else if (EthType == ETHERTYPE_IPV6)
		{
			NdisSetNblFlag(pNetBufferList, NDIS_NBL_FLAGS_IS_IPV6);
		}
		NET_BUFFER_LIST_INFO(pNetBufferList, NetBufferListFrameType) = (PVOID)RtlUshortByteSwap(EthType);
		NET_BUFFER_LIST_INFO(pNetBufferList, Ieee8021QNetBufferListInfo) = Qinfo.Value;

		// The packet has a buffer that needs to be freed after every single write
		RESERVED(pNetBufferList)->pIrp = NULL;
		RESERVED(pNetBufferList)->pState = pState;
		RESERVED(pNetBufferList)->FreeBufAfterWrite = bFreeBuf;
		RESERVED(pNetBufferList)->FreeMdlAfterWrite = TRUE;
		pNetBufferList->SourceHandle = Open->pFiltMod->AdapterHandle;

		NpfInterlockedIncrement(&pState->PacketsPending);
		NdisResetEvent(&pState->WriteCompleteEvent);

		if (StartTicks.QuadPart == 0)
		{
			// First packet
			// Retrieve the time references
			StartTicks = KeQueryPerformanceCounter(&TimeFreq);
			BufStartTime.tv_sec = pHdr->ts.tv_sec;
			BufStartTime.tv_usec = pHdr->ts.tv_usec;
		}
		else if (Sync)
		{
			// Time offset of this packet from the first one (usecs)
			LONGLONG usec_diff = ((LONGLONG)pHdr->ts.tv_sec - BufStartTime.tv_sec) * 1000000
				+ pHdr->ts.tv_usec - BufStartTime.tv_usec;
			if (usec_diff < prev_usec_diff) {
				// Parallel processing of packets can result in minor timestamp jitter.
				// If the difference is <1ms, warn in debug mode but just proceed with sending.
				// If the difference is >1ms, produce an error.
				WARNING_DBG("timestamp %08x.%08x out of order by %lld usecs!\n",
						pHdr->ts.tv_sec, pHdr->ts.tv_usec, prev_usec_diff - usec_diff);
				if (prev_usec_diff - usec_diff > 1000) {
					NPF_FreePackets(Open->pFiltMod, pNetBufferList, NPF_IRQL_UNKNOWN);
					Status = RPC_NT_INVALID_TIMEOUT;
					break;
				}
				// else continue to send.
				// Do not overwrite prev_usec_diff, since we've already waited to sync with that timestamp.
			}
			else
			{
				// packet is in order; check if we should delay or return.
				prev_usec_diff = usec_diff;
				// Release the application if it has been or would be blocked for more than 1 second
				if (usec_diff > 1000000)
				{
					INFO_DBG("timestamp elapsed, returning.\n");

					NPF_FreePackets(Open->pFiltMod, pNetBufferList, NPF_IRQL_UNKNOWN);
					break;
				}

				// Calculate the target QPC ticks to send the next packet
				LARGE_INTEGER TargetTicks = { 0 };
				TargetTicks.QuadPart = StartTicks.QuadPart + usec_diff * TimeFreq.QuadPart / 1000000;

				// Save the current time stamp counter
				LARGE_INTEGER CurTicks = KeQueryPerformanceCounter(NULL);
				// If we need to wait, do so
				if (CurTicks.QuadPart < TargetTicks.QuadPart)
				{
					// whole microseconds remaining.
					// Explicit cast ok since condition above ensures this will be at most 1000000us.
					i = (UINT)(((TargetTicks.QuadPart - CurTicks.QuadPart) * 1000000) / TimeFreq.QuadPart);
					NT_ASSERT(i < 1000000);
					// These are the NDIS-recommended routines for delaying execution.
					// Note that both can fire up to 1 system clock tick (e.g. 15ms) later than requested.
					if (i >= 50)
					{
						NdisMSleep(i);
					}
					else
					{
						NdisStallExecution(i);
					}
				}
			}
		}

		//receive the packets before sending them
		NPF_DoTap(Open->pFiltMod, pNetBufferList, Open, NPF_IRQL_UNKNOWN);

		//
		// Call the MAC
		//
		INFO_DBG("NBL %p Buffered send: Open = %p, pState = %p\n", pNetBufferList, Open, pState);
#ifdef HAVE_WFP_LOOPBACK_SUPPORT
		if (Open->pFiltMod->Loopback)
		{
			NdisSetNblFlag(pNetBufferList, NDIS_NBL_FLAGS_IS_LOOPBACK_PACKET);
			Status = NPF_LoopbackSendNetBufferLists(Open,
				pNetBufferList);
			if (!NT_SUCCESS(Status))
			{
				NPF_FreePackets(Open->pFiltMod, pNetBufferList, NPF_IRQL_UNKNOWN);
				break;
			}
		}
		else
#endif
#ifdef HAVE_RX_SUPPORT
			if (Open->bSendToRx)
			{
				INFO_DBG("NPF_BufferedWrite::SendToRxPath, Open->pFiltMod->AdapterHandle=%p, pNetBufferList=%p\n", Open->pFiltMod->AdapterHandle, pNetBufferList);
				// pretend to receive these packets from network and indicate them to upper layers
				NdisFIndicateReceiveNetBufferLists(
					Open->pFiltMod->AdapterHandle,
					pNetBufferList,
					NDIS_DEFAULT_PORT_NUMBER,
					1,
					0); // If NDIS_RECEIVE_FLAGS_RESOURCES, would need to free pNetBufferList after this.
				// WORKAROUND: We are calling NPF_AnalysisAssumeAliased here because the annotations for
				// NdisFIndicateReceiveNetBufferLists do not use __drv_aliasesMem for the 2nd parameter.
				// When Flags (5th parameter) do *not* have NDIS_RECEIVE_FLAGS_RESOURCES set, the NBL is
				// owned by NDIS until it is returned via NPF_ReturnEx (FilterReturnNetBufferLists handler)
				// Therefore we must not free it, and it is not leaking here.
				NPF_AnalysisAssumeAliased(pNetBufferList);
			}
			else
#endif
			{
				NdisFSendNetBufferLists(Open->pFiltMod->AdapterHandle,
					pNetBufferList,
					NDIS_DEFAULT_PORT_NUMBER,
					SendFlags);
			}

		Pos = ulDataOffset + pHdr->caplen;
	}

	while (pState->PacketsPending > 0) {
		NdisWaitEvent(&pState->WriteCompleteEvent, 0);
	}
	ExFreePoolWithTag(pState, NPF_BUFFERED_WRITE_TAG);

	*Written = Pos;

NPF_BufferedWrite_End:
	NPF_StopUsingOpenInstance(Open, OpenRunning, NPF_IRQL_UNKNOWN);

	TRACE_EXIT();
	return Status;
}

//-------------------------------------------------------------------

_Use_decl_annotations_
VOID
NPF_FreePackets(
	PNPCAP_FILTER_MODULE pFiltMod,
	PNET_BUFFER_LIST    pNetBufList,
	BOOLEAN AtDispatchLevel
	)
	/*++

	Routine Description:

	Free our own initiated Net Buffer Lists.

	Arguments:

	NetBufferLists          - a chain of NBLs that are being freed

	Return Value:

	NONE

	--*/
{
	PNET_BUFFER         Currbuff;
	PPACKET_RESERVED pRsvd = RESERVED(pNetBufList);
	BOOLEAN bDoCleanup = TRUE;

/*	TRACE_ENTER();*/

	if (pRsvd) {
		PIRP pIrp = pRsvd->pIrp;
		if (pIrp != NULL) {
			INFO_DBG("NBL %p complete: Irp = %p\n", pNetBufList, pIrp);

			PWRITE_IRP_CONTEXT pContext = GET_WRITE_IRP_CONTEXT(pIrp);
			// Only do cleanup if we remove the last reference.
			if (0 == NpfInterlockedDecrement(&pContext->ulRefcount)) {
				PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(pIrp);
				POPEN_INSTANCE pOpen = IrpSp->FileObject->FsContext;
				NT_ASSERT(pOpen->pFiltMod == pFiltMod);
				bDoCleanup = TRUE;

				NPF_StopUsingOpenInstance(pOpen, OpenRunning, AtDispatchLevel);

				NDIS_STATUS Status = NET_BUFFER_LIST_STATUS(pNetBufList);
				pIrp->IoStatus.Status = Status;
				if (NDIS_STATUS_SUCCESS == Status)
				{
					pIrp->IoStatus.Information = IrpSp->Parameters.Write.Length;
				}
				else
				{
					WARNING_DBG("NBL status = %#08x\n", Status);
					pIrp->IoStatus.Information = 0;
				}
				IoCompleteRequest(pIrp, IO_NO_INCREMENT);
				INFO_DBG("Write complete\n");
			}
		}

		PNPF_BUFFERED_WRITE_STATE pState = pRsvd->pState;
		if (pState != NULL)
		{
			if (0 == NpfInterlockedDecrement(&pState->PacketsPending))
			{
				NdisSetEvent(&pState->WriteCompleteEvent);
			}
		}

		if (bDoCleanup && pRsvd->FreeMdlAfterWrite)
		{
			//Free the NBL allocate by myself
			Currbuff = NET_BUFFER_LIST_FIRST_NB(pNetBufList);
			while (Currbuff)
			{
				NPF_FreeMdlAndBuffer(NET_BUFFER_FIRST_MDL(Currbuff), pRsvd->FreeBufAfterWrite);
				Currbuff = NET_BUFFER_NEXT_NB(Currbuff);
			}
		}
	}

#ifdef HAVE_WFP_LOOPBACK_SUPPORT
	if (pFiltMod->Loopback)
	{
		FwpsFreeNetBufferList(pNetBufList);
		// FwpsFreeNetBufferList lacks the __drv_freesMem SAL annotation needed
		NPF_AnalysisAssumeFreed(pNetBufList);
	}
	else
#endif
	{
		NdisFreeNetBufferList(pNetBufList); //Free NBL
	}

/*	TRACE_EXIT();*/
}

//-------------------------------------------------------------------

_Use_decl_annotations_
VOID
NPF_SendCompleteEx(
	NDIS_HANDLE         FilterModuleContext,
	PNET_BUFFER_LIST    NetBufferLists,
	ULONG               SendCompleteFlags
	)
/*++

Routine Description:

	Send complete handler

	This routine is invoked whenever the lower layer is finished processing 
	sent NET_BUFFER_LISTs.  If the filter does not need to be involved in the
	send path, you should remove this routine and the FilterSendNetBufferLists
	routine.  NDIS will pass along send packets on behalf of your filter more 
	efficiently than the filter can.

Arguments:

	FilterModuleContext     - our filter context
	NetBufferLists          - a chain of NBLs that are being returned to you
	SendCompleteFlags       - flags (see documentation)

Return Value:

	 NONE

--*/
{
	PNET_BUFFER_LIST    pNetBufList = NULL;
	PNET_BUFFER_LIST    pPrevNetBufList = NULL;
	PNPCAP_FILTER_MODULE pFiltMod = (PNPCAP_FILTER_MODULE) FilterModuleContext;
	BOOLEAN bAtDispatchLevel = NDIS_TEST_SEND_AT_DISPATCH_LEVEL(SendCompleteFlags);

	TRACE_ENTER();
	/* This callback is used for NDIS LWF as well as WFP/loopback */

	//
	// If your filter injected any send packets into the datapath to be sent,
	// you must identify their NBLs here and remove them from the chain.  Do not
	// attempt to send-complete your NBLs up to the higher layer.
	//

	pNetBufList = NetBufferLists;
	while (pNetBufList != NULL)
	{
		// Keep track of this one
		PNET_BUFFER_LIST pNBL = pNetBufList;
		// Point to the next one
		pNetBufList = NET_BUFFER_LIST_NEXT_NBL(pNetBufList);

		if (pNBL->SourceHandle != pFiltMod->AdapterHandle)
		{
			// No match, just move down.
			pPrevNetBufList = pNBL;
			continue;
		}
		// this is our self-sent packets

		// Remove this one from the chain and move down.
		if (pPrevNetBufList == NULL) {
			// head of list, repoint NetBufferLists
			NetBufferLists = pNetBufList;
		}
		else {
			NET_BUFFER_LIST_NEXT_NBL(pPrevNetBufList) = pNetBufList;
		}
		NET_BUFFER_LIST_NEXT_NBL(pNBL) = NULL;


		NPF_FreePackets(pFiltMod, pNBL, bAtDispatchLevel);
	}

	// Send complete any NBLS that are left (didn't originate with us)
	if (NetBufferLists != NULL) {
		NdisFSendNetBufferListsComplete(pFiltMod->AdapterHandle, NetBufferLists, SendCompleteFlags);
	}

	TRACE_EXIT();
}

//-------------------------------------------------------------------

#ifdef HAVE_WFP_LOOPBACK_SUPPORT

_IRQL_requires_min_(PASSIVE_LEVEL)
_IRQL_requires_max_(DISPATCH_LEVEL)
_IRQL_requires_same_
void NTAPI NPF_NetworkInjectionComplete(
	_In_ VOID* pContext,
	_Inout_ NET_BUFFER_LIST* pNetBufferList,
	_In_ BOOLEAN dispatchLevel
	)
{
	TRACE_ENTER();

	/* This method should only be used for Loopback (for now, though see #516) */
	NT_ASSERT(((PNPCAP_FILTER_MODULE) pContext)->Loopback);

	// Don't need to Retreat the data offset since the completion/free functions ignore CurrentMdl
	// Call complete function manually just like NDIS callback.
	NPF_SendCompleteEx(pContext, pNetBufferList, dispatchLevel ? NDIS_SEND_COMPLETE_FLAGS_DISPATCH_LEVEL : 0);

	TRACE_EXIT();
	return;
}

_Use_decl_annotations_
NTSTATUS
NPF_LoopbackSendNetBufferLists(
	POPEN_INSTANCE pOpen,
	PNET_BUFFER_LIST NetBufferList
	)
{
	ULONG bytesAdvanced = 0;
	HANDLE hInjectionHandle = NULL;
	NTSTATUS status = STATUS_UNSUCCESSFUL;

	TRACE_ENTER();
	NT_ASSERT(pOpen->bLoopback);

	if (NdisTestNblFlag(NetBufferList, NDIS_NBL_FLAGS_IS_IPV4))
	{
		hInjectionHandle = g_pDriverExtension->hInject[NPF_INJECT_IPV4];
	}
	else if (NdisTestNblFlag(NetBufferList, NDIS_NBL_FLAGS_IS_IPV6))
	{
		hInjectionHandle = g_pDriverExtension->hInject[NPF_INJECT_IPV6];
	}
	else
	{
		INFO_DBG("NPF_LoopbackSendNetBufferLists: invalid NBL (NblFlags not IPv4 or IPv6)\n");
		TRACE_EXIT();
		return STATUS_PROTOCOL_NOT_SUPPORTED;
	}

	bytesAdvanced = g_pDriverExtension->bDltNullMode ? DLT_NULL_HDR_LEN : ETHER_HDR_LEN;

	if (!NT_VERIFY(hInjectionHandle != NULL))
	{
		INFO_DBG("NPF_LoopbackSendNetBufferLists: invalid injection handle\n");
		TRACE_EXIT();
		return STATUS_INVALID_HANDLE;
	}

	NdisAdvanceNetBufferListDataStart(NetBufferList, bytesAdvanced, FALSE, NULL);

	status = FwpsInjectNetworkSendAsync(hInjectionHandle,
			NULL,
			0,
			UNSPECIFIED_COMPARTMENT_ID,
			NetBufferList,
			NPF_NetworkInjectionComplete,
			pOpen->pFiltMod);
	if (NT_SUCCESS(status))
	{
		// Fwps* functions don't have annotations about aliasing or freeing memory. Have to do it ourselves.
		NPF_AnalysisAssumeAliased(NetBufferList);
	}
	else
	{
		WARNING_DBG("FwpsInjectNetworkSendAsync failed: %#08x; NBL = %p\n", status, NetBufferList);
	}

	TRACE_EXIT();
	return status;
}
#endif

```

`packetWin7/npf/npf/cpp.hint`:

```hint
// Hint files help the Visual Studio IDE interpret Visual C++ identifiers
// such as names of functions and macros.
// For more information see https://go.microsoft.com/fwlink/?linkid=865984
#define DECLARE_XNUM
#define _Dispatch_type_
```

`packetWin7/npf/npf/ieee80211_radiotap.h`:

```h
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
/*-
* Copyright (c) 2003, 2004 David Young.  All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
* 3. The name of David Young may not be used to endorse or promote
*    products derived from this software without specific prior
*    written permission.
*
* THIS SOFTWARE IS PROVIDED BY DAVID YOUNG ``AS IS'' AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
* THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
* PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL DAVID
* YOUNG BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
* OF SUCH DAMAGE.
*
*/
#ifndef _NET_IF_IEEE80211RADIOTAP_H_
#define _NET_IF_IEEE80211RADIOTAP_H_

/* A generic radio capture format is desirable. There is one for
* Linux, but it is neither rigidly defined (there were not even
* units given for some fields) nor easily extensible.
*
* I suggest the following extensible radio capture format. It is
* based on a bitmap indicating which fields are present.
*
* I am trying to describe precisely what the application programmer
* should expect in the following, and for that reason I tell the
* units and origin of each measurement (where it applies), or else I
* use sufficiently weaselly language ("is a monotonically nondecreasing
* function of...") that I cannot set false expectations for lawyerly
* readers.
*/
#if defined(__KERNEL__) || defined(_KERNEL)
#ifndef DLT_IEEE802_11_RADIO
#define	DLT_IEEE802_11_RADIO	127	/* 802.11 plus WLAN header */
#endif
#endif /* defined(__KERNEL__) || defined(_KERNEL) */

#if defined _WIN32
#define u_int8_t  UCHAR
#define u_int16_t USHORT
#define u_int32_t ULONG
#define u_int64_t ULONGLONG

#define int8_t  CHAR
#define int16_t SHORT
#define int32_t LONG
#define int64_t LONGLONG
#endif

/* The radio capture header precedes the 802.11 header. */

#ifndef __MINGW32__
#pragma pack(push)
#pragma pack(1)
#endif // __MINGW32__
typedef struct _ieee80211_radiotap_header {
	u_int8_t it_version;		/* Version 0. Only increases
								* for drastic changes,
								* introduction of compatible
								* new fields does not count.
								*/
	u_int8_t it_pad;
	u_int16_t it_len;		/* length of the whole
							* header in bytes, including
							* it_version, it_pad,
							* it_len, and data fields.
							*/
	u_int32_t it_present;		/* A bitmap telling which
								* fields are present. Set bit 31
								* (0x80000000) to extend the
								* bitmap by another 32 bits.
								* Additional extensions are made
								* by setting bit 31.
								*/
} IEEE80211_RADIOTAP_HEADER, *PIEEE80211_RADIOTAP_HEADER;
#ifdef __MINGW32__
__attribute__((__packed__))
#endif // __MINGW32__
;

#ifndef __MINGW32__
#pragma pack(pop)
#endif // __MINGW32__

/* Name                                 Data type       Units
* ----                                 ---------       -----
*
* IEEE80211_RADIOTAP_TSFT              u_int64_t       microseconds
*
*      Value in microseconds of the MAC's 64-bit 802.11 Time
*      Synchronization Function timer when the first bit of the
*      MPDU arrived at the MAC. For received frames, only.
*
* IEEE80211_RADIOTAP_CHANNEL           2 x u_int16_t   MHz, bitmap
*
*      Tx/Rx frequency in MHz, followed by flags (see below).
*
* IEEE80211_RADIOTAP_FHSS              u_int16_t       see below
*
*      For frequency-hopping radios, the hop set (first byte)
*      and pattern (second byte).
*
* IEEE80211_RADIOTAP_RATE              u_int8_t        500kb/s
*
*      Tx/Rx data rate
*
* IEEE80211_RADIOTAP_DBM_ANTSIGNAL     int8_t          decibels from
*                                                      one milliwatt (dBm)
*
*      RF signal power at the antenna, decibel difference from
*      one milliwatt.
*
* IEEE80211_RADIOTAP_DBM_ANTNOISE      int8_t          decibels from
*                                                      one milliwatt (dBm)
*
*      RF noise power at the antenna, decibel difference from one
*      milliwatt.
*
* IEEE80211_RADIOTAP_DB_ANTSIGNAL      u_int8_t        decibel (dB)
*
*      RF signal power at the antenna, decibel difference from an
*      arbitrary, fixed reference.
*
* IEEE80211_RADIOTAP_DB_ANTNOISE       u_int8_t        decibel (dB)
*
*      RF noise power at the antenna, decibel difference from an
*      arbitrary, fixed reference point.
*
* IEEE80211_RADIOTAP_LOCK_QUALITY		u_int16_t       unitless
*
*      Quality of Barker code lock. Unitless. Monotonically
*      nondecreasing with "better" lock strength. Called "Signal
*      Quality" in datasheets.  (Is there a standard way to measure
*      this?)
*
* IEEE80211_RADIOTAP_TX_ATTENUATION    u_int16_t       unitless
*
*      Transmit power expressed as unitless distance from max
*      power set at factory calibration.  0 is max power.
*      Monotonically nondecreasing with lower power levels.
*
* IEEE80211_RADIOTAP_DB_TX_ATTENUATION u_int16_t       decibels (dB)
*
*      Transmit power expressed as decibel distance from max power
*      set at factory calibration.  0 is max power.  Monotonically
*      nondecreasing with lower power levels.
*
* IEEE80211_RADIOTAP_DBM_TX_POWER      int8_t          decibels from
*                                                      one milliwatt (dBm)
*
*      Transmit power expressed as dBm (decibels from a 1 milliwatt
*      reference). This is the absolute power level measured at
*      the antenna port.
*
* IEEE80211_RADIOTAP_FLAGS             u_int8_t        bitmap
*
*      Properties of transmitted and received frames. See flags
*      defined below.
*
* IEEE80211_RADIOTAP_ANTENNA           u_int8_t        antenna index
*
*      Unitless indication of the Rx/Tx antenna for this packet.
*      The first antenna is antenna 0.
*
* IEEE80211_RADIOTAP_FCS           	u_int32_t       data
*
*	FCS from frame in network byte order.
*/

/* ethereal does NOT handle the following:
IEEE80211_RADIOTAP_FHSS:
IEEE80211_RADIOTAP_LOCK_QUALITY:
IEEE80211_RADIOTAP_TX_ATTENUATION:
IEEE80211_RADIOTAP_DB_TX_ATTENUATION:
*/

enum ieee80211_radiotap_type
{
	IEEE80211_RADIOTAP_TSFT = 0,
	IEEE80211_RADIOTAP_FLAGS = 1,
	IEEE80211_RADIOTAP_RATE = 2,
	IEEE80211_RADIOTAP_CHANNEL = 3,
	IEEE80211_RADIOTAP_FHSS = 4,
	IEEE80211_RADIOTAP_DBM_ANTSIGNAL = 5,
	IEEE80211_RADIOTAP_DBM_ANTNOISE = 6,
	IEEE80211_RADIOTAP_LOCK_QUALITY = 7,
	IEEE80211_RADIOTAP_TX_ATTENUATION = 8,
	IEEE80211_RADIOTAP_DB_TX_ATTENUATION = 9,
	IEEE80211_RADIOTAP_DBM_TX_POWER = 10,
	IEEE80211_RADIOTAP_ANTENNA = 11,
	IEEE80211_RADIOTAP_DB_ANTSIGNAL = 12,
	IEEE80211_RADIOTAP_DB_ANTNOISE = 13,
	// IEEE80211_RADIOTAP_FCS = 14, // from ieee80211_radiotap.h (AirPcap)
	// IEEE80211_RADIOTAP_EXT = 31, // from ieee80211_radiotap.h (AirPcap)
	IEEE80211_RADIOTAP_RX_FLAGS = 14,
	// IEEE80211_RADIOTAP_TX_FLAGS = 15, // from packet-ieee80211-radiotap-defs.h (Wireshark)
	// IEEE80211_RADIOTAP_RTS_RETRIES = 16, // from packet-ieee80211-radiotap-defs.h (Wireshark)
	// IEEE80211_RADIOTAP_DATA_RETRIES = 17, // from packet-ieee80211-radiotap-defs.h (Wireshark)
	// IEEE80211_RADIOTAP_XCHANNEL = 18,  // from packet-ieee80211-radiotap-defs.h (Wireshark) /* Unofficial, used by FreeBSD */
	IEEE80211_RADIOTAP_MCS = 19,
	IEEE80211_RADIOTAP_AMPDU_STATUS = 20,
	IEEE80211_RADIOTAP_VHT = 21,
};

#define BIT(n)	(1U << n)

#ifndef _KERNEL
/* Channel flags. */
#define IEEE80211_CHAN_TURBO    0x0010  /* Turbo channel */
#define IEEE80211_CHAN_CCK      0x0020  /* CCK channel */
#define IEEE80211_CHAN_OFDM     0x0040  /* OFDM channel */
#define	IEEE80211_CHAN_2GHZ	0x0080	/* 2 GHz spectrum channel. */
#define IEEE80211_CHAN_5GHZ     0x0100  /* 5 GHz spectrum channel */
#define IEEE80211_CHAN_PASSIVE  0x0200  /* Only passive scan allowed */
#define	IEEE80211_CHAN_DYN	0x0400	/* Dynamic CCK-OFDM channel */
#define	IEEE80211_CHAN_GFSK	0x0800	/* GFSK channel (FHSS PHY) */
#define	IEEE80211_CHAN_STURBO	0x2000	/* 11a static turbo channel only */
#endif /* !_KERNEL */

/* For IEEE80211_RADIOTAP_FLAGS */
#define	IEEE80211_RADIOTAP_F_CFP	0x01	/* sent/received
* during CFP
*/
#define	IEEE80211_RADIOTAP_F_SHORTPRE	0x02	/* sent/received
* with short
* preamble
*/
#define	IEEE80211_RADIOTAP_F_WEP	0x04	/* sent/received
* with WEP encryption
*/
#define	IEEE80211_RADIOTAP_F_FRAG	0x08	/* sent/received
* with fragmentation
*/
#define	IEEE80211_RADIOTAP_F_FCS	0x10	/* frame includes FCS */
#define	IEEE80211_RADIOTAP_F_DATAPAD	0x20	/* frame has padding between
* 802.11 header and payload
* (to 32-bit boundary)
*/
#define IEEE80211_RADIOTAP_F_BADFCS	0x40	/* frame failed FCS check */

#endif /* _NET_IF_IEEE80211RADIOTAP_H_ */

```

`packetWin7/npf/npf/ioctls.h`:

```h
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
/*
 * Copyright (c) 2007 CACE Technologies, Davis (California)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of CACE Technologies nor the names of its 
 * contributors may be used to endorse or promote products derived from 
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#ifndef __NPF_IOCTLS_H__
#define __NPF_IOCTLS_H__

/***************************/
/*  	   IOCTLs   	   */
/***************************/

/** @addtogroup NPF 
 *  @{
 */

/** @defgroup NPF_ioctl NPF I/O control codes 
 *  @{
 */

/*!
  \brief IOCTL code: set kernel buffer size.

  This IOCTL is used to set a new size of the circular buffer associated with an instance of NPF.
  When a BIOCSETBUFFERSIZE command is received, the driver frees the old buffer, allocates the new one 
  and resets all the parameters associated with the buffer in the OPEN_INSTANCE structure. The currently 
  buffered packets are lost.
*/
#define W_BIOCSETBUFFERSIZE 9592 /*CTL_CODE(0, 0x95e, METHOD_BUFFERED, FILE_ANY_ACCESS)*/
#define BIOCSETBUFFERSIZE CTL_CODE(FILE_DEVICE_TRANSPORT, 0xa01, METHOD_BUFFERED, FILE_READ_DATA)

/*!
  \brief IOCTL code: set packet filtering program.

  This IOCTL sets a new packet filter in the driver. Before allocating any memory for the new filter, the 
  bpf_validate() function is called to check the correctness of the filter. If this function returns TRUE, 
  the filter is copied to the driver's memory, its address is stored in the bpfprogram field of the 
  OPEN_INSTANCE structure associated with current instance of the driver, and the filter will be applied to 
  every incoming packet. This command also empties the circular buffer used by current instance 
  to store packets. This is done to avoid the presence in the buffer of packets that do not match the filter.
*/
/* Historical number 9030 */
#define W_BIOCSETF 9030 /*CTL_CODE(0, 0x8d1, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)*/
#define BIOCSETF CTL_CODE(FILE_DEVICE_TRANSPORT, 0xa02, METHOD_BUFFERED, FILE_READ_DATA)

/*!
  \brief IOCTL code: get the capture stats

  This command returns to the application the number of packets received and the number of packets dropped by 
  an instance of the driver.
*/
/* Historical number 9031 */
#define W_BIOCGSTATS 9031 /*CTL_CODE(0, 0x8d1, METHOD_NEITHER, FILE_ANY_ACCESS)*/
#define BIOCGSTATS CTL_CODE(FILE_DEVICE_TRANSPORT, 0xa03, METHOD_BUFFERED, FILE_READ_DATA)

/*!
  \brief IOCTL code: set the read timeout

  This command sets the maximum timeout after which a read is released, also if no data packets were received.
*/
#define W_BIOCSRTIMEOUT 7416 /*CTL_CODE(0, 0x73e, METHOD_BUFFERED, FILE_ANY_ACCESS)*/
#define BIOCSRTIMEOUT CTL_CODE(FILE_DEVICE_TRANSPORT, 0xa04, METHOD_BUFFERED, FILE_READ_DATA)

/*!
  \brief IOCTL code: set working mode

  This IOCTL can be used to set the working mode of a NPF instance. The new mode, received by the driver in the
  buffer associated with the IOCTL command, can be #MODE_CAPT for capture mode (the default), #MODE_STAT for
  statistical mode.
*/
#define W_BIOCSMODE 7412 /*CTL_CODE(0, 0x73d, METHOD_BUFFERED, FILE_ANY_ACCESS)*/
#define BIOCSMODE CTL_CODE(FILE_DEVICE_TRANSPORT, 0xa05, METHOD_BUFFERED, FILE_READ_DATA)

/*!
  \brief IOCTL code: set number of physical repetions of every packet written by the app

  Sets the number of times a single write call must be repeated. This command sets the OPEN_INSTANCE::Nwrites 
  member, and is used to implement the 'multiple write' feature of the driver.
*/
#define W_BIOCSWRITEREP 7413 /*CTL_CODE(0, 0x73d, METHOD_IN_DIRECT, FILE_ANY_ACCESS)*/
#define BIOCSWRITEREP CTL_CODE(FILE_DEVICE_TRANSPORT, 0xa06, METHOD_BUFFERED, FILE_WRITE_DATA)

/*!
  \brief IOCTL code: set minimum amount of data in the kernel buffer that unlocks a read call

  This command sets the OPEN_INSTANCE::MinToCopy member.
*/
#define W_BIOCSMINTOCOPY 7414 /*CTL_CODE(0, 0x73d, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)*/
#define BIOCSMINTOCOPY CTL_CODE(FILE_DEVICE_TRANSPORT, 0xa07, METHOD_BUFFERED, FILE_READ_DATA)

/*!
  \brief IOCTL code: set an OID value

  This IOCTL is used to perform an OID set operation on the NIC driver. 
*/
#define W_BIOCSETOID 0x80000000 /*CTL_CODE(0, 0x0, METHOD_BUFFERED, FILE_ANY_ACCESS)*/
#define BIOCSETOID CTL_CODE(FILE_DEVICE_TRANSPORT, 0xa08, METHOD_BUFFERED, FILE_WRITE_DATA)

/*!
  \brief IOCTL code: get an OID value

  This IOCTL is used to perform an OID get operation on the NIC driver. 
*/
#define W_BIOCQUERYOID 0x80000004 /*CTL_CODE(0, 0x1, METHOD_BUFFERED, FILE_ANY_ACCESS)*/
#define BIOCQUERYOID CTL_CODE(FILE_DEVICE_TRANSPORT, 0xa09, METHOD_BUFFERED, FILE_READ_DATA)

// kernel dump mode not supported by Npcap.
#define W_BIOCSETDUMPFILENAME 9029 /*CTL_CODE(0, 0x8d1, METHOD_IN_DIRECT, FILE_ANY_ACCESS)*/
#define BIOCSETDUMPFILENAME CTL_CODE(FILE_DEVICE_TRANSPORT, 0xa0a, METHOD_BUFFERED, FILE_READ_DATA)

/*!
  \brief IOCTL code: get the name of the event that the driver signals when some data is present in the buffer

  Command used by the application to retrieve the name of the global event associated with a NPF instance.
  The event is signaled by the driver when the kernel buffer contains enough data for a transfer.
*/
#define W_BIOCGEVNAME 7415 /*CTL_CODE(0, 0x73d, METHOD_NEITHER, FILE_ANY_ACCESS)*/
#define BIOCGEVNAME CTL_CODE(FILE_DEVICE_TRANSPORT, 0xa0b, METHOD_BUFFERED, FILE_READ_DATA)

/*!
  \brief IOCTL code: Send a buffer containing multiple packets to the network, ignoring the timestamps.

  Command used to send a buffer of packets in a single system call. Every packet in the buffer is preceded by
  a dump_bpf_hdr structure. The timestamps of the packets are ignored, i.e. the packets are sent as fast as 
  possible. The NPF_BufferedWrite() function is invoked to send the packets.
*/
#define W_BIOCSENDPACKETSNOSYNC 9032 /*CTL_CODE(0, 0x8d2, METHOD_BUFFERED, FILE_ANY_ACCESS)*/
#define BIOCSENDPACKETSNOSYNC CTL_CODE(FILE_DEVICE_TRANSPORT, 0xa0c, METHOD_BUFFERED, FILE_WRITE_DATA)

/*!
  \brief IOCTL code: Send a buffer containing multiple packets to the network, considering the timestamps.

  Command used to send a buffer of packets in a single system call. Every packet in the buffer is preceded by
  a dump_bpf_hdr structure. The timestamps of the packets are used to synchronize the write, i.e. the packets 
  are sent to the network respecting the intervals specified in the dump_bpf_hdr structure assiciated with each
  packet. NPF_BufferedWrite() function is invoked to send the packets. 
*/
#define W_BIOCSENDPACKETSSYNC 9033 /*CTL_CODE(0, 0x8d2, METHOD_IN_DIRECT, FILE_ANY_ACCESS)*/
#define BIOCSENDPACKETSSYNC CTL_CODE(FILE_DEVICE_TRANSPORT, 0xa0d, METHOD_BUFFERED, FILE_WRITE_DATA)

// kernel dump mode not supported by Npcap.
#define W_BIOCSETDUMPLIMITS 9034 /*CTL_CODE(0, 0x8d2, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)*/
#define BIOCSETDUMPLIMITS CTL_CODE(FILE_DEVICE_TRANSPORT, 0xa0e, METHOD_BUFFERED, FILE_READ_DATA)

// kernel dump mode not supported by Npcap.
#define W_BIOCISDUMPENDED 7411 /*CTL_CODE(0, 0x73c, METHOD_NEITHER, FILE_ANY_ACCESS)*/
#define BIOCISDUMPENDED CTL_CODE(FILE_DEVICE_TRANSPORT, 0xa0f, METHOD_BUFFERED, FILE_READ_DATA)

/*!
  \brief IOCTL code: set the loopback behavior.

  This IOCTL sets the loopback behavior of the driver with packets sent by itself: capture or drop.
*/
#define W_BIOCISETLOBBEH 7410 /*CTL_CODE(0, 0x73c, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)*/
#define BIOCISETLOBBEH CTL_CODE(FILE_DEVICE_TRANSPORT, 0xa10, METHOD_BUFFERED, FILE_READ_DATA)

/*!
	\brief This IOCTL passes the read event HANDLE allocated by the user (packet.dll) to kernel level

	Parameter: HANDLE
	Parameter size: sizeof(HANDLE). If the caller is 32 bit, the parameter size is 4 bytes, even if sizeof(HANDLE) at kernel level
		is 8 bytes. That's why in this IOCTL code handler we detect a 32bit calling process and do the necessary thunking.

*/
#define W_BIOCSETEVENTHANDLE 7920 /*CTL_CODE(0, 0x7bc, METHOD_BUFFERED, FILE_ANY_ACCESS)*/
#define BIOCSETEVENTHANDLE CTL_CODE(FILE_DEVICE_TRANSPORT, 0xa11, METHOD_BUFFERED, FILE_READ_DATA)

/*
  \brief IOCTL code: set the timestamp mode.

  This IOCTL sets the timestamp mode (DWORD) to one of the supported modes from time_calls.h
*/ 
#define BIOCSTIMESTAMPMODE CTL_CODE(FILE_DEVICE_TRANSPORT, 0xa12, METHOD_BUFFERED, FILE_READ_DATA)
// Get a list of supported timestamp modes. Output is an array of ULONG. First element is the number of modes supported.
#define BIOCGTIMESTAMPMODES CTL_CODE(FILE_DEVICE_TRANSPORT, 0xa13, METHOD_BUFFERED, FILE_READ_DATA)
/** 
 *  @}
 */

/** 
 *  @}
 */

/* IOCTL codes for driver control */

// Get a list of process IDs which have opened or used handles to the driver.
// Because handles can be inherited, this may not be a complete set.
#define BIOCGETPIDS CTL_CODE(FILE_DEVICE_TRANSPORT, 0xb01, METHOD_BUFFERED, FILE_READ_DATA)

// Get driver info. Valid on any handle in any state.
// Uses PACKET_OID_DATA structure, but instead of OID, we define our own Info IDs here
#define BIOCGETINFO CTL_CODE(FILE_DEVICE_TRANSPORT, 0xb02, METHOD_BUFFERED, FILE_READ_DATA)

#endif //__NPF_IOCTLS_H__

```

`packetWin7/npf/npf/macros.h`:

```h
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
#ifndef __MACRO
#define __MACRO

/* Trace messages for debug build */
#ifdef DBG
#define PRINT_DBG
#endif

#ifdef PRINT_DBG
#define ERROR_DBG(Fmt, ...)   DbgPrintEx( DPFLTR_IHVNETWORK_ID, DPFLTR_ERROR_LEVEL,   __FUNCTION__ ": " Fmt, __VA_ARGS__ )
#define WARNING_DBG(Fmt, ...) DbgPrintEx( DPFLTR_IHVNETWORK_ID, DPFLTR_WARNING_LEVEL, __FUNCTION__ ": " Fmt, __VA_ARGS__ )
#define TRACE_DBG(Fmt, ...)   DbgPrintEx( DPFLTR_IHVNETWORK_ID, DPFLTR_TRACE_LEVEL,   __FUNCTION__ ": " Fmt, __VA_ARGS__ )
#define INFO_DBG(Fmt, ...)    DbgPrintEx( DPFLTR_IHVNETWORK_ID, DPFLTR_INFO_LEVEL,    __FUNCTION__ ": " Fmt, __VA_ARGS__ )
#else
#define ERROR_DBG(Fmt, ...)
#define WARNING_DBG(Fmt, ...)
#define TRACE_DBG(Fmt, ...)
#define INFO_DBG(Fmt, ...)
#endif

#define TRACE_ENTER() TRACE_DBG("ENTER\n")
#define TRACE_EXIT()  TRACE_DBG("EXIT\n")

#pragma pack(push)
#pragma pack (1)

/*
* The number of bytes in an Ethernet (MAC) address.
*/
#define	ETHER_ADDR_LEN		6

/*
* The number of bytes in the type field.
*/
#define	ETHER_TYPE_LEN		2

/*
* The length of the combined header.
*/
#define	ETHER_HDR_LEN		(ETHER_ADDR_LEN * 2 + ETHER_TYPE_LEN)

/* 802.1q header is 4 bytes inserted after the Ethernet destination (6 bytes)
 * and source (6 bytes) */
#define VLAN_HDR_LEN 4

typedef struct _VLAN_HEADER
{
	UCHAR buf[4];
} VLAN_HEADER, *PVLAN_HEADER;
C_ASSERT(sizeof(VLAN_HEADER) == VLAN_HDR_LEN);

#define VLAN_HEADER_VALID(_pV) ((_pV)->buf[0] == 0x81 && (_pV)->buf[1] == 0x00)

#define VLAN_HEADER_TO_QINFO(_pV, _pQ) do { \
	NT_ASSERT(VLAN_HEADER_VALID(_pV)); \
	(_pQ)->TagHeader.UserPriority = ((_pV)->buf[2] & 0xe0) >> 5; \
	(_pQ)->TagHeader.CanonicalFormatId = ((_pV)->buf[2] & 0x10) >> 4; \
	(_pQ)->TagHeader.VlanId = (((_pV)->buf[2] & 0x0f) << 8) + (_pV)->buf[3]; \
} while (0);

#define QINFO_TO_VLAN_HEADER(_pQ, _pV) do { \
	(_pV)->buf[0] = 0x81; \
	(_pV)->buf[1] = 0x00; \
	(_pV)->buf[2] = ((_pQ)->TagHeader.UserPriority & 0x7) << 5 | \
			((_pQ)->TagHeader.CanonicalFormatId & 0x1) << 4 | \
			((_pQ)->TagHeader.VlanId & 0xf00) >> 8; \
	(_pV)->buf[3] = (_pQ->TagHeader.VlanId & 0xff); \
} while (0);

/*
* Structure of a 10Mb/s Ethernet header.
*/
typedef struct _ETHER_HEADER
{
	UCHAR	ether_dhost[ETHER_ADDR_LEN];
	UCHAR	ether_shost[ETHER_ADDR_LEN];
	USHORT	ether_type;
} ETHER_HEADER, *PETHER_HEADER;
C_ASSERT(sizeof(ETHER_HEADER) == ETHER_HDR_LEN);

/* Convenience struct for accessing fields in a 802.1q-tagged Ethernet header
 */
typedef struct _ETHER_VLAN_HEADER
{
	UCHAR ether_dhost[ETHER_ADDR_LEN];
	UCHAR ether_shost[ETHER_ADDR_LEN];
	VLAN_HEADER vlan;
	USHORT ether_type;
} ETHER_VLAN_HEADER, *PETHER_VLAN_HEADER;

/*
* Types in an Ethernet (MAC) header.
*/
#define	ETHERTYPE_PUP		0x0200	/* PUP protocol */
#define	ETHERTYPE_IP		0x0800	/* IP protocol */
#define ETHERTYPE_ARP		0x0806	/* Addr. resolution protocol */
#define ETHERTYPE_REVARP	0x8035	/* reverse Addr. resolution protocol */
#define	ETHERTYPE_VLAN		0x8100	/* IEEE 802.1Q VLAN tagging */
#define ETHERTYPE_IPV6		0x86dd	/* IPv6 */
#define	ETHERTYPE_LOOPBACK	0x9000	/* used to test interfaces */

/*
* Structure of a DLT_NULL header.
*/
typedef struct _DLT_NULL_HEADER
{
	UINT	null_type;
} DLT_NULL_HEADER, *PDLT_NULL_HEADER;

/*
* The length of the combined header.
*/
#define	DLT_NULL_HDR_LEN	sizeof(DLT_NULL_HEADER)

/*
* Types in a DLT_NULL (Loopback) header.
*/
#define	DLTNULLTYPE_IP		0x00000002	/* IP protocol */
#define	DLTNULLTYPE_IPV6	0x00000018	/* IPv6 */

#pragma pack(pop)

/* Interlocked API requires destination to be aligned to 32-bit boundaries.
 * These functions just assert that to catch errors */
#define INTERLOCKED_ALIGNMENT_BYTES 4
#define ASSERT_INTERLOCKED_ALIGNED(_ptr) NT_ASSERT(((ULONG_PTR)_ptr) % INTERLOCKED_ALIGNMENT_BYTES == 0)
inline LONG
NpfInterlockedIncrement (
		_Inout_ _Interlocked_operand_ LONG volatile *Addend
		)
{
	ASSERT_INTERLOCKED_ALIGNED(Addend);
	return InterlockedIncrement(Addend);
}

inline LONG
NpfInterlockedDecrement (
		_Inout_ _Interlocked_operand_ LONG volatile *Addend
		)
{
	ASSERT_INTERLOCKED_ALIGNED(Addend);
	return InterlockedDecrement(Addend);
}

inline LONG
NpfInterlockedExchangeAdd (
		_Inout_ _Interlocked_operand_ LONG volatile *Addend,
		_In_ LONG Value
		)
{
	ASSERT_INTERLOCKED_ALIGNED(Addend);
	return InterlockedExchangeAdd(Addend, Value);
}
#endif

```

`packetWin7/npf/npf/memory_tags.h`:

```h
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
#ifndef __NPCAP_MEMORY_TAGS_H
#define __NPCAP_MEMORY_TAGS_H


// Npcap doesn't need executable allocations
#if(NTDDI_VERSION >= NTDDI_WIN8)
#define NPF_NONPAGED NonPagedPoolNx
#else
/* NonPagedPoolNx is not available for Win7, so avoid warning about it. */
#pragma warning(disable: 30030)
#define NPF_NONPAGED NonPagedPool
#endif
_Must_inspect_result_
_Success_(return != NULL)
__drv_allocatesMem(mem)
inline DECLSPEC_RESTRICT PVOID NPF_AllocateZeroNonpaged(SIZE_T NumBytes, ULONG Tag)
{
#if(NTDDI_VERSION < NTDDI_WIN10_VB) // Windows 10 2004
#pragma warning(suppress: 4996)
	PVOID ret = ExAllocatePoolWithTag(NPF_NONPAGED, NumBytes, Tag);
	if (ret != NULL)
	{
		RtlZeroMemory(ret, NumBytes);
	}
	return ret;
#else
	return ExAllocatePool2(POOL_FLAG_NON_PAGED, NumBytes, Tag);
#endif
}

inline DECLSPEC_RESTRICT PVOID NPF_AllocateZeroPaged(SIZE_T NumBytes, ULONG Tag)
{
#if(NTDDI_VERSION < NTDDI_WIN10_VB) // Windows 10 2004
#pragma warning(suppress: 4996)
	PVOID ret = ExAllocatePoolWithTag(PagedPool, NumBytes, Tag);
	if (ret != NULL)
	{
		RtlZeroMemory(ret, NumBytes);
	}
	return ret;
#else
	return ExAllocatePool2(POOL_FLAG_PAGED, NumBytes, Tag);
#endif
}

// NPCAP_DRIVER_EXTENSION "NpDE"
#define NPF_DRIVER_EXTENSION_TAG 'EDpN'
// UNICODE_STRING::Buffer "NpUB"
#define NPF_UNICODE_BUFFER_TAG 'BUpN'
// Things that are freed within the same function they are allocated in.
// This should probably be used for PagedPool only. "NpST"
#define NPF_SHORT_TERM_TAG 'TSpN'
// BPF filter "NpPF"
#define NPF_BPF_TAG 'FPpN'
// User-submitted OID requests "NpoU"
#define NPF_USER_OID_TAG 'UopN'
// Internally-generated OID requests "NpoI"
#define NPF_INTERNAL_OID_TAG 'IopN'
// Cloned OID requests "NpoC"
#define NPF_CLONE_OID_TAG 'CopN'
// DEVICE_EXTENSION::InternalRequestPool "NpRP"
#define NPF_REQ_POOL_TAG 'PRpN'
// OPEN_INSTANCE "NpOP"
#define NPF_OPEN_TAG 'POpN'
// NPCAP_FILTER_MODULE "NpFM"
#define NPF_FILTMOD_TAG 'MFpN'
// NPCAP_NB_COPIES::Buffer packet data "NpPD"
#define NPF_PACKET_DATA_TAG 'DPpN'
// DEVICE_EXTENSION::NBLCopyPool "NpNL"
#define NPF_NBLC_POOL_TAG 'LNpN'
// DEVICE_EXTENSION::NBCopiesPool "NpNB"
#define NPF_NBC_POOL_TAG 'BNpN'
// DEVICE_EXTENSION::SrcNBPool "NpSN"
#define NPF_SRCNB_POOL_TAG 'NSpN'
// DEVICE_EXTENSION::Dot11HeaderPool and NPCAP_FILTER_MODULE::DataRateMappingTable "Np11"
#define NPF_DOT11_POOL_TAG '11pN'
// DEVICE_EXTENSION::CapturePool "NpCD"
#define NPF_CAP_POOL_TAG 'DCpN'
// NPF_BufferedWrite packet data "NpBW"
#define NPF_BUFFERED_WRITE_TAG 'WBpN'
// Loopback capture packet copy "NpBL"
#define NPF_LOOPBACK_COPY_TAG 'LBpN'
// NPCAP_FILTER_MODULE::PacketPool "NpPP"
#define NPF_PACKET_POOL_TAG 'PPpN'

#endif

```

`packetWin7/npf/npf/npcap.inf`:

```inf
;-------------------------------------------------------------------------
; NPCAP.INF -- Npcap NDIS 6.x LightWeight Filter Driver
;
; Copyright (c) 2025, Nmap Software LLC.  All rights reserved.
;------------------------------------------------------------------------
[version]
Signature       = "$Windows NT$"
Class           = NetService
ClassGUID       = {4D36E974-E325-11CE-BFC1-08002BE10318}
CatalogFile     = %NPF_DriverName%.cat
Provider        = %Insecure%
DriverVer=05/15/2015,14.48.38.905
PnpLockDown=1


[Manufacturer]
%Insecure%=Insecure,NTx86,NTARM64,NTamd64

[Insecure.NTx86]
%NPF_Desc_Standard%=FilterStandard, INSECURE_NPCAP
%NPF_Desc_WiFi%=FilterWiFi, INSECURE_NPCAP_WIFI

[Insecure.NTARM64]
%NPF_Desc_Standard%=FilterStandard, INSECURE_NPCAP
%NPF_Desc_WiFi%=FilterWiFi, INSECURE_NPCAP_WIFI

[Insecure.NTamd64]
%NPF_Desc_Standard%=FilterStandard, INSECURE_NPCAP
%NPF_Desc_WiFi%=FilterWiFi, INSECURE_NPCAP_WIFI

;-------------------------------------------------------------------------
; Installation Section
;-------------------------------------------------------------------------
[FilterStandard]
NetCfgInstanceId="{7daf2ac8-e9f6-4765-a842-f1f5d2501341}"
Copyfiles = npf.copyfiles.sys
Characteristics=0x40000
AddReg=FilterStandard.reg

[FilterWiFi]
NetCfgInstanceId="{7daf2ac8-e9f6-4765-a842-f1f5d2501351}"
Characteristics=0x40000
AddReg=FilterWiFi.reg

[SourceDisksNames]
1=%NPF_Desc_Standard%,"",,

[SourceDisksFiles]
npcap.sys=1

[DestinationDirs]
DefaultDestDir=12
npf.copyfiles.sys=12

[npf.copyfiles.sys]
%NPF_DriverName%.sys,,,2


;-------------------------------------------------------------------------
; Ndi installation support for the standard filter
;-------------------------------------------------------------------------
[FilterStandard.reg]
HKR, Ndi,Service,,%NPF_Filter_Name_Standard%
HKR, Ndi,CoServices,0x00010000,%NPF_Filter_Name_Standard%
HKR, Ndi,HelpText,,%NPF_HelpText_Standard%
HKR, Ndi,FilterClass,, compression


; For a Monitoring filter, use this:
;     HKR, Ndi,FilterType,0x00010001, 1 ; Monitoring filter
; For a Modifying filter, use this:
;     HKR, Ndi,FilterType,0x00010001, 2 ; Modifying filter
HKR, Ndi,FilterType,0x00010001,2


HKR, Ndi\Interfaces,UpperRange, , noupper
HKR, Ndi\Interfaces,LowerRange, , "nolower, ndis5"


; TODO: Ensure that the list of media types below is correct.  Typically,
; filters include "ethernet".  Filters may also include "ppip" to include
; native WWAN stacks, but you must be prepared to handle the packet framing.
; Possible values are listed on MSDN, but common values include:
;     ethernet, wan, ppip, wlan
HKR, Ndi\Interfaces, FilterMediaTypes,,"ethernet, fddi, wan, ppip, wlan, bluetooth, ndis5, vwifi, flpp4, flpp6, vchannel, iovvf, nolower"


; For a Mandatory filter, use this:
;     HKR, Ndi,FilterRunType,0x00010001, 1 ; Mandatory filter
; For an Optional filter, use this:
;     HKR, Ndi,FilterRunType,0x00010001, 2 ; Optional filter
HKR, Ndi,FilterRunType,0x00010001, 2 ; Optional filter


; By default, Mandatory filters unbind all protocols when they are
; installed/uninstalled, while Optional filters merely pause the stack.  If you
; would like to override this behavior, you can include these options.  These
; options only take effect with 6.30 filters on Windows "8" or later.
; To prevent a full unbind, and merely pause/restart protocols:
;     HKR, Ndi,UnbindOnAttach,0x00010001, 0 ; Do not unbind during FilterAttach
;     HKR, Ndi,UnbindOnDetach,0x00010001, 0 ; Do not unbind during FilterDetach
; To force a full unbind/bind (which includes pause/restart, of course):
;     HKR, Ndi,UnbindOnAttach,0x00010001, 1 ; Unbind during FilterAttach
;     HKR, Ndi,UnbindOnDetach,0x00010001, 1 ; Unbind during FilterDetach
;

;-------------------------------------------------------------------------
; Ndi installation support for the WiFi filter
;-------------------------------------------------------------------------
[FilterWiFi.reg]
HKR, Ndi,Service,,%NPF_Filter_Name_WiFi%
HKR, Ndi,CoServices,0x00010000,%NPF_Filter_Name_WiFi%
HKR, Ndi,HelpText,,%NPF_HelpText_WiFi%
HKR, Ndi,FilterClass,, ms_medium_converter_128


; For a Monitoring filter, use this:
;     HKR, Ndi,FilterType,0x00010001, 1 ; Monitoring filter
; For a Modifying filter, use this:
;     HKR, Ndi,FilterType,0x00010001, 2 ; Modifying filter
HKR, Ndi,FilterType,0x00010001,2


HKR, Ndi\Interfaces,UpperRange, , noupper
HKR, Ndi\Interfaces,LowerRange, , nolower


; TODO: Ensure that the list of media types below is correct.  Typically,
; filters include "ethernet".  Filters may also include "ppip" to include
; native WWAN stacks, but you must be prepared to handle the packet framing.
; Possible values are listed on MSDN, but common values include:
;     ethernet, wan, ppip, wlan
HKR, Ndi\Interfaces, FilterMediaTypes,,"wlan"


; For a Mandatory filter, use this:
;     HKR, Ndi,FilterRunType,0x00010001, 1 ; Mandatory filter
; For an Optional filter, use this:
;     HKR, Ndi,FilterRunType,0x00010001, 2 ; Optional filter
HKR, Ndi,FilterRunType,0x00010001, 2 ; Optional filter


; By default, Mandatory filters unbind all protocols when they are
; installed/uninstalled, while Optional filters merely pause the stack.  If you
; would like to override this behavior, you can include these options.  These
; options only take effect with 6.30 filters on Windows "8" or later.
; To prevent a full unbind, and merely pause/restart protocols:
;     HKR, Ndi,UnbindOnAttach,0x00010001, 0 ; Do not unbind during FilterAttach
;     HKR, Ndi,UnbindOnDetach,0x00010001, 0 ; Do not unbind during FilterDetach
; To force a full unbind/bind (which includes pause/restart, of course):
;     HKR, Ndi,UnbindOnAttach,0x00010001, 1 ; Unbind during FilterAttach
;     HKR, Ndi,UnbindOnDetach,0x00010001, 1 ; Unbind during FilterDetach
;

;-------------------------------------------------------------------------
; Service installation support
;-------------------------------------------------------------------------
[FilterStandard.Services]
AddService=%NPF_Filter_Name_Standard%,,FilterStandard.svc

[FilterWiFi.Services]
AddService=%NPF_Filter_Name_WiFi%,,FilterWiFi.svc

[FilterStandard.svc]
DisplayName     = %NPF_Desc_Standard%
ServiceType     = 1 ;SERVICE_KERNEL_DRIVER
StartType       = 1 ;SERVICE_SYSTEM_START
ErrorControl    = 1 ;SERVICE_ERROR_NORMAL
ServiceBinary   = %12%\%NPF_DriverName%.sys
LoadOrderGroup  = NDIS
Description     = %NPF_Desc_Standard%
AddReg          = NpcapConfig.reg, Common.Params.reg, NdisImPlatformBindingOptions.reg

[FilterStandard.Remove.Services]
DelService=%NPF_Filter_Name_Standard%,0x200 ; SPSVCINST_STOPSERVICE

[FilterWiFi.Remove.Services]
DelService=%NPF_Filter_Name_WiFi%,0x200 ; SPSVCINST_STOPSERVICE

[FilterWiFi.svc]
DisplayName     = %NPF_Desc_WiFi%
ServiceType     = 1 ;SERVICE_KERNEL_DRIVER
; We will disable this in installer; InfVerif does not permit StartType=4 here.
StartType       = 3 ;SERVICE_DEMAND_START
ErrorControl    = 1 ;SERVICE_ERROR_NORMAL
ServiceBinary   = %12%\%NPF_DriverName%.sys
LoadOrderGroup  = NDIS
Description     = %NPF_Desc_WiFi%
AddReg          = Common.Params.reg, NdisImPlatformBindingOptions.reg

[NpcapConfig.reg]
HKR, Parameters, LoopbackSupport, 0x00010001, 1
HKR, Parameters, DltNull, 0x00010001, 1
; These parameters may be overwritten by the installer
HKR, Parameters, Edition, , "Npcap"
HKR, Parameters, AdminOnly, 0x00010001, 0
HKR, Parameters, Dot11Support, 0x00010001, 0
; Historical, not used
; HKR, Parameters, VlanSupport, 0x00010001, 0

[Common.Params.reg]

[NdisImPlatformBindingOptions.reg]
; By default, when an LBFO team or Bridge is created, all filters will be
; unbound from the underlying members and bound to the TNic(s). This keyword
; allows a component to opt out of the default behavior
; To prevent binding this filter to the TNic(s):
;   HKR, Parameters, NdisImPlatformBindingOptions,0x00010001,1 ; Do not bind to TNic
; To prevent unbinding this filter from underlying members:
HKR, Parameters, NdisImPlatformBindingOptions,0x00010001,2 ; Do not unbind from Members
; To prevent both binding to TNic and unbinding from members:
;   HKR, Parameters, NdisImPlatformBindingOptions,0x00010001,3 ; Do not bind to TNic or unbind from Members
; HKR, Parameters, NdisImPlatformBindingOptions,0x00010001,0 ; Subscribe to default behavior

[Strings]
NPF_DriverName = "npcap"
NPF_Filter_Name_Standard = "npcap"
NPF_Filter_Name_WiFi = "npcap_wifi"
Insecure = "Nmap Project"
NPF_Desc_Standard = "Npcap Packet Driver (NPCAP)"
NPF_Desc_WiFi = "Npcap Packet Driver (NPCAP) (Wi-Fi)"
NPF_HelpText_Standard = "A NDIS 6 filter driver and WFP callout driver to support packet capturing and sending"
NPF_HelpText_WiFi = "A NDIS 6 filter driver and WFP callout driver (Wi-Fi) to support packet capturing and sending"

```

`packetWin7/npf/npf/npcap.rc`:

```rc
#include <winver.h>
#include "..\..\..\version.h"

/////////////////////////////////////////////////////////////////////////////
//
// Version
//
VS_VERSION_INFO VERSIONINFO
 FILEVERSION WINPCAP_MAJOR,WINPCAP_MINOR,WINPCAP_REV,WINPCAP_BUILD
 PRODUCTVERSION WINPCAP_MAJOR,WINPCAP_MINOR,WINPCAP_REV,WINPCAP_BUILD
 FILEFLAGSMASK VS_FFI_FILEFLAGSMASK
#ifdef DBG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS_NT_WINDOWS32
 FILETYPE VFT_DRV
 FILESUBTYPE VFT2_DRV_SYSTEM
BEGIN
	BLOCK "StringFileInfo"
	BEGIN
		BLOCK "000004b0"
		BEGIN
			VALUE "CompanyName",       WINPCAP_COMPANY_NAME
#ifdef _AMD64_
			VALUE "FileDescription",   "npcap.sys (NT6 AMD64) Kernel Filter Driver"
#else
			VALUE "FileDescription",   "npcap.sys (NT6 x86) Kernel Filter Driver"
#endif
			VALUE "FileVersion",       WINPCAP_VER_STRING
			VALUE "InternalName",      "NPCAP"
			VALUE "LegalCopyright",    WINPCAP_COPYRIGHT_STRING
			VALUE "LegalTrademarks",   ""
			VALUE "OriginalFilename",  "npcap.sys"
			VALUE "ProductName",       WINPCAP_PRODUCT_NAME
			VALUE "ProductVersion",    WINPCAP_VER_STRING
		END
	END
	BLOCK "VarFileInfo"
	BEGIN
		VALUE "Translation", 0x0, 1200
	END
END

```

`packetWin7/npf/npf/npcap_wfp.inf`:

```inf
;-------------------------------------------------------------------------
; NPCAP_WFP.INF -- Npcap NDIS 6.x LightWeight Filter Driver
;
; Copyright (c) 2025, Nmap Software LLC.  All rights reserved.
;------------------------------------------------------------------------
[version]
Signature       = "$Windows NT$"
Class           = WFPCALLOUTS
ClassGUID       = {57465043-616C-6C6F-7574-5F636C617373}
CatalogFile     = %NPF_DriverName%.cat
Provider        = %Insecure%
DriverVer=05/15/2015,14.48.38.905
PnpLockDown=1


[Manufacturer]
%Insecure%=Insecure,NTx86,NTARM64,NTamd64

[Insecure.NTx86]
%NPF_Desc%=Install, INSECURE_NPCAP

[Insecure.NTARM64]
%NPF_Desc%=Install, INSECURE_NPCAP

[Insecure.NTamd64]
%NPF_Desc%=Install, INSECURE_NPCAP

;-------------------------------------------------------------------------
; Installation Section
;-------------------------------------------------------------------------
[Install]
AddReg=Inst_Ndi
Characteristics=0x40000
NetCfgInstanceId="{7daf2ac8-e9f6-4765-a842-f1f5d2501341}"
Copyfiles = npf.copyfiles.sys

[SourceDisksNames]
1=%NPF_Desc%,"",,

[SourceDisksFiles]
npcap.sys=1

[DestinationDirs]
DefaultDestDir=12
npf.copyfiles.sys=12

[npf.copyfiles.sys]
%NPF_DriverName%.sys,,,2


;-------------------------------------------------------------------------
; Ndi installation support
;-------------------------------------------------------------------------
[Inst_Ndi]
HKR, Ndi,Service,,%NPF_DriverName%
HKR, Ndi,CoServices,0x00010000,%NPF_DriverName%
HKR, Ndi,HelpText,,%NPF_HelpText%

;-------------------------------------------------------------------------
; Service installation support
;-------------------------------------------------------------------------
[Install.Services]
AddService=%NPF_DriverName%,,NPF_Service_Inst
AddService=,2

[NPF_Service_Inst]
DisplayName     = %NPF_Desc%
ServiceType     = 1 ;SERVICE_KERNEL_DRIVER
StartType       = 1 ;SERVICE_SYSTEM_START
ErrorControl    = 1 ;SERVICE_ERROR_NORMAL
ServiceBinary   = %12%\%NPF_DriverName%.sys
LoadOrderGroup  = NDIS
Description     = %NPF_Desc%
AddReg          = Common.Params.reg

[Common.Params.reg]

[Strings]
NPF_DriverName = "npcap"
Insecure = "Nmap Project"
NPF_Desc = "Npcap Packet Driver (NPCAP)"
NPF_HelpText = "A NDIS 6 filter driver & WFP callout driver to support packet capturing and sending under Windows 7, 8 & 10"

```

`packetWin7/npf/npf/npf.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Win10 Debug|ARM64">
      <Configuration>Win10 Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win10 Debug|Win32">
      <Configuration>Win10 Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win10 Debug|x64">
      <Configuration>Win10 Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win10 OEM Debug|ARM64">
      <Configuration>Win10 OEM Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win10 OEM Debug|Win32">
      <Configuration>Win10 OEM Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win10 OEM Debug|x64">
      <Configuration>Win10 OEM Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win10 OEM Release|ARM64">
      <Configuration>Win10 OEM Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win10 OEM Release|Win32">
      <Configuration>Win10 OEM Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win10 OEM Release|x64">
      <Configuration>Win10 OEM Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win10 OEM RO Release|ARM64">
      <Configuration>Win10 OEM RO Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win10 OEM RO Release|Win32">
      <Configuration>Win10 OEM RO Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win10 OEM RO Release|x64">
      <Configuration>Win10 OEM RO Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win10 Release|ARM64">
      <Configuration>Win10 Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win10 Release|Win32">
      <Configuration>Win10 Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win10 Release|x64">
      <Configuration>Win10 Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 Debug|ARM64">
      <Configuration>Win7 Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 OEM Debug|ARM64">
      <Configuration>Win7 OEM Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 OEM Debug|Win32">
      <Configuration>Win7 OEM Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 OEM Debug|x64">
      <Configuration>Win7 OEM Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 OEM Release|ARM64">
      <Configuration>Win7 OEM Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 OEM RO Release|ARM64">
      <Configuration>Win7 OEM RO Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 OEM RO Release|Win32">
      <Configuration>Win7 OEM RO Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 OEM RO Release|x64">
      <Configuration>Win7 OEM RO Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 OEM Release|Win32">
      <Configuration>Win7 OEM Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 OEM Release|x64">
      <Configuration>Win7 OEM Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 Release SDV|ARM64">
      <Configuration>Win7 Release SDV</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 Release SDV|Win32">
      <Configuration>Win7 Release SDV</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 Release SDV|x64">
      <Configuration>Win7 Release SDV</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 Debug|Win32">
      <Configuration>Win7 Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 Release|ARM64">
      <Configuration>Win7 Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 Release|Win32">
      <Configuration>Win7 Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 Debug|x64">
      <Configuration>Win7 Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 Release|x64">
      <Configuration>Win7 Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win8 Debug|ARM64">
      <Configuration>Win8 Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win8 Debug|Win32">
      <Configuration>Win8 Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win8 Debug|x64">
      <Configuration>Win8 Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win8 OEM Release|ARM64">
      <Configuration>Win8 OEM Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win8 OEM Release|Win32">
      <Configuration>Win8 OEM Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win8 OEM Release|x64">
      <Configuration>Win8 OEM Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win8 OEM RO Release|ARM64">
      <Configuration>Win8 OEM RO Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win8 OEM RO Release|Win32">
      <Configuration>Win8 OEM RO Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win8 OEM RO Release|x64">
      <Configuration>Win8 OEM RO Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win8 Release|ARM64">
      <Configuration>Win8 Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win8 Release|Win32">
      <Configuration>Win8 Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win8 Release|x64">
      <Configuration>Win8 Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Win8 Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
  </PropertyGroup>
  <PropertyGroup Label="Globals">
    <RootNamespace>npf</RootNamespace>
  </PropertyGroup>
  <PropertyGroup Label="PropertySheets">
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration.Substring(0,5))' == 'Win10'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration.Substring(0,4))' == 'Win8'" Label="Configuration">
    <TargetVersion>Windows8</TargetVersion>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration.Substring(0,4))' == 'Win7'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Debug|Win32'" Label="Configuration">
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM Debug|Win32'" Label="Configuration">
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release|Win32'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Release|Win32'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Debug|Win32'" Label="Configuration">
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 OEM Release|Win32'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 OEM RO Release|Win32'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 Release|Win32'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 Debug|Win32'" Label="Configuration">
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM Debug|Win32'" Label="Configuration">
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM Release|Win32'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM RO Release|Win32'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM Release|Win32'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM RO Release|Win32'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release SDV|Win32'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Debug|x64'" Label="Configuration">
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Debug|ARM64'" Label="Configuration">
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM Debug|x64'" Label="Configuration">
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM Debug|ARM64'" Label="Configuration">
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release|x64'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release|ARM64'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Release|x64'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Debug|x64'" Label="Configuration">
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 OEM Release|x64'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 OEM RO Release|x64'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Release|ARM64'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Debug|ARM64'" Label="Configuration">
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 OEM Release|ARM64'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 OEM RO Release|ARM64'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 Release|x64'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 Release|ARM64'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 Debug|x64'" Label="Configuration">
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 Debug|ARM64'" Label="Configuration">
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM Debug|x64'" Label="Configuration">
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM Debug|ARM64'" Label="Configuration">
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM Release|x64'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM Release|ARM64'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM RO Release|x64'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM RO Release|ARM64'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM Release|x64'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM Release|ARM64'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM RO Release|x64'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM RO Release|ARM64'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release SDV|x64'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release SDV|ARM64'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(TargetVersion)'=='Windows7'">
    <_NT_TARGET_VERSION>0x0601</_NT_TARGET_VERSION>
  </PropertyGroup>
  <PropertyGroup Condition="'$(TargetVersion)'=='Windows8'">
    <_NT_TARGET_VERSION>0x0602</_NT_TARGET_VERSION>
  </PropertyGroup>
  <PropertyGroup Condition="'$(TargetVersion)'=='Windows10'">
    <_NT_TARGET_VERSION>0x0A00</_NT_TARGET_VERSION>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Debug|Win32'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir>$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM Debug|Win32'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir>$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release|Win32'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir>$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Release|Win32'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir>$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Debug|Win32'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir>$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 OEM Release|Win32'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir>$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 OEM RO Release|Win32'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir>$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 Release|Win32'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir>$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 Debug|Win32'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir>$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM Debug|Win32'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir>$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM Release|Win32'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir>$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM RO Release|Win32'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir>$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM Release|Win32'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir>$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM RO Release|Win32'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir>$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release SDV|Win32'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir>$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Debug|x64'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Debug|ARM64'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM Debug|x64'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM Debug|ARM64'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release|x64'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release|ARM64'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Release|x64'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Debug|x64'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 OEM Release|x64'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 OEM RO Release|x64'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Release|ARM64'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Debug|ARM64'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 OEM Release|ARM64'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 OEM RO Release|ARM64'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 Release|x64'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 Release|ARM64'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 Debug|x64'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 Debug|ARM64'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM Debug|x64'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM Debug|ARM64'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM Release|x64'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM Release|ARM64'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM RO Release|x64'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM RO Release|ARM64'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM Release|x64'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM Release|ARM64'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM RO Release|x64'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM RO Release|ARM64'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release SDV|x64'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release SDV|ARM64'">
    <TargetName>npcap</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PreprocessorDefinitions>WIN9X_COMPAT_SPINLOCK;HAVE_WFP_LOOPBACK_SUPPORT;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;DBG=1;STD_CALL;%(PreprocessorDefinitions);NDIS620;WINVER=0x0601;_WIN32_WINNT=0x0601;NTDDI_VERSION=0x06010000</PreprocessorDefinitions>
      <InlineFunctionExpansion>Disabled</InlineFunctionExpansion>
      <IntrinsicFunctions>false</IntrinsicFunctions>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PreprocessorDefinitions>NPCAP_OEM;WIN9X_COMPAT_SPINLOCK;HAVE_WFP_LOOPBACK_SUPPORT;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;DBG=1;STD_CALL;%(PreprocessorDefinitions);NDIS620;WINVER=0x0601;_WIN32_WINNT=0x0601;NTDDI_VERSION=0x06010000</PreprocessorDefinitions>
      <InlineFunctionExpansion>Disabled</InlineFunctionExpansion>
      <IntrinsicFunctions>false</IntrinsicFunctions>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PreprocessorDefinitions>WIN9X_COMPAT_SPINLOCK;HAVE_WFP_LOOPBACK_SUPPORT;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;DBG=1;%(PreprocessorDefinitions);NDIS620;WINVER=0x0601;_WIN32_WINNT=0x0601;NTDDI_VERSION=0x06010000</PreprocessorDefinitions>
      <IntrinsicFunctions>false</IntrinsicFunctions>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Debug|ARM64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PreprocessorDefinitions>WIN9X_COMPAT_SPINLOCK;HAVE_WFP_LOOPBACK_SUPPORT;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;DBG=1;%(PreprocessorDefinitions);NDIS620;WINVER=0x0601;_WIN32_WINNT=0x0601;NTDDI_VERSION=0x06010000</PreprocessorDefinitions>
      <IntrinsicFunctions>false</IntrinsicFunctions>
      <WholeProgramOptimization>true</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PreprocessorDefinitions>NPCAP_OEM;WIN9X_COMPAT_SPINLOCK;HAVE_WFP_LOOPBACK_SUPPORT;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;DBG=1;%(PreprocessorDefinitions);NDIS620;WINVER=0x0601;_WIN32_WINNT=0x0601;NTDDI_VERSION=0x06010000</PreprocessorDefinitions>
      <IntrinsicFunctions>false</IntrinsicFunctions>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM Debug|ARM64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PreprocessorDefinitions>NPCAP_OEM;WIN9X_COMPAT_SPINLOCK;HAVE_WFP_LOOPBACK_SUPPORT;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;DBG=1;%(PreprocessorDefinitions);NDIS620;WINVER=0x0601;_WIN32_WINNT=0x0601;NTDDI_VERSION=0x06010000</PreprocessorDefinitions>
      <IntrinsicFunctions>false</IntrinsicFunctions>
      <WholeProgramOptimization>true</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PreprocessorDefinitions>WIN9X_COMPAT_SPINLOCK;HAVE_WFP_LOOPBACK_SUPPORT;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;STD_CALL;%(PreprocessorDefinitions);NDIS620;WINVER=0x0601;_WIN32_WINNT=0x0601;NTDDI_VERSION=0x06010000</PreprocessorDefinitions>
      <WholeProgramOptimization>true</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PreprocessorDefinitions>HAVE_WFP_LOOPBACK_SUPPORT;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;NDIS630=1;WINVER=0x0602;_WIN32_WINNT=0x0602;NTDDI_VERSION=0x06020000;STD_CALL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <WholeProgramOptimization>true</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PreprocessorDefinitions>DBG=1;HAVE_WFP_LOOPBACK_SUPPORT;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;NDIS630=1;WINVER=0x0602;_WIN32_WINNT=0x0602;NTDDI_VERSION=0x06020000;STD_CALL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win8 OEM Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PreprocessorDefinitions>HAVE_WFP_LOOPBACK_SUPPORT;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;NDIS630=1;WINVER=0x0602;_WIN32_WINNT=0x0602;NTDDI_VERSION=0x06020000;NPCAP_OEM;STD_CALL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <WholeProgramOptimization>true</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win8 OEM RO Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PreprocessorDefinitions>HAVE_WFP_LOOPBACK_SUPPORT;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;NDIS630=1;WINVER=0x0602;_WIN32_WINNT=0x0602;NTDDI_VERSION=0x06020000;NPCAP_OEM;NPCAP_READ_ONLY;STD_CALL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <WholeProgramOptimization>true</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win10 Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PreprocessorDefinitions>HAVE_WFP_LOOPBACK_SUPPORT;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;STD_CALL;%(PreprocessorDefinitions);NDIS650;NDIS685;NDIS689;WINVER=0x0A00;_WIN32_WINNT=0x0A00;NTDDI_VERSION=0x0A000000</PreprocessorDefinitions>
      <WholeProgramOptimization>true</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win10 Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PreprocessorDefinitions>HAVE_WFP_LOOPBACK_SUPPORT;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;DBG=1;STD_CALL;%(PreprocessorDefinitions);NDIS650;NDIS685;NDIS689;WINVER=0x0A00;_WIN32_WINNT=0x0A00;NTDDI_VERSION=0x0A000000</PreprocessorDefinitions>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PreprocessorDefinitions>NPCAP_OEM;HAVE_WFP_LOOPBACK_SUPPORT;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;DBG=1;STD_CALL;%(PreprocessorDefinitions);NDIS650;NDIS685;NDIS689;WINVER=0x0A00;_WIN32_WINNT=0x0A00;NTDDI_VERSION=0x0A000000</PreprocessorDefinitions>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PreprocessorDefinitions>NPCAP_OEM;HAVE_WFP_LOOPBACK_SUPPORT;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;STD_CALL;%(PreprocessorDefinitions);NDIS650;NDIS685;NDIS689;WINVER=0x0A00;_WIN32_WINNT=0x0A00;NTDDI_VERSION=0x0A000000</PreprocessorDefinitions>
      <WholeProgramOptimization>true</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM RO Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PreprocessorDefinitions>NPCAP_OEM;NPCAP_READ_ONLY;HAVE_WFP_LOOPBACK_SUPPORT;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;STD_CALL;%(PreprocessorDefinitions);NDIS650;NDIS685;NDIS689;WINVER=0x0A00;_WIN32_WINNT=0x0A00;NTDDI_VERSION=0x0A000000</PreprocessorDefinitions>
      <WholeProgramOptimization>true</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PreprocessorDefinitions>WIN9X_COMPAT_SPINLOCK;NPCAP_OEM;HAVE_WFP_LOOPBACK_SUPPORT;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;STD_CALL;%(PreprocessorDefinitions);NDIS620;WINVER=0x0601;_WIN32_WINNT=0x0601;NTDDI_VERSION=0x06010000</PreprocessorDefinitions>
      <WholeProgramOptimization>true</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM RO Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PreprocessorDefinitions>WIN9X_COMPAT_SPINLOCK;NPCAP_OEM;NPCAP_READ_ONLY;HAVE_WFP_LOOPBACK_SUPPORT;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;STD_CALL;%(PreprocessorDefinitions);NDIS620;WINVER=0x0601;_WIN32_WINNT=0x0601;NTDDI_VERSION=0x06010000</PreprocessorDefinitions>
      <WholeProgramOptimization>true</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release SDV|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PreprocessorDefinitions>WIN9X_COMPAT_SPINLOCK;NDIS_WDM=1;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;STD_CALL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <WholeProgramOptimization>true</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <ResourceCompile>
      <AdditionalIncludeDirectories>$(UM_IncludePath)</AdditionalIncludeDirectories>
    </ResourceCompile>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release|x64'">
    <ClCompile>
      <PreprocessorDefinitions>WIN9X_COMPAT_SPINLOCK;HAVE_WFP_LOOPBACK_SUPPORT;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;%(PreprocessorDefinitions);NDIS620;WINVER=0x0601;_WIN32_WINNT=0x0601;NTDDI_VERSION=0x06010000</PreprocessorDefinitions>
      <WarningLevel>Level3</WarningLevel>
      <WholeProgramOptimization>true</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release|ARM64'">
    <ClCompile>
      <PreprocessorDefinitions>WIN9X_COMPAT_SPINLOCK;HAVE_WFP_LOOPBACK_SUPPORT;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;%(PreprocessorDefinitions);NDIS620;WINVER=0x0601;_WIN32_WINNT=0x0601;NTDDI_VERSION=0x06010000</PreprocessorDefinitions>
      <WarningLevel>Level3</WarningLevel>
      <WholeProgramOptimization>true</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Release|x64'">
    <ClCompile>
      <PreprocessorDefinitions>HAVE_WFP_LOOPBACK_SUPPORT;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;NDIS630=1;WINVER=0x0602;_WIN32_WINNT=0x0602;NTDDI_VERSION=0x06020000;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <WarningLevel>Level3</WarningLevel>
      <WholeProgramOptimization>true</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Debug|x64'">
    <ClCompile>
      <PreprocessorDefinitions>DBG=1;HAVE_WFP_LOOPBACK_SUPPORT;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;NDIS630=1;WINVER=0x0602;_WIN32_WINNT=0x0602;NTDDI_VERSION=0x06020000;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <WarningLevel>Level3</WarningLevel>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win8 OEM Release|x64'">
    <ClCompile>
      <PreprocessorDefinitions>HAVE_WFP_LOOPBACK_SUPPORT;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;NDIS630=1;WINVER=0x0602;_WIN32_WINNT=0x0602;NTDDI_VERSION=0x06020000;NPCAP_OEM;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <WarningLevel>Level3</WarningLevel>
      <WholeProgramOptimization>true</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win8 OEM RO Release|x64'">
    <ClCompile>
      <PreprocessorDefinitions>HAVE_WFP_LOOPBACK_SUPPORT;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;NDIS630=1;WINVER=0x0602;_WIN32_WINNT=0x0602;NTDDI_VERSION=0x06020000;NPCAP_OEM;NPCAP_READ_ONLY;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <WarningLevel>Level3</WarningLevel>
      <WholeProgramOptimization>true</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Release|ARM64'">
    <ClCompile>
      <PreprocessorDefinitions>HAVE_WFP_LOOPBACK_SUPPORT;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;NDIS630=1;WINVER=0x0602;_WIN32_WINNT=0x0602;NTDDI_VERSION=0x06020000;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <WarningLevel>Level3</WarningLevel>
      <WholeProgramOptimization>true</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Debug|ARM64'">
    <ClCompile>
      <PreprocessorDefinitions>DBG=1;HAVE_WFP_LOOPBACK_SUPPORT;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;NDIS630=1;WINVER=0x0602;_WIN32_WINNT=0x0602;NTDDI_VERSION=0x06020000;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <WarningLevel>Level3</WarningLevel>
      <WholeProgramOptimization>true</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win8 OEM Release|ARM64'">
    <ClCompile>
      <PreprocessorDefinitions>HAVE_WFP_LOOPBACK_SUPPORT;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;NDIS630=1;WINVER=0x0602;_WIN32_WINNT=0x0602;NTDDI_VERSION=0x06020000;NPCAP_OEM;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <WarningLevel>Level3</WarningLevel>
      <WholeProgramOptimization>true</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win8 OEM RO Release|ARM64'">
    <ClCompile>
      <PreprocessorDefinitions>HAVE_WFP_LOOPBACK_SUPPORT;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;NDIS630=1;WINVER=0x0602;_WIN32_WINNT=0x0602;NTDDI_VERSION=0x06020000;NPCAP_OEM;NPCAP_READ_ONLY;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <WarningLevel>Level3</WarningLevel>
      <WholeProgramOptimization>true</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win10 Release|x64'">
    <ClCompile>
      <PreprocessorDefinitions>HAVE_WFP_LOOPBACK_SUPPORT;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;%(PreprocessorDefinitions);NDIS650;NDIS685;NDIS689;WINVER=0x0A00;_WIN32_WINNT=0x0A00;NTDDI_VERSION=0x0A000000</PreprocessorDefinitions>
      <WarningLevel>Level3</WarningLevel>
      <WholeProgramOptimization>true</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win10 Release|ARM64'">
    <ClCompile>
      <PreprocessorDefinitions>HAVE_WFP_LOOPBACK_SUPPORT;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;%(PreprocessorDefinitions);NDIS650;NDIS685;NDIS689;WINVER=0x0A00;_WIN32_WINNT=0x0A00;NTDDI_VERSION=0x0A000000</PreprocessorDefinitions>
      <WarningLevel>Level3</WarningLevel>
      <WholeProgramOptimization>true</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win10 Debug|x64'">
    <ClCompile>
      <PreprocessorDefinitions>HAVE_WFP_LOOPBACK_SUPPORT;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;DBG=1;%(PreprocessorDefinitions);NDIS650;NDIS685;NDIS689;WINVER=0x0A00;_WIN32_WINNT=0x0A00;NTDDI_VERSION=0x0A000000</PreprocessorDefinitions>
      <WarningLevel>Level3</WarningLevel>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win10 Debug|ARM64'">
    <ClCompile>
      <PreprocessorDefinitions>HAVE_WFP_LOOPBACK_SUPPORT;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;DBG=1;%(PreprocessorDefinitions);NDIS650;NDIS685;NDIS689;WINVER=0x0A00;_WIN32_WINNT=0x0A00;NTDDI_VERSION=0x0A000000</PreprocessorDefinitions>
      <WarningLevel>Level3</WarningLevel>
      <WholeProgramOptimization>true</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM Debug|x64'">
    <ClCompile>
      <PreprocessorDefinitions>NPCAP_OEM;HAVE_WFP_LOOPBACK_SUPPORT;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;DBG=1;%(PreprocessorDefinitions);NDIS650;NDIS685;NDIS689;WINVER=0x0A00;_WIN32_WINNT=0x0A00;NTDDI_VERSION=0x0A000000</PreprocessorDefinitions>
      <WarningLevel>Level3</WarningLevel>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM Debug|ARM64'">
    <ClCompile>
      <PreprocessorDefinitions>NPCAP_OEM;HAVE_WFP_LOOPBACK_SUPPORT;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;DBG=1;%(PreprocessorDefinitions);NDIS650;NDIS685;NDIS689;WINVER=0x0A00;_WIN32_WINNT=0x0A00;NTDDI_VERSION=0x0A000000</PreprocessorDefinitions>
      <WarningLevel>Level3</WarningLevel>
      <WholeProgramOptimization>true</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM Release|x64'">
    <ClCompile>
      <PreprocessorDefinitions>NPCAP_OEM;HAVE_WFP_LOOPBACK_SUPPORT;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;%(PreprocessorDefinitions);NDIS650;NDIS685;NDIS689;WINVER=0x0A00;_WIN32_WINNT=0x0A00;NTDDI_VERSION=0x0A000000</PreprocessorDefinitions>
      <WarningLevel>Level3</WarningLevel>
      <WholeProgramOptimization>true</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM Release|ARM64'">
    <ClCompile>
      <PreprocessorDefinitions>NPCAP_OEM;HAVE_WFP_LOOPBACK_SUPPORT;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;%(PreprocessorDefinitions);NDIS650;NDIS685;NDIS689;WINVER=0x0A00;_WIN32_WINNT=0x0A00;NTDDI_VERSION=0x0A000000</PreprocessorDefinitions>
      <WarningLevel>Level3</WarningLevel>
      <WholeProgramOptimization>true</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM RO Release|x64'">
    <ClCompile>
      <PreprocessorDefinitions>NPCAP_OEM;NPCAP_READ_ONLY;HAVE_WFP_LOOPBACK_SUPPORT;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;%(PreprocessorDefinitions);NDIS650;NDIS685;NDIS689;WINVER=0x0A00;_WIN32_WINNT=0x0A00;NTDDI_VERSION=0x0A000000</PreprocessorDefinitions>
      <WarningLevel>Level3</WarningLevel>
      <WholeProgramOptimization>true</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win10 OEM RO Release|ARM64'">
    <ClCompile>
      <PreprocessorDefinitions>NPCAP_OEM;NPCAP_READ_ONLY;HAVE_WFP_LOOPBACK_SUPPORT;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;%(PreprocessorDefinitions);NDIS650;NDIS685;NDIS689;WINVER=0x0A00;_WIN32_WINNT=0x0A00;NTDDI_VERSION=0x0A000000</PreprocessorDefinitions>
      <WarningLevel>Level3</WarningLevel>
      <WholeProgramOptimization>true</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM Release|x64'">
    <ClCompile>
      <PreprocessorDefinitions>WIN9X_COMPAT_SPINLOCK;NPCAP_OEM;HAVE_WFP_LOOPBACK_SUPPORT;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;%(PreprocessorDefinitions);NDIS620;WINVER=0x0601;_WIN32_WINNT=0x0601;NTDDI_VERSION=0x06010000</PreprocessorDefinitions>
      <WarningLevel>Level3</WarningLevel>
      <WholeProgramOptimization>true</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM Release|ARM64'">
    <ClCompile>
      <PreprocessorDefinitions>WIN9X_COMPAT_SPINLOCK;NPCAP_OEM;HAVE_WFP_LOOPBACK_SUPPORT;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;%(PreprocessorDefinitions);NDIS620;WINVER=0x0601;_WIN32_WINNT=0x0601;NTDDI_VERSION=0x06010000</PreprocessorDefinitions>
      <WarningLevel>Level3</WarningLevel>
      <WholeProgramOptimization>true</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM RO Release|x64'">
    <ClCompile>
      <PreprocessorDefinitions>WIN9X_COMPAT_SPINLOCK;NPCAP_OEM;NPCAP_READ_ONLY;HAVE_WFP_LOOPBACK_SUPPORT;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;%(PreprocessorDefinitions);NDIS620;WINVER=0x0601;_WIN32_WINNT=0x0601;NTDDI_VERSION=0x06010000</PreprocessorDefinitions>
      <WarningLevel>Level3</WarningLevel>
      <WholeProgramOptimization>true</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 OEM RO Release|ARM64'">
    <ClCompile>
      <PreprocessorDefinitions>WIN9X_COMPAT_SPINLOCK;NPCAP_OEM;NPCAP_READ_ONLY;HAVE_WFP_LOOPBACK_SUPPORT;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;%(PreprocessorDefinitions);NDIS620;WINVER=0x0601;_WIN32_WINNT=0x0601;NTDDI_VERSION=0x06010000</PreprocessorDefinitions>
      <WarningLevel>Level3</WarningLevel>
      <WholeProgramOptimization>true</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release SDV|x64'">
    <ClCompile>
      <PreprocessorDefinitions>WIN9X_COMPAT_SPINLOCK;NDIS_WDM=1;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <WarningLevel>Level3</WarningLevel>
      <WholeProgramOptimization>true</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <ResourceCompile>
      <AdditionalIncludeDirectories>$(UM_IncludePath)</AdditionalIncludeDirectories>
    </ResourceCompile>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release SDV|ARM64'">
    <ClCompile>
      <PreprocessorDefinitions>WIN9X_COMPAT_SPINLOCK;NDIS_WDM=1;HAVE_RX_SUPPORT;HAVE_DOT11_SUPPORT;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <WarningLevel>Level3</WarningLevel>
      <WholeProgramOptimization>true</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <AdditionalDependencies>wdmsec.lib;ndis.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
    </Link>
    <ResourceCompile>
      <AdditionalIncludeDirectories>$(UM_IncludePath)</AdditionalIncludeDirectories>
    </ResourceCompile>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
    <FilesToPackage Include="@(Inf->'%(CopyOutput)')" Condition="'@(Inf)'!=''" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Loopback.c" />
    <ClCompile Include="Openclos.c" />
    <ClCompile Include="Packet.c" />
    <ClCompile Include="Read.c" />
    <ClCompile Include="win_bpf_filter.c" />
    <ClCompile Include="Write.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ieee80211_radiotap.h" />
    <ClInclude Include="ioctls.h" />
    <ClInclude Include="Loopback.h" />
    <ClInclude Include="macros.h" />
    <ClInclude Include="Packet.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="time_calls.h" />
    <ClInclude Include="valid_insns.h" />
    <ClInclude Include="win_bpf.h" />
  </ItemGroup>
  <ItemGroup>
    <Inf Include="npcap.inf" Condition="'$(Configuration)'=='Win7 Debug'" />
    <Inf Include="npcap.inf" Condition="'$(Configuration)'=='Win7 OEM Debug'" />
    <Inf Include="npcap.inf" Condition="'$(Configuration)'=='Win7 Release'" />
    <Inf Include="npcap.inf" Condition="'$(Configuration)'=='Win8 Release'" />
    <Inf Include="npcap.inf" Condition="'$(Configuration)'=='Win8 Debug'" />
    <Inf Include="npcap.inf" Condition="'$(Configuration)'=='Win8 OEM Release'" />
    <Inf Include="npcap.inf" Condition="'$(Configuration)'=='Win8 OEM RO Release'" />
    <Inf Include="npcap.inf" Condition="'$(Configuration)'=='Win10 Release'" />
    <Inf Include="npcap.inf" Condition="'$(Configuration)'=='Win10 Debug'" />
    <Inf Include="npcap.inf" Condition="'$(Configuration)'=='Win10 OEM Debug'" />
    <Inf Include="npcap.inf" Condition="'$(Configuration)'=='Win10 OEM Release'" />
    <Inf Include="npcap.inf" Condition="'$(Configuration)'=='Win10 OEM RO Release'" />
    <Inf Include="npcap.inf" Condition="'$(Configuration)'=='Win7 OEM Release'" />
    <Inf Include="npcap.inf" Condition="'$(Configuration)'=='Win7 OEM RO Release'" />
    <Inf Include="npcap.inf" Condition="'$(Configuration)'=='Win7 Release SDV'" />
    <Inf Include="npcap_wfp.inf" Condition="'$(Configuration)'=='Win7 Debug'" />
    <Inf Include="npcap_wfp.inf" Condition="'$(Configuration)'=='Win7 OEM Debug'" />
    <Inf Include="npcap_wfp.inf" Condition="'$(Configuration)'=='Win7 Release'" />
    <Inf Include="npcap_wfp.inf" Condition="'$(Configuration)'=='Win8 Release'" />
    <Inf Include="npcap_wfp.inf" Condition="'$(Configuration)'=='Win8 Debug'" />
    <Inf Include="npcap_wfp.inf" Condition="'$(Configuration)'=='Win8 OEM Release'" />
    <Inf Include="npcap_wfp.inf" Condition="'$(Configuration)'=='Win8 OEM RO Release'" />
    <Inf Include="npcap_wfp.inf" Condition="'$(Configuration)'=='Win10 Release'" />
    <Inf Include="npcap_wfp.inf" Condition="'$(Configuration)'=='Win10 Debug'" />
    <Inf Include="npcap_wfp.inf" Condition="'$(Configuration)'=='Win10 OEM Debug'" />
    <Inf Include="npcap_wfp.inf" Condition="'$(Configuration)'=='Win10 OEM Release'" />
    <Inf Include="npcap_wfp.inf" Condition="'$(Configuration)'=='Win10 OEM RO Release'" />
    <Inf Include="npcap_wfp.inf" Condition="'$(Configuration)'=='Win7 OEM Release'" />
    <Inf Include="npcap_wfp.inf" Condition="'$(Configuration)'=='Win7 OEM RO Release'" />
    <Inf Include="npcap_wfp.inf" Condition="'$(Configuration)'=='Win7 Release SDV'" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="npcap.rc" Condition="'$(Configuration)'=='Win7 Debug'" />
    <ResourceCompile Include="npcap.rc" Condition="'$(Configuration)'=='Win7 OEM Debug'" />
    <ResourceCompile Include="npcap.rc" Condition="'$(Configuration)'=='Win7 Release'" />
    <ResourceCompile Include="npcap.rc" Condition="'$(Configuration)'=='Win8 Release'" />
    <ResourceCompile Include="npcap.rc" Condition="'$(Configuration)'=='Win8 Debug'" />
    <ResourceCompile Include="npcap.rc" Condition="'$(Configuration)'=='Win8 OEM Release'" />
    <ResourceCompile Include="npcap.rc" Condition="'$(Configuration)'=='Win8 OEM RO Release'" />
    <ResourceCompile Include="npcap.rc" Condition="'$(Configuration)'=='Win10 Release'" />
    <ResourceCompile Include="npcap.rc" Condition="'$(Configuration)'=='Win10 Debug'" />
    <ResourceCompile Include="npcap.rc" Condition="'$(Configuration)'=='Win10 OEM Debug'" />
    <ResourceCompile Include="npcap.rc" Condition="'$(Configuration)'=='Win10 OEM Release'" />
    <ResourceCompile Include="npcap.rc" Condition="'$(Configuration)'=='Win10 OEM RO Release'" />
    <ResourceCompile Include="npcap.rc" Condition="'$(Configuration)'=='Win7 OEM Release'" />
    <ResourceCompile Include="npcap.rc" Condition="'$(Configuration)'=='Win7 OEM RO Release'" />
    <ResourceCompile Include="npcap.rc" Condition="'$(Configuration)'=='Win7 Release SDV'" />
  </ItemGroup>
  <ItemGroup>
    <None Include="cpp.hint" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`packetWin7/npf/npf/npf.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="Loopback.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Openclos.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Packet.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Read.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="win_bpf_filter.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Write.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ieee80211_radiotap.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ioctls.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Loopback.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="macros.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Packet.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="time_calls.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valid_insns.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="win_bpf.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="npcap.inf">
      <Filter>Driver Files</Filter>
    </Inf>
    <Inf Include="npcap_wfp.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{5481204c-ccff-42d5-ac09-0a194cc3cf17}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{a7428563-a40c-41d0-924b-d9d4c19fbc02}</UniqueIdentifier>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{bb3bdb45-b66d-4ceb-9cae-41d99d8bda6e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files">
      <UniqueIdentifier>{41d550b0-0cfb-4e43-b66c-30757a553772}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="npcap.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="cpp.hint" />
  </ItemGroup>
</Project>
```

`packetWin7/npf/npf/stdafx.h`:

```h
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/

#define NPF_REQUEST_ID '5678'

#define INVALID_HANDLE_VALUE ((HANDLE)(LONG_PTR)-1)

#include <ntifs.h>
#include <ntddk.h>
#include <ndis.h>
#include <wdmsec.h>
#include <wdmguid.h>
#include "macros.h"
#include "memory_tags.h"

```

`packetWin7/npf/npf/time_calls.h`:

```h
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
/*
 * Copyright (c) 2001 - 2005 NetGroup, Politecnico di Torino (Italy)
 * Copyright (c) 2005 - 2007 CACE Technologies, Davis (California)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Politecnico di Torino, CACE Technologies 
 * nor the names of its contributors may be used to endorse or promote 
 * products derived from this software without specific prior written 
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#ifndef _time_calls
#define _time_calls

#include <wdm.h>
#define DEFAULT_TIMESTAMPMODE 0

#define TIMESTAMPMODE_SINGLE_SYNCHRONIZATION 0
#define /* DEPRECATED */ TIMESTAMPMODE_SYNCHRONIZATION_ON_CPU_WITH_FIXUP 1
#define TIMESTAMPMODE_QUERYSYSTEMTIME 2
#define /* DEPRECATED */ TIMESTAMPMODE_RDTSC 3
#define TIMESTAMPMODE_QUERYSYSTEMTIME_PRECISE 4
#define /* DEPRECATED */ TIMESTAMPMODE_SYNCHRONIZATION_ON_CPU_NO_FIXUP 99

#define TIMESTAMPMODE_UNSET ((ULONG) -1)

extern LARGE_INTEGER TimeFreq;

inline BOOLEAN NPF_TimestampModeSupported(_In_ ULONG mode)
{
	return mode == TIMESTAMPMODE_SINGLE_SYNCHRONIZATION
		|| mode == TIMESTAMPMODE_QUERYSYSTEMTIME
		|| mode == TIMESTAMPMODE_QUERYSYSTEMTIME_PRECISE;
}

inline void BestQuerySystemTime(
	PLARGE_INTEGER CurrentTime
	)
{
#if(NTDDI_VERSION <= NTDDI_WIN7)
	KeQuerySystemTime(CurrentTime);
#else
	KeQuerySystemTimePrecise(CurrentTime);
#endif
}

/*!
  \brief A microsecond precise timestamp.

  included in the bpf_hdr that NPF associates with every packet. 
*/
struct timeval
{
	long tv_sec;		 ///< seconds
	long tv_usec;   	 ///< microseconds
};
// Number of usecs in a second
#define NUM_USECS 1000000
// Number of nsecs in a second
#define NUM_NSECS 1000000000
// Number of 100-nsec intervals in a second
#define NUM_SYSTIME 10000000
// Number of seconds between MS epoch and Unix epoch
#define MS_EPOCH 11644473600

/* KeQueryPerformanceCounter TimeStamps */
inline void TIME_SYNCHRONIZE(
		_Inout_ struct timeval* start)
{
	if (start->tv_sec != 0 || start->tv_usec != 0) {
		// We only synchronize once, as the timestamp mode name indicates (SINGLE_SYNCHRONIZATION)
		return;
	}

	//struct timeval tmp;
	LARGE_INTEGER SystemTime;
	//LARGE_INTEGER i;
	//ULONG tmp2;
	LARGE_INTEGER PTime;

	// get the absolute value of the system boot time.   
	PTime = KeQueryPerformanceCounter(&TimeFreq);
	BestQuerySystemTime(&SystemTime);

	start->tv_sec = (LONG)(SystemTime.QuadPart / NUM_SYSTIME - MS_EPOCH);

	start->tv_usec = (LONG)((SystemTime.QuadPart % NUM_SYSTIME) * 100);

	start->tv_sec -= (ULONG)(PTime.QuadPart / TimeFreq.QuadPart);

	start->tv_usec -= (LONG)((PTime.QuadPart % TimeFreq.QuadPart) * NUM_NSECS / TimeFreq.QuadPart);

	if (start->tv_usec < 0)
	{
		start->tv_sec --;
		start->tv_usec += NUM_NSECS;
	}
}	

inline void GetTimevalFromPerfCount(
		_Out_ struct timeval* __restrict dst,
		_In_ struct timeval* __restrict start,
		_In_ LARGE_INTEGER PTime,
		_In_ BOOLEAN bNano)
{
	NT_ASSERT(TimeFreq.QuadPart != 0);

	//it should be only the normal case i.e. TIMESTAMPMODE_SINGLESYNCHRONIZATION
	dst->tv_sec = start->tv_sec + (LONG)(PTime.QuadPart / TimeFreq.QuadPart);
	LONG ns = start->tv_usec + (LONG)((PTime.QuadPart % TimeFreq.QuadPart) * NUM_NSECS / TimeFreq.QuadPart);

	if (ns >= NUM_NSECS)
	{
		dst->tv_sec ++;
		ns -= NUM_NSECS;
	}
	dst->tv_usec = bNano ? ns : ns / 1000;
}

inline void GetTimeKQPC(
		_Out_ struct timeval* __restrict dst,
		_In_ struct timeval* __restrict start)
{
	LARGE_INTEGER PTime;

	PTime = KeQueryPerformanceCounter(NULL);
	GetTimevalFromPerfCount(dst, start, PTime, FALSE);
}

inline void GetTimevalFromSystemTime(
		_Out_ struct timeval* dst,
		_In_ LARGE_INTEGER SystemTime,
		_In_ BOOLEAN bNano)
{
	LONG tmp = (LONG)(SystemTime.QuadPart % NUM_SYSTIME);
	dst->tv_sec = (LONG)(SystemTime.QuadPart / NUM_SYSTIME - MS_EPOCH);
	dst->tv_usec = bNano ? (tmp * 100) : (tmp / 10);
}

inline void GetTimeQST(
		_Out_ struct timeval* dst)
{
	LARGE_INTEGER SystemTime;

	KeQuerySystemTime(&SystemTime);

	GetTimevalFromSystemTime(dst, SystemTime, FALSE);
}

inline void GetTimeQST_precise(
		_Out_ struct timeval* dst)
{
	LARGE_INTEGER SystemTime;

	BestQuerySystemTime(&SystemTime);

	GetTimevalFromSystemTime(dst, SystemTime, FALSE);
}


inline void GET_TIME(
		_Out_ struct timeval* __restrict dst,
		_In_ struct timeval* __restrict start,
		_In_ ULONG TimestampMode)
{
	switch (TimestampMode)
	{
		case TIMESTAMPMODE_QUERYSYSTEMTIME:
			GetTimeQST(dst);
			break;
		case TIMESTAMPMODE_QUERYSYSTEMTIME_PRECISE:
			GetTimeQST_precise(dst);
			break;
		default:
			GetTimeKQPC(dst, start);
			break;
	}
}

#endif /*_time_calls*/

```

`packetWin7/npf/npf/valid_insns.h`:

```h
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
/*
 * Copyright (c) 2001 - 2005 NetGroup, Politecnico di Torino (Italy)
 * Copyright (c) 2005 - 2006 CACE Technologies, Davis (California)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Politecnico di Torino, CACE Technologies 
 * nor the names of its contributors may be used to endorse or promote 
 * products derived from this software without specific prior written 
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

u_short valid_instructions[] =
{
	BPF_RET | BPF_K,
	BPF_RET | BPF_A,

	/* LD and LDX for IMM, MEM, and LEN (BPF_W is implied) */
	BPF_LD  | BPF_IMM,
	BPF_LDX | BPF_IMM,
	BPF_LD  | BPF_MEM,
	BPF_LDX | BPF_MEM,
	BPF_LD  | BPF_LEN,
	BPF_LDX | BPF_LEN,

	/* LD and LDX for W, H, and B sizes */
#define BPF_OP_SIZES(_Op) \
	(_Op) | BPF_W, (_Op) | BPF_H, (_Op) | BPF_B
	BPF_OP_SIZES(BPF_LD  | BPF_ABS),
	BPF_OP_SIZES(BPF_LDX | BPF_ABS),
	BPF_OP_SIZES(BPF_LD  | BPF_IND),

	BPF_LDX | BPF_MSH | BPF_B,

	BPF_ST,
	BPF_STX,

	/* JMP and ALU instructions for K and X variants */
#define BPF_OP_KX(_Op) \
	(_Op) | BPF_K, (_Op) | BPF_X

	BPF_JMP | BPF_JA,
	BPF_OP_KX(BPF_JMP | BPF_JGT),
	BPF_OP_KX(BPF_JMP | BPF_JGE),
	BPF_OP_KX(BPF_JMP | BPF_JEQ),
	BPF_OP_KX(BPF_JMP | BPF_JSET),

	BPF_OP_KX(BPF_ALU | BPF_ADD),
	BPF_OP_KX(BPF_ALU | BPF_SUB),
	BPF_OP_KX(BPF_ALU | BPF_MUL),
	BPF_OP_KX(BPF_ALU | BPF_DIV),
	BPF_OP_KX(BPF_ALU | BPF_AND),
	BPF_OP_KX(BPF_ALU | BPF_OR),
	BPF_OP_KX(BPF_ALU | BPF_LSH),
	BPF_OP_KX(BPF_ALU | BPF_RSH),
	BPF_ALU | BPF_NEG,
	BPF_OP_KX(BPF_ALU | BPF_MOD),
	BPF_OP_KX(BPF_ALU | BPF_XOR),

	BPF_MISC | BPF_TAX,
	BPF_MISC | BPF_TXA,

};

#define VALID_INSTRUCTIONS_LEN (sizeof(valid_instructions)/sizeof(valid_instructions[0]))

```

`packetWin7/npf/npf/win_bpf.h`:

```h
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
/*-
 * Copyright (c) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from the Stanford/CMU enet packet filter,
 * (net/enet.c) distributed as part of 4.3BSD, and code contributed
 * to Berkeley by Steven McCanne and Van Jacobson both of Lawrence 
 * Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *  	This product includes software developed by the University of
 *  	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *  	@(#)bpf.h   	7.1 (Berkeley) 5/7/91
 *
 */

#ifndef BPF_MAJOR_VERSION

/* BSD style release date */
#define BPF_RELEASE 199606

#include <ndis.h>
#include "time_calls.h"
#include "../../../Common/npcap-bpf.h"

typedef	UCHAR u_char;
typedef	USHORT u_short;
typedef	ULONG u_int;

typedef	LONG bpf_int32;
typedef	ULONG bpf_u_int32;
typedef	ULONG u_int32;

#define BPF_MAXINSNS 4096



/*
 * The instruction encodings.
 */
/* instruction classes */
#define BPF_CLASS(code) ((code) & 0x07)
#define		BPF_LD		0x00
#define		BPF_LDX		0x01
#define		BPF_ST		0x02
#define		BPF_STX		0x03
#define		BPF_ALU		0x04
#define		BPF_JMP		0x05
#define		BPF_RET		0x06
#define		BPF_MISC	0x07

/* ld/ldx fields */
#define BPF_SIZE(code)	((code) & 0x18)
#define		BPF_W		0x00
#define		BPF_H		0x08
#define		BPF_B		0x10
#define BPF_MODE(code)	((code) & 0xe0)
#define		BPF_IMM 	0x00
#define		BPF_ABS		0x20
#define		BPF_IND		0x40
#define		BPF_MEM		0x60
#define		BPF_LEN		0x80
#define		BPF_MSH		0xa0

/* alu/jmp fields */
#define BPF_OP(code)	((code) & 0xf0)
#define		BPF_ADD		0x00
#define		BPF_SUB		0x10
#define		BPF_MUL		0x20
#define		BPF_DIV		0x30
#define		BPF_OR		0x40
#define		BPF_AND		0x50
#define		BPF_LSH		0x60
#define		BPF_RSH		0x70
#define		BPF_NEG		0x80
#define		BPF_MOD		0x90
#define		BPF_XOR		0xa0
#define		BPF_JA		0x00
#define		BPF_JEQ		0x10
#define		BPF_JGT		0x20
#define		BPF_JGE		0x30
#define		BPF_JSET	0x40
#define BPF_SRC(code)	((code) & 0x08)
#define		BPF_K		0x00
#define		BPF_X		0x08

/* ret - BPF_K and BPF_X also apply */
#define BPF_RVAL(code)	((code) & 0x18)
#define		BPF_A		0x10

/* misc */
#define BPF_MISCOP(code) ((code) & 0xf8)
#define		BPF_TAX		0x00
#define		BPF_TXA		0x80

/*
 * Macros for insn array initializers.
 */
#define BPF_STMT(code, k) { (u_short)(code), 0, 0, k }
#define BPF_JUMP(code, k, jt, jf) { (u_short)(code), jt, jf, k }

/*
 * Number of scratch memory words (for BPF_LD|BPF_MEM and BPF_ST).
 */
#define BPF_MEMWORDS 16

#ifdef __cplusplus
extern "C"
{
#endif

	/*!
	  \brief Validates a filtering program arriving from the user-level app.
	  \param f The filter.
	  \param len Its length, in pseudo instructions.
	  \param mem_ex_size The length of the extended memory, used to validate LD/ST to that memory
	  \return true if f is a valid filter program..
	  
	  The kernel needs to be able to verify an application's filter code. Otherwise, a bogus program could easily 
	  crash the system.
	  This function returns true if f is a valid filter program. The constraints are that each jump be forward and 
	  to a valid code.  The code must terminate with either an accept or reject. 
	*/
	_Success_(return != 0)
	int bpf_validate(_In_reads_(len) struct bpf_insn* f, _In_range_(0, BPF_MAXINSNS) int len);

	/*!
	  \brief The filtering pseudo-machine interpreter.
	  \param pc The filter.
	  \param pNB Pointer to a NET_BUFFER containing the packet on which the filter will be executed.
	  \return The portion of the packet to keep, in bytes. 0 means that the packet must be rejected, -1 means that
	   the whole packet must be kept.
	*/
	u_int bpf_filter(_In_ const struct bpf_insn* pc, ULONG insns, _In_ const PNET_BUFFER pNB, _In_ const PVOID pContext);

#ifdef __cplusplus
}
#endif


#endif

```

`packetWin7/npf/npf/win_bpf_filter.c`:

```c
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
/*
 * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)
 * Copyright (c) 2005 - 2007 CACE Technologies, Davis (California)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Politecnico di Torino, CACE Technologies 
 * nor the names of its contributors may be used to endorse or promote 
 * products derived from this software without specific prior written 
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include "stdafx.h"

#include <ndis.h>
#include <limits.h>

#include "Packet.h"
#include "win_bpf.h"

#include "valid_insns.h"

#define MDL_NEXT_BYTE() \
	k++; \
	if (len <= k) { \
		p = p->Next; \
		if (p == NULL) return 0; \
		QueryMdl(p, &CurBuf, &len, NormalPagePriority); \
		if (CurBuf == NULL) return 0; \
		k = 0; \
	}

#define XNUM_GET_B() value |= CurBuf[k];

#define XNUM_GET_H() \
	value |= (CurBuf[k] << 8); \
	MDL_NEXT_BYTE(); \
	XNUM_GET_B();

#define XNUM_GET_W() \
	value |= (CurBuf[k] << 24); \
	MDL_NEXT_BYTE(); \
	value |= (CurBuf[k] << 16); \
	MDL_NEXT_BYTE(); \
	XNUM_GET_H();

#define DECLARE_XNUM(_Size) \
static u_int32 xnum_##_Size( _In_ PMDL p, _In_ u_int32 k, _Out_ int *err) \
{ \
	u_int32 len = 0; \
	u_char * CurBuf=NULL; \
	u_int32 value = 0; \
	*err = 1; \
 \
	while ((len = MmGetMdlByteCount(p)) <= k) { \
		k -= len; \
		p = p->Next; \
		if (p == NULL) return 0; \
	} \
	QueryMdl(p, &CurBuf, &len, NormalPagePriority); \
	if (CurBuf == NULL) return 0; \
	XNUM_GET_##_Size(); \
 \
	*err = 0; \
	return value; \
}

DECLARE_XNUM(W)
DECLARE_XNUM(H)
DECLARE_XNUM(B)

#define IS_EXTENSION_OFFSET(_k) ((int)(_k) < 0)
static int valid_extension_offset(_In_ u_int32 k) {
	switch (k) {
		case NPCAP_AD_OFF + NPCAP_AD_VLAN_TAG_PRESENT:
		case NPCAP_AD_OFF + NPCAP_AD_VLAN_TAG:
			return 1;
	}
	return 0;
}

static int do_extension(_In_ u_int32 k, _In_ const PNPF_NBL_COPY pNBLCopy)
{
	switch (k) {
		case NPCAP_AD_OFF + NPCAP_AD_VLAN_TAG_PRESENT:
			return ((pNBLCopy->qInfo.Value == 0 && !pNBLCopy->bQinfoPresent) ? 0 : 1);
			break;
		case NPCAP_AD_OFF + NPCAP_AD_VLAN_TAG:
			return ((pNBLCopy->qInfo.TagHeader.UserPriority & 0x7) << 13 |
				(pNBLCopy->qInfo.TagHeader.CanonicalFormatId & 0x1) << 12 |
				(pNBLCopy->qInfo.TagHeader.VlanId & 0xfff));
			break;
		default:
			// BAD validation failure
			NT_ASSERT(FALSE);
	}
	return 0;
}

_Use_decl_annotations_
u_int bpf_filter(const struct bpf_insn *pc, ULONG insns, const PNET_BUFFER pNB, const PVOID pContext)
{
	PMDL p = NET_BUFFER_CURRENT_MDL(pNB);
	PNPF_NBL_COPY pNBLCopy = (PNPF_NBL_COPY)pContext;
	ULONG data_offset = NET_BUFFER_CURRENT_MDL_OFFSET(pNB);
	ULONG wirelen = NET_BUFFER_DATA_LENGTH(pNB);
	const struct bpf_insn *last = pc + (insns - 1);
	register u_int32 A, X;
	register bpf_u_int32 k;

	int merr = 0;
	int mem[BPF_MEMWORDS];

	if (pc == NULL || insns == 0)
	/*
	* No filter means accept all.
	*/
		return (u_int) - 1;

	RtlZeroMemory(mem, sizeof(mem));
	A = 0;
	X = 0;
	--pc;
	while (NT_VERIFY(pc < last))
	{
		++pc;
		switch (pc->code)
		{
		default:
			return 0;

#define VAL_K (pc->k)
#define VAL_A (A)
#define VAL_X (X)
#define CASE_RET(_Val) \
		case BPF_RET|BPF_##_Val: \
			return (u_int)VAL_##_Val;

		CASE_RET(K);
		CASE_RET(A);

#define EXTRA_STMT_ABS if (IS_EXTENSION_OFFSET(pc->k)) \
	{ A = do_extension(pc->k, pNBLCopy); continue; }
#define EXTRA_STMT_IND
#define ADDR_MODE_ABS (pc->k)
#define ADDR_MODE_IND (X + pc->k)
#define CASE_LD_XNUM(_Size, _Mode) \
		case BPF_LD|BPF_##_Size|BPF_##_Mode: \
			EXTRA_STMT_##_Mode; \
			A = xnum_##_Size(p, ADDR_MODE_##_Mode + data_offset, &merr); \
			if (merr != 0) { \
				return 0; \
			} \
			continue;

		CASE_LD_XNUM(W, ABS);
		CASE_LD_XNUM(H, ABS);
		CASE_LD_XNUM(B, ABS);

		CASE_LD_XNUM(W, IND);
		CASE_LD_XNUM(H, IND);
		CASE_LD_XNUM(B, IND);

		case BPF_LDX|BPF_MSH|BPF_B:
			k = pc->k;
			X = xnum_B(p, k + data_offset, &merr);
			if (merr != 0) {
				return 0;
			}
			X = (X & 0xf) << 2;
			continue;

#define DST_LD A
#define DST_LDX X
#define VAL_MODE_IMM (pc->k)
#define VAL_MODE_MEM (mem[pc->k])
#define VAL_MODE_LEN (wirelen)
#define CASE_LD_OP(_Ld, _Mode) \
		case BPF_##_Ld|BPF_##_Mode: \
			DST_##_Ld = VAL_MODE_##_Mode; \
			continue;

		CASE_LD_OP(LD, IMM);
		CASE_LD_OP(LDX, IMM);
		CASE_LD_OP(LD, MEM);
		CASE_LD_OP(LDX, MEM);
		CASE_LD_OP(LD, LEN);
		CASE_LD_OP(LDX, LEN);

		case BPF_ST:
			if (!NT_VERIFY(pc->k < BPF_MEMWORDS))
				return 0;
			mem[pc->k] = A;
			continue;

		case BPF_STX:
			if (!NT_VERIFY(pc->k < BPF_MEMWORDS))
				return 0;
			mem[pc->k] = X;
			continue;

		case BPF_JMP|BPF_JA:
			if (!NT_VERIFY(pc->k < BPF_MAXINSNS))
				return 0;
			pc += pc->k;
			continue;

#define TEST_JGT(_Val) ((int)A > (int)(_Val))
#define TEST_JGE(_Val) ((int)A >= (int)(_Val))
#define TEST_JEQ(_Val) ((int)A == (int)(_Val))
#define TEST_JSET(_Val) (A & (_Val))

#define CASE_JMP(_Test, _Val) \
		case BPF_JMP|BPF_##_Test|BPF_##_Val: \
			pc += TEST_##_Test(VAL_##_Val) ? pc->jt : pc->jf; \
			continue;

		CASE_JMP(JGT, K);
		CASE_JMP(JGE, K);
		CASE_JMP(JEQ, K);
		CASE_JMP(JSET, K);

		CASE_JMP(JGT, X);
		CASE_JMP(JGE, X);
		CASE_JMP(JEQ, X);
		CASE_JMP(JSET, X);

#define ALU_OP_ADD(_Val) A += _Val;
#define ALU_OP_SUB(_Val) A -= _Val;
#define ALU_OP_MUL(_Val) A *= _Val;
#define ALU_OP_DIV(_Val) if ((_Val) == 0) return 0; A /= _Val;
#define ALU_OP_AND(_Val) A &= _Val;
#define ALU_OP_OR(_Val)  A |= _Val;
#define ALU_OP_LSH(_Val) A <<= _Val;
#define ALU_OP_RSH(_Val) A >>= _Val;
#define ALU_OP_MOD(_Val) if ((_Val) == 0) return 0; A %= _Val;
#define ALU_OP_XOR(_Val) A ^= _Val;

#define CASE_ALU(_Op, _Val) \
		case BPF_ALU|BPF_##_Op|BPF_##_Val: \
			ALU_OP_##_Op(VAL_##_Val); \
			continue;

		CASE_ALU(ADD, X);
		CASE_ALU(SUB, X);
		CASE_ALU(MUL, X);
		CASE_ALU(DIV, X);
		CASE_ALU(AND, X);
		CASE_ALU(OR,  X);
		CASE_ALU(LSH, X);
		CASE_ALU(RSH, X);
		CASE_ALU(MOD, X);
		CASE_ALU(XOR, X);

		CASE_ALU(ADD, K);
		CASE_ALU(SUB, K);
		CASE_ALU(MUL, K);
		CASE_ALU(DIV, K);
		CASE_ALU(AND, K);
		CASE_ALU(OR,  K);
		CASE_ALU(LSH, K);
		CASE_ALU(RSH, K);
		CASE_ALU(MOD, K);
		CASE_ALU(XOR, K);

		case BPF_ALU|BPF_NEG:
			(int)A = -((int)A);
			continue;

		case BPF_MISC|BPF_TAX:
			X = A;
			continue;

		case BPF_MISC|BPF_TXA:
			A = X;
			continue;
		}
	}
	return 0;
}

//-------------------------------------------------------------------

_Use_decl_annotations_
int bpf_validate(struct bpf_insn * f, int len)
{
	register u_int32 i, from;
	register int j;
	register struct bpf_insn* p;
	int flag;

	INFO_DBG("Validating program\n");

	if (len < 1)
		return 0;

	for (i = 0; i < (u_int32)len; ++i)
	{
		p = &f[i];

		flag = 0;
		for (j = 0; j < VALID_INSTRUCTIONS_LEN; j++)
		{
			if (p->code == valid_instructions[j])
			{
				flag = 1;
				break;
			}
		}
		if (flag == 0)
			return 0;

		INFO_DBG("Validating program: no unknown instructions\n");

		switch (BPF_CLASS(p->code))
		{
			/*
			 * Check that memory operations use valid addresses.
			 */
		case BPF_LD:
		case BPF_LDX:
			switch (BPF_MODE(p->code))
			{
			case BPF_ABS:
			case BPF_MSH:
				// Check for valid special offsets
				if (IS_EXTENSION_OFFSET(p->k) && !valid_extension_offset(p->k)) {
					return 0;
				}
				// Anything else is fine.
				break;
			case BPF_IND:
			case BPF_IMM:
				// Anything goes
				break;
			case BPF_MEM:
				if (p->k >= BPF_MEMWORDS)
					return 0;
				break;
			case BPF_LEN:
				// p->k is ignored
				break;
			default:
				return 0;
			}

			INFO_DBG("Validating program: no wrong LD memory locations\n");
			break;

		case BPF_ST:
		case BPF_STX:
			if (p->k >= BPF_MEMWORDS)
				return 0;

			INFO_DBG("Validating program: no wrong ST memory locations\n");
			break;

		case BPF_ALU:
			switch (BPF_OP(p->code))
			{
			case BPF_ADD:
			case BPF_SUB:
			case BPF_MUL:
			case BPF_OR:
			case BPF_AND:
			case BPF_LSH:
			case BPF_RSH:
			case BPF_NEG:
			case BPF_XOR:
				break;
			case BPF_DIV:
			case BPF_MOD:
				/*
				 * Check for constant division by 0.
				 */
				if (BPF_SRC(p->code) == BPF_K && p->k == 0)
					return 0;
				break;
			default:
				return 0;
			}
			break;
		case BPF_JMP:
			from = i + 1;
			/*
			 * Check that jumps are within the code block,
			 * and that unconditional branches don't go
			 * backwards as a result of an overflow.
			 * Unconditional branches have a 32-bit offset,
			 * so they could overflow; we check to make
			 * sure they don't.  Conditional branches have
			 * an 8-bit offset, and the from address is <=
			 * BPF_MAXINSNS, and we assume that BPF_MAXINSNS
			 * is sufficiently small that adding 255 to it
			 * won't overflow.
			 *
			 * We know that len is <= BPF_MAXINSNS, and we
			 * assume that BPF_MAXINSNS is < the maximum size
			 * of a u_int, so that i + 1 doesn't overflow.
			 */
			/* Never assume; check instead. */
			C_ASSERT(BPF_MAXINSNS < UINT_MAX - UCHAR_MAX);
			// Jump can't be the last instruction
			if (from >= (u_int32)len)
				return 0;
			switch (BPF_OP(p->code))
			{
			case BPF_JA:
				if (p->k >= len - from)
					return 0;
				break;
			case BPF_JEQ:
			case BPF_JGT:
			case BPF_JGE:
			case BPF_JSET:
				if (p->jt >= len - from || p->jf >= len - from)
					return 0;
				break;
			default:
				return 0;
			}
			INFO_DBG("Validating program: no wrong JUMPS\n");
			break;
		case BPF_RET:
			break;
		case BPF_MISC:
			break;
		default:
			return 0;
		}
	}
	return BPF_CLASS(f[len - 1].code) == BPF_RET;
}

```

`packetWin7/vs14/npcap.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.14.36401.2
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "npf", "..\npf\npf\npf.vcxproj", "{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "npf Package", "..\npf\npf Package\npf Package.vcxproj", "{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Packet", "..\Dll\Project\Packet.vcxproj", "{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "NpcapHelper", "..\Helper\NpcapHelper\NpcapHelper.vcxproj", "{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "WlanHelper", "..\WlanHelper\WlanHelper\WlanHelper.vcxproj", "{044CB4DC-827D-4134-B14B-DE114E884BB9}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "NPFInstall", "..\NPFInstall\NPFInstall\NPFInstall.vcxproj", "{5D8A2717-4F35-4402-B868-45612D27291B}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DriverQuery", "..\DriverQuery\DriverQuery.vcxproj", "{C87689C8-9CEE-4E97-953C-7C981385522F}"
	ProjectSection(ProjectDependencies) = postProject
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52} = {17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}
	EndProjectSection
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug No AirPcap|ARM64 = Debug No AirPcap|ARM64
		Debug No AirPcap|x64 = Debug No AirPcap|x64
		Debug No AirPcap|x86 = Debug No AirPcap|x86
		Debug Win10 driver|ARM64 = Debug Win10 driver|ARM64
		Debug Win10 driver|x64 = Debug Win10 driver|x64
		Debug Win10 driver|x86 = Debug Win10 driver|x86
		Debug Win7 driver|ARM64 = Debug Win7 driver|ARM64
		Debug Win7 driver|x64 = Debug Win7 driver|x64
		Debug Win7 driver|x86 = Debug Win7 driver|x86
		Debug Win8 driver|ARM64 = Debug Win8 driver|ARM64
		Debug Win8 driver|x64 = Debug Win8 driver|x64
		Debug Win8 driver|x86 = Debug Win8 driver|x86
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		OEM Debug Win10 driver|ARM64 = OEM Debug Win10 driver|ARM64
		OEM Debug Win10 driver|x64 = OEM Debug Win10 driver|x64
		OEM Debug Win10 driver|x86 = OEM Debug Win10 driver|x86
		OEM Debug|ARM64 = OEM Debug|ARM64
		OEM Debug|x64 = OEM Debug|x64
		OEM Debug|x86 = OEM Debug|x86
		OEM Release Win10 driver|ARM64 = OEM Release Win10 driver|ARM64
		OEM Release Win10 driver|x64 = OEM Release Win10 driver|x64
		OEM Release Win10 driver|x86 = OEM Release Win10 driver|x86
		OEM Release Win8 driver|ARM64 = OEM Release Win8 driver|ARM64
		OEM Release Win8 driver|x64 = OEM Release Win8 driver|x64
		OEM Release Win8 driver|x86 = OEM Release Win8 driver|x86
		OEM Release|ARM64 = OEM Release|ARM64
		OEM Release|x64 = OEM Release|x64
		OEM Release|x86 = OEM Release|x86
		OEM RO Release Win10 driver|ARM64 = OEM RO Release Win10 driver|ARM64
		OEM RO Release Win10 driver|x64 = OEM RO Release Win10 driver|x64
		OEM RO Release Win10 driver|x86 = OEM RO Release Win10 driver|x86
		OEM RO Release Win7 driver|ARM64 = OEM RO Release Win7 driver|ARM64
		OEM RO Release Win7 driver|x64 = OEM RO Release Win7 driver|x64
		OEM RO Release Win7 driver|x86 = OEM RO Release Win7 driver|x86
		OEM RO Release Win8 driver|ARM64 = OEM RO Release Win8 driver|ARM64
		OEM RO Release Win8 driver|x64 = OEM RO Release Win8 driver|x64
		OEM RO Release Win8 driver|x86 = OEM RO Release Win8 driver|x86
		OEM RO Release|ARM64 = OEM RO Release|ARM64
		OEM RO Release|x64 = OEM RO Release|x64
		OEM RO Release|x86 = OEM RO Release|x86
		Release No AirPcap|ARM64 = Release No AirPcap|ARM64
		Release No AirPcap|x64 = Release No AirPcap|x64
		Release No AirPcap|x86 = Release No AirPcap|x86
		Release Win10 driver|ARM64 = Release Win10 driver|ARM64
		Release Win10 driver|x64 = Release Win10 driver|x64
		Release Win10 driver|x86 = Release Win10 driver|x86
		Release Win7 driver|ARM64 = Release Win7 driver|ARM64
		Release Win7 driver|x64 = Release Win7 driver|x64
		Release Win7 driver|x86 = Release Win7 driver|x86
		Release Win8 driver|ARM64 = Release Win8 driver|ARM64
		Release Win8 driver|x64 = Release Win8 driver|x64
		Release Win8 driver|x86 = Release Win8 driver|x86
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Debug No AirPcap|ARM64.ActiveCfg = Win7 Debug|ARM64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Debug No AirPcap|x64.ActiveCfg = Win7 Debug|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Debug No AirPcap|x86.ActiveCfg = Win7 Debug|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Debug Win10 driver|ARM64.ActiveCfg = Win10 Debug|ARM64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Debug Win10 driver|ARM64.Build.0 = Win10 Debug|ARM64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Debug Win10 driver|ARM64.Deploy.0 = Win10 Debug|ARM64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Debug Win10 driver|x64.ActiveCfg = Win10 Debug|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Debug Win10 driver|x64.Build.0 = Win10 Debug|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Debug Win10 driver|x64.Deploy.0 = Win10 Debug|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Debug Win10 driver|x86.ActiveCfg = Win10 Debug|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Debug Win10 driver|x86.Build.0 = Win10 Debug|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Debug Win10 driver|x86.Deploy.0 = Win10 Debug|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Debug Win7 driver|ARM64.ActiveCfg = Win7 Debug|ARM64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Debug Win7 driver|x64.ActiveCfg = Win7 Debug|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Debug Win7 driver|x64.Build.0 = Win7 Debug|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Debug Win7 driver|x64.Deploy.0 = Win7 Debug|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Debug Win7 driver|x86.ActiveCfg = Win7 Debug|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Debug Win7 driver|x86.Build.0 = Win7 Debug|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Debug Win7 driver|x86.Deploy.0 = Win7 Debug|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Debug Win8 driver|ARM64.ActiveCfg = Win8 Release|ARM64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Debug Win8 driver|x64.ActiveCfg = Win8 Debug|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Debug Win8 driver|x64.Build.0 = Win8 Debug|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Debug Win8 driver|x64.Deploy.0 = Win8 Debug|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Debug Win8 driver|x86.ActiveCfg = Win8 Debug|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Debug Win8 driver|x86.Build.0 = Win8 Debug|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Debug Win8 driver|x86.Deploy.0 = Win8 Debug|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Debug|ARM64.ActiveCfg = Win7 Debug|ARM64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Debug|x64.ActiveCfg = Win7 Debug|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Debug|x86.ActiveCfg = Win7 Debug|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM Debug Win10 driver|ARM64.ActiveCfg = Win10 OEM Debug|ARM64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM Debug Win10 driver|ARM64.Build.0 = Win10 OEM Debug|ARM64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM Debug Win10 driver|ARM64.Deploy.0 = Win10 OEM Debug|ARM64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM Debug Win10 driver|x64.ActiveCfg = Win10 OEM Debug|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM Debug Win10 driver|x64.Build.0 = Win10 OEM Debug|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM Debug Win10 driver|x64.Deploy.0 = Win10 OEM Debug|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM Debug Win10 driver|x86.ActiveCfg = Win10 OEM Debug|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM Debug Win10 driver|x86.Build.0 = Win10 OEM Debug|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM Debug Win10 driver|x86.Deploy.0 = Win10 OEM Debug|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM Debug|ARM64.ActiveCfg = Win7 OEM Debug|ARM64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM Debug|x64.ActiveCfg = Win7 OEM Debug|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM Debug|x86.ActiveCfg = Win7 OEM Debug|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM Release Win10 driver|ARM64.ActiveCfg = Win10 OEM Release|ARM64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM Release Win10 driver|ARM64.Build.0 = Win10 OEM Release|ARM64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM Release Win10 driver|ARM64.Deploy.0 = Win10 OEM Release|ARM64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM Release Win10 driver|x64.ActiveCfg = Win10 OEM Release|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM Release Win10 driver|x64.Build.0 = Win10 OEM Release|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM Release Win10 driver|x64.Deploy.0 = Win10 OEM Release|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM Release Win10 driver|x86.ActiveCfg = Win10 OEM Release|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM Release Win10 driver|x86.Build.0 = Win10 OEM Release|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM Release Win10 driver|x86.Deploy.0 = Win10 OEM Release|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM Release Win8 driver|ARM64.ActiveCfg = Win8 OEM Release|ARM64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM Release Win8 driver|x64.ActiveCfg = Win8 OEM Release|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM Release Win8 driver|x64.Build.0 = Win8 OEM Release|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM Release Win8 driver|x64.Deploy.0 = Win8 OEM Release|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM Release Win8 driver|x86.ActiveCfg = Win8 OEM Release|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM Release Win8 driver|x86.Build.0 = Win8 OEM Release|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM Release Win8 driver|x86.Deploy.0 = Win8 OEM Release|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM Release|ARM64.ActiveCfg = Win7 OEM Release|ARM64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM Release|x64.ActiveCfg = Win7 OEM Release|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM Release|x86.ActiveCfg = Win7 OEM Release|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM RO Release Win10 driver|ARM64.ActiveCfg = Win10 OEM RO Release|ARM64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM RO Release Win10 driver|ARM64.Build.0 = Win10 OEM RO Release|ARM64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM RO Release Win10 driver|ARM64.Deploy.0 = Win10 OEM RO Release|ARM64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM RO Release Win10 driver|x64.ActiveCfg = Win10 OEM RO Release|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM RO Release Win10 driver|x64.Build.0 = Win10 OEM RO Release|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM RO Release Win10 driver|x64.Deploy.0 = Win10 OEM RO Release|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM RO Release Win10 driver|x86.ActiveCfg = Win10 OEM RO Release|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM RO Release Win10 driver|x86.Build.0 = Win10 OEM RO Release|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM RO Release Win10 driver|x86.Deploy.0 = Win10 OEM RO Release|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM RO Release Win7 driver|ARM64.ActiveCfg = Win7 OEM RO Release|ARM64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM RO Release Win7 driver|ARM64.Build.0 = Win7 OEM RO Release|ARM64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM RO Release Win7 driver|ARM64.Deploy.0 = Win7 OEM RO Release|ARM64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM RO Release Win7 driver|x64.ActiveCfg = Win7 OEM RO Release|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM RO Release Win7 driver|x64.Build.0 = Win7 OEM RO Release|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM RO Release Win7 driver|x64.Deploy.0 = Win7 OEM RO Release|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM RO Release Win7 driver|x86.ActiveCfg = Win7 OEM RO Release|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM RO Release Win7 driver|x86.Build.0 = Win7 OEM RO Release|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM RO Release Win7 driver|x86.Deploy.0 = Win7 OEM RO Release|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM RO Release Win8 driver|ARM64.ActiveCfg = Win8 OEM RO Release|ARM64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM RO Release Win8 driver|x64.ActiveCfg = Win8 OEM RO Release|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM RO Release Win8 driver|x64.Build.0 = Win8 OEM RO Release|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM RO Release Win8 driver|x64.Deploy.0 = Win8 OEM RO Release|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM RO Release Win8 driver|x86.ActiveCfg = Win8 OEM RO Release|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM RO Release Win8 driver|x86.Build.0 = Win8 OEM RO Release|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM RO Release Win8 driver|x86.Deploy.0 = Win8 OEM RO Release|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM RO Release|ARM64.ActiveCfg = Win7 OEM RO Release|ARM64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM RO Release|x64.ActiveCfg = Win7 OEM RO Release|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.OEM RO Release|x86.ActiveCfg = Win7 OEM RO Release|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Release No AirPcap|ARM64.ActiveCfg = Win7 Release|ARM64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Release No AirPcap|x64.ActiveCfg = Win7 Release|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Release No AirPcap|x86.ActiveCfg = Win7 Release|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Release Win10 driver|ARM64.ActiveCfg = Win10 Release|ARM64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Release Win10 driver|ARM64.Build.0 = Win10 Release|ARM64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Release Win10 driver|ARM64.Deploy.0 = Win10 Release|ARM64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Release Win10 driver|x64.ActiveCfg = Win10 Release|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Release Win10 driver|x64.Build.0 = Win10 Release|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Release Win10 driver|x64.Deploy.0 = Win10 Release|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Release Win10 driver|x86.ActiveCfg = Win10 Release|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Release Win10 driver|x86.Build.0 = Win10 Release|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Release Win10 driver|x86.Deploy.0 = Win10 Release|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Release Win7 driver|ARM64.ActiveCfg = Win7 Release|ARM64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Release Win7 driver|x64.ActiveCfg = Win7 Release|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Release Win7 driver|x64.Build.0 = Win7 Release|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Release Win7 driver|x64.Deploy.0 = Win7 Release|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Release Win7 driver|x86.ActiveCfg = Win7 Release|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Release Win7 driver|x86.Build.0 = Win7 Release|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Release Win7 driver|x86.Deploy.0 = Win7 Release|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Release Win8 driver|ARM64.ActiveCfg = Win8 Release|ARM64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Release Win8 driver|x64.ActiveCfg = Win8 Release|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Release Win8 driver|x64.Build.0 = Win8 Release|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Release Win8 driver|x64.Deploy.0 = Win8 Release|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Release Win8 driver|x86.ActiveCfg = Win8 Release|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Release Win8 driver|x86.Build.0 = Win8 Release|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Release Win8 driver|x86.Deploy.0 = Win8 Release|Win32
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Release|ARM64.ActiveCfg = Win7 Release|ARM64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Release|x64.ActiveCfg = Win7 Release|x64
		{3556F5BC-F8EC-437E-93E3-7CF2DC63FF61}.Release|x86.ActiveCfg = Win7 Release|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Debug No AirPcap|ARM64.ActiveCfg = Win7 Debug|ARM64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Debug No AirPcap|x64.ActiveCfg = Win7 Debug|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Debug No AirPcap|x86.ActiveCfg = Win7 Debug|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Debug Win10 driver|ARM64.ActiveCfg = Win10 Debug|ARM64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Debug Win10 driver|ARM64.Build.0 = Win10 Debug|ARM64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Debug Win10 driver|ARM64.Deploy.0 = Win10 Debug|ARM64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Debug Win10 driver|x64.ActiveCfg = Win10 Debug|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Debug Win10 driver|x64.Build.0 = Win10 Debug|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Debug Win10 driver|x64.Deploy.0 = Win10 Debug|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Debug Win10 driver|x86.ActiveCfg = Win10 Debug|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Debug Win10 driver|x86.Build.0 = Win10 Debug|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Debug Win10 driver|x86.Deploy.0 = Win10 Debug|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Debug Win7 driver|ARM64.ActiveCfg = Win7 Debug|ARM64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Debug Win7 driver|x64.ActiveCfg = Win7 Debug|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Debug Win7 driver|x64.Build.0 = Win7 Debug|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Debug Win7 driver|x64.Deploy.0 = Win7 Debug|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Debug Win7 driver|x86.ActiveCfg = Win7 Debug|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Debug Win7 driver|x86.Build.0 = Win7 Debug|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Debug Win7 driver|x86.Deploy.0 = Win7 Debug|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Debug Win8 driver|ARM64.ActiveCfg = Win8 Release|ARM64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Debug Win8 driver|x64.ActiveCfg = Win8 Debug|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Debug Win8 driver|x64.Build.0 = Win8 Debug|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Debug Win8 driver|x64.Deploy.0 = Win8 Debug|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Debug Win8 driver|x86.ActiveCfg = Win8 Debug|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Debug Win8 driver|x86.Build.0 = Win8 Debug|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Debug Win8 driver|x86.Deploy.0 = Win8 Debug|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Debug|ARM64.ActiveCfg = Win7 Debug|ARM64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Debug|x64.ActiveCfg = Win7 Debug|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Debug|x86.ActiveCfg = Win7 Debug|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM Debug Win10 driver|ARM64.ActiveCfg = Win10 OEM Debug|ARM64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM Debug Win10 driver|ARM64.Build.0 = Win10 OEM Debug|ARM64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM Debug Win10 driver|ARM64.Deploy.0 = Win10 OEM Debug|ARM64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM Debug Win10 driver|x64.ActiveCfg = Win10 OEM Debug|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM Debug Win10 driver|x64.Build.0 = Win10 OEM Debug|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM Debug Win10 driver|x64.Deploy.0 = Win10 OEM Debug|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM Debug Win10 driver|x86.ActiveCfg = Win10 OEM Debug|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM Debug Win10 driver|x86.Build.0 = Win10 OEM Debug|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM Debug Win10 driver|x86.Deploy.0 = Win10 OEM Debug|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM Debug|ARM64.ActiveCfg = Win7 OEM Debug|ARM64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM Debug|x64.ActiveCfg = Win7 OEM Debug|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM Debug|x86.ActiveCfg = Win7 OEM Debug|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM Release Win10 driver|ARM64.ActiveCfg = Win10 OEM Release|ARM64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM Release Win10 driver|ARM64.Build.0 = Win10 OEM Release|ARM64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM Release Win10 driver|ARM64.Deploy.0 = Win10 OEM Release|ARM64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM Release Win10 driver|x64.ActiveCfg = Win10 OEM Release|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM Release Win10 driver|x64.Build.0 = Win10 OEM Release|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM Release Win10 driver|x64.Deploy.0 = Win10 OEM Release|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM Release Win10 driver|x86.ActiveCfg = Win10 OEM Release|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM Release Win10 driver|x86.Build.0 = Win10 OEM Release|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM Release Win10 driver|x86.Deploy.0 = Win10 OEM Release|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM Release Win8 driver|ARM64.ActiveCfg = Win8 OEM Release|ARM64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM Release Win8 driver|x64.ActiveCfg = Win8 OEM Release|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM Release Win8 driver|x64.Build.0 = Win8 OEM Release|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM Release Win8 driver|x64.Deploy.0 = Win8 OEM Release|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM Release Win8 driver|x86.ActiveCfg = Win8 OEM Release|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM Release Win8 driver|x86.Build.0 = Win8 OEM Release|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM Release Win8 driver|x86.Deploy.0 = Win8 OEM Release|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM Release|ARM64.ActiveCfg = Win7 OEM Release|ARM64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM Release|x64.ActiveCfg = Win7 OEM Release|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM Release|x86.ActiveCfg = Win7 OEM Release|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM RO Release Win10 driver|ARM64.ActiveCfg = Win10 OEM RO Release|ARM64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM RO Release Win10 driver|ARM64.Build.0 = Win10 OEM RO Release|ARM64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM RO Release Win10 driver|ARM64.Deploy.0 = Win10 OEM RO Release|ARM64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM RO Release Win10 driver|x64.ActiveCfg = Win10 OEM RO Release|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM RO Release Win10 driver|x64.Build.0 = Win10 OEM RO Release|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM RO Release Win10 driver|x64.Deploy.0 = Win10 OEM RO Release|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM RO Release Win10 driver|x86.ActiveCfg = Win10 OEM RO Release|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM RO Release Win10 driver|x86.Build.0 = Win10 OEM RO Release|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM RO Release Win10 driver|x86.Deploy.0 = Win10 OEM RO Release|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM RO Release Win7 driver|ARM64.ActiveCfg = Win7 OEM RO Release|ARM64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM RO Release Win7 driver|x64.ActiveCfg = Win7 OEM RO Release|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM RO Release Win7 driver|x64.Build.0 = Win7 OEM RO Release|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM RO Release Win7 driver|x64.Deploy.0 = Win7 OEM RO Release|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM RO Release Win7 driver|x86.ActiveCfg = Win7 OEM RO Release|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM RO Release Win7 driver|x86.Build.0 = Win7 OEM RO Release|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM RO Release Win7 driver|x86.Deploy.0 = Win7 OEM RO Release|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM RO Release Win8 driver|ARM64.ActiveCfg = Win8 OEM RO Release|ARM64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM RO Release Win8 driver|x64.ActiveCfg = Win8 OEM RO Release|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM RO Release Win8 driver|x64.Build.0 = Win8 OEM RO Release|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM RO Release Win8 driver|x64.Deploy.0 = Win8 OEM RO Release|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM RO Release Win8 driver|x86.ActiveCfg = Win8 OEM RO Release|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM RO Release Win8 driver|x86.Build.0 = Win8 OEM RO Release|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM RO Release Win8 driver|x86.Deploy.0 = Win8 OEM RO Release|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM RO Release|ARM64.ActiveCfg = Win8 OEM RO Release|ARM64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM RO Release|x64.ActiveCfg = Win8 OEM RO Release|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.OEM RO Release|x86.ActiveCfg = Win8 OEM RO Release|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Release No AirPcap|ARM64.ActiveCfg = Win7 Release|ARM64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Release No AirPcap|x64.ActiveCfg = Win7 Release|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Release No AirPcap|x86.ActiveCfg = Win7 Release|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Release Win10 driver|ARM64.ActiveCfg = Win10 Release|ARM64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Release Win10 driver|ARM64.Build.0 = Win10 Release|ARM64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Release Win10 driver|ARM64.Deploy.0 = Win10 Release|ARM64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Release Win10 driver|x64.ActiveCfg = Win10 Release|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Release Win10 driver|x64.Build.0 = Win10 Release|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Release Win10 driver|x64.Deploy.0 = Win10 Release|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Release Win10 driver|x86.ActiveCfg = Win10 Release|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Release Win10 driver|x86.Build.0 = Win10 Release|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Release Win10 driver|x86.Deploy.0 = Win10 Release|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Release Win7 driver|ARM64.ActiveCfg = Win7 Release|ARM64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Release Win7 driver|x64.ActiveCfg = Win7 Release|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Release Win7 driver|x64.Build.0 = Win7 Release|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Release Win7 driver|x64.Deploy.0 = Win7 Release|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Release Win7 driver|x86.ActiveCfg = Win7 Release|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Release Win7 driver|x86.Build.0 = Win7 Release|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Release Win7 driver|x86.Deploy.0 = Win7 Release|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Release Win8 driver|ARM64.ActiveCfg = Win8 Release|ARM64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Release Win8 driver|x64.ActiveCfg = Win8 Release|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Release Win8 driver|x64.Build.0 = Win8 Release|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Release Win8 driver|x64.Deploy.0 = Win8 Release|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Release Win8 driver|x86.ActiveCfg = Win8 Release|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Release Win8 driver|x86.Build.0 = Win8 Release|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Release Win8 driver|x86.Deploy.0 = Win8 Release|Win32
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Release|ARM64.ActiveCfg = Win7 Release|ARM64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Release|x64.ActiveCfg = Win7 Release|x64
		{1A6BC1F1-F16A-4653-B787-FAF5A0E50229}.Release|x86.ActiveCfg = Win7 Release|Win32
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Debug No AirPcap|ARM64.ActiveCfg = Debug No AirPcap|ARM64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Debug No AirPcap|ARM64.Build.0 = Debug No AirPcap|ARM64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Debug No AirPcap|x64.ActiveCfg = Debug No AirPcap|x64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Debug No AirPcap|x64.Build.0 = Debug No AirPcap|x64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Debug No AirPcap|x86.ActiveCfg = Debug No AirPcap|Win32
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Debug No AirPcap|x86.Build.0 = Debug No AirPcap|Win32
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Debug Win10 driver|ARM64.ActiveCfg = Release|ARM64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Debug Win10 driver|x64.ActiveCfg = Release|x64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Debug Win10 driver|x86.ActiveCfg = Release|Win32
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Debug Win7 driver|ARM64.ActiveCfg = Debug No AirPcap|ARM64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Debug Win7 driver|x64.ActiveCfg = Debug|x64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Debug Win7 driver|x86.ActiveCfg = Debug|Win32
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Debug Win8 driver|ARM64.ActiveCfg = Release|ARM64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Debug Win8 driver|x64.ActiveCfg = Release|x64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Debug Win8 driver|x86.ActiveCfg = Release|Win32
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Debug|ARM64.ActiveCfg = Debug No AirPcap|ARM64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Debug|ARM64.Build.0 = Debug No AirPcap|ARM64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Debug|x64.ActiveCfg = Debug|x64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Debug|x64.Build.0 = Debug|x64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Debug|x86.ActiveCfg = Debug|Win32
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Debug|x86.Build.0 = Debug|Win32
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.OEM Debug Win10 driver|ARM64.ActiveCfg = OEM Debug|ARM64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.OEM Debug Win10 driver|x64.ActiveCfg = Release|x64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.OEM Debug Win10 driver|x86.ActiveCfg = Release|Win32
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.OEM Debug|ARM64.ActiveCfg = OEM Debug No AirPcap|ARM64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.OEM Debug|ARM64.Build.0 = OEM Debug No AirPcap|ARM64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.OEM Debug|x64.ActiveCfg = OEM Debug|x64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.OEM Debug|x64.Build.0 = OEM Debug|x64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.OEM Debug|x86.ActiveCfg = OEM Debug|Win32
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.OEM Debug|x86.Build.0 = OEM Debug|Win32
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.OEM Release Win10 driver|ARM64.ActiveCfg = OEM Release|ARM64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.OEM Release Win10 driver|x64.ActiveCfg = Release|x64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.OEM Release Win10 driver|x86.ActiveCfg = Release|Win32
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.OEM Release Win8 driver|ARM64.ActiveCfg = OEM Release|ARM64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.OEM Release Win8 driver|x64.ActiveCfg = Release|x64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.OEM Release Win8 driver|x86.ActiveCfg = Release|Win32
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.OEM Release|ARM64.ActiveCfg = OEM Release No AirPcap|ARM64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.OEM Release|ARM64.Build.0 = OEM Release No AirPcap|ARM64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.OEM Release|x64.ActiveCfg = OEM Release|x64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.OEM Release|x64.Build.0 = OEM Release|x64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.OEM Release|x86.ActiveCfg = OEM Release|Win32
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.OEM Release|x86.Build.0 = OEM Release|Win32
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.OEM RO Release Win10 driver|ARM64.ActiveCfg = Release|ARM64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.OEM RO Release Win10 driver|x64.ActiveCfg = Release|x64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.OEM RO Release Win10 driver|x86.ActiveCfg = Release|Win32
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.OEM RO Release Win7 driver|ARM64.ActiveCfg = Release|ARM64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.OEM RO Release Win7 driver|x64.ActiveCfg = Release|x64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.OEM RO Release Win7 driver|x86.ActiveCfg = Release|Win32
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.OEM RO Release Win8 driver|ARM64.ActiveCfg = Release|ARM64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.OEM RO Release Win8 driver|x64.ActiveCfg = Release|x64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.OEM RO Release Win8 driver|x86.ActiveCfg = Release|Win32
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.OEM RO Release|ARM64.ActiveCfg = OEM Release No AirPcap|ARM64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.OEM RO Release|ARM64.Build.0 = OEM Release No AirPcap|ARM64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.OEM RO Release|x64.ActiveCfg = OEM Release|x64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.OEM RO Release|x64.Build.0 = OEM Release|x64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.OEM RO Release|x86.ActiveCfg = OEM Release|Win32
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.OEM RO Release|x86.Build.0 = OEM Release|Win32
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Release No AirPcap|ARM64.ActiveCfg = Release No AirPcap|ARM64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Release No AirPcap|ARM64.Build.0 = Release No AirPcap|ARM64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Release No AirPcap|x64.ActiveCfg = Release No AirPcap|x64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Release No AirPcap|x64.Build.0 = Release No AirPcap|x64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Release No AirPcap|x86.ActiveCfg = Release No AirPcap|Win32
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Release No AirPcap|x86.Build.0 = Release No AirPcap|Win32
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Release Win10 driver|ARM64.ActiveCfg = Release|ARM64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Release Win10 driver|x64.ActiveCfg = Release|x64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Release Win10 driver|x86.ActiveCfg = Release|Win32
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Release Win7 driver|ARM64.ActiveCfg = Release No AirPcap|ARM64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Release Win7 driver|x64.ActiveCfg = Release|x64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Release Win7 driver|x86.ActiveCfg = Release|Win32
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Release Win8 driver|ARM64.ActiveCfg = Release|ARM64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Release Win8 driver|x64.ActiveCfg = Release|x64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Release Win8 driver|x86.ActiveCfg = Release|Win32
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Release|ARM64.ActiveCfg = Release No AirPcap|ARM64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Release|ARM64.Build.0 = Release No AirPcap|ARM64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Release|x64.ActiveCfg = Release|x64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Release|x64.Build.0 = Release|x64
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Release|x86.ActiveCfg = Release|Win32
		{17D62EEB-EABF-4D94-B1FF-BCDAAFA7DA52}.Release|x86.Build.0 = Release|Win32
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Debug No AirPcap|ARM64.ActiveCfg = Debug|ARM64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Debug No AirPcap|ARM64.Build.0 = Debug|ARM64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Debug No AirPcap|x64.ActiveCfg = Debug|x64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Debug No AirPcap|x64.Build.0 = Debug|x64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Debug No AirPcap|x86.ActiveCfg = Debug|Win32
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Debug No AirPcap|x86.Build.0 = Debug|Win32
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Debug Win10 driver|ARM64.ActiveCfg = Release|ARM64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Debug Win10 driver|x64.ActiveCfg = Release|x64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Debug Win10 driver|x86.ActiveCfg = Release|Win32
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Debug Win7 driver|ARM64.ActiveCfg = Debug|ARM64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Debug Win7 driver|x64.ActiveCfg = Debug|x64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Debug Win7 driver|x86.ActiveCfg = Debug|Win32
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Debug Win8 driver|ARM64.ActiveCfg = Release|ARM64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Debug Win8 driver|x64.ActiveCfg = Release|x64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Debug Win8 driver|x86.ActiveCfg = Release|Win32
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Debug|ARM64.Build.0 = Debug|ARM64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Debug|x64.ActiveCfg = Debug|x64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Debug|x64.Build.0 = Debug|x64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Debug|x86.ActiveCfg = Debug|Win32
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Debug|x86.Build.0 = Debug|Win32
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.OEM Debug Win10 driver|ARM64.ActiveCfg = OEM Debug|ARM64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.OEM Debug Win10 driver|x64.ActiveCfg = Release|x64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.OEM Debug Win10 driver|x86.ActiveCfg = Release|Win32
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.OEM Debug|ARM64.ActiveCfg = OEM Debug|ARM64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.OEM Debug|x64.ActiveCfg = OEM Debug|x64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.OEM Debug|x86.ActiveCfg = OEM Debug|Win32
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.OEM Release Win10 driver|ARM64.ActiveCfg = OEM Release|ARM64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.OEM Release Win10 driver|x64.ActiveCfg = Release|x64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.OEM Release Win10 driver|x86.ActiveCfg = Release|Win32
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.OEM Release Win8 driver|ARM64.ActiveCfg = OEM Release|ARM64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.OEM Release Win8 driver|x64.ActiveCfg = Release|x64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.OEM Release Win8 driver|x86.ActiveCfg = Release|Win32
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.OEM Release|ARM64.ActiveCfg = OEM Release|ARM64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.OEM Release|x64.ActiveCfg = OEM Release|x64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.OEM Release|x86.ActiveCfg = OEM Release|Win32
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.OEM RO Release Win10 driver|ARM64.ActiveCfg = Release|ARM64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.OEM RO Release Win10 driver|x64.ActiveCfg = Release|x64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.OEM RO Release Win10 driver|x86.ActiveCfg = Release|Win32
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.OEM RO Release Win7 driver|ARM64.ActiveCfg = Release|ARM64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.OEM RO Release Win7 driver|x64.ActiveCfg = Release|x64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.OEM RO Release Win7 driver|x86.ActiveCfg = Release|Win32
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.OEM RO Release Win8 driver|ARM64.ActiveCfg = Release|ARM64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.OEM RO Release Win8 driver|x64.ActiveCfg = Release|x64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.OEM RO Release Win8 driver|x86.ActiveCfg = Release|Win32
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.OEM RO Release|ARM64.ActiveCfg = OEM Release|ARM64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.OEM RO Release|x64.ActiveCfg = OEM Release|x64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.OEM RO Release|x86.ActiveCfg = OEM Release|Win32
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Release No AirPcap|ARM64.ActiveCfg = Release|ARM64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Release No AirPcap|ARM64.Build.0 = Release|ARM64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Release No AirPcap|x64.ActiveCfg = Release|x64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Release No AirPcap|x64.Build.0 = Release|x64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Release No AirPcap|x86.ActiveCfg = Release|Win32
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Release No AirPcap|x86.Build.0 = Release|Win32
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Release Win10 driver|ARM64.ActiveCfg = Release|ARM64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Release Win10 driver|x64.ActiveCfg = Release|x64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Release Win10 driver|x86.ActiveCfg = Release|Win32
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Release Win7 driver|ARM64.ActiveCfg = Release|ARM64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Release Win7 driver|x64.ActiveCfg = Release|x64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Release Win7 driver|x86.ActiveCfg = Release|Win32
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Release Win8 driver|ARM64.ActiveCfg = Release|ARM64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Release Win8 driver|x64.ActiveCfg = Release|x64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Release Win8 driver|x86.ActiveCfg = Release|Win32
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Release|ARM64.ActiveCfg = Release|ARM64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Release|ARM64.Build.0 = Release|ARM64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Release|x64.ActiveCfg = Release|x64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Release|x64.Build.0 = Release|x64
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Release|x86.ActiveCfg = Release|Win32
		{917BE5CC-CE5E-4476-A9E7-3B1F96E9FC43}.Release|x86.Build.0 = Release|Win32
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Debug No AirPcap|ARM64.ActiveCfg = Debug|ARM64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Debug No AirPcap|ARM64.Build.0 = Debug|ARM64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Debug No AirPcap|x64.ActiveCfg = Debug|x64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Debug No AirPcap|x64.Build.0 = Debug|x64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Debug No AirPcap|x86.ActiveCfg = Debug|Win32
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Debug No AirPcap|x86.Build.0 = Debug|Win32
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Debug Win10 driver|ARM64.ActiveCfg = Release|ARM64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Debug Win10 driver|x64.ActiveCfg = Release|x64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Debug Win10 driver|x86.ActiveCfg = Release|Win32
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Debug Win7 driver|ARM64.ActiveCfg = Debug|ARM64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Debug Win7 driver|x64.ActiveCfg = Debug|x64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Debug Win7 driver|x86.ActiveCfg = Debug|Win32
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Debug Win8 driver|ARM64.ActiveCfg = Release|ARM64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Debug Win8 driver|x64.ActiveCfg = Release|x64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Debug Win8 driver|x86.ActiveCfg = Release|Win32
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Debug|ARM64.Build.0 = Debug|ARM64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Debug|x64.ActiveCfg = Debug|x64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Debug|x64.Build.0 = Debug|x64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Debug|x86.ActiveCfg = Debug|Win32
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Debug|x86.Build.0 = Debug|Win32
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.OEM Debug Win10 driver|ARM64.ActiveCfg = OEM Debug|ARM64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.OEM Debug Win10 driver|x64.ActiveCfg = Release|x64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.OEM Debug Win10 driver|x86.ActiveCfg = Release|Win32
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.OEM Debug|ARM64.ActiveCfg = OEM Debug|ARM64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.OEM Debug|x64.ActiveCfg = OEM Debug|x64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.OEM Debug|x86.ActiveCfg = OEM Debug|Win32
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.OEM Release Win10 driver|ARM64.ActiveCfg = OEM Release|ARM64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.OEM Release Win10 driver|x64.ActiveCfg = Release|x64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.OEM Release Win10 driver|x86.ActiveCfg = Release|Win32
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.OEM Release Win8 driver|ARM64.ActiveCfg = OEM Release|ARM64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.OEM Release Win8 driver|x64.ActiveCfg = Release|x64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.OEM Release Win8 driver|x86.ActiveCfg = Release|Win32
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.OEM Release|ARM64.ActiveCfg = OEM Release|ARM64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.OEM Release|x64.ActiveCfg = OEM Release|x64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.OEM Release|x86.ActiveCfg = OEM Release|Win32
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.OEM RO Release Win10 driver|ARM64.ActiveCfg = Release|ARM64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.OEM RO Release Win10 driver|x64.ActiveCfg = Release|x64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.OEM RO Release Win10 driver|x86.ActiveCfg = Release|Win32
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.OEM RO Release Win7 driver|ARM64.ActiveCfg = Release|ARM64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.OEM RO Release Win7 driver|x64.ActiveCfg = Release|x64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.OEM RO Release Win7 driver|x86.ActiveCfg = Release|Win32
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.OEM RO Release Win8 driver|ARM64.ActiveCfg = Release|ARM64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.OEM RO Release Win8 driver|x64.ActiveCfg = Release|x64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.OEM RO Release Win8 driver|x86.ActiveCfg = Release|Win32
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.OEM RO Release|ARM64.ActiveCfg = OEM Release|ARM64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.OEM RO Release|x64.ActiveCfg = OEM Release|x64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.OEM RO Release|x86.ActiveCfg = OEM Release|Win32
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Release No AirPcap|ARM64.ActiveCfg = Release|ARM64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Release No AirPcap|ARM64.Build.0 = Release|ARM64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Release No AirPcap|x64.ActiveCfg = Release|x64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Release No AirPcap|x64.Build.0 = Release|x64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Release No AirPcap|x86.ActiveCfg = Release|Win32
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Release No AirPcap|x86.Build.0 = Release|Win32
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Release Win10 driver|ARM64.ActiveCfg = Release|ARM64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Release Win10 driver|x64.ActiveCfg = Release|x64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Release Win10 driver|x86.ActiveCfg = Release|Win32
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Release Win7 driver|ARM64.ActiveCfg = Release|ARM64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Release Win7 driver|x64.ActiveCfg = Release|x64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Release Win7 driver|x86.ActiveCfg = Release|Win32
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Release Win8 driver|ARM64.ActiveCfg = Release|ARM64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Release Win8 driver|x64.ActiveCfg = Release|x64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Release Win8 driver|x86.ActiveCfg = Release|Win32
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Release|ARM64.ActiveCfg = Release|ARM64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Release|ARM64.Build.0 = Release|ARM64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Release|x64.ActiveCfg = Release|x64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Release|x64.Build.0 = Release|x64
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Release|x86.ActiveCfg = Release|Win32
		{044CB4DC-827D-4134-B14B-DE114E884BB9}.Release|x86.Build.0 = Release|Win32
		{5D8A2717-4F35-4402-B868-45612D27291B}.Debug No AirPcap|ARM64.ActiveCfg = Debug|ARM64
		{5D8A2717-4F35-4402-B868-45612D27291B}.Debug No AirPcap|ARM64.Build.0 = Debug|ARM64
		{5D8A2717-4F35-4402-B868-45612D27291B}.Debug No AirPcap|x64.ActiveCfg = Debug|x64
		{5D8A2717-4F35-4402-B868-45612D27291B}.Debug No AirPcap|x64.Build.0 = Debug|x64
		{5D8A2717-4F35-4402-B868-45612D27291B}.Debug No AirPcap|x86.ActiveCfg = Debug|Win32
		{5D8A2717-4F35-4402-B868-45612D27291B}.Debug No AirPcap|x86.Build.0 = Debug|Win32
		{5D8A2717-4F35-4402-B868-45612D27291B}.Debug Win10 driver|ARM64.ActiveCfg = Release|ARM64
		{5D8A2717-4F35-4402-B868-45612D27291B}.Debug Win10 driver|x64.ActiveCfg = Release|x64
		{5D8A2717-4F35-4402-B868-45612D27291B}.Debug Win10 driver|x86.ActiveCfg = Release|Win32
		{5D8A2717-4F35-4402-B868-45612D27291B}.Debug Win7 driver|ARM64.ActiveCfg = Debug|ARM64
		{5D8A2717-4F35-4402-B868-45612D27291B}.Debug Win7 driver|x64.ActiveCfg = Debug|x64
		{5D8A2717-4F35-4402-B868-45612D27291B}.Debug Win7 driver|x86.ActiveCfg = Debug|Win32
		{5D8A2717-4F35-4402-B868-45612D27291B}.Debug Win8 driver|ARM64.ActiveCfg = Release|ARM64
		{5D8A2717-4F35-4402-B868-45612D27291B}.Debug Win8 driver|x64.ActiveCfg = Release|x64
		{5D8A2717-4F35-4402-B868-45612D27291B}.Debug Win8 driver|x86.ActiveCfg = Release|Win32
		{5D8A2717-4F35-4402-B868-45612D27291B}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{5D8A2717-4F35-4402-B868-45612D27291B}.Debug|ARM64.Build.0 = Debug|ARM64
		{5D8A2717-4F35-4402-B868-45612D27291B}.Debug|x64.ActiveCfg = Debug|x64
		{5D8A2717-4F35-4402-B868-45612D27291B}.Debug|x64.Build.0 = Debug|x64
		{5D8A2717-4F35-4402-B868-45612D27291B}.Debug|x86.ActiveCfg = Debug|Win32
		{5D8A2717-4F35-4402-B868-45612D27291B}.Debug|x86.Build.0 = Debug|Win32
		{5D8A2717-4F35-4402-B868-45612D27291B}.OEM Debug Win10 driver|ARM64.ActiveCfg = OEM Debug|ARM64
		{5D8A2717-4F35-4402-B868-45612D27291B}.OEM Debug Win10 driver|x64.ActiveCfg = Release|x64
		{5D8A2717-4F35-4402-B868-45612D27291B}.OEM Debug Win10 driver|x86.ActiveCfg = Release|Win32
		{5D8A2717-4F35-4402-B868-45612D27291B}.OEM Debug|ARM64.ActiveCfg = OEM Debug|ARM64
		{5D8A2717-4F35-4402-B868-45612D27291B}.OEM Debug|x64.ActiveCfg = OEM Debug|x64
		{5D8A2717-4F35-4402-B868-45612D27291B}.OEM Debug|x86.ActiveCfg = OEM Debug|Win32
		{5D8A2717-4F35-4402-B868-45612D27291B}.OEM Release Win10 driver|ARM64.ActiveCfg = OEM Release|ARM64
		{5D8A2717-4F35-4402-B868-45612D27291B}.OEM Release Win10 driver|x64.ActiveCfg = Release|x64
		{5D8A2717-4F35-4402-B868-45612D27291B}.OEM Release Win10 driver|x86.ActiveCfg = Release|Win32
		{5D8A2717-4F35-4402-B868-45612D27291B}.OEM Release Win8 driver|ARM64.ActiveCfg = OEM Release|ARM64
		{5D8A2717-4F35-4402-B868-45612D27291B}.OEM Release Win8 driver|x64.ActiveCfg = Release|x64
		{5D8A2717-4F35-4402-B868-45612D27291B}.OEM Release Win8 driver|x86.ActiveCfg = Release|Win32
		{5D8A2717-4F35-4402-B868-45612D27291B}.OEM Release|ARM64.ActiveCfg = OEM Release|ARM64
		{5D8A2717-4F35-4402-B868-45612D27291B}.OEM Release|x64.ActiveCfg = OEM Release|x64
		{5D8A2717-4F35-4402-B868-45612D27291B}.OEM Release|x86.ActiveCfg = OEM Release|Win32
		{5D8A2717-4F35-4402-B868-45612D27291B}.OEM RO Release Win10 driver|ARM64.ActiveCfg = Release|ARM64
		{5D8A2717-4F35-4402-B868-45612D27291B}.OEM RO Release Win10 driver|x64.ActiveCfg = Release|x64
		{5D8A2717-4F35-4402-B868-45612D27291B}.OEM RO Release Win10 driver|x86.ActiveCfg = Release|Win32
		{5D8A2717-4F35-4402-B868-45612D27291B}.OEM RO Release Win7 driver|ARM64.ActiveCfg = Release|ARM64
		{5D8A2717-4F35-4402-B868-45612D27291B}.OEM RO Release Win7 driver|x64.ActiveCfg = Release|x64
		{5D8A2717-4F35-4402-B868-45612D27291B}.OEM RO Release Win7 driver|x86.ActiveCfg = Release|Win32
		{5D8A2717-4F35-4402-B868-45612D27291B}.OEM RO Release Win8 driver|ARM64.ActiveCfg = Release|ARM64
		{5D8A2717-4F35-4402-B868-45612D27291B}.OEM RO Release Win8 driver|x64.ActiveCfg = Release|x64
		{5D8A2717-4F35-4402-B868-45612D27291B}.OEM RO Release Win8 driver|x86.ActiveCfg = Release|Win32
		{5D8A2717-4F35-4402-B868-45612D27291B}.OEM RO Release|ARM64.ActiveCfg = OEM Release|ARM64
		{5D8A2717-4F35-4402-B868-45612D27291B}.OEM RO Release|x64.ActiveCfg = OEM Release|x64
		{5D8A2717-4F35-4402-B868-45612D27291B}.OEM RO Release|x86.ActiveCfg = OEM Release|Win32
		{5D8A2717-4F35-4402-B868-45612D27291B}.Release No AirPcap|ARM64.ActiveCfg = Release|ARM64
		{5D8A2717-4F35-4402-B868-45612D27291B}.Release No AirPcap|ARM64.Build.0 = Release|ARM64
		{5D8A2717-4F35-4402-B868-45612D27291B}.Release No AirPcap|x64.ActiveCfg = Release|x64
		{5D8A2717-4F35-4402-B868-45612D27291B}.Release No AirPcap|x64.Build.0 = Release|x64
		{5D8A2717-4F35-4402-B868-45612D27291B}.Release No AirPcap|x86.ActiveCfg = Release|Win32
		{5D8A2717-4F35-4402-B868-45612D27291B}.Release No AirPcap|x86.Build.0 = Release|Win32
		{5D8A2717-4F35-4402-B868-45612D27291B}.Release Win10 driver|ARM64.ActiveCfg = Release|ARM64
		{5D8A2717-4F35-4402-B868-45612D27291B}.Release Win10 driver|x64.ActiveCfg = Release|x64
		{5D8A2717-4F35-4402-B868-45612D27291B}.Release Win10 driver|x86.ActiveCfg = Release|Win32
		{5D8A2717-4F35-4402-B868-45612D27291B}.Release Win7 driver|ARM64.ActiveCfg = Release|ARM64
		{5D8A2717-4F35-4402-B868-45612D27291B}.Release Win7 driver|x64.ActiveCfg = Release|x64
		{5D8A2717-4F35-4402-B868-45612D27291B}.Release Win7 driver|x86.ActiveCfg = Release|Win32
		{5D8A2717-4F35-4402-B868-45612D27291B}.Release Win8 driver|ARM64.ActiveCfg = Release|ARM64
		{5D8A2717-4F35-4402-B868-45612D27291B}.Release Win8 driver|x64.ActiveCfg = Release|x64
		{5D8A2717-4F35-4402-B868-45612D27291B}.Release Win8 driver|x86.ActiveCfg = Release|Win32
		{5D8A2717-4F35-4402-B868-45612D27291B}.Release|ARM64.ActiveCfg = Release|ARM64
		{5D8A2717-4F35-4402-B868-45612D27291B}.Release|ARM64.Build.0 = Release|ARM64
		{5D8A2717-4F35-4402-B868-45612D27291B}.Release|x64.ActiveCfg = Release|x64
		{5D8A2717-4F35-4402-B868-45612D27291B}.Release|x64.Build.0 = Release|x64
		{5D8A2717-4F35-4402-B868-45612D27291B}.Release|x86.ActiveCfg = Release|Win32
		{5D8A2717-4F35-4402-B868-45612D27291B}.Release|x86.Build.0 = Release|Win32
		{C87689C8-9CEE-4E97-953C-7C981385522F}.Debug No AirPcap|ARM64.ActiveCfg = Debug|x64
		{C87689C8-9CEE-4E97-953C-7C981385522F}.Debug No AirPcap|x64.ActiveCfg = Debug|x64
		{C87689C8-9CEE-4E97-953C-7C981385522F}.Debug No AirPcap|x86.ActiveCfg = Debug|Win32
		{C87689C8-9CEE-4E97-953C-7C981385522F}.Debug Win10 driver|ARM64.ActiveCfg = Debug|x64
		{C87689C8-9CEE-4E97-953C-7C981385522F}.Debug Win10 driver|x64.ActiveCfg = Debug|x64
		{C87689C8-9CEE-4E97-953C-7C981385522F}.Debug Win10 driver|x86.ActiveCfg = Debug|Win32
		{C87689C8-9CEE-4E97-953C-7C981385522F}.Debug Win7 driver|ARM64.ActiveCfg = Debug|x64
		{C87689C8-9CEE-4E97-953C-7C981385522F}.Debug Win7 driver|x64.ActiveCfg = Debug|x64
		{C87689C8-9CEE-4E97-953C-7C981385522F}.Debug Win7 driver|x86.ActiveCfg = Debug|Win32
		{C87689C8-9CEE-4E97-953C-7C981385522F}.Debug Win8 driver|ARM64.ActiveCfg = Debug|x64
		{C87689C8-9CEE-4E97-953C-7C981385522F}.Debug Win8 driver|x64.ActiveCfg = Debug|x64
		{C87689C8-9CEE-4E97-953C-7C981385522F}.Debug Win8 driver|x86.ActiveCfg = Debug|Win32
		{C87689C8-9CEE-4E97-953C-7C981385522F}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{C87689C8-9CEE-4E97-953C-7C981385522F}.Debug|ARM64.Build.0 = Debug|ARM64
		{C87689C8-9CEE-4E97-953C-7C981385522F}.Debug|x64.ActiveCfg = Debug|x64
		{C87689C8-9CEE-4E97-953C-7C981385522F}.Debug|x64.Build.0 = Debug|x64
		{C87689C8-9CEE-4E97-953C-7C981385522F}.Debug|x86.ActiveCfg = Debug|Win32
		{C87689C8-9CEE-4E97-953C-7C981385522F}.Debug|x86.Build.0 = Debug|Win32
		{C87689C8-9CEE-4E97-953C-7C981385522F}.OEM Debug Win10 driver|ARM64.ActiveCfg = Debug|x64
		{C87689C8-9CEE-4E97-953C-7C981385522F}.OEM Debug Win10 driver|x64.ActiveCfg = Debug|x64
		{C87689C8-9CEE-4E97-953C-7C981385522F}.OEM Debug Win10 driver|x86.ActiveCfg = Debug|Win32
		{C87689C8-9CEE-4E97-953C-7C981385522F}.OEM Debug|ARM64.ActiveCfg = Debug|x64
		{C87689C8-9CEE-4E97-953C-7C981385522F}.OEM Debug|x64.ActiveCfg = Debug|x64
		{C87689C8-9CEE-4E97-953C-7C981385522F}.OEM Debug|x86.ActiveCfg = Debug|Win32
		{C87689C8-9CEE-4E97-953C-7C981385522F}.OEM Release Win10 driver|ARM64.ActiveCfg = Release|x64
		{C87689C8-9CEE-4E97-953C-7C981385522F}.OEM Release Win10 driver|x64.ActiveCfg = Release|x64
		{C87689C8-9CEE-4E97-953C-7C981385522F}.OEM Release Win10 driver|x86.ActiveCfg = Release|Win32
		{C87689C8-9CEE-4E97-953C-7C981385522F}.OEM Release Win8 driver|ARM64.ActiveCfg = Release|x64
		{C87689C8-9CEE-4E97-953C-7C981385522F}.OEM Release Win8 driver|x64.ActiveCfg = Release|x64
		{C87689C8-9CEE-4E97-953C-7C981385522F}.OEM Release Win8 driver|x86.ActiveCfg = Release|Win32
		{C87689C8-9CEE-4E97-953C-7C981385522F}.OEM Release|ARM64.ActiveCfg = Release|x64
		{C87689C8-9CEE-4E97-953C-7C981385522F}.OEM Release|x64.ActiveCfg = Release|x64
		{C87689C8-9CEE-4E97-953C-7C981385522F}.OEM Release|x86.ActiveCfg = Release|Win32
		{C87689C8-9CEE-4E97-953C-7C981385522F}.OEM RO Release Win10 driver|ARM64.ActiveCfg = Release|x64
		{C87689C8-9CEE-4E97-953C-7C981385522F}.OEM RO Release Win10 driver|x64.ActiveCfg = Release|x64
		{C87689C8-9CEE-4E97-953C-7C981385522F}.OEM RO Release Win10 driver|x86.ActiveCfg = Release|Win32
		{C87689C8-9CEE-4E97-953C-7C981385522F}.OEM RO Release Win7 driver|ARM64.ActiveCfg = Release|x64
		{C87689C8-9CEE-4E97-953C-7C981385522F}.OEM RO Release Win7 driver|x64.ActiveCfg = Release|x64
		{C87689C8-9CEE-4E97-953C-7C981385522F}.OEM RO Release Win7 driver|x86.ActiveCfg = Release|Win32
		{C87689C8-9CEE-4E97-953C-7C981385522F}.OEM RO Release Win8 driver|ARM64.ActiveCfg = Release|x64
		{C87689C8-9CEE-4E97-953C-7C981385522F}.OEM RO Release Win8 driver|x64.ActiveCfg = Release|x64
		{C87689C8-9CEE-4E97-953C-7C981385522F}.OEM RO Release Win8 driver|x86.ActiveCfg = Release|Win32
		{C87689C8-9CEE-4E97-953C-7C981385522F}.OEM RO Release|ARM64.ActiveCfg = Release|x64
		{C87689C8-9CEE-4E97-953C-7C981385522F}.OEM RO Release|x64.ActiveCfg = Release|x64
		{C87689C8-9CEE-4E97-953C-7C981385522F}.OEM RO Release|x86.ActiveCfg = Release|Win32
		{C87689C8-9CEE-4E97-953C-7C981385522F}.Release No AirPcap|ARM64.ActiveCfg = Release|x64
		{C87689C8-9CEE-4E97-953C-7C981385522F}.Release No AirPcap|x64.ActiveCfg = Release|x64
		{C87689C8-9CEE-4E97-953C-7C981385522F}.Release No AirPcap|x86.ActiveCfg = Release|Win32
		{C87689C8-9CEE-4E97-953C-7C981385522F}.Release Win10 driver|ARM64.ActiveCfg = Release|x64
		{C87689C8-9CEE-4E97-953C-7C981385522F}.Release Win10 driver|x64.ActiveCfg = Release|x64
		{C87689C8-9CEE-4E97-953C-7C981385522F}.Release Win10 driver|x86.ActiveCfg = Release|Win32
		{C87689C8-9CEE-4E97-953C-7C981385522F}.Release Win7 driver|ARM64.ActiveCfg = Release|x64
		{C87689C8-9CEE-4E97-953C-7C981385522F}.Release Win7 driver|x64.ActiveCfg = Release|x64
		{C87689C8-9CEE-4E97-953C-7C981385522F}.Release Win7 driver|x86.ActiveCfg = Release|Win32
		{C87689C8-9CEE-4E97-953C-7C981385522F}.Release Win8 driver|ARM64.ActiveCfg = Release|x64
		{C87689C8-9CEE-4E97-953C-7C981385522F}.Release Win8 driver|x64.ActiveCfg = Release|x64
		{C87689C8-9CEE-4E97-953C-7C981385522F}.Release Win8 driver|x86.ActiveCfg = Release|Win32
		{C87689C8-9CEE-4E97-953C-7C981385522F}.Release|ARM64.ActiveCfg = Release|ARM64
		{C87689C8-9CEE-4E97-953C-7C981385522F}.Release|ARM64.Build.0 = Release|ARM64
		{C87689C8-9CEE-4E97-953C-7C981385522F}.Release|x64.ActiveCfg = Release|x64
		{C87689C8-9CEE-4E97-953C-7C981385522F}.Release|x64.Build.0 = Release|x64
		{C87689C8-9CEE-4E97-953C-7C981385522F}.Release|x86.ActiveCfg = Release|Win32
		{C87689C8-9CEE-4E97-953C-7C981385522F}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {8740DD97-0A53-4514-B1C2-247294161C48}
	EndGlobalSection
EndGlobal

```

`test/README.md`:

```md
#Tests for Npcap.

Requirements:

* Npcap installed
* Nmap installed
* Some examples from the SDK

##SDK examples required

From `Examples-pcap`:

* iflist.exe
* pcap_filter.exe
* sendpack.exe
* readfile.exe

From `Examples-remote`:

* sendcap.exe

```

`test/make_test.bat`:

```bat
SET SAVEPID=0

set ARCH=x86
rem All platforms support x86 emulation
Call :DO_TEST x86 || goto :error

rem If we're running in native arch,
if "%PROCESSOR_ARCHITEW6432%" == "" (
	rem and it's x86, we're done.
	if "%PROCESSOR_ARCHITECTURE%" == "x86" goto :quit

	rem Otherwise, test the native arch
	set ARCH=%PROCESSOR_ARCHITECTURE%
) else (
	rem Otherwise, we're running in WOW64, so test the native arch
	set ARCH=%PROCESSOR_ARCHITEW6432%
)

if "%ARCH%" == "AMD64" (
	set ARCH=x64
) else (
	if NOT "%ARCH%" == "ARM64" goto :error
)

Call :DO_TEST %ARCH% || goto :error

:quit
pause
exit /b %ERR%

:error
set ERR=%ERRORLEVEL%
if "%ERR%" == "" set ERR=1
echo %ARCH% Failed: %ERR%
if %SAVEPID% NEQ 0 taskkill /PID %SAVEPID%
goto :quit

:DO_TEST

echo Testing iflist...
set devname=""
for /f "TOKENS=1,2" %%a in ('nmap --iflist') do @if %%a==lo0 set devname=%%b
if not "%devname%"=="\Device\NPF_Loopback" goto :error
.\%1\iflist.exe || goto :error

echo Testing Loopback operations...
echo Testing pcap_filter...
del loopback-%1.pcap
start .\%1\pcap_filter.exe -o loopback-%1.pcap -s %devname% -f tcp -l 1450
for /F "TOKENS=1,2,*" %%a in ('tasklist /FI "IMAGENAME eq pcap_filter.exe"') do set SAVEPID=%%b
if "%SAVEPID%" == "" goto :error

echo Running nmap...
nmap -F -O -d -n localhost || goto :error
nmap -F -O -d -n -6 localhost || goto :error

echo Testing sendpack...
.\%1\sendpack.exe %devname% || goto :error

echo Killing pcap_filter...
taskkill /PID %SAVEPID% || goto :error
SET SAVEPID=0

echo Reading dump file...
.\%1\readfile.exe -v loopback-%1.pcap || goto :error

echo Replaying dump file...
.\%1\sendcap.exe loopback-%1.pcap %devname% s || goto :error


echo Checking for Internet...
set devname=""
for /f "TOKENS=1,3" %%a in ('nmap --route-dst scanme.nmap.org') do @if %%b==srcaddr set ifname=%%a
if %ifname%=="" goto :error
if %ifname%=="No" goto :error
for /f "TOKENS=1,2" %%a in ('nmap --iflist') do @if %%a==%ifname% set devname=%%b
if not %devname:~0,12%==\Device\NPF_ goto :error

echo Testing pcap_filter...
del scanme-%1.pcap
start .\%1\pcap_filter.exe -o scanme-%1.pcap -s %devname% -f tcp -l 1450
for /F "TOKENS=1,2,*" %%a in ('tasklist /FI "IMAGENAME eq pcap_filter.exe"') do set SAVEPID=%%b

echo Running nmap...
nmap -F -O -d -n scanme.nmap.org || goto :error
rem Need IPv6 connectivity to test this:
rem nmap -F -O -d -n -6 scanme.nmap.org || goto :error

echo Testing sendpack...
.\%1\sendpack.exe %devname% || goto :error

echo Killing pcap_filter...
taskkill /PID %SAVEPID% || goto :error
SET SAVEPID=0

echo Reading dump file...
.\%1\readfile.exe -v scanme-%1.pcap || goto :error

echo Replaying dump file...
.\%1\sendcap.exe scanme-%1.pcap %devname% || goto :error

goto :EOF

```

`test/static.props`:

```props
<?xml version="1.0" encoding="utf-8"?> 
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemDefinitionGroup Condition="'$(Configuration)'=='Release'">
    <ClCompile>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)'=='Debug'">
    <ClCompile>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
  </ItemDefinitionGroup>
</Project>

```

`version.h`:

```h
/***********************IMPORTANT NPCAP LICENSE TERMS***********************
 *
 * Npcap (https://npcap.com) is a Windows packet sniffing driver and library and
 * is copyright (c) 2013-2025 by Nmap Software LLC ("The Nmap Project").  All
 * rights reserved.
 *
 * Even though Npcap source code is publicly available for review, it is not
 * open source software and may not be redistributed or used in other software
 * without special permission from the Nmap Project. The standard (free) version
 * is usually limited to installation on five systems. For more details, see the
 * LICENSE file included with Npcap and also available at
 * https://github.com/nmap/npcap/blob/master/LICENSE. This header file
 * summarizes a few important aspects of the Npcap license, but is not a
 * substitute for that full Npcap license agreement.
 *
 * We fund the Npcap project by selling two types of commercial licenses to a
 * special Npcap OEM edition:
 *
 * 1) The Npcap OEM Redistribution License allows companies distribute Npcap OEM
 * within their products. Licensees generally use the Npcap OEM silent
 * installer, ensuring a seamless experience for end users. Licensees may choose
 * between a perpetual unlimited license or a quarterly term license, along with
 * options for commercial support and updates. Prices and details:
 * https://npcap.com/oem/redist.html
 *
 * 2) The Npcap OEM Internal-Use License is for organizations that wish to use
 * Npcap OEM internally, without redistribution outside their organization. This
 * allows them to bypass the 5-system usage cap of the Npcap free edition. It
 * includes commercial support and update options, and provides the extra Npcap
 * OEM features such as the silent installer for automated deployment. Prices
 * and details: https://npcap.com/oem/internal.html
 *
 * Both of these licenses include updates and support as well as a warranty.
 * Npcap OEM also includes a silent installer for unattended installation.
 * Further details about Npcap OEM are available from https://npcap.com/oem/,
 * and you are also welcome to contact us at sales@nmap.com to ask any questions
 * or set up a license for your organization.
 *
 * Free and open source software producers are also welcome to contact us for
 * redistribution requests. However, we normally recommend that such authors
 * instead ask your users to download and install Npcap themselves. It will be
 * free for them if they need 5 or fewer copies.
 *
 * If the Nmap Project (directly or through one of our commercial licensing
 * customers) has granted you additional rights to Npcap or Npcap OEM, those
 * additional rights take precedence where they conflict with the terms of the
 * license agreement.
 *
 * Since the Npcap source code is available for download and review, users
 * sometimes contribute code patches to fix bugs or add new features. By sending
 * these changes to the Nmap Project (including through direct email or our
 * mailing lists or submitting pull requests through our source code
 * repository), it is understood unless you specify otherwise that you are
 * offering the Nmap Project the unlimited, non-exclusive right to reuse,
 * modify, and relicense your code contribution so that we may (but are not
 * obligated to) incorporate it into Npcap. If you wish to specify special
 * license conditions or restrictions on your contributions, just say so when
 * you send them.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Warranty rights and commercial support are
 * available for the OEM Edition described above.
 *
 * Other copyright notices and attribution may appear below this license header.
 * We have kept those for attribution purposes, but any license terms granted by
 * those notices apply only to their original work, and not to any changes made
 * by the Nmap Project or to this entire file.
 *
 ***************************************************************************/
/*{{NO_DEPENDENCIES}}
 * Microsoft Developer Studio generated include file.
 *
 *
 * 3.1.0.24   -->  WinPcap  3.1 beta4
 * 3.1.0.27   -->  WinPcap  3.1 RTM
 * 3.2.0.29	  -->  WinPcap  3.2 alpha1
 * 4.0.0.374  -->  WinPcap  4.0 alpha1
 * 4.0.0.592  -->  WinPcap  4.0 beta1
 * 4.0.0.655  -->  WinPcap  4.0 beta2
 * 4.0.0.703  -->  WinPcap  4.0 beta3
 * 4.0.0.755  -->  WinPcap  4.0 RTM
 * 4.1.0.902  -->  WinPcap  4.1 beta
 * 4.1.0.1048 -->  WinPcap  4.1 beta2
 * 4.1.0.1124 -->  WinPcap  4.1 beta3
 * 4.1.0.1237 -->  WinPcap  4.1 beta4
 * 4.1.0.1452 -->  WinPcap  4.1 beta5
 * 4.1.0.1752 -->  WinPcap  4.1 RTM
 * 4.1.0.1753 -->  WinPcap  4.1.1 RTM
 * 4.1.0.2001 -->  WinPcap  4.1.2 RTM
 * 4.1.0.2980 -->  WinPcap  4.1.3 RTM
 * 4.1.0.3001 -->  WinPcap  4.1.3 RTM (NDIS6)
 * 0.1.0.710  -->  Npcap  0.01 beta (NDIS6)
 * 0.2.0.718  -->  Npcap  0.02 beta
 * 0.3.0.727  -->  Npcap  0.03 beta
 * 0.4.0.815  -->  Npcap  0.04 beta
 * 0.5.0.912  -->  Npcap  0.05 beta
 * 0.6.0.301  -->  Npcap  0.06 beta
 * 0.7.0.424  -->  Npcap  0.07 beta
 * 0.8.0.724  -->  Npcap  0.08 beta
 * 0.9.0.831  -->  Npcap  0.09 beta
 * 0.10.0.921 -->  Npcap  0.10 beta
 * 0.11.0.1121-->  Npcap  0.11 beta
 * 0.78.0.1123-->  Npcap  0.78 beta
 */

#define /*
 !define /**/ WINPCAP_MAJOR				5
#define /*
 !define /**/ WINPCAP_MINOR				1
/* WINPCAP_REV should be less than 256 to fit in UCHAR */
#define /*
 !define /**/ WINPCAP_REV				86
#define /*
 !define /**/ WINPCAP_BUILD				203
#define /*
 !define /**/ WINPCAP_VER_STRING		"1.87"
#define /*
 !define /**/ NPCAP_SDK_VERSION "1.16"

#define WINPCAP_COMPANY_NAME 			"Nmap Software LLC"

#ifdef RC_INVOKED
/* NPFInstall.exe uses the VersionInfo.ProductName to identify Npcap DLLs, so
 * we can't put OEM name in there unless we change that. */
#define WINPCAP_PRODUCT_NAME "Npcap"
#else

#ifdef /*
 !ifdef /**/ NPCAP_OEM
#ifdef /*
 !ifdef /**/ NPCAP_READ_ONLY
#define /*
 !define /**/ WINPCAP_PRODUCT_NAME 			"Npcap OEM RO"
#else /*
 !else /**/
#define /*
 !define /**/ WINPCAP_PRODUCT_NAME 			"Npcap OEM"
#endif /*
 !endif /**/
#else /*
 !else /**/
#define /*
 !define /**/ WINPCAP_PRODUCT_NAME 			"Npcap"
#endif /*
 !endif /**/

#endif /* RC_INVOKED */

#define WINPCAP_COPYRIGHT_STRING 		"Copyright (c) 2025, Nmap Software LLC.  All rights reserved."
#define /*
 !define /**/ WINPCAP_INSTALLERHELPER_COPYRIGHT_STRING "Copyright (c) 2025, Nmap Software LLC.  All rights reserved."
#define WINPCAP_RPCAPD_COPYRIGHT_STRING "Copyright (c) 2025, Nmap Software LLC.  All rights reserved."

#define WINPCAP_BUILD_DESCRIPTION 		""
#define WINPCAP_PRIVATE_BUILD			""

```

`wpcap/wpcap-cmake.bat`:

```bat
for /f "usebackq delims=#" %%a in (`"%ProgramFiles(x86)%\Microsoft Visual Studio\Installer\vswhere" -version 17 -property installationPath`) do set CMAKE="%%a\Common7\IDE\CommonExtensions\Microsoft\CMake\CMake\bin\cmake.exe"
set GENERATOR=Visual Studio 17 2022
set NPCAP_SDK=..\..\npcap-sdk-1.16
set AIRPCAP_SDK=..\..\Airpcap_Devpack
set CFG_FLAGS=/guard:cf

mkdir build-win32
cd build-win32
%CMAKE% -A Win32 -DCMAKE_DISABLE_FIND_PACKAGE_OpenSSL=TRUE -DOpenSSL_FOUND=FALSE -DCMAKE_C_FLAGS_INIT=%CFG_FLAGS% -DCMAKE_SHARED_LINKER_FLAGS_INIT=%CFG_FLAGS% -DPacket_ROOT=..\%NPCAP_SDK% -DLIBRARY_NAME=wpcap -DAirPcap_ROOT=..\%AIRPCAP_SDK% -G "%GENERATOR%" ..\libpcap\
cd ..

mkdir build-x64
cd build-x64
%CMAKE% -A x64 -DCMAKE_DISABLE_FIND_PACKAGE_OpenSSL=TRUE -DOpenSSL_FOUND=FALSE -DCMAKE_C_FLAGS_INIT=%CFG_FLAGS% -DCMAKE_SHARED_LINKER_FLAGS_INIT=%CFG_FLAGS% -DPacket_ROOT=..\%NPCAP_SDK% -DLIBRARY_NAME=wpcap -DAirPcap_ROOT=..\%AIRPCAP_SDK% -G "%GENERATOR%" ..\libpcap\
cd ..

rem AirPcap does not have ARM64 libs
mkdir build-ARM64
cd build-ARM64
%CMAKE% -A ARM64 -DCMAKE_DISABLE_FIND_PACKAGE_OpenSSL=TRUE -DOpenSSL_FOUND=FALSE -DCMAKE_C_FLAGS_INIT=%CFG_FLAGS% -DCMAKE_SHARED_LINKER_FLAGS_INIT=%CFG_FLAGS% -DPacket_ROOT=..\%NPCAP_SDK% -DLIBRARY_NAME=wpcap -G "%GENERATOR%" ..\libpcap\
cd ..

```