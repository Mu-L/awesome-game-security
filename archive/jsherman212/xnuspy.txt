Project Path: arc_jsherman212_xnuspy_6pxgal2l

Source Tree:

```txt
arc_jsherman212_xnuspy_6pxgal2l
├── LICENSE
├── Makefile
├── README.md
├── ent.xml
├── example
│   ├── Makefile
│   ├── README.md
│   ├── kaddr_of_port.c
│   ├── kernel_thread.c
│   ├── open1_hook.c
│   ├── shmem.c
│   └── user_client_monitor.c
├── include
│   ├── asm
│   │   ├── asm.h
│   │   └── asm_support.h
│   ├── common
│   │   ├── common.h
│   │   └── preboot_hook.h
│   ├── pf
│   │   ├── 13
│   │   │   └── pf.h
│   │   ├── 14
│   │   │   └── pf.h
│   │   ├── 15
│   │   │   └── pf.h
│   │   ├── offsets.h
│   │   ├── pf_common.h
│   │   └── pfs.h
│   ├── pongo.h
│   └── xnuspy
│       ├── el1
│       │   ├── debug.h
│       │   ├── externs.h
│       │   ├── libc.h
│       │   ├── mem.h
│       │   ├── pte.h
│       │   ├── tramp.h
│       │   ├── utils.h
│       │   └── wrappers.h
│       ├── el3
│       │   └── kpp.h
│       ├── xnuspy_cache.h
│       ├── xnuspy_ctl.h
│       └── xnuspy_structs.h
├── klog
│   ├── Makefile
│   ├── README.md
│   └── klog.c
├── loader
│   ├── Makefile
│   └── loader.c
├── module
│   ├── Makefile
│   ├── README.md
│   ├── common
│   │   ├── Makefile
│   │   ├── asm.c
│   │   └── common.c
│   ├── el1
│   │   ├── Makefile
│   │   ├── hook_system_check_sysctlbyname_hook.h
│   │   ├── hook_system_check_sysctlbyname_hook.s
│   │   ├── xnuspy_ctl
│   │   │   ├── Makefile
│   │   │   ├── debug.c
│   │   │   ├── libc.c
│   │   │   ├── mem.c
│   │   │   ├── pte.c
│   │   │   ├── tramp.c
│   │   │   ├── utils.c
│   │   │   ├── wrappers.c
│   │   │   └── xnuspy_ctl.c
│   │   ├── xnuspy_ctl_tramp.h
│   │   └── xnuspy_ctl_tramp.s
│   ├── el3
│   │   ├── Makefile
│   │   ├── kpp.c
│   │   └── kpp.s
│   ├── pf
│   │   ├── 13
│   │   │   ├── Makefile
│   │   │   └── pf.c
│   │   ├── 14
│   │   │   ├── Makefile
│   │   │   └── pf.c
│   │   ├── 15
│   │   │   ├── Makefile
│   │   │   └── pf.c
│   │   ├── Makefile
│   │   └── README.md
│   ├── preboot_hook.c
│   └── xnuspy.c
├── opdump
│   ├── Makefile
│   └── opdump.c
└── open1_hook.png

```

`LICENSE`:

```
MIT License

Copyright (c) 2020 Justin Sherman

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Makefile`:

```
RP = $(realpath $(shell pwd))

export RP

TARGET_DIRS = loader opdump module klog example

all : $(TARGET_DIRS)

.PHONY: all $(TARGET_DIRS)

$(TARGET_DIRS) :
	$(MAKE) -C $@

```

`README.md`:

```md
# xnuspy

![alt text](https://github.com/jsherman212/xnuspy/blob/master/open1_hook.png)

<sup>Output from the kernel log after compiling and running `example/open1_hook.c`</sup>

xnuspy is a pongoOS module that installs a new system call, `xnuspy_ctl`,
which allows you to hook kernel functions from userspace. It supports iOS 13.x,
iOS 14.x, and iOS 15.x on checkra1n 0.12.2 and up. 4K devices are not supported.

This module completely neuters KTRR/KPP and makes it possible to create
RWX memory inside EL1. Do not use this on your daily driver.

Requires `libusb`: `brew install libusb`

# Building
Run `make` in the top level directory. It'll build the loader and the module.

### Build Options
Add these before `make`.

- `XNUSPY_DEBUG=1`
	- Send debug output from xnuspy to the kernel log (`kprintf`).
- `XNUSPY_SERIAL=1`
	- Send debug output from xnuspy to `IOLog`.
- `XNUSPY_LEAKED_PAGE_LIMIT=n`
	- Set the number of pages xnuspy is allowed to leak before its garbage
collection thread starts deallocating them. Default is `64`. More info can
be found under [Debugging Kernel Panics](#debugging-kernel-panics).
- `XNUSPY_TRAMP_PAGES=n`
	- Set the number of pages xnuspy will reserve for its trampoline structures.
Default is 1. More info can be found under [Limits](#limits).

`XNUSPY_DEBUG` and `XNUSPY_SERIAL` do not depend on each other.

# Usage
After you've built everything, have checkra1n boot your device to a pongo
shell: `/Applications/checkra1n.app/Contents/MacOS/checkra1n -p`

In the same directory you built the loader and the module, do
`loader/loader module/xnuspy`. After doing that, xnuspy will do its thing and
in a few seconds your device will boot. `loader` will wait a couple more
seconds after issuing `xnuspy-getkernelv` in case SEPROM needs to be exploited.

# Known Issues
Sometimes a couple of my phones would get stuck at "Booting" after checkra1n's KPF
runs. I have yet to figure out what causes this, but if it happens, try again.
Also, if the device hangs after `bootx`, try again. Finally, marking the
compiled `xnuspy_ctl` code as executable on my iPhone X running iOS 13.3.1 is
a bit spotty, but succeeds 100% of the time on my other phones. If you panic
with a kernel instruction fetch abort when you execute your hook program,
try again.

# xnuspy_ctl
xnuspy will patch an `enosys` system call to point to `xnuspy_ctl_tramp`.
This is a small trampoline which marks the compiled `xnuspy_ctl` code as
executable and branches to it. You can find `xnuspy_ctl`'s implementation at
`module/el1/xnuspy_ctl/xnuspy_ctl.c` and examples in the `example` directory.

Inside `include/xnuspy/` is `xnuspy_ctl.h`, a header which defines constants
for `xnuspy_ctl`. It is meant to be included in all programs which hook
kernel functions.

You can use `sysctlbyname` to figure out which system call was patched:

```
size_t oldlen = sizeof(long);
long SYS_xnuspy_ctl = 0;
sysctlbyname("kern.xnuspy_ctl_callnum", &SYS_xnuspy_ctl, &oldlen, NULL, 0);
```

This system call takes four arguments, `flavor`, `arg1`, `arg2`, and `arg3`.
The flavor can either be `XNUSPY_CHECK_IF_PATCHED`, `XNUSPY_INSTALL_HOOK`,
`XNUSPY_REGISTER_DEATH_CALLBACK`, `XNUSPY_CALL_HOOKME`, `XNUSPY_CACHE_READ`,
`XNUSPY_KREAD`, `XNUSPY_KWRITE`, or `XNUSPY_GET_CURRENT_THREAD`.
The meaning of the next three arguments depend on the flavor.

## `XNUSPY_CHECK_IF_PATCHED`
This exists so you can check if `xnuspy_ctl` is present. Invoking it with this
flavor will cause it to return `999`. The values of the other arguments are
ignored.

## `XNUSPY_INSTALL_HOOK`
I designed this flavor to match [`MSHookFunction`](http://www.cydiasubstrate.com/api/c/MSHookFunction/)'s API.
`arg1` is the *UNSLID* address of the kernel function you wish to hook. If you
supply a slid address, you will most likely panic. `arg2` is a pointer to your
ABI-compatible replacement function. `arg3` is a pointer for `xnuspy_ctl` to
`copyout` the address of a trampoline that represents the original kernel
function. This can be `NULL` if you don't intend to call the original.

## `XNUSPY_REGISTER_DEATH_CALLBACK`
This flavor allows you to register an optional "death callback", a function xnuspy
will call when your hook program exits. It gives you a chance to clean up anything
you created from your kernel hooks. If you created any kernel threads, you would
tell them to terminate in this function.

Your callback is not invoked asynchronously, so if you block, you're preventing
xnuspy's garbage collection thread from executing.

`arg1` is a pointer to your callback function. The values of the other arguments
are ignored.

## `XNUSPY_CALL_HOOKME`
`hookme` is a small assembly stub which xnuspy exports through the xnuspy cache
for you to hook. Invoking `xnuspy_ctl` with this flavor will cause `hookme` to
get called, providing a way for you to easily gain kernel code execution without
having to hook an actual kernel function.

`arg1` is an argument that will be passed to `hookme` when it is invoked.
This can be `NULL`.

## `XNUSPY_CACHE_READ`
This flavor gives you a way to read from the xnuspy cache. It contains many useful
things like `kprintf`, `current_proc`, `kernel_thread_start`, some libc functions,
and the kernel slide so you don't have to find them yourself. For a complete list
of cache IDs, check out `example/xnuspy_ctl.h`. 

`arg1` is one of the cache IDs defined in `xnuspy_ctl.h` and `arg2` is a
pointer for `xnuspy_ctl` to `copyout` the address or value of what you requested.
The values of the other arguments are ignored.

## `XNUSPY_KREAD`
This flavor gives you an easy way to read kernel memory from userspace without
tfp0.

`arg1` is a kernel virtual address, `arg2` is the address of a userspace buffer,
and `arg3` is the size of that userspace buffer. `arg3` bytes will be written
from `arg1` to `arg2`.

## `XNUSPY_KWRITE`
This flavor gives you an easy way to write to kernel memory from userspace without
tfp0.

`arg1` is a kernel virtual address, `arg2` is the address of a userspace buffer,
and `arg3` is the size of that userspace buffer. `arg3` bytes will be written
from `arg2` to `arg1`.

## `XNUSPY_GET_CURRENT_THREAD`
This flavor provides userspace the kernel address of the calling thread.

`arg1` is a pointer for `xnuspy_ctl` to `copyout` the return value of
`current_thread`. The values of the other arguments are ignored.

### Errors
For all flavors except `XNUSPY_CHECK_IF_PATCHED`, `0` is returned on success.
Upon error, `-1` is returned and `errno` is set. `XNUSPY_CHECK_IF_PATCHED`
does not return any errors. XNU's `mach_to_bsd_errno` is used to convert a
`kern_return_t` to the appropriate `errno`. 

#### Errors Pertaining to `XNUSPY_INSTALL_HOOK`
`errno` is set to...
- `EEXIST` if:
  - A hook already exists for the unslid kernel function denoted by `arg1`.
- `ENOMEM` if:
  - `unified_kalloc` returned `NULL`.
- `ENOSPC` if:
  - There are no free `xnuspy_tramp` structs, a data structure internal to
xnuspy. This shouldn't happen unless you're hooking hundreds of kernel functions
*at the same time*. If you need more function hooks, check out [Limits](#limits).
- `ENOTSUP` if:
  - The caller is not from a Mach-O executable or dynamic library.
- `ENOENT` if:
  - `mh_for_addr` was unable to determine the Mach-O header corresponding to
`arg2` inside the caller's address space.
- `EFAULT` if:
  - The determined Mach-O header is not actually a Mach-O header. This will probably
never happen.
- `EIO` if:
  - `mach_make_memory_entry_64` did not return a memory entry for the entirety
of the determined Mach-O header's `__TEXT` and `__DATA` segments.

`errno` also depends on the return value of `vm_map_wire_external`,
`mach_vm_map_external`, `mach_make_memory_entry_64`, `copyin`, `copyout`, and
if applicable, the one-time initialization function.

If this flavor returns an error, the target kernel function was not hooked.
If you passed a non-`NULL` pointer for `arg3`, it may or may not have been
initialized. It's unsafe to use if it was.

#### Errors Pertaining to `XNUSPY_REGISTER_DEATH_CALLBACK`
`errno` is set to...
- `ENOENT` if:
  - The calling process hasn't hooked any kernel functions.

If this flavor returns an error, your death callback was not registered.

#### Errors Pertaining to `XNUSPY_CALL_HOOKME`
`errno` is set to...
- `ENOTSUP` if:
  - `hookme` is too far away from the memory containing the `xnuspy_tramp`
structures. This is determined inside of pongoOS, and can only happen if
xnuspy had to fallback to unused code already inside of the kernelcache.
In this case, calling `hookme` would almost certainly cause a kernel panic,
and you'll have to figure out another kernel function to hook.

If this flavor returns an error, `hookme` was not called.

#### Errors Pertaining to `XNUSPY_CACHE_READ`
`errno` is set to...
- `EINVAL` if:
  - The constant denoted by `arg1` does not represent anything in the cache.
  - `arg1` was `IO_LOCK`, but the kernel is iOS 14.4.2 or below or iOS 15.x.
  - `arg1` was `IPC_OBJECT_LOCK`, but the kernel is iOS 15.x.
  - `arg1` was `IPC_PORT_RELEASE_SEND`, but the kernel is iOS 14.5 or above.
  - `arg1` was `IPC_PORT_RELEASE_SEND_AND_UNLOCK`, but the kernel is iOS 14.4.2 or below.
  - `arg1` was `KALLOC_CANBLOCK`, but the kernel is iOS 14.x or above.
  - `arg1` was `KALLOC_EXTERNAL`, but the kernel is iOS 13.x.
  - `arg1` was `KFREE_ADDR`, but the kernel is iOS 14.x or above.
  - `arg1` was `KFREE_EXT`, but the kernel is iOS 13.x.
  - `arg1` was `PROC_REF`, but the kernel is iOS 14.8 or below.
  - `arg1` was `PROC_REF_LOCKED`, but the kernel is iOS 15.x.
  - `arg1` was `PROC_RELE`, but the kernel is iOS 14.8 or below.
  - `arg1` was `PROC_RELE_LOCKED`, but the kernel is iOS 15.x.
  - `arg1` was `VM_MAP_UNWIRE`, but the kernel is iOS 15.x.
  - `arg1` was `VM_MAP_UNWIRE_NESTED`, but the kernel is iOS 14.8 or below.

`errno` also depends on the return value of `copyout` and if applicable, the
return value of the one-time initialization function.

If this flavor returns an error, the pointer you passed for `arg2` was not
initialized.

#### Errors Pertaining to `XNUSPY_KREAD` and `XNUSPY_KWRITE`
`errno` is set to...
- `EFAULT` if:
  - Address translation failed for `arg1` or `arg2`. If you compiled with
`XNUSPY_DEBUG=1`, a message about it is printed to the kernel log.

If this flavor returns an error, kernel memory was not read/written.

#### Errors Pertaining to `XNUSPY_GET_CURRENT_THREAD`
If `copyout` fails, `errno` is set to its return value.

# Important Information

### Common Pitfalls
While writing replacement functions, it was easy to forget that I was writing
kernel code. Here's a couple things to keep in mind when you're writing hooks:

- *You cannot execute any userspace code that lives outside your program's
`__TEXT` segment*. You will panic if, for example, you accidentally call `printf`
instead of `kprintf`. You need to re-implement any libc function you want to call
if that function is not already available via `XNUSPY_CACHE_READ`.
You can create function pointers to other kernel functions and call those, though.
- *Many macros commonly used in userspace code are unsafe for the kernel.* For
example, `PAGE_SIZE` expands to `vm_page_size`, not a constant. You need to
disable PAN (on A10+, which I also don't recommend doing) before reading this 
variable or you will panic.
- *Make sure to compile your code with `-fno-stack-protector` and `-D_FORTIFY_SOURCE=0`* In some cases,
the device will have to read `___stack_chk_guard` by dereferencing another userspace
pointer, which will panic on A10+.
- *Just to be safe, don't compile your hook programs with compiler optimizations.*

Skimming https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/KernelProgramming/style/style.html is also recommended.

### Debugging Kernel Panics
Bugs are inevitable when writing code, so eventually you're going to cause a
kernel panic. A panic doesn't necessarily mean there's a bug with xnuspy, so
before opening an issue, please make sure that you still panic when you do
nothing but call the original function and return its value (if needed). If
you still panic, then it's likely an xnuspy bug (and please open an issue),
but if not, there's something wrong with your replacement.

Since xnuspy does not actually redirect execution to EL0 pages, debugging
a panic isn't as straightforward. Open up `module/el1/xnuspy_ctl/xnuspy_ctl.c`,
and right before the only call to `kwrite_instr` in `xnuspy_install_hook`,
add a call to `IOSleep` for a couple seconds. This is done to make sure there's
enough time before the device panics for logs to propagate. Re-compile xnuspy with
`XNUSPY_DEBUG=1 make -B` and load the module again. After loading the module,
if you haven't already, compile `klog` from `klog/`. Upload it to your device
and do `stdbuf -o0 ./klog | grep shared_mapping_kva`. Run your hook program again
and watch for a line from `klog` that looks like this:

`shared_mapping_kva: dist 0x7af4 uaddr 0x104797af4 umh 0x104790000 kmh 0xfffffff00c90c000`

If you're installing more than one hook, there will be more than one occurrence.
In that case, `dist` and `uaddr` will vary, but `umh` and `kmh` won't. `kmh`
points to the beginning of the kernel's mapping of your program's `__TEXT` segment.
Throw your hook program into your favorite disassembler and rebase it so its Mach-O
header is at the address of `kmh`. For IDA Pro, that's `Edit -> Segments -> Rebase
program...` with `Image base` bubbled. After your device panics and reboots again,
if there are addresses which correspond to the kernel's mapping of your replacement
in the panic log, they will match up with the disassembly. If there are none, then
you probably have some sort of subtle memory corruption inside your replacement.

xnuspy also has no way of knowing if a kernel thread is still executing (or will
execute) on the kernel's mapping of your program's `__TEXT` segment after your
hooks are uninstalled. One of the things xnuspy does to deal with this is to not
deallocate this mapping immediately after your hook program dies. Instead, it's
added to the end of a queue. Once xnuspy's garbage collection thread notices a
set limit has been exceeded regarding how many pages worth of mappings are held
in that queue, it will start to deallocate from the front of the queue and will
continue until that limit is no longer exceeded. By default, this limit is 1 MB,
or 64 pages.

While this does help enormously, the larger the `__TEXT` and `__DATA` segments
of your hook program become, the less likely xnuspy wins this race. If you are
panicking regularly and have a somewhat large hook program, try increasing
this limit by adding `XNUSPY_LEAKED_PAGE_LIMIT=n` before `make`. This will set
this limit to `n` pages rather than 64.

### Limits
xnuspy reserves one page of static kernel memory before XNU boots for its `xnuspy_tramp`
structs, letting you simultaneously hook around 225 kernel functions. If you want
more, you can add `XNUSPY_TRAMP_PAGES=n` before `make`. This will tell xnuspy to
reserve `n` pages of static memory for `xnuspy_tramp` structures. However, if
xnuspy has to fall back to unused code already inside the kernelcache, then this
is ignored. When this happens is detailed in [How It Works](#how-it-works).

### Logging
For some reason, logs from `os_log_with_args` don't show up in the stream
outputted from the command line tool `oslog`. Logs from `kprintf` don't
make it there either, but they *can* be seen with `dmesg`. However, `dmesg`
isn't a live feed, so I wrote `klog`, a tool which shows `kprintf` logs
in real time. Find it in `klog/`. I strongly recommend using that instead
of spamming `dmesg` for your `kprintf` messages.

If you get `open: Resource busy` after running `klog`, run this command
`launchctl unload /System/Library/LaunchDaemons/com.apple.syslogd.plist`
and try again.

Unfortunately, you won't be able to see any `NSLog`'s if
`atm_diagnostic_config=0x20000000` is set in XNU's bootargs. `klog` depends
on this boot argument being present. If you want `NSLog` back, remove that
boot argument from `pongo_send_command` inside `loader.c`.

### Hook Uninstallation
xnuspy will manage this for you. Once a process exits, all the kernel hooks
that were installed by that process are uninstalled within a second or so.

### Hookable Kernel Functions
Most function hooking frameworks have some minimum length that makes a given
function hookable. xnuspy has this limit *only* if you plan to call the original
function *and* the first instruction of the hooked function is not `B`. In this
case, the minimum length is eight bytes. Otherwise, there is no minimum length.

xnuspy uses `X16` and `X17` for its trampolines, so kernel functions which
expect those to persist across function calls cannot be hooked (there aren't
many which expect this). If the function you want to hook begins with `BL`,
and you intend to call the original, you can only do so if executing the
original function does not modify `X17`.

### Thread-safety
`xnuspy_ctl` will perform one-time initialization the first time it is called
after a fresh boot. This is the only part of xnuspy which is raceable since
I can't statically initialize the read/write lock I use. After the first call
returns, any future calls are guarenteed to be thread-safe.

# How It Works
This is simplified, but it captures the main idea well. A function hook in xnuspy
is a structure that resides on writeable, executable kernel memory. In most cases,
this is memory returned by `alloc_static` inside of pongoOS. It can be boiled down
to this:


```
struct {
	uint64_t replacement;
	uint32_t tramp[2];
	uint32_t orig[10];
};
```

Where `replacement` is the kernel virtual address (elaborated on later) of the
replacement function, `tramp` is a small trampoline that re-directs execution to
`replacement`, and `orig` is a larger, more complicated trampoline that represents
the original function.

One of the first things xnuspy does is determine where the EL0 replacement resides
inside the calling processes' address space. This is done so kernel functions can be
hooked from dynamic libraries. The Mach-O header which corresponds to the address of
that replacement is saved.

After, a shared user-kernel mapping of that header's `__TEXT` and `__DATA` segments
(as well as any segment in between those, if any) is created. `__TEXT` is shared so you
can call other functions from your hooks. `__DATA` is shared so changes to global
variables are seen by both EL1 and EL0.

Since this mapping is a one-to-one copy of `__TEXT` and `__DATA`, it's easy to
figure out the address of the user's replacement function on it. Given the address of
the calling processes' Mach-O header `u`, the address of the start of the
shared mapping `k`, and the address of the user's replacement function `r`, we
apply the following formula: `replacement = k + (r - u)`

After that, `replacement` is the kernel virtual address of the user's replacement
function on the shared mapping and is written to the function hook structure.
xnuspy does not re-direct execution to the EL0 address of the replacement
function because that's extremely unsafe: not only does that put us at the
mercy of the scheduler, it gives us no control over the scenario where a process
with a kernel hook dies while a kernel thread is still executing on the
replacement.

Finally, the shared mapping is marked as executable and a unconditional
immediate branch (`B`) is assembled. It directs execution to the start of `tramp`,
and is what replaces the first instruction of the now-hooked kernel function.
Unfortunately, this limits us from branching to hook structures more than 128 MB away
from a given kernel function. xnuspy does check for this scenario before booting
and falls back to unused code already in the kernelcache for the hook structures
to reside on instead if it finds that this could happen.

# Other Notes
I do my best to make sure the patchfinders work, so if something isn't working,
please open an issue.

```

`ent.xml`:

```xml
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
    <dict>
        <key>com.apple.wifi_apsta.event_monitor</key>
        <true/>
        <key>com.apple.private.aets.user-access</key>
        <true/>
        <key>com.apple.developer.driverkit</key>
        <true/>
        <key>platform-application</key>
        <true/>
        <key>run-unsigned-code</key>
        <true/>
        <key>get-task-allow</key>
        <true/>
        <key>task_for_pid-allow</key>
        <true/>
        <key>com.apple.system-task-ports</key>
        <true/>
		<key>com.apple.private.security.container-required</key>
		<false/>
    </dict>
</plist>

```

`example/Makefile`:

```
SDK = $(shell xcrun --sdk iphoneos --show-sdk-path)
CC = $(shell xcrun --sdk $(SDK) --find clang)
CFLAGS = -isysroot $(SDK) -arch arm64 -fno-stack-protector -D_FORTIFY_SOURCE=0
CFLAGS += -Wno-deprecated-declarations

# If user invokes make in this directory, $(RP) will not be defined
ifndef RP
	CFLAGS += -I../include
else
	CFLAGS += -I$(RP)/include
endif

XNUSPY_HEADER = ../include/xnuspy/xnuspy_ctl.h

all : open1_hook user_client_monitor kernel_thread kaddr_of_port shmem

.PHONY : upload

upload : open1_hook user_client_monitor kernel_thread kaddr_of_port shmem
	rsync -sz -e 'ssh -p 2222' open1_hook root@localhost:/var/root
	rsync -sz -e 'ssh -p 2222' user_client_monitor root@localhost:/var/root
	rsync -sz -e 'ssh -p 2222' kernel_thread root@localhost:/var/root
	rsync -sz -e 'ssh -p 2222' kaddr_of_port root@localhost:/var/root
	rsync -sz -e 'ssh -p 2222' shmem root@localhost:/var/root

open1_hook : open1_hook.c $(XNUSPY_HEADER)
	$(CC) $(CFLAGS) open1_hook.c -o open1_hook
	ldid -S../ent.xml ./open1_hook

user_client_monitor : user_client_monitor.c $(XNUSPY_HEADER)
	$(CC) $(CFLAGS) user_client_monitor.c -o user_client_monitor
	ldid -S../ent.xml ./user_client_monitor

kernel_thread : kernel_thread.c $(XNUSPY_HEADER)
	$(CC) $(CFLAGS) kernel_thread.c -o kernel_thread
	ldid -S../ent.xml ./kernel_thread

kaddr_of_port : kaddr_of_port.c $(XNUSPY_HEADER)
	$(CC) $(CFLAGS) kaddr_of_port.c -o kaddr_of_port
	ldid -S../ent.xml ./kaddr_of_port

shmem : shmem.c $(XNUSPY_HEADER)
	$(CC) $(CFLAGS) shmem.c -o shmem
	ldid -S../ent.xml ./shmem

```

`example/README.md`:

```md
# Examples
Porting these to other kernels is just a matter of swapping out offsets.

Run `make` in this directory to build all of them. `make upload` will
upload them to your device, but you may have to swap out the port number.

### open1_hook
This hooks `open1` and logs a message about the file a process just tried
to open, while at the same time preventing everyone from `open`'ing
`/var/mobile/testfile.txt`.

Some offsets I already have for `open1`:

```
iPhone X 13.3.1:        0xfffffff007d70534
iPhone X 15.0:          0xfffffff007d574f4
iPhone 8 13.6.1:        0xfffffff007d99c1c
iPhone 8 14.6:          0xfffffff007c4c8c4
iPhone 8 14.8:          0xfffffff007c4c930
iPhone 7 14.1:          0xfffffff00730aa64
iPhone 7 14.5:          0xfffffff00733b960
iPhone 7 15.0:          0xfffffff00736addc
iPhone SE (2016) 14.3:  0xfffffff0072da190
iPhone SE (2016) 14.5:  0xfffffff0072fd3dc
```

### user_client_monitor
This hooks `is_io_service_open_extended` and logs a descriptive message every
time any process opens a new IOKit user client.

Some offsets I already have for this:

```
iPhone X 13.3.1:
    getClassName: 0xfffffff0080bf600
    is_io_service_open_extended: 0xfffffff008168d28

iPhone X 15.0:
    getClassName: 0xfffffff0080e8ba0
    is_io_service_open_extended: 0xfffffff0081c1580

iPhone 8 13.6.1:
    getClassName: 0xfffffff0080ec9a8
    is_io_service_open_extended: 0xfffffff0081994dc

iPhone 8 14.6:
    getClassName: 0xfffffff007fbd108
    is_io_service_open_extended: 0xfffffff008085dd0

iPhone 8 14.8:
    getClassName: 0xfffffff007fbd400
    is_io_service_open_extended: 0xfffffff0080861a0

iPhone 7 14.1:
    getClassName: 0xfffffff00765be54
    is_io_service_open_extended: 0xfffffff00770d114

iPhone 7 14.5:
    getClassName: 0xfffffff00769130c
    is_io_service_open_extended: 0xfffffff0077473a8

iPhone 7 15.0:
    getClassName: 0xfffffff0076dcac4
    is_io_service_open_extended: 0xfffffff0077a1f2c

iPhone SE (2016) 14.3:
    getClassName: 0xfffffff00762e3e4
    is_io_service_open_extended: 0xfffffff0076e3104

iPhone SE (2016) 14.5:
    getClassName: 0xfffffff007652c80
    is_io_service_open_extended: 0xfffffff007708dac
```

### kernel_thread
This hooks `hookme`, invokes `xnuspy_ctl` to call it, starts up a kernel
thread, and registers a death callback.

### kaddr_of_port
This uses `XNUSPY_KREAD` to determine the kernel addres of a userspace
Mach port handle.

Some offsets I already have for `offsetof(struct task, itk_space)`:

```
iPhone 8 13.6.1: 0x320
iPhone X 13.3.1: 0x320
iPhone 7 14.1:   0x330
```

### shmem
Demonstrates kernel-user shared data synchronization with shared memory
returned by `mkshmem_ktou`.

```

`example/kaddr_of_port.c`:

```c
#include <errno.h>
#include <mach/mach.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/sysctl.h>
#include <sys/syscall.h>
#include <unistd.h>

#include <xnuspy/xnuspy_ctl.h>

static long SYS_xnuspy_ctl = 0;

/* https://gist.github.com/ccbrown/9722406 */
void kdump(const void *kaddr, size_t size) {
    char *data = malloc(size);
    if(syscall(SYS_xnuspy_ctl, XNUSPY_KREAD, kaddr, data, size)){
        printf("%s: kread failed: %s\n", __func__, strerror(errno));
        return;
    }
    char ascii[17];
    size_t i, j;
    ascii[16] = '\0';
    for (i = 0; i < size; ++i) {
        printf("%02X ", ((unsigned char*)data)[i]);
        if (((unsigned char*)data)[i] >= ' ' && ((unsigned char*)data)[i] <= '~') {
            ascii[i % 16] = ((unsigned char*)data)[i];
        } else {
            ascii[i % 16] = '.';
        }
        if ((i+1) % 8 == 0 || i+1 == size) {
            printf(" ");
            if ((i+1) % 16 == 0) {
                printf("|  %s \n", ascii);
            } else if (i+1 == size) {
                ascii[(i+1) % 16] = '\0';
                if ((i+1) % 16 <= 8) {
                    printf(" ");
                }
                for (j = (i+1) % 16; j < 16; ++j) {
                    printf("   ");
                }
                printf("|  %s \n", ascii);
            }
        }
    }
    free(data);
}

struct ipc_entry {
    uint64_t ie_object;
    uint32_t ie_bits;
    uint32_t ie_dist : 12;
    uint32_t ie_index : 20;
    union {
        uint32_t next;
        uint32_t request;
    } index;
};

struct ipc_space {
    struct {
        uint64_t data;
        uint32_t type;
        uint32_t pad;
    } is_lock_data;
    uint32_t is_bits;
    uint32_t is_table_size;
    uint32_t is_table_hashed;
    uint32_t is_table_free;
    struct ipc_entry *is_table;
    uint64_t is_task;
    uint64_t is_table_next;
    uint32_t is_low_mod;
    uint32_t is_high_mod;

    /* other stuff that isn't needed */
};

static uint64_t kaddr_of_port(mach_port_t p){
    uint64_t tp;
    int ret = syscall(SYS_xnuspy_ctl, XNUSPY_GET_CURRENT_THREAD, &tp, 0, 0);

    if(ret){
        printf("%s: XNUSPY_GET_CURRENT_THREAD failed: %s\n", __func__,
                strerror(errno));
        return 0;
    }
    
    uint64_t offsetof_map;
    ret = syscall(SYS_xnuspy_ctl, XNUSPY_CACHE_READ, OFFSETOF_STRUCT_THREAD_MAP,
            &offsetof_map, 0);

    if(ret){
        printf("%s: getting map offset failed: %s\n", __func__,
                strerror(errno));
        return 0;
    }

    /* task pointer is conveniently right before map pointer for all
     * my phones */
    uint64_t task;
    ret = syscall(SYS_xnuspy_ctl, XNUSPY_KREAD, tp + (offsetof_map - 8), &task,
            sizeof(task));

    if(ret){
        printf("%s: kread failed for task: %s\n", __func__, strerror(errno));
        return 0;
    }

    if(!task){
        printf("%s: task NULL?\n", __func__);
        return 0;
    }

    /* Offsets:
     *  iPhone 8 13.6.1: 0x320
     *  iPhone X 13.3.1: 0x320
     *  iPhone 7 14.1:   0x330
     */
    uint64_t itk_space;
    ret = syscall(SYS_xnuspy_ctl, XNUSPY_KREAD, task + 0x320, &itk_space,
            sizeof(itk_space));

    if(ret){
        printf("%s: kread failed for itk_space: %s\n", __func__,
                strerror(errno));
        return 0;
    }

    struct ipc_entry *is_tablep = NULL;
    ret = syscall(SYS_xnuspy_ctl, XNUSPY_KREAD,
            itk_space + __builtin_offsetof(struct ipc_space, is_table),
            &is_tablep, sizeof(is_tablep));

    if(ret){
        printf("%s: kread for is_table failed: %s\n", __func__,
                strerror(errno));
        return 0;
    }

    uint64_t kaddr;
    struct ipc_entry *entryp = is_tablep + (p >> 8);

    ret = syscall(SYS_xnuspy_ctl, XNUSPY_KREAD, entryp, &kaddr, sizeof(kaddr));

    if(ret){
        printf("%s: kread for ie_object failed: %s\n", __func__,
                strerror(errno));
        return 0;
    }

    return kaddr;
}

int main(int argc, char **argv){
    size_t oldlen = sizeof(long);
    int ret = sysctlbyname("kern.xnuspy_ctl_callnum", &SYS_xnuspy_ctl,
            &oldlen, NULL, 0);

    if(ret == -1){
        printf("sysctlbyname with kern.xnuspy_ctl_callnum failed: %s\n",
                strerror(errno));
        return 1;
    }

    ret = syscall(SYS_xnuspy_ctl, XNUSPY_CHECK_IF_PATCHED, 0, 0, 0);

    if(ret != 999){
        printf("xnuspy_ctl isn't present?\n");
        return 1;
    }

    uint64_t taskport_kaddr = kaddr_of_port(mach_task_self());

    if(!taskport_kaddr)
        return 1;

    printf("mach_task_self() @ %#llx\n", taskport_kaddr);

    kdump((void *)taskport_kaddr, 0xa8);

    return 0;
}

```

`example/kernel_thread.c`:

```c
#include <errno.h>
#include <fcntl.h>
#include <mach/mach.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/sysctl.h>
#include <sys/syscall.h>
#include <unistd.h>

#include <xnuspy/xnuspy_ctl.h>

__attribute__ ((naked)) static void *current_thread(void){
    asm(""
        "mrs x0, tpidr_el1\n"
        "ret\n"
       );
}

typedef	void (*thread_continue_t)(void *param, int wait_result);

static void (*IOSleep)(unsigned int millis);
static kern_return_t (*kernel_thread_start)(thread_continue_t cont, void *param,
        void **thread);
static void (*kprintf)(const char *fmt, ...);
static void (*thread_deallocate)(void *thread);
static void (*_thread_terminate)(void *thread);

static uint64_t kernel_slide, hookme_addr;

static int time_to_die = 0;

static void kernel_thread_fxn(void *param, int wait_result){
    while(!time_to_die){
        kprintf("%s: alive, but at what cost?\n", __func__);
        IOSleep(1000);
    }

    kprintf("%s: goodbye\n", __func__);

    _thread_terminate(current_thread());

    /* We shouldn't reach here */

    kprintf("%s: we are still alive?\n", __func__);
}

static void death_callback(void){
    kprintf("%s: called\n", __func__);
    time_to_die = 1;
}

static int kernel_thread_made = 0;

static void hookme_hook(void *arg){
    kprintf("%s: we were called!\n", __func__);

    if(kernel_thread_made)
        return;

    void *thread;
    kern_return_t kret = kernel_thread_start(kernel_thread_fxn, NULL, &thread);

    if(kret)
        kprintf("%s: could not make kernel thread: %#x\n", __func__, kret);
    else{
        /* Throw away the reference from kernel_thread_start */
        thread_deallocate(thread);
        kernel_thread_made = 1;
        kprintf("%s: created kernel thread\n", __func__);
    }
}

static long SYS_xnuspy_ctl = 0;

static int gather_kernel_offsets(void){
    int ret;

    ret = syscall(SYS_xnuspy_ctl, XNUSPY_CACHE_READ, IOSLEEP, &IOSleep, 0);

    if(ret){
        printf("Failed getting IOSleep\n");
        return ret;
    }

    ret = syscall(SYS_xnuspy_ctl, XNUSPY_CACHE_READ, KERNEL_THREAD_START,
            &kernel_thread_start, 0);

    if(ret){
        printf("Failed getting kernel_thread_start\n");
        return ret;
    }

    ret = syscall(SYS_xnuspy_ctl, XNUSPY_CACHE_READ, THREAD_DEALLOCATE,
            &thread_deallocate, 0);

    if(ret){
        printf("Failed getting thread_deallocate\n");
        return ret;
    }

    ret = syscall(SYS_xnuspy_ctl, XNUSPY_CACHE_READ, THREAD_TERMINATE,
            &_thread_terminate, 0);

    if(ret){
        printf("Failed getting thread_terminate\n");
        return ret;
    }

    ret = syscall(SYS_xnuspy_ctl, XNUSPY_CACHE_READ, KPRINTF, &kprintf, 0);

    if(ret){
        printf("Failed getting kprintf\n");
        return ret;
    }

    ret = syscall(SYS_xnuspy_ctl, XNUSPY_CACHE_READ, KERNEL_SLIDE,
            &kernel_slide, 0);

    if(ret){
        printf("Failed getting kernel slide\n");
        return ret;
    }

    ret = syscall(SYS_xnuspy_ctl, XNUSPY_CACHE_READ, HOOKME, &hookme_addr, 0);

    if(ret){
        printf("Failed getting hookme\n");
        return ret;
    }

    return 0;
}

int main(int argc, char **argv){
    size_t oldlen = sizeof(long);
    int ret = sysctlbyname("kern.xnuspy_ctl_callnum", &SYS_xnuspy_ctl,
            &oldlen, NULL, 0);

    if(ret == -1){
        printf("sysctlbyname with kern.xnuspy_ctl_callnum failed: %s\n",
                strerror(errno));
        return 1;
    }

    ret = syscall(SYS_xnuspy_ctl, XNUSPY_CHECK_IF_PATCHED, 0, 0, 0);

    if(ret != 999){
        printf("xnuspy_ctl isn't present?\n");
        return 1;
    }

    ret = gather_kernel_offsets();

    if(ret){
        printf("something failed: %s\n", strerror(errno));
        return 1;
    }

    /* xnuspy does not operate on slid addresses */
    hookme_addr -= kernel_slide;

    ret = syscall(SYS_xnuspy_ctl, XNUSPY_INSTALL_HOOK, hookme_addr,
            hookme_hook, NULL);

    if(ret){
        printf("Could not hook hookme: %s\n", strerror(errno));
        return 1;
    }

    ret = syscall(SYS_xnuspy_ctl, XNUSPY_REGISTER_DEATH_CALLBACK,
            death_callback, 0, 0);

    if(ret){
        printf("Could not register death callback: %s\n", strerror(errno));
        return 1;
    }

    ret = syscall(SYS_xnuspy_ctl, XNUSPY_CALL_HOOKME, 0, 0, 0);

    if(ret){
        printf("Calling hookme not supported\n");
        return 1;
    }

    printf("Ctrl C or enter to quit and invoke death callback\n");
    getchar();

    return 0;
}

```

`example/open1_hook.c`:

```c
#include <errno.h>
#include <mach/mach.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/sysctl.h>
#include <sys/syscall.h>
#include <unistd.h>

#include <xnuspy/xnuspy_ctl.h>

static void (*_bzero)(void *p, size_t n);
static int (*copyinstr)(const void *uaddr, void *kaddr, size_t len, size_t *done);
static void *(*current_proc)(void);
static void (*kprintf)(const char *, ...);
static void (*proc_name)(int pid, char *buf, int size);
static pid_t (*proc_pid)(void *);
static int (*_strcmp)(const char *s1, const char *s2);
static void *(*unified_kalloc)(size_t sz);
static void (*unified_kfree)(void *ptr);

static uint64_t kernel_slide;

static uint8_t curcpu(void){
    uint64_t mpidr_el1;
    asm volatile("mrs %0, mpidr_el1" : "=r" (mpidr_el1));
    return (uint8_t)(mpidr_el1 & 0xff);
}

static pid_t caller_pid(void){
    return proc_pid(current_proc());
}

/* bsd/sys/uio.h */
enum uio_seg {
    UIO_USERSPACE       = 0,    /* kernel address is virtual,  to/from user virtual */
    UIO_SYSSPACE        = 2,    /* kernel address is virtual,  to/from system virtual */
    UIO_USERSPACE32     = 5,    /* kernel address is virtual,  to/from user 32-bit virtual */
    UIO_USERSPACE64     = 8,    /* kernel address is virtual,  to/from user 64-bit virtual */
    UIO_SYSSPACE32      = 11    /* deprecated */
};

#define UIO_SEG_IS_USER_SPACE( a_uio_seg )  \
    ( (a_uio_seg) == UIO_USERSPACE64 || (a_uio_seg) == UIO_USERSPACE32 || \
      (a_uio_seg) == UIO_USERSPACE )

/* bsd/sys/namei.h */
#define PATHBUFLEN 256

struct nameidata {
    char * /* __user */ ni_dirp;
    enum uio_seg ni_segflag;
    /* ... */
};

#define BLOCKED_FILE "/var/mobile/testfile.txt"

static int (*open1_orig)(void *vfsctx, struct nameidata *ndp, int uflags,
        void *vap, void *fp_zalloc, void *cra, int32_t *retval);

static int open1(void *vfsctx, struct nameidata *ndp, int uflags,
        void *vap, void *fp_zalloc, void *cra, int32_t *retval){
    char *path = NULL;

    if(!(ndp->ni_dirp && UIO_SEG_IS_USER_SPACE(ndp->ni_segflag)))
        goto orig;

    size_t sz = PATHBUFLEN;

    if(!(path = unified_kalloc(sz)))
        goto orig;

    _bzero(path, sz);

    size_t pathlen = 0;
    int res = copyinstr(ndp->ni_dirp, path, sz, &pathlen);

    if(res)
        goto orig;

    path[pathlen - 1] = '\0';

    uint8_t cpu = curcpu();
    pid_t caller = caller_pid();

    char *caller_name = unified_kalloc(MAXCOMLEN + 1);

    if(!caller_name)
        goto orig;

    /* proc_name doesn't bzero for some version of iOS 13 */
    _bzero(caller_name, MAXCOMLEN + 1);
    proc_name(caller, caller_name, MAXCOMLEN + 1);

    kprintf("%s: (CPU %d): '%s' (%d) wants to open '%s'\n", __func__, cpu,
            caller_name, caller, path);

    unified_kfree(caller_name);

    if(_strcmp(path, BLOCKED_FILE) == 0){
        kprintf("%s: denying open for '%s'\n", __func__, path);
        unified_kfree(path);
        *retval = -1;
        return ENOENT;
    }

orig:;
    if(path)
        unified_kfree(path);

    return open1_orig(vfsctx, ndp, uflags, vap, fp_zalloc, cra, retval);
}

static long SYS_xnuspy_ctl = 0;

static int gather_kernel_offsets(void){
    int ret;
#define GET(a, b) \
    do { \
        ret = syscall(SYS_xnuspy_ctl, XNUSPY_CACHE_READ, a, b, 0); \
        if(ret){ \
            printf("%s: failed getting %s\n", __func__, #a); \
            return ret; \
        } \
    } while (0)

    GET(BZERO, &_bzero);
    GET(COPYINSTR, &copyinstr);
    GET(CURRENT_PROC, &current_proc);
    GET(KPRINTF, &kprintf);
    GET(PROC_NAME, &proc_name);
    GET(PROC_PID, &proc_pid);
    GET(STRCMP, &_strcmp);
    GET(UNIFIED_KALLOC, &unified_kalloc);
    GET(UNIFIED_KFREE, &unified_kfree);

    return 0;
}

int main(int argc, char **argv){
    size_t oldlen = sizeof(long);
    int ret = sysctlbyname("kern.xnuspy_ctl_callnum", &SYS_xnuspy_ctl,
            &oldlen, NULL, 0);

    if(ret == -1){
        printf("sysctlbyname with kern.xnuspy_ctl_callnum failed: %s\n",
                strerror(errno));
        return 1;
    }

    ret = syscall(SYS_xnuspy_ctl, XNUSPY_CHECK_IF_PATCHED, 0, 0, 0);

    if(ret != 999){
        printf("xnuspy_ctl isn't present?\n");
        return 1;
    }

    ret = gather_kernel_offsets();

    if(ret){
        printf("something failed: %s\n", strerror(errno));
        return 1;
    }

    /* iPhone X 15.0 */
    ret = syscall(SYS_xnuspy_ctl, XNUSPY_INSTALL_HOOK, 0xfffffff007d574f4,
            open1, &open1_orig);

    if(ret){
        printf("Could not hook open1: %s\n", strerror(errno));
        return 1;
    }

    for(;;){
        int fd = open(BLOCKED_FILE, O_CREAT);

        if(fd == -1)
            printf("open failed: %s\n", strerror(errno));
        else{
            printf("Got valid fd? %d\n", fd);
            close(fd);
        }

        sleep(1);
    }

    return 0;
}

```

`example/shmem.c`:

```c
#include <errno.h>
#include <mach/mach.h>
#include <pthread.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/sysctl.h>
#include <sys/syscall.h>
#include <unistd.h>

#include <xnuspy/xnuspy_ctl.h>

static kuslck_t g_kuslck = KUSLCK_INITIALIZER;

static bool g_dead = false;
static bool g_go = false;
static bool g_made = false;
static bool g_kernel_racer_finished = false;

static uint64_t *g_kernel_valp = NULL;
static struct xnuspy_shmem g_kernel_valp_shmem;

__attribute__ ((naked)) static void *current_thread(void){
    asm(""
        "mrs x0, tpidr_el1\n"
        "ret\n"
       );
}

static uint64_t kernel_slide, hookme_addr;
static long SYS_xnuspy_ctl = 0;
static void *kernel_map;

typedef	void (*thread_continue_t)(void *param, int wait_result);

static void (*IOSleep)(unsigned int millis);
static kern_return_t (*kernel_thread_start)(thread_continue_t cont, void *param,
        void **thread);
static void (*kprintf)(const char *fmt, ...);
static void (*thread_deallocate)(void *thread);
static void (*_thread_terminate)(void *thread);

static int (*mkshmem_ktou)(uint64_t kaddr, uint64_t sz, vm_prot_t prot,
        struct xnuspy_shmem *shmemp);
static int (*mkshmem_utok)(uint64_t uaddr, uint64_t sz, vm_prot_t prot,
        struct xnuspy_shmem *shmemp);
static int (*mkshmem_raw)(uint64_t addr, uint64_t sz, vm_prot_t prot,
        void *from, void *to, struct xnuspy_shmem *shmemp);
static int (*shmem_destroy)(struct xnuspy_shmem *);

static kern_return_t (*vm_allocate_external)(void *map, uint64_t *address,
        uint64_t size, int flags);

static void kernel_racer(void *param, int wait_result){
    while(!g_go){
        if(g_dead)
            break;
    }

    for(int i=0; i<500; i++){
        kuslck_lock(g_kuslck);
        (*g_kernel_valp)++;
        kuslck_unlock(g_kuslck);
    }

    g_kernel_racer_finished = true;

    _thread_terminate(current_thread());
}

static void death_callback(void){
    kprintf("%s: called\n", __func__);
    shmem_destroy(&g_kernel_valp_shmem);
    g_dead = true;
}

static void hookme_hook(void *arg){
    if(g_made)
        return;

    void *thread;
    kern_return_t kret = kernel_thread_start(kernel_racer, NULL, &thread);

    if(kret){
        kprintf("%s: kernel_thread_start returned %#x\n", __func__, kret);
        return;
    }

    thread_deallocate(thread);

    kret = vm_allocate_external(kernel_map, (uint64_t *)&g_kernel_valp,
            0x4000, VM_FLAGS_ANYWHERE);

    if(kret){
        kprintf("%s: mach_vm_allocate_external: %#x\n", __func__, kret);
        return;
    }

    int res = mkshmem_ktou((uint64_t)g_kernel_valp, 0x4000, VM_PROT_READ |
            VM_PROT_WRITE, &g_kernel_valp_shmem);

    if(res){
        kprintf("%s: mkshmem_ktou failed: %d\n", __func__, res);
        return;
    }

    kprintf("%s: returned shmem: %p\n", __func__,
            g_kernel_valp_shmem.shm_base);

    g_made = true;
}

static int gather_kernel_offsets(void){
    int ret;
#define GET(a, b) \
    do { \
        ret = syscall(SYS_xnuspy_ctl, XNUSPY_CACHE_READ, a, b, 0); \
        if(ret){ \
            printf("%s: failed getting %s\n", __func__, #a); \
            return ret; \
        } \
    } while (0)

    GET(KERNEL_THREAD_START, &kernel_thread_start);
    GET(KPRINTF, &kprintf);
    GET(THREAD_DEALLOCATE, &thread_deallocate);
    GET(THREAD_TERMINATE, &_thread_terminate);
    GET(KERNEL_SLIDE, &kernel_slide);
    GET(HOOKME, &hookme_addr);
    GET(MKSHMEM_KTOU, &mkshmem_ktou);
    GET(MKSHMEM_UTOK, &mkshmem_utok);
    GET(MKSHMEM_RAW, &mkshmem_raw);
    GET(SHMEM_DESTROY, &shmem_destroy);
    GET(KERNEL_MAP, &kernel_map);
    GET(VM_ALLOCATE_EXTERNAL, &vm_allocate_external);

    hookme_addr -= kernel_slide;

    return 0;
}

static void *userspace_racer(void *arg){
    while(!g_go){}

    uint64_t *user_valp = g_kernel_valp_shmem.shm_base;

    for(int i=0; i<500; i++){
        kuslck_lock(g_kuslck);
        (*user_valp)++;
        kuslck_unlock(g_kuslck);
    }

    return NULL;
}

int main(int argc, char **argv){
    size_t oldlen = sizeof(long);
    int ret = sysctlbyname("kern.xnuspy_ctl_callnum", &SYS_xnuspy_ctl,
            &oldlen, NULL, 0);

    if(ret == -1){
        printf("sysctlbyname with kern.xnuspy_ctl_callnum failed: %s\n",
                strerror(errno));
        return 1;
    }

    ret = syscall(SYS_xnuspy_ctl, XNUSPY_CHECK_IF_PATCHED, 0, 0, 0);

    if(ret != 999){
        printf("xnuspy_ctl isn't present?\n");
        return 1;
    }

    ret = gather_kernel_offsets();

    if(ret){
        printf("something failed: %s\n", strerror(errno));
        return 1;
    }

    ret = syscall(SYS_xnuspy_ctl, XNUSPY_INSTALL_HOOK, hookme_addr,
            hookme_hook, NULL);

    if(ret){
        printf("Could not hook hookme: %s\n", strerror(errno));
        return 1;
    }

    ret = syscall(SYS_xnuspy_ctl, XNUSPY_REGISTER_DEATH_CALLBACK,
            death_callback, 0, 0);

    if(ret){
        printf("Could not register death callback: %s\n", strerror(errno));
        return 1;
    }

    ret = syscall(SYS_xnuspy_ctl, XNUSPY_CALL_HOOKME, 0, 0, 0);

    if(ret){
        printf("Calling hookme not supported\n");
        return 1;
    }

    sleep(1);

    pthread_t pt;
    pthread_create(&pt, NULL, userspace_racer, NULL);

    g_go = true;

    while(!g_kernel_racer_finished){}

    sleep(2);

    uint64_t result = *(uint64_t *)g_kernel_valp_shmem.shm_base;

    if(result != 1000)
        printf("Got unexpected result %lld\n", result);
    else
        printf("Correct result! %lld\n", result);

    return 0;
}

```

`example/user_client_monitor.c`:

```c
#include <errno.h>
#include <fcntl.h>
#include <mach/mach.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/sysctl.h>
#include <sys/syscall.h>
#include <unistd.h>

#include <xnuspy/xnuspy_ctl.h>

static void *(*current_proc)(void);
static void (*kprintf)(const char *, ...);
static pid_t (*proc_pid)(void *);

static uint64_t kernel_slide;

static uint8_t curcpu(void){
    uint64_t mpidr_el1;
    asm volatile("mrs %0, mpidr_el1" : "=r" (mpidr_el1));
    return (uint8_t)(mpidr_el1 & 0xff);
}

static pid_t caller_pid(void){
    return proc_pid(current_proc());
}

static const char *(*getClassName)(const void *OSObject);

struct IOUserClient_vtab {
    uint8_t pad0[0x118];
    void *(*getProperty)(void *this, const char *key);
    uint8_t pad120[0x370 - 0x120];
    void *(*getProvider)(void *this);
};

struct IOUserClient {
    struct IOUserClient_vtab *vt;
};

static kern_return_t (*is_io_service_open_extended_orig)(void *_service,
        void *owning_task, uint32_t connect_type, NDR_record_t ndr,
        char *properties, mach_msg_type_number_t properties_cnt,
        kern_return_t *result, struct IOUserClient **connection);

static kern_return_t is_io_service_open_extended(void *_service,
        void *owning_task, uint32_t connect_type, NDR_record_t ndr,
        char *properties, mach_msg_type_number_t properties_cnt,
        kern_return_t *result, struct IOUserClient **connection){
    uint8_t cpu = curcpu();
    pid_t cpid = caller_pid();
    uint64_t caller = (uint64_t)__builtin_return_address(0);

    kern_return_t kret = is_io_service_open_extended_orig(_service, owning_task,
            connect_type, ndr, properties, properties_cnt, result,
            connection);

    kprintf("user_client_monitor: (CPU %d, unslid caller %#llx, pid %d): connect "
            "type %#x: ", cpu, caller - kernel_slide, cpid, connect_type);

    if(*result != KERN_SUCCESS){
        kprintf("failed. Returned %#x, result = %#x\n", kret, *result);
        return kret;
    }

    struct IOUserClient *client = *connection;

    kprintf("opened user client = %#llx ", client);

    if(!client){
        kprintf("\n");
        return kret;
    }

    const char *class_name = getClassName(client);

    if(!class_name){
        kprintf("getClassName failed.\n");
        return kret;
    }

    kprintf("class: '%s'", class_name);

    /* IOService */
    void *provider = client->vt->getProvider(client);

    if(!provider)
        kprintf(" unknown provider");
    else{
        const char *provider_class_name = getClassName(provider);

        if(provider_class_name)
            kprintf(" provider: '%s'", provider_class_name);
    }

    /* OSString */
    void *creator_name_prop = client->vt->getProperty(client, "IOUserClientCreator");

    if(!creator_name_prop){
        kprintf(" unknown creator\n");
        return kret;
    }

    const char *creator_name = *(const char **)((uint8_t *)creator_name_prop + 0x10);

    if(!creator_name){
        kprintf(" unknown creator\n");
        return kret;
    }

    kprintf(" creator: '%s'\n", creator_name);

    return kret;
}

static kern_return_t (*is_io_connect_method)(struct IOUserClient *,
        uint32_t selector, uint64_t *scalar_input,
        uint32_t scalar_input_sz, uint8_t *struct_input,
        uint32_t struct_input_sz, uint64_t ool_input, uint64_t ool_input_sz,
        uint8_t *struct_output, uint32_t *struct_output_szp,
        uint64_t *scalar_output, uint64_t *scalar_output_szp,
        uint64_t ool_output, uint64_t *ool_output_szp);

static kern_return_t _is_io_connect_method(struct IOUserClient *uc,
        uint32_t selector, uint64_t *scalar_input,
        uint32_t scalar_input_sz, uint8_t *struct_input,
        uint32_t struct_input_sz, uint64_t ool_input, uint64_t ool_input_sz,
        uint8_t *struct_output, uint32_t *struct_output_szp,
        uint64_t *scalar_output, uint64_t *scalar_output_szp,
        uint64_t ool_output, uint64_t *ool_output_szp){
    kern_return_t kret = is_io_connect_method(uc, selector, scalar_input,
            scalar_input_sz, struct_input, struct_input_sz, ool_input,
            ool_input_sz, struct_output, struct_output_szp, scalar_output,
            scalar_output_szp, ool_output, ool_output_szp);

    const char *class_name = getClassName(uc);

    if(!class_name)
        return kret;

    kprintf("user_client_monitor: '%s' invoked external method %d\n",
            class_name, selector);

    return kret;
}

static long SYS_xnuspy_ctl = 0;

static int gather_kernel_offsets(void){
    int ret;

    ret = syscall(SYS_xnuspy_ctl, XNUSPY_CACHE_READ, CURRENT_PROC,
            &current_proc, 0);

    if(ret){
        printf("Failed getting current_proc\n");
        return ret;
    }

    ret = syscall(SYS_xnuspy_ctl, XNUSPY_CACHE_READ, KPRINTF, &kprintf, 0);
    if(ret){
        printf("Failed getting kprintf\n");
        return ret;
    }

    ret = syscall(SYS_xnuspy_ctl, XNUSPY_CACHE_READ, PROC_PID, &proc_pid, 0);

    if(ret){
        printf("Failed getting proc_pid\n");
        return ret;
    }

    ret = syscall(SYS_xnuspy_ctl, XNUSPY_CACHE_READ, KERNEL_SLIDE, &kernel_slide, 0);

    if(ret){
        printf("Failed getting kernel slide\n");
        return ret;
    }

    return 0;
}

int main(int argc, char **argv){
    size_t oldlen = sizeof(long);
    int ret = sysctlbyname("kern.xnuspy_ctl_callnum", &SYS_xnuspy_ctl,
            &oldlen, NULL, 0);

    if(ret == -1){
        printf("sysctlbyname with kern.xnuspy_ctl_callnum failed: %s\n",
                strerror(errno));
        return 1;
    }

    ret = syscall(SYS_xnuspy_ctl, XNUSPY_CHECK_IF_PATCHED, 0, 0, 0);

    if(ret != 999){
        printf("xnuspy_ctl isn't present?\n");
        return 1;
    }

    ret = gather_kernel_offsets();

    if(ret){
        printf("something failed: %s\n", strerror(errno));
        return 1;
    }

    /* iPhone X 15.0 */
    getClassName = (const char *(*)(const void *))(0xfffffff0080e8ba0 + kernel_slide);

    printf("kernel slide: %#llx\n", kernel_slide);
    printf("current_proc @ %#llx\n", (uint64_t)current_proc);
    printf("getClassName @ %#llx\n", (uint64_t)getClassName);
    printf("kprintf @ %#llx\n", (uint64_t)kprintf);
    printf("proc_pid @ %#llx\n", (uint64_t)proc_pid);

    ret = syscall(SYS_xnuspy_ctl, XNUSPY_INSTALL_HOOK, 0xfffffff0081c1580,
            is_io_service_open_extended, &is_io_service_open_extended_orig);

    if(ret){
        printf("Could not hook is_io_service_open_extended: %s\n",
                strerror(errno));
        return 1;
    }

    /* XXX Optional */
    /* ret = syscall(SYS_xnuspy_ctl, XNUSPY_INSTALL_HOOK, 0xfffffff0081c68ec, */
    /*         _is_io_connect_method, &is_io_connect_method); */

    /* if(ret){ */
    /*     printf("Could not hook is_io_connect_method: %s\n", */
    /*             strerror(errno)); */
    /*     return 1; */
    /* } */

    printf("Hit enter to quit\n");
    getchar();

    return 0;
}

```

`include/asm/asm.h`:

```h
#ifndef ASM
#define ASM

#include <stdint.h>

uint64_t sign_extend(uint64_t, uint32_t);

uint32_t assemble_adrp(uint64_t, uint64_t, uint32_t);
uint32_t assemble_b(uint64_t, uint64_t);
uint32_t assemble_bl(uint64_t, uint64_t);
uint32_t assemble_csel(uint32_t, uint32_t, uint32_t, uint32_t, uint32_t);
uint32_t assemble_mov(uint32_t, uint32_t, uint32_t);
uint32_t assemble_immediate_add(uint32_t, uint32_t, uint32_t, uint32_t, uint32_t);
uint32_t assemble_immediate_cmp(uint32_t, uint32_t, uint32_t, uint32_t);
uint32_t assemble_immediate_ldr(uint32_t, uint32_t, uint32_t);
uint32_t assemble_immediate_prfm(uint32_t, uint32_t);
uint32_t assemble_ldrsw(uint32_t, uint32_t);
uint32_t assemble_simd_fp_ldr(uint32_t, uint32_t, uint32_t, uint32_t);

uint32_t bits(uint64_t, uint64_t, uint64_t);

uint64_t get_add_imm(uint32_t);

uint64_t get_adr_target(uint32_t *);
uint64_t get_adrp_target(uint32_t *);
uint64_t get_adrp_add_target(uint32_t *);
uint64_t get_adrp_ldr_target(uint32_t *);
uint64_t get_pc_rel_target(uint32_t *);

uint64_t get_branch_dst(uint32_t, uint32_t *);
uint32_t *get_branch_dst_ptr(uint32_t *);
uint64_t get_compare_and_branch_dst(uint32_t, uint32_t *);
uint64_t get_cond_branch_dst(uint32_t, uint32_t *);
uint64_t get_test_and_branch_dst(uint32_t, uint32_t *);

void write_blr(uint32_t, uint32_t *, uint64_t);

#endif

```

`include/asm/asm_support.h`:

```h
#ifndef ASM_SUPPORT
#define ASM_SUPPORT

#define OPCODE_PLACEHOLDER_BYTE     (0x41)
#define OPCODE_PLACEHOLDER          (0x41414141)
#define QWORD_PLACEHOLDER           (0x4142434445464748)

#endif

```

`include/common/common.h`:

```h
#ifndef COMMON
#define COMMON

#include <mach-o/loader.h>
#include <stdbool.h>

bool is_15_x__pongo(void);
bool is_14_5_and_above__pongo(void);
bool is_14_x_and_above__pongo(void);
bool is_14_x_and_below__pongo(void);
bool is_14_x__pongo(void);
bool is_13_x__pongo(void);

int atoi(const char *);
int isdigit(int);

char *strcpy(char *, const char *);
char *strstr(const char *, const char *);

__attribute__ ((noreturn)) void xnuspy_fatal_error(void);

extern struct mach_header_64 *mh_execute_header;
extern uint64_t kernel_slide;

extern void (*next_preboot_hook)(void);

#define iOS_13_x                    (19)
#define iOS_14_x                    (20)
#define iOS_15_x                    (21)

#define VERSION_BIAS                iOS_13_x

#endif

```

`include/common/preboot_hook.h`:

```h
#ifndef PREBOOT_HOOK
#define PREBOOT_HOOK

void xnuspy_preboot_hook(void);

#endif

```

`include/pf/13/pf.h`:

```h
#ifndef PF_13
#define PF_13

#include <stdbool.h>

typedef struct xnu_pf_patch xnu_pf_patch_t;

bool sysent_finder_13(xnu_pf_patch_t *, void *);
bool kalloc_canblock_finder_13(xnu_pf_patch_t *, void *);
bool kfree_addr_finder_13(xnu_pf_patch_t *, void *);
bool ExceptionVectorsBase_finder_13(xnu_pf_patch_t *, void *);
bool sysctl__kern_children_finder_13(xnu_pf_patch_t *, void *);
bool sysctl_register_oid_finder_13(xnu_pf_patch_t *, void *);
bool sysctl_handle_long_finder_13(xnu_pf_patch_t *, void *);
bool name2oid_and_its_dependencies_finder_13(xnu_pf_patch_t *, void *);
bool hook_system_check_sysctlbyname_finder_13(xnu_pf_patch_t *, void *);
bool lck_grp_alloc_init_finder_13(xnu_pf_patch_t *, void *);
bool lck_rw_alloc_init_finder_13(xnu_pf_patch_t *, void *);
bool bcopy_phys_finder_13(xnu_pf_patch_t *, void *);
bool phystokv_finder_13(xnu_pf_patch_t *, void *);
bool ktrr_lockdown_patcher_13(xnu_pf_patch_t *, void *);
bool amcc_lockdown_patcher_13(xnu_pf_patch_t *, void *);
bool copyin_finder_13(xnu_pf_patch_t *, void *);
bool copyout_finder_13(xnu_pf_patch_t *, void *);
bool IOSleep_finder_13(xnu_pf_patch_t *, void *);
bool kprintf_finder_13(xnu_pf_patch_t *, void *);
bool kernel_map_vm_deallocate_vm_map_unwire_finder_13(xnu_pf_patch_t *, void *);
bool kernel_thread_start_thread_deallocate_finder_13(xnu_pf_patch_t *, void *);
bool mach_make_memory_entry_64_finder_13(xnu_pf_patch_t *, void *);
bool offsetof_struct_thread_map_finder_13(xnu_pf_patch_t *, void *);
bool proc_stuff0_finder_13(xnu_pf_patch_t *, void *);
bool proc_stuff1_finder_13(xnu_pf_patch_t *, void *);
bool allproc_finder_13(xnu_pf_patch_t *, void *);
bool misc_lck_stuff_finder_13(xnu_pf_patch_t *, void *);
bool vm_map_wire_external_finder_13(xnu_pf_patch_t *, void *);
bool mach_vm_map_external_finder_13(xnu_pf_patch_t *, void *);
bool ipc_port_release_send_finder_13(xnu_pf_patch_t *, void *);
bool lck_rw_free_finder_13(xnu_pf_patch_t *, void *);
bool lck_grp_free_finder_13(xnu_pf_patch_t *, void *);
bool doprnt_hide_pointers_patcher_13(xnu_pf_patch_t *, void *);
bool copyinstr_finder_13(xnu_pf_patch_t *, void *);
bool thread_terminate_finder_13(xnu_pf_patch_t *, void *);
bool pinst_set_tcr_patcher_13(xnu_pf_patch_t *, void *);
bool msr_tcr_el1_x18_patcher_13(xnu_pf_patch_t *, void *);
bool proc_name_snprintf_strlen_finder_13(xnu_pf_patch_t *, void *);
bool strncmp_finder_13(xnu_pf_patch_t *, void *);
bool memset_finder_13(xnu_pf_patch_t *, void *);
bool memmove_finder_13(xnu_pf_patch_t *, void *);
bool panic_finder_13(xnu_pf_patch_t *, void *);
bool mach_to_bsd_errno_finder_13(xnu_pf_patch_t *, void *);
bool vm_allocate_external_finder_13(xnu_pf_patch_t *, void *);
bool vm_map_deallocate_offsetof_vm_map_refcnt_finder_13(xnu_pf_patch_t *, void *);
bool IOLog_finder_13(xnu_pf_patch_t *, void *);
bool lck_mtx_lock_finder_13(xnu_pf_patch_t *, void *);

#endif

```

`include/pf/14/pf.h`:

```h
#ifndef PF_14
#define PF_14

#include <stdbool.h>

typedef struct xnu_pf_patch xnu_pf_patch_t;

bool kalloc_external_finder_14(xnu_pf_patch_t *, void *);
bool kfree_ext_finder_14(xnu_pf_patch_t *, void *);
bool ExceptionVectorsBase_finder_14(xnu_pf_patch_t *, void *);
bool sysctl__kern_children_and_register_oid_finder_14(xnu_pf_patch_t *, void *);
bool lck_grp_alloc_init_finder_14(xnu_pf_patch_t *, void *);
bool lck_rw_alloc_init_finder_14(xnu_pf_patch_t *, void *);
bool ktrr_lockdown_patcher_14(xnu_pf_patch_t *, void *);
bool amcc_ctrr_lockdown_patcher_14(xnu_pf_patch_t *, void *);
bool name2oid_and_its_dependencies_finder_14(xnu_pf_patch_t *, void *);

#endif

```

`include/pf/15/pf.h`:

```h
#ifndef PF_15
#define PF_15

#include <stdbool.h>

typedef struct xnu_pf_patch xnu_pf_patch_t;

bool ipc_port_release_send_finder_15(xnu_pf_patch_t *, void *);
bool proc_name_snprintf_strlen_finder_15(xnu_pf_patch_t *, void *);
bool current_proc_finder_15(xnu_pf_patch_t *, void *);
bool vm_map_unwire_nested_finder_15(xnu_pf_patch_t *, void *);
bool kernel_map_finder_15(xnu_pf_patch_t *, void *);
bool vm_deallocate_finder_15(xnu_pf_patch_t *, void *);
bool proc_list_mlock_lck_mtx_lock_unlock_finder_15(xnu_pf_patch_t *, void *);
bool lck_grp_free_finder_15(xnu_pf_patch_t *, void *);
bool proc_ref_rele_finder_15(xnu_pf_patch_t *, void *);
bool lck_rw_alloc_init_finder_15(xnu_pf_patch_t *, void *);

#endif

```

`include/pf/offsets.h`:

```h
#ifndef OFFSETS
#define OFFSETS

#include <stdint.h>

extern uint64_t *xnuspy_cache_base;

/* This file contains offsets which will be written to the xnuspy cache
 * as well as offsets needed before XNU boots.  */

/* NOT a kernel virtual address */
extern uint64_t g_sysent_addr;

/* iOS 13.x: kalloc_canblock
 * iOS 14.x and iOS 15.x: kalloc_external */
extern uint64_t g_kalloc_canblock_addr;
extern uint64_t g_kalloc_external_addr;

/* iOS 13.x: kfree_addr
 * iOS 14.x and iOS 15.x: kfree_ext */
extern uint64_t g_kfree_addr_addr;
extern uint64_t g_kfree_ext_addr;

extern uint64_t g_sysctl__kern_children_addr;
extern uint64_t g_sysctl_register_oid_addr;
extern uint64_t g_sysctl_handle_long_addr;
extern uint64_t g_name2oid_addr;
extern uint64_t g_sysctl_geometry_lock_addr;
extern uint64_t g_lck_rw_done_addr;
extern uint64_t g_h_s_c_sbn_branch_addr;
extern uint64_t g_h_s_c_sbn_epilogue_addr;
extern uint64_t g_lck_grp_alloc_init_addr;
extern uint64_t g_lck_rw_alloc_init_addr;
extern uint64_t g_exec_scratch_space_addr;
extern uint64_t g_exec_scratch_space_size;
extern uint32_t *g_ExceptionVectorsBase_stream;
extern uint64_t g_bcopy_phys_addr;
extern uint64_t g_phystokv_addr;
extern uint64_t g_copyin_addr;
extern uint64_t g_copyout_addr;
extern uint64_t g_IOSleep_addr;
extern uint64_t g_kprintf_addr;
extern uint64_t g_vm_map_unwire_addr;
extern uint64_t g_vm_map_unwire_nested_addr;
extern uint64_t g_vm_deallocate_addr;
extern uint64_t g_kernel_map_addr;
extern uint64_t g_kernel_thread_start_addr;
extern uint64_t g_thread_deallocate_addr;
extern uint64_t g_mach_make_memory_entry_64_addr;
extern uint64_t g_offsetof_struct_thread_map;
extern uint64_t g_current_proc_addr;
extern uint64_t g_proc_list_lock_addr;
extern uint64_t g_proc_ref_locked_addr;
extern uint64_t g_proc_list_mlock_addr;
extern uint64_t g_lck_mtx_lock_addr;
extern uint64_t g_lck_mtx_unlock_addr;
extern uint64_t g_proc_rele_locked_addr;
extern uint64_t g_proc_uniqueid_addr;
extern uint64_t g_proc_pid_addr;
extern uint64_t g_allproc_addr;
extern uint64_t g_lck_rw_lock_shared_addr;
extern uint64_t g_lck_rw_lock_shared_to_exclusive_addr;
extern uint64_t g_lck_rw_lock_exclusive_addr;
extern uint64_t g_vm_map_wire_external_addr;
extern uint64_t g_mach_vm_map_external_addr;

/* Only for <14.5 */
extern uint64_t g_ipc_port_release_send_addr;

/* Only for >=14.5 */
extern uint64_t g_ipc_port_release_send_and_unlock_addr;

extern uint64_t g_lck_rw_free_addr;
extern uint64_t g_lck_grp_free_addr;
extern int g_patched_doprnt_hide_pointers;
extern uint64_t g_copyinstr_addr;
extern uint64_t g_thread_terminate_addr;
extern int g_patched_pinst_set_tcr;
extern int g_patched_all_msr_tcr_el1_x18;
extern uint64_t g_snprintf_addr;
extern uint64_t g_strlen_addr;
extern uint64_t g_proc_name_addr;
extern uint64_t g_strncmp_addr;
extern uint64_t g_memset_addr;
extern uint64_t g_memmove_addr;
extern uint64_t g_panic_addr;
extern uint64_t g_mach_to_bsd_errno_addr;
extern uint64_t g_xnuspy_sysctl_mib_ptr;
extern uint64_t g_xnuspy_sysctl_mib_count_ptr;
extern uint64_t g_xnuspy_ctl_callnum;
extern uint64_t g_kern_version_major;
extern uint64_t g_kern_version_minor;

/* Only for >=14.5 && <15.0 */
extern uint64_t g_io_lock_addr;

/* Only for >=15.0 */
extern uint64_t g_ipc_object_lock_addr;

extern uint64_t g_vm_allocate_external_addr;
extern uint64_t g_vm_map_deallocate_addr;
extern uint64_t g_offsetof_struct_vm_map_refcnt;
extern uint64_t g_IOLog_addr;

/* Following two are only valid on iOS 15+ */
extern uint64_t g_proc_ref_addr;
extern uint64_t g_proc_rele_addr;

#endif

```

`include/pf/pf_common.h`:

```h
#ifndef PF_COMMON
#define PF_COMMON

#include <stdbool.h>
#include <stdint.h>

typedef struct xnu_pf_patch xnu_pf_patch_t;

struct pf {
    const char *pf_name;
    uint64_t pf_matches[8];
    uint64_t pf_masks[8];
    uint32_t pf_mmcount;
    /* XNU_PF_ACCESS_8BIT, etc */
    uint32_t pf_access_type;
    bool (*pf_callback)(xnu_pf_patch_t *, void *);
    /* If applicable, the name of the kext used with xnu_pf_get_kext_header
     * If not applicable, NULL */
    const char *pf_kext;
    const char *pf_segment;
    /* If applicable, the section used with xnu_pf_section
     * If not applicable, NULL */
    const char *pf_section;
    uint8_t pf_unused;
};

#define LISTIZE(...) __VA_ARGS__

#define PF_DECL32(name, matches, masks, mmcount, callback, seg) \
    { \
        .pf_name = name, \
        .pf_matches = matches, \
        .pf_masks = masks, \
        .pf_mmcount = mmcount, \
        .pf_access_type = XNU_PF_ACCESS_32BIT, \
        .pf_callback = callback, \
        .pf_kext = NULL, \
        .pf_segment = seg, \
        .pf_section = NULL, \
        .pf_unused = 0, \
    }

#define PF_DECL_FULL(name, matches, masks, mmcount, access, callback, kext, seg, sect) \
    { \
        .pf_name = name, \
        .pf_matches = matches, \
        .pf_masks = masks, \
        .pf_mmcount = mmcount, \
        .pf_access_type = access, \
        .pf_callback = callback, \
        .pf_kext = kext, \
        .pf_segment = seg, \
        .pf_section = sect, \
        .pf_unused = 0, \
    }

#define PF_UNUSED { .pf_unused = 1 }

#define PF_END { .pf_unused = 0x41 }

#endif

```

`include/pf/pfs.h`:

```h
#ifndef PFS
#define PFS

#include <pf/pf_common.h>

#include <pf/13/pf.h>
#include <pf/14/pf.h>
#include <pf/15/pf.h>

#define MAXPF                       (100)
#define NUM_SUPPORTED_VERSIONS      (3)

#define PFS_END(x) (x[0].pf_unused == 0x41 && x[1].pf_unused == 0x41 \
        && x[2].pf_unused == 0x41)
#define IS_PF_UNUSED(x) (x->pf_unused == 1)

/* Format:
 *
 * { { iOS 13 patchfinder }, { iOS 14 patchfinder }, { iOS 15 patchfinder } }
 *
 * Not all patchfinders are different across versions.
 *
 * This array will end with
 * { PF_END, PF_END, PF_END }
 */
struct pf g_all_pfs[MAXPF][NUM_SUPPORTED_VERSIONS] = {
    {
        PF_DECL32("sysent finder iOS 13",
            LISTIZE({
                0x1a803000,     /* csel Wn, Wn, Wn, cc */
                0x12003c00,     /* and Wn, Wn, 0xffff */
                0x10000000,     /* adrp Xn, n or adr Xn, n */
            }),
            LISTIZE({
                0xffe0fc00,     /* ignore all but condition code */
                0xfffffc00,     /* ignore all but immediate */
                0x1f000000,     /* ignore everything */
            }),
            3, sysent_finder_13, "__TEXT_EXEC"),
        PF_DECL32("sysent finder iOS 14",
            LISTIZE({
                0x1a803000,     /* csel Wn, Wn, Wn, cc */
                0x92403c00,     /* and Xn, Xn, 0xffff */
                0x52800300,     /* mov Wn, 0x18 */
            }),
            LISTIZE({
                0xffe0fc00,     /* ignore all but condition code */
                0xfffffc00,     /* ignore all but immediate */
                0xffffffe0,     /* ignore Rd */
            }),
            3, sysent_finder_13, "__TEXT_EXEC"),
        PF_DECL32("sysent finder iOS 15",
            LISTIZE({
                0x1a803000,     /* csel Wn, Wn, Wn, cc */
                0x92403c00,     /* and Xn, Xn, 0xffff */
                0x52800300,     /* mov Wn, 0x18 */
            }),
            LISTIZE({
                0xffe0fc00,     /* ignore all but condition code */
                0xfffffc00,     /* ignore all but immediate */
                0xffffffe0,     /* ignore Rd */
            }),
            3, sysent_finder_13, "__TEXT_EXEC"),
    },
    {
        PF_DECL32("kalloc_canblock finder iOS 13",
            LISTIZE({
                0xaa0003f3,     /* mov x19, x0 */
                0xf90003ff,     /* str xzr, [sp, n] */
                0xf9400000,     /* ldr Xn, [Xn] */
                0xf11fbc1f,     /* cmp Xn, 0x7ef */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffc003ff,     /* ignore immediate */
                0xffc00000,     /* ignore immediate, Rn, and Rt */
                0xfffffc1f,     /* ignore Rn */
            }),
            4, kalloc_canblock_finder_13, "__TEXT_EXEC"),
        PF_DECL_FULL("kalloc_external finder iOS 14",
            LISTIZE({
                0x910022f7,     /* add x23, x23, #0x8 */
                0x910043a8,     /* add x8, x29, #0x10 */
                0xf9000fe8,     /* str w8, [sp, #0x18] */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            3, XNU_PF_ACCESS_32BIT, kalloc_external_finder_14,
            "com.apple.driver.AppleMobileFileIntegrity",
            "__TEXT_EXEC", NULL),
        PF_DECL_FULL("kalloc_external finder iOS 15",
            LISTIZE({
                0x910022f7,     /* add x23, x23, #0x8 */
                0x910043a8,     /* add x8, x29, #0x10 */
                0xf9000fe8,     /* str w8, [sp, #0x18] */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            3, XNU_PF_ACCESS_32BIT, kalloc_external_finder_14,
            "com.apple.driver.AppleMobileFileIntegrity",
            "__TEXT_EXEC", NULL),
    },
    {
        PF_DECL32("kfree_addr finder iOS 13",
            LISTIZE({
                0x10000009,     /* adrp x9, n or adr x9, n */
                0x0,            /* ignore this instruction */
                0xfa538002,     /* ccmp Xn, x19, #2, hi */
                0x10000000,     /* adrp Xn, n or adr Xn, n */
                0x0,            /* ignore this instruction */
            }),
            LISTIZE({
                0x1f00001f,     /* ignore immediate */
                0x0,            /* ignore this instruction */
                0xfffffc1f,     /* ignore Xn */
                0x1f000000,     /* ignore everything */
                0x0,            /* ignore this instruction */
            }),
            5, kfree_addr_finder_13, "__TEXT_EXEC"),
        PF_DECL32("kfree_ext finder iOS 14",
            LISTIZE({
                0xd2800000,     /* mov x0, #0 */
                0xaa1303e1,     /* mov x1, x19 */
                0x0,            /* ignore this instruction */
                0x94000000,     /* bl n */
                0xaa1803e0,     /* mov x0, x24 */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0x0,            /* ignore this instruction */
                0xfc000000,     /* ignore immediate */
                0xffffffff,     /* match exactly */
            }),
            5, kfree_ext_finder_14, "__TEXT_EXEC"),
        PF_DECL32("kfree_ext finder iOS 15",
            LISTIZE({
                0x10000000,     /* adrp x0, n or adr x0, n */
                0x0,            /* ignore this instruction */
                0xaa1303e1,     /* mov x1, x19 */
                0x0,            /* ignore this instruction */
                0x94000000,     /* bl n */
                0xaa1803e0,     /* mov x0, x24 */
            }),
            LISTIZE({
                0x1f00001f,     /* ignore immediate */
                0x0,            /* ignore this instruction */
                0xffffffff,     /* match exactly */
                0x0,            /* ignore this instruction */
                0xfc000000,     /* ignore immediate */
                0xffffffff,     /* match exactly */
            }),
            6, kfree_ext_finder_14, "__TEXT_EXEC"),
    },
    {
        PF_DECL32("Unused executable code finder iOS 13",
            LISTIZE({
                0xd538d092,     /* mrs x18, tpidr_el1 */
                0xf9400252,     /* ldr x18, [x18, n] */
                0xf9400252,     /* ldr x18, [x18, n] */
                0xf9400252,     /* ldr x18, [x18] */
                0xd61f0240,     /* br x18 */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffc003ff,     /* match all but immediate */
                0xffc003ff,     /* match all but immediate */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            5, ExceptionVectorsBase_finder_13, "__TEXT_EXEC"),
        PF_DECL32("Unused executable code finder iOS 14",
            LISTIZE({
                0xd538d092,     /* mrs x18, tpidr_el1 */
                0xf9400252,     /* ldr x18, [x18, n] */
                0xf9400252,     /* ldr x18, [x18, n] */
                0xf9400252,     /* ldr x18, [x18] */
                0xd61f0240,     /* br x18 */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffc003ff,     /* match all but immediate */
                0xffc003ff,     /* match all but immediate */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            5, ExceptionVectorsBase_finder_14, "__TEXT_EXEC"),
        PF_DECL32("Unused executable code finder iOS 15",
            LISTIZE({
                0xd538d092,     /* mrs x18, tpidr_el1 */
                0xf9400252,     /* ldr x18, [x18, n] */
                0xf9400252,     /* ldr x18, [x18, n] */
                0xf9400252,     /* ldr x18, [x18] */
                0xd61f0240,     /* br x18 */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffc003ff,     /* match all but immediate */
                0xffc003ff,     /* match all but immediate */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            5, ExceptionVectorsBase_finder_14, "__TEXT_EXEC"),
    },
    {
        PF_DECL32("sysctl__kern_children finder iOS 13",
            LISTIZE({
                0x10000013,     /* ADRP X19, n or ADR X19, n */
                0x0,            /* ignore this instruction */
                0x10000014,     /* ADRP X20, n or ADR X20, n */
                0x0,            /* ignore this instruction */
                0x10000015,     /* ADRP X21, n or ADR X21, n */
                0x0,            /* ignore this instruction */
                0x10000016,     /* ADRP X22, n or ADR X22, n */
                0x0,            /* ignore this instruction */
            }),
            LISTIZE({
                0x1f00001f,     /* ignore immediate */
                0x0,            /* ignore this instruction */
                0x1f00001f,     /* ignore immediate */
                0x0,            /* ignore this instruction */
                0x1f00001f,     /* ignore immediate */
                0x0,            /* ignore this instruction */
                0x1f00001f,     /* ignore immediate */
                0x0,            /* ignore this instruction */
            }),
            8, sysctl__kern_children_finder_13, "__TEXT_EXEC"),
        PF_DECL_FULL("sysctl__kern_children & sysctl_register_oid finder iOS 14",
            LISTIZE({
                0x94000000,     /* bl n */
                0x10000008,     /* adrp x8, n or adr x8, n */
                0x0,            /* ignore this instruction */
                0xad400500,     /* ldp q0, q1, [x8] */
                0xad0087e0,     /* stp q0, q1, [sp, 0x10] */
            }),
            LISTIZE({
                0xfc000000,     /* ignore immediate */
                0x1f00001f,     /* ignore immediate */
                0x0,            /* ignore this instruction */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            5, XNU_PF_ACCESS_32BIT, sysctl__kern_children_and_register_oid_finder_14,
            "com.apple.kec.corecrypto", "__TEXT_EXEC", NULL),
        PF_DECL_FULL("sysctl__kern_children & sysctl_register_oid finder iOS 15",
            LISTIZE({
                0x94000000,     /* bl n */
                0x10000008,     /* adrp x8, n or adr x8, n */
                0x0,            /* ignore this instruction */
                0xad400500,     /* ldp q0, q1, [x8] */
                0xad0007e0,     /* stp q0, q1, [sp, n] */
                0x3dc00100,     /* ldr q0, [x8, n] */
                0x3d8003e0,     /* str q0, [sp, n] */
            }),
            LISTIZE({
                0xfc000000,     /* ignore immediate */
                0x1f00001f,     /* ignore immediate */
                0x0,            /* ignore this instruction */
                0xffffffff,     /* match exactly */
                0xffc07fff,     /* ignore signed offset */
                0xffc003ff,     /* ignore immediate */
                0xffc003ff,     /* ignore immediate */
            }),
            7, XNU_PF_ACCESS_32BIT, sysctl__kern_children_and_register_oid_finder_14,
            "com.apple.kec.corecrypto", "__TEXT_EXEC", NULL),
    },
    {
        PF_DECL32("sysctl_register_oid finder iOS 13",
            LISTIZE({
                0xb4000013,     /* cbz x19, n */
                0xf9000013,     /* str x19, [xn, n] */
                0x91002000,     /* add xn, xn, 8 */
                0xf9000260,     /* str xn, [x19, n] */
                0xf9400000,     /* ldr x0, [xn, n] */
                0x94000000,     /* bl n (_sysctl_register_oid) */
            }),
            LISTIZE({
                0xff00001f,     /* ignore immediate */
                0xffc0001f,     /* ignore all but Rt */
                0xfffffc00,     /* only match immediate */
                0xffc003e0,     /* ignore immediate and Rt */
                0xffc0001f,     /* ignore all but Rt */
                0xfc000000,     /* ignore immediate */
            }),
            6, sysctl_register_oid_finder_13, "__TEXT_EXEC"),
        PF_UNUSED,
        PF_UNUSED,
    },
    {
        PF_DECL_FULL("hook_system_check_sysctlbyname finder iOS 13",
            LISTIZE({
                0x7100101f,     /* cmp wn, 4 */
                0x54000003,     /* b.cc n */
                0xb9400000,     /* ldr wn, [xn] */
                0x7100041f,     /* cmp wn, 1 */
                0x54000001,     /* b.ne n */
                0xb9400400,     /* ldr wn, [xn, 4] */
                0x7100381f,     /* cmp wn, 0xe */
                0x54000001,     /* b.ne n */
            }),
            LISTIZE({
                0xfffffc1f,     /* ignore Rn */
                0xff00001f,     /* ignore immediate */
                0xfffffc00,     /* ignore Rn and Rt */
                0xfffffc1f,     /* ignore Rn */
                0xff00001f,     /* ignore immediate */
                0xfffffc00,     /* ignore Rn and Rt */
                0xfffffc1f,     /* ignore Rn */
                0xff00001f,     /* ignore immediate */
            }),
            8, XNU_PF_ACCESS_32BIT, hook_system_check_sysctlbyname_finder_13,
            "com.apple.security.sandbox", "__TEXT_EXEC", NULL),
        PF_DECL_FULL("hook_system_check_sysctlbyname finder iOS 14",
            LISTIZE({
                0xf100101f,     /* cmp xn, 4 */
                0x54000003,     /* b.cc n */
                0xb9400000,     /* ldr wn, [xn] */
                0x7100041f,     /* cmp wn, 1 */
                0x54000001,     /* b.ne n */
                0xb9400400,     /* ldr wn, [xn, 4] */
                0x7100381f,     /* cmp wn, 0xe */
                0x54000001,     /* b.ne n */
            }),
            LISTIZE({
                0xfffffc1f,     /* ignore Rn */
                0xff00001f,     /* ignore immediate */
                0xfffffc00,     /* ignore Rn and Rt */
                0xfffffc1f,     /* ignore Rn */
                0xff00001f,     /* ignore immediate */
                0xfffffc00,     /* ignore Rn and Rt */
                0xfffffc1f,     /* ignore Rn */
                0xff00001f,     /* ignore immediate */
            }),
            8, XNU_PF_ACCESS_32BIT, hook_system_check_sysctlbyname_finder_13,
            "com.apple.security.sandbox", "__TEXT_EXEC", NULL),
        PF_DECL_FULL("hook_system_check_sysctlbyname finder iOS 15",
            LISTIZE({
                0xf100101f,     /* cmp xn, 4 */
                0x54000003,     /* b.cc n */
                0xb9400000,     /* ldr wn, [xn] */
                0x7100041f,     /* cmp wn, 1 */
                0x54000001,     /* b.ne n */
                0xb9400400,     /* ldr wn, [xn, 4] */
                0x7100381f,     /* cmp wn, 0xe */
                0x54000001,     /* b.ne n */
            }),
            LISTIZE({
                0xfffffc1f,     /* ignore Rn */
                0xff00001f,     /* ignore immediate */
                0xfffffc00,     /* ignore Rn and Rt */
                0xfffffc1f,     /* ignore Rn */
                0xff00001f,     /* ignore immediate */
                0xfffffc00,     /* ignore Rn and Rt */
                0xfffffc1f,     /* ignore Rn */
                0xff00001f,     /* ignore immediate */
            }),
            8, XNU_PF_ACCESS_32BIT, hook_system_check_sysctlbyname_finder_13,
            "com.apple.security.sandbox", "__TEXT_EXEC", NULL),
    },
    {
        PF_DECL32("sysctl_handle_long finder iOS 13",
            LISTIZE({
                0xb4000001,     /* cbz x1, n */
                0xd10003ff,     /* sub sp, sp, n */
                0xa9004ff4,     /* stp x20, x19, [sp, n] */
                0xa9007bfd,     /* stp x29, x30, [sp, n] */
                0x0,            /* ignore this instruction */
                0xaa0303f4,     /* mov x20, x3 */
                0xaa0103f3,     /* mov x19, x1 */
                0xf9400028,     /* ldr x8, [x1] */
            }),
            LISTIZE({
                0xff00001f,     /* ignore immediate */
                0xffc003ff,     /* ignore immediate */
                0xffc07fff,     /* ignore immediate */
                0xffc07fff,     /* ignore immediate */
                0x0,            /* ignore this instruction */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            8, sysctl_handle_long_finder_13, "__TEXT_EXEC"),
        PF_DECL32("sysctl_handle_long finder iOS 14",
            LISTIZE({
                0xb4000001,     /* cbz x1, n */
                0xd10003ff,     /* sub sp, sp, n */
                0xa9004ff4,     /* stp x20, x19, [sp, n] */
                0xa9007bfd,     /* stp x29, x30, [sp, n] */
                0x0,            /* ignore this instruction */
                0xaa0303f4,     /* mov x20, x3 */
                0xaa0103f3,     /* mov x19, x1 */
                0xf9400028,     /* ldr x8, [x1] */
            }),
            LISTIZE({
                0xff00001f,     /* ignore immediate */
                0xffc003ff,     /* ignore immediate */
                0xffc07fff,     /* ignore immediate */
                0xffc07fff,     /* ignore immediate */
                0x0,            /* ignore this instruction */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            8, sysctl_handle_long_finder_13, "__TEXT_EXEC"),
        PF_DECL32("sysctl_handle_long finder iOS 15",
            LISTIZE({
                0xb4000001,     /* cbz x1, n */
                0xd10003ff,     /* sub sp, sp, n */
                0xa9004ff4,     /* stp x20, x19, [sp, n] */
                0xa9007bfd,     /* stp x29, x30, [sp, n] */
                0x0,            /* ignore this instruction */
                0xaa0303f4,     /* mov x20, x3 */
                0xaa0103f3,     /* mov x19, x1 */
                0xf9400028,     /* ldr x8, [x1] */
            }),
            LISTIZE({
                0xff00001f,     /* ignore immediate */
                0xffc003ff,     /* ignore immediate */
                0xffc07fff,     /* ignore immediate */
                0xffc07fff,     /* ignore immediate */
                0x0,            /* ignore this instruction */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            8, sysctl_handle_long_finder_13, "__TEXT_EXEC"),
    },
    {
        PF_DECL32("name2oid and its dependencies finder iOS 13",
            LISTIZE({
                0x10000000,     /* adrp xn, n or adr xn, n (n = _sysctl_geometry_lock) */
                0xf9400000,     /* ldr x0, [xn, n] */
                0x94000000,     /* bl n (_lck_rw_lock_shared) */
                0x910003e1,     /* add x1, sp, n */
                0x910003e2,     /* add x2, sp, n */
                0x0,            /* ignore this instruction */
                0x94000000,     /* bl n (_name2oid) */
                0x0,            /* ignore this instruction */
            }),
            LISTIZE({
                0x1f000000,     /* ignore everything */
                0xffc0001f,     /* ignore all but Rt */
                0xfc000000,     /* ignore immediate */
                0xffc003ff,     /* ignore immediate */
                0xffc003ff,     /* ignore immediate */
                0x0,            /* ignore this instruction */
                0xfc000000,     /* ignore immediate */
                0x0,            /* ignore this instruction */
            }),
            8, name2oid_and_its_dependencies_finder_13, "__TEXT_EXEC"),
        PF_DECL32("name2oid and its dependencies finder iOS 14",
            LISTIZE({
                0x94000000,     /* bl n (_lck_rw_lock_shared) */
                0x910043e1,     /* add x1, sp, #0x10 */
                0x910023e2,     /* add x2, sp, #0x8 */
                0x0,            /* ignore this instruction */
                0x94000000,     /* BL n (_name2oid) */
            }),
            LISTIZE({
                0xfc000000,     /* ignore immediate */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0x0,            /* ignore this instruction */
                0xfc000000,     /* ignore immediate */
            }),
            5, name2oid_and_its_dependencies_finder_14, "__TEXT_EXEC"),
        PF_DECL32("name2oid and its dependencies finder iOS 15",
            LISTIZE({
                0x94000000,     /* bl n (_lck_rw_lock_shared) */
                0x910043e1,     /* add x1, sp, #0x10 */
                0x910023e2,     /* add x2, sp, #0x8 */
                0x0,            /* ignore this instruction */
                0x94000000,     /* BL n (_name2oid) */
            }),
            LISTIZE({
                0xfc000000,     /* ignore immediate */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0x0,            /* ignore this instruction */
                0xfc000000,     /* ignore immediate */
            }),
            5, name2oid_and_its_dependencies_finder_14, "__TEXT_EXEC"),
    },
    {
        PF_DECL_FULL("lck_grp_alloc_init finder iOS 13",
            LISTIZE({
                0xf9400260,     /* ldr x0, [x19] */
                0xf9400281,     /* ldr x1, [x20, n] */
                0x94000000,     /* bl n */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffc003ff,     /* ignore immediate */
                0xfc000000,     /* ignore immediate */
            }),
            3, XNU_PF_ACCESS_32BIT, lck_grp_alloc_init_finder_13,
            "com.apple.security.sandbox", "__TEXT_EXEC", NULL),
        PF_DECL_FULL("lck_grp_alloc_init finder iOS 14",
            LISTIZE({
                0x910003e3,     /* add x3, sp, n */
                0x910003e5,     /* add x5, sp, n */
                0xaa1303e0,     /* mov x0, x19 */
                0x52800802,     /* mov w2, 0x40 */
                0x52800104,     /* mov w4, 0x8 */
                0xd2800006,     /* mov x6, 0 */
                0xd2800007,     /* mov x7, 0 */
            }),
            LISTIZE({
                0xffc003ff,     /* ignore immediate */
                0xffc003ff,     /* ignore immediate */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            7, XNU_PF_ACCESS_32BIT, lck_grp_alloc_init_finder_14,
            "com.apple.kec.corecrypto", "__TEXT_EXEC", NULL),
        PF_DECL_FULL("lck_grp_alloc_init finder iOS 15",
            LISTIZE({
                0x910003e3,     /* add x3, sp, n */
                0x910003e5,     /* add x5, sp, n */
                0xaa1303e0,     /* mov x0, x19 */
                0x52800802,     /* mov w2, 0x40 */
                0x52800104,     /* mov w4, 0x8 */
                0xd2800006,     /* mov x6, 0 */
                0xd2800007,     /* mov x7, 0 */
            }),
            LISTIZE({
                0xffc003ff,     /* ignore immediate */
                0xffc003ff,     /* ignore immediate */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            7, XNU_PF_ACCESS_32BIT, lck_grp_alloc_init_finder_14,
            "com.apple.kec.corecrypto", "__TEXT_EXEC", NULL),
    },
    {
        PF_DECL32("lck_rw_alloc_init finder iOS 13",
            LISTIZE({
                0xd37ced01,     /* lsl x1, x8, #4 */
                0x94000000,     /* bl n (bzero) */
                0x10000008,     /* adrp x8, n or adr x8, n */
                0x0,            /* ignore this instruction */
                0xd2800001,     /* mov x1, 0 */
                0x94000000,     /* bl n (lck_rw_alloc_init) */
                0xf9000260,     /* str x0, [x19, n] */
                0xb5000000,     /* cbnz x0, n */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xfc000000,     /* ignore immediate */
                0x1f00001f,     /* ignore immediate */
                0x0,            /* ignore this instruction */
                0xffffffff,     /* match exactly */
                0xfc000000,     /* ignore immediate */
                0xffc003ff,     /* ignore immediate */
                0xff00001f,     /* ignore immediate */
            }),
            8, lck_rw_alloc_init_finder_13, "__TEXT_EXEC"),
        PF_DECL32("lck_rw_alloc_init finder iOS 14",
            LISTIZE({
                0x94000000,     /* bl n (lck_rw_alloc_init) */
                0xf90002a0,     /* str x0, [x21] */
                0xb4000000,     /* cbz x0, n */
                0x0,            /* ignore this instruction */
                0x0,            /* ignore this instruction */
                0x35000000,     /* cbnz w0, n */
                0x52804000,     /* mov w0, 0x200 */
            }),
            LISTIZE({
                0xfc000000,     /* ignore immediate */
                0xffffffff,     /* match exactly */
                0xff00001f,     /* ignore immediate */
                0x0,            /* ignore this instruction */
                0x0,            /* ignore this instruction */
                0xff00001f,     /* ignore immediate */
                0xffffffff,     /* match exactly */
            }),
            7, lck_rw_alloc_init_finder_14, "__TEXT_EXEC"),
        PF_DECL_FULL("lck_rw_alloc_init finder iOS 15",
            LISTIZE({
                0xd2800016,     /* mov x22, #0 */
                0xf9400260,     /* ldr x0, [x19] */
                0xd2800001,     /* mov x1, #0 */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            3, XNU_PF_ACCESS_32BIT, lck_rw_alloc_init_finder_15,
            "com.apple.filesystems.lifs", "__TEXT_EXEC", NULL),
    },
    {
        PF_DECL32("bcopy_phys finder iOS 13",
            LISTIZE({
                0x52800808,     /* mov w8, 0x4<n> */
                0x0,            /* ignore this instruction */
                0x0,            /* ignore this instruction */
                0x52800808,     /* mov w8, 0x4<n> */
            }),
            LISTIZE({
                0xfffffe1f,     /* ignore the lower 4 bits of imm16 */
                0x0,            /* ignore this instruction */
                0x0,            /* ignore this instruction */
                0xfffffe1f,     /* ignore the lower 4 bits of imm16 */
            }),
            4, bcopy_phys_finder_13, "__TEXT_EXEC"),
        PF_DECL32("bcopy_phys finder iOS 14",
            LISTIZE({
                0x52800808,     /* mov w8, 0x4<n> */
                0x0,            /* ignore this instruction */
                0x0,            /* ignore this instruction */
                0x52800808,     /* mov w8, 0x4<n> */
            }),
            LISTIZE({
                0xfffffe1f,     /* ignore the lower 4 bits of imm16 */
                0x0,            /* ignore this instruction */
                0x0,            /* ignore this instruction */
                0xfffffe1f,     /* ignore the lower 4 bits of imm16 */
            }),
            4, bcopy_phys_finder_13, "__TEXT_EXEC"),
        PF_DECL32("bcopy_phys finder iOS 15",
            LISTIZE({
                0x52800808,     /* mov w8, 0x4<n> */
                0x0,            /* ignore this instruction */
                0x0,            /* ignore this instruction */
                0x52800808,     /* mov w8, 0x4<n> */
            }),
            LISTIZE({
                0xfffffe1f,     /* ignore the lower 4 bits of imm16 */
                0x0,            /* ignore this instruction */
                0x0,            /* ignore this instruction */
                0xfffffe1f,     /* ignore the lower 4 bits of imm16 */
            }),
            4, bcopy_phys_finder_13, "__TEXT_EXEC"),
    },
    {
        PF_DECL32("phystokv finder iOS 13",
            LISTIZE({
                0x92dfff29,     /* mov x9, #-0xfff900000001 */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
            }),
            1, phystokv_finder_13, "__TEXT_EXEC"),
        PF_DECL32("phystokv finder iOS 14",
            LISTIZE({
                0x92dffe49,     /* mov x9, #-0xfff200000001 */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
            }),
            1, phystokv_finder_13, "__TEXT_EXEC"),
        PF_DECL32("phystokv finder iOS 15",
            LISTIZE({
                0x92dffe49,     /* mov x9, #-0xfff200000001 */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
            }),
            1, phystokv_finder_13, "__TEXT_EXEC"),
    },
    {
        PF_DECL32("KTRR MMU lockdown patcher iOS 13",
            LISTIZE({
                0xd51cf260,     /* msr s3_4_c15_c2_3, xn */
                0x00000000,     /* ignore this instruction */
                0xd51cf280,     /* msr s3_4_c15_c2_4, xn */
                0x00000000,     /* ignore this instruction */
                0xd51cf240,     /* msr s3_4_c15_c2_2, xn */
            }),
            LISTIZE({
                0xffffffe0,     /* ignore Rt */
                0x00000000,     /* ignore this instruction */
                0xffffffe0,     /* ignore Rt */
                0x00000000,     /* ignore this instruction */
                0xffffffe0,     /* ignore Rt */
            }),
            5, ktrr_lockdown_patcher_13, "__TEXT_EXEC"),
        PF_DECL32("KTRR MMU lockdown patcher iOS 14",
            LISTIZE({
                0xd51cf260,     /* msr s3_4_c15_c2_3, xn */
                0xd51cf280,     /* msr s3_4_c15_c2_4, xn */
                0x52800020,     /* mov (x|w)n, 1 */
                0xd51cf240,     /* msr s3_4_c15_c2_2, xn */
            }),
            LISTIZE({
                0xffffffe0,     /* ignore Rt */
                0xffffffe0,     /* ignore Rt */
                0x7fffffe0,     /* ignore Rd */
                0xffffffe0,     /* ignore Rt */
            }),
            4, ktrr_lockdown_patcher_14, "__TEXT_EXEC"),
        PF_DECL32("KTRR MMU lockdown patcher iOS 15",
            LISTIZE({
                0xd51cf260,     /* msr s3_4_c15_c2_3, xn */
                0xd51cf280,     /* msr s3_4_c15_c2_4, xn */
                0x52800020,     /* mov (x|w)n, 1 */
                0xd51cf240,     /* msr s3_4_c15_c2_2, xn */
            }),
            LISTIZE({
                0xffffffe0,     /* ignore Rt */
                0xffffffe0,     /* ignore Rt */
                0x7fffffe0,     /* ignore Rd */
                0xffffffe0,     /* ignore Rt */
            }),
            4, ktrr_lockdown_patcher_14, "__TEXT_EXEC"),
    },
    {
        PF_DECL32("AMCC MMU lockdown patcher iOS 13",
            LISTIZE({
                0xb907ec00,     /* str wn, [xn, 0x7ec] */
                0xd5033fdf,     /* isb */
                0xd51cf260,     /* msr s3_4_c15_c2_3, xn */
                0xd51cf280,     /* msr s3_4_c15_c2_4, xn */
                0xd51cf240,     /* msr s3_4_c15_c2_2, xn */
            }),
            LISTIZE({
                0xfffffc00,     /* ignore Rn and Rt */
                0xffffffff,     /* match exactly */
                0xffffffe0,     /* ignore Rt */
                0xffffffe0,     /* ignore Rt */
                0xffffffe0,     /* ignore Rt */
            }),
            5, amcc_lockdown_patcher_13, "__TEXT_EXEC"),
        PF_DECL32("AMCC CTRR MMU lockdown patcher iOS 14",
            LISTIZE({
                0xb94001d1,     /* ldr w17, [x14] */
                0x1b0f7e31,     /* mul x17, w17, w15 */
                0x8b110210,     /* add x16, x16, x17 */
                0x0,            /* ignore this instruction */
                0x0,            /* ignore this instruction */
                0xb8316a00,     /* str w0, [x16, x17] */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0x0,            /* ignore this instruction */
                0x0,            /* ignore this instruction */
                0xffffffff,     /* match exactly */
            }),
            6, amcc_ctrr_lockdown_patcher_14, "__TEXT_EXEC"),
        PF_DECL32("AMCC CTRR MMU lockdown patcher iOS 15",
            LISTIZE({
                0xb94001d1,     /* ldr w17, [x14] */
                0x1b0f7e31,     /* mul x17, w17, w15 */
                0x8b110210,     /* add x16, x16, x17 */
                0x0,            /* ignore this instruction */
                0x0,            /* ignore this instruction */
                0xb8316a00,     /* str w0, [x16, x17] */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0x0,            /* ignore this instruction */
                0x0,            /* ignore this instruction */
                0xffffffff,     /* match exactly */
            }),
            6, amcc_ctrr_lockdown_patcher_14, "__TEXT_EXEC"),
    },
    {
        PF_DECL32("copyin finder iOS 13",
            LISTIZE({
                0xb4000002,     /* cbz x2, n */
                0xaa0203f3,     /* mov x19, x2 */
                0xaa0103f4,     /* mov x20, x1 */
                0xaa0003f5,     /* mov x21, x0 */
                0x528000a3,     /* mov w3, 5 */
                0x94000000,     /* bl _copy_validate */
            }),
            LISTIZE({
                0xff00001f,     /* ignore immediate */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xfc000000,     /* ignore immediate */
            }),
            6, copyin_finder_13, "__TEXT_EXEC"),
        PF_DECL32("copyin finder iOS 14",
            LISTIZE({
                0xb4000002,     /* cbz x2, n */
                0xaa0203f3,     /* mov x19, x2 */
                0xaa0103f4,     /* mov x20, x1 */
                0xaa0003f5,     /* mov x21, x0 */
                0x528000a3,     /* mov w3, 5 */
                0x94000000,     /* bl _copy_validate */
            }),
            LISTIZE({
                0xff00001f,     /* ignore immediate */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xfc000000,     /* ignore immediate */
            }),
            6, copyin_finder_13, "__TEXT_EXEC"),
        PF_DECL32("copyin finder iOS 15",
            LISTIZE({
                0xb4000002,     /* cbz x2, n */
                0xaa0203f3,     /* mov x19, x2 */
                0xaa0103f4,     /* mov x20, x1 */
                0xaa0003f5,     /* mov x21, x0 */
                0x528000a3,     /* mov w3, 5 */
                0x94000000,     /* bl _copy_validate */
            }),
            LISTIZE({
                0xff00001f,     /* ignore immediate */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xfc000000,     /* ignore immediate */
            }),
            6, copyin_finder_13, "__TEXT_EXEC"),
    },
    {
        PF_DECL32("copyout finder iOS 13",
            LISTIZE({
                0xb4000002,     /* cbz x2, n */
                0xaa0203f3,     /* mov x19, x2 */
                0xaa0103f4,     /* mov x20, x1 */
                0xaa0003f5,     /* mov x21, x0 */
                0x0,            /* ignore this instruction */
                0x0,            /* ignore this instruction */
                0x0,            /* ignore this instruction */
                0x94000000,     /* bl _copy_validate */
            }),
            LISTIZE({
                0xff00001f,     /* ignore immediate */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0x0,            /* ignore this instruction */
                0x0,            /* ignore this instruction */
                0x0,            /* ignore this instruction */
                0xfc000000,     /* ignore immediate */
            }),
            8, copyout_finder_13, "__TEXT_EXEC"),
        PF_DECL32("copyout finder iOS 14",
            LISTIZE({
                0xb4000002,     /* cbz x2, n */
                0xaa0203f3,     /* mov x19, x2 */
                0xaa0103f4,     /* mov x20, x1 */
                0xaa0003f5,     /* mov x21, x0 */
                0x0,            /* ignore this instruction */
                0x0,            /* ignore this instruction */
                0x0,            /* ignore this instruction */
                0x94000000,     /* bl _copy_validate */
            }),
            LISTIZE({
                0xff00001f,     /* ignore immediate */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0x0,            /* ignore this instruction */
                0x0,            /* ignore this instruction */
                0x0,            /* ignore this instruction */
                0xfc000000,     /* ignore immediate */
            }),
            8, copyout_finder_13, "__TEXT_EXEC"),
        PF_DECL32("copyout finder iOS 15",
            LISTIZE({
                0xb4000002,     /* cbz x2, n */
                0xaa0203f3,     /* mov x19, x2 */
                0xaa0103f4,     /* mov x20, x1 */
                0xaa0003f5,     /* mov x21, x0 */
                0x0,            /* ignore this instruction */
                0x0,            /* ignore this instruction */
                0x0,            /* ignore this instruction */
                0x94000000,     /* bl _copy_validate */
            }),
            LISTIZE({
                0xff00001f,     /* ignore immediate */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0x0,            /* ignore this instruction */
                0x0,            /* ignore this instruction */
                0x0,            /* ignore this instruction */
                0xfc000000,     /* ignore immediate */
            }),
            8, copyout_finder_13, "__TEXT_EXEC"),
    },
    {
        PF_DECL32("IOSleep finder iOS 14",
            LISTIZE({
                0x52884801,     /* mov w1, 0x4240 */
                0x72a001e1,     /* movk w1, 0xf, lsl 16 */
                0x14000000,     /* b _delay_for_interval */
                0x52884802,     /* mov w2, 0x4240 */
                0x72a001e2,     /* movk w2, 0xf, lsl 16 */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xfc000000,     /* ignore immediate */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            5, IOSleep_finder_13, "__TEXT_EXEC"),
        PF_DECL32("IOSleep finder iOS 14",
            LISTIZE({
                0x52884801,     /* mov w1, 0x4240 */
                0x72a001e1,     /* movk w1, 0xf, lsl 16 */
                0x14000000,     /* b _delay_for_interval */
                0x52884802,     /* mov w2, 0x4240 */
                0x72a001e2,     /* movk w2, 0xf, lsl 16 */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xfc000000,     /* ignore immediate */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            5, IOSleep_finder_13, "__TEXT_EXEC"),
        PF_DECL32("IOSleep finder iOS 15",
            LISTIZE({
                0x52884801,     /* mov w1, 0x4240 */
                0x72a001e1,     /* movk w1, 0xf, lsl 16 */
                0x14000000,     /* b _delay_for_interval */
                0x52884802,     /* mov w2, 0x4240 */
                0x72a001e2,     /* movk w2, 0xf, lsl 16 */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xfc000000,     /* ignore immediate */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            5, IOSleep_finder_13, "__TEXT_EXEC"),
    },
    {
        PF_DECL32("kprintf finder iOS 13",
            LISTIZE({
                0x910003fd,     /* add x29, sp, #n */
                0xaa1e03f3,     /* mov x19, x30 */
                0xaa0003f4,     /* mov x20, x0 */
                0xa9007fff,     /* stp xzr, xzr, [sp] */
            }),
            LISTIZE({
                0xffc003ff,     /* ignore immediate */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            4, kprintf_finder_13, "__TEXT_EXEC"),
        PF_DECL32("kprintf finder iOS 14",
            LISTIZE({
                0x910003fd,     /* add x29, sp, #n */
                0xaa1e03f3,     /* mov x19, x30 */
                0xaa0003f4,     /* mov x20, x0 */
                0xa9007fff,     /* stp xzr, xzr, [sp] */
            }),
            LISTIZE({
                0xffc003ff,     /* ignore immediate */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            4, kprintf_finder_13, "__TEXT_EXEC"),
        PF_DECL32("kprintf finder iOS 15",
            LISTIZE({
                0x910003fd,     /* add x29, sp, #n */
                0xaa1e03f3,     /* mov x19, x30 */
                0xaa0003f4,     /* mov x20, x0 */
                0xa9007fff,     /* stp xzr, xzr, [sp] */
            }),
            LISTIZE({
                0xffc003ff,     /* ignore immediate */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            4, kprintf_finder_13, "__TEXT_EXEC"),
    },
    {
        PF_DECL_FULL("kernel_map,vm_deallocate,vm_map_unwire finder iOS 13",
            LISTIZE({
                0x94000000,     /* bl _vm_map_unwire */
                0xf94002e0,     /* ldr x0, [x23] */
                0xa9400a61,     /* ldp x1, x2, [x19] */
                0x94000000,     /* bl _vm_deallocate */
                0xa9402668,     /* ldp x8, x9, [x19] */
                0x8b090114,     /* add x20, x8, x9 */
            }),
            LISTIZE({
                0xfc000000,     /* ignore immediate */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xfc000000,     /* ignore immediate */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            6, XNU_PF_ACCESS_32BIT,
            kernel_map_vm_deallocate_vm_map_unwire_finder_13,
            "com.apple.security.sandbox", "__TEXT_EXEC", NULL),
        PF_DECL_FULL("kernel_map,vm_deallocate,vm_map_unwire finder iOS 14",
            LISTIZE({
                0x94000000,     /* bl _vm_map_unwire */
                0xf94002e0,     /* ldr x0, [x23] */
                0xa9400a61,     /* ldp x1, x2, [x19] */
                0x94000000,     /* bl _vm_deallocate */
                0xa9402668,     /* ldp x8, x9, [x19] */
                0x8b090114,     /* add x20, x8, x9 */
            }),
            LISTIZE({
                0xfc000000,     /* ignore immediate */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xfc000000,     /* ignore immediate */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            6, XNU_PF_ACCESS_32BIT,
            kernel_map_vm_deallocate_vm_map_unwire_finder_13,
            "com.apple.security.sandbox", "__TEXT_EXEC", NULL),
        PF_UNUSED,
    },
    {
        PF_UNUSED,
        PF_UNUSED,
        PF_DECL32("vm_map_unwire_nested finder iOS 15",
            LISTIZE({
                0x94000000,     /* bl _vm_map_unwire_nested */
                0xf9400000,     /* ldr x0, [Xn, n] */
                0x910003e4,     /* add x4, sp, n */
                0xaa0003e1,     /* mov x1, Xn */
                0xaa0003e2,     /* mov x2, Xn */
                0x52800023,     /* mov w3, #1 */
                0x94000000,     /* bl n */
            }),
            LISTIZE({
                0xfc000000,     /* ignore immediate */
                0xffc0001f,     /* ignore Rn & immediate */
                0xff8003ff,     /* ignore immediate */
                0xffe0ffff,     /* ignore Xn */
                0xffe0ffff,     /* ignore Xn */
                0xffffffff,     /* match exactly */
                0xfc000000,     /* ignore immediate */
            }),
            7, vm_map_unwire_nested_finder_15, "__TEXT_EXEC"),
    },
    {
        PF_UNUSED,
        PF_UNUSED,
        PF_DECL32("kernel_map finder iOS 15",
            LISTIZE({
                0x94000000,     /* bl n */
                0xaa0003f4,     /* mov x20, x0 */
                0x0,            /* ignore this instruction */
                0x9ba87c00,     /* umull Xn, w0, w8 */
            }),
            LISTIZE({
                0xfc000000,     /* ignore immediate */
                0xffffffff,     /* match exactly */
                0x0,            /* ignore this instruction */
                0xffffffe0,     /* ignore Rd */
            }),
            4, kernel_map_finder_15, "__TEXT_EXEC"),
    },
    {
        PF_UNUSED,
        PF_UNUSED,
        PF_DECL32("vm_deallocate finder iOS 15",
            LISTIZE({
                0x94000000,     /* bl n */
                0xf900001f,     /* str xzr, [Xn, n] */
                0x3900001f,     /* strb wzr, [Xn, n] */
                0xb4000000,     /* cbz Xn, n */
                0x0,            /* ignore this instruction */
                0x0,            /* ignore this instruction */
                0xaa0003e1,     /* mov x1, Xn */
                0xaa0003e2,     /* mov x2, Xn */
            }),
            LISTIZE({
                0xfc000000,     /* ignore immediate */
                0xffc0001f,     /* ignore Rn & immediate */
                0xffc0001f,     /* ignore Rn & immediate */
                0xff000000,     /* ignore Rn & immediate */
                0x0,            /* ignore this instruction */
                0x0,            /* ignore this instruction */
                0xffe0ffff,     /* ignore Rn */
                0xffe0ffff,     /* ignore Rn */
            }),
            8, vm_deallocate_finder_15, "__TEXT_EXEC"),
    },
    {
        PF_DECL_FULL("kernel_thread_start,thread_deallocate finder iOS 13",
            LISTIZE({
                0x94000000,     /* bl _kernel_thread_start */
                0x34000000,     /* cbz w0, n */
                0xf900027f,     /* str xzr, [x19] */
                0x528000a0,     /* mov w0, 5 */
                0xa9417bfd,     /* ldp x29, x30, [sp, 0x10] */
            }),
            LISTIZE({
                0xfc000000,     /* ignore immediate */
                0xff00001f,     /* ignore immediate */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            5, XNU_PF_ACCESS_32BIT,
            kernel_thread_start_thread_deallocate_finder_13,
            "com.apple.filesystems.apfs", "__TEXT_EXEC", NULL),
        PF_DECL_FULL("kernel_thread_start,thread_deallocate finder iOS 14",
            LISTIZE({
                0x94000000,     /* bl _kernel_thread_start */
                0x34000000,     /* cbz w0, n */
                0xf900027f,     /* str xzr, [x19] */
                0x528000a0,     /* mov w0, 5 */
                0xa9417bfd,     /* ldp x29, x30, [sp, 0x10] */
            }),
            LISTIZE({
                0xfc000000,     /* ignore immediate */
                0xff00001f,     /* ignore immediate */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            5, XNU_PF_ACCESS_32BIT,
            kernel_thread_start_thread_deallocate_finder_13,
            "com.apple.filesystems.apfs", "__TEXT_EXEC", NULL),
        PF_DECL_FULL("kernel_thread_start,thread_deallocate finder iOS 15",
            LISTIZE({
                0x94000000,     /* bl _kernel_thread_start */
                0x34000000,     /* cbz w0, n */
                0xf900027f,     /* str xzr, [x19] */
                0x528000a0,     /* mov w0, 5 */
                0xa9417bfd,     /* ldp x29, x30, [sp, 0x10] */
            }),
            LISTIZE({
                0xfc000000,     /* ignore immediate */
                0xff00001f,     /* ignore immediate */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            5, XNU_PF_ACCESS_32BIT,
            kernel_thread_start_thread_deallocate_finder_13,
            "com.apple.filesystems.apfs", "__TEXT_EXEC", NULL),
    },
    {
        PF_DECL32("mach_make_memory_entry_64 finder iOS 13",
            LISTIZE({
                0x7218107f,     /* tst w3, 0x1f00 */
                0x54000000,     /* b.eq n */
                0x52800240,     /* mov w0, 0x12 */
                0xd65f03c0,     /* ret */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xff00001f,     /* ignore immediate */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            4, mach_make_memory_entry_64_finder_13, "__TEXT_EXEC"),
        PF_DECL32("mach_make_memory_entry_64 finder iOS 14",
            LISTIZE({
                0x7218107f,     /* tst w3, 0x1f00 */
                0x54000000,     /* b.eq n */
                0x52800240,     /* mov w0, 0x12 */
                0xd65f03c0,     /* ret */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xff00001f,     /* ignore immediate */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            4, mach_make_memory_entry_64_finder_13, "__TEXT_EXEC"),
        PF_DECL32("mach_make_memory_entry_64 finder iOS 15",
            LISTIZE({
                0x7218107f,     /* tst w3, 0x1f00 */
                0x54000000,     /* b.eq n */
                0x52800240,     /* mov w0, 0x12 */
                0xd65f03c0,     /* ret */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xff00001f,     /* ignore immediate */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            4, mach_make_memory_entry_64_finder_13, "__TEXT_EXEC"),
    },
    {
        PF_DECL32("offsetof(struct thread, map) finder iOS 13",
            LISTIZE({
                0xd538d088,     /* mrs x8, tpidr_el1 */
                0xf9400100,     /* ldr Xn, [x8, n] */
                0xf9400020,     /* ldr Xn, [x1] */
                0xa9007fe0,     /* stp Xn, xzr, [sp, n] */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffc003e0,     /* ignore Rt and immediate */
                0xffffffe0,     /* ignore Rt */
                0xffc07fe0,     /* ignore Rt and immediate */
            }),
            4, offsetof_struct_thread_map_finder_13, "__TEXT_EXEC"),
        PF_DECL32("offsetof(struct thread, map) finder iOS 14",
            LISTIZE({
                0xd538d088,     /* mrs x8, tpidr_el1 */
                0xf9400100,     /* ldr Xn, [x8, n] */
                0xf9400020,     /* ldr Xn, [x1] */
                0xa9007fe0,     /* stp Xn, xzr, [sp, n] */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffc003e0,     /* ignore Rt and immediate */
                0xffffffe0,     /* ignore Rt */
                0xffc07fe0,     /* ignore Rt and immediate */
            }),
            4, offsetof_struct_thread_map_finder_13, "__TEXT_EXEC"),
        PF_DECL32("offsetof(struct thread, map) finder iOS 15",
            LISTIZE({
                0xd538d088,     /* mrs x8, tpidr_el1 */
                0xf9400100,     /* ldr x0, [x8, n] */
                0xaa1503e1,     /* mov x1, x21 */
                0xaa1703e2,     /* mov x2, x23 */
                0xaa1403e3,     /* mov x3, x20 */
                0x52800004,     /* mov w4, #0 */
                0x94000000,     /* bl n */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffc003ff,     /* ignore immediate */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xfc000000,     /* ignore immediate */
            }),
            7, offsetof_struct_thread_map_finder_13, "__TEXT_EXEC"),
    },
    {
        PF_DECL32("proc stuff finder 0 iOS 13",
            LISTIZE({
                0x910043fd,     /* add x29, sp, 0x10 */
                0x94000000,     /* bl _current_proc */
                0xaa0003f3,     /* mov x19, x0 */
                0x94000000,     /* bl _proc_list_lock */
                0xaa1303e0,     /* mov x0, x19 */
                0x94000000,     /* bl _proc_ref_locked */
                0x0,            /* ignore this instruction */
                0x9a9f0273,     /* csel x19, x19, xzr, eq */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xfc000000,     /* ignore immediate */
                0xffffffff,     /* match exactly */
                0xfc000000,     /* ignore immediate */
                0xffffffff,     /* match exactly */
                0xfc000000,     /* ignore immediate */
                0x0,            /* ignore this instruction */
                0xffffffff,     /* match exactly */
            }),
            8, proc_stuff0_finder_13, "__TEXT_EXEC"),
        PF_DECL32("proc stuff finder 0 iOS 14",
            LISTIZE({
                0x910043fd,     /* add x29, sp, 0x10 */
                0x94000000,     /* bl _current_proc */
                0xaa0003f3,     /* mov x19, x0 */
                0x94000000,     /* bl _proc_list_lock */
                0xaa1303e0,     /* mov x0, x19 */
                0x94000000,     /* bl _proc_ref_locked */
                0x0,            /* ignore this instruction */
                0x9a9f0273,     /* csel x19, x19, xzr, eq */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xfc000000,     /* ignore immediate */
                0xffffffff,     /* match exactly */
                0xfc000000,     /* ignore immediate */
                0xffffffff,     /* match exactly */
                0xfc000000,     /* ignore immediate */
                0x0,            /* ignore this instruction */
                0xffffffff,     /* match exactly */
            }),
            8, proc_stuff0_finder_13, "__TEXT_EXEC"),
        PF_UNUSED, /* _proc_self inlines almost all calls on iOS 15 */
    },
    {
        PF_UNUSED,
        PF_UNUSED,
        PF_DECL32("current_proc finder iOS 15",
            LISTIZE({
                0x39402a88,     /* ldrb w8, [x20, #0xa] */
                0x35000008,     /* cbnz w8, n */
                0x94000000,     /* bl current_proc */
                0xf9000e80,     /* str x0, [x20, #0x18] */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffc0001f,     /* ignore signed offset */
                0xfc000000,     /* ignore immediate */
                0xffffffff,     /* match exactly */
            }),
            4, current_proc_finder_15, "__TEXT_EXEC"),
    },
    {
        PF_DECL_FULL("proc stuff finder 1 iOS 13",
            LISTIZE({
                0xf81f82a0,     /* stur x0, [x21, -0x8] */
                0xf81e82bf,     /* stur xzr, [x21, -0x18] */
                0xb81f02bf,     /* stur wzr, [x21, -0x10] */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            3, XNU_PF_ACCESS_32BIT,
            proc_stuff1_finder_13, "com.apple.security.sandbox",
            "__TEXT_EXEC", NULL),
        PF_DECL_FULL("proc stuff finder 1 iOS 14",
            LISTIZE({
                0xf81f82a0,     /* stur x0, [x21, -0x8] */
                0xf81e82bf,     /* stur xzr, [x21, -0x18] */
                0xb81f02bf,     /* stur wzr, [x21, -0x10] */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            3, XNU_PF_ACCESS_32BIT,
            proc_stuff1_finder_13, "com.apple.security.sandbox",
            "__TEXT_EXEC", NULL),
        PF_DECL_FULL("proc stuff finder 1 iOS 15",
            LISTIZE({
                0xf81f82a0,     /* stur x0, [x21, -0x8] */
                0xf81e82bf,     /* stur xzr, [x21, -0x18] */
                0xb81f02bf,     /* stur wzr, [x21, -0x10] */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            3, XNU_PF_ACCESS_32BIT,
            proc_stuff1_finder_13, "com.apple.security.sandbox",
            "__TEXT_EXEC", NULL),
    },
    {
        PF_UNUSED,
        PF_UNUSED,
        PF_DECL32("proc_list_mlock,lck_mtx_lock,lck_mtx_unlock finder iOS 15",
            LISTIZE({
                0x10000000,     /* adrp Xd, n or adr Xd, n */
                0x0,            /* ignore this instruction */
                0xaa0003e0,     /* mov x0, Xn */
                0x94000000,     /* bl _lck_mtx_lock */
                0xb9400008,     /* ldr w8, [Xn, n] */
                0x32150108,     /* orr w8, w8, #0x800 */
                0xb9000008,     /* str w8, [Xn, n] */
                0xaa0003e0,     /* mov x0, Xn */
            }),
            LISTIZE({
                0x1f000000,     /* ignore immediate, ignore Rd */
                0x0,            /* ignore this instruction */
                0xffe0ffff,     /* ignore Rn */
                0xfc000000,     /* ignore immediate */
                0xffc0001f,     /* ignore Rn & immediate */
                0xffffffff,     /* match exactly */
                0xffc0001f,     /* ignore Rn & immediate */
                0xffe0ffff,     /* ignore Rn */
            }),
            8, proc_list_mlock_lck_mtx_lock_unlock_finder_15, "__TEXT_EXEC"),
    },
    {
        PF_DECL32("allproc finder iOS 13",
            LISTIZE({
                0xf900427f,     /* str xzr, [x19, 0x80] */
                0xf9000293,     /* str x19, [x20] */
                0xf9004674,     /* str x20, [x19, 0x88] */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            3, allproc_finder_13, "__TEXT_EXEC"),
        PF_DECL32("allproc finder iOS 13",
            LISTIZE({
                0xf900427f,     /* str xzr, [x19, 0x80] */
                0xf9000293,     /* str x19, [x20] */
                0xf9004674,     /* str x20, [x19, 0x88] */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            3, allproc_finder_13, "__TEXT_EXEC"),
        PF_DECL32("allproc finder iOS 15",
            LISTIZE({
                0xf900427f,     /* str xzr, [x19, 0x80] */
                0xf9000293,     /* str x19, [x20] */
                0xf9004674,     /* str x20, [x19, 0x88] */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            3, allproc_finder_13, "__TEXT_EXEC"),
    },
    {
        PF_DECL32("misc. lock stuff finder iOS 13",
            LISTIZE({
                0xaa0003f3,     /* mov x19, x0 */
                0xf9400c08,     /* ldr x8, [x0, #0x18] */
                0xf9400d14,     /* ldr x20, [x8, #0x18] */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            3, misc_lck_stuff_finder_13, "__TEXT_EXEC"),
        PF_DECL32("misc. lock stuff finder iOS 14",
            LISTIZE({
                0xaa0003f3,     /* mov x19, x0 */
                0xf9400c08,     /* ldr x8, [x0, #0x18] */
                0xf9400d14,     /* ldr x20, [x8, #0x18] */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            3, misc_lck_stuff_finder_13, "__TEXT_EXEC"),
        PF_DECL32("misc. lock stuff finder iOS 15",
            LISTIZE({
                0xf9400c08,     /* ldr x8, [x0, #0x18] */
                0xf9400909,     /* ldr x9, [x8, #0x10] */
                0xb9400129,     /* ldr w9, [x9] */
                0x7100793f,     /* cmp w9, #0x1e */
                0x7a421924,     /* ccmp w9, #2, #4, ne */
                0x0,            /* ignore this instruction */
                0xaa0003f3,     /* mov x19, x0 */
                0xf9400d14,     /* ldr x20, [x8, #0x18] */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0x0,            /* ignore this instruction */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            8, misc_lck_stuff_finder_13, "__TEXT_EXEC"),
    },
    {
        PF_DECL32("vm_map_wire_external finder iOS 13",
            LISTIZE({
                0x910003fd,     /* add x29, sp, n */
                0xaa0403f3,     /* mov x19, x4 */
                0xaa0303f4,     /* mov x20, x3 */
                0xaa0203f5,     /* mov x21, x2 */
                0xaa0103f6,     /* mov x22, x1 */
                0xaa0003f7,     /* mov x23, x0 */
                0x94000000,     /* bl n */
            }),
            LISTIZE({
                0xffc003ff,     /* ignore immediate */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xfc000000,     /* ignore immediate */
            }),
            7, vm_map_wire_external_finder_13, "__TEXT_EXEC"),
        PF_DECL32("vm_map_wire_external finder iOS 14",
            LISTIZE({
                0x910003fd,     /* add x29, sp, n */
                0xaa0403f3,     /* mov x19, x4 */
                0xaa0303f4,     /* mov x20, x3 */
                0xaa0203f5,     /* mov x21, x2 */
                0xaa0103f6,     /* mov x22, x1 */
                0xaa0003f7,     /* mov x23, x0 */
                0x94000000,     /* bl n */
            }),
            LISTIZE({
                0xffc003ff,     /* ignore immediate */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xfc000000,     /* ignore immediate */
            }),
            7, vm_map_wire_external_finder_13, "__TEXT_EXEC"),
        PF_DECL32("vm_map_wire_external finder iOS 15",
            LISTIZE({
                0x910003fd,     /* add x29, sp, n */
                0xaa0403f3,     /* mov x19, x4 */
                0xaa0303f4,     /* mov x20, x3 */
                0xaa0203f5,     /* mov x21, x2 */
                0xaa0103f6,     /* mov x22, x1 */
                0xaa0003f7,     /* mov x23, x0 */
                0x94000000,     /* bl n */
            }),
            LISTIZE({
                0xffc003ff,     /* ignore immediate */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xfc000000,     /* ignore immediate */
            }),
            7, vm_map_wire_external_finder_13, "__TEXT_EXEC"),
    },
    {
        PF_DECL32("mach_vm_map_external finder iOS 13",
            LISTIZE({
                0x5297e009,     /* mov w9, 0xbf<n>0 */
                0x72a00d09,     /* movk w9, 0x68, lsl 16 */
                0x6a09009f,     /* tst w4, w9 */
            }),
            LISTIZE({
                0xffffe1ff,     /* ignore bits [7:4] of immediate */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            3, mach_vm_map_external_finder_13, "__TEXT_EXEC"),
        PF_DECL32("mach_vm_map_external finder iOS 14",
            LISTIZE({
                0x5297e009,     /* mov w9, 0xbf<n>0 */
                0x72a00d09,     /* movk w9, 0x68, lsl 16 */
                0x6a09009f,     /* tst w4, w9 */
            }),
            LISTIZE({
                0xffffe1ff,     /* ignore bits [7:4] of immediate */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            3, mach_vm_map_external_finder_13, "__TEXT_EXEC"),
        PF_DECL32("mach_vm_map_external finder iOS 15",
            LISTIZE({
                0x5297e009,     /* mov w9, 0xbf<n>0 */
                0x72a00d09,     /* movk w9, 0x68, lsl 16 */
                0x6a09009f,     /* tst w4, w9 */
            }),
            LISTIZE({
                0xffffe1ff,     /* ignore bits [7:4] of immediate */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            3, mach_vm_map_external_finder_13, "__TEXT_EXEC"),
    },
    {
        PF_DECL32("ipc_port_release_send finder iOS 13",
            LISTIZE({
                0xaa1303e0,     /* mov x0, x19 */
                0x94000000,     /* bl _ipc_port_release_send */
                0x14000000,     /* b n */
                0x94000000,     /* bl ___stack_chk_fail */
                0xf90003f8,     /* str x24, [sp] */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xfc000000,     /* ignore immediate */
                0xfc000000,     /* ignore immediate */
                0xfc000000,     /* ignore immediate */
                0xffffffff,     /* match exactly */
            }),
            5, ipc_port_release_send_finder_13, "__TEXT_EXEC"),
        PF_DECL32("io_lock/ipc_port_release_send_and_unlock finder iOS 14",
            LISTIZE({
                0xaa1303e0,     /* mov x0, x19 */
                0x94000000,     /* bl _ipc_port_release_send_and_unlock */
                0x14000000,     /* b n */
                0x94000000,     /* bl ___stack_chk_fail */
                0xf90003f8,     /* str x24, [sp] */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xfc000000,     /* ignore immediate */
                0xfc000000,     /* ignore immediate */
                0xfc000000,     /* ignore immediate */
                0xffffffff,     /* match exactly */
            }),
            5, ipc_port_release_send_finder_13, "__TEXT_EXEC"),
        PF_DECL32("ipc_object_lock/ipc_port_release_send_and_unlock finder iOS 15",
            LISTIZE({
                0x910006e8,     /* add x8, x23, #1 */
                0xf100091f,     /* cmp x8, 2 */
                0x540000a3,     /* b.lo 0x1c */
                0xaa1703e0,     /* mov x0, x23 */
                0x94000000,     /* bl _ipc_object_lock */
                0xaa1703e0,     /* mov x0, x23 */
                0x94000000      /* bl _ipc_port_release_send_and_unlock */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xfc000000,     /* ignore immediate */
                0xffffffff,     /* match exactly */
                0xfc000000,     /* ignore immediate */
            }),
            7, ipc_port_release_send_finder_15, "__TEXT_EXEC"),
    },
    {
        PF_DECL32("lck_rw_free finder iOS 13",
            LISTIZE({
                0x10000008,     /* adrp x8, n or adr x8, n */
                0x0,            /* ignore this instruction */
                0x14000000,     /* b n */
                0xd65f03c0,     /* ret */
                0x10000008,     /* adrp x8, n or adr x8, n */
                0x0,            /* ignore this instruction */
                0xd2800001,     /* mov x1, 0 */
            }),
            LISTIZE({
                0x1f00001f,     /* ignore immediate */
                0x0,            /* ignore this instruction */
                0xfc000000,     /* ignore immediate */
                0xffffffff,     /* match exactly */
                0x1f00001f,     /* ignore immediate */
                0x0,            /* ignore this instruction */
                0xffffffff,     /* match exactly */
            }),
            7, lck_rw_free_finder_13, "__TEXT_EXEC"),
        PF_DECL32("lck_rw_free finder iOS 14",
            LISTIZE({
                0x10000008,     /* adrp x8, n or adr x8, n */
                0x0,            /* ignore this instruction */
                0x14000000,     /* b n */
                0xd65f03c0,     /* ret */
                0x10000008,     /* adrp x8, n or adr x8, n */
                0x0,            /* ignore this instruction */
                0xd2800001,     /* mov x1, 0 */
            }),
            LISTIZE({
                0x1f00001f,     /* ignore immediate */
                0x0,            /* ignore this instruction */
                0xfc000000,     /* ignore immediate */
                0xffffffff,     /* match exactly */
                0x1f00001f,     /* ignore immediate */
                0x0,            /* ignore this instruction */
                0xffffffff,     /* match exactly */
            }),
            7, lck_rw_free_finder_13, "__TEXT_EXEC"),
        PF_DECL32("lck_rw_free finder iOS 15",
            LISTIZE({
                0x10000008,     /* adrp x8, n or adr x8, n */
                0x0,            /* ignore this instruction */
                0x14000000,     /* b n */
                0xd65f03c0,     /* ret */
                0x10000008,     /* adrp x8, n or adr x8, n */
                0x0,            /* ignore this instruction */
                0xd2800001,     /* mov x1, 0 */
            }),
            LISTIZE({
                0x1f00001f,     /* ignore immediate */
                0x0,            /* ignore this instruction */
                0xfc000000,     /* ignore immediate */
                0xffffffff,     /* match exactly */
                0x1f00001f,     /* ignore immediate */
                0x0,            /* ignore this instruction */
                0xffffffff,     /* match exactly */
            }),
            7, lck_rw_free_finder_13, "__TEXT_EXEC"),
    },
    {
        PF_DECL32("lck_grp_free finder iOS 13",
            LISTIZE({
                0x94000000,     /* bl n */
                0x0,            /* ignore this instruction. It is either
                                   mov w22, 0xc or orr w22, wzr, 0xc */
                0x14000000,     /* b n */
                0x0,            /* ignore this instruction. It is either
                                   mov w22, 0xc or orr w22, wzr, 0xc */
                0xaa1403e0,     /* mov x0, x20 */
                0x94000000,     /* bl _lck_grp_free */
                0x10000014,     /* adrp x20, n or adr x20, n */
            }),
            LISTIZE({
                0xfc000000,     /* ignore immediate */
                0x0,            /* ignore this instruction */
                0xfc000000,     /* ignore immediate */
                0x0,            /* ignore this instruction */
                0xffffffff,     /* ignore immediate */
                0xfc000000,     /* ignore immediate */
                0x1f00001f,     /* ignore immediate */
            }),
            7, lck_grp_free_finder_13, "__TEXT_EXEC"),
        PF_DECL32("lck_grp_free finder iOS 14",
            LISTIZE({
                0x94000000,     /* bl n */
                0x0,            /* ignore this instruction. It is either
                                   mov w22, 0xc or orr w22, wzr, 0xc */
                0x14000000,     /* b n */
                0x0,            /* ignore this instruction. It is either
                                   mov w22, 0xc or orr w22, wzr, 0xc */
                0xaa1403e0,     /* mov x0, x20 */
                0x94000000,     /* bl _lck_grp_free */
                0xa94006e0,     /* ldp x0, x1, [x23] */
            }),
            LISTIZE({
                0xfc000000,     /* ignore immediate */
                0x0,            /* ignore this instruction */
                0xfc000000,     /* ignore immediate */
                0x0,            /* ignore this instruction */
                0xffffffff,     /* ignore immediate */
                0xfc000000,     /* ignore immediate */
                0xffffffff,     /* match exactly */
            }),
            7, lck_grp_free_finder_13, "__TEXT_EXEC"),
        PF_DECL_FULL("lck_grp_free finder iOS 15",
            LISTIZE({
                0xf9400000,     /* ldr x0, [Xn, n] */
                0x94000000,     /* bl n */
                0xf9400000,     /* ldr x0, [Xn, n] */
                0x94000000,     /* bl n */
                0xf9400000,     /* ldr x0, [Xn, n] */
                0x94000000,     /* bl n */
                0xd2800000,     /* mov x0, #0 */
                0x94000000,     /* bl n */
            }),
            LISTIZE({
                0xffc0001f,     /* ignore Rn & immediate */
                0xfc000000,     /* ignore immediate */
                0xffc0001f,     /* ignore Rn & immediate */
                0xfc000000,     /* ignore immediate */
                0xffc0001f,     /* ignore Rn & immediate */
                0xfc000000,     /* ignore immediate */
                0xffffffff,     /* match exactly */
                0xfc000000,     /* ignore this instruction */
            }),
            8, XNU_PF_ACCESS_32BIT, lck_grp_free_finder_15,
            "com.apple.filesystems.lifs", "__TEXT_EXEC", NULL),
    },
    {
        PF_DECL32("doprnt_hide_pointers patcher iOS 13",
            LISTIZE({
                0x93407c00,     /* sxtw Xn, Wn */
                0x710001df,     /* cmp w14, 0 */
                0x9a800000,     /* csel Xn, Xn, Xn, eq */
            }),
            LISTIZE({
                0xfffffc00,     /* ignore Rn and Rd */
                0xffffffff,     /* match exactly */
                0xffe0fc00,     /* ignore Rm, Rn, and Rd */
            }),
            3, doprnt_hide_pointers_patcher_13, "__TEXT_EXEC"),
        PF_DECL32("doprnt_hide_pointers patcher iOS 14",
            LISTIZE({
                0x93407c00,     /* sxtw Xn, Wn */
                0x710001df,     /* cmp w14, 0 */
                0x9a800000,     /* csel Xn, Xn, Xn, eq */
            }),
            LISTIZE({
                0xfffffc00,     /* ignore Rn and Rd */
                0xffffffff,     /* match exactly */
                0xffe0fc00,     /* ignore Rm, Rn, and Rd */
            }),
            3, doprnt_hide_pointers_patcher_13, "__TEXT_EXEC"),
        PF_DECL32("doprnt_hide_pointers patcher iOS 15",
            LISTIZE({
                0x93407c00,     /* sxtw Xn, Wn */
                0x7100001f,     /* cmp Wn, 0 */
                0x9a800000,     /* csel Xn, Xn, Xn, eq */
            }),
            LISTIZE({
                0xfffffc00,     /* ignore Rn and Rd */
                0x7fbffc1f,     /* ignore Rn and sf */
                0xffe0fc00,     /* ignore Rm, Rn, and Rd */
            }),
            3, doprnt_hide_pointers_patcher_13, "__TEXT_EXEC"),
    },
    {
        PF_DECL32("copyinstr finder iOS 13",
            LISTIZE({
                0xf90007ff,     /* str xzr, [sp, 8] */
                0xf900007f,     /* str xzr, [x3] */
                0xb4000002,     /* cbz x2, n */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xff00001f,     /* ignore immediate */
            }),
            3, copyinstr_finder_13, "__TEXT_EXEC"),
        PF_DECL32("copyinstr finder iOS 14",
            LISTIZE({
                0xf90007ff,     /* str xzr, [sp, 8] */
                0xf900007f,     /* str xzr, [x3] */
                0xb4000002,     /* cbz x2, n */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xff00001f,     /* ignore immediate */
            }),
            3, copyinstr_finder_13, "__TEXT_EXEC"),
        PF_DECL32("copyinstr finder iOS 15",
            LISTIZE({
                0xf90007ff,     /* str xzr, [sp, 8] */
                0xf900007f,     /* str xzr, [x3] */
                0xb4000002,     /* cbz x2, n */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xff00001f,     /* ignore immediate */
            }),
            3, copyinstr_finder_13, "__TEXT_EXEC"),
    },
    {
        PF_DECL32("thread_terminate finder iOS 13",
            LISTIZE({
                0xaa1503e0,     /* mov x0, x21 */
                0xaa1603e1,     /* mov x1, x22 */
                0xd63f0280,     /* blr x20 */
                0xd538d080,     /* mrs x0, tpidr_el1 */
                0x14000000,     /* b n */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xfc000000,     /* ignore immediate */
            }),
            5, thread_terminate_finder_13, "__TEXT_EXEC"),
        PF_DECL32("thread_terminate finder iOS 14",
            LISTIZE({
                0xaa1503e0,     /* mov x0, x21 */
                0xaa1603e1,     /* mov x1, x22 */
                0xd63f0280,     /* blr x20 */
                0xd538d080,     /* mrs x0, tpidr_el1 */
                0x14000000,     /* b n */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xfc000000,     /* ignore immediate */
            }),
            5, thread_terminate_finder_13, "__TEXT_EXEC"),
        PF_DECL32("thread_terminate finder iOS 15",
            LISTIZE({
                0xaa1503e0,     /* mov x0, x21 */
                0xaa1603e1,     /* mov x1, x22 */
                0xd63f0280,     /* blr x20 */
                0xd538d080,     /* mrs x0, tpidr_el1 */
                0x14000000,     /* b n */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xfc000000,     /* ignore immediate */
            }),
            5, thread_terminate_finder_13, "__TEXT_EXEC"),
    },
    {
        PF_DECL32("pinst_set_tcr patcher iOS 13",
            LISTIZE({
                0xd2facbe2,     /* movz x2, 0xd65f, lsl 48 */
                0xf2c07802,     /* movk x2, 0x03c0, lsl 32 */
                0xf2baa302,     /* movk x2, 0xd518, lsl 16 */
                0xf2840802,     /* movk x2, 0x2040 */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            4, pinst_set_tcr_patcher_13, "__TEXT_EXEC"),
        PF_DECL32("pinst_set_tcr patcher iOS 14",
            LISTIZE({
                0xd2facbe2,     /* movz x2, 0xd65f, lsl 48 */
                0xf2c07802,     /* movk x2, 0x03c0, lsl 32 */
                0xf2baa302,     /* movk x2, 0xd518, lsl 16 */
                0xf2840802,     /* movk x2, 0x2040 */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            4, pinst_set_tcr_patcher_13, "__TEXT_EXEC"),
        PF_DECL32("pinst_set_tcr patcher iOS 15",
            LISTIZE({
                0xd2facbe2,     /* movz x2, 0xd65f, lsl 48 */
                0xf2c07802,     /* movk x2, 0x03c0, lsl 32 */
                0xf2baa302,     /* movk x2, 0xd518, lsl 16 */
                0xf2840802,     /* movk x2, 0x2040 */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            4, pinst_set_tcr_patcher_13, "__TEXT_EXEC"),
    },
    {
        PF_DECL32("msr tcr_el1, x18 patcher iOS 13",
            LISTIZE({
                0xd5182052,     /* msr tcr_el1, x18 */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
            }),
            1, msr_tcr_el1_x18_patcher_13, "__TEXT_EXEC"),
        PF_DECL32("msr tcr_el1, x18 patcher iOS 14",
            LISTIZE({
                0xd5182052,     /* msr tcr_el1, x18 */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
            }),
            1, msr_tcr_el1_x18_patcher_13, "__TEXT_EXEC"),
        PF_DECL32("msr tcr_el1, x18 patcher iOS 15",
            LISTIZE({
                0xd5182052,     /* msr tcr_el1, x18 */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
            }),
            1, msr_tcr_el1_x18_patcher_13, "__TEXT_EXEC"),
    },
    {
        PF_DECL32("proc_name,snprintf,strlen finder iOS 13",
            LISTIZE({
                0x94000000,     /* bl n */
                0x8b000001,     /* add x1, xn, x0 */
                0x4b000002,     /* sub w2, wn, w0 */
                0x0,            /* ignore this instruction */
                0x94000000,     /* bl n */
                0x0,            /* ignore this instruction */
                0x0,            /* ignore this instruction */
                0xb4000000,     /* cbz x0, n */
            }),
            LISTIZE({
                0xfc000000,     /* ignore immediate */
                0xfffffc1f,     /* ignore Rn */
                0xfffffc1f,     /* ignore Rn */
                0x0,            /* ignore this instruction */
                0xfc000000,     /* ignore immediate */
                0x0,            /* ignore this instruction */
                0x0,            /* ignore this instruction */
                0xff00001f,     /* ignore immediate */
            }),
            8, proc_name_snprintf_strlen_finder_13, "__TEXT_EXEC"),
        PF_DECL32("proc_name,snprintf,strlen finder iOS 14",
            LISTIZE({
                0x94000000,     /* bl n */
                0x8b000001,     /* add x1, xn, x0 */
                0x4b000002,     /* sub w2, wn, w0 */
                0x0,            /* ignore this instruction */
                0x94000000,     /* bl n */
                0x10000000,     /* adrp x0, n or adr x0, n */
            }),
            LISTIZE({
                0xfc000000,     /* ignore immediate */
                0xfffffc1f,     /* ignore Rn */
                0xfffffc1f,     /* ignore Rn */
                0x0,            /* ignore this instruction */
                0xfc000000,     /* ignore immediate */
                0x1f00001f,     /* ignore immediate */
            }),
            6, proc_name_snprintf_strlen_finder_13, "__TEXT_EXEC"),
        PF_DECL_FULL("proc_name,snprintf,strlen finder iOS 15",
            LISTIZE({
                0x910003e0,     /* add x0, sp, n */
                0x52800001,     /* mov w1, n */
                0x94000000,     /* bl n */
                0x910003e0,     /* add x0, sp, n */
                0x94000000,     /* bl n */
                0x8b000001,     /* add x1, Xn, Xn */
                0x4b000002,     /* sub w2, Wn, Wn */
                0xaa0003e0,     /* mov x0, Xn */
            }),
            LISTIZE({
                0xff8003ff,     /* ignore immediate */
                0xff80001f,     /* ignore immediate */
                0xfc000000,     /* ignore imemdiate */
                0xff8003ff,     /* ignore immediate */
                0xfc000000,     /* ignore immediate */
                0xffe0fc1f,     /* ignore Rn & Rd */
                0xffe0fc1f,     /* ignore Rn & Rd */
                0xffe0ffff,     /* ignore Rn */
            }),
            8, XNU_PF_ACCESS_32BIT, proc_name_snprintf_strlen_finder_15,
            "com.apple.driver.AppleEmbeddedUSBHost", "__TEXT_EXEC", NULL),
    },
    {
        PF_DECL32("strcmp finder iOS 13",
            LISTIZE({
                0xa9bf7bfd,     /* stp x29, x30, [sp, -0x10]! */
                0x910003fd,     /* mov x29, sp */
                0xca030063,     /* eor x3, x3, x3 */
                0xb4000002,     /* cbz x2, n */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xff00001f,     /* ignore immediate */
            }),
            4, strncmp_finder_13, "__TEXT_EXEC"),
        PF_DECL32("strcmp finder iOS 13",
            LISTIZE({
                0xa9bf7bfd,     /* stp x29, x30, [sp, -0x10]! */
                0x910003fd,     /* mov x29, sp */
                0xca030063,     /* eor x3, x3, x3 */
                0xb4000002,     /* cbz x2, n */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xff00001f,     /* ignore immediate */
            }),
            4, strncmp_finder_13, "__TEXT_EXEC"),
        PF_DECL32("strcmp finder iOS 15",
            LISTIZE({
                0xa9bf7bfd,     /* stp x29, x30, [sp, -0x10]! */
                0x910003fd,     /* mov x29, sp */
                0xca030063,     /* eor x3, x3, x3 */
                0xb4000002,     /* cbz x2, n */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xff00001f,     /* ignore immediate */
            }),
            4, strncmp_finder_13, "__TEXT_EXEC"),
    },
    {
        PF_DECL32("memset finder iOS 13",
            LISTIZE({
                0x92401c21,     /* and x1, x1, 0xff */
                0xb200c3e3,     /* mov x3, 0x101010101010101 */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            2, memset_finder_13, "__TEXT_EXEC"),
        PF_DECL32("memset finder iOS 14",
            LISTIZE({
                0x92401c21,     /* and x1, x1, 0xff */
                0xb200c3e3,     /* mov x3, 0x101010101010101 */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            2, memset_finder_13, "__TEXT_EXEC"),
        PF_DECL32("memset finder iOS 15",
            LISTIZE({
                0x92401c21,     /* and x1, x1, 0xff */
                0xb200c3e3,     /* mov x3, 0x101010101010101 */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            2, memset_finder_13, "__TEXT_EXEC"),
    },
    {
        PF_DECL32("memmove finder iOS 13",
            LISTIZE({
                0xcb010003,     /* sub x3, x0, x1 */
                0xeb02007f,     /* cmp x3, x2 */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            2, memmove_finder_13, "__TEXT_EXEC"),
        PF_DECL32("memmove finder iOS 14",
            LISTIZE({
                0xcb010003,     /* sub x3, x0, x1 */
                0xeb02007f,     /* cmp x3, x2 */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            2, memmove_finder_13, "__TEXT_EXEC"),
        PF_DECL32("memmove finder iOS 15",
            LISTIZE({
                0xcb010003,     /* sub x3, x0, x1 */
                0xeb02007f,     /* cmp x3, x2 */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            2, memmove_finder_13, "__TEXT_EXEC"),
    },
    {
        PF_DECL32("panic finder iOS 13",
            LISTIZE({
                0x910023e1,     /* add x1, sp, #8 */
                0x52800002,     /* mov w2, #0 */
                0xd2800003,     /* mov x3, #0 */
                0xd2800004,     /* mov x4, #0 */
                0xd2800005,     /* mov x5, #0 */
                0xaa1e03e6      /* mov x6, x30 */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            6, panic_finder_13, "__TEXT_EXEC"),
        PF_DECL32("panic finder iOS 14",
            LISTIZE({
                0x910023e1,     /* add x1, sp, #8 */
                0x52800002,     /* mov w2, #0 */
                0xd2800003,     /* mov x3, #0 */
                0xd2800004,     /* mov x4, #0 */
                0xd2800005,     /* mov x5, #0 */
                0xaa1e03e6      /* mov x6, x30 */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            6, panic_finder_13, "__TEXT_EXEC"),
        PF_DECL32("panic finder iOS 15",
            LISTIZE({
                0x910023e1,     /* add x1, sp, #8 */
                0x52800002,     /* mov w2, #0 */
                0xd2800003,     /* mov x3, #0 */
                0xd2800004,     /* mov x4, #0 */
                0xd2800005,     /* mov x5, #0 */
                0xaa1e03e6      /* mov x6, x30 */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            6, panic_finder_13, "__TEXT_EXEC"),
    },
    {
        PF_DECL32("mach_bsd_to_errno finder iOS 13",
            LISTIZE({
                0x7100cc1f,     /* cmp w0, #0x33 */
                0x54000008,     /* b.hi n */
                0x10000008,     /* adrp x8, n or adr x8, n */
                0x0,            /* ignore this instruction */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xff00001f,     /* ignore immediate */
                0x1f00001f,     /* ignore immediate */
                0x0,            /* ignore this instruction */
            }),
            4, mach_to_bsd_errno_finder_13, "__TEXT_EXEC"),
        PF_DECL32("mach_bsd_to_errno finder iOS 14",
            LISTIZE({
                0x7100cc1f,     /* cmp w0, #0x33 */
                0x54000008,     /* b.hi n */
                0x10000008,     /* adrp x8, n or adr x8, n */
                0x0,            /* ignore this instruction */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xff00001f,     /* ignore immediate */
                0x1f00001f,     /* ignore immediate */
                0x0,            /* ignore this instruction */
            }),
            4, mach_to_bsd_errno_finder_13, "__TEXT_EXEC"),
        PF_DECL32("mach_bsd_to_errno finder iOS 15",
            LISTIZE({
                0x7100e01f,     /* cmp w0, #0x38 */
                0x54000008,     /* b.hi n */
                0x10000008,     /* adrp x8, n or adr x8, n */
                0x0,            /* ignore this instruction */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xff00001f,     /* ignore immediate */
                0x1f00001f,     /* ignore immediate */
                0x0,            /* ignore this instruction */
            }),
            4, mach_to_bsd_errno_finder_13, "__TEXT_EXEC"),
    },
    {
        PF_DECL32("vm_allocate_external finder iOS 13",
            LISTIZE({
                0x53187C64,     /* lsr w4, w3, #0x18 */
                0x14000000,     /* b n */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xfc000000,     /* ignore immediate */
            }),
            2, vm_allocate_external_finder_13, "__TEXT_EXEC"),
        PF_DECL32("vm_allocate_external finder iOS 14",
            LISTIZE({
                0x53187C64,     /* lsr w4, w3, #0x18 */
                0x14000000,     /* b n */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xfc000000,     /* ignore immediate */
            }),
            2, vm_allocate_external_finder_13, "__TEXT_EXEC"),
        PF_DECL32("vm_allocate_external finder iOS 15",
            LISTIZE({
                0x53187C64,     /* lsr w4, w3, #0x18 */
                0x14000000,     /* b n */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xfc000000,     /* ignore immediate */
            }),
            2, vm_allocate_external_finder_13, "__TEXT_EXEC"),
    },
    {
        PF_DECL32("vm_map_deallocate, offsetof(vm_map_t, refcnt) finder iOS 13",
            LISTIZE({
                0xb4000000,     /* cbz x0, n */
                0x94000000,     /* bl n */
                0xf900027f,     /* str xzr, [x19, n] */
                0xf900027f,     /* str xzr, [x19, n] */
                0xf900027f,     /* str xzr, [x19, n] */
            }),
            LISTIZE({
                0xfc000000,     /* ignore immediate */
                0xfc000000,     /* ignore immediate */
                0xffc003ff,     /* ignore immediate */
                0xffc003ff,     /* ignore immediate */
                0xffc003ff,     /* ignore immediate */
            }),
            5, vm_map_deallocate_offsetof_vm_map_refcnt_finder_13,
            "__TEXT_EXEC"),
        PF_DECL32("vm_map_deallocate, offsetof(vm_map_t, refcnt) finder iOS 14",
            LISTIZE({
                0xb4000000,     /* cbz x0, n */
                0x94000000,     /* bl n */
                0xf900027f,     /* str xzr, [x19, n] */
                0xf900027f,     /* str xzr, [x19, n] */
                0xf900027f,     /* str xzr, [x19, n] */
            }),
            LISTIZE({
                0xfc000000,     /* ignore immediate */
                0xfc000000,     /* ignore immediate */
                0xffc003ff,     /* ignore immediate */
                0xffc003ff,     /* ignore immediate */
                0xffc003ff,     /* ignore immediate */
            }),
            5, vm_map_deallocate_offsetof_vm_map_refcnt_finder_13,
            "__TEXT_EXEC"),
        PF_DECL32("vm_map_deallocate, offsetof(vm_map_t, refcnt) finder iOS 15",
            LISTIZE({
                0xb4000000,     /* cbz x0, n */
                0x94000000,     /* bl n */
                0xf900027f,     /* str xzr, [x19, n] */
                0xf900027f,     /* str xzr, [x19, n] */
                0xf900027f,     /* str xzr, [x19, n] */
            }),
            LISTIZE({
                0xfc000000,     /* ignore immediate */
                0xfc000000,     /* ignore immediate */
                0xffc003ff,     /* ignore immediate */
                0xffc003ff,     /* ignore immediate */
                0xffc003ff,     /* ignore immediate */
            }),
            5, vm_map_deallocate_offsetof_vm_map_refcnt_finder_13,
            "__TEXT_EXEC"),
    },
    {
        PF_DECL32("IOLog finder iOS 13",
            LISTIZE({
                0xa9016fe0,     /* stp x0, x27, [sp, #0x10] */
                0xa90067f8,     /* stp x24, x25, [sp] */
                0xaa1603e0,     /* mov x0, x22 */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            3, IOLog_finder_13, "__TEXT_EXEC"),
        PF_DECL32("IOLog finder iOS 14",
            LISTIZE({
                0xa9016fe0,     /* stp x0, x27, [sp, #0x10] */
                0xa90067f8,     /* stp x24, x25, [sp] */
                0xaa1603e0,     /* mov x0, x22 */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            3, IOLog_finder_13, "__TEXT_EXEC"),
        PF_DECL32("IOLog finder iOS 15",
            LISTIZE({
                0xa90173e0,     /* stp x0, x28, [sp, #0x10] */
                0xa90067f8,     /* stp x24, x25, [sp] */
                0xaa1603e0,     /* mov x0, x22 */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            3, IOLog_finder_13, "__TEXT_EXEC"),
    },
    {
        PF_UNUSED,
        PF_UNUSED,
        PF_DECL32("proc_ref,proc_rele finder iOS 15",
            LISTIZE({
                0xaa1903f8,     /* mov x24, x25 */
                0xaa1803e0,     /* mov x0, x24 */
                0x52800021,     /* mov w1, #1 */
            }),
            LISTIZE({
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
                0xffffffff,     /* match exactly */
            }),
            3, proc_ref_rele_finder_15, "__TEXT_EXEC"),
    },
    {
        PF_DECL_FULL("lck_mtx_lock finder iOS 13",
            LISTIZE({
                0xf90003f4,     /* str x20, [sp, n] */
                0x93407e9b,     /* sxtw x27, x20 */
            }),
            LISTIZE({
                0xffc003ff,     /* ignore immediate */
                0xffffffff,     /* match exactly */
            }),
            2, XNU_PF_ACCESS_32BIT, lck_mtx_lock_finder_13,
            "com.apple.filesystems.apfs", "__TEXT_EXEC", NULL),
        PF_DECL_FULL("lck_mtx_lock finder iOS 14",
            LISTIZE({
                0xf90003f4,     /* str x20, [sp, n] */
                0x93407e9b,     /* sxtw x27, x20 */
            }),
            LISTIZE({
                0xffc003ff,     /* ignore immediate */
                0xffffffff,     /* match exactly */
            }),
            2, XNU_PF_ACCESS_32BIT, lck_mtx_lock_finder_13,
            "com.apple.filesystems.apfs", "__TEXT_EXEC", NULL),
        PF_UNUSED,
    },
    { PF_END, PF_END, PF_END },
};

#endif

```

`include/pongo.h`:

```h
/* 
 * pongoOS - https://checkra.in
 * 
 * Copyright (C) 2019-2020 checkra1n team
 *
 * This file is part of pongoOS.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
 */
#ifndef PONGOH
#define PONGOH
#include <mach-o/loader.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <strings.h>
/* #include <kerninfo.h> */

#ifdef PONGO_PRIVATE
#include "framebuffer/fb.h"
#include "usb/usb.h"
#include "uart/uart.h"
#include "gpio/gpio.h"
#include "timer/timer.h"
#include "xnu/xnu.h"
#include "tz/tz.h"
#include "libDER/DER_Encode.h"
#include "libDER/DER_Decode.h"
#include "libDER/asn1Types.h"
#include "libDER/oids.h"
#include "img4/img4.h"
#include "mipi/mipi.h"
#include "aes/aes.h"
#endif

#define DT_KEY_LEN 0x20

extern int service_cmd(const char* name, int cmd_id, void* data_in, size_t in_size, void* data_out, size_t* out_size);

#define kSerialService "serial"
// these are for consumers
#define kSerialRXDequeue 1
#define kSerialTXQueue 2
// these are for providers
#define kSerialRXQueue 3
#define kSerialTXDequeue 4

struct Boot_Video {
	unsigned long	v_baseAddr;	/* Base address of video memory */
	unsigned long	v_display;	/* Display Code (if Applicable */
	unsigned long	v_rowBytes;	/* Number of bytes per pixel row */
	unsigned long	v_width;	/* Width */
	unsigned long	v_height;	/* Height */
	unsigned long	v_depth;	/* Pixel Depth and other parameters */
};
typedef struct boot_args {
	uint16_t		Revision;			/* Revision of boot_args structure */
	uint16_t		Version;			/* Version of boot_args structure */
	uint64_t		virtBase;			/* Virtual base of memory */
	uint64_t		physBase;			/* Physical base of memory */
	uint64_t		memSize;			/* Size of memory */
	uint64_t		topOfKernelData;	/* Highest physical address used in kernel data area */
	struct Boot_Video Video;				/* Video Information */
	uint32_t		machineType;		/* Machine Type */
	void			*deviceTreeP;		/* Base of flattened device tree */
	uint32_t		deviceTreeLength;	/* Length of flattened tree */
	char			CommandLine[256];	/* Passed in command line */
	uint64_t		bootFlags;		/* Additional flags specified by the bootloader */
	uint64_t		memSizeActual;		/* Actual size of memory */
} boot_args;

typedef struct
{
    uint32_t nprop;
    uint32_t nchld;
    char prop[];
} dt_node_t;

typedef struct
{
    char key[DT_KEY_LEN];
    uint32_t len;
    char val[];
} dt_prop_t;

typedef struct
{
    const char* name;
    dt_node_t* node;
} dt_find_cb_t;

typedef struct
{
    const char* key;
    void* val;
    uint32_t len;
} dt_prop_cb_t;
struct memmap {
    uint64_t addr;
    uint64_t size;
};

extern volatile char gBootFlag;
#define BOOT_FLAG_DEFAULT 0
#define BOOT_FLAG_HARD 1
#define BOOT_FLAG_HOOK 2
#define BOOT_FLAG_LINUX 3
#define BOOT_FLAG_RAW 4

typedef uint64_t lock;
extern void lock_take(lock* lock); // takes a lock spinning initially but after being pre-empted once it will start yielding until it acquires it
extern void lock_take_spin(lock* lock); // takes a lock spinning until it acquires it
extern void lock_release(lock* lock); // releases ownership on a lock

extern int dt_check(void* mem, uint32_t size, uint32_t* offp);
extern int dt_parse(dt_node_t* node, int depth, uint32_t* offp, int (*cb_node)(void*, dt_node_t*), void* cbn_arg, int (*cb_prop)(void*, dt_node_t*, int, const char*, void*, uint32_t), void* cbp_arg);
extern dt_node_t* dt_find(dt_node_t* node, const char* name);
extern void* dt_prop(dt_node_t* node, const char* key, uint32_t* lenp);
extern void* dt_get_prop(const char* device, const char* prop, uint32_t* size);
extern struct memmap* dt_alloc_memmap(dt_node_t* node, const char* name);
extern void task_yield_asserted();
extern void _task_yield();
extern uint8_t * loader_xfer_recv_data;
extern uint32_t loader_xfer_recv_count;
extern uint32_t autoboot_count;
extern uint64_t gBootTimeTicks;

extern void (*sepfw_kpf_hook)(void* sepfw_bytes, size_t sepfw_size);

#define TASK_CAN_EXIT 1
#define TASK_LINKED 2
#define TASK_IRQ_HANDLER 4
#define TASK_PREEMPT 8
#define TASK_MASK_NEXT_IRQ 16
#define TASK_HAS_EXITED 32
#define TASK_WAS_LINKED 64
#define TASK_HAS_CRASHED 128
#define TASK_RESTART_ON_EXIT 256
#define TASK_SPAWN 512
#define TASK_FROM_PROC 1024
#define TASK_PLEASE_DEREF 2048

#define TASK_TYPE_MASK TASK_IRQ_HANDLER|TASK_PREEMPT|TASK_LINKED|TASK_CAN_EXIT|TASK_RESTART_ON_EXIT|TASK_SPAWN
#define TASK_REFCOUNT_GLOBAL 0x7fffffff
struct event {
	struct task* task_head;
};

extern struct vm_space kernel_vm_space;

#define VM_SPACE_SIZE 0x100000000
#define VM_SPACE_BASE 0xFFFFFFFE00000000
#define PAGING_INFO_ALLOC_ON_FAULT_MAGIC 0x00000000efef0008ULL
#define PAGING_INFO_ALLOC_ON_FAULT_MASK  0x00000000ffffffffULL
#define PAGING_INFO_ALLOC_ON_FAULT_INFO_MASK  0x000000ff00000000ULL
#define PAGING_INFO_ALLOC_ON_FAULT_INFO_GET(x) ((x & PAGING_INFO_ALLOC_ON_FAULT_INFO_MASK) >> 32ULL)
#define PAGING_INFO_ALLOC_ON_FAULT_INFO_SET(to, x) to = ((to & ~PAGING_INFO_ALLOC_ON_FAULT_INFO_MASK) | ((((uint64_t)x) << 32ULL) & PAGING_INFO_ALLOC_ON_FAULT_INFO_MASK));

#undef KERN_SUCCESS
#undef KERN_FAILURE
#undef KERN_VM_OOM
#undef VM_FLAGS_ANYWHERE
#undef VM_FLAGS_FIXED
#undef PROT_READ
#undef PROT_WRITE
#undef PROT_EXEC
#undef PROT_KERN_ONLY
#undef PROT_DEVICE
#undef PROT_PAGING_INFO

typedef enum {
    KERN_SUCCESS,
    KERN_FAILURE,
    KERN_VM_OOM
} err_t;
typedef enum {
    VM_FLAGS_ANYWHERE = 0,
    VM_FLAGS_FIXED = 1,
    VM_FLAGS_NOMAP = 2 // only reserves the VM space without doing anything with the lower level MM. call vm_space_map_page_physical_prot to actually associate a physical page manually! without this, pages will be populated on PF
} vm_flags_t;
typedef enum {
    PROT_READ = 1,
    PROT_WRITE = 2,
    PROT_EXEC = 4,
    PROT_KERN_ONLY = 8,
    PROT_DEVICE = 16,
    PROT_PAGING_INFO = 32
} vm_protect_t;

#ifdef PONGO_PRIVATE
#import "vfs.h"
#import "task.h"
#else
struct proc;
struct task;
struct vm_space;
#endif
#define PAGE_SIZE 0x4000
#define PAGE_MASK 0x3FFF
extern struct vm_space* vm_reference(struct vm_space* vmspace);
extern void vm_release(struct vm_space* vmspace);
extern struct vm_space* vm_create(struct vm_space* parent);
extern struct proc* proc_create(struct proc* parent, const char* proc_name, uint32_t flags);
extern void proc_reference(struct proc*);
extern void proc_release(struct proc*);
extern struct task* proc_create_task(struct proc* proc, void* entrypoint);
#define PROC_NO_VM 1
extern uint32_t loader_xfer_recv_size;
extern void resize_loader_xfer_data(uint32_t newsz);
extern bool vm_fault(struct vm_space* vmspace, uint64_t vma, vm_protect_t fault_prot);
extern err_t map_physical_range(struct vm_space* vmspace, uint64_t* va, uint64_t pa, uint32_t size, vm_flags_t flags, vm_protect_t prot);
extern struct vm_space* task_vm_space(struct task*);
extern void map_range_map(uint64_t* tt0, uint64_t va, uint64_t pa, uint64_t size, uint64_t sh, uint64_t attridx, bool overwrite, uint64_t paging_info, vm_protect_t prot, bool is_tt1);
extern err_t vm_space_map_page_physical_prot(struct vm_space* vmspace, uint64_t vaddr, uint64_t physical, vm_protect_t prot);
extern uint64_t ppage_alloc();
extern void ppage_free(uint64_t page);
extern void* page_alloc();
extern void page_free(void* page);
extern void* alloc_contig(uint32_t size);
extern void free_contig(void* base, uint32_t size);
extern void free_phys(uint64_t base, uint32_t size);
extern err_t vm_allocate(struct vm_space* vmspace, uint64_t* addr, uint64_t size, vm_flags_t flags);
extern err_t vm_deallocate(struct vm_space* vmspace, uint64_t addr, uint64_t size);
extern void vm_flush(struct vm_space* fl);
extern void vm_flush_by_addr(struct vm_space* fl, uint64_t va);
extern size_t memcpy_trap(void* dest, void* src, size_t size);
extern void task_critical_enter();
extern void task_critical_exit();
extern boot_args * gBootArgs;
extern void task_restart(struct task* task);
extern void* gEntryPoint;
extern dt_node_t *gDeviceTree;
extern uint64_t gIOBase;
extern uint64_t gPMGRBase;
extern char* gDevType;
extern void* ramdisk_buf;
extern uint32_t ramdisk_size;
extern char soc_name[9];
extern uint32_t socnum;
extern uint64_t vatophys_static(void* kva); // only safe to use with phystokva or alloc_contig's return value
extern uint32_t phys_get_entry(uint64_t pa);
extern void phys_set_entry(uint64_t pa, uint32_t val);
extern void mark_phys_wired(uint64_t pa, uint64_t size);
extern void phys_force_free(uint64_t pa, uint64_t size);
extern void phys_reference(uint64_t pa, uint64_t size);
extern void phys_dereference(uint64_t pa, uint64_t size);

typedef struct xnu_pf_range {
    uint64_t va;
    uint64_t size;
    uint8_t* cacheable_base;
    uint8_t* device_base;
} xnu_pf_range_t;

struct xnu_pf_patchset;

typedef struct xnu_pf_patch {
    bool (*pf_callback)(struct xnu_pf_patch* patch, void* cacheable_stream);
    bool is_required;
    bool has_fired;
    bool should_match;
    uint32_t pfjit_stolen_opcode;
    uint32_t pfjit_max_emit_size;
    uint32_t* (*pf_emit)(struct xnu_pf_patch* patch, struct xnu_pf_patchset *patchset,uint32_t* insn, uint32_t** insn_stream_end, uint8_t access_type);
    void (*pf_match)(struct xnu_pf_patch* patch, uint8_t access_type, void* preread, void* cacheable_stream);
    struct xnu_pf_patch* next_patch;
    uint32_t* pfjit_entry;
    uint32_t* pfjit_exit;
    uint8_t pf_data[0];
    char * name;

    //            patch->pf_match(XNU_PF_ACCESS_32BIT, reads, &stream[index], &dstream[index]);

} xnu_pf_patch_t;

typedef struct xnu_pf_patchset {
    xnu_pf_patch_t* patch_head;
    void* jit_matcher;
    uint64_t p0;
    uint8_t accesstype;
    bool is_required;
} xnu_pf_patchset_t;

#define XNU_PF_ACCESS_8BIT 0x8
#define XNU_PF_ACCESS_16BIT 0x10
#define XNU_PF_ACCESS_32BIT 0x20
#define XNU_PF_ACCESS_64BIT 0x40
#define TICKS_IN_1MS 24000
extern uint64_t xnu_slide_hdr_va(struct mach_header_64* header, uint64_t hdr_va);
extern uint64_t xnu_slide_value(struct mach_header_64* header);
extern struct mach_header_64* xnu_header();
extern xnu_pf_range_t* xnu_pf_range_from_va(uint64_t va, uint64_t size);
extern xnu_pf_range_t* xnu_pf_segment(struct mach_header_64* header, char* segment_name);
extern xnu_pf_range_t* xnu_pf_section(struct mach_header_64* header, void* segment, char* section_name);
extern xnu_pf_range_t* xnu_pf_all(struct mach_header_64* header);
extern xnu_pf_range_t* xnu_pf_all_x(struct mach_header_64* header);
extern void xnu_pf_disable_patch(xnu_pf_patch_t* patch);
extern void xnu_pf_enable_patch(xnu_pf_patch_t* patch);
extern struct segment_command_64* macho_get_segment(struct mach_header_64* header, const char* segname);
extern struct section_64 *macho_get_section(struct segment_command_64 *seg, const char *name);
extern struct mach_header_64* xnu_pf_get_first_kext(struct mach_header_64* kheader);
extern void hexdump(void *mem, unsigned int len);
extern xnu_pf_patch_t* xnu_pf_ptr_to_data(xnu_pf_patchset_t* patchset, uint64_t slide, xnu_pf_range_t* range, void* data, size_t datasz, bool required, bool (*callback)(struct xnu_pf_patch* patch, void* cacheable_stream));
extern xnu_pf_patch_t* xnu_pf_maskmatch(xnu_pf_patchset_t* patchset, char * name, uint64_t* matches, uint64_t* masks, uint32_t entryc, bool required, bool (*callback)(struct xnu_pf_patch* patch, void* cacheable_stream));
extern void xnu_pf_emit(xnu_pf_patchset_t* patchset); // converts a patchset to JIT
extern void xnu_pf_apply(xnu_pf_range_t* range, xnu_pf_patchset_t* patchset);
extern xnu_pf_patchset_t* xnu_pf_patchset_create(uint8_t pf_accesstype);
extern void xnu_pf_patchset_destroy(xnu_pf_patchset_t* patchset);
extern void* xnu_va_to_ptr(uint64_t va);
extern uint64_t xnu_ptr_to_va(void* ptr);
extern uint64_t xnu_rebase_va(uint64_t va);
extern uint64_t kext_rebase_va(uint64_t va);
extern struct mach_header_64* xnu_pf_get_kext_header(struct mach_header_64* kheader, const char* kext_bundle_id);
extern void xnu_pf_apply_each_kext(struct mach_header_64* kheader, xnu_pf_patchset_t* patchset);

#ifdef OVERRIDE_CACHEABLE_VIEW
#   define kCacheableView OVERRIDE_CACHEABLE_VIEW
#else
#   define kCacheableView 0x400000000ULL
#endif
struct pongo_exports {
    const char* name;
    void * value;
};
struct pongo_module_segment_info {
    char* name;
    uint64_t vm_addr;
    uint64_t vm_size;
    vm_protect_t prot;
};

struct pongo_module_info {
    const char* name;
    struct pongo_exports* exports;
    uint64_t vm_base;
    uint64_t vm_end;
    struct pongo_module_info* next;
    uint32_t segcount;
    struct pongo_module_segment_info segments[];
};
extern struct pongo_module_info* pongo_module_create(uint32_t segmentCount);
#define EXPORT_SYMBOL(x) {.name = "_"#x, .value = x}
#define EXPORT_SYMBOL_P(x) {.name = "_"#x, .value = (void*)&x}
extern void map_range(uint64_t va, uint64_t pa, uint64_t size, uint64_t sh, uint64_t attridx, bool overwrite);
void pongo_entry(uint64_t* kernel_args, void* entryp, void (*exit_to_el1_image)(void* boot_args, void* boot_entry_point));
int pongo_fiq_handler();
extern void (*preboot_hook)();
extern void (*sep_boot_hook)();
extern void (*rdload_hook)();
extern void vm_flush_by_addr_all_asid(uint64_t va);
extern void task_register_coop(struct task* task, void (*entry)()); // registers a cooperative task
extern void task_register_preempt_irq(struct task* task, void (*entry)(), int irq_id); // registers an irq handler
extern void task_register_irq(struct task* task, void (*entry)(), int irq_id); // registers an irq handler
extern void task_register(struct task* task, void (*entry)()); // register a preempt task
extern void task_yield();
extern void task_wait();
extern void task_exit();
extern void task_crash(const char* reason, ...);
extern void task_restart_and_link(struct task* task);
extern void task_exit_asserted();
extern void task_crash_asserted(const char* reason, ...);
extern struct task* task_create(const char* name, void (*entry)());
extern struct task* task_create_extended(const char* name, void (*entry)(), int task_type, uint64_t arg);
extern void task_reference(struct task* task);
extern void task_release(struct task* task);
extern void event_wait_asserted(struct event* ev);
extern void event_wait(struct event* ev);
extern void event_fire(struct event* ev);
extern void* alloc_static(uint32_t size); // memory returned by this will be added to the xnu static region, thus will persist after xnu boot
extern void task_bind_to_irq(struct task* task, int irq);
extern struct event command_handler_iter;

#ifdef memset
#   undef memset
#endif
extern void* memset(void *b, int c, size_t len);
extern void* memmem(const void* big, unsigned long blength, const void* little, unsigned long llength);
extern void* memstr(const void* big, unsigned long blength, const char* little);
extern void* memstr_partial(const void* big, unsigned long blength, const char* little);
extern unsigned long int strtoul(const char *nptr, char **endptr, int base);

extern uint64_t scheduler_ticks;
extern void invalidate_icache(void);
extern struct task* task_current();
extern char preemption_should_skip_beat();
extern void task_switch_irq(struct task* to_task);
extern void task_exit_irq();
extern void task_switch(struct task* to_task);
extern void task_link(struct task* to_task);
extern void task_unlink(struct task* to_task);
extern void task_irq_dispatch(uint32_t intr);
extern void task_yield_asserted();
extern void task_register_unlinked(struct task* task, void (*entry)());
extern void task_suspend_self();
extern _Noreturn void panic(const char* string, ...);
extern void pmgr_reset();
extern void spin(uint32_t usec);
extern void task_set_sched_head(struct task* task);
extern void enable_interrupts();
extern void disable_interrupts();
extern uint64_t get_ticks();
extern void usleep(uint64_t usec);
extern void sleep(uint32_t sec);
extern uint32_t dt_get_u32_prop(const char* device, const char* prop);
extern uint64_t dt_get_u64_prop(const char* device, const char* prop);
extern uint64_t dt_get_u64_prop_i(const char* device, const char* prop, uint32_t idx);
extern void unmask_interrupt(uint32_t reg);
extern void mask_interrupt(uint32_t reg);
extern _Noreturn void wdt_reset();
extern void wdt_enable();
extern void wdt_disable();
extern bool linux_can_boot();
extern void linux_prep_boot();
extern void linux_boot();
extern void command_register(const char* name, const char* desc, void (*cb)(const char* cmd, char* args));
extern char* command_tokenize(char* str, uint32_t strbufsz);
extern uint8_t get_el(void);
extern uint64_t vatophys(uint64_t kvaddr);
extern void* phystokv(uint64_t paddr);
extern void cache_invalidate(void *address, size_t size);
extern void cache_clean_and_invalidate(void *address, size_t size);
extern void cache_clean(void *address, size_t size);
extern void register_irq_handler(uint16_t irq_v, struct task* irq_handler);
extern uint64_t device_clock_by_id(uint32_t id);
extern uint64_t device_clock_by_name(const char *name);
extern void clock_gate(uint64_t addr, char val);
extern void disable_preemption();
extern void enable_preemption();
extern void* alloc_contig(uint32_t size);
extern uint64_t alloc_phys(uint32_t size);
extern void task_suspend_self_asserted();
extern void command_execute(char* cmd);
extern void queue_rx_string(char* string);
extern void command_unregister(const char* name);
extern int hexparse(uint8_t *buf, char *s, size_t len);
extern void hexprint(uint8_t *data, size_t sz);

// Legacy
extern void print_register(uint64_t value);
extern void command_putc(char val);
extern void command_puts(const char* val);

extern void pongo_syscall_entry(struct task* task, uint32_t sysnr, uint64_t* state);
extern uint64_t vatophys_force(uint64_t kvaddr);
#ifdef PONGO_PRIVATE
#define STDOUT_BUFLEN 0x1000
extern volatile uint8_t command_in_progress;
extern void set_stdout_blocking(bool block);
extern void fetch_stdoutbuf(char* to, int* len);
extern void usbloader_init();
extern void pmgr_init();
extern void command_init();
extern void task_init();
extern void serial_init();
extern void interrupt_init();
extern void interrupt_teardown();
extern void task_irq_teardown();
extern uint32_t exception_vector[];
extern void set_vbar_el1(uint64_t vec);
extern void rebase_pc(uint64_t vec);
extern void rebase_sp(uint64_t vec);
extern uint64_t get_mmfr0(void);
extern uint64_t get_migsts(void);
extern uint64_t get_mpidr(void);
extern void set_migsts(uint64_t val);
extern void enable_mmu_el1(uint64_t ttbr0, uint64_t tcr, uint64_t mair, uint64_t ttbr1);
extern void disable_mmu_el1();
extern void lowlevel_cleanup(void);
extern void lowlevel_setup(uint64_t phys_off, uint64_t phys_size);
extern void map_full_ram(uint64_t phys_off, uint64_t phys_size);
extern uint64_t linear_kvm_alloc(uint32_t size);
static inline _Bool is_16k(void)
{
    return ((get_mmfr0() >> 20) & 0xf) == 0x1;
}
static inline void flush_tlb(void)
{
    __asm__ volatile("isb");
    __asm__ volatile("tlbi vmalle1\n");
    __asm__ volatile("dsb sy");
}
extern void task_real_unlink(struct task* task);
#include "hal/hal.h"

#endif

#endif


```

`include/xnuspy/el1/debug.h`:

```h
#ifndef DEBUG
#define DEBUG

#include <xnuspy/xnuspy_structs.h>

#if defined(XNUSPY_DEBUG)
#define DEBUG_SPEW(fmt, args...) kprintf(fmt, ##args)
#else
#define DEBUG_SPEW(fmt, args...)
#endif

#if defined(XNUSPY_SERIAL)
#define SERIAL_SPEW(fmt, args...) IOLog(fmt, ##args)
#else
#define SERIAL_SPEW(fmt, args...)
#endif

#define SPYDBG(fmt, args...) \
    do { \
        DEBUG_SPEW(fmt, ##args); \
        SERIAL_SPEW(fmt, ##args); \
    } while (0) \

void desc_freelist(void);
void desc_xnuspy_shmem(struct xnuspy_shmem *);
/* XXX ONLY meant to be called from xnuspy_gc_thread, hence the lack
 * of locking. */
void desc_unmaplist(void);
void desc_usedlist(void);

void desc_xnuspy_mapping(struct xnuspy_mapping *);
void desc_xnuspy_mapping_metadata(struct xnuspy_mapping_metadata *);
void desc_xnuspy_tramp(struct xnuspy_tramp *, uint32_t);

#endif

```

`include/xnuspy/el1/externs.h`:

```h
#ifndef EXTERNS
#define EXTERNS

#include <mach/mach.h>
#include <stdbool.h>
#include <stdint.h>
#include <sys/queue.h>
#include <unistd.h>

#undef PAGE_SIZE
#define PAGE_SIZE       (0x4000uLL)

#define iOS_13_x        (19)
#define iOS_14_x        (20)
#define iOS_15_x        (21)

#define MAP_MEM_VM_SHARE            0x400000 /* extract a VM range for remap */

typedef unsigned int lck_rw_type_t;

typedef	void (*thread_continue_t)(void *param, int wait_result);

typedef struct __lck_rw_t__ lck_rw_t;

/* Start kernel offsets */

extern void **allprocp;
extern void (*bcopy_phys)(uint64_t src, uint64_t dst,
        vm_size_t bytes);
extern int (*copyin)(const void *uaddr, void *kaddr,
        vm_size_t nbytes);
extern int (*copyinstr)(const void *uaddr, void *kaddr,
        size_t len, size_t *done);
extern int (*copyout)(const void *kaddr, uint64_t uaddr,
        vm_size_t nbytes);
extern void *(*current_proc)(void);
extern uint64_t hookme_in_range;
extern uint64_t iOS_version;
extern void (*io_lock)(void *io);
extern void (*ipc_object_lock)(void *obj);
extern void (*IOLog)(const char *fmt, ...);
extern void (*IOSleep)(unsigned int millis);
extern void (*ipc_port_release_send)(void *port);
extern void (*ipc_port_release_send_and_unlock)(void *port);
extern void *(*kalloc_canblock)(vm_size_t *sizep, bool canblock,
        void *site);
extern void *(*kalloc_external)(vm_size_t sz);
extern uint64_t kern_version_minor;
extern void **kernel_mapp;
extern uint64_t kernel_slide;
extern kern_return_t (*kernel_thread_start)(thread_continue_t cont,
        void *parameter, void **new_thread);
extern void (*kfree_addr)(void *addr);
extern void (*kfree_ext)(void *kheap, void *addr,
        vm_size_t sz);
extern void (*kprintf)(const char *fmt, ...);
extern void *(*lck_grp_alloc_init)(const char *grp_name,
        void *attr);
extern void (*lck_grp_free)(void *grp);
extern void (*lck_mtx_lock)(void *lock);
extern void (*lck_mtx_unlock)(void *lock);
extern lck_rw_t *(*lck_rw_alloc_init)(void *grp, void *attr);
extern uint32_t (*lck_rw_done)(lck_rw_t *lock);
extern void (*lck_rw_free)(lck_rw_t *lock, void *grp);
extern void (*lck_rw_lock_exclusive)(void *lock);
extern void (*lck_rw_lock_shared)(void *lock);
extern int (*lck_rw_lock_shared_to_exclusive)(lck_rw_t *lck);
extern kern_return_t (*_mach_make_memory_entry_64)(void *target_map,
        uint64_t *size, uint64_t offset, vm_prot_t prot, void **object_handle,
        void *parent_handle);
extern int (*mach_to_bsd_errno)(kern_return_t mach_err);
extern kern_return_t (*mach_vm_map_external)(void *target_map,
        uint64_t *address, uint64_t size, uint64_t mask, int flags,
        void *memory_object, uint64_t offset, int copy,
        vm_prot_t cur_protection, vm_prot_t max_protection,
        vm_inherit_t inheritance);
extern void *(*_memmove)(void *dest, const void *src, size_t n);
extern void *(*_memset)(void *s, int c, size_t n);
extern uint64_t offsetof_struct_thread_map;
extern uint64_t offsetof_struct_vm_map_refcnt;
extern __attribute__ ((noreturn)) void (*_panic)(const char *fmt, ...);
extern uint64_t (*phystokv)(uint64_t pa);
extern void **proc_list_mlockp;
extern void (*proc_name)(int pid, char *buf, int size);
extern pid_t (*proc_pid)(void *proc);
extern void *(*proc_ref)(void *proc, bool w1);
extern void *(*proc_ref_locked)(void *proc);
extern int (*proc_rele)(void *proc);
extern void (*proc_rele_locked)(void *proc);
extern uint64_t (*proc_uniqueid)(void *proc);
extern int (*_snprintf)(char *str, size_t size, const char *fmt, ...);
extern size_t (*_strlen)(const char *s);
extern int (*_strncmp)(const char *s1, const char *s2, size_t n);
extern void (*thread_deallocate)(void *thread);
extern void (*_thread_terminate)(void *thread);
extern kern_return_t (*vm_allocate_external)(void *map, uint64_t *addr,
        uint64_t size, int flags);
extern kern_return_t (*_vm_deallocate)(void *map,
        uint64_t start, uint64_t size);
extern void (*vm_map_deallocate)(void *map);
extern kern_return_t (*vm_map_unwire)(void *map, uint64_t start,
        uint64_t end, int user);
extern kern_return_t (*vm_map_unwire_nested)(void *map, uint64_t start,
        uint64_t end, int user, uint64_t map_pmap, uint64_t pmap_addr);
extern kern_return_t (*vm_map_wire_external)(void *map,
        uint64_t start, uint64_t end, vm_prot_t prot, int user_wire);
extern struct xnuspy_tramp *xnuspy_tramp_mem;
extern struct xnuspy_tramp *xnuspy_tramp_mem_end;

/* End kernel offsets */

extern STAILQ_HEAD(, stailq_entry) freelist;
extern STAILQ_HEAD(, stailq_entry) usedlist;
extern STAILQ_HEAD(, stailq_entry) unmaplist;

extern lck_rw_t *xnuspy_rw_lck;

#endif

```

`include/xnuspy/el1/libc.h`:

```h
#ifndef LIBC
#define LIBC

#include <stddef.h>

void bzero(void *p, size_t n);
void *memchr(const void *s, int c, size_t n);
int memcmp(const void *s1, const void *s2, size_t n);
void *memmem(const void *big, size_t blen, const void *little, size_t llen);
void *memrchr(const void *s, int c, size_t n);
char *strchr(const char *s, int c);
char *strrchr(const char *s, int c);
int strcmp(const char *s1, const char *s2);
char *strstr(const char *big, const char *little);
char *strnstr(const char *big, const char *little, size_t len);

#endif

```

`include/xnuspy/el1/mem.h`:

```h
#ifndef MEM
#define MEM

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

__attribute__((naked)) uint64_t kvtophys(uint64_t);
__attribute__((naked)) uint64_t uvtophys(uint64_t);

void dcache_clean_PoU(void *address, size_t size);
void icache_invalidate_PoU(void *address, size_t size);

int kprotect(void *, uint64_t, vm_prot_t);
int uprotect(void *, uint64_t, vm_prot_t);

void kwrite_static(void *, void *, size_t);
void kwrite_instr(uint64_t, uint32_t);

int mkshmem_ktou(uint64_t, uint64_t, vm_prot_t, struct xnuspy_shmem *);
int mkshmem_utok(uint64_t, uint64_t, vm_prot_t, struct xnuspy_shmem *);
int mkshmem_raw(uint64_t, uint64_t, vm_prot_t, struct _vm_map *,
        struct _vm_map *, struct xnuspy_shmem *);

int shmem_destroy(struct xnuspy_shmem *);

void *unified_kalloc(size_t);
void unified_kfree(void *);

#endif

```

`include/xnuspy/el1/pte.h`:

```h
#ifndef PTE
#define PTE

#include <stdint.h>

typedef uint64_t pte_t;

pte_t *el0_ptep(void *);
pte_t *el1_ptep(void *);

void tlb_flush(void);

#define ARM_TTE_TABLE_MASK          (0x0000ffffffffc000)

#define ARM_16K_TT_L1_SHIFT         (36)
#define ARM_16K_TT_L2_SHIFT         (25)
#define ARM_16K_TT_L3_SHIFT         (14)

#define ARM_TT_L1_SHIFT             ARM_16K_TT_L1_SHIFT
#define ARM_TT_L2_SHIFT             ARM_16K_TT_L2_SHIFT
#define ARM_TT_L3_SHIFT             ARM_16K_TT_L3_SHIFT

#define ARM_16K_TT_L1_INDEX_MASK    (0x00007ff000000000)
#define ARM_16K_TT_L2_INDEX_MASK    (0x0000000ffe000000)
#define ARM_16K_TT_L3_INDEX_MASK    (0x0000000001ffc000)

#define ARM_TT_L1_INDEX_MASK        ARM_16K_TT_L1_INDEX_MASK
#define ARM_TT_L2_INDEX_MASK        ARM_16K_TT_L2_INDEX_MASK
#define ARM_TT_L3_INDEX_MASK        ARM_16K_TT_L3_INDEX_MASK

#define ARM_PTE_NX                  (0x0040000000000000uLL)
#define ARM_PTE_PNX                 (0x0020000000000000uLL)

#define ARM_PTE_APMASK              (0xc0uLL)
#define ARM_PTE_AP(x)               ((x) << 6)

#define AP_RWNA                     (0x0) /* priv=read-write, user=no-access */
#define AP_RWRW                     (0x1) /* priv=read-write, user=read-write */
#define AP_RONA                     (0x2) /* priv=read-only, user=no-access */
#define AP_RORO                     (0x3) /* priv=read-only, user=read-only */
#define AP_MASK                     (0x3) /* mask to find ap bits */

#endif

```

`include/xnuspy/el1/tramp.h`:

```h
#ifndef TRAMP
#define TRAMP

#include <stdint.h>

void generate_original_tramp(uint64_t, uint32_t *, uint32_t *);
void generate_replacement_tramp(uint32_t *);

#endif

```

`include/xnuspy/el1/utils.h`:

```h
#ifndef UTILS
#define UTILS

#include <stdbool.h>
#include <stdint.h>

#include <xnuspy/xnuspy_structs.h>

__attribute__ ((naked)) uint64_t current_thread(void);
struct _vm_map *current_map(void);
void vm_map_reference(void *);

bool is_15_x(void);
bool is_14_5_and_above(void);
bool is_14_x_and_above(void);
bool is_14_x_and_below(void);
bool is_14_x(void);
bool is_13_x(void);

void *get_proc_list_mlock(void);
void proc_list_lock(void);
void proc_list_unlock(void);

#endif

```

`include/xnuspy/el1/wrappers.h`:

```h
#ifndef WRAPPERS
#define WRAPPERS

#include <stdint.h>

void ipc_port_release_send_wrapper(void *);
kern_return_t vm_map_unwire_wrapper(void *, uint64_t, uint64_t, int);
void *proc_ref_wrapper(void *, bool);
int proc_rele_wrapper(void *, bool);

#endif

```

`include/xnuspy/el3/kpp.h`:

```h
#ifndef KPP
#define KPP

void patch_kpp(void);

#endif

```

`include/xnuspy/xnuspy_cache.h`:

```h
#ifndef XNUSPY_CACHE
#define XNUSPY_CACHE

#define SYSCTL__KERN_CHILDREN_PTR                       (0x0)
#define SYSCTL_REGISTER_OID                             (0x8)
#define SYSCTL_HANDLE_LONG                              (0x10)
#define NAME2OID                                        (0x18)
#define SYSCTL_GEOMETRY_LOCK_PTR                        (0x20)
#define LCK_RW_LOCK_SHARED                              (0x28)
#define LCK_RW_DONE                                     (0x30)
#define DID_REGISTER_SYSCTL                             (0x38)
#define H_S_C_SBN_EPILOGUE_ADDR                         (0x40)
#define XNUSPY_SYSCTL_MIB_PTR                           (0x48)
#define XNUSPY_SYSCTL_MIB_COUNT_PTR                     (0x50)
#define XNUSPY_CTL_CALLNUM                              (0x58)
#define IOS_VERSION                                     (0x60)
#define XNUSPY_CTL_ENTRYPOINT                           (0x68)
#define XNUSPY_CTL_CODESTART                            (0x70)
#define XNUSPY_CTL_CODESZ                               (0x78)
#define XNUSPY_CTL_IS_RX                                (0x80)
#define PHYSTOKV                                        (0x88)
#define BCOPY_PHYS                                      (0x90)

/* for kalloc/kfree, one of these will written to the cache depending
 * on iOS version
 */
#define KALLOC_CANBLOCK                                 (0x98)
#define KALLOC_EXTERNAL                                 (0x98)

#define KFREE_ADDR                                      (0xa0)
#define KFREE_EXT                                       (0xa0)

#define iOS_13_x                                        (19)
#define iOS_14_x                                        (20)
#define iOS_15_x                                        (21)

#define KERN_VERSION_MINOR                              (0xa8)

#endif

```

`include/xnuspy/xnuspy_ctl.h`:

```h
#ifndef XNUSPY_CTL
#define XNUSPY_CTL

#include <stdint.h>

/* Flavors for xnuspy_ctl */
enum {
    XNUSPY_CHECK_IF_PATCHED = 0,
    XNUSPY_INSTALL_HOOK,
    XNUSPY_REGISTER_DEATH_CALLBACK,
    XNUSPY_CALL_HOOKME,
    XNUSPY_CACHE_READ,
    XNUSPY_KREAD,
    XNUSPY_KWRITE,
    XNUSPY_GET_CURRENT_THREAD,
#ifdef XNUSPY_PRIVATE
    XNUSPY_MAX_FLAVOR = XNUSPY_GET_CURRENT_THREAD,
#endif
};

/* Values for XNUSPY_CACHE_READ - keep this alphabetical so it's
 * easier to find things */

#ifdef XNUSPY_PRIVATE
enum xnuspy_cache_id {
#else
enum {
#endif
    /* struct proclist allproc @ bsd/sys/proc_internal.h */
    ALLPROC = 0,
    BCOPY_PHYS,
    BZERO,
    COPYIN,
    COPYINSTR,
    COPYOUT,

    /* Idential to XNU's implementation */
    CURRENT_MAP,

    CURRENT_PROC,

    /* Only valid for iOS 14.5 - iOS 14.8, inclusive. EINVAL will be
     * returned otherwise. */
    IO_LOCK,

    /* Only valid for iOS 15.x. EINVAL will be returned otherwise. */
    IPC_OBJECT_LOCK,

    IOLOG,
    IOSLEEP,

    /* Only valid for < iOS 14.5. EINVAL will be returned otherwise. */
    IPC_PORT_RELEASE_SEND,
    
    /* Only valid for >= iOS 14.5. EINVAL will be returned otherwise. */
    IPC_PORT_RELEASE_SEND_AND_UNLOCK,

    /* Selects the correct way to release a send right based on the
     * kernel version. Parameters are the same as XNU's
     * ipc_port_release_send. */
    IPC_PORT_RELEASE_SEND_WRAPPER,

    /* Only valid for iOS 13.x. EINVAL will be returned otherwise. */
    KALLOC_CANBLOCK,

    /* Only valid for iOS 14.x and iOS 15.x. EINVAL will be returned
     * otherwise. */
    KALLOC_EXTERNAL,

    /* vm_map_t kernel_map @ osfmk/vm/vm_kern.h */
    KERNEL_MAP,

    KERNEL_THREAD_START,

    /* Only valid for iOS 13.x. EINVAL will be returned otherwise. */
    KFREE_ADDR,

    /* Only valid for iOS 14.x and iOS 15.x. EINVAL will be returned
     * otherwise. */
    KFREE_EXT,

    KPRINTF,
    LCK_GRP_ALLOC_INIT,
    LCK_GRP_FREE,
    LCK_MTX_LOCK,
    LCK_MTX_UNLOCK,
    LCK_RW_ALLOC_INIT,
    LCK_RW_DONE,
    LCK_RW_FREE,
    LCK_RW_LOCK_EXCLUSIVE,
    LCK_RW_LOCK_SHARED,
    LCK_RW_LOCK_SHARED_TO_EXCLUSIVE,
    MACH_MAKE_MEMORY_ENTRY_64,
    MACH_TO_BSD_ERRNO,
    MACH_VM_MAP_EXTERNAL,
    MEMCHR,
    MEMCMP,
    MEMMEM,
    MEMMOVE,
    MEMRCHR,
    MEMSET,
    PANIC,
    PHYSTOKV,

    /* Selects the correct way to take proc_list_mlock based
     * on the kernel version.
     *
     *      void proc_list_lock(void);
     *
     */
    PROC_LIST_LOCK,

    /* lck_mtx_t *proc_list_mlock @ bsd/sys/proc_internal.h */
    PROC_LIST_MLOCK,

    /* Selects the correct way to release proc_list_mlock based
     * on the kernel version.
     *
     *      void proc_list_unlock(void);
     *
     */
    PROC_LIST_UNLOCK,

    PROC_NAME,
    PROC_PID,

    /* Only valid for 15.x. EINVAL will be returned otherwise.
     * Until 15 sources come out, here's what I think the function
     * signature is:
     *
     *      proc_t proc_ref(proc_t proc, bool holding_proc_list_mlock);
     *
     * You can find a call to it in proc_exit. It looks like it is good
     * practice to make sure the returned proc pointer was the same one
     * as you passed in. Not sure what the return value being different
     * than the first parameter indicates... */
    PROC_REF,

    /* Only valid for 13.x and 14.x. EINVAL will be returned otherwise.
     * This function assumes the caller holds proc_list_mlock. */
    PROC_REF_LOCKED,

    /* Selects the correct way to take a reference on a proc structure
     * based on the kernel version.
     *
     *      void *proc_ref_wrapper(void *proc, bool holding_proc_list_mlock);
     *
     * If you are on iOS 13.x or iOS 14.x and you pass false for the
     * second parameter, this function takes proc_list_mlock before
     * calling proc_ref_locked and releases it after that returns. If
     * you are on iOS 15.x, this tail calls proc_ref. Return value
     * is either the return value of proc_ref or proc_ref_locked. */
    PROC_REF_WRAPPER,

    /* Only valid for 15.x. EINVAL will be returned otherwise.
     * This function assumes the caller DOES NOT hold proc_list_mlock,
     * though I'm not sure if it's safe to hold that mutex and call this
     * function.
     * Until 15 sources come out, here's the function signature:
     *
     *      int proc_rele(proc_t proc);
     *
     * Seems to always return 0. */
    PROC_RELE,

    /* Only valid for 13.x and 14.x. EINVAL will be returned otherwise.
     * This function assumes the caller holds proc_list_mlock. */
    PROC_RELE_LOCKED,

    /* Selects the correct way to release a reference on a proc structure
     * based on the kernel version.
     *
     *      int proc_rele_wrapper(void *proc, bool holding_proc_list_mlock);
     *
     * If you are on iOS 13.x or iOS 14.x and you pass false for the
     * second parameter, this function takes proc_list_mlock before
     * calling proc_rele_locked and releases it after that returns. If
     * you are on iOS 15.x, this tail calls proc_rele and the second
     * parameter is ignored. Return value is either the return value
     * of proc_ref (for iOS 15.x) or zero (for iOS 13.x and iOS 14.x) */
    PROC_RELE_WRAPPER,

    PROC_UNIQUEID,
    SNPRINTF,
    STRCHR,
    STRRCHR,
    STRCMP,
    STRLEN,
    STRNCMP,
    STRSTR,
    STRNSTR,
    THREAD_DEALLOCATE,
    THREAD_TERMINATE,
    VM_ALLOCATE_EXTERNAL,
    VM_DEALLOCATE,
    VM_MAP_DEALLOCATE,

    /* Identical to XNU's implementation */
    VM_MAP_REFERENCE,

    /* Only valid for 13.x and 14.x. EINVAL will be returned otherwise. */
    VM_MAP_UNWIRE,

    /* Only valid for 15.x. EINVAL will be returned otherwise. */
    VM_MAP_UNWIRE_NESTED,

    /* Selects the correct way to unwire a vm_map based on the
     * kernel version. Parameters are the same as XNU's vm_map_unwire. */
    VM_MAP_UNWIRE_WRAPPER,

    VM_MAP_WIRE_EXTERNAL,

    /*  --------------------------------------------
     * Everything above (with the exception of the small wrapper functions)
     * is from XNU, everything below are things from xnuspy you may
     * find useful
     *  ---------------------------------------------
     */

    /* uint64_t *el0_ptep(void *uaddr)
     *
     * Given a user virtual address, this function returns a pointer to its
     * page table entry.
     *
     * Parameters:
     *  uaddr: user virtual address.
     *
     * Returns:
     *  Kernel virtual address of page table entry for uaddr.
     */
    EL0_PTEP,

    /* uint64_t *el1_ptep(void *kaddr)
     *
     * Given a kernel virtual address, this function returns a pointer to its
     * page table entry.
     *
     * Parameters:
     *  kaddr: kernel virtual address.
     *
     * Returns:
     *  Kernel virtual address of page table entry for kaddr.
     */
    EL1_PTEP,

    /* void hookme(void *arg)
     *
     * This function is a stub for you to hook to easily gain kernel code
     * execution without having to hook an actual kernel function. You can
     * get xnuspy to call it by invoking xnuspy_ctl with the
     * XNUSPY_CALL_HOOKME flavor.
     */
    HOOKME,

    /* uint64_t iOS_version
     *
     * This variable contains the major from the "Darwin Kernel Version"
     * string. On iOS 13.x, this is 19, on iOS 14.x, this is 20, and
     * on iOS 15.x, this is 21. */
    IOS_VERSION,

    /* uint64_t kernel_slide
     *
     * KASLR slide */
    KERNEL_SLIDE,

    /* uint64_t kern_version_minor
     *
     * This variable contains the minor from the "Darwin Kernel Version"
     * string. */
    KERN_VERSION_MINOR,

    /* int kprotect(void *kaddr, uint64_t size, vm_prot_t prot)
     *
     * Change protections of kernel memory at the page table level.
     * You are allowed to make writable, executable memory.
     *
     * Parameters:
     *  kaddr: kernel virtual address of target.
     *  size:  the number of bytes in the target region.
     *  prot:  protections to apply. Only VM_PROT_READ, VM_PROT_WRITE, and
     *         VM_PROT_EXECUTE are respected.
     *
     * Returns:
     *  Zero if successful, non-zero otherwise.
     */
    KPROTECT,

    /* uint64_t kvtophys(uint64_t kaddr)
     *
     * Convert a kernel (EL1) virtual address to a physical address.
     *
     * Parameters:
     *  kaddr: kernel virtual address.
     *
     * Returns:
     *  Non-zero if address translation was successful, zero otherwise.
     */
    KVTOPHYS,

    /* void kwrite_instr(uint64_t addr, uint32_t instr)
     *
     * Patch a single instruction of executable kernel code. This function
     * handles permissions, data cache cleaning, and instruction cache
     * invalidation.
     *
     * Parameters:
     *  addr:  kernel virtual address.
     *  instr: new instruction for addr.
     */
    KWRITE_INSTR,

    /* void kwrite_static(void *dst, void *buf, size_t sz)
     *
     * Write to static kernel memory, using bcopy_phys.
     *
     * Parameters:
     *  dst: kernel virtual address of destination.
     *  buf: kernel virtual address of data.
     *  sz:  how many bytes 'buf' is.
     */
    KWRITE_STATIC,

    /* The next three functions deal with shared memory. KTOU ("kernel to
     * user") and UTOK ("user to kernel") specify the "direction". "a to b",
     * where <a> and <b> are both vm_map pointers, means pages from <a> will
     * be mapped into <b> as shared memory. Pages from <a> must have been
     * allocated via vm_allocate for these functions to succeed. KTOU and UTOK
     * automatically select the <a> and <b> vm_map pointers for convenience.
     * The RAW variant allows you to specify the <a> and <b> vm_map pointers.
     * You would use mkshmem_raw when you are unsure of current_task()->map
     * or the current CPU's TTBR0 inside your kernel code.
     *
     * int mkshmem_ktou(uint64_t kaddr, uint64_t sz, vm_prot_t prot,
     *         struct xnuspy_shmem *shmemp);
     * int mkshmem_utok(uint64_t uaddr, uint64_t sz, vm_prot_t prot,
     *         struct xnuspy_shmem *shmemp);
     * int mkshmem_raw(uint64_t addr, uint64_t sz, vm_prot_t prot,
     *         vm_map_t from, vm_map_t to, struct xnuspy_shmem *shmemp);
     *
     * Parameters (for all three):
     *  kaddr/uaddr/addr: virtual address somewhere inside <a>
     *  sz:               page aligned mapping size
     *  prot:             virtual protections to apply to the created
     *                    shared mapping
     *  shmemp:           returned shmem. The structure definition can
     *                    be found at the end of this file.
     *
     * Parameters specific to mkshmem_raw:
     *  from: source map, aka <a>
     *  to:   destination map, aka <b>
     *
     * Returns (for all three):
     *  Zero on success (and populated shmemp structure), non-zero BSD errno
     *  on failure.
     *
     * Other notes:
     *  These functions use kprotect to apply VM protections, so any
     *  combination of those are allowed. VM protections are only applied
     *  to the newly-created mapping, not the source pages that came
     *  from <a>.
     */
    MKSHMEM_KTOU,
    MKSHMEM_UTOK,
    MKSHMEM_RAW,

    /* offsetof(struct thread, map), vm_map_t */
    OFFSETOF_STRUCT_THREAD_MAP,

    /* offsetof(struct _vm_map, map_refcnt), int (yes, int) */
    OFFSETOF_STRUCT_VM_MAP_REFCNT,

    /* int shmem_destroy(struct xnuspy_shmem *shmemp);
     *
     * Destory shared memory returned by mkshmem_ktou, mkshmem_utok, or
     * mkshmem_raw.
     *
     * Parameters:
     *  shmemp: pointer to shmem structure
     *
     * Returns:
     *  Zero on success, non-zero BSD errno on failure.
     */
    SHMEM_DESTROY,

    /* void tlb_flush(void)
     *
     * After modifying a page table, call this function to invalidate
     * the TLB.
     */
    TLB_FLUSH,

    /* The next two functions abstract away the different kalloc/kfree pairs
     * for different iOS versions and keeps track of allocation sizes. This
     * creates an API like malloc/free. Pointers returned from unified_kalloc
     * can only be freed with unified_kfree, and pointers returned by other
     * memory allocation functions cannot be freed with unified_kfree.
     *
     *  uint8_t *buf = unified_kalloc(0x200);
     *  
     *  if(!buf)
     *     <error>
     *
     *  buf[0] = '\0';
     *
     *  unified_kfree(buf);
     *
     * -------------------------------
     *
     * void *unified_kalloc(size_t sz)
     *
     * Parameters:
     *  sz: allocation size.
     *
     * Returns:
     *  Upon success, a pointer to memory. If we are on 13.x, kalloc_canblock's
     *  canblock parameter is false. Upon failure, NULL.
     *
     * -------------------------------
     *
     * void unified_kfree(void *ptr)
     *
     * Parameters:
     *  ptr: a pointer returned from unified_kalloc.
     */
    UNIFIED_KALLOC,
    UNIFIED_KFREE,

    /* int uprotect(void *uaddr, uint64_t size, vm_prot_t prot)
     *
     * Change protections of user memory at the page table level.
     * You are allowed to make writable, executable memory.
     *
     * Parameters:
     *  uaddr: user virtual address of target.
     *  size:  the number of bytes in the target region.
     *  prot:  protections to apply. Only VM_PROT_READ, VM_PROT_WRITE, and
     *         VM_PROT_EXECUTE are respected.
     *
     * Returns:
     *  Zero if successful, non-zero otherwise.
     */
    UPROTECT,

    /* uint64_t uvtophys(uint64_t uaddr)
     *
     * Convert a user (EL0) virtual address to a physical address.
     *
     * Parameters:
     *  uaddr: user virtual address.
     *
     * Returns:
     *  Non-zero if address translation was successful, zero otherwise.
     */
    UVTOPHYS,

#ifdef XNUSPY_PRIVATE
    MAX_CACHE = UVTOPHYS,
#endif
};

#define iOS_13_x    (19)
#define iOS_14_x    (20)
#define iOS_15_x    (21)

/* Structures for locks that work in both kernelspace and userspace.
 * Any locks you declare must be declared globally so they
 * are mapped as shared memory when you install your kernel hooks */
/* kuslck_t: a simple spinlock */
typedef struct {
    uint32_t word;
} kuslck_t;

#define KUSLCK_UNLOCKED (0)
#define KUSLCK_LOCKED   (1)

/* kuslck_t lck = KUSLCK_INITIALIZER; */
#define KUSLCK_INITIALIZER { .word = KUSLCK_UNLOCKED }

#define kuslck_lock(lck) \
    do { \
        while(__atomic_exchange_n(&(lck).word, KUSLCK_LOCKED, \
                    __ATOMIC_ACQ_REL) == 0){} \
    } while (0) \

#define kuslck_unlock(lck) \
    do { \
        __atomic_store_n(&(lck).word, KUSLCK_UNLOCKED, __ATOMIC_RELEASE); \
    } while (0) \

struct xnuspy_shmem {
    /* Base of shared memory */
    void *shm_base;
    /* Size of shared memory, page multiple */
    uint64_t shm_sz;
#ifdef XNUSPY_PRIVATE
    /* Memory entry for the shared memory, ipc_port_t */
    void *shm_entry;
    /* The vm_map_t which the source pages belong to */
    void *shm_map_from;
    /* The vm_map_t which the source pages were mapped into */
    void *shm_map_to;
#else
    void *opaque[3];
#endif
};

#endif

```

`include/xnuspy/xnuspy_structs.h`:

```h
#ifndef XNUSPY_STRUCTS
#define XNUSPY_STRUCTS

#include <sys/queue.h>

struct stailq_entry {
    void *elem;
    STAILQ_ENTRY(stailq_entry) link;
};

struct slist_entry {
    void *elem;
    SLIST_ENTRY(slist_entry) link;
};

/* struct xnuspy_shmem { */
/*     /1* Base of shared memory *1/ */
/*     void *shm_base; */
/*     /1* Size of shared memory, page multiple *1/ */
/*     uint64_t shm_sz; */
/*     /1* Memory entry for the shared memory, ipc_port_t *1/ */
/*     void *shm_entry; */
/*     /1* The vm_map_t which the source pages belong to *1/ */
/*     void *shm_map_from; */
/*     /1* The vm_map_t which the source pages were mapped into *1/ */
/*     void *shm_map_to; */
/* }; */

#define MAX_MAPPING_REFERENCES (0x1000000)

/* This structure represents a shared __TEXT and __DATA mapping. There could
 * be a number of these structures per-process because different dynamic
 * libraries loaded into the address space of one process can install
 * hooks. */
struct xnuspy_mapping {
    /* Reference count for this mapping, NOT the mapping metadata */
    _Atomic int64_t refcnt;
    /* Pointer to caller's Mach-O header */
    uint64_t mapping_addr_uva;
    /* Death callback to invoke when refcnt hits zero */
    void (*death_callback)(void);
    /* Kernel's mapping of the shared __TEXT and __DATA. This has
     * to be a pointer so I can easily enqueue it onto the unmaplist */
    struct xnuspy_shmem *segment_shmem;
};

/* This structure maintains all shared mappings for a given process. There
 * is one of these per-process. This will be deallocated when the mappings
 * linked list is empty. */
struct xnuspy_mapping_metadata {
    /* Process which owns all of the mappings managed by this structure
     * (p_uniqueid) */
    uint64_t owner;
    /* Linked list of all shared mappings we've created for this process.
     * Protected by xnuspy_rw_lck. */
    SLIST_HEAD(, slist_entry) mappings;
};

/* This structure contains information for an xnuspy_tramp that isn't
 * necessary to keep in the struct itself. I do this to save space. These are
 * not reference counted because they're per-hook. */
struct xnuspy_tramp_metadata {
    /* Hooked kernel function */
    uint64_t hooked;
    /* Overwritten instruction */
    uint32_t orig_instr;
};

/* This structure represents a function hook. Every xnuspy_tramp struct resides
 * on writeable, executable memory. */
struct xnuspy_tramp {
    /* Kernel virtual address of userland replacement on shared mapping */
    uint64_t replacement;
    /* The trampoline for a hooked function. When the user installs a hook
     * on a function, the first instruction of that function is replaced
     * with a branch to here. An xnuspy trampoline looks like this:
     *  tramp[0]    LDR X16, #-0x8      (replacement)
     *  tramp[1]    BR X16
     */
    uint32_t tramp[2];
    /* An abstraction that represents the original function. It's just another
     * trampoline, but it can take on one of seven forms. The most common
     * form is this:
     *  orig[0]     <original first instruction of the hooked function>
     *  orig[1]     LDR X16, #0x8
     *  orig[2]     BR X16
     *  orig[3]     <address of second instruction of the hooked function>[31:0]
     *  orig[4]     <address of second instruction of the hooked function>[63:32]
     *
     * The above form is taken when the original first instruction of the hooked
     * function is not an immediate conditional branch (b.cond), an immediate
     * compare and branch (cbz/cbnz), an immediate test and branch (tbz/tbnz),
     * an immediate unconditional branch (b), an immediate unconditional
     * branch with link (bl), load register (literal), or an ADR. These are
     * special cases because the immediates do not contain enough bits for me
     * to just "fix up" or assume we'll always be in range once we do, so I
     * need to emit an equivalent sequence of instructions.
     *
     * If the first instruction was B.cond <label>
     *  orig[0]     LDR X16, #0x10
     *  orig[1]     LDR X17, #0x14
     *  orig[2]     CSEL X16, X16, X17, <cond>
     *  orig[3]     BR X16
     *  orig[4]     <destination if condition holds>[31:0]
     *  orig[5]     <destination if condition holds>[63:32]
     *  orig[6]     <address of second instruction of the hooked function>[31:0]
     *  orig[7]     <address of second instruction of the hooked function>[63:32]
     *
     * If the first instruction was CBZ Rn, <label> or CBNZ Rn, <label>
     *  orig[0]     LDR X16, #0x14
     *  orig[1]     LDR X17, #0x18
     *  orig[2]     CMP Rn, #0
     *  orig[3]     CSEL X16, X16, X17, <if CBZ, eq, if CBNZ, ne>
     *  orig[4]     BR X16
     *  orig[5]     <destination if condition holds>[31:0]
     *  orig[6]     <destination if condition holds>[63:32]
     *  orig[7]     <address of second instruction of the hooked function>[31:0]
     *  orig[8]     <address of second instruction of the hooked function>[63:32]
     *
     * If the first instruction was TBZ Rn, #n, <label> or TBNZ Rn, #n, <label>
     *  orig[0]     LDR X16, #0x14
     *  orig[1]     LDR X17, #0x18
     *  orig[2]     TST Rn, #(1 << n)
     *  orig[3]     CSEL X16, X16, X17, <if TBZ, eq, if TBNZ, ne>
     *  orig[4]     BR X16
     *  orig[5]     <destination if condition holds>[31:0]
     *  orig[6]     <destination if condition holds>[63:32]
     *  orig[7]     <address of second instruction of the hooked function>[31:0]
     *  orig[8]     <address of second instruction of the hooked function>[63:32]
     *
     * If the first instruction was ADR Rn, #n
     *  orig[0]     ADRP Rn, #n@PAGE
     *  orig[1]     ADD Rn, Rn, #n@PAGEOFF
     *  orig[2]     LDR X16, #0x8
     *  orig[3]     BR X16
     *  orig[4]     <address of second instruction of the hooked function>[31:0]
     *  orig[5]     <address of second instruction of the hooked function>[63:32]
     *
     * If the first instruction was B <label>
     *  orig[0]     LDR X16, 0x8
     *  orig[1]     BR X16
     *  orig[2]     <address of branch destination>[31:0]
     *  orig[3]     <address of branch destination>[63:32]
     *
     * If the first instruction was BL <label>
     *  orig[0]     MOV X17, X30
     *  orig[1]     LDR X16, #0x14
     *  orig[2]     BLR X16
     *  orig[3]     MOV X30, X17
     *  orig[4]     LDR X16, #0x10
     *  orig[5]     BR X16
     *  orig[6]     <address of branch destination>[31:0]
     *  orig[7]     <address of branch destination>[63:32]
     *  orig[8]     <address of second instruction of the hooked function>[31:0]
     *  orig[9]     <address of second instruction of the hooked function>[63:32]
     *
     * If the first instruction belongs to the "Load register (literal)" class
     *  orig[0]     ADRP X16, <label>@PAGE
     *  orig[1]     ADD X16, X16, <label>@PAGEOFF
     *  orig[2]     LDR{SW} Rn, [X16] or PRFM <prfop>, [X16]
     *  orig[3]     LDR X16, 0x8
     *  orig[4]     BR X16
     *  orig[5]     <address of second instruction of the hooked function>[31:0]
     *  orig[6]     <address of second instruction of the hooked function>[63:32]
     */
    uint32_t orig[10];
    struct xnuspy_tramp_metadata *tramp_metadata;
    struct xnuspy_mapping_metadata *mapping_metadata;
};

typedef struct __lck_rw_t__ {
    uint64_t word;
    void *owner;
} lck_rw_t;

#define CAST_TO_VM_MAP_ENTRY(x) ((struct vm_map_entry *)(uintptr_t)(x))
#define vm_map_to_entry(map) CAST_TO_VM_MAP_ENTRY(&(map)->hdr.links)
#define vm_map_first_entry(map) ((map)->hdr.links.next)

#define vme_prev		links.prev
#define vme_next		links.next
#define vme_start		links.start
#define vme_end			links.end

struct vm_map_links {
    struct vm_map_entry *prev;
    struct vm_map_entry *next;
    uint64_t start;
    uint64_t end;
};

struct vm_map_entry {
    struct vm_map_links links;
};

struct vm_map_header {
    struct vm_map_links links;
};

struct _vm_map {
    lck_rw_t lck;
    struct vm_map_header hdr;
};

struct sysent {
    uint64_t sy_call;
    void *sy_arg_munge32;
    int32_t sy_return_type;
    int16_t sy_narg;
    uint16_t sy_arg_bytes;
};

#endif

```

`klog/Makefile`:

```
SDK = $(shell xcrun --sdk iphoneos --show-sdk-path)
CC = $(shell xcrun --sdk $(SDK) --find clang)
CFLAGS = -isysroot $(SDK) -arch arm64

all : klog

.PHONY : upload

upload : klog
	rsync -sz -e 'ssh -p 2222' klog root@localhost:/var/root

klog : klog.c
	$(CC) $(CFLAGS) klog.c -o klog
	ldid -S../ent.xml ./klog

```

`klog/README.md`:

```md
# klog

klog will read from `/dev/klog` for incoming `kprintf` and `IOLog` messages.
It depends on `atm_diagnostic_config=0x20000000` being present in
XNU's boot arguments.

Recommended usage: `stdbuf -o0 ./klog | grep <thing>`

Run `make` in this directory to build `klog`. `make upload` will
upload it to your device, but you may have to swap out the port number.

```

`klog/klog.c`:

```c
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

int main(int argc, char **argv){
    int klog_fd = open("/dev/klog", O_RDONLY);

    if(klog_fd == -1){
        printf("open: %s\n", strerror(errno));
        return 1;
    }

    for(;;){
        fd_set rfds;
        FD_ZERO(&rfds);
        FD_SET(klog_fd, &rfds);

        int res = select(FD_SETSIZE, &rfds, NULL, NULL, NULL);

        if(res < 0){
            printf("select failed: %s\n", strerror(errno));
            close(klog_fd);
            return 1;
        }

        char buf[1024];
        memset(buf, 0, sizeof(buf));
        ssize_t r = read(klog_fd, buf, sizeof(buf));

        if(r < 0){
            printf("read failed: %s\n", strerror(errno));
            close(klog_fd);
            return 1;
        }

        buf[r] = '\0';
        printf("%s", buf);
    }

    close(klog_fd);

    return 0;
}

```

`loader/Makefile`:

```
CC = clang
CFLAGS = -g
LDFLAGS = -lusb-1.0

ifeq ($(XNUSPY_SERIAL), 1)
	CFLAGS += -DXNUSPY_SERIAL
endif

TARGET = loader

SOURCES = loader.c

$(TARGET) : $(SOURCES)
	$(CC) $(CFLAGS) $(LDFLAGS) $(SOURCES) -o $(TARGET)

```

`loader/loader.c`:

```c
#include <errno.h>
#include <fcntl.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>

#include <libusb-1.0/libusb.h>

static int pongo_send_command(libusb_device_handle *pongo_device,
        const char *command){
    size_t command_len = 1;

    if(command)
        command_len += strlen(command);

    return libusb_control_transfer(pongo_device, 0x21, 3, 0, 0,
            (unsigned char *)command, command_len, 0);
}

static int pongo_init_bulk_upload(libusb_device_handle *pongo_device){
    return libusb_control_transfer(pongo_device, 0x21, 1, 0, 0, NULL, 0, 0);
}

static int pongo_discard_bulk_upload(libusb_device_handle *pongo_device){
    return libusb_control_transfer(pongo_device, 0x21, 2, 0, 0, NULL, 0, 0);
}

static int pongo_do_bulk_upload(libusb_device_handle *pongo_device,
        void *data, size_t len){
    return libusb_bulk_transfer(pongo_device, 2, data, len, NULL, 0);
}

static int pongo_get_stdout(libusb_device_handle *pongo_device, char *outbuf){
    return libusb_control_transfer(pongo_device, 0xa1, 1, 0, 0,
            (unsigned char *)outbuf, 512, 0);
}

static int hotplug_callback(libusb_context *ctx, libusb_device *device,
        libusb_hotplug_event event, void *user_data){
    if(event != LIBUSB_HOTPLUG_EVENT_DEVICE_ARRIVED)
        return 0;

    libusb_device_handle **pongo_device = (libusb_device_handle **)user_data;
    int err = libusb_open(device, pongo_device);
    
    if(err){
        printf("Couldn't open pongoOS device: %s\n", libusb_error_name(err));
        libusb_exit(NULL);
        exit(1);
    }

    return 0;
}

int main(int argc, char **argv, const char **envp){
    if(argc < 2){
        printf("usage: loader <pongo module>\n");
        return 1;
    }
    
    int err = libusb_init(NULL);

    if(err < 0){
        printf("libusb_init failed: %d\n", err);
        return 1;
    }

    printf("Waiting for pongoOS device...\n");

    libusb_hotplug_callback_handle cbh = 0;
    libusb_device_handle *pongo_device = NULL;

    err = libusb_hotplug_register_callback(NULL, LIBUSB_HOTPLUG_EVENT_DEVICE_ARRIVED,
            LIBUSB_HOTPLUG_ENUMERATE, 0x5ac, 0x4141, LIBUSB_HOTPLUG_MATCH_ANY,
            hotplug_callback, &pongo_device, &cbh);

    if(err < 0){
        printf("libusb_hotplug_register_callback: %s\n", libusb_error_name(err));
        return 1;
    }

    while(!pongo_device)
        libusb_handle_events_completed(NULL, NULL);

    libusb_hotplug_deregister_callback(NULL, cbh);

    printf("Got pongoOS device\n");

    err = libusb_claim_interface(pongo_device, 0);

    if(err < 0){
        printf("libusb_claim_interface: %s\n", libusb_error_name(err));
        goto err0;
    }

    char *module_path = argv[1];
    struct stat st = {0};
    
    if(stat(module_path, &st)){
        printf("Problem stat'ing '%s': %s\n", module_path, strerror(errno));
        goto err0;
    }

    int module_fd = open(module_path, O_RDONLY);

    if(module_fd < 0){
        printf("Problem open'ing '%s': %s\n", module_path, strerror(errno));
        goto err0;
    }

    size_t module_size = st.st_size;
    printf("Module size %#lx\n", module_size);

    void *module_data = mmap(NULL, module_size, PROT_READ, MAP_PRIVATE,
            module_fd, 0);

    close(module_fd);

    if(module_data == MAP_FAILED){
        printf("Problem mmap'ing '%s': %s\n", module_path, strerror(errno));
        goto err0;
    }

    const char *xnuspy_ctl_path = "./module/el1/xnuspy_ctl/xnuspy_ctl";

    memset(&st, 0, sizeof(st));

    if(stat(xnuspy_ctl_path, &st)){
        printf("Problem stat'ing '%s': %s\n", xnuspy_ctl_path, strerror(errno));
        goto err1;
    }

    size_t xnuspy_ctl_imgsz = st.st_size;
    printf("xnuspy_ctl image size %#zx\n", xnuspy_ctl_imgsz);

    int xnuspy_ctl_fd = open(xnuspy_ctl_path, O_RDONLY);

    if(xnuspy_ctl_fd == -1){
        printf("Problem open'ing '%s': %s\n", xnuspy_ctl_path, strerror(errno));
        goto err1;
    }

    void *xnuspy_ctl_imgdata = mmap(NULL, xnuspy_ctl_imgsz, PROT_READ,
            MAP_PRIVATE, xnuspy_ctl_fd, 0);

    close(xnuspy_ctl_fd);

    if(xnuspy_ctl_imgdata == MAP_FAILED){
        printf("Problem mmap'ing '%s': %s\n", xnuspy_ctl_path, strerror(errno));
        goto err1;
    }

    err = pongo_init_bulk_upload(pongo_device);

    if(err < 0){
        printf("pongo_init_bulk_upload: %s\n", libusb_error_name(err));
        goto err2;
    }

    err = pongo_do_bulk_upload(pongo_device, module_data, module_size);

    if(err < 0){
        printf("pongo_do_bulk_upload (module): %s\n", libusb_error_name(err));
        goto err2;
    }

    err = pongo_send_command(pongo_device, "modload\n");

    if(err < 0){
        printf("pongo_send_command: %s\n", libusb_error_name(err));
        goto err2;
    }
    
    usleep(200 * 1000);

    /* If you want to modify this string, don't remove rootdev=md0 and
     * use_contiguous_hint=0. Make sure to keep the newline. */
    err = pongo_send_command(pongo_device, "xargs rootdev=md0"
            " use_contiguous_hint=0 msgbuf=0x3c000"
#if defined(XNUSPY_SERIAL)
            " -v serial=3"
#endif
            " atm_diagnostic_config=0x20000000\n");

    if(err < 0){
        printf("pongo_send_command: %s\n", libusb_error_name(err));
        goto err2;
    }
    
    usleep(200 * 1000);

    err = pongo_send_command(pongo_device, "xnuspy-getkernelv\n");

    if(err < 0){
        printf("pongo_send_command: %s\n", libusb_error_name(err));
        goto err2;
    }

    /* we may have had to pwn SEPROM or patch KPP, so wait a bit longer
     * before we continue */
    sleep(3);

    /* send the compiled xnuspy_ctl image */
    err = pongo_init_bulk_upload(pongo_device);

    if(err < 0){
        printf("pongo_init_bulk_upload: %s\n", libusb_error_name(err));
        goto err2;
    }

    err = pongo_do_bulk_upload(pongo_device, xnuspy_ctl_imgdata,
            xnuspy_ctl_imgsz);

    if(err < 0){
        printf("pongo_do_bulk_upload (xnuspy_ctl): %s\n",
                libusb_error_name(err));
        goto err2;
    }

    err = pongo_send_command(pongo_device, "xnuspy-prep\n");

    if(err < 0){
        printf("pongo_send_command: %s\n", libusb_error_name(err));
        goto err2;
    }

    sleep(2);

    err = pongo_send_command(pongo_device, "bootx\n");

    if(err < 0){
        printf("pongo_send_command: %s\n", libusb_error_name(err));
        goto err2;
    }

err2:
    munmap(xnuspy_ctl_imgdata, xnuspy_ctl_imgsz);
err1:
    munmap(module_data, module_size);
err0:;
    libusb_release_interface(pongo_device, 0);
    libusb_close(pongo_device);
    libusb_exit(NULL);
    return 0;
}

```

`module/Makefile`:

```
SDK = $(shell xcrun --sdk iphoneos --show-sdk-path)
CC = $(shell xcrun --sdk $(SDK) --find clang)
CFLAGS = -isysroot $(SDK) -arch arm64 -Wno-string-plus-int -fno-stack-protector
CFLAGS += -Wno-shorten-64-to-32 -D_FORTIFY_SOURCE=0 -nostdlib
CFLAGS += -DXNUSPY_PRIVATE -I$(RP)/include
LDFLAGS = -Xlinker -kext
OPDUMP = $(RP)/opdump/opdump

export CC
export CFLAGS
export OPDUMP
export SDK

TARGET_DIRS = common el1 el3 pf

all : $(TARGET_DIRS) preboot_hook.o xnuspy

.PHONY : target_dirs $(TARGET_DIRS)

target_dirs : $(TARGET_DIRS)

$(TARGET_DIRS) :
	$(MAKE) -C $@

OBJECT_FILES = $(shell find ./common ./pf ./el3 -type f -name "*.o")
INSTR_FILES = $(shell find $(RP)/include/xnuspy/el1 -type f -name "*_instrs.h")

ifneq ($(XNUSPY_TRAMP_PAGES), )
preboot_hook.o : CFLAGS += -DXNUSPY_TRAMP_PAGES=$(XNUSPY_TRAMP_PAGES)
endif

preboot_hook.o : $(INSTR_FILES) preboot_hook.c \
	$(RP)/include/common/preboot_hook.h \
	$(RP)/include/xnuspy/xnuspy_structs.h
	$(CC) $(CFLAGS) preboot_hook.c -c

xnuspy : $(OBJECT_FILES) xnuspy.c preboot_hook.o \
	$(RP)/include/common/common.h \
	$(RP)/include/pf/offsets.h \
	$(RP)/include/pf/pfs.h \
	$(RP)/include/xnuspy/xnuspy_ctl.h \
	$(RP)/include/xnuspy/xnuspy_structs.h
	$(CC) $(CFLAGS) $(LDFLAGS) $(OBJECT_FILES) preboot_hook.o xnuspy.c -o xnuspy

```

`module/README.md`:

```md
Directory structure:

common/
- miscellaneous functions and headers

el1/
- kernel code

el3/
- KPP patchfinder for A9 and its variants

pf/
- patchfinder code for the kernel

preboot_hook.c
- sets everything up for xnuspy_ctl and installs it

xnuspy.c
- gets kernel version, either exploits SEPROM, patches KPP, or neither, and
launches xnuspy's patchfinders

```

`module/common/Makefile`:

```
all : asm.o common.o

asm.o : asm.c $(RP)/include/asm/asm.h
	$(CC) $(CFLAGS) asm.c -c

common.o : common.c $(RP)/include/common/common.h
	$(CC) $(CFLAGS) common.c -c

```

`module/common/asm.c`:

```c
#include <stdint.h>

uint64_t sign_extend(uint64_t number, uint32_t numbits /* signbit */){
    if(number & ((uint64_t)1 << (numbits - 1)))
        return number | ~(((uint64_t)1 << numbits) - 1);

    return number;
}

uint64_t bits(uint64_t number, uint64_t start, uint64_t end){
    uint64_t amount = (end - start) + 1;
    uint64_t mask = (((uint64_t)1 << amount) - 1) << start;

    return (number & mask) >> start;
}

uint32_t assemble_adrp(uint64_t label, uint64_t pc, uint32_t Rd){
    label &= ~0xfffuLL;
    pc &= ~0xfffuLL;

    uint64_t dist = label - pc;

    return (1u << 31) | (1 << 28) | ((dist & 0x3000) << 17) |
        ((dist & 0x1ffffc000uLL) >> 9) | Rd;
}

uint32_t assemble_b(uint64_t from, uint64_t to){
    uint32_t imm26 = ((to - from) >> 2) & 0x3ffffff;
    return (5 << 26) | imm26;
}

uint32_t assemble_bl(uint64_t from, uint64_t to){
    uint32_t imm26 = ((to - from) >> 2) & 0x3ffffff;
    return (37u << 26) | imm26;
}

uint32_t assemble_csel(uint32_t sf, uint32_t Rm, uint32_t cond,
        uint32_t Rn, uint32_t Rd){
    return (sf << 31) | (0xd4 << 21) | (Rm << 16) | (cond << 12) | (Rn << 5) | Rd;
}

uint32_t assemble_immediate_add(uint32_t sf, uint32_t sh, uint32_t imm12,
        uint32_t Rn, uint32_t Rd){
    return (sf << 31) | (0x22 << 23) | (sh << 22) | (imm12 << 10) | (Rn << 5) | Rd;
}

/* this is really just SUBS RZR, Rn, #imm */
uint32_t assemble_immediate_cmp(uint32_t sf, uint32_t sh, uint32_t imm12,
        uint32_t Rn){
    return (sf << 31) | (0xe2 << 23) | (sh << 22) | (imm12 << 10) | (Rn << 5) | 0x1f;
}

/* No offset */
uint32_t assemble_immediate_ldr(uint32_t size, uint32_t Rn, uint32_t Rt){
    return (size << 30) | (0xe5 << 22) | (Rn << 5) | Rt;
}

/* No offset */
uint32_t assemble_immediate_prfm(uint32_t Rn, uint32_t Rt){
    return (0x3e6u << 22) | (Rn << 5) | Rt;
}

/* No offset */
uint32_t assemble_ldrsw(uint32_t Rn, uint32_t Rt){
    return (0x2e6u << 22) | (Rn << 5) | Rt;
}

/* No offset */
uint32_t assemble_simd_fp_ldr(uint32_t size, uint32_t opc, uint32_t Rn,
        uint32_t Rt){
    return (size << 30) | (0x3d << 24) | (opc << 22) | (Rn << 5) | Rt;
}

uint32_t assemble_mov(uint32_t sf, uint32_t imm, uint32_t Rd){
    uint32_t imm16 = imm & 0xffff;
    uint32_t hw = (imm & 0x30000);

    return (sf << 31) | (0xa5 << 23) | (hw << 21) | (imm16 << 5) | Rd;
}

/* resolves shift also */
uint64_t get_add_imm(uint32_t add){
    uint64_t imm = 0;

    uint8_t sh = (add & 0x200000) >> 22;
    uint32_t imm12 = (add & 0x3ffc00) >> 10;

    if(sh)
        imm = imm12 << 12;
    else
        imm = imm12;

    return imm;
}

uint64_t get_adr_target(uint32_t *adrp){
    uint32_t immlo = bits(*adrp, 29, 30);
    uint32_t immhi = bits(*adrp, 5, 23);

    return sign_extend((immhi << 2) | immlo, 21) + (uintptr_t)adrp;
}

uint64_t get_adrp_target(uint32_t *adrpp){
    uint32_t adrp = *adrpp;

    uint32_t immlo = bits(adrp, 29, 30);
    uint32_t immhi = bits(adrp, 5, 23);

    return sign_extend(((immhi << 2) | immlo) << 12, 32) +
        ((uintptr_t)adrpp & ~0xfffuLL);
}

uint64_t get_adrp_add_target(uint32_t *adrpp){
    uint32_t adrp = *adrpp;
    uint32_t add = *(adrpp + 1);

    int64_t addr = (int64_t)get_adrp_target(adrpp);

    return (uint64_t)(addr + (int64_t)bits(add, 10, 21));
}

uint64_t get_adrp_ldr_target(uint32_t *adrpp){
    uint32_t adrp = *adrpp;
    uint32_t ldr = *(adrpp + 1);

    int64_t addr = (int64_t)get_adrp_target(adrpp);

    /* for LDR, assuming unsigned immediate
     *
     * no shift on LDRB variants
     */
    uint32_t shift = 0;

    uint32_t size = bits(ldr, 30, 31);
    uint32_t V = bits(ldr, 26, 26);
    uint32_t opc = bits(ldr, 22, 23);
    uint32_t imm12 = bits(ldr, 10, 21);

    uint32_t ldr_type = (size << 3) | (V << 2) | opc;

    /* floating point variant */
    if(V)
        shift = ((opc >> 1) << 2) | size;
    /* LDRH || LDRSH (64 bit) || (LDRSH (32 bit) */
    else if(ldr_type == 9 || ldr_type == 10 || ldr_type == 11)
        shift = 1;
    /* LDRSW */
    else if(ldr_type == 18)
        shift = 2;
    /* LDR (32 bit) || LDR (64 bit) */
    else if(ldr_type == 17 || ldr_type == 25)
        shift = size;

    /* takes care of LDR */
    int64_t pimm = (int64_t)sign_extend(imm12, 12) << shift;

    return (uint64_t)(addr + pimm);
}

uint64_t get_pc_rel_target(uint32_t *adrpp){
    if(((adrpp[1] >> 25) & 5) == 4)
        /* only ldr */
        return get_adrp_ldr_target(adrpp);
    else if(*adrpp & 0x80000000)
        return get_adrp_add_target(adrpp);
    else
        return get_adr_target(adrpp);
}

uint64_t get_branch_dst(uint32_t branch, uint32_t *pc){
    intptr_t signed_pc = (intptr_t)pc;
    int32_t imm26 = (int32_t)sign_extend(bits(branch, 0, 25) << 2, 28);

    return (uint64_t)(signed_pc + imm26);
}

uint32_t *get_branch_dst_ptr(uint32_t *pc){
    uint32_t branch = *pc;
    intptr_t signed_pc = (intptr_t)pc;

    int32_t imm26 = (int32_t)sign_extend(bits(branch, 0, 25) << 2, 28);

    return (uint32_t *)(signed_pc + imm26);
}

uint64_t get_compare_and_branch_dst(uint32_t cab, uint32_t *pc){
    intptr_t signed_pc = (intptr_t)pc;
    int32_t imm19 = (int32_t)sign_extend(bits(cab, 5, 23) << 2, 21);

    return (uint64_t)(signed_pc + imm19);
}

uint64_t get_cond_branch_dst(uint32_t branch, uint32_t *pc){
    intptr_t signed_pc = (intptr_t)pc;
    int32_t imm19 = (int32_t)sign_extend(bits(branch, 5, 23) << 2, 21);

    return (uint64_t)(signed_pc + imm19);
}

uint64_t get_test_and_branch_dst(uint32_t tab, uint32_t *pc){
    intptr_t signed_pc = (intptr_t)pc;
    int32_t imm14 = (int32_t)sign_extend(bits(tab, 5, 18) << 2, 16);

    return (uint64_t)(signed_pc + imm14);
}

void write_blr(uint32_t reg, uint32_t *from, uint64_t to){
    /* movz */
    *(from++) = (uint32_t)(0xd2800000 | ((to & 0xffff) << 5) | reg);
    /* movk */
    *(from++) = (uint32_t)(0xf2800000 | (1 << 21) | (((to >> 16) & 0xffff) << 5) | reg);
    /* movk */
    *(from++) = (uint32_t)(0xf2800000 | (2 << 21) | (((to >> 32) & 0xffff) << 5) | reg);
    /* movk */
    *(from++) = (uint32_t)(0xf2800000 | (3 << 21) | (((to >> 48) & 0xffff) << 5) | reg);
    /* blr */
    *(from++) = (uint32_t)(0xd63f0000 | (reg << 5));
}

```

`module/common/common.c`:

```c
#include <mach-o/loader.h>
#include <stdbool.h>
#include <stdio.h>

#include <common/common.h>
#include <pf/offsets.h>

bool is_15_x__pongo(void){
    return g_kern_version_major == iOS_15_x;
}

bool is_14_5_and_above__pongo(void){
    if(g_kern_version_major <= iOS_13_x)
        return false;

    if (g_kern_version_major == iOS_14_x &&
        g_kern_version_minor < 4)
        return false;

    return true;
}

bool is_14_x_and_above__pongo(void){
    return g_kern_version_major >= iOS_14_x;
}

bool is_14_x_and_below__pongo(void){
    return g_kern_version_major <= iOS_14_x;
}

bool is_14_x__pongo(void){
    return g_kern_version_major == iOS_14_x;
}

bool is_13_x__pongo(void){
    return g_kern_version_major == iOS_13_x;
}

/* no sign support */
int atoi(const char *s){
    int res = 0;

    while(*s){
        res = res * 10 + (*s - '0');
        s++;
    }

    return res;
}

int isdigit(int c){
    return c >= '0' && c <= '9';
}

char *strcpy(char *dest, const char *src){
    char *src0 = (char *)src;
    while((*dest++ = *src0++));
    *dest = '\0';
    /* who cares about strcpy return value */
    return dest;
}

char *strstr(const char *haystack, const char *needle){
    if(!*needle)
        return (char *)haystack;

    char *hay = (char *)haystack;
    char *n = (char *)needle;

    for(; *hay; hay++){
        if(*hay != *n)
            continue;

        char *h = hay;

        for(;;){
            if(!*n)
                return hay;

            if(*h++ != *n++)
                break;
        }

        n = (char *)needle;
    }

    return NULL;
}

struct mach_header_64 *mh_execute_header = NULL;
uint64_t kernel_slide = 0;

/* XXX do not panic so user can see what screen says */
__attribute__ ((noreturn)) void xnuspy_fatal_error(void){
    puts("xnuspy: fatal error.");
    puts("     Please file an issue");
    puts("     on Github. Include");
    puts("     output up to this");
    puts("     point and device/iOS");
    puts("     version.");
    puts("Spinning forever.");

    for(;;);
}

```

`module/el1/Makefile`:

```
ASM_INSTR_HDRS = $(patsubst %.s, $(RP)/include/xnuspy/el1/%_instrs.h, $(wildcard *.s))
TARGET_DIRS = xnuspy_ctl

all : $(ASM_INSTR_HDRS) target_dirs

$(RP)/include/xnuspy/el1/%_instrs.h : %.s %.h \
	$(RP)/include/asm/asm_support.h $(RP)/include/xnuspy/xnuspy_cache.h
	$(eval OUTFILE = $(subst .s,,$<))
	$(CC) -arch arm64 -isysroot $(SDK) -I$(RP)/include -e _$(OUTFILE) $< -o $(OUTFILE)
	$(OPDUMP) -td -i ./$(OUTFILE) -a $(OUTFILE) -o $(OUTFILE)_instrs.h
	mv $(OUTFILE)_instrs.h $(RP)/include/xnuspy/el1/

.PHONY : target_dirs $(TARGET_DIRS)

target_dirs : $(TARGET_DIRS)

$(TARGET_DIRS) :
	$(MAKE) -C $@

```

`module/el1/hook_system_check_sysctlbyname_hook.h`:

```h
#ifndef HOOK_SYSTEM_CHECK_SYSCTLBYNAME_HOOK
#define HOOK_SYSTEM_CHECK_SYSCTLBYNAME_HOOK

#define STACK                       (0x200)

#define KALLOC_SZ                   (STACK-0xb0)
#define SYSCTL_NAME_SPACE           (STACK-0xf0)

/* sysctl stuff */
#define CTL_MAXNAME                 (12)

#define SIZEOF_STRUCT_SYSCTL_OID    (0x50)

#define OFFSETOF_OID_PARENT         (0x0)
#define OFFSETOF_OID_LINK           (0x8)
#define OFFSETOF_OID_NUMBER         (0x10)
#define OFFSETOF_OID_KIND           (0x14)
#define OFFSETOF_OID_ARG1           (0x18)
#define OFFSETOF_OID_ARG2           (0x20)
#define OFFSETOF_OID_NAME           (0x28)
#define OFFSETOF_OID_HANDLER        (0x30)
#define OFFSETOF_OID_FMT            (0x38)
#define OFFSETOF_OID_DESCR          (0x40)
#define OFFSETOF_OID_VERSION        (0x48)
#define OFFSETOF_OID_REFCNT         (0x4c)

#define OID_AUTO                    (-1)

#define CTLTYPE_INT                 (2)
#define CTLFLAG_OID2                (0x00400000)
#define CTLFLAG_ANYBODY             (0x10000000)
#define CTLFLAG_RD                  (0x80000000)

#define SYSCTL_OID_VERSION          (1)

#endif

```

`module/el1/hook_system_check_sysctlbyname_hook.s`:

```s
#include <asm/asm_support.h>
#include <xnuspy/xnuspy_cache.h>

#include "hook_system_check_sysctlbyname_hook.h"

.align 2
.global _hook_system_check_sysctlbyname_hook

_hook_system_check_sysctlbyname_hook:
    sub sp, sp, STACK
    /* We branched when parameters were being copied to callee-saved
    registers */
    stp x7, x6, [sp, #(STACK-0xa0)]
    stp x5, x4, [sp, #(STACK-0x90)]
    stp x3, x2, [sp, #(STACK-0x80)]
    stp x1, x0, [sp, #(STACK-0x70)]
    stp x28, x27, [sp, #(STACK-0x60)]
    stp x26, x25, [sp, #(STACK-0x50)]
    stp x24, x23, [sp, #(STACK-0x40)]
    stp x22, x21, [sp, #(STACK-0x30)]
    stp x20, x19, [sp, #(STACK-0x20)]
    stp x29, x30, [sp, #(STACK-0x10)]
    add x29, sp, #(STACK-0x10)

    adr x19, addrof_xnuspy_cache
    ldr x28, [x19]

    /* MIB array */
    mov x19, x2
    /* Length of MIB array */
    mov w20, w3

    /* This function does not take sysctl_geometry_lock */
    mov x0, x28
    bl _get_sysctl_geo_lck
    ldr x21, [x28, LCK_RW_LOCK_SHARED]
    blr x21
    /* If this sysctl hasn't been added yet, register it */
    ldr x21, [x28, DID_REGISTER_SYSCTL]
    cbz x21, Lregister_xnuspy_ctl_callnum_sysctl
    ldr x21, [x28, XNUSPY_SYSCTL_MIB_COUNT_PTR]
    ldr w21, [x21]
    /* Not the same length? Definitely not ours */
    cmp w21, w20
    b.ne Lnot_ours

    /* Same length, so compare MIB contents. Setting up for mib_check_loop:
    X21: pointer to kern.xnuspy_ctl_callnum MIB array
    X22: pointer to passed in MIB array
    X23: pointer to the end of our MIB array. If we're here, the MIB array
         parameter is the same length of ours.
    X24-X26: scratch registers
    */
    ldr x21, [x28, XNUSPY_SYSCTL_MIB_PTR]
    mov x22, x19
    add x23, x21, x20, lsl #0x2

Lmib_check_loop:
    ldr w24, [x21], #0x4
    ldr w25, [x22], #0x4
    /* One mismatched elem and we know it isn't ours */
    cmp w24, w25
    b.ne Lnot_ours
    /* If we hit the end of our MIB array, it's ours */
    subs x26, x23, x21
    cbnz x26, Lmib_check_loop

Lours:
    mov x0, x28
    bl _get_sysctl_geo_lck
    ldr x19, [x28, LCK_RW_DONE]
    blr x19
    /* If it is ours, branch right to hook_system_check_sysctlbyname's
    epilogue, returning no error */
    ldr x1, [x28, H_S_C_SBN_EPILOGUE_ADDR]
    add sp, sp, STACK
    mov x0, xzr
    br x1
    /* Not reached */

Lregister_xnuspy_ctl_callnum_sysctl:
    mov x0, x28
    bl _get_sysctl_geo_lck
    ldr x19, [x28, LCK_RW_DONE]
    blr x19

    mov x0, SIZEOF_STRUCT_SYSCTL_OID
    ldr x19, [x28, IOS_VERSION]
    cmp x19, iOS_13_x
    b.eq LiOS_13_x_kalloc

    ldr x19, [x28, KALLOC_EXTERNAL]
    blr x19

    b Lregister

LiOS_13_x_kalloc:
    str x0, [sp, KALLOC_SZ]
    add x0, sp, KALLOC_SZ
    mov x1, xzr
    mov w2, wzr
    ldr x19, [x28, KALLOC_CANBLOCK]
    blr x19

Lregister:
    cbz x0, Lnot_ours

    ldr x19, [x28, SYSCTL__KERN_CHILDREN_PTR]
    str x19, [x0, OFFSETOF_OID_PARENT]
    str xzr, [x0, OFFSETOF_OID_LINK]
    mov w19, OID_AUTO
    str w19, [x0, OFFSETOF_OID_NUMBER]
    mov w19, CTLTYPE_INT
    orr w19, w19, CTLFLAG_RD
    orr w19, w19, CTLFLAG_ANYBODY
    orr w19, w19, CTLFLAG_OID2
    str w19, [x0, OFFSETOF_OID_KIND]
    add x19, x28, XNUSPY_CTL_CALLNUM
    str x19, [x0, OFFSETOF_OID_ARG1]
    str wzr, [x0, OFFSETOF_OID_ARG2]
    adr x19, oid_name
    /* Skip "kern." */
    add x19, x19, #0x5
    str x19, [x0, OFFSETOF_OID_NAME]
    ldr x19, [x28, SYSCTL_HANDLE_LONG]
    str x19, [x0, OFFSETOF_OID_HANDLER]
    adr x19, oid_fmt
    str x19, [x0, OFFSETOF_OID_FMT]
    adr x19, oid_descr
    str x19, [x0, OFFSETOF_OID_DESCR]
    mov w19, SYSCTL_OID_VERSION
    str w19, [x0, OFFSETOF_OID_VERSION]
    str wzr, [x0, OFFSETOF_OID_REFCNT]

    ldr x19, [x28, SYSCTL_REGISTER_OID]
    blr x19

    /* Figure out what the MIB array looks like for this new sysctl.
    Unfortunately I can't just reserve space for this because this
    page is r-x. name2oid expects sysctl_geometry_lock to be held */
    mov x0, x28
    bl _get_sysctl_geo_lck
    ldr x19, [x28, LCK_RW_LOCK_SHARED]
    blr x19

    /* name2oid modifies the first parameter, so we need to deep copy */
    adr x0, oid_name
    add x1, sp, SYSCTL_NAME_SPACE

Lcopy_name:
    ldrb w2, [x0], #0x1
    strb w2, [x1], #0x1
    cmp w2, wzr
    b.ne Lcopy_name

    add x0, sp, SYSCTL_NAME_SPACE
    ldr x1, [x28, XNUSPY_SYSCTL_MIB_PTR]
    ldr x2, [x28, XNUSPY_SYSCTL_MIB_COUNT_PTR]
    ldr x19, [x28, NAME2OID]
    blr x19

    mov x19, #0x1
    str x19, [x28, DID_REGISTER_SYSCTL]

Lnot_ours:
    mov x0, x28
    bl _get_sysctl_geo_lck
    ldr x19, [x28, LCK_RW_DONE]
    blr x19
    ldp x29, x30, [sp, #(STACK-0x10)]
    ldp x20, x19, [sp, #(STACK-0x20)]
    ldp x22, x21, [sp, #(STACK-0x30)]
    ldp x24, x23, [sp, #(STACK-0x40)]
    ldp x26, x25, [sp, #(STACK-0x50)]
    ldp x28, x27, [sp, #(STACK-0x60)]
    ldp x1, x0, [sp, #(STACK-0x70)]
    ldp x3, x2, [sp, #(STACK-0x80)]
    ldp x5, x4, [sp, #(STACK-0x90)]
    ldp x7, x6, [sp, #(STACK-0xa0)]
    add sp, sp, STACK
    .space (5*4), OPCODE_PLACEHOLDER_BYTE
    /* xnuspy will write back the instructions we overwrote in the space
    above inside install_h_s_c_sbn_hook (preboot_hook.c) */
    ret

/* These are still in __text, so clang treats them as code. Four byte align
    them so clang doesn't complain */
addrof_xnuspy_cache: .dword QWORD_PLACEHOLDER
oid_name: .asciz "kern.xnuspy_ctl_callnum"
.align 2
oid_descr: .asciz "query for xnuspy_ctl's call number"
.align 2
oid_fmt: .asciz "L"
/* Align so we can write four bytes every time and not have to worry about
    scratch_space being unaligned when we go to write other instructions */
.align 2

/* Cursed case: are we on 14.5 or above? If we are, we get a pointer to
sysctl_geometry_lock from *(xnuspy_cache+SYSCTL_GEOMETRY_LOCK_PTR),
as opposed to a pointer to a pointer to sysctl_geometry_lock on
13.0 - 14.4.2. This is the case for both old and new 14.5 kernels.
This is apparently also the case for 15.x.

One parameter, a pointer to the xnuspy cache. Returns a pointer to
sysctl_geometry_lock */
.align 2
_get_sysctl_geo_lck:
    stp x19, x20, [sp, #-0x10]!
    stp x29, x30, [sp, #-0x10]!

    ldr x19, [x0, SYSCTL_GEOMETRY_LOCK_PTR]
    ldr x20, [x0, IOS_VERSION]
    cmp x20, iOS_13_x
    b.eq Lout_not_14_5
    cmp x20, iOS_15_x
    b.eq Lout_14_5_and_above_cursed_case
    ldr x20, [x0, KERN_VERSION_MINOR]
    cmp x20, #0x4
    /* ge in case a new version of 14 is released that does the
    same thing 14.5 does */
    b.ge Lout_14_5_and_above_cursed_case

Lout_not_14_5:
    ldr x0, [x19]
    b Lout

Lout_14_5_and_above_cursed_case:
    mov x0, x19

Lout:
    ldp x29, x30, [sp], #0x10
    ldp x19, x20, [sp], #0x10
    ret

```

`module/el1/xnuspy_ctl/Makefile`:

```
OBJECT_FILES = debug.o libc.o mem.o pte.o tramp.o utils.o wrappers.o

ASM_DEP = ../../common/asm.o
EXTERNAL_DEPS = $(RP)/include/xnuspy/el1/externs.h \
				$(RP)/include/xnuspy/xnuspy_ctl.h \
				$(RP)/include/xnuspy/xnuspy_structs.h

CFLAGS += -mkernel -Wswitch-enum

ifeq ($(XNUSPY_DEBUG), 1)
	CFLAGS += -DXNUSPY_DEBUG
endif

ifeq ($(XNUSPY_SERIAL), 1)
	CFLAGS += -DXNUSPY_SERIAL
endif

ifneq ($(XNUSPY_LEAKED_PAGE_LIMIT), )
	CFLAGS += -DXNUSPY_LEAKED_PAGE_LIMIT=$(XNUSPY_LEAKED_PAGE_LIMIT)
endif

LDFLAGS = -Xlinker -kext 

all : $(OBJECT_FILES) xnuspy_ctl

# %.o will match all object files, so in case someone's clang decides to
# leave a leftover xnuspy_ctl.o I do it like this
debug.o : debug.c $(RP)/include/xnuspy/el1/debug.h $(EXTERNAL_DEPS)
	$(CC) $(CFLAGS) debug.c -c

libc.o : libc.c $(RP)/include/xnuspy/el1/libc.h $(EXTERNAL_DEPS)
	$(CC) $(CFLAGS) libc.c -c

mem.o : mem.c $(RP)/include/xnuspy/el1/mem.h $(EXTERNAL_DEPS)
	$(CC) $(CFLAGS) mem.c -c

pte.o : pte.c $(RP)/include/xnuspy/el1/pte.h $(EXTERNAL_DEPS)
	$(CC) $(CFLAGS) pte.c -c

tramp.o : tramp.c $(RP)/include/xnuspy/el1/tramp.h $(ASM_DEP) $(EXTERNAL_DEPS)
	$(CC) $(CFLAGS) tramp.c -c

utils.o : utils.c $(RP)/include/xnuspy/el1/utils.h $(EXTERNAL_DEPS)
	$(CC) $(CFLAGS) utils.c -c

wrappers.o : wrappers.c $(RP)/include/xnuspy/el1/wrappers.h $(EXTERNAL_DEPS)
	$(CC) $(CFLAGS) wrappers.c -c

xnuspy_ctl : $(OBJECT_FILES) $(ASM_DEP) $(EXTERNAL_DEPS) xnuspy_ctl.c
	$(CC) $(CFLAGS) $(LDFLAGS) $(OBJECT_FILES) $(ASM_DEP) xnuspy_ctl.c \
		-o xnuspy_ctl

```

`module/el1/xnuspy_ctl/debug.c`:

```c
#include <mach/mach.h>
#include <stdbool.h>
#include <stdint.h>

#include <xnuspy/xnuspy_ctl.h>

#include <xnuspy/el1/debug.h>
#include <xnuspy/el1/externs.h>
#include <xnuspy/el1/mem.h>

void desc_freelist(void){
    lck_rw_lock_shared(xnuspy_rw_lck);

    SPYDBG("[Freelist] ");

    if(STAILQ_EMPTY(&freelist)){
        lck_rw_done(xnuspy_rw_lck);
        SPYDBG("Empty\n");
        return;
    }

    SPYDBG("FRONT: ");

    struct stailq_entry *entry;

    STAILQ_FOREACH(entry, &freelist, link)
        SPYDBG("%#llx <- ", entry->elem);

    SPYDBG("\n");

    lck_rw_done(xnuspy_rw_lck);
}

void desc_xnuspy_shmem(struct xnuspy_shmem *xs){
    if(!xs){
        SPYDBG("%s: NULL\n", __func__);
        return;
    }

    SPYDBG("This xnuspy_shmem object is at %p\n", xs);
    SPYDBG("\tRange: [%p, %p)\n", xs->shm_base,
            (uintptr_t)xs->shm_base + xs->shm_sz);
    SPYDBG("\tMemory entry: %p\n", xs->shm_entry);
    SPYDBG("\tOrigin map: %p\n", xs->shm_map_from);
    SPYDBG("\tDestination map: %p\n", xs->shm_map_to);
}

/* XXX ONLY meant to be called from xnuspy_gc_thread, hence the lack
 * of locking. */
void desc_unmaplist(void){
    SPYDBG("[Unmaplist] ");

    if(STAILQ_EMPTY(&unmaplist)){
        SPYDBG("Empty\n");
        return;
    }

    SPYDBG("FRONT: ");

    struct stailq_entry *entry;

    STAILQ_FOREACH(entry, &unmaplist, link)
        SPYDBG("%#llx <- ", entry->elem);

    SPYDBG("\n");
}

void desc_usedlist(void){
    lck_rw_lock_shared(xnuspy_rw_lck);

    SPYDBG("[Usedlist] ");

    if(STAILQ_EMPTY(&usedlist)){
        lck_rw_done(xnuspy_rw_lck);
        SPYDBG("Empty\n");
        return;
    }

    struct stailq_entry *entry;

    STAILQ_FOREACH(entry, &usedlist, link)
        SPYDBG("%#llx -> ", entry->elem);

    SPYDBG("\n");

    lck_rw_done(xnuspy_rw_lck);
}

static void _desc_xnuspy_mapping(struct xnuspy_mapping *m){
    struct xnuspy_shmem *xs = m->segment_shmem;

    SPYDBG("\tMapping metadata refcnt: %lld\n", m->refcnt);
    SPYDBG("\tMemory entry: %p\n", xs->shm_entry);
    SPYDBG("\tUserspace Mach-O header source: %#llx\n", m->mapping_addr_uva);
    SPYDBG("\tShared mapping addr/size: %p/%#llx\n", xs->shm_base,
            (uintptr_t)xs->shm_base + xs->shm_sz);

    SPYDBG("\tDeath callback: ");

    if(m->death_callback)
        SPYDBG("%#llx\n", m->death_callback);
    else
        SPYDBG("none\n");
}

void desc_xnuspy_mapping(struct xnuspy_mapping *m){
    struct xnuspy_shmem *xs = m->segment_shmem;

    SPYDBG("Mapping metadata refcnt: %lld\n", m->refcnt);
    SPYDBG("Memory entry: %p\n", xs->shm_entry);
    SPYDBG("Userspace Mach-O header source: %#llx\n", m->mapping_addr_uva);
    SPYDBG("Shared mapping addr/size: %p/%#llx\n", xs->shm_base,
            (uintptr_t)xs->shm_base + xs->shm_sz);

    SPYDBG("Death callback: ");

    if(m->death_callback)
        SPYDBG("%#llx\n", m->death_callback);
    else
        SPYDBG("none\n");
}

void desc_xnuspy_mapping_metadata(struct xnuspy_mapping_metadata *mm){
    SPYDBG("Owner: %d\n", mm->owner);
    SPYDBG("Mappings:\n");

    if(SLIST_EMPTY(&mm->mappings)){
        SPYDBG("none\n");
        return;
    }

    struct slist_entry *entry;

    SLIST_FOREACH(entry, &mm->mappings, link){
        struct xnuspy_mapping *m = entry->elem;
        _desc_xnuspy_mapping(m);
        SPYDBG("\n");
    }
}

void desc_xnuspy_tramp(struct xnuspy_tramp *t, uint32_t orig_tramp_len){
    SPYDBG("This xnuspy_tramp is @ %#llx\n", (uint64_t)t);
    SPYDBG("Replacement: %#llx\n", t->replacement);
    
    SPYDBG("Replacement trampoline:\n");

    for(int i=0; i<sizeof(t->tramp)/sizeof(t->tramp[0]); i++)
        SPYDBG("\ttramp[%d]    %#x\n", i, t->tramp[i]);

    SPYDBG("Original trampoline:\n");

    for(int i=0; i<orig_tramp_len; i++)
        SPYDBG("\ttramp[%d]    %#x\n", i, t->orig[i]);

    if(!t->tramp_metadata)
        SPYDBG("NULL tramp metadata\n");
    else{
        SPYDBG("Hooked function: %#llx [unslid=%#llx]\n",
                t->tramp_metadata->hooked,
                t->tramp_metadata->hooked - kernel_slide);

        SPYDBG("Original instruction: %#x\n", t->tramp_metadata->orig_instr);
    }

    if(!t->mapping_metadata)
        SPYDBG("NULL mapping metadata\n");
    else
        desc_xnuspy_mapping_metadata(t->mapping_metadata);
}

```

`module/el1/xnuspy_ctl/libc.c`:

```c
/* libc functions that aren't hyper-optimized inside the kernel that I can
 * just reimplement here. This saves me the trouble of writing a ton of
 * patchfinders */

#include <stddef.h>
#include <stdint.h>

#include <xnuspy/el1/externs.h>

void bzero(void *p, size_t n){
    uint8_t *p0 = p;
    uint8_t *p_end = p0 + n;

    while(p0 < p_end)
        *p0++ = '\0';
}

void *memchr(const void *s, int c, size_t n){
    if(!n)
        return NULL;

    uint8_t *sp = (uint8_t *)s;

    for(size_t i=0; i<n; i++){
        if(sp[i] == c)
            return &sp[i];
    }

    return NULL;
}

int memcmp(const void *s1, const void *s2, size_t n){
    if(!n)
        return 0;

    uint8_t *s1p = (uint8_t *)s1, *s2p = (uint8_t *)s2;

    do {
        if(*s1p++ != *s2p++)
            return *--s1p - *--s2p;

    } while (--n);

    return 0;
}

void *memmem(const void *big, size_t blen, const void *little, size_t llen){
    if(!blen || !llen)
        return NULL;

    if(llen > blen)
        return NULL;

    const char *bs = (const char *)big;
    const char *ls = (const char *)little;

    if(llen == 1)
        return memchr(big, (int)*ls, blen);

    char *limit = (char *)bs + (blen - llen);
    char *cursor;

    for(cursor = (char *)bs; cursor <= limit; cursor++){
        if(*cursor != *ls)
            continue;

        if(memcmp(cursor, ls, llen) == 0)
            return cursor;
    }

    return NULL;
}

void *memrchr(const void *s, int c, size_t n){
    if(!n)
        return NULL;

    uint8_t *sp = (uint8_t *)s + n;

    do {
        if(*(--sp) == (uint8_t)c)
            return sp;
    } while (--n != 0);

    return NULL;
}

char *strchr(const char *s, int c){
    char *sp = (char *)s;

    for(; *sp != (char)c; ++sp){
        if(!*sp)
            return NULL;
    }

    return sp;
}

char *strrchr(const char *s, int c){
    char *lastp = NULL;
    char *sp = (char *)s;

    do {
        if(*sp == (char)c)
            lastp = sp;
    } while (*sp++);

    return lastp;
}

int strcmp(const char *s1, const char *s2){
    while(*s1 && (*s1 == *s2)){
        s1++;
        s2++;
    }

    return *(const unsigned char *)s1 - *(const unsigned char *)s2;
}

char *strstr(const char *big, const char *little){
    size_t blen = _strlen(big);
    size_t llen = _strlen(little);

    if(!llen)
        return (char *)big;

    if(llen > blen)
        return NULL;

    char *limit = (char *)big + (blen - llen);
    char *cursor;

    for(cursor = (char *)big; cursor <= limit; cursor++){
        if(memcmp(cursor, little, llen) == 0)
            return cursor;
    }

    return NULL;
}

char *strnstr(const char *big, const char *little, size_t n){
    size_t llen = _strlen(little);

    if(!llen)
        return (char *)big;

    if(llen > n)
        return NULL;

    char *limit = (char *)big + (n - llen);
    char *cursor;

    for(cursor = (char *)big; cursor <= limit; cursor++){
        if(memcmp(cursor, little, llen) == 0)
            return cursor;
    }

    return NULL;
}

```

`module/el1/xnuspy_ctl/mem.c`:

```c
#include <errno.h>
#include <mach/mach.h>
#include <stdbool.h>
#include <stdint.h>
#include <unistd.h>

#include <xnuspy/xnuspy_ctl.h>

#include <xnuspy/el1/debug.h>
#include <xnuspy/el1/externs.h>
#include <xnuspy/el1/pte.h>
#include <xnuspy/el1/utils.h>
#include <xnuspy/el1/wrappers.h>

__attribute__ ((naked)) uint64_t kvtophys(uint64_t kaddr){
    asm volatile(""
            "mrs x1, DAIF\n"
            "msr DAIFSet, #0xf\n"
            "at s1e1r, x0\n"
            "mrs x2, par_el1\n"
            "msr DAIF, x1\n"
            "tbnz x2, 0x0, 5f\n"
            "and x2, x2, 0xfffffffff000\n"
            "and x1, x0, 0x3fff\n"
            "orr x0, x2, x1\n"
            "b 3f\n"
            "5:\n"
            "mov x0, xzr\n"
            "3:\n"
            "ret\n"
            );
}

__attribute__ ((naked)) uint64_t uvtophys(uint64_t kaddr){
    asm volatile(""
            "mrs x1, DAIF\n"
            "msr DAIFSet, #0xf\n"
            "at s1e0r, x0\n"
            "mrs x2, par_el1\n"
            "msr DAIF, x1\n"
            "tbnz x2, 0x0, 5f\n"
            "and x2, x2, 0xfffffffff000\n"
            "and x1, x0, 0x3fff\n"
            "orr x0, x2, x1\n"
            "b 3f\n"
            "5:\n"
            "mov x0, xzr\n"
            "3:\n"
            "ret\n"
            );
}

void dcache_clean_PoU(void *address, size_t size){
    const size_t cache_line_size = 64;

    size = (size + cache_line_size) & ~(cache_line_size - 1);

    uint64_t start = ((uint64_t)address & ~(cache_line_size - 1));
    uint64_t end = start + size;

    asm volatile("isb sy");

    do {
        asm volatile(""
                "dc cvau, %0\n"
                "dsb ish\n"
                "isb sy\n"
                : : "r" (start));

        start += cache_line_size;
    } while (start < end);
}

void icache_invalidate_PoU(void *address, size_t size){
    const size_t cache_line_size = 64;

    size = (size + cache_line_size) & ~(cache_line_size - 1);

    uint64_t start = ((uint64_t)address & ~(cache_line_size - 1));
    uint64_t end = start + size;

    asm volatile("isb sy");

    do {
        asm volatile(""
                "ic ivau, %0\n"
                "dsb ish\n"
                "isb sy\n"
                : : "r" (start));

        start += cache_line_size;
    } while (start < end);
}

/* Write to static kernel memory, using bcopy_phys.
 *
 * Parameters:
 *  dst: kernel virtual address of destination
 *  buf: kernel virtual address of data
 *  sz:  how many bytes 'buf' is
 *
 * Returns: nothing
 */
void kwrite_static(void *dst, void *buf, size_t sz){
    uint64_t dst_phys = kvtophys((uint64_t)dst);
    uint64_t buf_phys = kvtophys((uint64_t)buf);

    bcopy_phys(buf_phys, dst_phys, sz);
}

static int protect_common(uint64_t vaddr, uint64_t size, vm_prot_t prot,
        uint32_t el){  
    /* Memory must be readable for EL1 */
    if(!(prot & VM_PROT_READ) && el == 1)
        return 1;

    /* Round size up to the nearest page if not already a multiple of PAGE_SIZE */
    if(size & 0xfff)
        size = (size + PAGE_SIZE) & ~(PAGE_SIZE - 1);

    uint64_t target_region_cur = vaddr & ~(PAGE_SIZE - 1);
    uint64_t target_region_end = (vaddr + size) & ~(PAGE_SIZE - 1);

    /* Determine the equivalent PTE protections of 'prot'. Assume caller only
     * wants read permissions. */
    uint64_t new_pte_ap;

    if(el == 0)
        new_pte_ap = ARM_PTE_AP(AP_RORO);
    else
        new_pte_ap = ARM_PTE_AP(AP_RONA);

    if(prot & VM_PROT_WRITE){
        if(el == 0)
            new_pte_ap = ARM_PTE_AP(AP_RWRW);
        else
            new_pte_ap = ARM_PTE_AP(AP_RWNA);
    }

    while(target_region_cur < target_region_end){
        pte_t *ptep;

        if(el == 0)
            ptep = el0_ptep((void *)target_region_cur);
        else
            ptep = el1_ptep((void *)target_region_cur);

        pte_t new_pte = (*ptep & ~ARM_PTE_APMASK) | new_pte_ap;

        new_pte &= ~(ARM_PTE_NX | ARM_PTE_PNX);

        if(prot & VM_PROT_EXECUTE){
            if(el == 0)
                new_pte |= ARM_PTE_PNX;
            else
                new_pte |= ARM_PTE_NX;
        }

        kwrite_static(ptep, &new_pte, sizeof(new_pte));

        target_region_cur += PAGE_SIZE;
    }

    tlb_flush();

    return 0;
}

/* Change protections of kernel memory at the page table level.
 *
 * Parameters:
 *  kaddr: kernel virtual address of target
 *  size:  the number of bytes in the target region
 *  prot:  protections to apply
 *
 * Returns:
 *  zero if successful, non-zero otherwise
 */
int kprotect(void *kaddr, uint64_t size, vm_prot_t prot){
    return protect_common((uint64_t)kaddr, size, prot, 1);
}

/* Change protections of user memory at the page table level.
 *
 * Parameters:
 *  uaddr: EL0 virtual address of target
 *  size:  the number of bytes in the target region
 *  prot:  protections to apply
 *
 * Returns:
 *  zero if successful, non-zero otherwise
 */
int uprotect(void *uaddr, uint64_t size, vm_prot_t prot){
    return protect_common((uint64_t)uaddr, size, prot, 0);
}

void kwrite_instr(uint64_t dst, uint32_t instr){
    kprotect((void *)dst, sizeof(uint32_t), VM_PROT_READ | VM_PROT_WRITE |
            VM_PROT_EXECUTE);

    *(uint32_t *)dst = instr;

    dcache_clean_PoU((void *)dst, sizeof(uint32_t));
    icache_invalidate_PoU((void *)dst, sizeof(uint32_t));

    kprotect((void *)dst, sizeof(uint32_t), VM_PROT_READ | VM_PROT_EXECUTE);
}

static int mkshmem_common(uint64_t start, uint64_t sz, vm_prot_t prot,
        struct _vm_map *from, struct _vm_map *to,
        struct xnuspy_shmem *shmemp){
    int retval = 0;

    kern_return_t kret = vm_map_wire_external(from, start, sz,
            VM_PROT_READ, from != *kernel_mapp);

    if(kret){
        SPYDBG("%s: vm_map_wire_external failed when wiring down "
                "[%#llx,%#llx): %#x\n", __func__, start, start+sz, kret);
        retval = mach_to_bsd_errno(kret);
        goto failed;
    }

    vm_prot_t shm_prot = VM_PROT_READ;

    /* ipc_port_t */
    void *shm_entry = NULL;

    uint64_t sz_before = sz;

    kret = _mach_make_memory_entry_64(from, &sz, start,
            MAP_MEM_VM_SHARE | shm_prot, &shm_entry, NULL);

    if(kret){
        SPYDBG("%s: mach_make_memory_entry_64 failed: %d\n", __func__, kret);
        retval = mach_to_bsd_errno(kret);
        goto failed_unwire_orig_pages;
    }

    if(sz_before != sz){
        SPYDBG("%s: did not map the entirety of sz? got %#llx, "
                "expected %#llx\n", __func__, sz, sz_before);
        /* Probably not the best option */
        retval = EIO;
        goto failed_dealloc_shm_entry;
    }

    uint64_t shm_addr = 0;

    kret = mach_vm_map_external(to, &shm_addr, sz, 0, VM_FLAGS_ANYWHERE,
            shm_entry, 0, 0, shm_prot, shm_prot, VM_INHERIT_NONE);

    if(kret){
        SPYDBG("%s: mach_vm_map_external failed: %d\n", __func__, kret);
        retval = mach_to_bsd_errno(kret);
        goto failed_dealloc_shm_entry;
    }

    kret = vm_map_wire_external(to, shm_addr, shm_addr + sz,
            shm_prot, to != *kernel_mapp);

    if(kret){
        SPYDBG("%s: vm_map_wire_external failed: %d\n", __func__, kret);
        retval = mach_to_bsd_errno(kret);
        goto failed_dealloc_created_mapping;
    }

    shmemp->shm_base = (void *)shm_addr;
    shmemp->shm_sz = sz;
    shmemp->shm_entry = shm_entry;
    shmemp->shm_map_from = from;
    shmemp->shm_map_to = to;

    vm_map_reference(shmemp->shm_map_from);
    vm_map_reference(shmemp->shm_map_to);

    /* Set requested protections on the new mapping. We leave the
     * original pages alone. */
    if(to == *kernel_mapp)
        kprotect(shmemp->shm_base, shmemp->shm_sz, prot);
    else
        uprotect(shmemp->shm_base, shmemp->shm_sz, prot);

    return 0;

failed_dealloc_created_mapping:
    _vm_deallocate(to, shm_addr, sz);
failed_dealloc_shm_entry:
    ipc_port_release_send_wrapper(shm_entry);
failed_unwire_orig_pages:
    vm_map_unwire_wrapper(from, start, start + sz, from != *kernel_mapp);
failed:
    return retval;
}

/* This maps kernel pages into userspace as shared memory.
 * On success, it returns 0 and sets the two output parameters.
 * On failure, it returns non-zero. */
int mkshmem_ktou(uint64_t kaddr, uint64_t sz, vm_prot_t prot,
        struct xnuspy_shmem *shmemp){
    return mkshmem_common(kaddr, sz, prot, *kernel_mapp,
            current_map(), shmemp);
}

/* Same as the above function, but this maps userspace pages into the
 * kernel as shared memory. */
int mkshmem_utok(uint64_t uaddr, uint64_t sz, vm_prot_t prot,
        struct xnuspy_shmem *shmemp){
    return mkshmem_common(uaddr, sz, prot, current_map(),
            *kernel_mapp, shmemp);
}

/* Allows specification of source/destination maps */
int mkshmem_raw(uint64_t addr, uint64_t sz, vm_prot_t prot,
        struct _vm_map *from, struct _vm_map *to,
        struct xnuspy_shmem *shmemp){
    return mkshmem_common(addr, sz, prot, from, to, shmemp);
}

int shmem_destroy(struct xnuspy_shmem *shmemp){
    int retval = 0;

    ipc_port_release_send_wrapper(shmemp->shm_entry);

    kern_return_t kret = vm_map_unwire_wrapper(shmemp->shm_map_to,
            (uint64_t)shmemp->shm_base,
            (uint64_t)shmemp->shm_base + shmemp->shm_sz,
            shmemp->shm_map_to != *kernel_mapp);

    /* I don't know if it's safe to deallocate if we failed to unwire.
     * But if this failed because we tried to unwire some userspace
     * mapping after its task has died, then the pages of the userspace
     * shmem won't be in its vm_map anymore. That's fine, we'll just
     * release the references we hold on both maps. */
    if(kret){
        SPYDBG("%s: vm_map_unwire failed: %#x\n", __func__, kret);
        retval = mach_to_bsd_errno(kret);
        goto out;
    }

    kret = _vm_deallocate(shmemp->shm_map_to, (uint64_t)shmemp->shm_base,
            shmemp->shm_sz);

    if(kret){
        SPYDBG("%s: vm_deallocate failed: %#x\n", __func__, kret);
        retval = mach_to_bsd_errno(kret);
    }

out:;
    vm_map_deallocate(shmemp->shm_map_from);
    vm_map_deallocate(shmemp->shm_map_to);

    return retval;
}

struct unifiedhdr {
    size_t allocsz;
};

void *unified_kalloc(size_t sz){
    struct unifiedhdr *hdr;
    size_t allocsz = sizeof(*hdr) + sz;

    if(iOS_version == iOS_13_x)
        hdr = kalloc_canblock(&allocsz, 0, NULL);
    else
        hdr = kalloc_external(allocsz);

    if(!hdr)
        return NULL;

    hdr->allocsz = allocsz;

    return hdr + 1;
}

void unified_kfree(void *ptr){
    if(!ptr)
        return;

    /* future-proofing */
    struct unifiedhdr *hdr = (struct unifiedhdr *)((uintptr_t)ptr - sizeof(*hdr));

    if(iOS_version == iOS_13_x)
        kfree_addr(hdr);
    else
        kfree_ext(NULL, hdr, hdr->allocsz);
}

```

`module/el1/xnuspy_ctl/pte.c`:

```c
#include <stdint.h>

#include <xnuspy/el1/debug.h>
#include <xnuspy/el1/externs.h>
#include <xnuspy/el1/pte.h>

static pte_t *ptep(uint64_t ttbr, uint64_t addr){
    uint64_t l1_table = phystokv(ttbr & 0xfffffffffffe);
    uint64_t l1_idx = (addr >> ARM_TT_L1_SHIFT) & 0x7;
    uint64_t *l1_ttep = (uint64_t *)(l1_table + (0x8 * l1_idx));

    SPYDBG("%s: l1 table %#llx idx %#llx ttep %p tte %#llx\n", __func__,
            l1_table, l1_idx, l1_ttep, *l1_ttep);

    uint64_t l2_table = phystokv(*l1_ttep & ARM_TTE_TABLE_MASK);
    uint64_t l2_idx = (addr >> ARM_TT_L2_SHIFT) & 0x7ff;
    uint64_t *l2_ttep = (uint64_t *)(l2_table + (0x8 * l2_idx));

    SPYDBG("%s: l2 table %#llx idx %#llx ttep %p tte %#llx\n", __func__,
            l2_table, l2_idx, l2_ttep, *l2_ttep);

    uint64_t l3_table = phystokv(*l2_ttep & ARM_TTE_TABLE_MASK);
    uint64_t l3_idx = (addr >> ARM_TT_L3_SHIFT) & 0x7ff;

    pte_t *l3_ptep = (pte_t *)(l3_table + (0x8 * l3_idx));

    SPYDBG("%s: l3 table %#llx idx %#llx ptep %p pte %#llx\n", __func__,
            l3_table, l3_idx, l3_ptep, *l3_ptep);

    return l3_ptep;
}

pte_t *el0_ptep(void *uaddr){
    uint64_t ttbr0_el1;
    asm volatile("mrs %0, ttbr0_el1" : "=r" (ttbr0_el1));
    return ptep(ttbr0_el1, (uint64_t)uaddr);
}

pte_t *el1_ptep(void *kaddr){
    uint64_t ttbr1_el1;
    asm volatile("mrs %0, ttbr1_el1" : "=r" (ttbr1_el1));
    return ptep(ttbr1_el1, (uint64_t)kaddr);
}

__attribute__ ((naked)) void tlb_flush(void){
    asm(""
        "isb sy\n"
        "dsb sy\n"
        "tlbi vmalle1\n"
        "dsb sy\n"
        "isb sy\n"
        "ret\n"
       );
}

```

`module/el1/xnuspy_ctl/tramp.c`:

```c
#include <mach/mach.h>
#include <stdbool.h>
#include <stdint.h>

#include <asm/asm.h>

#include <xnuspy/el1/externs.h>

static void generate_b_cond_equivalent(uint32_t orig_instr, uint32_t **tramp,
        uint32_t *len_out){
    /* get the condition of this branch, and we'll use that to build
     * the CSEL */
    uint32_t cond = orig_instr & 0xf;

    /* LDR X16, #0x10 */
    *(*tramp)++ = 0x58000090;
    /* LDR X17, #0x14 */
    *(*tramp)++ = 0x580000b1;
    /* CSEL X16, X16, X17, <cond> */
    *(*tramp)++ = assemble_csel(1, 17, cond, 16, 16);
    /* BR X16 */
    *(*tramp)++ = 0xd61f0200;

    *len_out += 4;
}

static void generate_cbz_or_cbnz_equivalent(uint32_t orig_instr, uint32_t **tramp,
        uint32_t *len_out){
    uint8_t sf = orig_instr >> 31;
    uint32_t Rn = orig_instr & 0x1f;

    uint32_t cond;

    if(orig_instr & (1 << 24)){
        /* ne, because original instr is CBNZ */
        cond = 1;
    }
    else{
        /* eq, because original instr is CBZ */
        cond = 0;
    }

    /* LDR X16, #0x14 */
    *(*tramp)++ = 0x580000b0;
    /* LDR X17, #0x18 */
    *(*tramp)++ = 0x580000d1;
    /* CMP Rn, #0 */
    *(*tramp)++ = assemble_immediate_cmp(sf, 0, 0, Rn);
    /* CSEL X16, X16, X17, <cond> */
    *(*tramp)++ = assemble_csel(1, 17, cond, 16, 16);
    /* BR X16 */
    *(*tramp)++ = 0xd61f0200;

    *len_out += 5;
}

static void generate_tbz_or_tbnz_equivalent(uint32_t orig_instr, uint32_t **tramp,
        uint32_t *len_out){
    /* I'm not going to even try to understand the mind boggling encoding
     * of arm64 bitmask immediates. My head exploded while reading it. So I
     * will index inside an array of TST instrs and then set the bits
     * accordingly
     *
     * For tst[n]:
     *  n < 32: tst[n] == TST W0, (1 << (n-1))
     *  n >= 32: tst[n] == TST X0, (1uLL << (n-1))
     */
    static const uint32_t tst[] = {
        0x7200001f, 0x721f001f, 0x721e001f, 0x721d001f, 0x721c001f, 0x721b001f,
        0x721a001f, 0x7219001f, 0x7218001f, 0x7217001f, 0x7216001f, 0x7215001f,
        0x7214001f, 0x7213001f, 0x7212001f, 0x7211001f, 0x7210001f, 0x720f001f,
        0x720e001f, 0x720d001f, 0x720c001f, 0x720b001f, 0x720a001f, 0x7209001f,
        0x7208001f, 0x7207001f, 0x7206001f, 0x7205001f, 0x7204001f, 0x7203001f,
        0x7202001f, 0x7201001f, 0xf260001f, 0xf25f001f, 0xf25e001f, 0xf25d001f,
        0xf25c001f, 0xf25b001f, 0xf25a001f, 0xf259001f, 0xf258001f, 0xf257001f,
        0xf256001f, 0xf255001f, 0xf254001f, 0xf253001f, 0xf252001f, 0xf251001f,
        0xf250001f, 0xf24f001f, 0xf24e001f, 0xf24d001f, 0xf24c001f, 0xf24b001f,
        0xf24a001f, 0xf249001f, 0xf248001f, 0xf247001f, 0xf246001f, 0xf245001f,
        0xf244001f, 0xf243001f, 0xf242001f, 0xf241001f,
    };

    uint32_t b5 = orig_instr >> 31;
    uint32_t b40 = bits(orig_instr, 19, 23);
    uint32_t tested_bit = (b5 << 5) | b40;
    uint32_t Rt = orig_instr & 0x1f;

    uint32_t cond;

    if(orig_instr & (1 << 24)){
        /* ne, because original instr is TBNZ */
        cond = 1;
    }
    else{
        /* eq, because original instr is TBZ */
        cond = 0;
    }

    uint32_t tst_instr = tst[tested_bit];

    if(b5)
        tst_instr |= 0x80000000;

    tst_instr |= (Rt << 5);

    /* LDR X16, #0x14 */
    *(*tramp)++ = 0x580000b0;
    /* LDR X17, #0x18 */
    *(*tramp)++ = 0x580000d1;
    /* TST Rn, #(1 << n) */
    *(*tramp)++ = tst_instr;
    /* CSEL X16, X16, X17, <cond> */
    *(*tramp)++ = assemble_csel(1, 17, cond, 16, 16);
    /* BR X16 */
    *(*tramp)++ = 0xd61f0200;

    *len_out += 5;
}

static void generate_adr_equivalent(uint32_t orig_instr,
        uint32_t *orig_instr_pc, uint32_t **tramp, uint32_t *len_out){
    uint64_t adr_target = get_adr_target(orig_instr_pc);
    uint32_t Rd = orig_instr & 0x1f;
    uint64_t new_pc = (uint64_t)*tramp;

    /* ADRP Rn, #n@PAGE */
    *(*tramp)++ = assemble_adrp(adr_target, new_pc, Rd);
    /* ADD Rn, Rn, #n@PAGEOFF */
    *(*tramp)++ = assemble_immediate_add(1, 0, adr_target & 0xfff, Rd, Rd);
    /* LDR X16, #0x8 */
    *(*tramp)++ = 0x58000050;
    /* BR X16 */
    *(*tramp)++ = 0xd61f0200;

    *len_out += 4;
}

static void generate_load_register_literal_equivalent(uint32_t orig_instr,
        uint64_t orig_instr_pc, uint32_t **tramp, uint32_t *len_out){
    uint32_t opc = orig_instr >> 30;
    uint8_t V = (orig_instr >> 26) & 1;
    int fp = V;
    int need_64bit = opc == 1 && !fp;
    int sw = opc == 2 && !fp;
    int prfm = opc == 3 && !fp;
    int32_t offset = sign_extend(bits(orig_instr, 5, 23) << 2, 21);
    uint32_t Rt = orig_instr & 0x1f;
    uint64_t label = (uint64_t)((int64_t)orig_instr_pc + offset);
    uint64_t new_pc = (uint64_t)*tramp;

    /* ADRP X16, <label>@PAGE */
    *(*tramp)++ = assemble_adrp(label, new_pc, 16);
    /* ADD X16, X16, <label>@PAGEOFF */
    *(*tramp)++ = assemble_immediate_add(1, 0, label & 0xfff, 16, 16);

    if(fp){
        uint32_t size;

        if(opc == 0 || opc == 1){
            if(opc == 0){
                /* Sn */
                size = 2;
            }
            else{
                /* Dn */
                size = 3;
            }

            /* Must be 1 for both Sn and Dn for immediate simd&fp ldr */
            opc = 1;
        }
        else if(opc == 2){
            /* Qn */
            size = 0;
            /* Must be 3 for immediate simd&fp ldr */
            opc = 3;
        }

        /* LDR (S|D|Q)n, [X16] */
        *(*tramp)++ = assemble_simd_fp_ldr(size, opc, 16, Rt);
    }
    else if(sw){
        /* LDRSW Rn, [X16] */
        *(*tramp)++ = assemble_ldrsw(16, Rt);
    }
    else if(prfm){
        /* PRFM <prfop>, [X16], Rt == prfop */
        *(*tramp)++ = assemble_immediate_prfm(16, Rt);
    }
    else{
        /* LDR Rn, [X16] */
        *(*tramp)++ = assemble_immediate_ldr(opc + 2, 16, Rt);
    }

    /* LDR X16, 0x8 */
    *(*tramp)++ = 0x58000050;
    /* BR X16 */
    *(*tramp)++ = 0xd61f0200;

    *len_out += 5;
}

/* This function generates a trampoline that'll represent the original
 * function. 'tramp' is expected to be an array of 10 uint32_t's, and
 * the length of the trampoline is returned through 'tramp_len_out'.
 *
 * 'addrof_second_instr' is to know where to branch back to. */
void generate_original_tramp(uint64_t addrof_second_instr,
        uint32_t *tramp, uint32_t *tramp_len_out){
    uint32_t *orig_instr_pc = (uint32_t *)(addrof_second_instr - 4);
    uint32_t orig_instr = *(uint32_t *)orig_instr_pc;

    uint32_t tramp_len = 0;

    if((orig_instr & 0xff000010) == 0x54000000){
        generate_b_cond_equivalent(orig_instr, &tramp, &tramp_len);

        uint64_t dst = get_cond_branch_dst(orig_instr, orig_instr_pc);

        ((uint64_t *)tramp)[0] = dst;
        ((uint64_t *)tramp)[1] = addrof_second_instr;

        tramp_len += 4;
    }
    else if((orig_instr & 0x7e000000) == 0x34000000){
        generate_cbz_or_cbnz_equivalent(orig_instr, &tramp, &tramp_len);

        uint64_t dst = get_compare_and_branch_dst(orig_instr, orig_instr_pc);

        ((uint64_t *)tramp)[0] = dst;
        ((uint64_t *)tramp)[1] = addrof_second_instr;

        tramp_len += 4;
    }
    else if((orig_instr & 0x7e000000) == 0x36000000){
        generate_tbz_or_tbnz_equivalent(orig_instr, &tramp, &tramp_len);

        uint64_t dst = get_test_and_branch_dst(orig_instr, orig_instr_pc);

        ((uint64_t *)tramp)[0] = dst;
        ((uint64_t *)tramp)[1] = addrof_second_instr;

        tramp_len += 4;
    }
    else if((orig_instr & 0x9f000000) == 0x10000000){
        generate_adr_equivalent(orig_instr, orig_instr_pc, &tramp, &tramp_len);

        *(uint64_t *)tramp = addrof_second_instr;

        tramp_len += 2;
    }
    else if((orig_instr & 0xfc000000) == 0x14000000){
        /* B */
        uint64_t dst = get_branch_dst(orig_instr, orig_instr_pc);

        /* LDR X16, #0x8 */
        *tramp++ = 0x58000050;
        /* BR X16 */
        *tramp++ = 0xd61f0200;

        *(uint64_t *)tramp = dst;

        tramp_len += 4;
    }
    else if((orig_instr & 0xfc000000) == 0x94000000){
        /* BL */
        uint64_t dst = get_branch_dst(orig_instr, orig_instr_pc);

        /* MOV X17, X30 */
        *tramp++ = 0xaa1e03f1;
        /* LDR X16, #0x14 */
        *tramp++ = 0x580000b0;
        /* BLR X16 */
        *tramp++ = 0xd63f0200;
        /* MOV X30, X17 */
        *tramp++ = 0xaa1103fe;
        /* LDR X16, #0x10 */
        *tramp++ = 0x58000090;
        /* BR X16 */
        *tramp++ = 0xd61f0200;

        ((uint64_t *)tramp)[0] = dst;
        ((uint64_t *)tramp)[1] = addrof_second_instr;

        tramp_len += 10;
    }
    else if((orig_instr & 0x38000000) == 0x18000000){
        generate_load_register_literal_equivalent(orig_instr,
                (uint64_t)orig_instr_pc, &tramp, &tramp_len);

        *(uint64_t *)tramp = addrof_second_instr;

        tramp_len += 2;
    }
    else{
        /* We have to fix up the immediate if we have an ADRP as the
         * original instruction. Otherwise, we just write the original
         * instruction to the trampoline. */
        uint32_t fixed_instr = orig_instr;

        if((orig_instr & 0x9f000000) == 0x90000000){
            /* page */
            uint64_t adrp_target = get_adrp_target(orig_instr_pc);
            uint32_t Rd = orig_instr & 0x1f;

            fixed_instr = assemble_adrp(adrp_target, (uint64_t)tramp, Rd);
        }

        *tramp++ = fixed_instr;
        /* LDR X16, #0x8 */
        *tramp++ = 0x58000050;
        /* BR X16 */
        *tramp++ = 0xd61f0200;

        *(uint64_t *)tramp = addrof_second_instr;

        tramp_len += 5;
    }

    *tramp_len_out = tramp_len;
}

/* this function generates a replacement trampoline and returns it through
 * the 'tramp' parameter. 'tramp' is expected to be an array of 2 uint32_t's */
void generate_replacement_tramp(uint32_t *tramp){
    /* LDR X16, #-0x8 */
    tramp[0] = 0x58ffffd0;
    /* BR X16 */
    tramp[1] = 0xd61f0200;
}

```

`module/el1/xnuspy_ctl/utils.c`:

```c
#include <stdatomic.h>
#include <stdbool.h>
#include <stdint.h>

#include <xnuspy/xnuspy_structs.h>

#include <xnuspy/el1/externs.h>

__attribute__ ((naked)) uint64_t current_thread(void){
    asm(""
        "mrs x0, tpidr_el1\n"
        "ret\n"
       );
}

struct _vm_map *current_map(void){
    return *(struct _vm_map **)(current_thread() + offsetof_struct_thread_map);
}

void vm_map_reference(void *map){
    uint64_t off = offsetof_struct_vm_map_refcnt;
    _Atomic int *refcnt = (_Atomic int *)((uintptr_t)map + off);
    atomic_fetch_add_explicit(refcnt, 1, memory_order_relaxed);
}

bool is_15_x(void){
    return iOS_version == iOS_15_x;
}

bool is_14_5_and_above(void){
    if(iOS_version <= iOS_13_x)
        return false;

    if (iOS_version == iOS_14_x &&
        kern_version_minor < 4)
        return false;

    return true;
}

bool is_14_x_and_above(void){
    return iOS_version >= iOS_14_x;
}

bool is_14_x_and_below(void){
    return iOS_version <= iOS_14_x;
}

bool is_14_x(void){
    return iOS_version == iOS_14_x;
}

bool is_13_x(void){
    return iOS_version == iOS_13_x;
}

/* On 14.5+, the patchfinder for proc_list_mlock yields a pointer
 * to it, not a pointer to a pointer to it like on 13.0 - 14.4.2 */
void *get_proc_list_mlock(void){
    void *mtx = proc_list_mlockp;

    if(is_14_5_and_above())
        return mtx;

    return *(void **)mtx;
}

void proc_list_lock(void){
    lck_mtx_lock(get_proc_list_mlock());
}

/* proc_list_unlock has been inlined so aggressively on all kernels that there
 * are no xrefs to the actual function so we need to do it like this */
void proc_list_unlock(void){
    lck_mtx_unlock(get_proc_list_mlock());
}

```

`module/el1/xnuspy_ctl/wrappers.c`:

```c
#include <stdbool.h>
#include <stdint.h>

#include <xnuspy/el1/utils.h>
#include <xnuspy/el1/externs.h>

void ipc_port_release_send_wrapper(void *port){
    if(!is_14_5_and_above()){
        ipc_port_release_send(port);
        return;
    }

    if(is_15_x())
        ipc_object_lock(port);
    else
        io_lock(port);

    ipc_port_release_send_and_unlock(port);
}

kern_return_t vm_map_unwire_wrapper(void *map, uint64_t start, uint64_t end,
        int user){
    if(is_15_x())
        return vm_map_unwire_nested(map, start, end, user, 0, 0);

    return vm_map_unwire(map, start, end, user);
}

void *proc_ref_wrapper(void *proc, bool holding_proc_list_mlock){
    /* For 13.x and 14.x, proc_ref_locked and proc_rele_locked expect
     * the proc_list_mlock to be held before they are called. For
     * 15.x, the second parameter to proc_ref indicates whether it is
     * held or not */
    if(is_15_x())
        return proc_ref(proc, holding_proc_list_mlock);

    void *proc_list_mlock = get_proc_list_mlock();

    if(!holding_proc_list_mlock)
        lck_mtx_lock(proc_list_mlock);

    void *res = proc_ref_locked(proc);

    if(!holding_proc_list_mlock)
        lck_mtx_unlock(proc_list_mlock);

    return res;
}

int proc_rele_wrapper(void *proc, bool holding_proc_list_mlock){
    /* On 15.x the second parameter is ignored, but we need to know
     * if we're on 13.x or 14.x */
    if(is_15_x())
        return proc_rele(proc);

    void *proc_list_mlock = get_proc_list_mlock();

    if(!holding_proc_list_mlock)
        lck_mtx_lock(proc_list_mlock);

    proc_rele_locked(proc);

    if(!holding_proc_list_mlock)
        lck_mtx_unlock(proc_list_mlock);

    /* Just return 0 for 13.x and 14.x, proc_rele_locked has no
     * return value for those kernels */

    return 0;
}

```

`module/el1/xnuspy_ctl/xnuspy_ctl.c`:

```c
#include <errno.h>
#include <mach/mach.h>
#include <mach-o/loader.h>
#include <stdbool.h>
#include <stdint.h>
#include <unistd.h>

#include <asm/asm.h>
#include <xnuspy/xnuspy_ctl.h>
#include <xnuspy/xnuspy_structs.h>

#include <xnuspy/el1/debug.h>
#include <xnuspy/el1/libc.h>
#include <xnuspy/el1/mem.h>
#include <xnuspy/el1/pte.h>
#include <xnuspy/el1/tramp.h>
#include <xnuspy/el1/utils.h>
#include <xnuspy/el1/wrappers.h>

#undef current_map
#undef current_thread
#undef PAGE_SIZE

#define PAGE_SIZE                   (0x4000)
#define MAP_MEM_VM_SHARE            0x400000 /* extract a VM range for remap */

typedef unsigned int lck_rw_type_t;
typedef	void (*thread_continue_t)(void *param, int wait_result);

#define MARK_AS_KERNEL_OFFSET __attribute__ ((section("__DATA,__koff")))

MARK_AS_KERNEL_OFFSET void **allprocp;
MARK_AS_KERNEL_OFFSET void (*bcopy_phys)(uint64_t src, uint64_t dst,
        vm_size_t bytes);
MARK_AS_KERNEL_OFFSET int (*copyin)(const void *uaddr, void *kaddr,
        vm_size_t nbytes);
MARK_AS_KERNEL_OFFSET int (*copyinstr)(const void *uaddr, void *kaddr,
        size_t len, size_t *done);
MARK_AS_KERNEL_OFFSET int (*copyout)(const void *kaddr, uint64_t uaddr,
        vm_size_t nbytes);
MARK_AS_KERNEL_OFFSET void *(*current_proc)(void);
/* Keep these all aligned 8 bytes */
MARK_AS_KERNEL_OFFSET uint64_t hookme_in_range;

MARK_AS_KERNEL_OFFSET uint64_t iOS_version;

/* Only for >= 14.5 && < 15.0 */
MARK_AS_KERNEL_OFFSET void (*io_lock)(void *io);

/* Only for >= 15.0 */
MARK_AS_KERNEL_OFFSET void (*ipc_object_lock)(void *obj);

MARK_AS_KERNEL_OFFSET void (*IOLog)(const char *fmt, ...);
MARK_AS_KERNEL_OFFSET void (*IOSleep)(unsigned int millis);

/* Only for < 14.5 */
MARK_AS_KERNEL_OFFSET void (*ipc_port_release_send)(void *port);

/* Only for >= 14.5 */
MARK_AS_KERNEL_OFFSET void (*ipc_port_release_send_and_unlock)(void *port);

/* Only for 13.x */
MARK_AS_KERNEL_OFFSET void *(*kalloc_canblock)(vm_size_t *sizep,
        bool canblock, void *site);

/* Only for >= 14.x */
MARK_AS_KERNEL_OFFSET void *(*kalloc_external)(vm_size_t sz);

MARK_AS_KERNEL_OFFSET uint64_t kern_version_minor;
MARK_AS_KERNEL_OFFSET void **kernel_mapp;
MARK_AS_KERNEL_OFFSET uint64_t kernel_slide;
MARK_AS_KERNEL_OFFSET kern_return_t (*kernel_thread_start)(thread_continue_t cont,
        void *parameter, void **new_thread);
MARK_AS_KERNEL_OFFSET void (*kfree_addr)(void *addr);
MARK_AS_KERNEL_OFFSET void (*kfree_ext)(void *kheap, void *addr,
        vm_size_t sz);
MARK_AS_KERNEL_OFFSET void (*kprintf)(const char *fmt, ...);
MARK_AS_KERNEL_OFFSET void *(*lck_grp_alloc_init)(const char *grp_name,
        void *attr);
MARK_AS_KERNEL_OFFSET void (*lck_grp_free)(void *grp);
MARK_AS_KERNEL_OFFSET void (*lck_mtx_lock)(void *lock);
MARK_AS_KERNEL_OFFSET void (*lck_mtx_unlock)(void *lock);
MARK_AS_KERNEL_OFFSET lck_rw_t *(*lck_rw_alloc_init)(void *grp, void *attr);
MARK_AS_KERNEL_OFFSET uint32_t (*lck_rw_done)(lck_rw_t *lock);
MARK_AS_KERNEL_OFFSET void (*lck_rw_free)(lck_rw_t *lock, void *grp);
MARK_AS_KERNEL_OFFSET void (*lck_rw_lock_exclusive)(void *lock);
MARK_AS_KERNEL_OFFSET void (*lck_rw_lock_shared)(void *lock);
MARK_AS_KERNEL_OFFSET int (*lck_rw_lock_shared_to_exclusive)(lck_rw_t *lck);
MARK_AS_KERNEL_OFFSET kern_return_t (*_mach_make_memory_entry_64)(void *target_map,
        uint64_t *size, uint64_t offset, vm_prot_t prot, void **object_handle,
        void *parent_handle);
MARK_AS_KERNEL_OFFSET int (*mach_to_bsd_errno)(kern_return_t mach_err);
MARK_AS_KERNEL_OFFSET kern_return_t (*mach_vm_map_external)(void *target_map,
        uint64_t *address, uint64_t size, uint64_t mask, int flags,
        void *memory_object, uint64_t offset, int copy,
        vm_prot_t cur_protection, vm_prot_t max_protection,
        vm_inherit_t inheritance);
MARK_AS_KERNEL_OFFSET void *(*_memmove)(void *dest, const void *src, size_t n);
MARK_AS_KERNEL_OFFSET void *(*_memset)(void *s, int c, size_t n);
MARK_AS_KERNEL_OFFSET uint64_t offsetof_struct_thread_map;
MARK_AS_KERNEL_OFFSET uint64_t offsetof_struct_vm_map_refcnt;
MARK_AS_KERNEL_OFFSET __attribute__ ((noreturn)) void (*_panic)(const char *fmt, ...);
MARK_AS_KERNEL_OFFSET uint64_t (*phystokv)(uint64_t pa);
MARK_AS_KERNEL_OFFSET void **proc_list_mlockp;
/* XNU's declaration, not mine */
MARK_AS_KERNEL_OFFSET void (*proc_name)(int pid, char *buf, int size);
MARK_AS_KERNEL_OFFSET pid_t (*proc_pid)(void *proc);

/* Only for 15.x */
MARK_AS_KERNEL_OFFSET void *(*proc_ref)(void *proc,
        bool holding_proc_list_mlock);

/* Only for 13.x and 14.x */
MARK_AS_KERNEL_OFFSET void *(*proc_ref_locked)(void *proc);

/* Only for 15.x */
MARK_AS_KERNEL_OFFSET int (*proc_rele)(void *proc);

/* Only for 13.x and 14.x */
MARK_AS_KERNEL_OFFSET void (*proc_rele_locked)(void *proc);

MARK_AS_KERNEL_OFFSET uint64_t (*proc_uniqueid)(void *proc);
MARK_AS_KERNEL_OFFSET int (*_snprintf)(char *str, size_t size, const char *fmt, ...);
MARK_AS_KERNEL_OFFSET size_t (*_strlen)(const char *s);
MARK_AS_KERNEL_OFFSET int (*_strncmp)(const char *s1, const char *s2, size_t n);
MARK_AS_KERNEL_OFFSET void (*thread_deallocate)(void *thread);
MARK_AS_KERNEL_OFFSET void (*_thread_terminate)(void *thread);
MARK_AS_KERNEL_OFFSET kern_return_t (*vm_allocate_external)(void *map,
        uint64_t *addr, uint64_t size, int flags);
MARK_AS_KERNEL_OFFSET kern_return_t (*_vm_deallocate)(void *map,
        uint64_t start, uint64_t size);
MARK_AS_KERNEL_OFFSET void (*vm_map_deallocate)(void *map);

/* Only for 13.x and 14.x */
MARK_AS_KERNEL_OFFSET kern_return_t (*vm_map_unwire)(void *map, uint64_t start,
        uint64_t end, int user);

/* Only for 15.x */
MARK_AS_KERNEL_OFFSET kern_return_t (*vm_map_unwire_nested)(void *map, 
        uint64_t start, uint64_t end, int user, uint64_t map_pmap, 
        uint64_t pmap_addr);

MARK_AS_KERNEL_OFFSET kern_return_t (*vm_map_wire_external)(void *map,
        uint64_t start, uint64_t end, vm_prot_t prot, int user_wire);
MARK_AS_KERNEL_OFFSET struct xnuspy_tramp *xnuspy_tramp_mem;
MARK_AS_KERNEL_OFFSET struct xnuspy_tramp *xnuspy_tramp_mem_end;

lck_rw_t *xnuspy_rw_lck = NULL;

/* I cannot reference count the xnuspy_tramp structs because I am unable
 * to use the stack to push a frame so the replacement function returns to
 * a routine to release a taken reference. Reference counting these structs
 * would prevent me from unmapping something that some thread is currently
 * executing on.
 *
 * Instead, I'm maximizing the time between the previous free and the next
 * allocation of a given xnuspy_tramp struct. I do this in case we uninstall
 * while some thread is currently, or will end up, executing on a trampoline.
 * When a hook is uninstalled, its shared mapping won't be unmapped immediately.
 * It may be unmapped when xnuspy_gc_thread notices that we're pushing our
 * limit in regard to the number of pages we're currently leaking. 
 *
 * Freed structs will be pushed to the end of the freelist, and we allocate
 * from the front of the freelist. The usedlist is used as a normal linked
 * list, but has to be an STAILQ so I can insert objects from the freelist
 * and into the usedlist and vice versa. The unmaplist contains shared mappings
 * from recently freed xnuspy_tramp structs. The mapping from the most
 * recently freed xnuspy_tramp struct is pushed to the end of the unmaplist,
 * and we pull from the start of the unmaplist for garbage collection.
 *
 * freelist and usedlist are protected by xnuspy_rw_lck, unmaplist isn't
 * because it's only touched by xnuspy_gc_thread.
 */
STAILQ_HEAD(, stailq_entry) freelist = STAILQ_HEAD_INITIALIZER(freelist);
STAILQ_HEAD(, stailq_entry) usedlist = STAILQ_HEAD_INITIALIZER(usedlist);
STAILQ_HEAD(, stailq_entry) unmaplist = STAILQ_HEAD_INITIALIZER(unmaplist);

static uint64_t g_num_leaked_pages = 0;

static bool xnuspy_mapping_release(struct xnuspy_mapping *m){
    int64_t prev = m->refcnt--;

    if(prev < 1)
        _panic("%s: xnuspy_mapping(%p) over-release", __func__, m);

    if(prev >= MAX_MAPPING_REFERENCES){
        _panic("%s: xnuspy_mapping(%p) possible memory corruption",
                __func__, m);
    }

    bool last = (prev == 1);

    if(last){
        if(m->death_callback){
            SPYDBG("%s: invoking death cb at %#llx for mapping %p\n",
                    __func__, (uint64_t)m->death_callback, m);
            m->death_callback();
        }

        g_num_leaked_pages += m->segment_shmem->shm_sz / PAGE_SIZE;

        struct stailq_entry *stqe = unified_kalloc(sizeof(*stqe));

        if(!stqe){
            SPYDBG("%s: stqe allocation failed\n", __func__);
            return last;
        }

        stqe->elem = m->segment_shmem;

        STAILQ_INSERT_TAIL(&unmaplist, stqe, link);

        SPYDBG("%s: added mapping @ %p to the unmaplist\n", __func__,
                m->segment_shmem->shm_base);

        desc_xnuspy_shmem(m->segment_shmem);

        unified_kfree(m);
    }

    return last;
}

static void xnuspy_mapping_reference(struct xnuspy_mapping *m){
    int64_t prev = m->refcnt++;

    if(prev < 0)
        _panic("%s: xnuspy_mapping(%p) resurrection", __func__, m);

    if(prev >= MAX_MAPPING_REFERENCES){
        _panic("%s: xnuspy_mapping(%p) possible memory corruption",
                __func__, m);
    }
}

/* This function is expected to be called with an xnuspy_tramp that has
 * already been pulled off the usedlist, but not yet added to the freelist.
 * xnuspy_rw_lock is expected to be held exclusively if we're here. */
static void xnuspy_tramp_teardown(struct xnuspy_tramp *t){
    struct xnuspy_mapping_metadata *mm = t->mapping_metadata;
    struct xnuspy_tramp_metadata *tm = t->tramp_metadata;

    uint64_t replacement_kva = t->replacement;

    struct slist_entry *entry, *tmp;

    SLIST_FOREACH_SAFE(entry, &mm->mappings, link, tmp){
        struct xnuspy_mapping *m = entry->elem;
        struct xnuspy_shmem *xs = m->segment_shmem;

        uint64_t start = (uint64_t)xs->shm_base;
        uint64_t end = start + xs->shm_sz;

        if(replacement_kva >= start && replacement_kva < end){
            if(xnuspy_mapping_release(m)){
                SPYDBG("%s: last ref on mapping was released, removing from"
                        " list\n", __func__);

                SLIST_REMOVE(&mm->mappings, entry, slist_entry, link);

                if(SLIST_EMPTY(&mm->mappings)){
                    SPYDBG("%s: mappings list is empty, freeing mm\n",
                            __func__);

                    unified_kfree(mm);
                }
            }

            t->mapping_metadata = NULL;

            break;
        }
    }

    if(t->tramp_metadata){
        unified_kfree(t->tramp_metadata);
        t->tramp_metadata = NULL;
    }
}

/* Free an xnuspy_tramp struct by putting it at the end of the freelist */
static void xnuspy_tramp_free(struct stailq_entry *stqe){
    lck_rw_lock_exclusive(xnuspy_rw_lck);
    STAILQ_INSERT_TAIL(&freelist, stqe, link);
    lck_rw_done(xnuspy_rw_lck);
}

/* Pull an xnuspy_tramp struct off of the freelist, we may or may not commit
 * it to use */
static struct stailq_entry *xnuspy_tramp_alloc(void){
    lck_rw_lock_exclusive(xnuspy_rw_lck);

    if(STAILQ_EMPTY(&freelist)){
        lck_rw_done(xnuspy_rw_lck);
        return NULL;
    }

    struct stailq_entry *allocated = STAILQ_FIRST(&freelist);

    STAILQ_REMOVE_HEAD(&freelist, link);

    lck_rw_done(xnuspy_rw_lck);

    return allocated;
}

/* Commit an xnuspy_tramp struct to use by putting it on the usedlist */
static void xnuspy_tramp_commit(struct stailq_entry *stqe){
    lck_rw_lock_exclusive(xnuspy_rw_lck);
    STAILQ_INSERT_TAIL(&usedlist, stqe, link);
    lck_rw_done(xnuspy_rw_lck);
}

/* Add an xnuspy mapping to the list of the calling process's shared
 * mappings. A reference for m must have been taken before calling this
 * function. */
static int xnuspy_mapping_add(struct xnuspy_mapping_metadata *mm,
        struct xnuspy_mapping *m){
    struct slist_entry *sle = unified_kalloc(sizeof(*sle));

    if(!sle)
        return ENOMEM;

    sle->elem = m;

    lck_rw_lock_exclusive(xnuspy_rw_lck);
    SLIST_INSERT_HEAD(&mm->mappings, sle, link);
    lck_rw_done(xnuspy_rw_lck);

    return 0;
}

static struct xnuspy_mapping_metadata *caller_mapping_metadata(void){
    uint64_t cuniqueid = proc_uniqueid(current_proc());
    struct stailq_entry *entry;

    lck_rw_lock_shared(xnuspy_rw_lck);

    STAILQ_FOREACH(entry, &usedlist, link){
        struct xnuspy_tramp *tramp = entry->elem;

        if(tramp->mapping_metadata->owner == cuniqueid){
            struct xnuspy_mapping_metadata *mm = tramp->mapping_metadata;
            lck_rw_done(xnuspy_rw_lck);
            return mm;
        }
    }

    lck_rw_done(xnuspy_rw_lck);

    return NULL;
}

static bool hook_already_exists(uint64_t target){
    struct stailq_entry *entry;

    lck_rw_lock_shared(xnuspy_rw_lck);

    STAILQ_FOREACH(entry, &usedlist, link){
        struct xnuspy_tramp *tramp = entry->elem;

        if(tramp->tramp_metadata->hooked == target){
            lck_rw_done(xnuspy_rw_lck);
            return true;
        }
    }

    lck_rw_done(xnuspy_rw_lck);

    return false;
}

/* Figure out the kernel virtual address of a user address on a shared
 * mapping */
static uint64_t shared_mapping_kva(struct xnuspy_mapping *m,
        uint64_t /* __user */ uaddr){
    uint64_t dist = uaddr - m->mapping_addr_uva;
    uintptr_t shm_base = (uintptr_t)m->segment_shmem->shm_base;

    SPYDBG("%s: dist %#llx uaddr %#llx umh %#llx kmh %#llx\n", __func__,
            dist, uaddr, m->mapping_addr_uva, shm_base);

    return shm_base + dist;
}

/* Create a shared mapping of __TEXT and __DATA from the Mach-O header passed
 * in.
 *
 * We share __TEXT so the user can call other functions they wrote from their
 * kernel hooks. We share __DATA so modifications to global variables are
 * visible to both EL1 and EL0. 
 *
 * On success, returns a new xnuspy_mapping struct with a reference taken.
 *
 * On failure, returns NULL and sets retval.
 */
static struct xnuspy_mapping *
map_segments(struct mach_header_64 * /* __user */ umh, int *retval){
    struct mach_header_64 umh_kern;

    int res = copyin(umh, &umh_kern, sizeof(umh_kern));

    if(res){
        SPYDBG("%s: copyin failed for mach-o header: %d\n", __func__, res);
        *retval = res;
        return NULL;
    }

    if(umh_kern.magic != MH_MAGIC_64){
        SPYDBG("%s: %#llx is not a Mach-O header? Found %#x\n", __func__,
                (uint64_t)umh, umh_kern.magic);
        *retval = EFAULT;
        return NULL;
    }

    uint32_t sizeofcmds = umh_kern.sizeofcmds;

    struct load_command *lc = unified_kalloc(sizeofcmds);

    if(!lc){
        SPYDBG("%s: failed allocating load command buffer\n", __func__);
        *retval = ENOMEM;
        return NULL;
    }

    struct load_command *lc_orig = lc;
    struct load_command * /* __user */ ulc = (struct load_command *)(umh + 1);

    res = copyin(ulc, lc, sizeofcmds);

    if(res){
        unified_kfree(lc);
        SPYDBG("%s: copyin failed for load commands: %d\n", __func__, res);
        *retval = res;
        return NULL;
    }

    uint64_t aslr_slide;

    if(umh_kern.filetype == MH_EXECUTE)
        aslr_slide = (uintptr_t)umh - 0x100000000;
    else if(umh_kern.filetype == MH_DYLIB)
        aslr_slide = (uint64_t)umh;
    else{
        unified_kfree(lc);
        SPYDBG("%s: the caller is not from a Mach-O executable or a"
                " dylib? Filetype=%#x\n", __func__, umh_kern.filetype);
        *retval = ENOTSUP;
        return NULL;
    }

    uint64_t copystart = 0, copysz = 0;
    bool seen_text = false, seen_data = false;

    uint32_t ncmds = umh_kern.ncmds;

    for(uint32_t i=0; i<ncmds; i++){
        if(lc->cmd != LC_SEGMENT_64)
            goto nextcmd;

        struct segment_command_64 *sc64 = (struct segment_command_64 *)lc;

        bool is_text = strcmp(sc64->segname, "__TEXT") == 0;
        bool is_data = strcmp(sc64->segname, "__DATA") == 0;

        /* These will always be page aligned and unslid */
        uint64_t /* __user */ start = sc64->vmaddr + aslr_slide;
        uint64_t /* __user */ end = start + sc64->vmsize;

        SPYDBG("%s: start %#llx end %#llx\n", __func__, start, end);

        /* If this segment is neither __TEXT nor __DATA, but we've already
         * seen __TEXT or __DATA, we need to make sure we account for
         * that gap. copystart being non-zero implies we've already seen
         * __TEXT or __DATA */
        if(copystart && !is_text && !is_data)
            copysz += sc64->vmsize;
        else if(is_text || is_data){
            if(copystart)
                copysz += sc64->vmsize;
            else{
                copystart = start;
                copysz = sc64->vmsize;
            }

            if(is_text)
                seen_text = true;

            if(is_data)
                seen_data = true;

            if(seen_text && seen_data){
                SPYDBG("%s: we've seen text and data, breaking\n", __func__);
                break;
            }
        }

nextcmd:
        lc = (struct load_command *)((uintptr_t)lc + lc->cmdsize);
    }

    unified_kfree(lc_orig);

    SPYDBG("%s: ended with copystart %#llx copysz %#llx\n", __func__,
            copystart, copysz);

    struct xnuspy_mapping *m = NULL;

    if(!copystart || !copysz){
        SPYDBG("%s: text and data are not present?\n", __func__);
        *retval = ENOENT;
        goto failed;
    }

    m = unified_kalloc(sizeof(*m));

    if(!m){
        SPYDBG("%s: unified_kalloc returned NULL when allocating "
                "mapping obj\n", __func__);
        *retval = ENOMEM;
        goto failed;
    }

    _memset(m, 0, sizeof(*m));

    struct xnuspy_shmem *xs = unified_kalloc(sizeof(*xs));

    if(!xs){
        SPYDBG("%s: unified_kalloc failed for xnuspy_shmem alloc\n",
                __func__);
        *retval = ENOMEM;
        goto failed;
    }

    vm_prot_t allprot = VM_PROT_READ | VM_PROT_WRITE | VM_PROT_EXECUTE;

    res = mkshmem_utok(copystart, copysz, allprot, xs);

    if(res){
        SPYDBG("%s: mkshmem_utok failed: %d\n", __func__, res);
        *retval = res;
        goto failed;
    }

    m->mapping_addr_uva = (uint64_t)umh;
    m->segment_shmem = xs;

    xnuspy_mapping_reference(m);

    *retval = 0;

    return m;

failed:;
    if(m)
        unified_kfree(m);

    if(xs)
        unified_kfree(xs);

    return NULL;
}

static struct xnuspy_mapping *
find_mapping_for_uaddr(struct xnuspy_mapping_metadata *mm,
        uint64_t /* __user */ addr){
    struct slist_entry *entry;

    lck_rw_lock_shared(xnuspy_rw_lck);

    SLIST_FOREACH(entry, &mm->mappings, link){
        struct xnuspy_mapping *m = entry->elem;
        struct xnuspy_shmem *xs = m->segment_shmem;

        uint64_t /* __user */ start = m->mapping_addr_uva;
        uint64_t /* __user */ end = start + xs->shm_sz;

        if(addr >= start && addr < end){
            xnuspy_mapping_reference(m);
            lck_rw_done(xnuspy_rw_lck);
            return m;
        }
    }

    lck_rw_done(xnuspy_rw_lck);

    return NULL;
}

/* Given the vm_map of the caller, figure out the Mach-O header that
 * corresponds to addr. This exists so xnuspy can be used inside dynamic
 * libraries. */
static struct mach_header_64 * /* __user */ mh_for_addr(struct _vm_map *cm,
        uint64_t /* __user */ addr){
    struct vm_map_entry *entry;

    lck_rw_lock_shared(&cm->lck);

    for(entry = vm_map_first_entry(cm);
            entry != vm_map_to_entry(cm);
            entry = entry->vme_next){
        uint64_t /* __user */ start = entry->vme_start;
        uint64_t /* __user */ end = entry->vme_end;

        if(addr >= start && addr < end){
            lck_rw_done(&cm->lck);

            SPYDBG("%s: found Mach-O header for %#llx @ %#llx\n", __func__,
                    addr, start);

            return (struct mach_header_64 *)start;
        }
    }

    lck_rw_done(&cm->lck);

    return NULL;
}

static int xnuspy_install_hook(uint64_t target,
        uint64_t /* __user */ replacement, uint64_t /* __user */ origp){
    SPYDBG("%s: called with unslid target %#llx replacement %#llx origp %#llx\n",
            __func__, target, replacement, origp);

    int res = 0;

    /* Slide target */
    target += kernel_slide;

    if(hook_already_exists(target)){
        SPYDBG("%s: hook for %#llx already exists\n", __func__, target);
        res = EEXIST;
        goto out;
    }

    struct xnuspy_tramp_metadata *tm = unified_kalloc(sizeof(*tm));

    if(!tm){
        SPYDBG("%s: failed allocating mem for tramp metadata\n", __func__);
        res = ENOMEM;
        goto out;
    }

    tm->hooked = target;
    tm->orig_instr = *(uint32_t *)target;

    struct stailq_entry *tramp_entry = xnuspy_tramp_alloc();

    /* We don't need to keep this locked because we have not committed
     * this entry to the usedlist and it no longer exists in the freelist */

    if(!tramp_entry){
        SPYDBG("%s: no free xnuspy_tramp structs\n", __func__);
        res = ENOSPC;
        goto out_free_tramp_metadata;
    }

    uint32_t orig_tramp_len = 0;

    struct xnuspy_tramp *tramp = tramp_entry->elem;

    generate_replacement_tramp(tramp->tramp);
    generate_original_tramp(target + 4, tramp->orig, &orig_tramp_len);

    dcache_clean_PoU(tramp->tramp, sizeof(tramp->tramp));
    icache_invalidate_PoU(tramp->tramp, sizeof(tramp->tramp));

    dcache_clean_PoU(tramp->orig, sizeof(tramp->orig));
    icache_invalidate_PoU(tramp->orig, sizeof(tramp->orig));

    /* copyout the original function trampoline before the target
     * function is hooked, if necessary */
    if(origp){
        uint32_t *orig_tramp = tramp->orig;
        res = copyout(&orig_tramp, origp, sizeof(origp));

        if(res){
            SPYDBG("%s: copyout orig trampoline failed: %d\n", __func__, res);
            goto out_free_tramp_entry;
        }
    }

    /* Check if we've got mapping metadata for the calling process already.
     * If we don't, this is the first hook being installed for this process,
     * so we need to create it. */
    struct xnuspy_mapping_metadata *mm = caller_mapping_metadata();

    bool need_mm_kfree_on_fail = false;

    if(!mm){
        SPYDBG("%s: no mapping metadata for this process, creating it\n",
                __func__);

        mm = unified_kalloc(sizeof(*mm));

        if(!mm){
            SPYDBG("%s: unified_kalloc failed for new metadata object\n",
                    __func__);
            res = ENOMEM;
            goto out_free_tramp_entry;
        }

        need_mm_kfree_on_fail = true;

        mm->owner = proc_uniqueid(current_proc());

        SLIST_INIT(&mm->mappings);
    }

    /* Check to see if we already have a mapping for the replacement.
     * If we don't, we need to create it now. A reference has already
     * been taken for m if it's not NULL. */
    struct xnuspy_mapping *m = find_mapping_for_uaddr(mm, replacement);
    struct _vm_map *cm = current_map();

    if(!m){
        struct mach_header_64 * /* __user */ umh = mh_for_addr(cm, replacement);

        if(!umh){
            SPYDBG("%s: could not find Mach-O header corresponding to the page"
                    " containing %#llx\n", __func__, replacement);
            res = ENOENT;
            goto out_free_mapping_metadata;
        }

        SPYDBG("%s: no shared mapping for %#llx, creating it now\n",
                __func__, replacement);

        m = map_segments(umh, &res);

        if(!m){
            SPYDBG("%s: could not make mapping: %d\n", __func__, res);
            goto out_free_mapping_metadata;
        }

        res = xnuspy_mapping_add(mm, m);

        if(res){
            SPYDBG("%s: Could not add this mapping struct to mapping list"
                    " for this process: %d\n", __func__, res);
            goto out_release_mapping;
        }
    }

    uint32_t branch = assemble_b(target, (uint64_t)tramp->tramp);

    tramp->replacement = shared_mapping_kva(m, replacement);
    tramp->tramp_metadata = tm;
    tramp->mapping_metadata = mm;

    desc_xnuspy_tramp(tramp, orig_tramp_len);

    xnuspy_tramp_commit(tramp_entry);
    kwrite_instr(target, branch);

    return 0;

out_release_mapping:
    xnuspy_mapping_release(m);
out_free_mapping_metadata:;
    if(need_mm_kfree_on_fail)
        unified_kfree(mm);
out_free_tramp_entry:
    xnuspy_tramp_free(tramp_entry);
out_free_tramp_metadata:
    unified_kfree(tm);
out:
    return res;
}

/* By default, allow around 1 mb of kernel memory to be leaked by us */
#ifndef XNUSPY_LEAKED_PAGE_LIMIT
#define XNUSPY_LEAKED_PAGE_LIMIT 64
#endif

/* We only deallocate just enough pages to get us back down around the limit. */
static void xnuspy_do_gc(void){
    SPYDBG("%s: doing gc\n", __func__);

    if(STAILQ_EMPTY(&unmaplist)){
        SPYDBG("%s: unmap list is empty\n", __func__);
        return;
    }

    int64_t dealloc_pages = (int64_t)(g_num_leaked_pages - XNUSPY_LEAKED_PAGE_LIMIT);

    SPYDBG("%s: need to deallocate %lld pages to get back around limit\n",
            __func__, dealloc_pages);

    struct stailq_entry *entry, *tmp;

    STAILQ_FOREACH_SAFE(entry, &unmaplist, link, tmp){
        if(g_num_leaked_pages <= XNUSPY_LEAKED_PAGE_LIMIT){
            SPYDBG("%s: back around limit with %lld leaked pages\n",
                    __func__, g_num_leaked_pages);
            return;
        }

        struct xnuspy_shmem *orphan = entry->elem;
        
        int res = shmem_destroy(orphan);

        if(res){
            SPYDBG("%s: failed to gc :( (%d) those pages will be"
                    " leaked forever\n", __func__, res);
        }
        else{
            SPYDBG("%s: gc okay\n", __func__);
            g_num_leaked_pages -= orphan->shm_sz / PAGE_SIZE;
        }

        STAILQ_REMOVE(&unmaplist, entry, stailq_entry, link);

        unified_kfree(entry);
        unified_kfree(orphan);
    }
}

static void xnuspy_consider_gc(void){
    SPYDBG("%s: Currently, there are %lld leaked pages\n", __func__,
            g_num_leaked_pages);

    if(g_num_leaked_pages <= XNUSPY_LEAKED_PAGE_LIMIT)
        return;

    xnuspy_do_gc();
}

/* Every second, this thread loops through the proc list, and checks
 * if the owner of a given xnuspy_mapping_metadata struct is no longer present.
 * If so, all the hooks associated with that metadata struct are uninstalled
 * and sent back to the freelist.
 *
 * This thread also handles deallocation of shared mappings whose owners were
 * freed a long time ago so we don't end up leaking a ridiculous amount of
 * memory. */
static void xnuspy_gc_thread(void *param, int wait_result){
    for(;;){
        lck_rw_lock_shared(xnuspy_rw_lck);

        if(STAILQ_EMPTY(&usedlist))
            goto unlock_and_consider_gc;

        if(!lck_rw_lock_shared_to_exclusive(xnuspy_rw_lck))
            lck_rw_lock_exclusive(xnuspy_rw_lck);
        
        struct stailq_entry *entry, *tmp;

        STAILQ_FOREACH_SAFE(entry, &usedlist, link, tmp){
            struct xnuspy_tramp *tramp = entry->elem;
            struct xnuspy_mapping_metadata *mm = tramp->mapping_metadata;
            struct xnuspy_tramp_metadata *tm = tramp->tramp_metadata;

            proc_list_lock();

            /* Looping through allproc with LIST_FOREACH doesn't pick up the
             * last proc structure in the list for some reason */
            void *curproc = *allprocp;
            pid_t pid;

            /* For simplicity, assume owner is dead before we start the
             * search */
            bool owner_dead = true;

            do {
                proc_ref_wrapper(curproc, true);

                pid = proc_pid(curproc);
                uint64_t uniqueid = proc_uniqueid(curproc);
                void *nextproc = *(void **)curproc;

                proc_rele_wrapper(curproc, true);

                if(mm->owner == uniqueid){
                    owner_dead = false;
                    break;
                }

                curproc = nextproc;
            } while (pid != 0);

            proc_list_unlock();

            if(owner_dead){
                SPYDBG("%s: Tramp %#llx's owner (%lld) is dead, freeing it\n",
                        __func__, tramp, mm->owner);

                STAILQ_REMOVE(&usedlist, entry, stailq_entry, link);

                kwrite_instr(tm->hooked, tm->orig_instr);

                xnuspy_tramp_teardown(tramp);

                STAILQ_INSERT_TAIL(&freelist, entry, link);
            }
        }

unlock_and_consider_gc:;
        lck_rw_done(xnuspy_rw_lck);
        xnuspy_consider_gc();
        IOSleep(1000);
    }
}

static int xnuspy_init_flag = 0;

static int xnuspy_init(void){
    int res = 0;

    /* Kinda sucks I can't statically initialize the xnuspy lock, so I'll have
     * to deal with racing inside xnuspy_init. Why would anyone try to race
     * this function anyway */
    void *grp = lck_grp_alloc_init("xnuspy", NULL);
    
    if(!grp){
        SPYDBG("%s: no mem for lck grp\n", __func__);
        res = ENOMEM;
        goto out;
    }

    xnuspy_rw_lck = lck_rw_alloc_init(grp, NULL);

    if(!xnuspy_rw_lck){
        SPYDBG("%s: no mem for xnuspy rw lck\n", __func__);
        res = ENOMEM;
        goto out_dealloc_grp;
    }

    STAILQ_INIT(&freelist);
    STAILQ_INIT(&usedlist);
    STAILQ_INIT(&unmaplist);

    uint64_t nhooks = 0;

    struct xnuspy_tramp *cursor = xnuspy_tramp_mem;

    while(cursor + 1 < xnuspy_tramp_mem_end){
        struct stailq_entry *entry = unified_kalloc(sizeof(*entry));

        if(!entry){
            SPYDBG("%s: no mem for stailq_entry\n", __func__);
            res = ENOMEM;
            goto out_dealloc_xnuspy_lck;
        }

        entry->elem = cursor;
        STAILQ_INSERT_TAIL(&freelist, entry, link);
        cursor++;
        nhooks++;
    }

    SPYDBG("%s: %lld available xnuspy_tramp structs\n", __func__, nhooks);

    void *gct = NULL;
    kern_return_t kret = kernel_thread_start(xnuspy_gc_thread, NULL, &gct);

    if(kret){
        SPYDBG("%s: kernel_thread_start failed: %d\n", __func__, kret);
        res = mach_to_bsd_errno(kret);
        goto out_dealloc_xnuspy_lck;
    }

    thread_deallocate(gct);

    uint64_t sz = (uint64_t)xnuspy_tramp_mem_end - (uint64_t)xnuspy_tramp_mem;
    vm_prot_t prot = VM_PROT_READ | VM_PROT_WRITE | VM_PROT_EXECUTE;

    kprotect(xnuspy_tramp_mem, sz, prot);

    xnuspy_init_flag = 1;

    SPYDBG("%s: xnuspy inited\n", __func__);

    return 0;

out_dealloc_xnuspy_lck:;
    lck_rw_free(xnuspy_rw_lck, grp);
    xnuspy_rw_lck = NULL;
out_dealloc_freelist:;
    struct stailq_entry *entry, *tmp;

    STAILQ_FOREACH_SAFE(entry, &freelist, link, tmp){
        STAILQ_REMOVE(&freelist, entry, stailq_entry, link);
        unified_kfree(entry);
    }

    STAILQ_INIT(&freelist);
out_dealloc_grp:
    lck_grp_free(grp);
out:
    return res;
}

static int xnuspy_register_death_callback(uint64_t /* __user */ addr){
    SPYDBG("%s: called with user address %#llx\n", __func__, addr);

    /* Find mapping metadata for this processes, if none, no hooks are
     * installed, so it doesn't make sense to install a callback */
    struct xnuspy_mapping_metadata *mm = caller_mapping_metadata();

    if(!mm){
        SPYDBG("%s: no hooks, not installing callback\n", __func__);
        return ENOENT;
    }

    struct xnuspy_mapping *m = find_mapping_for_uaddr(mm, addr);

    if(!m){
        SPYDBG("%s: no shared mapping for user addr %#llx, no hooks,"
                " not installing callback\n", __func__, addr);
        return ENOENT;
    }

    m->death_callback = (void (*)(void))shared_mapping_kva(m, addr);

    SPYDBG("%s: set death callback to %#llx for %lld\n", __func__,
            (uint64_t)m->death_callback, mm->owner);

    xnuspy_mapping_release(m);

    return 0;
}

__attribute__ ((naked)) static void _hookme(void *arg){
    asm(""
        "nop\n"
        "ret\n"
       );
}

static int hookme(void *arg){
    if(!hookme_in_range){
        SPYDBG("%s: _hookme is unable to be hooked, but if it was, calling"
                " it would panic, bailing.\n", __func__);
        return ENOTSUP;
    }

    _hookme(arg);

    return 0;
}

static int xnuspy_cache_read(enum xnuspy_cache_id which,
        uint64_t /* __user */ outp){
    SPYDBG("%s: XNUSPY_CACHE_READ called with which %d origp %#llx\n",
            __func__, which, outp);

    void *what;

    switch(which){
        case ALLPROC:
            what = *allprocp;
            break;
        case BCOPY_PHYS:
            what = bcopy_phys;
            break;
        case BZERO:
            what = bzero;
            break;
        case COPYIN:
            what = copyin;
            break;
        case COPYINSTR:
            what = copyinstr;
            break;
        case COPYOUT:
            what = copyout;
            break;
        case CURRENT_MAP:
            what = current_map;
            break;
        case CURRENT_PROC:
            what = current_proc;
            break;
        case IO_LOCK:
            if(is_14_5_and_above() && !is_15_x())
                what = io_lock;
            else
                return EINVAL;

            break;
        case IPC_OBJECT_LOCK:
            if(!is_15_x())
                return EINVAL;

            what = ipc_object_lock;
            break;
        case IOLOG:
            what = IOLog;
            break;
        case IOSLEEP:
            what = IOSleep;
            break;
        case IPC_PORT_RELEASE_SEND:
            if(is_14_5_and_above())
                return EINVAL;

            what = ipc_port_release_send;
            break;
        case IPC_PORT_RELEASE_SEND_AND_UNLOCK:
            if(!is_14_5_and_above())
                return EINVAL;

            what = ipc_port_release_send_and_unlock;
            break;
        case IPC_PORT_RELEASE_SEND_WRAPPER:
            what = ipc_port_release_send_wrapper;
            break;
        case KALLOC_CANBLOCK:
            if(!is_13_x())
                return EINVAL;

            what = kalloc_canblock;
            break;
        case KALLOC_EXTERNAL:
            if(!is_14_x_and_above())
                return EINVAL;

            what = kalloc_external;
            break;
        case KERNEL_MAP:
            what = *kernel_mapp;
            break;
        case KERNEL_THREAD_START:
            what = kernel_thread_start;
            break;
        case KFREE_ADDR:
            if(!is_13_x())
                return EINVAL;

            what = kfree_addr;
            break;
        case KFREE_EXT:
            if(!is_14_x_and_above())
                return EINVAL;

            what = kfree_ext;
            break;
        case KPRINTF:
            what = kprintf;
            break;
        case LCK_GRP_ALLOC_INIT:
            what = lck_grp_alloc_init;
            break;
        case LCK_GRP_FREE:
            what = lck_grp_free;
            break;
        case LCK_MTX_LOCK:
            what = lck_mtx_lock;
            break;
        case LCK_MTX_UNLOCK:
            what = lck_mtx_unlock;
            break;
        case LCK_RW_ALLOC_INIT:
            what = lck_rw_alloc_init;
            break;
        case LCK_RW_DONE:
            what = lck_rw_done;
            break;
        case LCK_RW_FREE:
            what = lck_rw_free;
            break;
        case LCK_RW_LOCK_EXCLUSIVE:
            what = lck_rw_lock_exclusive;
            break;
        case LCK_RW_LOCK_SHARED:
            what = lck_rw_lock_shared;
            break;
        case LCK_RW_LOCK_SHARED_TO_EXCLUSIVE:
            what = lck_rw_lock_shared_to_exclusive;
            break;
        case MACH_MAKE_MEMORY_ENTRY_64:
            what = _mach_make_memory_entry_64;
            break;
        case MACH_TO_BSD_ERRNO:
            what = mach_to_bsd_errno;
            break;
        case MACH_VM_MAP_EXTERNAL:
            what = mach_vm_map_external;
            break;
        case MEMCHR:
            what = memchr;
            break;
        case MEMCMP:
            what = memcmp;
            break;
        case MEMMEM:
            what = memmem;
            break;
        case MEMMOVE:
            what = _memmove;
            break;
        case MEMRCHR:
            what = memrchr;
            break;
        case MEMSET:
            what = _memset;
            break;
        case PANIC:
            what = _panic;
            break;
        case PHYSTOKV:
            what = phystokv;
            break;
        case PROC_LIST_LOCK:
            what = proc_list_lock;
            break;
        case PROC_LIST_MLOCK:
            what = get_proc_list_mlock();
            break;
        case PROC_LIST_UNLOCK:
            what = proc_list_unlock;
            break;
        case PROC_NAME:
            what = proc_name;
            break;
        case PROC_PID:
            what = proc_pid;
            break;
        case PROC_REF:
            if(!is_15_x())
                return EINVAL;

            what = proc_ref;
            break;
        case PROC_REF_LOCKED:
            if(is_15_x())
                return EINVAL;

            what = proc_ref_locked;
            break;
        case PROC_REF_WRAPPER:
            what = proc_ref_wrapper;
            break;
        case PROC_RELE:
            if(!is_15_x())
                return EINVAL;

            what = proc_rele;
            break;
        case PROC_RELE_LOCKED:
            if(is_15_x())
                return EINVAL;

            what = proc_rele_locked;
            break;
        case PROC_RELE_WRAPPER:
            what = proc_rele_wrapper;
            break;
        case PROC_UNIQUEID:
            what = proc_uniqueid;
            break;
        case SNPRINTF:
            what = _snprintf;
            break;
        case STRCHR:
            what = strchr;
            break;
        case STRRCHR:
            what = strrchr;
            break;
        case STRCMP:
            what = strcmp;
            break;
        case STRLEN:
            what = _strlen;
            break;
        case STRNCMP:
            what = _strncmp;
            break;
        case STRSTR:
            what = strstr;
            break;
        case STRNSTR:
            what = strnstr;
            break;
        case THREAD_DEALLOCATE:
            what = thread_deallocate;
            break;
        case THREAD_TERMINATE:
            what = _thread_terminate;
            break;
        case VM_ALLOCATE_EXTERNAL:
            what = vm_allocate_external;
            break;
        case VM_DEALLOCATE:
            what = _vm_deallocate;
            break;
        case VM_MAP_DEALLOCATE:
            what = vm_map_deallocate;
            break;
        case VM_MAP_REFERENCE:
            what = vm_map_reference;
            break;
        case VM_MAP_UNWIRE:
            if(is_15_x())
                return EINVAL;

            what = vm_map_unwire;
            break;
        case VM_MAP_UNWIRE_NESTED:
            if(!is_15_x())
                return EINVAL;

            what = vm_map_unwire_nested;
            break;
        case VM_MAP_UNWIRE_WRAPPER:
            what = vm_map_unwire_wrapper;
            break;
        case VM_MAP_WIRE_EXTERNAL:
            what = vm_map_wire_external;
            break;
        case EL0_PTEP:
            what = el0_ptep;
            break;
        case EL1_PTEP:
            what = el1_ptep;
            break;
        case HOOKME:
            what = _hookme;
            break;
        case IOS_VERSION:
            what = (void *)iOS_version;
            break;
        case KERNEL_SLIDE:
            what = (void *)kernel_slide;
            break;
        case KERN_VERSION_MINOR:
            what = (void *)kern_version_minor;
            break;
        case KPROTECT:
            what = kprotect;
            break;
        case KVTOPHYS:
            what = kvtophys;
            break;
        case KWRITE_INSTR:
            what = kwrite_instr;
            break;
        case KWRITE_STATIC:
            what = kwrite_static;
            break;
        case MKSHMEM_KTOU:
            what = mkshmem_ktou;
            break;
        case MKSHMEM_UTOK:
            what = mkshmem_utok;
            break;
        case MKSHMEM_RAW:
            what = mkshmem_raw;
            break;
        case OFFSETOF_STRUCT_THREAD_MAP:
            what = (void *)offsetof_struct_thread_map;
            break;
        case OFFSETOF_STRUCT_VM_MAP_REFCNT:
            what = (void *)offsetof_struct_vm_map_refcnt;
            break;
        case SHMEM_DESTROY:
            what = shmem_destroy;
            break;
        case TLB_FLUSH:
            what = tlb_flush;
            break;
        case UNIFIED_KALLOC:
            what = unified_kalloc;
            break;
        case UNIFIED_KFREE:
            what = unified_kfree;
            break;
        case UPROTECT:
            what = uprotect;
            break;
        case UVTOPHYS:
            what = uvtophys;
            break;
        default:
            return EINVAL;
    };

    return copyout(&what, outp, sizeof(outp));
}

static int xnuspy_kwhat(int what, uint64_t kva, uint64_t uva, vm_size_t sz){
    SPYDBG("%s: called with flavor %d, kva %#llx, uva %#llx, sz %#llx\n",
            __func__, what, kva, uva, sz);

    uint64_t kphys = kvtophys(kva), uphys = uvtophys(uva);

    if(!kphys || !uphys){
        SPYDBG("%s: address translation failed for kva or uva kphys=%#llx"
                " uphys=%#llx\n", __func__, kphys, uphys);
        return EFAULT;
    }

    uint64_t src, dst;

    if(what == XNUSPY_KREAD){
        src = kphys;
        dst = uphys;
    }
    else{
        src = uphys;
        dst = kphys;
    }

    bcopy_phys(src, dst, sz);

    SPYDBG("%s: wrote %#llx bytes from %#llx to %#llx\n", __func__, sz,
            src, dst);

    return 0;
}

struct xnuspy_ctl_args {
    uint64_t flavor;
    uint64_t arg1;
    uint64_t arg2;
    uint64_t arg3;
};

int xnuspy_ctl(void *p, struct xnuspy_ctl_args *uap, int *retval){
    uint64_t flavor = uap->flavor;
    
    if(flavor == XNUSPY_CHECK_IF_PATCHED){
        SPYDBG("%s: we exist!\n", __func__);
        *retval = 999;
        return 0;
    }

    int res;

    if(!xnuspy_init_flag){
        res = xnuspy_init();

        if(res)
            goto out;
    }

    switch(flavor){
        case XNUSPY_INSTALL_HOOK:
            res = xnuspy_install_hook(uap->arg1, uap->arg2, uap->arg3);
            break;
        case XNUSPY_REGISTER_DEATH_CALLBACK:
            res = xnuspy_register_death_callback(uap->arg1);
            break;
        case XNUSPY_CALL_HOOKME:
            res = hookme((void *)uap->arg1);
            break;
        case XNUSPY_CACHE_READ:
            {
                enum xnuspy_cache_id xcid = (enum xnuspy_cache_id)uap->arg1;
                res = xnuspy_cache_read(xcid, uap->arg2);
                break;
            }
        case XNUSPY_KREAD:
        case XNUSPY_KWRITE:
            res = xnuspy_kwhat(flavor, uap->arg1, uap->arg2, uap->arg3);
            break;
        case XNUSPY_GET_CURRENT_THREAD:
            {
                uint64_t ct = current_thread();
                res = copyout(&ct, uap->arg1, sizeof(ct));
                break;
            }
        default:
            SPYDBG("%s: bad flavor %d\n", __func__, flavor);
            *retval = -1;
            return EINVAL;
    };

    if(res)
out:
        *retval = -1;

    return res;
}

```

`module/el1/xnuspy_ctl_tramp.h`:

```h
#ifndef XNUSPY_CTL_TRAMP
#define XNUSPY_CTL_TRAMP

#define STACK                       (0x200)

#define NEW_PTE_SPACE               (STACK-0x80)

/* mask for extracting pointer to the next table */
#define ARM_TTE_TABLE_MASK          (0x0000ffffffffc000)

#define ARM_16K_TT_L1_SHIFT         (36)
#define ARM_16K_TT_L2_SHIFT         (25)
#define ARM_16K_TT_L3_SHIFT         (14)

#define ARM_TT_L1_SHIFT             ARM_16K_TT_L1_SHIFT
#define ARM_TT_L2_SHIFT             ARM_16K_TT_L2_SHIFT
#define ARM_TT_L3_SHIFT             ARM_16K_TT_L3_SHIFT

#define ARM_16K_TT_L1_INDEX_MASK    (0x00007ff000000000)
#define ARM_16K_TT_L2_INDEX_MASK    (0x0000000ffe000000)
#define ARM_16K_TT_L3_INDEX_MASK    (0x0000000001ffc000)

#define ARM_TT_L1_INDEX_MASK        ARM_16K_TT_L1_INDEX_MASK
#define ARM_TT_L2_INDEX_MASK        ARM_16K_TT_L2_INDEX_MASK
#define ARM_TT_L3_INDEX_MASK        ARM_16K_TT_L3_INDEX_MASK

#define DAIFSC_DEBUGF               (1 << 3)
#define DAIFSC_ASYNCF               (1 << 2)
#define DAIFSC_IRQF                 (1 << 1)
#define DAIFSC_FIQF                 (1 << 0)

#endif

```

`module/el1/xnuspy_ctl_tramp.s`:

```s
#include <asm/asm_support.h>
#include <xnuspy/xnuspy_cache.h>

#include "xnuspy_ctl_tramp.h"

.align 2
.global _xnuspy_ctl_tramp

/* This exists to mark the __TEXT_EXEC segment of the xnuspy_ctl Mach-O as
    executable before we branch to it. We need to preserve x0, x1, and x2
    since this code is what an _enosys sysent was modified to point to. */
_xnuspy_ctl_tramp:
    sub sp, sp, STACK
    stp x0, x1, [sp, #(STACK-0x10)]
    stp x2, x19, [sp, #(STACK-0x20)]
    stp x20, x21, [sp, #(STACK-0x30)]
    stp x22, x23, [sp, #(STACK-0x40)]
    stp x24, x25, [sp, #(STACK-0x50)]
    stp x26, x27, [sp, #(STACK-0x60)]
    stp x29, x30, [sp, #(STACK-0x70)]
    add x29, sp, #(STACK-0x70)

    adr x27, addrof_xnuspy_cache
    ldr x27, [x27]

    ldr x19, [x27, XNUSPY_CTL_IS_RX]
    cbnz x19, Lhandoff

    ldr x19, [x27, XNUSPY_CTL_CODESTART]
    ldr x20, [x27, XNUSPY_CTL_CODESZ]
    /* We don't need to worry about this not being page aligned. Clang always
    page-aligns __TEXT_EXEC,__text for the xnuspy_ctl Mach-O */
    add x20, x19, x20

    mrs x0, ttbr1_el1 
    and x0, x0, #0xfffffffffffe
    ldr x22, [x27, PHYSTOKV]
    blr x22
    mov x21, x0
    
    /* For pteloop:
    X19: current page of xnuspy_ctl __TEXT_EXEC segment
    X20: end of last page of xnuspy_ctl __TEXT_EXEC segment
    X21: virtual address of TTBR1_EL1 translation table base
    X22 - X26: scratch registers
    X27: xnuspy cache pointer
    */

Lpteloop:
    lsr x22, x19, ARM_TT_L1_SHIFT
    and x22, x22, #0x7
    add x22, x21, x22, lsl #0x3
    ldr x22, [x22]
    and x0, x22, ARM_TTE_TABLE_MASK
    ldr x22, [x27, PHYSTOKV]
    blr x22
    mov x22, x0
    lsr x23, x19, ARM_TT_L2_SHIFT
    and x23, x23, #0x7ff
    add x23, x22, x23, lsl #0x3
    ldr x23, [x23]
    and x0, x23, ARM_TTE_TABLE_MASK
    ldr x22, [x27, PHYSTOKV]
    blr x22
    mov x22, x0
    lsr x23, x19, ARM_TT_L3_SHIFT
    and x23, x23, #0x7ff
    add x23, x22, x23, lsl #0x3
    /* X23 == pointer to PTE for this page */
    ldr x24, [x23]
    /* ~(ARM_PTE_PNXMASK | ARM_PTE_NXMASK) */
    mov x25, #0xff9fffffffffffff
    and x24, x24, x25
    str x24, [sp, NEW_PTE_SPACE]
    mov x0, x23
    bl _kvtophys
    mov x24, x0
    add x0, sp, NEW_PTE_SPACE
    bl _kvtophys
    mov x1, x24
    mov w2, #0x8
    ldr x23, [x27, BCOPY_PHYS]
    blr x23

Lnextpage:
    mov w22, #0x1
    add x19, x19, x22, lsl #0xe
    cmp x20, x19
    b.ne Lpteloop

    isb sy
    dsb sy
    tlbi vmalle1
    dsb sy
    isb sy

    str x22, [x27, XNUSPY_CTL_IS_RX]

Lhandoff:
    mov x7, x27
    ldp x0, x1, [sp, #(STACK-0x10)]
    ldp x2, x19, [sp, #(STACK-0x20)]
    ldp x20, x21, [sp, #(STACK-0x30)]
    ldp x22, x23, [sp, #(STACK-0x40)]
    ldp x24, x25, [sp, #(STACK-0x50)]
    ldp x26, x27, [sp, #(STACK-0x60)]
    ldp x29, x30, [sp, #(STACK-0x70)]
    add sp, sp, STACK
    ldr x7, [x7, XNUSPY_CTL_ENTRYPOINT]
    br x7
    /* Not reached */

/* All kvtophys calls were inlined on 14.x kernels :( */
_kvtophys:
    mrs x1, DAIF
    msr DAIFSet, #(DAIFSC_DEBUGF | DAIFSC_ASYNCF | DAIFSC_IRQF | DAIFSC_FIQF)
    at s1e1r, x0
    mrs x2, par_el1
    msr DAIF, x1
    tbnz x2, #0x0, 2f
    and x2, x2, #0xfffffffff000
    and x1, x0, #0x3fff
    orr x0, x2, x1

    b 1f

2:
    mov x0, xzr

1:
    ret

addrof_xnuspy_cache: .dword QWORD_PLACEHOLDER

```

`module/el3/Makefile`:

```
DST = $(RP)/include/xnuspy/el3

all : kpp kpp.o

# kpp : kpp.s ../common/asm_support.h
kpp : kpp.s $(RP)/include/asm/asm_support.h
	$(CC) -arch arm64 -isysroot $(SDK) -I$(RP)/include -e _kpp0 kpp.s -o kpp
	$(OPDUMP) -td -i ./kpp -a kpp_patches -o $(DST)/kpp_patches.h

# kpp.o : ../common/common.h kpp.c kpp.h kpp_patches.h
kpp.o : $(RP)/include/common/common.h kpp.c \
	$(RP)/include/xnuspy/el3/kpp.h $(DST)/kpp_patches.h
	$(CC) $(CFLAGS) kpp.c -c

```

`module/el3/kpp.c`:

```c
#include <stdio.h>
#include <stdint.h>

#include <pongo.h>

#include <asm/asm.h>
#include <asm/asm_support.h>
#include <common/common.h>

#include <xnuspy/el3/kpp_patches.h>

static uint64_t find_kpp(void){
    dt_node_t *cpus = dt_find(gDeviceTree, "cpus");

    if(!cpus){
        printf("xnuspy: no cpus node?\n");
        xnuspy_fatal_error();
    }

    dt_node_t *cpu0 = dt_find(cpus, "cpu0");

    if(!cpu0){
        printf("xnuspy: no cpu0 node?\n");
        xnuspy_fatal_error();
    }

    uint32_t len;
    void *reg_private = dt_prop(cpu0, "reg-private", &len);

    if(!reg_private || len != 8){
        printf("xnuspy: bad reg-private prop?\n");
        xnuspy_fatal_error();
    }
    
    uint64_t *IORVBARp = (uint64_t *)(*(uint64_t *)reg_private + 0x40000);

    if(!IORVBARp){
        printf("xnuspy: no IORVBAR?\n");
        xnuspy_fatal_error();
    }

    return *IORVBARp & 0xfffffffff;
}

static void patchfind_kpp(uint32_t *kpp_stream, uint32_t *kpp_stream_end){
    /* We're searching for KPP's handler for synchronous exceptions from EL1.
     * It'll be easy to find; it saves X0-X17, X29, and X30 to the stack
     * then calls the function that performs all the integrity checks. 
     * We'll search for stp x16, x17, [sp, -0x10]! and then shortly after that
     * will be a BL to the integrity check/"KPP syscall" function. Once we've
     * got that function, we need to find the pointer to (what I call)
     * _kernEntry. It's set via an SMC with X0 == 0x800 (MONITOR_SET_ENTRY),
     * and KPP's _start routine depends on that being set so it can ERET back
     * to EL1 upon reset. We'll search for this, starting from the start of
     * the integrity check function:
     *
     * CMP             X0, #0x802
     * B.EQ            loc_410000647C
     * CMP             X0, #0x801
     * B.EQ            loc_41000064D0
     * CMP             X0, #0x800
     * B.NE            loc_4100005F90
     *
     * And once we've found that, the first ADRP or ADR,STR pair we see going
     * forward is for _kernEntry. We save its pointer and then loop back to
     * the start of the integrity check function and replace it with the code
     * from kpp.s.
     *
     * kpp_stream points to KPP's Mach-O header, so we can do a linear search.
     */
    uint32_t stp_x16_x17_sp_pre = 0xa9bf47f0;

    while(*kpp_stream != stp_x16_x17_sp_pre){
        if(kpp_stream >= kpp_stream_end){
            printf("xnuspy: did not find\n"
                   "   stp x16, x17 in KPP?\n");
            xnuspy_fatal_error();
        }

        kpp_stream++;
    }

    kpp_stream = get_branch_dst_ptr(kpp_stream + 2);

    uint32_t *saved_prologue = kpp_stream;

    uint32_t cmp_matches[] = {
        0xf120081f,     /* cmp x0, 0x802 */
        0x54000000,     /* b.eq n */
        0xf120041f,     /* cmp x0, 0x801 */
        0x54000000,     /* b.eq n */
        0xf120001f,     /* cmp x0, 0x800 */
        0x54000001,     /* b.ne n */
    };

    uint32_t cmp_masks[] = {
        0xffffffff,     /* match exactly */
        0xff00001f,     /* ignore immediate */
        0xffffffff,     /* match exactly */
        0xff00001f,     /* ignore immediate */
        0xffffffff,     /* match exactly */
        0xff00001f,     /* ignore immediate */
    };

    for(;;){
        if(kpp_stream >= kpp_stream_end){
            printf("xnuspy: did not find\n"
                   "   X0 if statement?\n");
            xnuspy_fatal_error();
        }

        if((*kpp_stream & *cmp_masks) == *cmp_matches){
            for(int i=1; i<sizeof(cmp_matches)/sizeof(*cmp_matches); i++){
                if((kpp_stream[i] & cmp_masks[i]) != cmp_matches[i])
                    goto nope;
            }

            break;
        }

nope:
        kpp_stream++;
    }

    /* Now look for _kernEntry. Trying to match adrp/adr,str Xn, [Xn, n] */
    while((*kpp_stream & 0x1f000000) != 0x90000000 &&
            (kpp_stream[1] & 0xffc00000) != 0xf9000000){
        if(kpp_stream >= kpp_stream_end){
            printf("xnuspy: did not find\n"
                   "   _kernEntry for KPP\n");
            xnuspy_fatal_error();
        }

        kpp_stream++;
    }

    uint32_t adrp = *kpp_stream;
    uint32_t str = kpp_stream[1];

    uint32_t immlo = bits(adrp, 29, 30);
    uint32_t immhi = bits(adrp, 5, 23);
    uint32_t imm12 = bits(str, 10, 21);
    uint32_t shift = bits(str, 30, 31);

    uint64_t page = sign_extend(((immhi << 2) | immlo) << 12, 32) +
        ((uintptr_t)kpp_stream & ~0xfffuLL);
    uint64_t pageoff = sign_extend(imm12, 12) << shift;

    uint64_t mapping_kernEntryp = page + pageoff;
    uint64_t kpp_kernEntryp = 0x4100000000 + (mapping_kernEntryp - 0xc10000000);

    uint64_t kpp_patches_len = g_kpp_patches_len / sizeof(uint32_t);
    uint32_t *kpp_patches_cursor = (uint32_t *)g_kpp_patches;
    uint32_t *kpp_patches_end = kpp_patches_cursor + kpp_patches_len;

    kpp_stream = saved_prologue;

    /* Finally, replace this function */
    while(kpp_patches_cursor < kpp_patches_end){
        if(*(uint64_t *)kpp_patches_cursor == QWORD_PLACEHOLDER)
            *(uint64_t *)kpp_patches_cursor = kpp_kernEntryp;

        *kpp_stream++ = *kpp_patches_cursor++;
    }
}

void patch_kpp(void){
    uint64_t kppphys = find_kpp();

    printf("xnuspy: found KPP at %#llx\n", kppphys);

    map_range(0xc10000000, kppphys, 0xc000, 3, 0, true);

    uint32_t *kppmapping = (uint32_t *)0xc10000000;

    patchfind_kpp(kppmapping, kppmapping + 0x3000);

    puts("xnuspy: patched KPP");
}

```

`module/el3/kpp.s`:

```s
/* The code in this file replaces the function which is called by KPP's
    lower EL synchronous exception handler */

#include <asm/asm_support.h>

#define MONITOR_SET_ENTRY 0x800

.align 2
.global _kpp0

_kpp0:
    stp x19, x20, [sp, #-0x10]!

    /* Are we here because of monitor_call? If so, the only case we have to
    handle is MONITOR_SET_ENTRY */
    mrs x19, esr_el3
    mov x20, #0x11
    movk x20, #0x5e00, lsl 16
    cmp x19, x20
    b.eq Lsetentry

    /* Otherwise, we are here because the kernel touched CPACR_EL1, so we
    need to get off that instruction before we ERET */
    mov x19, #0x6b3
    msr scr_el3, x19
    msr cptr_el3, xzr
    mov x19, #0x300000
    msr cpacr_el1, x19
    mrs x19, elr_el3
    add x19, x19, #0x4
    msr elr_el3, x19

    b Lreturn

Lsetentry:
    cmp x0, MONITOR_SET_ENTRY
    b.ne Lreturn
    ldr x19, kernEntry
    str x1, [x19]

Lreturn:
    ldp x19, x20, [sp], #0x10
    ret

kernEntry: .dword QWORD_PLACEHOLDER

```

`module/pf/13/Makefile`:

```
pf.o : pf.c $(RP)/include/pf/13/pf.h
	$(CC) $(CFLAGS) pf.c -c

```

`module/pf/13/pf.c`:

```c
#include <stdbool.h>
#include <stdio.h>
#include <stdint.h>
#include <sys/sysctl.h>

#include <pongo.h>

#include <asm/asm.h>
#include <common/common.h>
#include <pf/offsets.h>
#include <pf/pf_common.h>

uint64_t g_sysent_addr = 0;
uint64_t g_kalloc_canblock_addr = 0;
uint64_t g_kfree_addr_addr = 0;
uint64_t g_sysctl__kern_children_addr = 0;
uint64_t g_sysctl_register_oid_addr = 0;
uint64_t g_sysctl_handle_long_addr = 0;
uint64_t g_name2oid_addr = 0;
uint64_t g_sysctl_geometry_lock_addr = 0;
uint64_t g_lck_rw_done_addr = 0;
uint64_t g_h_s_c_sbn_branch_addr = 0;
uint64_t g_h_s_c_sbn_epilogue_addr = 0;
uint64_t g_lck_grp_alloc_init_addr = 0;
uint64_t g_lck_rw_alloc_init_addr = 0;
uint64_t g_exec_scratch_space_addr = 0;
/* don't count the first opcode */
uint64_t g_exec_scratch_space_size = -sizeof(uint32_t);
uint32_t *g_ExceptionVectorsBase_stream = NULL;
uint64_t g_bcopy_phys_addr = 0;
uint64_t g_phystokv_addr = 0;
uint64_t g_copyin_addr = 0;
uint64_t g_copyout_addr = 0;
uint64_t g_IOSleep_addr = 0;
uint64_t g_kprintf_addr = 0;
uint64_t g_vm_map_unwire_addr = 0;
uint64_t g_vm_deallocate_addr = 0;
uint64_t g_kernel_map_addr = 0;
uint64_t g_kernel_thread_start_addr = 0;
uint64_t g_thread_deallocate_addr = 0;
uint64_t g_mach_make_memory_entry_64_addr = 0;
uint64_t g_offsetof_struct_thread_map = 0;
uint64_t g_current_proc_addr = 0;
uint64_t g_proc_list_lock_addr = 0;
uint64_t g_proc_ref_locked_addr = 0;
uint64_t g_proc_list_mlock_addr = 0;
uint64_t g_lck_mtx_lock_addr = 0;
uint64_t g_lck_mtx_unlock_addr = 0;
uint64_t g_proc_rele_locked_addr = 0;
uint64_t g_proc_uniqueid_addr = 0;
uint64_t g_proc_pid_addr = 0;
uint64_t g_allproc_addr = 0;
uint64_t g_lck_rw_lock_shared_addr = 0;
uint64_t g_lck_rw_lock_shared_to_exclusive_addr = 0;
uint64_t g_lck_rw_lock_exclusive_addr = 0;
uint64_t g_vm_map_wire_external_addr = 0;
uint64_t g_mach_vm_map_external_addr = 0;

/* Only for <14.5 */
uint64_t g_ipc_port_release_send_addr = 0;

/* Only for >=14.5 */
uint64_t g_ipc_port_release_send_and_unlock_addr = 0;

uint64_t g_lck_rw_free_addr = 0;
uint64_t g_lck_grp_free_addr = 0;
int g_patched_doprnt_hide_pointers = 0;
uint64_t g_copyinstr_addr = 0;
uint64_t g_thread_terminate_addr = 0;
int g_patched_pinst_set_tcr = 0;
int g_patched_all_msr_tcr_el1_x18 = 0;
uint64_t g_snprintf_addr = 0;
uint64_t g_strlen_addr = 0;
uint64_t g_proc_name_addr = 0;
uint64_t g_strncmp_addr = 0;
uint64_t g_memset_addr = 0;
uint64_t g_memmove_addr = 0;
uint64_t g_panic_addr = 0;
uint64_t g_mach_to_bsd_errno_addr = 0;
uint64_t g_xnuspy_sysctl_mib_ptr = 0;
uint64_t g_xnuspy_sysctl_mib_count_ptr = 0;
uint64_t g_xnuspy_ctl_callnum = 0;

/* Only for >=14.5 && <15.0 */
uint64_t g_io_lock_addr = 0;

uint64_t g_vm_allocate_external_addr = 0;
uint64_t g_vm_map_deallocate_addr = 0;
uint64_t g_offsetof_struct_vm_map_refcnt = 0;
uint64_t g_IOLog_addr = 0;

/* Confirmed working on all kernels 13.0 - 15.0 */
bool sysent_finder_13(xnu_pf_patch_t *patch, void *cacheable_stream){
    uint32_t *opcode_stream = cacheable_stream;

    /* if we're in the right place, sysent will be the first ADRP/ADD
     * pair we find when we go forward */
    uint32_t instr_limit = 10;

    while((*opcode_stream & 0x9f000000) != 0x90000000){
        if(instr_limit-- == 0)
            return false;

        opcode_stream++;
    }

    /* make sure this is actually sysent. to do this, we can check if
     * the first entry is the indirect system call */
    uint64_t maybe_sysent = get_pc_rel_target(opcode_stream);

    if(*(uint64_t *)maybe_sysent != 0 &&
            *(uint64_t *)(maybe_sysent + 0x8) == 0 &&
            *(uint32_t *)(maybe_sysent + 0x10) == 1 &&
            *(uint16_t *)(maybe_sysent + 0x14) == 0 &&
            *(uint16_t *)(maybe_sysent + 0x16) == 0){
        xnu_pf_disable_patch(patch);

        g_sysent_addr = maybe_sysent;

        puts("xnuspy: found sysent");

        return true;
    }

    return false;
}

/* Confirmed working on all kernels 13.0 - 13.7 */
bool kalloc_canblock_finder_13(xnu_pf_patch_t *patch, void *cacheable_stream){
    uint32_t *opcode_stream = cacheable_stream;

    /* if we're in the right place, we should find kalloc_canblock's prologue
     * no more than 10 instructions before
     *
     * looking for sub sp, sp, n
     */
    uint32_t instr_limit = 10;

    while((*opcode_stream & 0xffc003ff) != 0xd10003ff){
        if(instr_limit-- == 0)
            return false;

        opcode_stream--;
    }

    xnu_pf_disable_patch(patch);

    g_kalloc_canblock_addr = xnu_ptr_to_va(opcode_stream);

    puts("xnuspy: found kalloc_canblock");

    return true;
}

/* Confirmed working on all kernels 13.0 - 13.7 */
bool kfree_addr_finder_13(xnu_pf_patch_t *patch, void *cacheable_stream){
    xnu_pf_disable_patch(patch);

    uint32_t *opcode_stream = cacheable_stream;

    /* Find kfree_addr's prologue, looking for sub sp, sp, n */
    uint32_t instr_limit = 200;

    while((*opcode_stream & 0xffc003ff) != 0xd10003ff){
        if(instr_limit-- == 0)
            return false;

        opcode_stream--;
    }

    g_kfree_addr_addr = xnu_ptr_to_va(opcode_stream);

    puts("xnuspy: found kfree_addr");

    return true;
}

/* Confirmed working on all kernels 13.0 - 13.7 */
bool ExceptionVectorsBase_finder_13(xnu_pf_patch_t *patch,
        void *cacheable_stream){
    /* According to XNU source, _ExceptionVectorsBase is page aligned. We're
     * going to abuse that fact and use the executable free space before
     * it to write our code.
     *
     * For all the devices I've tested this with, the free space before
     * _ExceptionVectorsBase is filled with NOPs, but I don't want to assume
     * that will be the case for all kernels. The exc_vectors_table will be
     * before _ExceptionVectorsBase, so I'll search up until I hit something
     * which looks like a kernel pointer.
     *
     * see osfmk/arm64/locore.s inside XNU source
     */
    xnu_pf_disable_patch(patch);

    uint32_t *opcode_stream = cacheable_stream;

    g_ExceptionVectorsBase_stream = cacheable_stream;

    uint32_t limit = PAGE_SIZE / 4;
    bool got_exc_vectors_table = false;

    while(limit-- != 0){
        uint32_t cur = *opcode_stream;

        /* in case of tagged pointers */
        cur |= (0xffff << 16);

        if(cur == 0xfffffff0){
            got_exc_vectors_table = true;
            break;
        }

        g_exec_scratch_space_size += sizeof(uint32_t);
        opcode_stream--;
    }

    if(!got_exc_vectors_table){
        puts("xnuspy: didn't find");
        puts("     exc_vectors_table?");

        xnuspy_fatal_error();
    }

    /* we're currently at the upper 32 bits of the last pointer in
     * exc_vectors_table */
    opcode_stream++;

    g_exec_scratch_space_size -= sizeof(uint32_t);
    g_exec_scratch_space_addr = xnu_ptr_to_va(opcode_stream);

    puts("xnuspy: found unused executable code");

    return true;
}

/* Confirmed working on all kernels 13.0 - 13.7 */
bool sysctl__kern_children_finder_13(xnu_pf_patch_t *patch,
        void *cacheable_stream){
    uint32_t *opcode_stream = cacheable_stream;

    xnu_pf_disable_patch(patch);

    /* we should have landed right inside _kmeminit.
     *
     * The ADRP X20, n or ADR X20, n will lead us to sysctl__kern_children.
     */
    /* advance to the ADRP X20, n or ADR X20 */
    opcode_stream += 2;

    g_sysctl__kern_children_addr = *(uint64_t *)get_pc_rel_target(opcode_stream);

    /* Always untag, no need for a branch */
    g_sysctl__kern_children_addr |= ((uint64_t)0xffff << 48);
    g_sysctl__kern_children_addr = xnu_rebase_va(g_sysctl__kern_children_addr);

    puts("xnuspy: found sysctl__kern_children");

    return true;
}

/* Confirmed working on all kernels 13.0 - 13.7 */
bool sysctl_register_oid_finder_13(xnu_pf_patch_t *patch,
        void *cacheable_stream){
    xnu_pf_disable_patch(patch);

    uint32_t *opcode_stream = cacheable_stream;

    /* the BL we matched is guarenteed to be sysctl_register_oid */
    uint32_t *sysctl_register_oid = get_branch_dst_ptr(opcode_stream + 5);

    g_sysctl_register_oid_addr = xnu_ptr_to_va(sysctl_register_oid);

    puts("xnuspy: found sysctl_register_oid");

    return true;
}

/* Confirmed working on all kernels 13.0 - 15.0 */
bool sysctl_handle_long_finder_13(xnu_pf_patch_t *patch,
        void *cacheable_stream){
    uint32_t *opcode_stream = cacheable_stream;

    xnu_pf_disable_patch(patch);

    /* The patchfinder landed us at sysctl_handle_long or sysctl_handle_quad,
     * whichever came first in the kernelcache, because these functions are
     * pretty much identical. Both of them can act as sysctl_handle_long and
     * be fine. */
    g_sysctl_handle_long_addr = xnu_ptr_to_va(opcode_stream);

    puts("xnuspy: found sysctl_handle_long");

    return true;
}

/* Confirmed working on all kernels 13.0 - 13.7 */
bool name2oid_and_its_dependencies_finder_13(xnu_pf_patch_t *patch,
        void *cacheable_stream){
    uint32_t *opcode_stream = cacheable_stream;

    /* This finds name2oid and two other things:
     *      sysctl_geometry_lock (needs to be held when we call name2oid)
     *      lck_rw_done
     *
     * I can only do a maskmatch with 8 matches/masks, but I need 10.
     * Those last two matches differentiate the right/wrong place because
     * the first 8 matches/masks match two places in the kernel. I'll just
     * manually check if the two instrs after the 8 we just matched are LDR/BL
     */
    uint32_t eigth = opcode_stream[8];
    uint32_t ninth = opcode_stream[9];

    if((eigth & 0xffc0001f) != 0xf9400000 && (ninth & 0xfc000000) != 0x94000000)
        return false;

    xnu_pf_disable_patch(patch);

    uint32_t *sysctl_geometry_lock_addr = (uint32_t *)get_pc_rel_target(opcode_stream);
    uint32_t *name2oid = get_branch_dst_ptr(opcode_stream + 6);
    uint32_t *lck_rw_done = get_branch_dst_ptr(opcode_stream + 9);

    g_sysctl_geometry_lock_addr = xnu_ptr_to_va(sysctl_geometry_lock_addr);
    g_name2oid_addr = xnu_ptr_to_va(name2oid);
    g_lck_rw_done_addr = xnu_ptr_to_va(lck_rw_done);

    puts("xnuspy: found sysctl_geometry_lock");
    puts("xnuspy: found name2oid");
    puts("xnuspy: found lck_rw_done");

    return true;
}

/* Confirmed working on all kernels 13.0 - 15.0 */
bool hook_system_check_sysctlbyname_finder_13(xnu_pf_patch_t *patch,
        void *cacheable_stream){
    uint32_t *opcode_stream = cacheable_stream;

    xnu_pf_disable_patch(patch);

    /* we've landed inside hook_system_check_sysctlbyname, find the first
     * instruction after its prologue and the beginning of its epilogue
     *
     * search up, looking for sub sp, sp, n or add x29, sp, n
     */
    uint32_t instr_limit = 300;

    while((*opcode_stream & 0xffc003ff) != 0xd10003ff &&
            (*opcode_stream & 0xffc003ff) != 0x910003fd){
        if(instr_limit-- == 0)
            return false;

        opcode_stream--;
    }

    /* advance to the first instruction after the prologue */
    opcode_stream++;

    g_h_s_c_sbn_branch_addr = xnu_ptr_to_va(opcode_stream);

    puts("xnuspy: found h_s_c_sbn branch addr");

    /* now we need to find the beginning of its epilogue
     *
     * search down, looking for add sp, sp, n or ldp x29, x30, [sp, n]
     */
    instr_limit = 300;

    while((*opcode_stream & 0xffc003ff) != 0x910003ff &&
            (*opcode_stream & 0xffc07fff) != 0xa9407bfd){
        if(instr_limit-- == 0)
            return false;

        opcode_stream++;
    }

    g_h_s_c_sbn_epilogue_addr = xnu_ptr_to_va(opcode_stream);

    puts("xnuspy: found h_s_c_sbn epilogue");

    return true;
}

/* Confirmed working on all kernels 13.0-13.7 */
bool lck_grp_alloc_init_finder_13(xnu_pf_patch_t *patch,
        void *cacheable_stream){
    xnu_pf_disable_patch(patch);

    /* the BL we matched is guarenteed to be branching to lck_grp_alloc_init */
    uint32_t *blp = ((uint32_t *)cacheable_stream) + 2;

    uint32_t *lck_grp_alloc_init = get_branch_dst_ptr(blp);

    g_lck_grp_alloc_init_addr = xnu_ptr_to_va(lck_grp_alloc_init);

    puts("xnuspy: found lck_grp_alloc_init");

    return true;
}

/* Confirmed working on all kernels 13.0-13.7 */
bool lck_rw_alloc_init_finder_13(xnu_pf_patch_t *patch,
        void *cacheable_stream){
    xnu_pf_disable_patch(patch);

    uint32_t *opcode_stream = cacheable_stream;

    /* the second BL we matched is branching to lck_rw_alloc_init */
    uint32_t instr_limit = 25;
    uint32_t bl_cnt = 0;

    for(;;){
        if(instr_limit-- == 0){
            puts("xnuspy:");
            puts("   lck_rw_alloc_init_finder:");
            puts("   no BLs?");
            return false;
        }

        if((*opcode_stream & 0xfc000000) == 0x94000000){
            bl_cnt++;

            if(bl_cnt == 2)
                break;
        }

        opcode_stream++;
    }

    uint32_t *lck_rw_alloc_init = get_branch_dst_ptr(opcode_stream);

    g_lck_rw_alloc_init_addr = xnu_ptr_to_va(lck_rw_alloc_init);

    puts("xnuspy: found lck_rw_alloc_init");

    return true;
}

/* Confirmed working on all kernels 13.0 - 15.0 */
bool bcopy_phys_finder_13(xnu_pf_patch_t *patch, void *cacheable_stream){
    uint32_t *opcode_stream = cacheable_stream;

    /* search up for:
     *  mov w3, n
     *  b 4
     *
     * for bcopy_phys
     */
    uint32_t instr_limit = 200;

    while(*opcode_stream != 0x14000001 &&
            (opcode_stream[-1] & 0xffe0001f) != 0x52800003){
        if(instr_limit-- == 0)
            return false;

        opcode_stream--;
    }

    /* get on the mov w3, n */
    opcode_stream--;

    /* make sure we are actually on bcopy_phys. Check for sub sp, sp, n
     * two instructions down */
    if((opcode_stream[2] & 0xffc003ff) != 0xd10003ff)
        return false;

    xnu_pf_disable_patch(patch);

    g_bcopy_phys_addr = xnu_ptr_to_va(opcode_stream);
    
    puts("xnuspy: found bcopy_phys");

    return true;
}

/* Confirmed working on all kernels 13.0 - 15.0 */
bool phystokv_finder_13(xnu_pf_patch_t *patch, void *cacheable_stream){
    xnu_pf_disable_patch(patch);

    uint32_t *opcode_stream = cacheable_stream;

    /* We've landed inside arm_vm_init; the 5th instruction from this point
     * is branching to phystokv */
    uint32_t *phystokv = get_branch_dst_ptr(opcode_stream + 5);

    g_phystokv_addr = xnu_ptr_to_va(phystokv);

    puts("xnuspy: found phystokv");

    return true;
}

/* The KTRR & AMCC patchfinder for 13.0-13.7 is from KTRW, @bazad */

/* Confirmed working on all KTRR kernels 13.0-13.7 */
bool ktrr_lockdown_patcher_13(xnu_pf_patch_t *patch, void *cacheable_stream){
    xnu_pf_disable_patch(patch);

    uint32_t *opcode_stream = cacheable_stream;

    *opcode_stream = 0xd503201f;
    opcode_stream[2] = 0xd503201f;
    opcode_stream[4] = 0xd503201f;

    puts("xnuspy: disabled KTRR MMU lockdown");

    return true;
}

/* Confirmed working on all KTRR kernels 13.0-13.7 */
bool amcc_lockdown_patcher_13(xnu_pf_patch_t *patch, void *cacheable_stream){
    xnu_pf_disable_patch(patch);

    uint32_t *opcode_stream = cacheable_stream;

    *opcode_stream = 0xd503201f;
    opcode_stream[2] = 0xd503201f;
    opcode_stream[3] = 0xd503201f;
    opcode_stream[4] = 0xd503201f;

    puts("xnuspy: disabled AMCC MMU lockdown");

    return true;
}

/* Confirmed working on all kernels 13.0 - 15.0 */
bool copyin_finder_13(xnu_pf_patch_t *patch, void *cacheable_stream){
    xnu_pf_disable_patch(patch);

    uint32_t *opcode_stream = cacheable_stream;

    /* we've landed inside copyin, find its prologue
     *
     * looking for stp x22, x21, [sp, -0x30]!
     */
    uint32_t instr_limit = 100;

    while(*opcode_stream != 0xa9bd57f6){
        if(instr_limit-- == 0)
            return false;

        opcode_stream--;
    }

    g_copyin_addr = xnu_ptr_to_va(opcode_stream);

    puts("xnuspy: found copyin");

    return true;
}

/* Confirmed working on all kernels 13.0 - 15.0 */
bool copyout_finder_13(xnu_pf_patch_t *patch, void *cacheable_stream){
    uint32_t *opcode_stream = cacheable_stream;

    /* We may have landed inside copyout. Unfortunately, clang decided to
     * make the order of the three ignored instructions different across
     * kernels. On some kernels, the matches/masks combo matches two places,
     * so we need to make sure we're inside copyout. We're inside copyout if
     * the eighth instruction from this point is cmp w0, 0x12. */
    if(opcode_stream[8] != 0x7100481f)
        return false;

    xnu_pf_disable_patch(patch);

    /* If we're here, then we've landed inside copyout. Find its prologue
     *
     * looking for stp x22, x21, [sp, -0x30]!
     */
    uint32_t instr_limit = 100;

    while(*opcode_stream != 0xa9bd57f6){
        if(instr_limit-- == 0)
            return false;

        opcode_stream--;
    }

    g_copyout_addr = xnu_ptr_to_va(opcode_stream);

    puts("xnuspy: found copyout");

    return true;
}

/* Confirmed working on all kernels 13.0 - 15.0 */
bool IOSleep_finder_13(xnu_pf_patch_t *patch, void *cacheable_stream){
    xnu_pf_disable_patch(patch);

    g_IOSleep_addr = xnu_ptr_to_va(cacheable_stream);

    puts("xnuspy: found IOSleep");

    return true;
}

/* Confirmed working on all kernels 13.0 - 15.0 */
bool kprintf_finder_13(xnu_pf_patch_t *patch, void *cacheable_stream){
    xnu_pf_disable_patch(patch);

    /* We've landed inside kprintf, search up for the start of its prologue */
    uint32_t *opcode_stream = cacheable_stream;

    uint32_t instr_limit = 20;

    while((*opcode_stream & 0xffc003ff) != 0xd10003ff){
        if(instr_limit-- == 0)
            return false;

        opcode_stream--;
    }

    g_kprintf_addr = xnu_ptr_to_va(opcode_stream);

    puts("xnuspy: found kprintf");

    return true;
}

/* Confirmed working on all kernels 13.0 - 14.8 */
bool kernel_map_vm_deallocate_vm_map_unwire_finder_13(xnu_pf_patch_t *patch,
        void *cacheable_stream){
    xnu_pf_disable_patch(patch);

    /* If we're 13.x, we've landed inside profile_release, if we're 14.x,
     * we've landed inside _profile_destroy. For vm_map_unwire, it'll be the
     * branch we're currently sitting at. */
    uint32_t *opcode_stream = cacheable_stream;

    uint32_t *vm_map_unwire = get_branch_dst_ptr(opcode_stream);
    uint32_t *vm_deallocate = get_branch_dst_ptr(opcode_stream + 3);

    g_vm_map_unwire_addr = xnu_ptr_to_va(vm_map_unwire);
    g_vm_deallocate_addr = xnu_ptr_to_va(vm_deallocate);

    /* Finally, we can find kernel_map by searching up for the first ADRP
     * or ADR from where we initially landed */
    uint32_t instr_limit = 150;

    while((*opcode_stream & 0x1f000000) != 0x10000000){
        if(instr_limit-- == 0)
            return false;

        opcode_stream--;
    }

    /* The ADRP,LDR pairs require another level of indirection for this */
    if(((opcode_stream[1] >> 25) & 5) == 4){
        g_kernel_map_addr = *(uint64_t *)get_adrp_ldr_target(opcode_stream);
        g_kernel_map_addr |= ((uint64_t)0xffff << 48);
        g_kernel_map_addr = kext_rebase_va(g_kernel_map_addr);
    }
    else{
        uint64_t kernel_map_addr;

        if(*opcode_stream & 0x80000000)
            kernel_map_addr = get_adrp_add_target(opcode_stream);
        else
            kernel_map_addr = get_adr_target(opcode_stream);

        g_kernel_map_addr = xnu_ptr_to_va((void *)kernel_map_addr);
    }

    puts("xnuspy: found vm_map_unwire");
    puts("xnuspy: found vm_deallocate");
    puts("xnuspy: found kernel_map");

    return true;
}

/* Confirmed working on all kernels 13.0 - 15.0 */
bool kernel_thread_start_thread_deallocate_finder_13(xnu_pf_patch_t *patch,
        void *cacheable_stream){
    /* There's two hits for this, but they're identical, so whatever is
     * matched first will do */
    xnu_pf_disable_patch(patch);

    uint32_t *opcode_stream = cacheable_stream;

    uint32_t *kernel_thread_start = get_branch_dst_ptr(opcode_stream);
    uint32_t *thread_deallocate = get_branch_dst_ptr(opcode_stream + 8);

    g_kernel_thread_start_addr = xnu_ptr_to_va(kernel_thread_start);
    g_thread_deallocate_addr = xnu_ptr_to_va(thread_deallocate);

    puts("xnuspy: found kernel_thread_start");
    puts("xnuspy: found thread_deallocate");

    return true;
}

/* Confirmed working on all kernels 13.0 - 15.0 */
bool mach_make_memory_entry_64_finder_13(xnu_pf_patch_t *patch,
        void *cacheable_stream){
    xnu_pf_disable_patch(patch);

    g_mach_make_memory_entry_64_addr = xnu_ptr_to_va(cacheable_stream);

    puts("xnuspy: found mach_make_memory_entry_64");

    return true;
}

/* Confirmed working on all kernels 13.0 - 15.0 */
bool offsetof_struct_thread_map_finder_13(xnu_pf_patch_t *patch,
        void *cacheable_stream){
    /* For iOS 13 & 14 we landed in mmap, or in the case of iOS 15
     * we landed in _mach_vm_read_overwrite. In both cases, the first 
     * LDR we matched contains the offset of the map pointer inside 
     * struct thread */
    xnu_pf_disable_patch(patch);

    uint32_t *opcode_stream = cacheable_stream;

    uint32_t ldr = opcode_stream[1];
    uint64_t imm12 = (ldr & 0x3ffc00) >> 10;
    uint32_t size = ldr >> 30;

    g_offsetof_struct_thread_map = (uint64_t)(imm12 << size);

    puts("xnuspy: found offsetof(struct thread, map)");

    return true;
}

/* Confirmed working on all kernels 13.0 - 14.8 */
bool proc_stuff0_finder_13(xnu_pf_patch_t *patch, void *cacheable_stream){
    /* We've landed in proc_self. This finds:
     *      - current_proc
     *      - proc_ref_locked
     *      - proc_list_mlock
     *      - lck_mtx_unlock
     *      - proc_rele_locked
     * Right above proc_self is proc_rele_locked. proc_list_unlock
     * has been inlined so aggressively that there are no xrefs to the actual
     * function, which is obnoxious */
    xnu_pf_disable_patch(patch);

    uint32_t *opcode_stream = cacheable_stream;

    uint32_t *current_proc = get_branch_dst_ptr(opcode_stream + 1);
    uint32_t *proc_list_lock = get_branch_dst_ptr(opcode_stream + 3);
    uint32_t *proc_ref_locked = get_branch_dst_ptr(opcode_stream + 5);

    g_current_proc_addr = xnu_ptr_to_va(current_proc);
    g_proc_ref_locked_addr = xnu_ptr_to_va(proc_ref_locked);

    /* Go down until we hit an ADRP or ADR, this will be proc_list_mlock, and
     * the first bl below that will be lck_mtx_unlock */
    uint32_t instr_limit = 50;

    while((*opcode_stream & 0x1f000000) != 0x10000000){
        if(instr_limit-- == 0)
            return false;

        opcode_stream++;
    }

    g_proc_list_mlock_addr = xnu_ptr_to_va((void *)get_pc_rel_target(opcode_stream));

    instr_limit = 20;

    while((*opcode_stream & 0xfc000000) != 0x94000000){
        if(instr_limit-- == 0)
            return false;

        opcode_stream++;
    }

    uint32_t *lck_mtx_unlock = get_branch_dst_ptr(opcode_stream);

    g_lck_mtx_unlock_addr = xnu_ptr_to_va(lck_mtx_unlock);

    /* Finally, search up for proc_rele_locked. We'll look until we hit
     * ldr w8, [x0, n]. On some kernels, clang did not place the prologue
     * at the beginning of this function, but at the bottom for a call to
     * panic. So, we could either have ldr w8, [x0, n] or stp x29, x30, [sp, -0x10]!
     * at the beginning, but the ldr is guarenteed to be somewhere close
     * to the start so we'll look for that. */
    instr_limit = 250;

    while((*opcode_stream & 0xffc003ff) != 0xb9400008){
        if(instr_limit-- == 0)
            return false;

        opcode_stream--;
    }

    /* We're at the ldr, and if we're at the beginning of proc_rele_locked,
     * we will not see mov x29, sp. If we see that, the beginning is two
     * instructions behind this point. */
    if(opcode_stream[-1] == 0x910003fd)
        opcode_stream -= 2;

    g_proc_rele_locked_addr = xnu_ptr_to_va(opcode_stream);

    puts("xnuspy: found current_proc");
    puts("xnuspy: found proc_ref_locked");
    puts("xnuspy: found proc_list_mlock");
    puts("xnuspy: found lck_mtx_unlock");
    puts("xnuspy: found proc_rele_locked");

    return true;
}

/* Confirmed working on all kernels 13.0 - 15.0 */
bool proc_stuff1_finder_13(xnu_pf_patch_t *patch, void *cacheable_stream){
    /* We've landed in sandbox_reference_retain. This finds:
     *      - proc_pid
     *      - proc_uniqueid
     *
     * The first branch we see while searching up will be proc_uniqueid, and
     * the branch before that one will be proc_pid */
    xnu_pf_disable_patch(patch);

    uint32_t *opcode_stream = cacheable_stream;
    uint32_t instr_limit = 50;

    while((*opcode_stream & 0xfc000000) != 0x94000000){
        if(instr_limit-- == 0)
            return false;

        opcode_stream--;
    }

    uint32_t *proc_uniqueid = get_branch_dst_ptr(opcode_stream);

    /* Get off the branch to proc_uniqueid */
    opcode_stream--;

    while((*opcode_stream & 0xfc000000) != 0x94000000){
        if(instr_limit-- == 0)
            return false;

        opcode_stream--;
    }

    uint32_t *proc_pid = get_branch_dst_ptr(opcode_stream);

    g_proc_uniqueid_addr = xnu_ptr_to_va(proc_uniqueid);
    g_proc_pid_addr = xnu_ptr_to_va(proc_pid);

    puts("xnuspy: found proc_uniqueid");
    puts("xnuspy: found proc_pid");

    return true;
}

/* Confirmed working on all kernels 13.0 - 15.0 */
bool allproc_finder_13(xnu_pf_patch_t *patch, void *cacheable_stream){
    /* The ADRP three instructions past this point is for allproc */
    xnu_pf_disable_patch(patch);

    uint32_t *opcode_stream = cacheable_stream;

    g_allproc_addr = xnu_ptr_to_va((void *)get_pc_rel_target(opcode_stream + 3));

    puts("xnuspy: found allproc");

    return true;
}

/* Confirmed working on all kernels 13.0 - 15.0 */
bool misc_lck_stuff_finder_13(xnu_pf_patch_t *patch, void *cacheable_stream){
    /* We've landed in sflt_initsock. This finds:
     *      - lck_rw_lock_shared
     *      - lck_rw_lock_shared_to_exclusive
     *      - lck_rw_lock_exclusive
     *
     * From a programming perspective, lck_rw_lock would satisfy both the
     * first and third, but from a patchfinding perspective, it's so much
     * easier to get all three of these at once. (note: name2oid and its
     * dependencies finder also gets lck_rw_lock_shared on 14.x, but
     * not on 13.x)
     *
     * The first three BLs we see are for lck_rw_lock_shared,
     * lck_rw_lock_shared_to_exclusive, and lck_rw_lock_exclusive */
    bool already_found = g_lck_rw_lock_shared_addr != 0;

    uint32_t *opcode_stream = cacheable_stream;
    uint32_t seen_bls = 0;
    uint32_t instr_limit = 100;

    uint64_t *offs[] = { &g_lck_rw_lock_shared_addr,
        &g_lck_rw_lock_shared_to_exclusive_addr,
        &g_lck_rw_lock_exclusive_addr };

    while(seen_bls < 3){
        if(instr_limit-- == 0)
            return false;

        if((*opcode_stream & 0xfc000000) == 0x94000000){
            uint32_t *dst = get_branch_dst_ptr(opcode_stream);
            *offs[seen_bls] = xnu_ptr_to_va(dst);
            seen_bls++;
        }

        opcode_stream++;
    }

    xnu_pf_disable_patch(patch);

    if(!already_found)
        puts("xnuspy: found lck_rw_lock_shared");

    puts("xnuspy: found lck_rw_lock_shared_to_exclusive");
    puts("xnuspy: found lck_rw_lock_exclusive");

    return true;
}

/* Confirmed working on all kernels 13.0 - 15.0 */
bool vm_map_wire_external_finder_13(xnu_pf_patch_t *patch,
        void *cacheable_stream){
    /* We've matched a ton of places, we're in vm_map_wire_external if
     * the 14th/15th instrs from this point are mov x6, 0 and mov x7, 0 */
    uint32_t *opcode_stream = cacheable_stream;

    if(opcode_stream[14] != 0xd2800006 && opcode_stream[15] != 0xd2800007)
        return false;

    xnu_pf_disable_patch(patch);

    /* We're inside vm_map_wire_external, find the beginning. Looking for
     * sub sp, sp, n */
    uint32_t instr_limit = 50;

    while((*opcode_stream & 0xffc003ff) != 0xd10003ff){
        if(instr_limit-- == 0)
            return false;

        opcode_stream--;
    }
    
    g_vm_map_wire_external_addr = xnu_ptr_to_va(opcode_stream);

    puts("xnuspy: found vm_map_wire_external");

    return true;
}

/* Confirmed working on all kernels 13.0 - 15.0 */
bool mach_vm_map_external_finder_13(xnu_pf_patch_t *patch,
        void *cacheable_stream){
    /* We've matched a couple places, we are in mach_vm_map_external if the
     * 6th instruction from this point is mov x8, x5 */
    uint32_t *opcode_stream = cacheable_stream;

    if(opcode_stream[6] != 0xaa0503e8)
        return false;

    xnu_pf_disable_patch(patch);

    /* Find mach_vm_map_external's start. Searching for sub sp, sp, n */
    uint32_t instr_limit = 50;

    while((*opcode_stream & 0xffc003ff) != 0xd10003ff){
        if(instr_limit-- == 0)
            return false;

        opcode_stream--;
    }

    g_mach_vm_map_external_addr = xnu_ptr_to_va(opcode_stream);

    puts("xnuspy: found mach_vm_map_external");

    return true;
}

/* Confirmed working on all kernels 13.0 - 14.8 */
bool ipc_port_release_send_finder_13(xnu_pf_patch_t *patch,
        void *cacheable_stream){
    /* We've landed inside exception_deliver, or if we're on 14.6,
     * exception_triage_thread, the 2nd instruction from this
     * point is a BL to ipc_port_release_send. Also on 14.6, Apple seemed
     * to have moved the code which takes the port's lock from this
     * function to another smaller function. The smaller function is
     * inlined all over the place, but it calls io_lock, so we'll be able
     * to find a branch to io_lock right above where we landed. If we're
     * not on 14.6, this branch will be to ipc_port_release send. */
    xnu_pf_disable_patch(patch);

    uint32_t *opcode_stream = cacheable_stream;
    uint32_t *ipc_port_release_send = get_branch_dst_ptr(opcode_stream + 1);

    /* Just for clarity */
    if(is_14_5_and_above__pongo()){
        g_ipc_port_release_send_and_unlock_addr = xnu_ptr_to_va(ipc_port_release_send);
        puts("xnuspy: found ipc_port_release_send_and_unlock");
    }
    else{
        g_ipc_port_release_send_addr = xnu_ptr_to_va(ipc_port_release_send);
        puts("xnuspy: found ipc_port_release_send");
        return true;
    }

    uint32_t *io_lock = get_branch_dst_ptr(opcode_stream - 1);

    g_io_lock_addr = xnu_ptr_to_va(io_lock);

    puts("xnuspy: found io_lock");

    return true;
}

/* Confirmed working on all kernels 13.0 - 15.0 */
bool lck_rw_free_finder_13(xnu_pf_patch_t *patch, void *cacheable_stream){
    /* We've landed inside IORWLockFree, the unconditional branch is to
     * lck_rw_free */
    xnu_pf_disable_patch(patch);

    uint32_t *opcode_stream = cacheable_stream;

    uint32_t *lck_rw_free = get_branch_dst_ptr(opcode_stream + 2);

    g_lck_rw_free_addr = xnu_ptr_to_va(lck_rw_free);

    puts("xnuspy: found lck_rw_free");

    return true;
}

/* Confirmed working on all kernels 13.0 - 14.8 */
bool lck_grp_free_finder_13(xnu_pf_patch_t *patch, void *cacheable_stream){
    /* We've landed inside ipf_init, the 5th instruction from this point
     * is branching to lck_grp_free */
    xnu_pf_disable_patch(patch);

    uint32_t *opcode_stream = cacheable_stream;

    uint32_t *lck_grp_free = get_branch_dst_ptr(opcode_stream + 5);

    g_lck_grp_free_addr = xnu_ptr_to_va(lck_grp_free);

    puts("xnuspy: found lck_grp_free");

    return true;
}

/* Confirmed working on all kernels 13.0 - 15.0 */
bool doprnt_hide_pointers_patcher_13(xnu_pf_patch_t *patch,
        void *cacheable_stream){
    /* XNU only respects -show_pointers when debug_enabled is non-zero,
     * so I need to patch doprnt_hide_pointers manually. We've landed in
     * __doprnt, the next ADR/ADRP will be to doprnt_hide_pointers */
    xnu_pf_disable_patch(patch);

    uint32_t *opcode_stream = cacheable_stream;

    uint32_t instr_limit = 40;

    while((*opcode_stream & 0x1f000000) != 0x10000000){
        if(instr_limit-- == 0)
            return false;

        opcode_stream++;
    }

    *(uint32_t *)get_pc_rel_target(opcode_stream) = 0;

    g_patched_doprnt_hide_pointers = 1;

    puts("xnuspy: unset doprnt_hide_pointers");

    return true;
}

/* Confirmed working on all kernels 13.0 - 15.0 */
bool copyinstr_finder_13(xnu_pf_patch_t *patch, void *cacheable_stream){
    /* We've landed inside copyinstr, find its prologue. Looking for
     * sub sp, sp, n */
    xnu_pf_disable_patch(patch);

    uint32_t *opcode_stream = cacheable_stream;
    uint32_t instr_limit = 50;

    while((*opcode_stream & 0xffc003ff) != 0xd10003ff){
        if(instr_limit-- == 0)
            return false;

        opcode_stream--;
    }

    g_copyinstr_addr = xnu_ptr_to_va(opcode_stream);

    puts("xnuspy: found copyinstr");

    return true;
}

/* Confirmed working on all kernels 13.0 - 15.0 */
bool thread_terminate_finder_13(xnu_pf_patch_t *patch,
        void *cacheable_stream){
    /* We landed inside of _Call_continuation, the branch four
     * instructions down is for thread_terminate */
    xnu_pf_disable_patch(patch);

    uint32_t *opcode_stream = cacheable_stream;

    uint32_t *thread_terminate = get_branch_dst_ptr(opcode_stream + 4);

    g_thread_terminate_addr = xnu_ptr_to_va(thread_terminate);

    puts("xnuspy: found thread_terminate");

    return true;
}

/* Confirmed working on all A10+ kernels 13.0 - 15.0 */
bool pinst_set_tcr_patcher_13(xnu_pf_patch_t *patch, void *cacheable_stream){
    /* We need to keep TCR_EL1.HPD0 and TCR_EL1.HPD1 set if we want
     * A10+ to respect PTE permission bits as they are. We landed inside
     * of pinst_set_tcr, and we are replacing it with:
     *  orr x0, x0, 0x60000000000
     *  msr tcr_el1, x0
     *  ret
     *
     * A9(x) does not contain a pinst segment. */
    xnu_pf_disable_patch(patch);

    uint32_t *opcode_stream = cacheable_stream;

    *opcode_stream++ = 0xb2570400;
    *opcode_stream++ = 0xd5182040;
    *opcode_stream++ = 0xd65f03c0;

    g_patched_pinst_set_tcr = 1;

    puts("xnuspy: patched pinst_set_tcr");

    return true;
}

/* Confirmed working on all A10+ kernels 13.0 - 15.0 */
bool msr_tcr_el1_x18_patcher_13(xnu_pf_patch_t *patch,
        void *cacheable_stream){
    /* These patches don't need to be done on A9(x) */
    if(socnum < 0x8010){
        xnu_pf_disable_patch(patch);
        return true;
    }

    static int count = 1;
    uint32_t *opcode_stream = cacheable_stream;

    /* We are either in exception_return_unint_tpidr_x3{_dont_trash_x18} or
     * one of the exception vectors for exceptions from EL0. Either way,
     * we are sitting at msr tcr_el1, x18, and the value copied to x18 is
     * either TCR_EL1_USER or TCR_EL1_BOOT. Both of these constants don't
     * have TCR_EL1.HPD0 or TCR_EL1.HPD1 set, so we need to modify the
     * value copied to x18 ourselves. Right before where we are sitting is
     * this:
     *  movk x18, n, lsl 48
     *  movk x18, n, lsl 32
     *  movk x18, n, lsl 16
     *  movk x18, n
     *
     * HPD0 is the 41st bit and HPD1 is the 42nd bit of TCR_EL1, so patch
     * the immediate of the second movk. */
    opcode_stream[-3] |= (0x600 << 5);

    if(count == 5){
        xnu_pf_disable_patch(patch);
        puts("xnuspy: patched all occurrences of msr tcr_el1, x18");
        g_patched_all_msr_tcr_el1_x18 = 1;
    }

    count++;

    return true;
}

/* Confirmed working on all kernels 13.0 - 14.8 */
bool proc_name_snprintf_strlen_finder_13(xnu_pf_patch_t *patch,
        void *cacheable_stream){
    xnu_pf_disable_patch(patch);

    uint32_t *opcode_stream = cacheable_stream;

    uint32_t *snprintf = get_branch_dst_ptr(opcode_stream - 2);
    uint32_t *strlen = get_branch_dst_ptr(opcode_stream);
    uint32_t *proc_name = get_branch_dst_ptr(opcode_stream + 4);

    g_snprintf_addr = xnu_ptr_to_va(snprintf);
    g_strlen_addr = xnu_ptr_to_va(strlen);
    g_proc_name_addr = xnu_ptr_to_va(proc_name);

    puts("xnuspy: found snprintf");
    puts("xnuspy: found strlen");
    puts("xnuspy: found proc_name");

    return true;
}

/* Confirmed working on all kernels 13.0 - 15.0 */
bool strncmp_finder_13(xnu_pf_patch_t *patch, void *cacheable_stream){
    xnu_pf_disable_patch(patch);

    g_strncmp_addr = xnu_ptr_to_va(cacheable_stream);

    puts("xnuspy: found strncmp");

    return true;
}

/* Confirmed working on all kernels 13.0 - 15.0 */
bool memset_finder_13(xnu_pf_patch_t *patch, void *cacheable_stream){
    xnu_pf_disable_patch(patch);

    uint32_t *opcode_stream = cacheable_stream;

    /* Look for the start of memset's prologue, trying to match
     * stp x29, x30, [sp, -0x10]! */
    uint32_t instr_limit = 20;

    while(*opcode_stream != 0xa9bf7bfd){
        if(instr_limit-- == 0)
            return false;

        opcode_stream--;
    }

    g_memset_addr = xnu_ptr_to_va(opcode_stream);

    puts("xnuspy: found memset");

    return true;
}

/* Confirmed working on all kernels 13.0 - 15.0 */
bool memmove_finder_13(xnu_pf_patch_t *patch, void *cacheable_stream){
    xnu_pf_disable_patch(patch);

    uint32_t *opcode_stream = cacheable_stream;

    /* Look for the start of memmove's prologue, trying to match
     * stp x29, x30, [sp, -0x10]! */
    uint32_t instr_limit = 20;

    while(*opcode_stream != 0xa9bf7bfd){
        if(instr_limit-- == 0)
            return false;

        opcode_stream--;
    }

    g_memmove_addr = xnu_ptr_to_va(opcode_stream);

    puts("xnuspy: found memmove");

    return true;
}

/* Confirmed working on all kernels 13.0 - 15.0 */
bool panic_finder_13(xnu_pf_patch_t *patch, void *cacheable_stream){
    xnu_pf_disable_patch(patch);

    uint32_t *opcode_stream = cacheable_stream;

    /* Look for the start of panic's prologue, trying to match
     * sub sp, sp, n */
    uint32_t instr_limit = 50;

    while((*opcode_stream & 0xffc003ff) != 0xd10003ff){
        if(instr_limit-- == 0)
            return false;

        opcode_stream--;
    }

    g_panic_addr = xnu_ptr_to_va(opcode_stream);

    puts("xnuspy: found panic");

    return true;
}

/* Confirmed working on all kernels 13.0 - 15.0 */
bool mach_to_bsd_errno_finder_13(xnu_pf_patch_t *patch,
        void *cacheable_stream){
    xnu_pf_disable_patch(patch);

    g_mach_to_bsd_errno_addr = xnu_ptr_to_va(cacheable_stream);

    puts("xnuspy: found mach_to_bsd_errno");

    return true;
}

/* Confirmed working on all kernels 13.0 - 15.0 */
bool vm_allocate_external_finder_13(xnu_pf_patch_t *patch,
        void *cacheable_stream){
    /* We are either inside mach_vm_allocate_external or
     * vm_allocate_external, same things on 64 bit, so let's
     * just take whatever this is as vm_allocate_external */
    xnu_pf_disable_patch(patch);

    g_vm_allocate_external_addr = xnu_ptr_to_va(cacheable_stream);

    puts("xnuspy: found vm_allocate_external");

    return true;
}

/* Confirmed working on all kernels 13.0 - 15.0 */
bool vm_map_deallocate_offsetof_vm_map_refcnt_finder_13(xnu_pf_patch_t *patch,
        void *cacheable_stream){
    /* vm_map_reference does not exist on release kernels because it was
     * inlined everywhere it is called. So I will get the offset to the
     * reference count and then re-implement it in the kernel code.
     *
     * We landed in IOMemoryMap::taskDied, the call to vm_map_deallocate
     * is one instruction below */
    xnu_pf_disable_patch(patch);

    uint32_t *opcode_stream = cacheable_stream;
    uint32_t *vm_map_deallocate = get_branch_dst_ptr(opcode_stream + 1);

    g_vm_map_deallocate_addr = xnu_ptr_to_va(vm_map_deallocate);

    /* Now get the offset of the reference count. Searching
     * for add xn, x19, #n */
    uint32_t instr_limit = 100;

    while((*vm_map_deallocate & 0xffc003e0) != 0x91000260){
        if(instr_limit-- == 0)
            return false;

        vm_map_deallocate++;
    }

    uint32_t add = *vm_map_deallocate;
    uint64_t imm12 = (add & 0x3ffc00) >> 10;
    uint32_t sh = (add >> 22) & 1;

    g_offsetof_struct_vm_map_refcnt = imm12;

    if(sh)
        g_offsetof_struct_vm_map_refcnt <<= 12;

    puts("xnuspy: found vm_map_deallocate");
    puts("xnuspy: found offsetof(vm_map_t, refcnt)");

    return true;
}

/* Confirmed working on all kernels 13.0 - 15.0 */
bool IOLog_finder_13(xnu_pf_patch_t *patch, void *cacheable_stream){
    /* We landed inside IOService::finalize, call to IOLog is three
     * instructions down */
    xnu_pf_disable_patch(patch);

    uint32_t *opcode_stream = cacheable_stream;

    uint32_t *IOLog = get_branch_dst_ptr(opcode_stream + 3);

    g_IOLog_addr = xnu_ptr_to_va(IOLog);

    puts("xnuspy: found IOLog");

    return true;
}

/* Confirmed working on all kernels 13.0 - 14.8 */
bool lck_mtx_lock_finder_13(xnu_pf_patch_t *patch, void *cacheable_stream){
    /* We landed in _spaceman_ip_block_alloc, the call to lck_mtx_lock
     * is right behind us */
    xnu_pf_disable_patch(patch);

    uint32_t *opcode_stream = cacheable_stream;

    uint32_t *lck_mtx_lock = get_branch_dst_ptr(opcode_stream - 1);

    g_lck_mtx_lock_addr = xnu_ptr_to_va(lck_mtx_lock);

    puts("xnuspy: found lck_mtx_lock");

    return true;
}

```

`module/pf/14/Makefile`:

```
pf.o : pf.c $(RP)/include/pf/14/pf.h
	$(CC) $(CFLAGS) pf.c -c

```

`module/pf/14/pf.c`:

```c
#include <stdbool.h>
#include <stdio.h>
#include <stdint.h>

#include <pongo.h>

#include <asm/asm.h>
#include <common/common.h>
#include <pf/offsets.h>
#include <pf/pf_common.h>

uint64_t g_kalloc_external_addr = 0;
uint64_t g_kfree_ext_addr = 0;

/* Confirmed working 14.0 - 15.0 */
bool kalloc_external_finder_14(xnu_pf_patch_t *patch, void *cacheable_stream){
    /* We've landed somewhere inside AMFI, kalloc_external is the
     * branch six instructions down */
    xnu_pf_disable_patch(patch);

    uint32_t *opcode_stream = cacheable_stream;
    uint32_t *kalloc_external = get_branch_dst_ptr(opcode_stream + 6);

    g_kalloc_external_addr = xnu_ptr_to_va(kalloc_external);

    puts("xnuspy: found kalloc_external");

    return true;
}

/* Confirmed working 14.0 - 15.0 */
bool kfree_ext_finder_14(xnu_pf_patch_t *patch, void *cacheable_stream){
    /* For 14.x, we've landed somewhere in mach_gss_accept_sec_context,
     * kfree_ext is the branch three instructions down.
     *
     * For 15.x, the matches/masks get two hits, but in both cases, the
     * branch to kfree_ext is four instructions down. */
    xnu_pf_disable_patch(patch);

    uint32_t *opcode_stream = cacheable_stream;

    uint32_t limit = 8;
    for (int i = 0; i < limit; i++){
        if ((opcode_stream[i] & 0xfc000000) == 0x94000000){
            uint32_t *kfree_ext = get_branch_dst_ptr(opcode_stream + i);

            g_kfree_ext_addr = xnu_ptr_to_va(kfree_ext);

            puts("xnuspy: found kfree_ext");
            return true;
        }
    }

    return false;
}

/* Confirmed working 14.0 - 15.0 */
bool ExceptionVectorsBase_finder_14(xnu_pf_patch_t *patch,
        void *cacheable_stream){
    xnu_pf_disable_patch(patch);

    uint32_t *opcode_stream = cacheable_stream;

    g_ExceptionVectorsBase_stream = cacheable_stream;

    uint32_t limit = PAGE_SIZE / sizeof(uint32_t);

    /* go backwords one opcode, we'll hit the stream of values that clang
     * decided to page align ExceptionVectorsBase with */
    opcode_stream--;

    uintptr_t orig_opcode_stream = (uintptr_t)opcode_stream;
    uint32_t filler_opcode = *opcode_stream;

    /* go backwords until we hit an instruction */
    while(limit-- != 0){
        uint32_t cur = *opcode_stream;

        if(cur != filler_opcode)
            break;

        opcode_stream--;
    }

    /* get off this instruction, now we point to the beginning of unused
     * executable code */
    opcode_stream++;

    g_exec_scratch_space_size = orig_opcode_stream - (uintptr_t)opcode_stream;
    g_exec_scratch_space_addr = xnu_ptr_to_va(opcode_stream);

    puts("xnuspy: found unused executable code");

    return true;
}

/* Confirmed working 14.0 - 15.0 */
bool sysctl__kern_children_and_register_oid_finder_14(xnu_pf_patch_t *patch,
        void *cacheable_stream){
    xnu_pf_disable_patch(patch);

    /* We've landed inside corecrypto_kext_start. There's a stream of
     * ADRP, BL _sysctl_register_oid right above where we are. I know that the
     * first ADRP in this stream is how we can get sysctl__kern_children, so
     * let's find the beginning. Search up, looking for STUR X8, [X29, n] */
    uint32_t *opcode_stream = cacheable_stream;
    uint32_t limit = 500;

    while((*opcode_stream & 0xffe00fff) != 0xf80003a8){
        if(limit-- == 0)
            return false;

        opcode_stream--;
    }

    /* Now we're on the STUR. The first ADRP,BL pair is actually a kprintf
     * call, so skip the next four instructions */
    opcode_stream += 4;

    g_sysctl__kern_children_addr = *(uint64_t *)get_pc_rel_target(opcode_stream);
    g_sysctl__kern_children_addr |= ((uint64_t)0xffff << 48);
    g_sysctl__kern_children_addr = kext_rebase_va(g_sysctl__kern_children_addr);

    uint32_t *sysctl_register_oid = get_branch_dst_ptr(opcode_stream + 2);

    g_sysctl_register_oid_addr = xnu_ptr_to_va(sysctl_register_oid);
    
    puts("xnuspy: found sysctl__kern_children");
    puts("xnuspy: found sysctl_register_oid");

    return true;
}

/* Confirmed working 14.0 - 15.0 */
bool lck_grp_alloc_init_finder_14(xnu_pf_patch_t *patch,
        void *cacheable_stream){
    xnu_pf_disable_patch(patch);

    uint32_t *opcode_stream = cacheable_stream;

    uint32_t *lck_grp_alloc_init = get_branch_dst_ptr(opcode_stream + 15);

    g_lck_grp_alloc_init_addr = xnu_ptr_to_va(lck_grp_alloc_init);

    puts("xnuspy: found lck_grp_alloc_init");

    return true;
}

/* Confirmed working 14.0 - 14.8 */
bool lck_rw_alloc_init_finder_14(xnu_pf_patch_t *patch,
        void *cacheable_stream){
    /* On 14.x, we land inside tcp_init, and are sitting on a branch
     * to lck_rw_alloc_init */
    xnu_pf_disable_patch(patch);

    uint32_t *opcode_stream = cacheable_stream;

    uint32_t *lck_rw_alloc_init = get_branch_dst_ptr(opcode_stream);

    g_lck_rw_alloc_init_addr = xnu_ptr_to_va(lck_rw_alloc_init);

    puts("xnuspy: found lck_rw_alloc_init");

    return true;
}

/* Confirmed working on all KTRR kernels 14.0 - 15.0 */
bool ktrr_lockdown_patcher_14(xnu_pf_patch_t *patch, void *cacheable_stream){
    /* This also hits rorgn_lockdown, where the AMCC CTRR patches are,
     * but it's easier for me to separate them since the instruction
     * sequences are so different */
    static int count = 1;
    uint32_t *opcode_stream = cacheable_stream;

    *opcode_stream = 0xd503201f;
    opcode_stream[1] = 0xd503201f;
    opcode_stream[3] = 0xd503201f;

    if(count == 2){
        xnu_pf_disable_patch(patch);
        puts("xnuspy: disabled KTRR MMU lockdown");
    }

    count++;

    return true;
}

/* Confirmed working on all KTRR kernels 14.0 - 15.0 */
bool amcc_ctrr_lockdown_patcher_14(xnu_pf_patch_t *patch,
        void *cacheable_stream){
    /* On 14.x A10+ there doesn't seem to be a specific lock for
     * RoRgn, instead we've got these AMCC CTRR registers. We are
     * patching three of them: lock, enable, and write-disable. See
     * find_lock_group_data and rorgn_lockdown for more info. */
    static int count = 1;
    uint32_t *opcode_stream = cacheable_stream;

    /* str w0, [x16, x17] --> str wzr, [x16, x17] */
    opcode_stream[5] = 0xb8316a1f;

    if(count == 3){
        xnu_pf_disable_patch(patch);
        puts("xnuspy: disabled AMCC CTRR MMU lockdown");
    }

    count++;

    return true;
}

/* Confirmed working 14.0 - 15.0 */
bool name2oid_and_its_dependencies_finder_14(xnu_pf_patch_t *patch,
        void *cacheable_stream){
    /* This finds name2oid and three other things:
     *      sysctl_geometry_lock (needs to be held when we call name2oid)
     *      lck_rw_lock_shared
     *      lck_rw_done
     *
     * We are currently sitting on a branch to lck_rw_lock_shared.
     * The first ADRP we see before this point is getting the address
     * of sysctl_geometry_lock. Four instructions down is a branch to
     * name2oid, and seven instructions down is a branch to lck_rw_done.
     */
    xnu_pf_disable_patch(patch);

    bool already_found = g_lck_rw_lock_shared_addr != 0;

    uint32_t *opcode_stream = cacheable_stream;

    uint32_t *lck_rw_lock_shared = get_branch_dst_ptr(opcode_stream);
    uint32_t *name2oid = get_branch_dst_ptr(opcode_stream + 4);
    uint32_t *lck_rw_done = get_branch_dst_ptr(opcode_stream + 7);

    /* Find the first ADRP or ADR before this point */
    uint32_t instr_limit = 20;

    while((*opcode_stream & 0x1f000000) != 0x10000000){
        if(instr_limit-- == 0)
            return false;

        opcode_stream--;
    }

    uint32_t *sysctl_geometry_lock_addr = (uint32_t *)get_pc_rel_target(opcode_stream);

    g_sysctl_geometry_lock_addr = xnu_ptr_to_va(sysctl_geometry_lock_addr);
    g_lck_rw_lock_shared_addr = xnu_ptr_to_va(lck_rw_lock_shared);
    g_name2oid_addr = xnu_ptr_to_va(name2oid);
    g_lck_rw_done_addr = xnu_ptr_to_va(lck_rw_done);

    if(!already_found)
        puts("xnuspy: found lck_rw_lock_shared");

    puts("xnuspy: found name2oid");
    puts("xnuspy: found lck_rw_done");
    puts("xnuspy: found sysctl_geometry_lock");

    return true;
}

```

`module/pf/15/Makefile`:

```
pf.o : pf.c $(RP)/include/pf/15/pf.h
	$(CC) $(CFLAGS) pf.c -c

```

`module/pf/15/pf.c`:

```c
#include <stdbool.h>
#include <stdio.h>
#include <stdint.h>

#include <pongo.h>

#include <asm/asm.h>
#include <common/common.h>
#include <pf/offsets.h>
#include <pf/pf_common.h>

uint64_t g_vm_map_unwire_nested_addr = 0;
uint64_t g_proc_ref_addr = 0;
uint64_t g_proc_rele_addr = 0;
uint64_t g_ipc_object_lock_addr = 0;

/* Confirmed working 15.0 */
bool ipc_port_release_send_finder_15(xnu_pf_patch_t *patch, 
        void *cacheable_stream){
    /* will land in _exception_deliver in iOS 15. There is a sequence
     * where they lock/release 4 IPC ports if they are non-null. This
     * patchfinder will take us here, then it's just a matter of
     * resolving the branches. We get about 26 hits for these matches
     * and masks, so let's make sure we're actually in _exception_deliver.
     * If we are, then the two instructions behind where we landed will be
     * mov x27, #0 and mov x26, x0 */
    uint32_t *opcode_stream = cacheable_stream;

    if(opcode_stream[-1] != 0xd280001b && opcode_stream[-2] != 0xaa0003fa)
        return false;

    xnu_pf_disable_patch(patch);

    uint32_t *ipc_port_release_send_and_unlock = get_branch_dst_ptr(opcode_stream + 6);
    uint32_t *ipc_object_lock = get_branch_dst_ptr(opcode_stream + 4);

    g_ipc_port_release_send_and_unlock_addr = xnu_ptr_to_va(ipc_port_release_send_and_unlock);
    g_ipc_object_lock_addr = xnu_ptr_to_va(ipc_object_lock);

    puts("xnuspy: found ipc_port_release_send_and_unlock");
    puts("xnuspy: found ipc_object_lock");

    return true;
}

/* Confirmed working 15.0 */
bool proc_name_snprintf_strlen_finder_15(xnu_pf_patch_t *patch,
        void *cacheable_stream){
    /* will land either in AppleEmbeddedUSBDevice::setAuthenticationProperites
     * or AppleEmbeddedUSBDevice::setProperties, both look the same, so
     * just use the one we land in first */
    xnu_pf_disable_patch(patch);

    uint32_t *opcode_stream = cacheable_stream;

    uint32_t *snprintf = get_branch_dst_ptr(opcode_stream + 2);
    uint32_t *strlen = get_branch_dst_ptr(opcode_stream + 4);
    uint32_t *proc_name = get_branch_dst_ptr(opcode_stream + 8);

    g_snprintf_addr = xnu_ptr_to_va(snprintf);
    g_strlen_addr = xnu_ptr_to_va(strlen);
    g_proc_name_addr = xnu_ptr_to_va(proc_name);

    puts("xnuspy: found snprintf");
    puts("xnuspy: found strlen");
    puts("xnuspy: found proc_name");

    return true;
}

/* Confirmed working 15.0 */
bool current_proc_finder_15(xnu_pf_patch_t *patch, void *cacheable_stream){
    /* This matches four places inside _eval, all of which have a branch
     * to current_proc two instructions down */
    xnu_pf_disable_patch(patch);

    uint32_t *opcode_stream = cacheable_stream;

    uint32_t *current_proc = get_branch_dst_ptr(opcode_stream + 2);

    g_current_proc_addr = xnu_ptr_to_va(current_proc);

    puts("xnuspy: found current_proc");

    return true;
}

/* Confirmed working 15.0 */
bool vm_map_unwire_nested_finder_15(xnu_pf_patch_t *patch, 
        void *cacheable_stream){
    /* This matches five places. In three of them, we'll be sitting on a
     * BL to vm_map_unwire_nested if the instruction right behind us is
     * mov x5, #0 */
    uint32_t *opcode_stream = cacheable_stream;

    if(opcode_stream[-1] != 0xd2800005)
        return false;

    xnu_pf_disable_patch(patch);

    uint32_t *vm_map_unwire_nested = get_branch_dst_ptr(opcode_stream);

    g_vm_map_unwire_nested_addr = xnu_ptr_to_va(vm_map_unwire_nested);
    
    puts("xnuspy: found vm_map_unwire_nested");

    return true;
}

/* Confirmed working 15.0 */
bool kernel_map_finder_15(xnu_pf_patch_t *patch, void *cacheable_stream){
    /* Will land in panic_kernel, the first PC relative addressing pair
     * we see from this point on is for kernel_map */
    uint32_t *opcode_stream = cacheable_stream;
    uint32_t limit = 50;

    /* adrp or adr */
    while((*opcode_stream & 0x1f000000) != 0x10000000){
        if(limit-- == 0)
            return false;

        opcode_stream++;
    }

    xnu_pf_disable_patch(patch);

    uint64_t *kernel_mapp = (uint64_t *)get_pc_rel_target(opcode_stream);

    g_kernel_map_addr = xnu_ptr_to_va(kernel_mapp);
    
    puts("xnuspy: found kernel_map");
    
    return true;
}

/* Confirmed working 15.0 */
bool vm_deallocate_finder_15(xnu_pf_patch_t *patch, void *cacheable_stream){
    /* will land in ipc_kmsg_clean_partial. we can only 
     * search for 8 intructions at a time, so we check
     * for the 9th instruction (bl _vm_deallocate) */
    xnu_pf_disable_patch(patch);

    uint32_t *opcode_stream = cacheable_stream;

    if ((opcode_stream[8] & 0xfc000000) != 0x94000000){
        return false;
    }

    uint32_t *vm_deallocate = get_branch_dst_ptr(opcode_stream + 8);

    g_vm_deallocate_addr = xnu_ptr_to_va(vm_deallocate);

    puts("xnuspy: found vm_deallocate");

    return true;
}

/* Confirmed working 15.0 */
bool proc_list_mlock_lck_mtx_lock_unlock_finder_15(xnu_pf_patch_t *patch,
        void *cacheable_stream){
    /* This gets three hits, but they are identical for
     * all kernels. we can only search for 8 instructions
     * at a time, so we check for the 9th instruction
     * (bl _lck_mtx_unlock). We are sitting on an adrp or
     * adr to proc_list_mlock, and then the third instruction
     * from this point is a BL to lck_mtx_lock */
    xnu_pf_disable_patch(patch);
    
    uint32_t *opcode_stream = cacheable_stream;
    
    /* NOT a double pointer */
    uint64_t *proc_list_mlock = (uint64_t *)get_pc_rel_target(opcode_stream);

    uint32_t *lck_mtx_lock = get_branch_dst_ptr(opcode_stream + 3);
    uint32_t *lck_mtx_unlock = get_branch_dst_ptr(opcode_stream + 8);

    g_proc_list_mlock_addr = xnu_ptr_to_va(proc_list_mlock);
    g_lck_mtx_lock_addr = xnu_ptr_to_va(lck_mtx_lock);
    g_lck_mtx_unlock_addr = xnu_ptr_to_va(lck_mtx_unlock);

    puts("xnuspy: found proc_list_mlock");
    puts("xnuspy: found lck_mtx_lock");
    puts("xnuspy: found lck_mtx_unlock");

    return true;
}

/* Confirmed working 15.0 */
bool lck_grp_free_finder_15(xnu_pf_patch_t *patch, void *cacheable_stream){
    /* We landed in lifs_kext_stop. There's three sequences of
     * ldr x0, ... BL _lck_grp_free in front of us */
    xnu_pf_disable_patch(patch);

    uint32_t *opcode_stream = cacheable_stream;

    uint32_t *lck_grp_free = get_branch_dst_ptr(opcode_stream + 1);
    
    g_lck_grp_free_addr = xnu_ptr_to_va(lck_grp_free);

    puts("xnuspy: found lck_grp_free");

    return true;
}

/* Confirmed working 15.0 */
bool proc_ref_rele_finder_15(xnu_pf_patch_t *patch, void *cacheable_stream){
    /* We landed inside proc_rebootscan. A call to proc_ref is three
     * instructions down and a call to proc_rele is 14 instructions down */
    xnu_pf_disable_patch(patch);

    uint32_t *opcode_stream = cacheable_stream;

    uint32_t *proc_ref = get_branch_dst_ptr(opcode_stream + 3);
    uint32_t *proc_rele = get_branch_dst_ptr(opcode_stream + 14);

    g_proc_ref_addr = xnu_ptr_to_va(proc_ref);
    g_proc_rele_addr = xnu_ptr_to_va(proc_rele);

    puts("xnuspy: found proc_ref");
    puts("xnuspy: found proc_rele");

    return true;
}

/* Confirmed working 15.0 */
bool lck_rw_alloc_init_finder_15(xnu_pf_patch_t *patch,
        void *cacheable_stream){
    /* We landed inside lifs_req_hashtbl_init. The branch to
     * lck_rw_alloc_init is three instructions down if we see a
     * lsl w8, w0, #1 less than 20 instructions before where we are */
    uint32_t *opcode_stream = cacheable_stream;
    uint32_t *saved_stream = opcode_stream;
    uint32_t limit = 20;

    while(*opcode_stream != 0x531f7808){
        if(limit-- == 0)
            return false;

        opcode_stream--;
    }

    xnu_pf_disable_patch(patch);

    uint32_t *lck_rw_alloc_init = get_branch_dst_ptr(saved_stream + 3);

    g_lck_rw_alloc_init_addr = xnu_ptr_to_va(lck_rw_alloc_init);

    puts("xnuspy: found lck_rw_alloc_init");

    return true;
}

```

`module/pf/Makefile`:

```
TARGET_DIRS = 13 14 15

all : $(TARGET_DIRS)

target_dirs : $(TARGET_DIRS)

.PHONY : target_dirs $(TARGET_DIRS)

$(TARGET_DIRS) :
	$(MAKE) -C $@

```

`module/pf/README.md`:

```md
Directory structure:

13/
- patchfinder code for iOS 13.x

14/
- patchfinder code for iOS 14.x

15/
- patchfinder code for iOS 15.x

```

`module/preboot_hook.c`:

```c
#include <mach-o/nlist.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdint.h>
#include <sys/sysctl.h>

#include <pongo.h>

#include <asm/asm.h>
#include <asm/asm_support.h>
#include <common/common.h>
#include <pf/offsets.h>
#include <pf/pf_common.h>
#include <xnuspy/xnuspy_structs.h>

#include <xnuspy/el1/hook_system_check_sysctlbyname_hook_instrs.h>
#include <xnuspy/el1/xnuspy_ctl_tramp_instrs.h>

static uint64_t g_xnuspy_ctl_addr = 0;
/* address of start of __TEXT_EXEC in xnuspy_ctl image */
static uint64_t g_xnuspy_ctl_img_codestart = 0;
/* how many bytes to we need to mark as executable inside xnuspy_ctl_tramp? */
static uint64_t g_xnuspy_ctl_img_codesz = 0;
static uint64_t g_xnuspy_tramp_mem_addr = 0;
static uint64_t g_xnuspy_tramp_mem_end = 0;
/* Assume we're in range until we do the check */
static uint64_t g_hookme_in_range = 1;

uint64_t *xnuspy_cache_base = NULL;

#define WRITE_INSTR_TO_SCRATCH_SPACE(opcode) \
    do { \
        if(num_free_instrs < 2){ \
            printf("xnuspy: ran out\n" \
                    "  of executable scratch\n" \
                    "  space in function %s\n", \
                    __func__); \
            xnuspy_fatal_error(); \
        } \
        *scratch_space = (opcode); \
        scratch_space++; \
        num_free_instrs--; \
    } while (0) \

#define XNUSPY_CACHE_WRITE(thing) \
    do { \
        *xnuspy_cache_cursor++ = (thing); \
    } while (0) \

static struct xnuspy_ctl_kernel_symbol {
    const char *symbol;
    uint64_t *valp;
} g_xnuspy_ctl_needed_symbols[] = {
    { "_allprocp", &g_allproc_addr },
    { "_bcopy_phys", &g_bcopy_phys_addr },
    { "_copyin", &g_copyin_addr },
    { "_copyinstr", &g_copyinstr_addr },
    { "_copyout", &g_copyout_addr },
    { "_current_proc", &g_current_proc_addr },
    { "_hookme_in_range", &g_hookme_in_range },
    { "_io_lock", &g_io_lock_addr },
    { "_ipc_object_lock", &g_ipc_object_lock_addr },
    { "_IOLog", &g_IOLog_addr },
    { "_iOS_version", &g_kern_version_major },
    { "_IOSleep", &g_IOSleep_addr },
    { "_ipc_port_release_send", &g_ipc_port_release_send_addr },
    { "_ipc_port_release_send_and_unlock", &g_ipc_port_release_send_and_unlock_addr },
    { "_kalloc_canblock", &g_kalloc_canblock_addr },
    { "_kalloc_external", &g_kalloc_external_addr },
    { "_kern_version_minor", &g_kern_version_minor },
    { "_kernel_mapp", &g_kernel_map_addr },
    { "_kernel_slide", &kernel_slide },
    { "_kernel_thread_start", &g_kernel_thread_start_addr },
    { "_kfree_addr", &g_kfree_addr_addr },
    { "_kfree_ext", &g_kfree_ext_addr },
    { "_kprintf", &g_kprintf_addr },
    { "_lck_grp_alloc_init", &g_lck_grp_alloc_init_addr },
    { "_lck_grp_free", &g_lck_grp_free_addr },
    { "_lck_mtx_lock", &g_lck_mtx_lock_addr },
    { "_lck_mtx_unlock", &g_lck_mtx_unlock_addr },
    { "_lck_rw_alloc_init", &g_lck_rw_alloc_init_addr },
    { "_lck_rw_done", &g_lck_rw_done_addr },
    { "_lck_rw_free", &g_lck_rw_free_addr },
    { "_lck_rw_lock_exclusive", &g_lck_rw_lock_exclusive_addr },
    { "_lck_rw_lock_shared", &g_lck_rw_lock_shared_addr },
    { "_lck_rw_lock_shared_to_exclusive", &g_lck_rw_lock_shared_to_exclusive_addr },
    { "__mach_make_memory_entry_64", &g_mach_make_memory_entry_64_addr },
    { "_mach_to_bsd_errno", &g_mach_to_bsd_errno_addr },
    { "_mach_vm_map_external", &g_mach_vm_map_external_addr },
    { "__memmove", &g_memmove_addr },
    { "__memset", &g_memset_addr },
    { "_offsetof_struct_thread_map", &g_offsetof_struct_thread_map },
    { "_offsetof_struct_vm_map_refcnt", &g_offsetof_struct_vm_map_refcnt },
    { "__panic", &g_panic_addr },
    { "_phystokv", &g_phystokv_addr },
    { "_proc_list_mlockp", &g_proc_list_mlock_addr },
    { "_proc_name", &g_proc_name_addr },
    { "_proc_pid", &g_proc_pid_addr },
    { "_proc_ref", &g_proc_ref_addr },
    { "_proc_ref_locked", &g_proc_ref_locked_addr },
    { "_proc_rele", &g_proc_rele_addr },
    { "_proc_rele_locked", &g_proc_rele_locked_addr },
    { "_proc_uniqueid", &g_proc_uniqueid_addr },
    { "__snprintf", &g_snprintf_addr },
    { "__strlen", &g_strlen_addr },
    { "__strncmp", &g_strncmp_addr },
    { "_thread_deallocate", &g_thread_deallocate_addr },
    { "__thread_terminate", &g_thread_terminate_addr },
    { "__vm_deallocate", &g_vm_deallocate_addr },
    { "_vm_allocate_external", &g_vm_allocate_external_addr },
    { "_vm_map_deallocate", &g_vm_map_deallocate_addr },
    { "_vm_map_unwire", &g_vm_map_unwire_addr },
    { "_vm_map_unwire_nested", &g_vm_map_unwire_nested_addr },
    { "_vm_map_wire_external", &g_vm_map_wire_external_addr },
    { "_xnuspy_tramp_mem", &g_xnuspy_tramp_mem_addr },
    { "_xnuspy_tramp_mem_end", &g_xnuspy_tramp_mem_end },
};

static void anything_missing(void){
    static bool printed_err_hdr = false;

#define chk(expression, msg) \
    do { \
        if(expression){ \
            if(!printed_err_hdr){ \
                printf("xnuspy: error(s) before\n" \
                        "  we continue:\n"); \
                printed_err_hdr = true; \
            } \
            printf("  "msg); \
        } \
    } while (0) \

    chk(!g_sysent_addr, "sysent not found\n");
    chk(!g_sysctl__kern_children_addr, "sysctl__kern_children not found\n");
    chk(!g_sysctl_register_oid_addr, "sysctl_register_oid not found\n");
    chk(!g_sysctl_handle_long_addr, "sysctl_handle_long not found\n");
    chk(!g_name2oid_addr, "name2oid not found\n");
    chk(!g_sysctl_geometry_lock_addr, "sysctl_geometry_lock not found\n");
    chk(!g_lck_rw_done_addr, "lck_rw_done not found\n");
    chk(!g_h_s_c_sbn_branch_addr, "did not find hscsbn branch addr\n");
    chk(!g_h_s_c_sbn_epilogue_addr, "hscsbn epilogue not found\n");
    chk(!g_lck_grp_alloc_init_addr, "lck_grp_alloc_init not found\n");
    chk(!g_lck_rw_alloc_init_addr, "lck_rw_alloc_init not found\n");
    chk(!g_exec_scratch_space_addr, "unused executable code not found\n");
    chk(!g_bcopy_phys_addr, "bcopy_phys not found\n");
    chk(!g_phystokv_addr, "phystokv not found\n");
    chk(!g_copyin_addr, "copyin not found\n");
    chk(!g_copyout_addr, "copyout not found\n");
    chk(!g_IOSleep_addr, "IOSleep not found\n");
    chk(!g_kprintf_addr, "kprintf not found\n");
    chk(!g_vm_deallocate_addr, "vm_deallocate not found\n");
    chk(!g_kernel_map_addr, "kernel_map not found\n");
    chk(!g_kernel_thread_start_addr, "kernel_thread_start not found\n");
    chk(!g_thread_deallocate_addr, "thread_deallocate not found\n");
    chk(!g_mach_make_memory_entry_64_addr, "mach_make_memory_entry_64 not found\n");
    chk(!g_offsetof_struct_thread_map, "offsetof(struct thread, map) not found\n");
    chk(!g_current_proc_addr, "current_proc not found\n");
    chk(!g_proc_list_mlock_addr, "proc_list_mlock not found\n");
    chk(!g_lck_mtx_lock_addr, "lck_mtx_lock not found\n");
    chk(!g_lck_mtx_unlock_addr, "lck_mtx_unlock not found\n");
    chk(!g_proc_uniqueid_addr, "proc_uniqueid not found\n");
    chk(!g_proc_pid_addr, "proc_pid not found\n");
    chk(!g_allproc_addr, "address of allproc not found\n");
    chk(!g_lck_rw_lock_shared_addr, "lck_rw_lock_shared not found\n");
    chk(!g_lck_rw_lock_shared_to_exclusive_addr,
            "lck_rw_lock_shared_to_exclusive not found\n");
    chk(!g_lck_rw_lock_exclusive_addr, "lck_rw_lock_exclusive not found\n");
    chk(!g_vm_map_wire_external_addr, "vm_map_wire_external not found\n");
    chk(!g_mach_vm_map_external_addr, "mach_vm_map_external not found\n");
    chk(!g_lck_rw_free_addr, "lck_rw_free not found\n");
    chk(!g_lck_grp_free_addr, "lck_grp_free not found\n");
    chk(!g_patched_doprnt_hide_pointers, "doprnt_hide_pointers wasn't patched\n");
    chk(!g_copyinstr_addr, "copyinstr not found\n");
    chk(!g_thread_terminate_addr, "thread_terminate not found\n");
    chk(!g_IOLog_addr, "IOLog not found\n");
    chk(!g_proc_name_addr, "proc_name not found\n");
    chk(!g_snprintf_addr, "snprintf not found\n");
    chk(!g_strlen_addr, "strlen not found\n");
    chk(!g_strncmp_addr, "strncmp not found\n");
    chk(!g_memset_addr, "memset not found\n");
    chk(!g_memmove_addr, "memmove not found\n");
    chk(!g_panic_addr, "panic not found\n");
    chk(!g_mach_to_bsd_errno_addr, "mach_to_bsd_errno not found\n");
    chk(!g_vm_allocate_external_addr, "vm_allocate_external not found\n");
    chk(!g_vm_map_deallocate_addr, "vm_map_deallocate not found\n");
    chk(!g_offsetof_struct_vm_map_refcnt, "offsetof(vm_map_t, refcnt) not found\n");

    /* Specific to A10+. On A9(x), we don't need to keep TCR_EL1.HPD0 and
     * TCR_EL1.HPD1 set */
    if(socnum >= 0x8010){
        chk(!g_patched_pinst_set_tcr, "pinst_set_tcr wasn't patched\n");
        chk(!g_patched_all_msr_tcr_el1_x18, "did not patch all msr tcr_el1, x18\n");
    }

    /* Now check for version-specific patchfinds */

    if(is_14_x_and_below__pongo()){
        /* <= iOS 14.x */
        chk(!g_proc_ref_locked_addr, "proc_ref_locked not found\n");
        chk(!g_proc_rele_locked_addr, "proc_rele_locked not found\n");
        chk(!g_vm_map_unwire_addr, "vm_map_unwire not found\n");
    }

    if(is_13_x__pongo()){
        /* iOS 13.x */
        chk(!g_kalloc_canblock_addr, "kalloc_canblock not found\n");
        chk(!g_kfree_addr_addr, "kfree_addr not found\n");
    }
    else{
        /* >= iOS 14.x */
        chk(!g_kalloc_external_addr, "kalloc_external not found\n");
        chk(!g_kfree_ext_addr, "kfree_ext not found\n");

        if(is_14_5_and_above__pongo()){
            /* >= iOS 14.5 */

            if(is_15_x__pongo())
                chk(!g_ipc_object_lock_addr, "ipc_object_lock not found\n");
            else
                chk(!g_io_lock_addr, "io_lock not found\n");

            chk(!g_ipc_port_release_send_and_unlock_addr,
                    "ipc_port_release_send_and_unlock not found\n");
        }
        else{
            /* < iOS 14.5 */
            chk(!g_ipc_port_release_send_addr,
                    "ipc_port_release_send not found\n");
        }

        if(is_15_x__pongo()){
            /* iOS 15.x */

            chk(!g_proc_ref_addr, "proc_ref not found\n");
            chk(!g_proc_rele_addr, "proc_rele not found\n");
            chk(!g_vm_map_unwire_nested_addr, "vm_map_unwire_nested not found\n");
        }
    }

    /* If we printed the error header, something is missing */
    if(printed_err_hdr)
        xnuspy_fatal_error();
}

static void initialize_xnuspy_cache(void){
    uint64_t *xnuspy_cache_cursor = xnuspy_cache_base;

    XNUSPY_CACHE_WRITE(g_sysctl__kern_children_addr);
    XNUSPY_CACHE_WRITE(g_sysctl_register_oid_addr);
    XNUSPY_CACHE_WRITE(g_sysctl_handle_long_addr);
    XNUSPY_CACHE_WRITE(g_name2oid_addr);
    XNUSPY_CACHE_WRITE(g_sysctl_geometry_lock_addr);
    XNUSPY_CACHE_WRITE(g_lck_rw_lock_shared_addr);
    XNUSPY_CACHE_WRITE(g_lck_rw_done_addr);

    /* DID_REGISTER_SYSCTL, used inside hook_system_check_sysctlbyname_hook,
     * initialize to false */
    XNUSPY_CACHE_WRITE(0);

    XNUSPY_CACHE_WRITE(g_h_s_c_sbn_epilogue_addr);
    XNUSPY_CACHE_WRITE(g_xnuspy_sysctl_mib_ptr);
    XNUSPY_CACHE_WRITE(g_xnuspy_sysctl_mib_count_ptr);
    XNUSPY_CACHE_WRITE(g_xnuspy_ctl_callnum);
    XNUSPY_CACHE_WRITE(g_kern_version_major);
    XNUSPY_CACHE_WRITE(g_xnuspy_ctl_addr);
    XNUSPY_CACHE_WRITE(g_xnuspy_ctl_img_codestart);
    XNUSPY_CACHE_WRITE(g_xnuspy_ctl_img_codesz);

    /* XNUSPY_CTL_IS_RX, used inside xnuspy_ctl_tramp.s, initialize to false */
    XNUSPY_CACHE_WRITE(0);

    XNUSPY_CACHE_WRITE(g_phystokv_addr);
    XNUSPY_CACHE_WRITE(g_bcopy_phys_addr);

    if(g_kern_version_major == iOS_13_x){
        XNUSPY_CACHE_WRITE(g_kalloc_canblock_addr);
        XNUSPY_CACHE_WRITE(g_kfree_addr_addr);
    }
    else{
        XNUSPY_CACHE_WRITE(g_kalloc_external_addr);
        XNUSPY_CACHE_WRITE(g_kfree_ext_addr);
    }

    XNUSPY_CACHE_WRITE(g_kern_version_minor);

    puts("xnuspy: initialized xnuspy cache");
}

static uint32_t *install_h_s_c_sbn_hook(uint32_t *scratch_space,
        int64_t *num_free_instrsp){
    int64_t num_free_instrs = *num_free_instrsp;

    uint64_t h_s_c_sbn_hook_len =
        g_hook_system_check_sysctlbyname_hook_len / sizeof(uint32_t);
    uint32_t *h_s_c_sbn_hook_cursor =
        (uint32_t *)g_hook_system_check_sysctlbyname_hook;
    uint32_t *h_s_c_sbn_hook_end = h_s_c_sbn_hook_cursor + h_s_c_sbn_hook_len;

    uint64_t h_s_c_sbn_hook_addr = xnu_ptr_to_va(scratch_space);
    uint32_t *h_s_c_sbn_branch_from = xnu_va_to_ptr(g_h_s_c_sbn_branch_addr);
    uint32_t *h_s_c_sbn_branch_from_orig = h_s_c_sbn_branch_from;

    while(h_s_c_sbn_hook_cursor < h_s_c_sbn_hook_end){
        if(*(uint64_t *)h_s_c_sbn_hook_cursor == QWORD_PLACEHOLDER)
            *(uint64_t *)h_s_c_sbn_hook_cursor = xnu_ptr_to_va(xnuspy_cache_base);
        else if(*h_s_c_sbn_hook_cursor == OPCODE_PLACEHOLDER)
            *h_s_c_sbn_hook_cursor = *h_s_c_sbn_branch_from++;

        WRITE_INSTR_TO_SCRATCH_SPACE(*h_s_c_sbn_hook_cursor++);
    }

    /* Use x8 */
    write_blr(8, h_s_c_sbn_branch_from_orig, h_s_c_sbn_hook_addr);

    *num_free_instrsp = num_free_instrs;

    return scratch_space;
}

static uint32_t *write_xnuspy_ctl_tramp_instrs(uint32_t *scratch_space,
        int64_t *num_free_instrsp){
    int64_t num_free_instrs = *num_free_instrsp;

    uint64_t xnuspy_ctl_tramp_len = g_xnuspy_ctl_tramp_len / sizeof(uint32_t);
    uint32_t *xnuspy_ctl_tramp_cursor = (uint32_t *)g_xnuspy_ctl_tramp;
    uint32_t *xnuspy_ctl_tramp_end = xnuspy_ctl_tramp_cursor + xnuspy_ctl_tramp_len;

    while(xnuspy_ctl_tramp_cursor < xnuspy_ctl_tramp_end){
        if(*(uint64_t *)xnuspy_ctl_tramp_cursor == QWORD_PLACEHOLDER)
            *(uint64_t *)xnuspy_ctl_tramp_cursor = xnu_ptr_to_va(xnuspy_cache_base);

        WRITE_INSTR_TO_SCRATCH_SPACE(*xnuspy_ctl_tramp_cursor++);
    }

    *num_free_instrsp = num_free_instrs;

    return scratch_space;
}

/* This function will replace an _enosys sysent with the address of
 * xnuspy_ctl_tramp. For the reason we need a trampoline, see
 * module/el1/xnuspy_ctl_tramp.s */
static uint32_t *install_xnuspy_ctl_tramp(uint32_t *scratch_space,
        int64_t *num_free_instrsp){
    struct sysent *sysent_stream = (struct sysent *)g_sysent_addr;

    bool tagged_ptr = false;
    uint16_t old_tag = 0;

    uint32_t limit = 1000;

    for(uint32_t i=0; i<limit; i++){
        uint64_t sy_call = sysent_stream->sy_call;

        /* tagged pointer */
        if((sy_call & 0xffff000000000000) != 0xffff000000000000){
            old_tag = (sy_call >> 48);

            sy_call |= 0xffff000000000000;
            sy_call += kernel_slide;

            tagged_ptr = true;
        }

        /* mov w0, ENOSYS; ret */
        if(*(uint64_t *)xnu_va_to_ptr(sy_call) == 0xd65f03c0528009c0){
            g_xnuspy_ctl_callnum = i;

            uint64_t new_sy_call;

            /* sy_call */
            if(!tagged_ptr)
                new_sy_call = xnu_ptr_to_va(scratch_space);
            else{
                uint64_t untagged = (xnu_ptr_to_va(scratch_space) &
                        0xffffffffffff) - kernel_slide;

                /* re-tag */
                new_sy_call = untagged | ((uint64_t)old_tag << 48);
            }

            sysent_stream->sy_call = new_sy_call;

            /* no 32 bit processes on iOS 11+, so no argument munger */
            sysent_stream->sy_arg_munge32 = NULL;

            /* this syscall will return an integer */
            sysent_stream->sy_return_type = 1; /* _SYSCALL_RET_INT_T */

            /* this syscall has four arguments */
            sysent_stream->sy_narg = 4;

            /* four 64 bit arguments, so arguments total 32 bytes */
            sysent_stream->sy_arg_bytes = sizeof(uint64_t) * sysent_stream->sy_narg;

            return write_xnuspy_ctl_tramp_instrs(scratch_space,
                    num_free_instrsp);
        }

        sysent_stream++;
    }

    puts("xnuspy: didn't");
    puts("  find a sysent entry");
    puts("  with enosys?");

    xnuspy_fatal_error();
}

static void initialize_xnuspy_callnum_sysctl_offsets(void){
    uint32_t *sysctl_mibp = (uint32_t *)((uint8_t *)xnuspy_cache_base + (PAGE_SIZE / 2));
    uint32_t *sysctl_mib_countp = (uint32_t *)(sysctl_mibp + CTL_MAXNAME);

    g_xnuspy_sysctl_mib_ptr = xnu_ptr_to_va(sysctl_mibp);
    g_xnuspy_sysctl_mib_count_ptr = xnu_ptr_to_va(sysctl_mib_countp);
}

static void initialize_xnuspy_ctl_image_koff(char *ksym, uint64_t *va){
    const size_t num_needed_symbols = sizeof(g_xnuspy_ctl_needed_symbols) /
        sizeof(*g_xnuspy_ctl_needed_symbols);

    for(size_t i=0; i<num_needed_symbols; i++){
        if(strcmp(ksym, g_xnuspy_ctl_needed_symbols[i].symbol) == 0){
            *va = *g_xnuspy_ctl_needed_symbols[i].valp;
            return;
        }
    }
}

/* Fill in all our kernel offsets in __koff, initialize g_xnuspy_ctl_addr
 * and g_xnuspy_ctl_img_codesz */
static void process_xnuspy_ctl_image(void *xnuspy_ctl_image){
    struct mach_header_64 *mh = xnuspy_ctl_image;
    struct load_command *lc = (struct load_command *)(mh + 1);
    struct symtab_command *st = NULL;
    
    for(int i=0; i<mh->ncmds; i++){
        if(lc->cmd == LC_SYMTAB)
            st = (struct symtab_command *)lc;
        else if(lc->cmd == LC_SEGMENT_64){
            struct segment_command_64 *sc = (struct segment_command_64 *)lc;

            if(strcmp(sc->segname, "__TEXT_EXEC") == 0){
                g_xnuspy_ctl_img_codestart = xnu_ptr_to_va(mh) + sc->vmaddr;
                g_xnuspy_ctl_img_codesz = sc->vmsize;
            }
        }

        if(st && g_xnuspy_ctl_img_codesz)
            break;

        lc = (struct load_command *)((uint8_t *)lc + lc->cmdsize);
    }

    if(!st || !g_xnuspy_ctl_img_codesz){
        printf("xnuspy: could not find\n");

        if(!st)
            printf("   symtab\n");

        if(!g_xnuspy_ctl_img_codesz)
            printf("   g_xnuspy_ctl_img_codesz\n");

        printf("  This may be happening\n"
               "  due to a short read,\n"
               "  try adding some code to\n"
               "  module/el1/xnuspy_ctl/xnuspy_ctl.c\n"
               "  to increase image size.\n");

        xnuspy_fatal_error();
    }

    struct nlist_64 *symtab = (struct nlist_64 *)((uint8_t *)xnuspy_ctl_image +
        st->symoff);

    char *strtab = (char *)xnuspy_ctl_image + st->stroff;

    for(int i=0; i<st->nsyms; i++){
        char *sym = strtab + symtab[i].n_un.n_strx;
        uint64_t *va = (uint64_t *)((uint8_t *)xnuspy_ctl_image +
                symtab[i].n_value);

        if(strcmp(sym, "_xnuspy_ctl") == 0)
            g_xnuspy_ctl_addr = xnu_ptr_to_va(va);
        else if(strcmp(sym, "__hookme") == 0){
            uint64_t _hookme_kva = xnu_ptr_to_va(va);
            uint64_t ceil = g_xnuspy_tramp_mem_end;
            int64_t dist = ceil - _hookme_kva;

            if(dist < 0)
                dist = -dist;

            if(dist > 0x8000000){
                g_hookme_in_range = 0;

                printf("xnuspy: hookme is unable\n"
                       " to be hooked, XNUSPY_CALL_HOOKME\n"
                       " is disabled.\n");
            }

            /* In case we've already seen _hookme_in_range, initialize this
             * symbol again */
            initialize_xnuspy_ctl_image_koff("_hookme_in_range",
                    &g_hookme_in_range);
        }
        else{
            initialize_xnuspy_ctl_image_koff(sym, va);
        }
    }
}

#ifndef XNUSPY_TRAMP_PAGES
#define XNUSPY_TRAMP_PAGES 1
#endif

void (*next_preboot_hook)(void);

void xnuspy_preboot_hook(void){
    anything_missing();
    
    uint64_t xnuspy_tramp_mem_size = PAGE_SIZE * XNUSPY_TRAMP_PAGES;
    void *xnuspy_tramp_mem = alloc_static(xnuspy_tramp_mem_size);

    if(!xnuspy_tramp_mem){
        puts("xnuspy: alloc_static");
        puts("   returned NULL while");
        puts("   allocating xnuspy");
        puts("   trampoline mem");

        xnuspy_fatal_error();
    }

    memset(xnuspy_tramp_mem, 0, xnuspy_tramp_mem_size);

    /* For every function which gets hooked, a single unconditional
     * immediate branch is written targeting some point on the
     * xnuspy_tramp_page. So that page must be within 128MB from the first
     * code in the kernelcache. If it's is not within that range, we cannot
     * assume every branch will fall within 128MB, and will fall back to
     * the unused r-x page we found earlier. We need to figure out the
     * address of the first page of code. */

    /* I hope this is right */
    struct segment_command_64 *__PRELINK_TEXT = macho_get_segment(mh_execute_header,
            "__PRELINK_TEXT");
    struct segment_command_64 *__TEXT_EXEC = macho_get_segment(mh_execute_header,
            "__TEXT_EXEC");

    struct section_64 *sec64 = (struct section_64 *)(__TEXT_EXEC + 1);

    /* codestart already slid on all kernels when reading from __TEXT:HEADER */
    uint64_t codestart = UINT64_MAX;

    for(uint32_t i=0; i<__TEXT_EXEC->nsects; i++){
        if(sec64->addr < codestart)
            codestart = sec64->addr;

        sec64++;
    }

    /* Old style kc */
    if(__PRELINK_TEXT && __PRELINK_TEXT->vmsize > 0){
        struct segment_command_64 *__PRELINK_INFO = macho_get_segment(mh_execute_header,
                "__PRELINK_INFO");

        if(!__PRELINK_INFO){
            printf("xnuspy: no prelink info\n"
                   "  segment???\n");

            xnuspy_fatal_error();
        }

        struct section_64 *__info = macho_get_section(__PRELINK_INFO, "__info");

        if(!__info){
            printf("xnuspy: no prelink info\n"
                   "  dict?\n");

            xnuspy_fatal_error();
        }

        /* __info->addr already slid */
        char *infodict = xnu_va_to_ptr(__info->addr);
        char *cursor;

        while((cursor = strstr(infodict, "_PrelinkExecutableLoadAddr"))){
            char *loadaddr_s = strstr(cursor, "0xfffffff");

            if(!loadaddr_s)
                goto next;

            uint64_t loadaddr = strtoul(loadaddr_s, NULL, 0) + kernel_slide;
            struct mach_header_64 *mh64 = xnu_va_to_ptr(loadaddr);
            __TEXT_EXEC = macho_get_segment(mh64, "__TEXT_EXEC");

            if(__TEXT_EXEC)
                break;

next:
            infodict = cursor + 1;
        }

        struct section_64 *__text = macho_get_section(__TEXT_EXEC, "__text");

        if(!__text){
            printf("xnuspy: no __text section\n"
                   "  in __TEXT_EXEC??\n");

            xnuspy_fatal_error();
        }

        /* __text->addr not slid */
        if(__text->addr + kernel_slide < codestart)
            codestart = __text->addr + kernel_slide;
    }

    uint64_t ceil = xnu_ptr_to_va(xnuspy_tramp_mem) + xnuspy_tramp_mem_size;
    uint64_t dist = ceil - codestart;

    bool fallback = false;

    if(dist > 0x8000000){
        printf("xnuspy: distance from first\n"
               "  code to end of tramp mem is larger\n"
               "  than 128 MB. Falling back to\n"
               "  the unused r-x page already in\n"
               "  the kernelcache. As a result,\n"
               "  there are less hooks you can\n"
               "  install simultaneously.\n");

        fallback = true;
    }
    else{
        g_xnuspy_tramp_mem_addr = xnu_ptr_to_va(xnuspy_tramp_mem);
        g_xnuspy_tramp_mem_end = g_xnuspy_tramp_mem_addr + xnuspy_tramp_mem_size;
    }

    xnuspy_cache_base = alloc_static(PAGE_SIZE);

    if(!xnuspy_cache_base){
        puts("xnuspy: alloc_static");
        puts("   returned NULL while");
        puts("   allocating for xnuspy");
        puts("   cache");

        xnuspy_fatal_error();
    }

    void *xnuspy_ctl_image = alloc_static(loader_xfer_recv_count);

    if(!xnuspy_ctl_image){
        puts("xnuspy: alloc_static");
        puts("   returned NULL while");
        puts("   allocating pages for");
        puts("   xnuspy_ctl image");

        xnuspy_fatal_error();
    }

    memcpy(xnuspy_ctl_image, loader_xfer_recv_data, loader_xfer_recv_count);

    printf("xnuspy_ctl image base is at %#llx\n", xnu_ptr_to_va(xnuspy_ctl_image));

    int64_t num_free_instrs = g_exec_scratch_space_size / sizeof(uint32_t);
    uint32_t *scratch_space = xnu_va_to_ptr(g_exec_scratch_space_addr);

    scratch_space = install_h_s_c_sbn_hook(scratch_space, &num_free_instrs);
    scratch_space = install_xnuspy_ctl_tramp(scratch_space, &num_free_instrs);

    if(fallback){
        /* Use the rest of the scratch space for the xnuspy_tramp structs.
         * This page will be marked as rwx inside xnuspy_init */
        uint8_t *rxpage_unaligned = (uint8_t *)scratch_space;
        uint8_t *rxpage = (uint8_t *)(((uintptr_t)rxpage_unaligned + 8) & ~7);
        uint8_t *rxpage_end = (uint8_t *)(((uintptr_t)rxpage + PAGE_SIZE) & ~(PAGE_SIZE - 1));

        /* We do this so checkra1n kpf doesn't use this space for shellcode */
        memset(rxpage_unaligned, '$', rxpage_end - rxpage_unaligned);

        g_xnuspy_tramp_mem_addr = xnu_ptr_to_va(rxpage);
        g_xnuspy_tramp_mem_end = xnu_ptr_to_va(rxpage_end);
    }

    process_xnuspy_ctl_image(xnuspy_ctl_image);

    initialize_xnuspy_callnum_sysctl_offsets();
    initialize_xnuspy_cache();

    if(next_preboot_hook)
        next_preboot_hook();
}

```

`module/xnuspy.c`:

```c
#include <stdint.h>
#include <stdlib.h>
#include <stdbool.h>

#include <pongo.h>

#include <common/common.h>
#include <common/preboot_hook.h>
#include <pf/offsets.h>
#include <pf/pfs.h>

#include <xnuspy/el3/kpp.h>

uint64_t g_kern_version_major = 0;
uint64_t g_kern_version_minor = 0;

static uint32_t g_kern_version_revision = 0;

static bool getkernelv_callback(xnu_pf_patch_t *patch,
        void *cacheable_stream){
    xnu_pf_disable_patch(patch);

    char *version = cacheable_stream;

    /* on all kernels, major, minor, and version are no larger than 2 chars */
    char major_s[3] = {0};
    char minor_s[3] = {0};
    char revision_s[3] = {0};

    /* skip ahead until we get a digit */
    while(!isdigit(*version))
        version++;
    
    for(int i=0; *version != '.'; i++, version++)
        major_s[i] = *version;

    version++;

    for(int i=0; *version != '.'; i++, version++)
        minor_s[i] = *version;

    version++;

    for(int i=0; *version != ':'; i++, version++)
        revision_s[i] = *version;

    /* currently, I only use major and minor, but I get the rest in
     * case I need them in the future */
    g_kern_version_major = atoi(major_s);
    g_kern_version_minor = atoi(minor_s);
    g_kern_version_revision = atoi(revision_s);

    /* iOS 14 or newer */
    bool pwn_seprom = (g_kern_version_major >= iOS_14_x) &&
        (socnum == 0x8010 || socnum == 0x8011 || socnum == 0x8015);

    if(g_kern_version_major == iOS_13_x)
        printf("xnuspy: iOS 13.x detected\n");
    else if(g_kern_version_major == iOS_14_x)
        printf("xnuspy: iOS 14.x detected\n");
    else if (g_kern_version_major == iOS_15_x)
        printf("xnuspy: iOS 15.x detected\n");
    else{
        printf("xnuspy: error: unknown\n"
                "  major %lld\n",
                g_kern_version_major);

        xnuspy_fatal_error();
    }

    /* No need to exploit SEPROM on 14.x A9(x) and below, which conveniently
     * is the only KPP chip that xnuspy supports */
    if(pwn_seprom)
        queue_rx_string("sep auto\n");
    else if(socnum == 0x8000 || socnum == 0x8001 || socnum == 0x8003)
        patch_kpp();

    return true;
}

static void xnuspy_getkernelv(const char *cmd, char *args){
    xnu_pf_patchset_t *patchset = xnu_pf_patchset_create(XNU_PF_ACCESS_8BIT);

    xnu_pf_range_t *__TEXT___const = xnu_pf_section(mh_execute_header, "__TEXT",
            "__const");

    if(!__TEXT___const){
        puts("xnuspy: xnu_pf_section");
        puts("   returned NULL for");
        puts("   __TEXT:__const?");

        xnuspy_fatal_error();
    }

    const char *vers = "Darwin Kernel Version ";

    /* hardcoded so clang does not generate ___chkstk_darwin calls */
    uint64_t ver[21];
    uint64_t masks[21];

    for(int i=0; i<21; i++){
        ver[i] = vers[i];
        masks[i] = 0xff;
    }

    uint64_t count = sizeof(ver) / sizeof(*ver);

    xnu_pf_maskmatch(patchset, "kernel version finder", ver, masks, count,
            false, getkernelv_callback);
    xnu_pf_emit(patchset);
    xnu_pf_apply(__TEXT___const, patchset);
    xnu_pf_patchset_destroy(patchset);
}

#define MAXKEXTRANGE MAXPF

struct kextrange {
    xnu_pf_range_t *range;
    char *kext;
    char *seg;
    char *sect;
};

/* purpose of this function is to add patchfinder ranges for kexts in such
 * a way that there are no duplicates in `*ranges` */
static void add_kext_range(struct kextrange **ranges, const char *kext,
        const char *seg, const char *sect, size_t *nkextranges_out){
    size_t nkextranges = *nkextranges_out;

    if(nkextranges == MAXKEXTRANGE)
        return;

    /* first, check if this kext is already present */
    for(size_t i=0; i<nkextranges; i++){
        struct kextrange *kr = ranges[i];

        /* kext will never be NULL, otherwise, this function would have
         * no point */
        if(strcmp(kr->kext, kext) == 0){
            /* same segment? It will be the same range even if the section differs */
            if(seg && strcmp(kr->seg, seg) == 0)
                return;

            if(sect && strcmp(kr->sect, sect) == 0)
                return;
        }
    }

    /* new kext, make its range */
    struct mach_header_64 *mh = xnu_pf_get_kext_header(mh_execute_header, kext);

    if(!mh){
        printf( "xnuspy: could not\n"
                "   get Mach header for\n"
                "   %s\n", kext);

        xnuspy_fatal_error();
    }

    struct kextrange *kr = malloc(sizeof(struct kextrange));
    memset(kr, 0, sizeof(*kr));

    if(sect)
        kr->range = xnu_pf_section(mh, (void *)seg, (char *)sect);
    else
        kr->range = xnu_pf_segment(mh, (void *)seg);

    size_t kextl = 0, segl = 0, sectl = 0;
    
    kextl = strlen(kext);

    char *kn = malloc(kextl + 1);
    strcpy(kn, kext);
    kn[kextl] = '\0';
    kr->kext = kn;

    if(seg){
        segl = strlen(seg);
        char *segn = malloc(segl + 1);
        strcpy(segn, seg);
        segn[segl] = '\0';
        kr->seg = segn;
    }

    if(sect){
        sectl = strlen(sect);
        char *sectn = malloc(sectl + 1);
        strcpy(sectn, sect);
        sectn[sectl] = '\0';
        kr->sect = sectn;
    }

    ranges[nkextranges] = kr;
    *nkextranges_out = nkextranges + 1;
}

static void xnuspy_prep(const char *cmd, char *args){
    /* all the patchfinders in pf/pfs.h currently do 32 bit */
    xnu_pf_patchset_t *patchset = xnu_pf_patchset_create(XNU_PF_ACCESS_32BIT);

    size_t nkextranges = 0;
    struct kextrange **kextranges = malloc(sizeof(struct kextrange *) * MAXKEXTRANGE);

    for(int i=0; !PFS_END(g_all_pfs[i]); i++){
        struct pf *pf = &g_all_pfs[i][g_kern_version_major - VERSION_BIAS];

        if(IS_PF_UNUSED(pf))
            continue;

        const char *pf_kext = pf->pf_kext;
        const char *pf_segment = pf->pf_segment;
        const char *pf_section = pf->pf_section;

        if(pf_kext){
            add_kext_range(kextranges, pf_kext, pf_segment, pf_section,
                    &nkextranges);
        }

        xnu_pf_maskmatch(patchset, (char *)pf->pf_name, pf->pf_matches,
                pf->pf_masks, pf->pf_mmcount, false, pf->pf_callback);
    }

    xnu_pf_emit(patchset);

    xnu_pf_range_t *__TEXT_EXEC = xnu_pf_segment(mh_execute_header, "__TEXT_EXEC");
    xnu_pf_apply(__TEXT_EXEC, patchset);

    for(size_t i=0; i<nkextranges; i++){
        xnu_pf_range_t *range = kextranges[i]->range;
        xnu_pf_apply(range, patchset);
    }

    xnu_pf_patchset_destroy(patchset);
}

void module_entry(void){
    puts("xnuspy: loaded!");

    mh_execute_header = xnu_header();
    kernel_slide = xnu_slide_value(mh_execute_header);

    next_preboot_hook = preboot_hook;
    preboot_hook = xnuspy_preboot_hook;
    
    command_register("xnuspy-getkernelv", "get kernel version", xnuspy_getkernelv);
    command_register("xnuspy-prep", "get all offsets", xnuspy_prep);
}

const char *module_name = "xnuspy";

struct pongo_exports exported_symbols[] = {
    { .name = 0, .value = 0 }
};

```

`opdump/Makefile`:

```
CC = clang
CFLAGS = -g

opdump : opdump.c
	$(CC) $(CFLAGS) opdump.c -o opdump

```

`opdump/opdump.c`:

```c
#include <errno.h>
#include <fcntl.h>
#include <mach-o/loader.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>

static void usage(void){
    printf("Usage:\n"
           "    -a <name>       Create a C uint8_t array out of what's dumped.\n"
           "    -d              Dump __DATA\n"
           "    -i <name>       Input Mach-O file name\n"
           "    -o <name>       Output file name\n"
           "    -t              Dump __TEXT\n"
          );

    exit(1);
}

int main(int argc, char **argv){
    char *input = NULL, *output = NULL;
    int c_array = 0;
    char *c_array_name = NULL;
    int dump_text = 0;
    int dump_data = 0;

    int c;

    opterr = 0;

    while((c = getopt(argc, argv, "a:di:o:t")) != -1){
        switch(c){
            case 'a':
                c_array = 1;
                c_array_name = optarg;
                break;
            case 'd':
                dump_data = 1;
                break;
            case 'i':
                input = optarg;
                break;
            case 'o':
                output = optarg;
                break;
            case 't':
                dump_text = 1;
                break;
            default:
                usage();
        };
    }

    if(!input){
        printf("Expected input file name\n");
        return 1;
    }

    if(!output){
        printf("Expected output file name\n");
        return 1;
    }

    if(c_array && !c_array_name){
        printf("Need name for C array\n");
        return 1;
    }

    if(!dump_data && !dump_text){
        printf("Need either -d or -t\n");
        return 1;
    }

    int fd = open(input, O_RDONLY);

    if(fd == -1){
        printf("open: %s\n", strerror(errno));
        return 1;
    }

    struct stat st;

    if(stat(input, &st)){
        printf("stat: %s\n", strerror(errno));
        close(fd);
        return 1;
    }

    size_t fsz = st.st_size;

    void *fdata = mmap(NULL, fsz, PROT_READ, MAP_PRIVATE, fd, 0);

    close(fd);

    if(fdata == MAP_FAILED){
        printf("mmap: %s\n", strerror(errno));
        return 1;
    }

    struct mach_header_64 *mh = fdata;

    if(mh->magic != MH_MAGIC_64){
        printf("'%s' is not a mach-o file?\n", input);
        munmap(fdata, fsz);
        return 1;
    }

    struct load_command *lc = (struct load_command *)(mh + 1);

    /* __TEXT and __DATA are adjacent. But in case __DATA is
     * not present, we go until we hit the end of __TEXT */
    uint8_t *raw_cursor = NULL, *raw_end = NULL;

    for(int i=0; i<mh->ncmds; i++){
        if(lc->cmd != LC_SEGMENT_64)
            goto nextcmd;

        struct segment_command_64 *sc64 = (struct segment_command_64 *)lc;

        if(strcmp(sc64->segname, "__TEXT") == 0){
            struct section_64 *sec64 = (struct section_64 *)(sc64 + 1);

            for(int k=0; k<sc64->nsects; k++){
                if(dump_text && strcmp(sec64->sectname, "__text") == 0){
                    /* Make sure we start at the first function of __text and
                     * not the Mach-O header */
                    raw_cursor = (uint8_t *)((uintptr_t)fdata + sec64->offset);
                    raw_end = (uint8_t *)((uintptr_t)raw_cursor + sec64->size);

                    break;
                }

                sec64++;
            }
        }
        else if(dump_data && strcmp(sc64->segname, "__DATA") == 0){
            uint8_t *DATA_start = (uint8_t *)((uintptr_t)fdata + sc64->fileoff);

            if(!dump_text)
                raw_cursor = DATA_start;

            raw_end = (uint8_t *)(DATA_start + sc64->filesize);
        }

nextcmd:
        lc = (struct load_command *)((uintptr_t)lc + lc->cmdsize);
    }

    if(!raw_cursor){
        printf("Did not find start section\n");
        munmap(fdata, fsz);
        return 1;
    }

    FILE *outp = fopen(output, "wb");

    if(!outp){
        printf("fopen: %s\n", strerror(errno));
        munmap(fdata, fsz);
        return 1;
    }

    /* TODO: handle function starts */
    uint64_t nbytes = 0;

    if(c_array){
        fprintf(outp,
                "#ifndef %s_h\n"
                "#define %s_h\n"
                "static uint8_t g_%s[] = {\n",
                c_array_name, c_array_name, c_array_name);
    }

    while(raw_cursor < raw_end){
        if(!c_array){
            fwrite(raw_cursor, sizeof(uint8_t), 1, outp);
        }
        else{
            fprintf(outp, "\t0x%02x,\n", *raw_cursor);
            nbytes++;
        }

        raw_cursor++;
    }

    if(c_array){
        fprintf(outp, "};\n"
                "static const uint64_t g_%s_len = %lld;\n"
                "#endif", c_array_name, nbytes);
    }

    fflush(outp);
    fclose(outp);

    munmap(fdata, fsz);

    return 0;
}

```