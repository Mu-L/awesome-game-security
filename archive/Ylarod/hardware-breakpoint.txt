Project Path: arc_Ylarod_hardware-breakpoint_1yny7180

Source Tree:

```txt
arc_Ylarod_hardware-breakpoint_1yny7180
├── LICENSE
├── Makefile
├── README.md
├── doc
│   └── 硬件断点驱动解析.md
├── ext_hw_breakpoint.h
├── hw_breakpoint.c
├── hw_breakpoint_manage.c
├── hw_breakpoint_proc.c
├── hw_breakpoint_smp.c
├── hw_breakpoint_until.c
├── hw_breakpoint_until.h
└── make.sh

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Lesser General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

                    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

                            NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

Also add information on how to contact you by electronic and paper mail.

If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

    Gnomovision version 69, Copyright (C) year name of author
    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, the commands you use may
be called something other than `show w' and `show c'; they could even be
mouse-clicks or menu items--whatever suits your program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
  `Gnomovision' (which makes passes at compilers) written by James Hacker.

  <signature of Ty Coon>, 1 April 1989
  Ty Coon, President of Vice

This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.

```

`Makefile`:

```
CROSS?= aarch64-none-linux-gnu-
KERNEL_DIR?= your kernel dir
CURRENT_PATH:= $(shell pwd)
MODULE_NAME= hw_break

src_dir?= $(shell pwd)
export src_dir


includedir:= -I$(src_dir)/include
EXTRA_CFLAGS+= $(includedir) -g


obj-m:= $(MODULE_NAME).o
$(MODULE_NAME)-objs+= 	hw_breakpoint.o \
						hw_breakpoint_manage.o \
    					hw_breakpoint_proc.o \
    					hw_breakpoint_smp.o \
						hw_breakpoint_until.o \
    

all: ko
# 编译驱动
ko:
	make -C $(KERNEL_DIR) M=$(CURRENT_PATH) EXTRA_CFLAGS="$(EXTRA_CFLAGS)" CROSS_COMPILE=${CROSS} ARCH=arm64 modules


clean:
	make -C $(KERNEL_DIR) M=$(CURRENT_PATH) clean
```

`README.md`:

```md
## 已实现功能
- [x] proc通过IO物理地址查询所有ioremap的虚拟地址   
- [x] proc通过符号查询符号里的内容，常用于指针变量
- [x] proc通过符号查询符号地址
- [x] proc列出所有已经插入的断点 
- [x] 通过导出的函数使用符号或地址添加删除断点
- [x] proc通过符号和地址添加删除断点
- [x] 支持断点触发次数统计


## 使用方法

这里只介绍proc接口的使用方法，代码里使用直接调对应的函数即可，接口均已导出。具体实现见[原理解析](./doc/硬件断点驱动解析.md)。

### 添加断点

```
echo add <type> <len> <symbol>/<addr> > /proc/breakpoint, add a breakpoint
	[type]:
		[wp1]: HW_BREAKPOINT_R
		[wp2]: HW_BREAKPOINT_W
		[wp3]: HW_BREAKPOINT_R|HW_BREAKPOINT_W
		 [bp]:  HW_BREAKPOINT_X
	[len]:[0,8] (2^3,2^31]
```

使用add指令可添加一个断点，长度可以是1~2^31的任意值，驱动会自动解析入参，设置一个大于期望监控地址范围的断点。触发时会根据期望监控的地址范围，选择是否打印堆栈。重复插入相同地址的断点会失败

### 删除断点

`echo del <symbol>/<addr> > /proc/breakpoint, del a breakpoint `

删除一个断点。

### 查询符号地址或数据

`echo get ptr/val <symbol> > /proc/breakpoint, search &symbol/*(&symbol)`

有些时候想监控的地址是一个指针变量的地址的话，直接输入该符号名字，就无法监控了。所以提供了一个可以查询符号里内容的操作，可以查询指针变量里的指针。然后使用`echo add <type> <len> <addr> > /proc/breakpoint`打断点。也可以查询函数地址，然后在函数地址+N的地方设置执行断点。

### 列出所有已设置的断点

`echo show > /proc/breakpoint`

该命令用于查询所有已设置的断点，信息示例如下所示：

```
--------------------------------------------------
breakpoint[6]:														/*观察断点是6~9，执行断点是0~5*/
        type:   HW_BREAKPOINT_RW									/*断点类型*/
        name:   zwf_test_value0+0x0/0xffffffffffffda78 [hw_break]	/*断点的符号名称*/
        monit:  0xffffff8000843588--->0xffffff800084358b			/*断点期望监控的地址范围*/
        len:    4													/*断点期望监控的长度*/
        mask:   0x0													/*断点的mask掩码*/
        range:  0xffffff8000843588--->0xffffff800084358c			/*断点实际监控的地址范围*/
        size:   4													/*断点实际监控的大小*/
--------------------------------------------------
breakpoint[7]:
        type:   HW_BREAKPOINT_RW
        name:   zwf_test_value1+0x0/0xffffffffffffd9f8 [hw_break]
        monit:  0xffffff8000843608--->0xffffff8000843610
        len:    9
        mask:   0x5
        range:  0xffffff8000843600--->0xffffff800084361f
        size:   31
--------------------------------------------------
breakpoint[8]:
        type:   HW_BREAKPOINT_RW
        name:   zwf_test_value2+0x0/0xffffffffffffd978 [hw_break]
        monit:  0xffffff8000843688--->0xffffff80008436d4
        len:    77
        mask:   0x7
        range:  0xffffff8000843680--->0xffffff80008436ff
        size:   127
--------------------------------------------------
breakpoint[9]:
        type:   HW_BREAKPOINT_RW
        name:   zwf_test_value3+0x0/0xffffffffffffdb00 [hw_break]
        monit:  0xffffff8000843500--->0xffffff800084357f
        len:    128
        mask:   0x8
        range:  0xffffff8000843500--->0xffffff80008435ff
        size:   255

```

### 根据IO地址查询所有映射的虚拟地址

`echo iophy <ioaddr> > /proc/breakpoint`
该功能用于监测IO地址的更改，因为同一个IO地址可能被多个地方ioremap过，所以要监测IO地址的话就先找到该IO地址对应的所有虚拟地址。
示例：
```
/home # echo iophy 0x11030000 > /proc/breakpoint
--------------------------------------------------
VM STRUCT:
     phy addr:       0x11030000              /*该vm_struct映射的物理起始地址*/
     virt addr:      0xffffff800a135000      /*物理地址对应的虚拟地址起始地址*/
     size:           0x2000                  /*vm_struct映射的内存大小*/
0x11030000 to virt: 0xffffff800a135000          /*要查询的IO地址对应的虚拟地址*/

--------------------------------------------------
VM STRUCT:
        phy addr:       0x11020000
        virt addr:      0xffffff800c780000
        size:           0x11000
0x11030000 to virt: 0xffffff800c790000

--------------------------------------------------
VM STRUCT:
        phy addr:       0x10280000
        virt addr:      0xffffff8010000000
        size:           0x79d1000
0x11030000 to virt: 0xffffff8010db0000

```


```

`doc/硬件断点驱动解析.md`:

```md

# 硬件断点是什么

硬件断点是cpu自带的用于调试程序的断点，分为执行断点和内存断点。比如armv8架构，它有4个内存断点和6个执行断点。执行断点是最常见的断点类型，就是在某个程序地址处加断点，CPU运行到这里时就会触发，触发长度是4字节。而内存断点是，监控某一个内存区间，当CPU试图访问或者是操作这块内存时就会触发，触发长度可以是[1,8]字节，或是(8,2G]字节，其中8~2G的区间内只能是2的幂。

# 硬件断点的实现机制

cpu的架构不同，硬件断点的机制也不同。通常都是配置好对应的断点寄存器后，CPU触发断点，触发调试异常，进入中断执行相应操作后退出。大概流程如下图所示：

```mermaid
flowchart TB
    CONFIG_BKREG([配置断点寄存器])
    CPU_RUN([CPU正常运行])
    CPU_TRIGER([CPU访问断点内的地址])
    INTO_ESR([CPU发生异常])
    DECODE_ESRISS([解码ISS得到异常类型为ESR_ELx_EC_BREAKPT_CUR])
    GET_ESR_ENTRY([从异常向量表中找到ESR_ELx_EC_BREAKPT_CUR对应的服务函数])
    DEBUG_HANDLE([执行服务函数])

    CONFIG_BKREG-->CPU_RUN
    CPU_RUN-->CPU_TRIGER
    CPU_TRIGER-->INTO_ESR
    INTO_ESR-->DECODE_ESRISS
    DECODE_ESRISS-->GET_ESR_ENTRY
    GET_ESR_ENTRY-->DEBUG_HANDLE

    DEBUG_HANDLE-->CPU_RUN
```

## 断点寄存器解析

以armv8为例，比如cotex-a55核心，每个断点都有2个用于控制硬件断点的寄存器。如下所示：()下面表格中的N代表第几个断点，X代表异常等级，比如el0, el1, el2)

| name          | explain                |
| ------------- | ---------------------- |
| `dbgbvrN_elX` | 执行断点地址设置寄存器 |
| `dbgbcrN_elX` | 执行断点控制寄存器     |
| `dbgwvrN_elX` | 观察断点地址设置寄存器 |
| `dbgwcrN_elX` | 观察断点控制寄存器     |

### `dbgbvrN_elX`

设置执行断点的地址，linux里直接填入对应函数的虚拟地址即可。

### `dbgbcrN_elX`

执行断点的控制寄存器，共有31BIT。用于控制断点的各种属性。具体如下所示：

| 31~24 | 23~20 | 19~16 | 15~14 |  13  | 12~9 | 8~5  | 4~3  | 2~1  |  0   |
| :---: | :---: | :---: | :---: | :--: | :--: | :--: | :--: | :--: | :--: |
| RES2  |  BT   |  LBN  |  SSC  | HMC  | RES1 | BAS  | RES0 | PMC  |  E   |

其中比较常用的是E, PMC, BT。

* E是断点使能位，高位使能。
* PMC用于记录上次控制时的异常等级，配合HMC和SSC一起使用
* BT是控制断点触发的条件，默认是0b0000，对应的触发条件是当地址匹配时触发。

### `dbgwvrN_elX`

设置观察断点的地址，linux里直接填入想观察的内存区域的起始地址即可。

### `dbgwcrN_elX`

观察断点的控制寄存器，共有31bit，用于控制观察断点的各种属性。具体如下所示：

| 31~29 | 28~24 | 23~21 |  20  | 19~16 | 15~14 |  13  | 12~5 | 4~3  | 2~1  |  0   |
| ----- | :---: | :---: | :--: | :---: | :---: | :--: | :--: | :--: | :--: | :--: |
| RES1  | MASK  | RES0  |  WT  |  LBN  |  SSC  | HMC  | BAS  | LSC  | PAC  |  E   |

其中比较常用的是E, PAC, BAS, MASK。

* E是断点使能位，高位使能。
* PAC用于记录上次控制时的异常等级，配合HMC和SSC一起使用
* BAS一共8bit，代表要监控的内存大小，每1bit代表1byte，最大可检测8bytes。
* MASK代表使用掩码的模式监控地址，共有5bit，代表可以掩掉dbgwvrN_elX中的0~31位低地址。

#### MASK举例

比如想监控的地址是 `0xffffffc0622a5c10, MASK=0b00111`

则监控的范围是：`0xffffffc0622a5c00~0xffffffc0622a5c7f`，实际的 `dbgwcrN_elX=0xffffffc0622a5c00`

假如 `MASK=0b01100`

则监控的范围是：`0xffffffc0622a5000~0xffffffc0622a5fff`，实际的 `dbgwcrN_elX=0xffffffc0622a5000`

# 实现硬件断点驱动

在linux内核里其实有硬件断点功能，但是这个硬件断点不太好用，它依赖太多的配置选项。开了这些配置选项除了内核需要重编之外，由于头文件变更过大，所以所有的驱动也要重编。而且内核的硬件断点只能监控8字节，也不支持设置断点触发事件，自定义属性太少。

## 硬件断点需要实现的部分

实现硬件断点驱动，主要是需要实现以下几部分：

1. 注册自己的断点异常服务函数。
2. 根据设定的地址和长度自动解析需配置的硬件断点寄存器值。
3. 设置硬件断点寄存器。

## 硬件断点实现需要的内核接口

上述部分的实现依赖一些内核接口，这些接口内核是没有导出符号的，不过只要开启了 `CONFIG_KALLSYMS=y`，函数都是可以查询的到的。

涉及的接口如下：

```c
typedef struct HW_kernelApi
{
    struct
    {
        unsigned long (*kallsyms_lookup_name)(const char *name); /*根据符号查询地址函数*/
        void (*register_step_hook)(struct step_hook *hook);      /*注册step调试异常hook的函数*/
        void (*unregister_step_hook)(struct step_hook *hook);    /*取消注册step调试异常hook的函数*/
        void (*enable_debug_monitors)(enum dbg_active_el el);    /*使能debug异常*/
        void (*disable_debug_monitors)(enum dbg_active_el el);   /*失能debug异常*/
        int (*kernel_active_single_step)(void);                  /*单步调试是否激活*/
        void (*kernel_enable_single_step)(struct pt_regs *regs); /*使能单步调试异常*/
        void (*kernel_disable_single_step)(void);                /*失能单步调试异常*/
        u64 (*read_sanitised_ftr_reg)(u32 id);                   /*读ftr寄存器*/
        void (*show_regs)(struct pt_regs *);                     /*显示堆栈*/
        void (*do_bad)(unsigned long addr, unsigned int esr, struct pt_regs *regs); /*调试异常的默认中断处理函数*/
    } __aligned(128) fun;
    struct
    {
#ifdef CONFIG_CPU_PM
        u64 *hw_breakpoint_restore;         /*cpu从调试暂停恢复运行时执行的函数*/
        u64  default_hw_breakpoint_restore; /*接管之前的函数地址*/
#endif
        struct fault_info *debug_fault_info;      /*接管硬件断点调试异常中断，替换回调函数*/
        struct fault_info  default_fault_info[2]; /*接管之前的数据信息*/
    } __aligned(128) val;
} HW_kernelApi;
```

我记得在linux 5.7.0之后的内核版本，kallsyms_lookup_name这个根据符号查询地址的函数，是不再导出了。所以驱动中需要先找到这个符号的地址，再用这个地址去查询其余需要的内核接口即可。寻找kallsyms_lookup_name的代码如下：

```c
/*根据名字找函数地址*/
unsigned long kaddr_lookup_name(const char *fname_raw)
{
    int           i;
    unsigned long kaddr;
    char         *fname_lookup, *fname;

    fname_lookup = kzalloc(NAME_MAX, GFP_KERNEL);
    if (!fname_lookup)
        return 0;

    fname = kzalloc(strlen(fname_raw) + 4, GFP_KERNEL);
    if (!fname)
        return 0;

    /*第一个0x0代表是该符号的起始地址*/
    strcpy(fname, fname_raw);
    strcat(fname, "+0x0");

    /*获取内核代码段基地址*/
    kaddr  = (unsigned long)&sprint_symbol;
    kaddr &= 0xffffffffff000000;

    /*内核符号不会超过0x100000*16的大小，所以按4字节偏移，挨个找*/
    for (i = 0x0; i < 0x400000; i++)
    {
        /*寻找地址对应的符号名称*/
        sprint_symbol(fname_lookup, kaddr);
        /*对比寻找的符号名字*/
        if (strncmp(fname_lookup, fname, strlen(fname)) == 0)
        {
            /*找到了就返回地址*/
            kfree(fname_lookup);
            kfree(fname);
            return kaddr;
        }
        /*偏移4字节*/
        kaddr += 0x04;
    }
    /*没找到地址就返回0*/
    kfree(fname_lookup);
    kfree(fname);
    return 0;
}
```

## 解析要设置断点信息

对于使用者来说，是不需要关注每个断点寄存器应该配什么值，只需要知道以下几点就行了：

1. 断点类型：执行断点或是读/写断点。
2. 断点地址
3. 断点监控的长度

所以这部分需要解析对应调用者传入的参数，自动解析出寄存器需要配置的值。流程如下：

```mermaid
flowchart LR
	%% 设置曲线样式
	%%{ init: { 'flowchart': { 'curve': 'basis' } } }%%
    TYPE([BK TYPE])
    ADDR([BK ADDR])
    LEN([BK LEN])

    subgraph BP
    	direction LR
        dbgbvr([dbgbvr=addr])
        dbgbcr([dbgbcr.EN=1,\n.BT=0\n.bas=0b1111])

    end
    TYPE-->BP
    ADDR-->dbgbvr
    LEN-->|len=4|dbgbcr

    subgraph WP
    	direction TB
        len[[len>8?]]
        BASWl([dbgwcr.bas=0blen*1])
        dbgwvr([dbgwvr=addr])
    
        getBaseMask(["mask=log2(len)"])
        ifMask[["2^mask*bit=1 > addr+len?"]]
        maskAdd(["mask=mask+1"])
        MASK(["dbgwcr.mask=mask"])
    
    
    
    
        len-->|否|BASWl
        len-->|是|getBaseMask
        getBaseMask-->ifMask
        ifMask-->|是|MASK
        ifMask-->|否|maskAdd
        maskAdd-->ifMask
    end
  
    LEN-->len
    ADDR-->dbgwvr
    TYPE-->WP

```

## 实现断点异常服务函数

以观察断点服务函数为例，当一个观察断点触发时需要如下几步。

1. 先关闭所有观察断点，防止其一直触发。
2. 遍历所有已设置的观察断点，求出触发的地址与设置的地址正向距离最近的那个断点。
3. 取出断点数据结构，筛选该地址是否在期望监控的地址范围内。
4. 执行用户函数。
5. 在当前regs开启single step
6. 进入single step异常服务函数
7. 重新开启断点。

至此整个流程完毕，执行断点流程类似。代码如下所示：

```c
/*watchpoint回调函数*/
static int HW_watchpointHandler(unsigned long addr, unsigned int esr, struct pt_regs *regs)
{
    int                       i, *kernel_step, access, closest_match = -1;
    u64                       min_dist = -1, dist;
    u32                       ctrl_reg;
    u64                       val, startAddr, endAddr;
    struct HW_breakpointInfo *wp, **slots;
    // struct debug_info *debug_info;
    HW_breakpointVC     *info = NULL;
    HW_breakpointCtrlReg ctrl;

    slots = this_cpu_ptr(wp_on_reg);
    // debug_info = &current->thread.debug;

    /*
	 * Find all watchpoints that match the reported address. If no exact
	 * match is found. Attribute the hit to the closest watchpoint.
	 */
    rcu_read_lock();
    for (i = 0; i < core_num_wrps; ++i)
    {
        wp = slots[i];
        if (wp == NULL)
            continue;

        /*
		 * Check that the access type matches.
		 * 0 => load, otherwise => store
		 */
        access = (esr & AARCH64_ESR_ACCESS_MASK) ? HW_BREAKPOINT_W : HW_BREAKPOINT_R;
        if (!(access /*& hw_breakpoint_type(wp)待实现，将wp与attr->type关联*/))
            continue;

        /* Check if the watchpoint value and byte select match. */
        val      = HW_readBreakpointReg(AARCH64_DBG_REG_WVR, i);
        ctrl_reg = HW_readBreakpointReg(AARCH64_DBG_REG_WCR, i);
        HW_decodeCtrlReg(ctrl_reg, &ctrl);
        dist = HW_getDistanceFromWatchpoint(addr, wp->attr.addr, &ctrl);
        if (dist < min_dist)
        {
            min_dist      = dist;
            closest_match = i;
        }
        /* Is this an exact match? */
        if (dist != 0)
            continue;
        info          = HW_counterArchbp(wp);
        info->trigger = addr;
        closest_match = i;
    }
    if (min_dist > 0 && min_dist != -1)
    {
        /* No exact match found. */
        wp            = slots[closest_match];
        info          = HW_counterArchbp(wp);
        info->trigger = addr;
    }
    rcu_read_unlock();

    /*关闭所有断点*/
    HW_toggleBpRegisters(AARCH64_DBG_REG_WCR, DBG_ACTIVE_EL0, 0);
    HW_toggleBpRegisters(AARCH64_DBG_REG_WCR, DBG_ACTIVE_EL1, 0);
    kernel_step = this_cpu_ptr(&stepping_kernel_bp);

    // printk("watchpoint is trigger,addr=0x%lx, close = %d, dist = %d, mindist = %d, info = %lx\n",
    //        addr, closest_match, dist, min_dist);
    if (info)
    {
        wp = container_of(info, struct HW_breakpointInfo, info);
        if (addr >= wp->attr.addr && addr < wp->attr.addr + wp->attr.len)
        {
            /*在期望检测的地址范围之内，才打印堆栈信息*/
            printk("wp is triger = 0x%llx, addr = 0x%llx, len = %d\n", addr, wp->attr.addr, wp->attr.len);
            kernelApi.fun.show_regs(regs);
        }
        info->trigger = 0;
    }

    if (*kernel_step != ARM_KERNEL_STEP_NONE)
        return 0;

    if (kernelApi.fun.kernel_active_single_step())
    {
        *kernel_step = ARM_KERNEL_STEP_SUSPEND;
    }
    else
    {
        *kernel_step = ARM_KERNEL_STEP_ACTIVE;
        /*在当前regs触发step异常*/
        kernelApi.fun.kernel_enable_single_step(regs);
    }
    // }

    return 0;
}
```

## 注册调试异常服务函数

当断点触发时，是会进入到内核的调试异常服务函数，这个函数里会解析异常类型，去运行对应的断点调试异常函数。内核默认的断点调试异常函数是 `do_bad`，这是一个空函数。需要将这个函数替换为我们自己对应的服务函数。

```c
    /* 注册调试异常回调函数 */
    /*执行断点*/
    /*保存原先的变量*/
    kernelApi.val.default_fault_info[0].fn   = kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWBP].fn;
    kernelApi.val.default_fault_info[0].sig  = kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWBP].sig;
    kernelApi.val.default_fault_info[0].code = kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWBP].code;
    kernelApi.val.default_fault_info[0].name = kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWBP].name;
    /*注册新的内容*/
    kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWBP].fn   = HW_breakpointHandler;
    kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWBP].sig  = SIGTRAP;
    kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWBP].code = TRAP_HWBKPT;
    kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWBP].name = "hw-breakpoint handler";
    /*内存断点*/
    /*保存原先的变量*/
    kernelApi.val.default_fault_info[1].fn   = kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWWP].fn;
    kernelApi.val.default_fault_info[1].sig  = kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWWP].sig;
    kernelApi.val.default_fault_info[1].code = kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWWP].code;
    kernelApi.val.default_fault_info[1].name = kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWWP].name;
    /*注册新的内容*/
    kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWWP].fn   = HW_watchpointHandler;
    kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWWP].sig  = SIGTRAP;
    kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWWP].code = TRAP_HWBKPT;
    kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWWP].name = "hw-watchpoint handler";
    kernelApi.fun.register_step_hook(&gHwStepHook);

#ifdef CONFIG_CPU_PM
    /*注册cpu暂停后恢复断点的回调函数*/
    /*保存原先的变量*/
    kernelApi.val.default_hw_breakpoint_restore = *kernelApi.val.hw_breakpoint_restore;
    *kernelApi.val.hw_breakpoint_restore        = (u64)HW_breakpointReset;
#endif
```

# 已实现的硬件断点驱动

目前的话，该驱动已经实现。详情可参考[硬件断点仓库](https://gitee.com/SmartSmallBoy/hardware-breakpoint)。

目前只依赖两个内核选项：

1. `CONFIG_KALLSYMS=y`
2. `CONFIG_KALLSYMS_ALL=y`

linux 4.19~6.0内核均已测试，可以直接使用。

该驱动共分为3部分，分为底层实现，多核CPU的断点同步管理，API接口开放。

## 底层实现

底层实现包括设置对应的硬件断点寄存器，监控设置的地址，注册调试异常 `hook`等，注册单步异常 `hook`。

## 多核心CPU的断点同步管理

上述的底层实现只是实现单核 `CPU`断点的设置。假如在一个多核心的 `CPU`上要监视某个内存地址的读写行为，那肯定是要监控所有 `CPU`对该地址的读写行为，只监控当前 `CPU`的访问肯定是不够的。所以该部分是对上述底层的封装，对所有运行的核心进行遍历，通过多核同步机制(`smp_call_function_single`)，给所有核心打上/删除相同的断点。

## API接口开放

该部分集中管理所有通过API接口设置的断点，对外开放设置断点的接口，可选择和 `KGDB`联动，实现断点触发后的源码级调试。分为如下几个部分：

1. 直接通过地址设置断点。
2. 通过符号名字设置断点。
3. 在启用 `kgdb`联动功能后，可以通过 `kgdb`的设置断点功能设置硬件断点。
4. 在 `shell`下通过 `proc`调试文件来设置断点。
5. 查询符号地址。
6. 查询符号地址里的内容（针对指针变量使用）。

断点监测的虚拟地址范围最大为2Gb。当断点被触发时，会打印出当时操作这块内存的堆栈信息，便于问题定位，或是代码的深度理解。若是启用了 `KGDB`的联动功能，则会在打出堆栈信息后，进入 `KGDB`状态，等待远程主机连接调试。`KGDB`的原来及使用可以参考我的前一篇文章[KGDB原理分析及远程挂载调试ARM64内核](https://gitee.com/link?target=https%3A%2F%2Fblog.csdn.net%2Fqq_38384263%2Farticle%2Fdetails%2F132290737%3Fspm%3D1001.2014.3001.5502)。


```

`ext_hw_breakpoint.h`:

```h
#ifndef __EXT_HW_BREAKPOINT_H
#define __EXT_HW_BREAKPOINT_H

#include <asm/hw_breakpoint.h>
#include <linux/hw_breakpoint.h>
#include <asm/debug-monitors.h>

#define HW_SYMS_FUNC(x) g_kernel_api.fun.x
#define HW_SYMS_VAL(x) g_kernel_api.val.x

typedef struct hw_trigger_times {
	u64 read;
	u64 write;
	u64 exec;
} hw_trigger_times;

typedef struct hw_bp_callback_data {
	u32 type;
	u64 addr;
	hw_trigger_times times;
} hw_bp_callback_data;

typedef void (*hw_bp_callback)(const hw_bp_callback_data *attr,
			       const struct pt_regs *regs);

typedef struct hw_bp_attr {
	u32 type; /*bp type*/
	u64 addr; /*The addr of the bp expected to be monitored*/
	u64 start_addr; /*The starting address of the actual monitoring*/
	u64 end_addr; /*The end address of the actual monitoring*/
	u64 len; /*The length of the bp expected to be monitored*/
	u64 real_len; /*LBN len*/
	u32 mask; /*addr mask*/
	hw_trigger_times times; /*trigger times*/
	hw_bp_callback handler; /*user handler*/
	u64 disabled : 1, //63bit
		reserved : 63; //0~62bit
} hw_bp_attr;

/*struct of get info*/
typedef struct hw_bp_report {
	u32 type; /*bp type*/
	u64 addr; /*The addr of the bp expected to be monitored*/
	u64 len; /*The length of the bp expected to be monitored*/
	u32 mask;
	hw_trigger_times times; /*trigger times*/
} hw_bp_report;
typedef struct hw_bp_info_list {
	struct list_head list; /*list*/
	hw_bp_report *attr; /*bp attr. attr[cpu_id]*/
	int cpu_mask; /*success install of cpu*/
	int cpu_num; /*total cpu num*/
} hw_bp_info_list;

typedef struct hw_bp_ctrl_reg {
	u32 reserved2 : 3, //29~31bit,
		mask : 5, //24~28bit, addr mask，mask=0b11111: (mask2^0b11111 the low bit addr), support 8~2G range
		reserved1 : 3, //21~23bit,
		wt : 1, //20bit, watchpoint type, Unlinked(0)/linked(1) data address match.
		lbn : 4, //16~19bit, WT is only required to be set when setting, which is related to link breakpoints
		ssc : 2, //14,15bit, Security state control, which controls what state will listen for breakpoint events
		hmc : 1, //13bit, Use in conjunction with the above fields
		len : 8, //5~12bit, LBN of len, Each bit represents 1 byte and a maximum of 8 bytes
		type : 2, //3~4bit， bp type wp/bp
		privilege : 2, //1~2bit, The EL level at the time of the last breakpoint setting is used with SSC and HMC
		enabled : 1; //0bit, bp enable
} hw_bp_ctrl_reg;

typedef struct hw_bp_vc {
	u64 address;
	hw_bp_ctrl_reg ctrl;
	u64 trigger;
	u8 access_type;
} hw_bp_vc;

struct hw_bp_info {
	int cpu;
	hw_bp_attr attr;
	hw_bp_vc info;
};

struct fault_info {
	int (*fn)(unsigned long addr, unsigned int esr, struct pt_regs *regs);
	int sig;
	int code;
	const char *name;
};
typedef struct hw_kernel_api {
	struct {
		unsigned long (*kallsyms_lookup_name)(
			const char *name); /*search symbols func*/
		void (*register_step_hook)(struct step_hook *hook);
		void (*unregister_step_hook)(struct step_hook *hook);
		void (*enable_debug_monitors)(enum dbg_active_el el);
		void (*disable_debug_monitors)(enum dbg_active_el el);
		int (*kernel_active_single_step)(void);
		void (*kernel_enable_single_step)(struct pt_regs *regs);
		void (*kernel_disable_single_step)(void);
		u64 (*read_sanitised_ftr_reg)(u32 id);
		void (*show_regs)(struct pt_regs *);
		void (*dump_backtrace)(struct pt_regs *regs,
				       struct task_struct *tsk);
		void (*do_bad)(unsigned long addr, unsigned int esr,
			       struct pt_regs *regs);
	} __aligned(128) fun;
	struct {
#ifdef CONFIG_CPU_PM
		u64 *hw_breakpoint_restore;
		u64 default_hw_breakpoint_restore;
#endif
		struct fault_info *debug_fault_info;
		struct fault_info default_fault_info[2];
		spinlock_t *vmap_area_lock; /*kernel vm spinlock*/
		struct list_head *vmap_area_list; /*kernel vm list*/
	} __aligned(128) val;

} hw_kernel_api;

extern hw_kernel_api g_kernel_api;

/*encode reg*/
static inline u32 hw_encode_ctrl_reg(hw_bp_ctrl_reg ctrl)
{
	u32 val = (ctrl.mask << 24) | (ctrl.len << 5) | (ctrl.type << 3) |
		  (ctrl.privilege << 1) | ctrl.enabled;

	if (is_kernel_in_hyp_mode() && ctrl.privilege == AARCH64_BREAKPOINT_EL1)
		val |= DBG_HMC_HYP;

	return val;
}

/*decode reg*/
static inline void hw_decode_ctrl_reg(u32 reg, hw_bp_ctrl_reg *ctrl)
{
	ctrl->enabled = reg & 0x1;
	reg >>= 1;
	ctrl->privilege = reg & 0x3;
	reg >>= 2;
	ctrl->type = reg & 0x3;
	reg >>= 2;
	ctrl->len = reg & 0xff;
	reg >>= 19;
	ctrl->mask = reg & 0x1f;
}

static inline hw_bp_vc *hw_get_vc(struct hw_bp_info *bp)
{
	return &bp->info;
}

/* Determine number of BRP registers available. */
static inline int hw_get_num_brps(void)
{
    u64 dfr0 = HW_SYMS_FUNC(read_sanitised_ftr_reg)(SYS_ID_AA64DFR0_EL1);
#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
    return 1 + cpuid_feature_extract_unsigned_field(dfr0, ID_AA64DFR0_EL1_BRPs_SHIFT);
#else
    return 1 + cpuid_feature_extract_unsigned_field(dfr0, ID_AA64DFR0_BRPS_SHIFT);
#endif
}

/* Determine number of WRP registers available. */
static inline int hw_get_num_wrps(void)
{
    u64 dfr0 = HW_SYMS_FUNC(read_sanitised_ftr_reg)(SYS_ID_AA64DFR0_EL1);
#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
    return 1 + cpuid_feature_extract_unsigned_field(dfr0, ID_AA64DFR0_EL1_WRPs_SHIFT);
#else
    return 1 + cpuid_feature_extract_unsigned_field(dfr0, ID_AA64DFR0_WRPS_SHIFT);
#endif
}

int hw_get_bp_num(int type);
void hw_proc_exit(void);
void hw_bp_manage_deinit(void);

/*user handler*/
/*install/uninstall*/
int hw_bp_install_from_addr(u64 addr, int len, int type,
			    hw_bp_callback handler);
void hw_bp_uninstall_from_addr(u64 addr);
int hw_bp_install_from_symbol(char *name, int len, int type,
			      hw_bp_callback handler);
void hw_bp_uninstall_from_symbol(char *name);
/*get install bp info*/
hw_bp_info_list *hw_get_bp_infos(void);
void hw_free_bp_infos(hw_bp_info_list *info);

#endif
```

`hw_breakpoint.c`:

```c
#include <linux/module.h>
#include <asm-generic/kprobes.h>
#include <linux/kallsyms.h>
#include <linux/slab.h>
#include <linux/sched/debug.h>
#include <linux/version.h>
#include <asm/system_misc.h>
#include <asm/debug-monitors.h>
#include "ext_hw_breakpoint.h"

/*func extern*/
extern int hw_bp_manage_init(void);
extern int hw_proc_init(void);

enum hw_breakpoint_ops {
	HW_BREAKPOINT_INSTALL,
	HW_BREAKPOINT_UNINSTALL,
	HW_BREAKPOINT_RESTORE
};

/* Breakpoint currently in use for each BRP. */
static DEFINE_PER_CPU(struct hw_bp_info *, bp_on_reg[ARM_MAX_BRP]);

/* Watchpoint currently in use for each WRP. */
static DEFINE_PER_CPU(struct hw_bp_info *, wp_on_reg[ARM_MAX_WRP]);

/* Currently stepping a per-CPU kernel breakpoint. */
static DEFINE_PER_CPU(int, stepping_kernel_bp);

/* Number of BRP/WRP registers on this CPU. */
static int core_num_brps;
static int core_num_wrps;

/*kernel vars*/
hw_kernel_api g_kernel_api;

/*get bp num*/
int hw_get_bp_num(int type)
{
	switch (type) {
	case TYPE_INST:
		return hw_get_num_brps();
	case TYPE_DATA:
		return hw_get_num_wrps();
	default:
		pr_info("unknown slot type: %d\n", type);
		return 0;
	}
}

#define READ_WB_REG_CASE(OFF, N, REG, VAL)                                     \
	case ((OFF) + (N)):                                                    \
		AARCH64_DBG_READ(N, REG, VAL);                                 \
		break

#define WRITE_WB_REG_CASE(OFF, N, REG, VAL)                                    \
	case ((OFF) + (N)):                                                    \
		AARCH64_DBG_WRITE(N, REG, VAL);                                \
		break

#define GEN_READ_WB_REG_CASES(OFF, REG, VAL)                                   \
	READ_WB_REG_CASE(OFF, 0, REG, VAL);                                    \
	READ_WB_REG_CASE(OFF, 1, REG, VAL);                                    \
	READ_WB_REG_CASE(OFF, 2, REG, VAL);                                    \
	READ_WB_REG_CASE(OFF, 3, REG, VAL);                                    \
	READ_WB_REG_CASE(OFF, 4, REG, VAL);                                    \
	READ_WB_REG_CASE(OFF, 5, REG, VAL);                                    \
	READ_WB_REG_CASE(OFF, 6, REG, VAL);                                    \
	READ_WB_REG_CASE(OFF, 7, REG, VAL);                                    \
	READ_WB_REG_CASE(OFF, 8, REG, VAL);                                    \
	READ_WB_REG_CASE(OFF, 9, REG, VAL);                                    \
	READ_WB_REG_CASE(OFF, 10, REG, VAL);                                   \
	READ_WB_REG_CASE(OFF, 11, REG, VAL);                                   \
	READ_WB_REG_CASE(OFF, 12, REG, VAL);                                   \
	READ_WB_REG_CASE(OFF, 13, REG, VAL);                                   \
	READ_WB_REG_CASE(OFF, 14, REG, VAL);                                   \
	READ_WB_REG_CASE(OFF, 15, REG, VAL)

#define GEN_WRITE_WB_REG_CASES(OFF, REG, VAL)                                  \
	WRITE_WB_REG_CASE(OFF, 0, REG, VAL);                                   \
	WRITE_WB_REG_CASE(OFF, 1, REG, VAL);                                   \
	WRITE_WB_REG_CASE(OFF, 2, REG, VAL);                                   \
	WRITE_WB_REG_CASE(OFF, 3, REG, VAL);                                   \
	WRITE_WB_REG_CASE(OFF, 4, REG, VAL);                                   \
	WRITE_WB_REG_CASE(OFF, 5, REG, VAL);                                   \
	WRITE_WB_REG_CASE(OFF, 6, REG, VAL);                                   \
	WRITE_WB_REG_CASE(OFF, 7, REG, VAL);                                   \
	WRITE_WB_REG_CASE(OFF, 8, REG, VAL);                                   \
	WRITE_WB_REG_CASE(OFF, 9, REG, VAL);                                   \
	WRITE_WB_REG_CASE(OFF, 10, REG, VAL);                                  \
	WRITE_WB_REG_CASE(OFF, 11, REG, VAL);                                  \
	WRITE_WB_REG_CASE(OFF, 12, REG, VAL);                                  \
	WRITE_WB_REG_CASE(OFF, 13, REG, VAL);                                  \
	WRITE_WB_REG_CASE(OFF, 14, REG, VAL);                                  \
	WRITE_WB_REG_CASE(OFF, 15, REG, VAL)

/*read bp reg*/
static u64 hw_read_bp_reg(int reg, int n)
{
	u64 val = 0;

	switch (reg + n) {
		GEN_READ_WB_REG_CASES(AARCH64_DBG_REG_BVR,
				      AARCH64_DBG_REG_NAME_BVR, val);
		GEN_READ_WB_REG_CASES(AARCH64_DBG_REG_BCR,
				      AARCH64_DBG_REG_NAME_BCR, val);
		GEN_READ_WB_REG_CASES(AARCH64_DBG_REG_WVR,
				      AARCH64_DBG_REG_NAME_WVR, val);
		GEN_READ_WB_REG_CASES(AARCH64_DBG_REG_WCR,
				      AARCH64_DBG_REG_NAME_WCR, val);
	default:
		pr_info("attempt to read from unknown breakpoint register %d\n",
			n);
	}

	return val;
}
NOKPROBE_SYMBOL(hw_read_bp_reg);

/*write bp reg*/
static void hw_write_bp_reg(int reg, int n, u64 val)
{
	switch (reg + n) {
		GEN_WRITE_WB_REG_CASES(AARCH64_DBG_REG_BVR,
				       AARCH64_DBG_REG_NAME_BVR, val);
		GEN_WRITE_WB_REG_CASES(AARCH64_DBG_REG_BCR,
				       AARCH64_DBG_REG_NAME_BCR, val);
		GEN_WRITE_WB_REG_CASES(AARCH64_DBG_REG_WVR,
				       AARCH64_DBG_REG_NAME_WVR, val);
		GEN_WRITE_WB_REG_CASES(AARCH64_DBG_REG_WCR,
				       AARCH64_DBG_REG_NAME_WCR, val);
	default:
		pr_info("attempt to write to unknown breakpoint register %d\n",
			n);
	}
	/*Clear the pipeline to ensure that all previous instructions have been completed before the new instructions are executed*/
	isb();
}
NOKPROBE_SYMBOL(hw_write_bp_reg);

/*get elx level*/
static enum dbg_active_el hw_get_debug_exception_level(int privilege)
{
	switch (privilege) {
	case AARCH64_BREAKPOINT_EL0:
		return DBG_ACTIVE_EL0;
	case AARCH64_BREAKPOINT_EL1:
		return DBG_ACTIVE_EL1;
	default:
		pr_info("invalid breakpoint privilege level %d\n", privilege);
		return -EINVAL;
	}
}
NOKPROBE_SYMBOL(hw_get_debug_exception_level);

/**
 * hw_bp_slot_setup - Insert/remove bp in global variables
 *
 * @slots: pointer to the global variables
 * @max_slots: max bp num
 * @bp: bp info
 * @ops: type of bp
 *
 * Return:
 *    success: return the number of bp
 *    -ENOSPC no space
 *    -EINVAL cmd ops
 */
static int hw_bp_slot_setup(struct hw_bp_info **slots, int max_slots,
			    struct hw_bp_info *bp, enum hw_breakpoint_ops ops)
{
	int i;
	struct hw_bp_info **slot;

	for (i = 0; i < max_slots; ++i) {
		slot = &slots[i];
		switch (ops) {
		case HW_BREAKPOINT_INSTALL:
			if (!*slot) {
				*slot = bp;
				return i;
			}
			break;
		case HW_BREAKPOINT_UNINSTALL:
			if (*slot == bp) {
				*slot = NULL;
				return i;
			}
			break;
		case HW_BREAKPOINT_RESTORE:
			if (*slot == bp)
				return i;
			break;
		default:
			pr_info("Unhandled hw breakpoint ops %d\n", ops);
			return -EINVAL;
		}
	}
	return -ENOSPC;
}

/*bp control install/uninstall*/
static int hw_bp_control(struct hw_bp_info *bp, enum hw_breakpoint_ops ops)
{
	hw_bp_vc *info = hw_get_vc(bp);
	struct hw_bp_info **slots;
	int i, max_slots, ctrl_reg, val_reg;
	enum dbg_active_el dbg_el =
		hw_get_debug_exception_level(info->ctrl.privilege);
	u32 ctrl;

	// pr_info("the real CPU = %d\n", smp_processor_id());

	if (info->ctrl.type == ARM_BREAKPOINT_EXECUTE) {
		/* Breakpoint */
		ctrl_reg = AARCH64_DBG_REG_BCR;
		val_reg = AARCH64_DBG_REG_BVR;
		slots = this_cpu_ptr(bp_on_reg);
		max_slots = core_num_brps;
	} else {
		/* Watchpoint */
		ctrl_reg = AARCH64_DBG_REG_WCR;
		val_reg = AARCH64_DBG_REG_WVR;
		slots = this_cpu_ptr(wp_on_reg);
		max_slots = core_num_wrps;
	}

	i = hw_bp_slot_setup(slots, max_slots, bp, ops);

	if (WARN_ONCE(i < 0, "Can't find any breakpoint slot"))
		return i;

	switch (ops) {
	case HW_BREAKPOINT_INSTALL:
		/*Ensure debug monitors are enabled at the correct exception level.*/
		HW_SYMS_FUNC(enable_debug_monitors)(dbg_el);
		fallthrough;
		/* Fall through */
	case HW_BREAKPOINT_RESTORE:
		/* Setup the address register. */
		hw_write_bp_reg(val_reg, i, info->address);

		/* Setup the control register. */
		ctrl = hw_encode_ctrl_reg(info->ctrl);
		// pr_info("CTRL REG = %x\n", ctrl);
		hw_write_bp_reg(ctrl_reg, i, ctrl);
		break;
	case HW_BREAKPOINT_UNINSTALL:
		/* Reset the control register. */
		hw_write_bp_reg(ctrl_reg, i, 0);

		/*Release the debug monitors for the correct exception level.*/
		HW_SYMS_FUNC(disable_debug_monitors)(dbg_el);
		break;
	}

	return 0;
}

/*
 * Install a breakpoint.
 */
int hw_bp_install(struct hw_bp_info *bp)
{
	return hw_bp_control(bp, HW_BREAKPOINT_INSTALL);
}

int hw_bp_uninstall(struct hw_bp_info *bp)
{
	return hw_bp_control(bp, HW_BREAKPOINT_UNINSTALL);
}

/*get len from LBN bit*/
static int hw_get_hbp_Len(u8 hbp_len)
{
	int len_in_bytes = 0;

	switch (hbp_len) {
	case ARM_BREAKPOINT_LEN_1:
		len_in_bytes = 1;
		break;
	case ARM_BREAKPOINT_LEN_2:
		len_in_bytes = 2;
		break;
	case ARM_BREAKPOINT_LEN_3:
		len_in_bytes = 3;
		break;
	case ARM_BREAKPOINT_LEN_4:
		len_in_bytes = 4;
		break;
	case ARM_BREAKPOINT_LEN_5:
		len_in_bytes = 5;
		break;
	case ARM_BREAKPOINT_LEN_6:
		len_in_bytes = 6;
		break;
	case ARM_BREAKPOINT_LEN_7:
		len_in_bytes = 7;
		break;
	case ARM_BREAKPOINT_LEN_8:
	default:
		len_in_bytes = 8;
		break;
	}

	return len_in_bytes;
}

/*
 * Check whether bp virtual address is in kernel space.
 */
int hw_arch_check_bp_in_kspace(hw_bp_vc *hw)
{
	unsigned int len;
	unsigned long va;

	va = hw->address;
	len = hw_get_hbp_Len(hw->ctrl.len);

	/*get addr & len from mask*/
	if (hw->ctrl.mask) {
		len = 1 << hw->ctrl.mask;
	}

	return (va >= TASK_SIZE) && ((va + len - 1) >= TASK_SIZE);
}

/*
 * bp info to ctrl reg
 */
static int hw_arch_build_bp_info(struct hw_bp_info *bp, const hw_bp_attr *attr,
				 hw_bp_vc *hw)
{
	/* Type */
	switch (attr->type) {
	case HW_BREAKPOINT_X:
		hw->ctrl.type = ARM_BREAKPOINT_EXECUTE;
		break;
	case HW_BREAKPOINT_R:
		hw->ctrl.type = ARM_BREAKPOINT_LOAD;
		break;
	case HW_BREAKPOINT_W:
		hw->ctrl.type = ARM_BREAKPOINT_STORE;
		break;
	case HW_BREAKPOINT_RW:
		hw->ctrl.type = ARM_BREAKPOINT_LOAD | ARM_BREAKPOINT_STORE;
		break;
	default:
		return -EINVAL;
	}

	/* Len */
	switch (attr->real_len) {
	case HW_BREAKPOINT_LEN_1:
		hw->ctrl.len = ARM_BREAKPOINT_LEN_1;
		break;
	case HW_BREAKPOINT_LEN_2:
		hw->ctrl.len = ARM_BREAKPOINT_LEN_2;
		break;
	case HW_BREAKPOINT_LEN_3:
		hw->ctrl.len = ARM_BREAKPOINT_LEN_3;
		break;
	case HW_BREAKPOINT_LEN_4:
		hw->ctrl.len = ARM_BREAKPOINT_LEN_4;
		break;
	case HW_BREAKPOINT_LEN_5:
		hw->ctrl.len = ARM_BREAKPOINT_LEN_5;
		break;
	case HW_BREAKPOINT_LEN_6:
		hw->ctrl.len = ARM_BREAKPOINT_LEN_6;
		break;
	case HW_BREAKPOINT_LEN_7:
		hw->ctrl.len = ARM_BREAKPOINT_LEN_7;
		break;
	case HW_BREAKPOINT_LEN_8:
		hw->ctrl.len = ARM_BREAKPOINT_LEN_8;
		break;
	default:
		return -EINVAL;
	}

	/* only permit breakpoints of length 4 */
	if (hw->ctrl.type == ARM_BREAKPOINT_EXECUTE) {
		hw->ctrl.len = ARM_BREAKPOINT_LEN_4;
	}

	/* wp addr mask */
	hw->ctrl.mask = attr->mask;
	/* Address */
	hw->address = attr->start_addr;

	/*
	 * Privilege
	 * Note that we disallow combined EL0/EL1 breakpoints because
	 * that would complicate the stepping code.
	 */
	if (hw_arch_check_bp_in_kspace(hw))
		hw->ctrl.privilege = AARCH64_BREAKPOINT_EL1;
	else
		hw->ctrl.privilege = AARCH64_BREAKPOINT_EL0;

	/* Enabled */
	hw->ctrl.enabled = !attr->disabled;

	return 0;
}

/* parse bp info */
int hw_bp_arch_parse(struct hw_bp_info *bp, const hw_bp_attr *attr,
		     hw_bp_vc *hw)
{
	int ret;

	/* Build the arch_hw_breakpoint. */
	ret = hw_arch_build_bp_info(bp, attr, hw);
	if (ret)
		return ret;

	pr_info("ctrl.len=%x,mask=%d,enabled=%d,address=%llx\n", hw->ctrl.len,
		hw->ctrl.mask, hw->ctrl.enabled, hw->address);

	return 0;
}

/* enable/disable a bp */
static void hw_toggle_bp_registers(int reg, enum dbg_active_el el, int enable)
{
	int i, max_slots, privilege;
	u32 ctrl;
	struct hw_bp_info **slots;

	switch (reg) {
	case AARCH64_DBG_REG_BCR:
		slots = this_cpu_ptr(bp_on_reg);
		max_slots = core_num_brps;
		break;
	case AARCH64_DBG_REG_WCR:
		slots = this_cpu_ptr(wp_on_reg);
		max_slots = core_num_wrps;
		break;
	default:
		return;
	}

	for (i = 0; i < max_slots; ++i) {
		if (!slots[i])
			continue;

		privilege = hw_get_vc(slots[i])->ctrl.privilege;
		if (hw_get_debug_exception_level(privilege) != el)
			continue;

		ctrl = hw_read_bp_reg(reg, i);
		if (enable)
			ctrl |= 0x1;
		else
			ctrl &= ~0x1;
		hw_write_bp_reg(reg, i, ctrl);
	}
}
NOKPROBE_SYMBOL(hw_toggle_bp_registers);

/*bp events exception handler*/
#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
static int hw_bp_handler(unsigned long unused, unsigned long esr,
			 struct pt_regs *regs)
#else
static int hw_bp_handler(unsigned long unused, unsigned int esr,
			 struct pt_regs *regs)
#endif
{
	int i, *kernel_step;
	u32 ctrl_reg;
	u64 addr, val;
	struct hw_bp_info *bp, **slots;
	hw_bp_ctrl_reg ctrl;

	slots = this_cpu_ptr(bp_on_reg);
	addr = instruction_pointer(regs);

	for (i = 0; i < core_num_brps; ++i) {
		rcu_read_lock();

		bp = slots[i];

		if (bp == NULL)
			goto unlock;

		/* Check if the breakpoint value matches. */
		val = hw_read_bp_reg(AARCH64_DBG_REG_BVR, i);
		if (val != (addr & ~0x3))
			goto unlock;

		/* Possible match, check the byte address select to confirm. */
		ctrl_reg = hw_read_bp_reg(AARCH64_DBG_REG_BCR, i);
		hw_decode_ctrl_reg(ctrl_reg, &ctrl);
		if (!((1 << (addr & 0x3)) & ctrl.len))
			goto unlock;

		hw_get_vc(bp)->trigger = addr;

	unlock:
		rcu_read_unlock();
	}

	hw_toggle_bp_registers(AARCH64_DBG_REG_BCR, DBG_ACTIVE_EL1, 0);
	kernel_step = this_cpu_ptr(&stepping_kernel_bp);

	if (*kernel_step != ARM_KERNEL_STEP_NONE)
		return 0;

	if (HW_SYMS_FUNC(kernel_active_single_step)()) {
		*kernel_step = ARM_KERNEL_STEP_SUSPEND;
	} else {
		*kernel_step = ARM_KERNEL_STEP_ACTIVE;
		HW_SYMS_FUNC(kernel_enable_single_step)(regs);
	}

	return 0;
}
NOKPROBE_SYMBOL(hw_bp_handler);

/*get dist from trigger to wp addr*/
static u64 hw_get_distance_from_wp(unsigned long addr, u64 val,
				   hw_bp_ctrl_reg *ctrl)
{
	addr = untagged_addr(addr);
	val = untagged_addr(val);
	return addr - val;
}

/*wp events exception handler*/
#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
static int hw_wp_handler(unsigned long addr, unsigned long esr,
			 struct pt_regs *regs)
#else
static int hw_wp_handler(unsigned long addr, unsigned int esr,
			 struct pt_regs *regs)
#endif
{
	int i, *kernel_step, access, closest_match = -1;
	u64 min_dist = -1, dist;
	u32 ctrl_reg;
	u64 val;
	struct hw_bp_info *wp, **slots;
	hw_bp_vc *info = NULL;
	hw_bp_ctrl_reg ctrl;

	slots = this_cpu_ptr(wp_on_reg);

	/*find the nearest trigger address*/
	rcu_read_lock();
	for (i = 0; i < core_num_wrps; ++i) {
		wp = slots[i];
		if (wp == NULL)
			continue;

		/*check type of wp*/
		access = (esr & AARCH64_ESR_ACCESS_MASK) ? HW_BREAKPOINT_W :
							   HW_BREAKPOINT_R;
		if (!(access & wp->attr.type))
			continue;

		/* Check if the watchpoint value and byte select match. */
		val = hw_read_bp_reg(AARCH64_DBG_REG_WVR, i);
		ctrl_reg = hw_read_bp_reg(AARCH64_DBG_REG_WCR, i);
		hw_decode_ctrl_reg(ctrl_reg, &ctrl);
		dist = hw_get_distance_from_wp(addr, wp->attr.addr, &ctrl);
		if (dist < min_dist) {
			min_dist = dist;
			closest_match = i;
		}
		/* Is this an exact match? */
		if (dist != 0)
			continue;
		info = hw_get_vc(wp);
		info->trigger = addr;
		info->access_type = access;
		closest_match = i;
	}
	if (min_dist > 0 && min_dist != -1) {
		/* No exact match found. */
		wp = slots[closest_match];
		info = hw_get_vc(wp);
		info->trigger = addr;
		info->access_type = access;
	}
	rcu_read_unlock();

	/*disable all of wps*/
	hw_toggle_bp_registers(AARCH64_DBG_REG_WCR, DBG_ACTIVE_EL1, 0);
	kernel_step = this_cpu_ptr(&stepping_kernel_bp);

	if (*kernel_step != ARM_KERNEL_STEP_NONE)
		return 0;

	if (HW_SYMS_FUNC(kernel_active_single_step)()) {
		*kernel_step = ARM_KERNEL_STEP_SUSPEND;
	} else {
		*kernel_step = ARM_KERNEL_STEP_ACTIVE;
		/*enable ss exception in cur regs*/
		HW_SYMS_FUNC(kernel_enable_single_step)(regs);
	}

	return 0;
}
NOKPROBE_SYMBOL(hw_wp_handler);

/*resume bp states*/
static int hw_bp_reinstall(struct pt_regs *regs)
{
	// struct debug_info *debug_info = &current->thread.debug;
	int handled_exception = 0, *kernel_step;

	/*get step states*/
	kernel_step = this_cpu_ptr(&stepping_kernel_bp);

	if (*kernel_step != ARM_KERNEL_STEP_NONE) {
		hw_toggle_bp_registers(AARCH64_DBG_REG_BCR, DBG_ACTIVE_EL1, 1);
		hw_toggle_bp_registers(AARCH64_DBG_REG_WCR, DBG_ACTIVE_EL1, 1);

		if (*kernel_step != ARM_KERNEL_STEP_SUSPEND) {
			HW_SYMS_FUNC(kernel_disable_single_step());
			handled_exception = 1;
		} else {
			handled_exception = 0;
		}

		*kernel_step = ARM_KERNEL_STEP_NONE;
	}

	return !handled_exception;
}
NOKPROBE_SYMBOL(hw_bp_reinstall);

/*bp reset when cold boot*/
static int hw_bp_reset(unsigned int cpu)
{
	int i;
	struct hw_bp_info **slots;
	/*
	 * When a CPU goes through cold-boot, it does not have any installed
	 * slot, so it is safe to share the same function for restoring and
	 * resetting breakpoints; when a CPU is hotplugged in, it goes
	 * through the slots, which are all empty, hence it just resets control
	 * and value for debug registers.
	 * When this function is triggered on warm-boot through a CPU PM
	 * notifier some slots might be initialized; if so they are
	 * reprogrammed according to the debug slots content.
	 */
	for (slots = this_cpu_ptr(bp_on_reg), i = 0; i < core_num_brps; ++i) {
		if (slots[i]) {
			hw_bp_control(slots[i], HW_BREAKPOINT_RESTORE);
		} else {
			hw_write_bp_reg(AARCH64_DBG_REG_BCR, i, 0UL);
			hw_write_bp_reg(AARCH64_DBG_REG_BVR, i, 0UL);
		}
	}

	for (slots = this_cpu_ptr(wp_on_reg), i = 0; i < core_num_wrps; ++i) {
		if (slots[i]) {
			hw_bp_control(slots[i], HW_BREAKPOINT_RESTORE);
		} else {
			hw_write_bp_reg(AARCH64_DBG_REG_WCR, i, 0UL);
			hw_write_bp_reg(AARCH64_DBG_REG_WVR, i, 0UL);
		}
	}

	return 0;
}

static void hw_trigger_handler(struct pt_regs *regs)
{
	int i = 0;
	struct hw_bp_info *wp, **slots;
	hw_bp_callback_data report;

	rcu_read_lock();
	slots = this_cpu_ptr(bp_on_reg);
	for (i = 0; i < core_num_brps; ++i) {
		wp = slots[i];
		if (wp == NULL)
			continue;
		if (wp->info.trigger) {
			wp->attr.times.exec++;
			report.type = HW_BREAKPOINT_X;
			report.addr = wp->info.trigger;
			report.times = wp->attr.times;
			report.type = wp->attr.type;
			/*user handler*/
			wp->attr.handler(&report, regs);

			wp->info.trigger = 0;
		}
	}
	slots = this_cpu_ptr(wp_on_reg);
	for (i = 0; i < core_num_wrps; ++i) {
		wp = slots[i];
		if (wp == NULL)
			continue;
		if (!wp->info.trigger) {
			continue;
		}
		if (wp->info.trigger >= wp->attr.addr &&
		    wp->info.trigger < wp->attr.addr + wp->attr.len) {
			/*The user handler only within the range of addresses that are expected to be detected*/
			if (wp->info.access_type & HW_BREAKPOINT_R) {
				wp->attr.times.read++;
			} else if (wp->info.access_type & HW_BREAKPOINT_W) {
				wp->attr.times.write++;
			}
			/*user handler*/
			report.type = wp->info.access_type;
			report.addr = wp->info.trigger;
			report.times = wp->attr.times;
			wp->attr.handler(&report, regs);
		}
		wp->info.trigger = 0;
	}
	rcu_read_unlock();
}

/*ss exception handler, will run user handler*/
#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
static int hw_step_brk_fn(struct pt_regs *regs, unsigned long esr)
#else
static int hw_step_brk_fn(struct pt_regs *regs, unsigned int esr)
#endif
{
	int *kernel_step;

	/*step states*/
	kernel_step = this_cpu_ptr(&stepping_kernel_bp);

	if (user_mode(regs) || !(*kernel_step))
		return DBG_HOOK_ERROR;

	hw_trigger_handler(regs);

	if (hw_bp_reinstall(regs)) {
		return DBG_HOOK_ERROR;
	}
#ifdef CONFIG_KGDB
	kgdb_handle_exception(0, SIGTRAP, 0, regs);
#endif

	return DBG_HOOK_HANDLED;
}
NOKPROBE_SYMBOL(hw_step_brk_fn);

#ifdef CONFIG_CPU_PM
extern void cpu_suspend_set_dbg_restorer(int (*hw_bp_restore)(unsigned int));
#else
static inline void
cpu_suspend_set_dbg_restorer(int (*hw_bp_restore)(unsigned int))
{
}
#endif

static struct step_hook ghw_step_hook = { .fn = hw_step_brk_fn };

/*search symbol addr*/
unsigned long kaddr_lookup_name(const char *fname_raw)
{
	int i;
	unsigned long kaddr;
	char *fname_lookup, *fname;

	fname_lookup = kzalloc(NAME_MAX, GFP_KERNEL);
	if (!fname_lookup)
		return 0;

	fname = kzalloc(strlen(fname_raw) + 4, GFP_KERNEL);
	if (!fname)
		return 0;

	/*
   * We have to add "+0x0" to the end of our function name
   * because that's the format that sprint_symbol() returns
   * to us. If we don't do this, then our search can stop
   * prematurely and give us the wrong function address!
   */
	strcpy(fname, fname_raw);
	strcat(fname, "+0x0");

	/*获取内核代码段基地址*/
	kaddr = (unsigned long)&sprint_symbol;
	kaddr &= 0xffffffffff000000;

	/*内核符号不会超过0x100000*16的大小，所以按4字节偏移，挨个找*/
	for (i = 0x0; i < 0x400000; i++) {
		/*寻找地址对应的符号名称*/
		sprint_symbol(fname_lookup, kaddr);
		/*对比寻找的符号名字*/
		if (strncmp(fname_lookup, fname, strlen(fname)) == 0) {
			/*找到了就返回地址*/
			kfree(fname_lookup);
			kfree(fname);
			return kaddr;
		}
		/*偏移4字节*/
		kaddr += 0x04;
	}
	/*没找到地址就返回0*/
	kfree(fname_lookup);
	kfree(fname);
	return 0;
}

/*get kallsyms_lookup_name*/
static int hw_get_kallsyms_lookup_name(void)
{
	HW_SYMS_FUNC(kallsyms_lookup_name) =
		(void *)kaddr_lookup_name("kallsyms_lookup_name");
	if (!HW_SYMS_FUNC(kallsyms_lookup_name)) {
		printk("get kallsyms_lookup_name fail \n");
		return -1;
	}
	return 0;
}

/*get vars from kernel*/
static int hw_get_kernel_api(void)
{
	memset(&g_kernel_api, 0, sizeof(g_kernel_api));
	if (hw_get_kallsyms_lookup_name()) {
		return -1;
	}
	HW_SYMS_VAL(debug_fault_info) =
		(void *)HW_SYMS_FUNC(kallsyms_lookup_name)("debug_fault_info");
	if (!HW_SYMS_VAL(debug_fault_info)) {
		pr_warn("get debug_fault_info fail\n");
		return -1;
	}
	// pr_warn("debug_fault_info = %llx,name = %s\n", &HW_SYMS_VAL(debug_fault_info)[0],
	//        HW_SYMS_VAL(debug_fault_info)[0].name);
	// pr_warn("debug_fault_info = %llx,name = %s\n", &HW_SYMS_VAL(debug_fault_info)[2],
	//        HW_SYMS_VAL(debug_fault_info)[2].name);
#ifdef CONFIG_CPU_PM
	HW_SYMS_VAL(hw_breakpoint_restore) = (void *)HW_SYMS_FUNC(
		kallsyms_lookup_name)("hw_breakpoint_restore");
	if (!HW_SYMS_VAL(hw_breakpoint_restore)) {
		pr_warn("get hw_breakpoint_restore fail\n");
		return -1;
	}
	// pr_warn("hw_breakpoint_restore = %llx,%llx\n", HW_SYMS_VAL(hw_breakpoint_restore),
	//        *HW_SYMS_VAL(hw_breakpoint_restore));
#endif
	HW_SYMS_FUNC(kernel_active_single_step) = (void *)HW_SYMS_FUNC(
		kallsyms_lookup_name)("kernel_active_single_step");
	if (!HW_SYMS_FUNC(kernel_active_single_step)) {
		pr_warn("get kernel_active_single_step fail\n");
		return -1;
	}
	HW_SYMS_FUNC(kernel_disable_single_step) = (void *)HW_SYMS_FUNC(
		kallsyms_lookup_name)("kernel_disable_single_step");
	if (!HW_SYMS_FUNC(kernel_disable_single_step)) {
		pr_warn("get kernel_disable_single_step fail\n");
		return -1;
	}
	HW_SYMS_FUNC(kernel_enable_single_step) = (void *)HW_SYMS_FUNC(
		kallsyms_lookup_name)("kernel_enable_single_step");
	if (!HW_SYMS_FUNC(kernel_enable_single_step)) {
		pr_warn("get kernel_enable_single_step fail\n");
		return -1;
	}
	HW_SYMS_FUNC(disable_debug_monitors) = (void *)HW_SYMS_FUNC(
		kallsyms_lookup_name)("disable_debug_monitors");
	if (!HW_SYMS_FUNC(disable_debug_monitors)) {
		pr_warn("get disable_debug_monitors fail\n");
		return -1;
	}
	HW_SYMS_FUNC(do_bad) =
		(void *)HW_SYMS_FUNC(kallsyms_lookup_name)("do_bad");
	if (!HW_SYMS_FUNC(do_bad)) {
		pr_warn("get do_bad fail\n");
		return -1;
	}
	HW_SYMS_FUNC(enable_debug_monitors) = (void *)HW_SYMS_FUNC(
		kallsyms_lookup_name)("enable_debug_monitors");
	if (!HW_SYMS_FUNC(enable_debug_monitors)) {
		pr_warn("get enable_debug_monitors fail\n");
		return -1;
	}
	HW_SYMS_FUNC(read_sanitised_ftr_reg) = (void *)HW_SYMS_FUNC(
		kallsyms_lookup_name)("read_sanitised_ftr_reg");
	if (!HW_SYMS_FUNC(read_sanitised_ftr_reg)) {
		pr_warn("get read_sanitised_ftr_reg fail\n");
		return -1;
	}
	HW_SYMS_FUNC(show_regs) =
		(void *)HW_SYMS_FUNC(kallsyms_lookup_name)("show_regs");
	if (!HW_SYMS_FUNC(show_regs)) {
		pr_warn("get show_regs fail\n");
		return -1;
	}
	HW_SYMS_FUNC(dump_backtrace) =
		(void *)HW_SYMS_FUNC(kallsyms_lookup_name)("dump_backtrace");
	if (!HW_SYMS_FUNC(dump_backtrace)) {
		pr_warn("get dump_backtrace fail\n");
		return -1;
	}
	/*5.0以下内核用的是register_step_hook*/
	HW_SYMS_FUNC(register_step_hook) = (void *)HW_SYMS_FUNC(
		kallsyms_lookup_name)("register_step_hook");
	if (!HW_SYMS_FUNC(register_step_hook)) {
		/*5.0以上内核用的是register_kernel_step_hook*/
		HW_SYMS_FUNC(register_step_hook) = (void *)HW_SYMS_FUNC(
			kallsyms_lookup_name)("register_kernel_step_hook");
		if (!HW_SYMS_FUNC(register_step_hook)) {
			pr_warn("get register_step_hook fail\n");
			return -1;
		}
	}
	HW_SYMS_FUNC(unregister_step_hook) = (void *)HW_SYMS_FUNC(
		kallsyms_lookup_name)("unregister_step_hook");
	if (!HW_SYMS_FUNC(unregister_step_hook)) {
		HW_SYMS_FUNC(unregister_step_hook) = (void *)HW_SYMS_FUNC(
			kallsyms_lookup_name)("unregister_kernel_step_hook");
		if (!HW_SYMS_FUNC(unregister_step_hook)) {
			pr_warn("get unregister_step_hook fail\n");
			return -1;
		}
	}

	/*以下不影响驱动使用，只影响根据io地址查询虚拟地址功能*/
	HW_SYMS_VAL(vmap_area_lock) =
		(void *)HW_SYMS_FUNC(kallsyms_lookup_name)("vmap_area_lock");
	HW_SYMS_VAL(vmap_area_lock) =
		(void *)HW_SYMS_FUNC(kallsyms_lookup_name)("vmap_area_list");
	if ((!HW_SYMS_VAL(vmap_area_lock)) || (!HW_SYMS_VAL(vmap_area_lock))) {
		pr_warn("can not get virt from iophys\n");
	}

	return 0;
}

/*hp init*/
static int __init hw_bp_init(void)
{
	if (hw_get_kernel_api()) {
		return -1;
	}

	core_num_brps = hw_get_num_brps();
	core_num_wrps = hw_get_num_wrps();

	pr_info("found %d breakpoint and %d watchpoint registers.\n",
		core_num_brps, core_num_wrps);

	/* register dbg exception hook */
	/*bp*/
	/*save pre vars*/
	HW_SYMS_VAL(default_fault_info)
	[0].fn = HW_SYMS_VAL(debug_fault_info)[DBG_ESR_EVT_HWBP].fn;
	HW_SYMS_VAL(default_fault_info)
	[0].sig = HW_SYMS_VAL(debug_fault_info)[DBG_ESR_EVT_HWBP].sig;
	HW_SYMS_VAL(default_fault_info)
	[0].code = HW_SYMS_VAL(debug_fault_info)[DBG_ESR_EVT_HWBP].code;
	HW_SYMS_VAL(default_fault_info)
	[0].name = HW_SYMS_VAL(debug_fault_info)[DBG_ESR_EVT_HWBP].name;

	/*new*/
	HW_SYMS_VAL(debug_fault_info)[DBG_ESR_EVT_HWBP].fn = hw_bp_handler;
	HW_SYMS_VAL(debug_fault_info)[DBG_ESR_EVT_HWBP].sig = SIGTRAP;
	HW_SYMS_VAL(debug_fault_info)[DBG_ESR_EVT_HWBP].code = TRAP_HWBKPT;
	HW_SYMS_VAL(debug_fault_info)
	[DBG_ESR_EVT_HWBP].name = "hw-breakpoint handler";
	/*wp*/
	/*save pre vars*/
	HW_SYMS_VAL(default_fault_info)
	[1].fn = HW_SYMS_VAL(debug_fault_info)[DBG_ESR_EVT_HWWP].fn;
	HW_SYMS_VAL(default_fault_info)
	[1].sig = HW_SYMS_VAL(debug_fault_info)[DBG_ESR_EVT_HWWP].sig;
	HW_SYMS_VAL(default_fault_info)
	[1].code = HW_SYMS_VAL(debug_fault_info)[DBG_ESR_EVT_HWWP].code;
	HW_SYMS_VAL(default_fault_info)
	[1].name = HW_SYMS_VAL(debug_fault_info)[DBG_ESR_EVT_HWWP].name;
	/*new*/
	HW_SYMS_VAL(debug_fault_info)[DBG_ESR_EVT_HWWP].fn = hw_wp_handler;
	HW_SYMS_VAL(debug_fault_info)[DBG_ESR_EVT_HWWP].sig = SIGTRAP;
	HW_SYMS_VAL(debug_fault_info)[DBG_ESR_EVT_HWWP].code = TRAP_HWBKPT;
	HW_SYMS_VAL(debug_fault_info)
	[DBG_ESR_EVT_HWWP].name = "hw-watchpoint handler";
	HW_SYMS_FUNC(register_step_hook)(&ghw_step_hook);
#ifdef CONFIG_CPU_PM
	HW_SYMS_VAL(default_hw_breakpoint_restore) =
		*HW_SYMS_VAL(hw_breakpoint_restore);
	*HW_SYMS_VAL(hw_breakpoint_restore) = (u64)hw_bp_reset;
#endif
	hw_bp_manage_init();
	hw_proc_init();

	pr_info("zwf 11111111111111111111111111111 %s ok\n", __FUNCTION__);
	return 0;
}

static void __exit hw_bp_exit(void)
{
	hw_proc_exit();
	hw_bp_manage_deinit();
#ifdef CONFIG_CPU_PM
	*HW_SYMS_VAL(hw_breakpoint_restore) =
		HW_SYMS_VAL(default_hw_breakpoint_restore);
#endif
	HW_SYMS_FUNC(unregister_step_hook)(&ghw_step_hook);
	/*wp*/
	HW_SYMS_VAL(debug_fault_info)
	[DBG_ESR_EVT_HWWP].fn = HW_SYMS_VAL(default_fault_info)[1].fn;
	HW_SYMS_VAL(debug_fault_info)
	[DBG_ESR_EVT_HWWP].sig = HW_SYMS_VAL(default_fault_info)[1].sig;
	HW_SYMS_VAL(debug_fault_info)
	[DBG_ESR_EVT_HWWP].code = HW_SYMS_VAL(default_fault_info)[1].code;
	HW_SYMS_VAL(debug_fault_info)
	[DBG_ESR_EVT_HWWP].name = HW_SYMS_VAL(default_fault_info)[1].name;
	/*bp*/
	HW_SYMS_VAL(debug_fault_info)
	[DBG_ESR_EVT_HWBP].fn = HW_SYMS_VAL(default_fault_info)[0].fn;
	HW_SYMS_VAL(debug_fault_info)
	[DBG_ESR_EVT_HWBP].sig = HW_SYMS_VAL(default_fault_info)[0].sig;
	HW_SYMS_VAL(debug_fault_info)
	[DBG_ESR_EVT_HWBP].code = HW_SYMS_VAL(default_fault_info)[0].code;
	HW_SYMS_VAL(debug_fault_info)
	[DBG_ESR_EVT_HWBP].name = HW_SYMS_VAL(default_fault_info)[0].name;
	printk(" hw_bp_exit\n");
}

module_init(hw_bp_init);
module_exit(hw_bp_exit);

MODULE_AUTHOR("Vimoon Zheng <Vimoon.Zheng@cixtech.com>");
MODULE_DESCRIPTION("hardware breakpoint for SKY1 and later");
MODULE_LICENSE("GPL v2");
MODULE_ALIAS("platform: sky1-bp");

```

`hw_breakpoint_manage.c`:

```c
#include <linux/sched/debug.h>
#include <linux/kallsyms.h>
#include <linux/kgdb.h>
#include <linux/module.h>
#include <linux/version.h>
#include "ext_hw_breakpoint.h"

/*func extern*/
extern int hw_bp_register(struct hw_bp_info *__percpu *cpu_events,
			  hw_bp_attr *attr, int *state);
extern void hw_bp_unregister(struct hw_bp_info *__percpu *bp, int state);

struct hw_bp_manage_info {
	struct hw_bp_info **info; /*percpu bp info*/
	hw_bp_attr attr; /*bp attr*/
	int mask; /*bp register cpu mask*/
	char symbol_name[KSYM_SYMBOL_LEN]; /*symbol name of addr*/
};
struct hw_bp_manage {
	struct hw_bp_manage_info wp[ARM_MAX_WRP]; /*wp*/
	struct hw_bp_manage_info bp[ARM_MAX_BRP]; /*bp*/
	int max_wp_num; /*max num of wp*/
	int max_bp_num; /*max num of bp*/
	int cpu_mask; /*cpu mask, num of cpu*/
	int cpu_num; /**/
	struct mutex lock; /*mutex lock*/
} __aligned(512);

static struct hw_bp_manage g_hw_manage;
const char bp_type_str[4][30] = { "HW_BREAKPOINT_R", "HW_BREAKPOINT_W",
				  "HW_BREAKPOINT_RW", "HW_BREAKPOINT_X" };

/*show info of bp*/
static void hw_bp_show_one(struct hw_bp_manage_info *bp_info, int index)
{
	int cpu;
	struct hw_bp_info *bp_percpu;

	pr_info("--------------------------------------------------\n");
	/*index of bp*/
	switch (bp_info->attr.type) {
	case HW_BREAKPOINT_R:
	case HW_BREAKPOINT_W:
	case HW_BREAKPOINT_RW:
	case HW_BREAKPOINT_X: {
		pr_info("breakpoint[%d]:\n", index);
		break;
	}
	default: {
		pr_info("breakpoint[%d] type is error!\n", index);
		return;
	}
	}

	/*bp type*/
	pr_info("\ttype: \t%s\n", bp_type_str[bp_info->attr.type - 1]);
	/*symbol name of addr*/
	pr_info("\tname: \t%s\n", bp_info->symbol_name);
	/*the range of detect*/
	pr_info("\tmonit: \t0x%llx--->0x%llx\n", bp_info->attr.addr,
		bp_info->attr.addr + bp_info->attr.len - 1);
	/*detect len*/
	pr_info("\tlen: \t%llu\n", bp_info->attr.len);
	/*addr mask*/
	pr_info("\tmask: \t0x%x\n", bp_info->attr.mask);
	/*the fact of detect range*/
	pr_info("\trange: \t0x%llx--->0x%llx\n", bp_info->attr.start_addr,
		bp_info->attr.end_addr);
	pr_info("\tsize: \t%llu\n",
		bp_info->attr.end_addr - bp_info->attr.start_addr);
	pr_info("\ttimes:\n");
#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
	cpus_read_lock();
#else
	get_online_cpus();
#endif
	for_each_possible_cpu(cpu) {
		if (bp_info->mask & 1 << cpu) {
			bp_percpu = per_cpu(*bp_info->info, cpu);
			pr_info("\t\tcpu[%d]: \tread: %llu, write: %llu, exec: %llu\n",
				cpu, bp_percpu->attr.times.read,
				bp_percpu->attr.times.write,
				bp_percpu->attr.times.exec);
		}
	}
#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
	cpus_read_unlock();
#else
	put_online_cpus();
#endif
}

/*show all bp info*/
void hw_bp_show_all(void)
{
	struct hw_bp_manage_info *bp_info = NULL;
	int i = 0;

	mutex_lock(&g_hw_manage.lock);
	for (i = 0; i < g_hw_manage.max_bp_num; i++) {
		bp_info = &g_hw_manage.bp[i];
		if (bp_info->mask & g_hw_manage.cpu_mask) {
			hw_bp_show_one(bp_info, i);
		}
	}

	for (i = 0; i < g_hw_manage.max_wp_num; i++) {
		bp_info = &g_hw_manage.wp[i];
		if (bp_info->mask & g_hw_manage.cpu_mask) {
			hw_bp_show_one(bp_info, i + g_hw_manage.max_bp_num);
		}
	}
	mutex_unlock(&g_hw_manage.lock);
}

static void hw_bp_uninstall_all(void)
{
	struct hw_bp_manage_info *bp_info = NULL;
	int i = 0;

	mutex_lock(&g_hw_manage.lock);
	for (i = 0; i < g_hw_manage.max_bp_num; i++) {
		bp_info = &g_hw_manage.bp[i];
		if (bp_info->mask & g_hw_manage.cpu_mask) {
			hw_bp_unregister(bp_info->info, bp_info->mask);
			/*clear info*/
			memset(bp_info->symbol_name, 0,
			       sizeof(bp_info->symbol_name));
			memset(&bp_info->attr, 0, sizeof(bp_info->attr));
			bp_info->mask = 0;
		}
	}

	for (i = 0; i < g_hw_manage.max_wp_num; i++) {
		bp_info = &g_hw_manage.wp[i];
		if (bp_info->mask & g_hw_manage.cpu_mask) {
			hw_bp_unregister(bp_info->info, bp_info->mask);
			/*clear info*/
			memset(bp_info->symbol_name, 0,
			       sizeof(bp_info->symbol_name));
			memset(&bp_info->attr, 0, sizeof(bp_info->attr));
			bp_info->mask = 0;
		}
	}
	mutex_unlock(&g_hw_manage.lock);
}

static int hw_get_addr_mask(u64 addr, int len)
{
	/*end of the detect addr*/
	u64 addr_tmp = addr + len;
	u64 alignment_mask = 0;
	int mask, i = 0;

	/*log2(len)*/
	mask = (int)__ilog2_u64(len);
	if ((1 << mask) < len) {
		mask = mask + 1;
	}
	for (i = 0; i < mask; i++) {
		alignment_mask |= (1 << i);
	}

	/*Confirm that the end address is within the actual monitoring range*/
	while (1) {
		if ((addr | alignment_mask) >= addr_tmp) {
			break;
		}
		mask = mask + 1;
		alignment_mask |= (1 << i);
		i++;
	}

	if (mask > 31) {
		/*arm64 the mask is 0b11111*/
		mask = 31;
	}
	return mask;
}

static void hw_bp_handler_default(const hw_bp_callback_data *info,
				  const struct pt_regs *regs)
{
	pr_info("bp is triger = 0x%llx, type = %s\n", info->addr,
		bp_type_str[info->type - 1]);
	pr_info("times: read=%llu, write=%llu, exec=%llu\n", info->times.read,
		info->times.write, info->times.exec);
	HW_SYMS_FUNC(show_regs)((struct pt_regs *)regs);
}

/*install bp from addr*/
int hw_bp_install_from_addr(u64 addr, int len, int type, hw_bp_callback handler)
{
	int state, i, max_num, ret, mask = 0;
	struct hw_bp_manage_info *bp_info;
	u64 start_addr, end_addr;
	u64 alignment_mask = 0, real_len = len, offset;

	if ((0 == addr) || (addr < TASK_SIZE)) {
		pr_info("hw_bp_install_from_addr para is error\n");
		return -1;
	}

	switch (type) {
	case HW_BREAKPOINT_R:
	case HW_BREAKPOINT_W:
	case HW_BREAKPOINT_RW: {
		/*wp*/
		bp_info = g_hw_manage.wp;
		max_num = g_hw_manage.max_wp_num;
		if (len > 8) {
			/*len>8, use mask*/
			mask = hw_get_addr_mask(addr, len);
			real_len = 4;
		}
		if (mask != 0) {
			/*get mask startaddr&endaddr*/
			for (i = 0; i < mask; i++) {
				alignment_mask |= (1 << i);
			}
			start_addr = addr & ~(alignment_mask);
			end_addr = addr | alignment_mask;
		} else {
			/*len<=8, use LBN*/
			alignment_mask = 0x7;
			offset = addr & alignment_mask;
			real_len = len << offset;
			if (real_len > 8) {
				real_len = 8;
			}
			start_addr = addr & ~(alignment_mask);
			end_addr = start_addr + real_len;
		}
		break;
	}
	case HW_BREAKPOINT_X: {
		/*bp*/
		real_len = 4;
		bp_info = g_hw_manage.bp;
		max_num = g_hw_manage.max_bp_num;
		alignment_mask = 0x3;
		offset = addr & alignment_mask;
		real_len = len << offset;
		if (real_len > 8) {
			real_len = 8;
		}
		start_addr = addr & ~(alignment_mask);
		end_addr = start_addr + real_len;
		break;
	}
	default: {
		/*bp type error*/
		pr_info("breakpoint type error\n");
		return -1;
	}
	}

	mutex_lock(&g_hw_manage.lock);
	for (i = 0; i < max_num; i++) {
		if ((bp_info[i].mask & g_hw_manage.cpu_mask) != 0) {
			/*This bp has been set*/
			if (bp_info[i].attr.addr == addr) {
				pr_info("[install] The addr [%llx] is already set at index %d\n",
					addr, i);
				mutex_unlock(&g_hw_manage.lock);
				return -1;
			}
		}
	}

	for (i = 0; i < max_num; i++) {
		if ((bp_info[i].mask & g_hw_manage.cpu_mask) != 0) {
			continue;
		}
		bp_info[i].attr.len = len;
		bp_info[i].attr.real_len = real_len;
		bp_info[i].attr.mask = mask;
		bp_info[i].attr.type = type;
		bp_info[i].attr.addr = addr;
		bp_info[i].attr.start_addr = start_addr;
		bp_info[i].attr.end_addr = end_addr;
		bp_info[i].attr.handler = handler;
		if (bp_info[i].attr.handler == NULL) {
			bp_info[i].attr.handler = hw_bp_handler_default;
		}
		break;
	}

	if (i == max_num) {
		pr_info("[install] breakpoint is full type = %x\n", type);
		mutex_unlock(&g_hw_manage.lock);
		return -1;
	}

	// pr_info("gHwManage.wp[%d].info = %lx\n", i, gHwManage.wp[i].info);
	// pr_info("info = %lx,attr=%lx,state=%lx\n", bpInfo[i].info, &bpInfo[i].attr, &state);
	ret = hw_bp_register(bp_info[i].info, &bp_info[i].attr, &state);
	if (ret) {
		goto clear;
	}
	/*Several CPUs are registered with the breakpoint*/
	bp_info[i].mask = state;
	memset(bp_info[i].symbol_name, 0, sizeof(bp_info[i].symbol_name));
	sprint_symbol(bp_info[i].symbol_name, addr);
	mutex_unlock(&g_hw_manage.lock);
	hw_bp_show_one(&bp_info[i], i);
	return 0;
clear:
	pr_info("hw_bp_install_from_addr [%llx] error\n", addr);
	/*clear bp info*/
	memset(&bp_info[i].attr, 0, sizeof(bp_info[i].attr));
	memset(bp_info[i].symbol_name, 0, sizeof(bp_info[i].symbol_name));
	bp_info[i].mask = 0;
	mutex_unlock(&g_hw_manage.lock);
	return -1;
}
EXPORT_SYMBOL_GPL(hw_bp_install_from_addr);

/*从符号设置一个断点*/
int hw_bp_install_from_symbol(char *name, int len, int type,
			      hw_bp_callback handler)
{
	int ret = 0;
	u64 addr = 0;

	if ((NULL == name) || (HW_BREAKPOINT_INVALID == type)) {
		pr_info("HW_breakpointInstallFromSymbol para is error\n");
		return -1;
	}

	addr = HW_SYMS_FUNC(kallsyms_lookup_name)(name);
	if (0 == addr) {
		/*the symbol is invalid*/
		pr_info("Can not find the symbol, name: %s\n", name);
		return -1;
	}

	ret = hw_bp_install_from_addr(addr, len, type, handler);
	if (ret) {
		pr_info("HW_breakpointInstallFromSymbol error [%s]\n", name);
		return -1;
	}

	return 0;
}
EXPORT_SYMBOL_GPL(hw_bp_install_from_symbol);

void hw_bp_uninstall_from_addr(u64 addr)
{
	int i = 0;
	struct hw_bp_manage_info *bp_info = NULL;

	/*traverse bp arrays*/
	/*find bp*/
	mutex_lock(&g_hw_manage.lock);
	for (i = 0; i < g_hw_manage.max_bp_num; i++) {
		if (g_hw_manage.bp[i].mask & g_hw_manage.cpu_mask) {
			if (g_hw_manage.bp[i].attr.addr == addr) {
				bp_info = &g_hw_manage.bp[i];
				pr_info("[uninstall] find addr: bp[%d]\n", i);
				break;
			}
		}
	}
	/*find wp*/
	for (i = 0; (i < g_hw_manage.max_wp_num) && (bp_info == NULL); i++) {
		if (g_hw_manage.wp[i].mask & g_hw_manage.cpu_mask) {
			if (g_hw_manage.wp[i].attr.addr == addr) {
				bp_info = &g_hw_manage.wp[i];
				pr_info("[uninstall] find addr: wp[%d]\n", i);
				break;
			}
		}
	}
	if (NULL == bp_info) {
		pr_info("HW_breakpointUnInstallFromAddr fail,can not find addr:0x%llx\n",
			addr);
		mutex_unlock(&g_hw_manage.lock);
		return;
	}
	hw_bp_unregister(bp_info->info, bp_info->mask);
	/*clear bp info*/
	memset(bp_info->symbol_name, 0, sizeof(bp_info->symbol_name));
	memset(&bp_info->attr, 0, sizeof(bp_info->attr));
	bp_info->mask = 0;
	mutex_unlock(&g_hw_manage.lock);
}
EXPORT_SYMBOL_GPL(hw_bp_uninstall_from_addr);

void hw_bp_uninstall_from_symbol(char *name)
{
	u64 addr = 0;

	if (NULL == name) {
		pr_info("HW_breakpointUnInstallFromSymbol para is error\n");
		return;
	}

	addr = HW_SYMS_FUNC(kallsyms_lookup_name)(name);
	if (0 == addr) {
		/*the symbol is invalid*/
		pr_info("[uninstall] Can not find the symbol, name: %s\n",
			name);
		return;
	}
	hw_bp_uninstall_from_addr(addr);
}
EXPORT_SYMBOL_GPL(hw_bp_uninstall_from_symbol);

void hw_free_bp_infos(hw_bp_info_list *info)
{
	hw_bp_info_list *node = NULL, *next = NULL;

	if (info) {
		list_for_each_entry_safe(node, next, &info->list, list) {
			list_del(&node->list);
			if (node->attr) {
				kfree(node->attr);
			}
			kfree(node);
		}
		if (info->attr) {
			kfree(info->attr);
		}
		kfree(info);
	}
}
EXPORT_SYMBOL_GPL(hw_free_bp_infos);

static void hw_fill_report_data(struct hw_bp_manage_info *bp_info,
				hw_bp_info_list *node)
{
	struct hw_bp_info *bp = NULL;
	int cpu = 0;

#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
	cpus_read_lock();
#else
	get_online_cpus();
#endif
	for_each_possible_cpu(cpu) {
		if (bp_info->mask & 1 << cpu) {
			bp = per_cpu(*bp_info->info, cpu);
			/*value*/
			node->attr[cpu].type = bp->attr.type;
			node->attr[cpu].addr = bp->attr.addr;
			node->attr[cpu].len = bp->attr.len;
			node->attr[cpu].mask = bp->attr.mask;
			node->attr[cpu].times = bp->attr.times;
		}
	}
#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
	cpus_read_unlock();
#else
	put_online_cpus();
#endif
}

hw_bp_info_list *hw_get_bp_infos(void)
{
	hw_bp_info_list *head = NULL;
	hw_bp_info_list *node = NULL;
	struct hw_bp_manage_info *bp_info = NULL;
	int i = 0;

	mutex_lock(&g_hw_manage.lock);
	for (i = 0; i < g_hw_manage.max_bp_num; i++) {
		bp_info = &g_hw_manage.bp[i];
		if (bp_info->mask & g_hw_manage.cpu_mask) {
			/*bp is set*/
			if (head == NULL) {
				head = kzalloc(sizeof(hw_bp_info_list),
					       GFP_KERNEL);
				if (head == NULL) {
					goto err;
				}
				INIT_LIST_HEAD(&head->list);
				head->attr =
					kzalloc(sizeof(hw_bp_report) *
							g_hw_manage.cpu_num,
						GFP_KERNEL);
				if (head->attr == NULL) {
					goto err;
				}
				head->cpu_mask = bp_info->mask;
				head->cpu_num = g_hw_manage.cpu_num;
				hw_fill_report_data(bp_info, head);
			}
			node = kzalloc(sizeof(hw_bp_info_list), GFP_KERNEL);
			if (node == NULL) {
				goto err;
			}
			INIT_LIST_HEAD(&node->list);
			list_add_tail(&node->list, &head->list);
			node->attr = kzalloc(sizeof(hw_bp_report) *
						     g_hw_manage.cpu_num,
					     GFP_KERNEL);
			if (node->attr == NULL) {
				goto err;
			}
			node->cpu_mask = bp_info->mask;
			node->cpu_num = g_hw_manage.cpu_num;
			hw_fill_report_data(bp_info, node);
		}
	}

	for (i = 0; i < g_hw_manage.max_wp_num; i++) {
		bp_info = &g_hw_manage.wp[i];
		if (bp_info->mask & g_hw_manage.cpu_mask) {
			/*bp is set*/
			if (head == NULL) {
				head = kzalloc(sizeof(hw_bp_info_list),
					       GFP_KERNEL);
				if (head == NULL) {
					goto err;
				}
				INIT_LIST_HEAD(&head->list);
				head->attr =
					kzalloc(sizeof(hw_bp_report) *
							g_hw_manage.cpu_num,
						GFP_KERNEL);
				if (head->attr == NULL) {
					goto err;
				}
				head->cpu_mask = bp_info->mask;
				head->cpu_num = g_hw_manage.cpu_num;
				hw_fill_report_data(bp_info, head);
			}
			node = kzalloc(sizeof(hw_bp_info_list), GFP_KERNEL);
			if (node == NULL) {
				goto err;
			}
			INIT_LIST_HEAD(&node->list);
			list_add_tail(&node->list, &head->list);
			node->attr = kzalloc(sizeof(hw_bp_report) *
						     g_hw_manage.cpu_num,
					     GFP_KERNEL);
			if (node->attr == NULL) {
				goto err;
			}
			node->cpu_mask = bp_info->mask;
			node->cpu_num = g_hw_manage.cpu_num;
			hw_fill_report_data(bp_info, node);
		}
	}
	mutex_unlock(&g_hw_manage.lock);

	return head;

err:
	mutex_unlock(&g_hw_manage.lock);
	hw_free_bp_infos(head);
	return NULL;
}
EXPORT_SYMBOL_GPL(hw_get_bp_infos);

/*release bp*/
void hw_bp_manage_deinit(void)
{
	int i = 0;

	hw_bp_uninstall_all();

	for (i = 0; i < g_hw_manage.max_wp_num; i++) {
		free_percpu(g_hw_manage.wp[i].info);
	}

	for (i = 0; i < g_hw_manage.max_bp_num; i++) {
		free_percpu(g_hw_manage.bp[i].info);
	}
	mutex_destroy(&g_hw_manage.lock);
}

/*bp arch init*/
int hw_bp_manage_init(void)
{
	int cpu = -1, i = 0;
	struct hw_bp_info *__percpu *bp = NULL;

	/*get bp&wp num*/
	g_hw_manage.max_bp_num = hw_get_bp_num(TYPE_INST);
	g_hw_manage.max_wp_num = hw_get_bp_num(TYPE_DATA);

	/*get CPU num*/
	g_hw_manage.cpu_num = 0;
	for_each_online_cpu(cpu) {
		g_hw_manage.cpu_mask |= 1 << cpu;
		g_hw_manage.cpu_num++;
	}
	pr_info("CPU MASK =  %x\n", g_hw_manage.cpu_mask);

	/*mange mem of bp*/
	for (i = 0; i < g_hw_manage.max_wp_num; i++) {
		bp = alloc_percpu(typeof(*bp));
		if (!bp) {
			pr_info("wp alloc_percpu fail\n");
			goto free;
		}
		g_hw_manage.wp[i].info = bp;
		bp = NULL;
	}
	for (i = 0; i < g_hw_manage.max_bp_num; i++) {
		bp = alloc_percpu(typeof(*bp));
		if (!bp) {
			pr_info("wp alloc_percpu fail\n");
			goto free;
		}
		g_hw_manage.bp[i].info = bp;
		bp = NULL;
	}

	mutex_init(&g_hw_manage.lock);

	return 0;

free:
	hw_bp_manage_deinit();
	return -1;
}

```

`hw_breakpoint_proc.c`:

```c
#include <linux/errno.h>
#include <linux/version.h>
#include <linux/delay.h>
#include <linux/mii.h>
#include <linux/mdio.h>
#include <linux/proc_fs.h>
#include <linux/spinlock.h>
#include "linux/printk.h"
#include <linux/random.h>
#include "ext_hw_breakpoint.h"
#include "hw_breakpoint_until.h"

#define PROC_FILE_DEBUG "breakpoint"

/*func extern*/
extern void hw_bp_show_all(void);

/*proc_file handle*/
static struct proc_dir_entry *proc_file = NULL;

/*help*/
char *hw_proc_write_usag = {
	"Usage:\n"
	"\thw_break support cmd type: \n"
	"\t\t1: echo add <type> <len> <symbol>/<addr> > /proc/breakpoint, add a breakpoint\n"
	"\t\t\t[type]:\n"
	"\t\t\t\t[wp1]: HW_BREAKPOINT_R\n"
	"\t\t\t\t[wp2]: HW_BREAKPOINT_W\n"
	"\t\t\t\t[wp3]: HW_BREAKPOINT_R|HW_BREAKPOINT_W\n"
	"\t\t\t\t[bp]:  HW_BREAKPOINT_X\n"
	"\t\t\t[len]:[0,8] (2^3,2^31]\n"
	"\t\t2: echo del <symbol> > /proc/breakpoint, del a breakpoint\n"
	"\t\t3: echo get ptr/val <symbol> > /proc/breakpoint, search &symbol/*(&symbol)\n"
	"\t\t4: echo iophy <ioaddr> > /proc/breakpoint, search all of ioaddr map virt\n"
};
/*example*/
char *hw_proc_write_example = {
	"Example:\n"
	"\tThe first step:\n"
	"\t\techo add wp3 4 hw_test_value0 > /proc/breakpoint, add a watchpoint at "
	"&hw_test_value0\n"
	"\tThe second step:\n"
	"\t\techo write 0 0 > /proc/breakpoint, write hw_test_value0\n"
	"\tThe third step:\n"
	"\t\techo read 0 0 > /proc/breakpoint, read hw_test_value0\n"
	"\tThe forth step:\n"
	"\t\techo del hw_test_value0 > /proc/breakpoint, del wawtchpoint at "
	"&hw_test_value0\n"
};

/*seq show*/
static int hw_proc_show(struct seq_file *m, void *v)
{
	hw_bp_info_list *info = NULL, *node = NULL;
	int i = 0, index = 0;

	/*get info*/
	info = hw_get_bp_infos();
	if (info) {
		list_for_each_entry(node, &info->list, list) {
			for (i = 0; i < node->cpu_num; i++) {
				if (node->cpu_mask & (1 << i)) {
					break;
				}
			}
			seq_printf(m, "----------------[%d]----------------\n",
				   index++);
			seq_printf(m, "type: \t0x%x\n", node->attr[i].type);
			seq_printf(m, "addr: \t0x%llx\n", node->attr[i].addr);
			seq_printf(m, "len: \t0x%llx\n", node->attr[i].len);
			seq_printf(m, "mask: \t0x%x\n", node->attr[i].mask);
			for (i = 0; i < node->cpu_num; i++) {
				if (!(node->cpu_mask & (1 << i))) {
					continue;
				}
				seq_printf(m, "cpu[%d] trigger times:\n", i);
				seq_printf(
					m,
					"\tread: %llu, write: %llu, exec: %llu\n",
					node->attr[i].times.read,
					node->attr[i].times.write,
					node->attr[i].times.exec);
			}
		}
		hw_free_bp_infos(info);
	}
	return 0;
}

static int hw_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, hw_proc_show, inode->i_private);
}

u32 hw_test_value3[32] = { 0 };
u32 hw_test_value2[32] = { 0 };
u32 hw_test_value1[32] = { 0 };
u32 hw_test_value0[32] = { 0 };

/*show vm info*/
static void hw_show_vm(struct vm_struct *area, u64 phy_addr)
{
	pr_info("--------------------------------------------------\n");
	if (area->phys_addr) {
		pr_info("\tphy addr:\t0x%llx\n", area->phys_addr);
	}
	if (area->addr) {
		pr_info("\tvirt addr:\t0x%llx\n", (u64)area->addr);
	}
	if (area->size) {
		pr_info("\tsize:\t\t0x%lx\n", area->size);
	}
	if (area->addr && area->phys_addr) {
		pr_info("0x%llx to virt: 0x%llx\n", phy_addr,
			(u64)area->addr + phy_addr - area->phys_addr);
	}
	pr_info("\n");
}

/*proc get virt of iophys*/
static void hw_iophy_to_virt(char *addr_buf)
{
	u64 io_addr = 0;
	iophys_info *iophys = NULL, *node = NULL;

	io_addr = simple_strtol(addr_buf, NULL, 0);
	iophys = get_iophys_info(io_addr);

	if (iophys) {
		list_for_each_entry(node, &iophys->list, list) {
			hw_show_vm(&node->area, io_addr);
		}
	}
	free_iophys_info(iophys);
}

/*proc get handler*/
static int hw_proc_get(char *type_buf, char *name_buf)
{
	u64 addr = 0;

	/*get symbol addr*/
	addr = HW_SYMS_FUNC(kallsyms_lookup_name)(name_buf);
	if (!addr || addr < TASK_SIZE) {
		pr_info("can not find symbol %s\n", name_buf);
		return -1;
	}
	if (strcmp("ptr", type_buf) == 0) {
		pr_info("&%s = 0x%llx\n", name_buf, addr);
	} else if (strcmp("val", type_buf) == 0) {
		pr_info("*(%s) = 0x%llx\n", name_buf, *((u64 *)addr));
	} else {
		return -1;
	}
	return 0;
}

/*proc del bp*/
static void hw_proc_del(char *name_buf)
{
	u64 uninstall_addr = 0;

	if (name_buf[0] == '0' && name_buf[1] == 'x') {
		uninstall_addr = simple_strtol(name_buf, 0, 0);
	}
	if (uninstall_addr) {
		pr_info("will uninstall at 0x%llx\n", uninstall_addr);
		hw_bp_uninstall_from_addr(uninstall_addr);
	} else {
		pr_info("will uninstall at &%s\n", name_buf);
		hw_bp_uninstall_from_symbol(name_buf);
	}
}

/*proc add bp*/
static int hw_proc_add(char *type_buf, char *len_buf, char *name_buf)
{
	char *name = NULL;
	int len = HW_BREAKPOINT_LEN_4, type = 0;
	u64 install_addr = 0;

	/*check bp type*/
	switch (strlen(type_buf)) {
	/*The length is 2 for the bp*/
	case 2: {
		type = HW_BREAKPOINT_X;
		name = name_buf;
		break;
	}
	/*The length is 3 for the wp, and the third character is the breakpoint type*/
	case 3: {
		type = type_buf[2] - '0';
		len = (int)simple_strtoul(len_buf, NULL, 0);
		name = name_buf;
		break;
	}
	default: {
		return -1;
	}
	}
	/*check type if valid*/
	if (type < 1 || type > 4) {
		return -1;
	}

	if (name_buf[0] == '0' && name_buf[1] == 'x') {
		install_addr = simple_strtol(name_buf, 0, 0);
	}
	if (install_addr) {
		pr_info("will install at 0x%llx\n", install_addr);
		hw_bp_install_from_addr(install_addr, len, type, NULL);
	} else {
		pr_info("will install at &%s\n", name);
		hw_bp_install_from_symbol(name, len, type, NULL);
	}
	return 0;
}

/*test write*/
static void hw_proc_rw_test(char *cmd, char *index_of_buf, char *index_in_buf)
{
	int index = (int)simple_strtol(index_of_buf, NULL, 0);
	int index1 = (int)simple_strtol(index_in_buf, NULL, 0);
	u32 *tmpbuf;
	switch (index) {
	case 0: {
		tmpbuf = hw_test_value0;
		break;
	}
	case 1: {
		tmpbuf = hw_test_value1;
		break;
	}
	case 2: {
		tmpbuf = hw_test_value2;
		break;
	}
	case 3:
	default: {
		tmpbuf = hw_test_value3;
		break;
	}
	}
	if (strcmp("write", cmd) == 0) {
		pr_info("will write hw_test_value%d[%d], addr = %llx\n", index,
			index1, (u64)&tmpbuf[index1]);
		tmpbuf[index1] = get_random_u32();
	} else if (strcmp("read", cmd) == 0) {
		pr_info("will read hw_test_value%d[%d], addr = %llx\n", index,
			index1, (u64)&tmpbuf[index1]);
		pr_info("hw_test_value%d[%d] = %d\n", index, index1,
			tmpbuf[index1]);
	}
}

static ssize_t hw_proc_write(struct file *file, const char __user *p_buf,
			     size_t count, loff_t *pPos)
{
	size_t ret;
	char cmd_buf[128] = { 0 };
	int argc = 0;
	char *argv[10] = { NULL };

	// pr_info("hw_proc_write\n");

	if ((count > sizeof(cmd_buf)) || (count == 0)) {
		pr_info("test proc write, count is error!\n");
		return (ssize_t)count;
	}

	memset(cmd_buf, 0, sizeof(cmd_buf));
	ret = copy_from_user(cmd_buf, p_buf, count);
	if (0 != ret) {
		pr_info("fail to copy data from user!\n");
		return (ssize_t)count;
	}

	cmd_buf[count - 1] = '\0';
	memset(argv, 0, sizeof(argv));
	process_cmd_string(cmd_buf, &argc, argv);

	if (strcmp("write", argv[0]) == 0 || strcmp("read", argv[0]) == 0) {
		if (argc != 3) {
			goto cmdErr;
		}
		hw_proc_rw_test(argv[0], argv[1], argv[2]);
		return (ssize_t)count;
	} else if (strcmp("show", argv[0]) == 0) {
		hw_bp_show_all();
		return (ssize_t)count;
	} else if (strcmp("help", argv[0]) == 0) {
		pr_info("%s", hw_proc_write_usag);
		pr_info("%s", hw_proc_write_example);
		return (ssize_t)count;
	}

	if (strcmp("add", argv[0]) == 0) {
		if (argc != 4) {
			// pr_info("argc = %d\n",argc);
			goto cmdErr;
		}
		if (hw_proc_add(argv[1], argv[2], argv[3])) {
			goto cmdErr;
		}
	} else if (strcmp("del", argv[0]) == 0) {
		if (argc != 2) {
			// pr_info("argc = %d\n",argc);
			goto cmdErr;
		}
		hw_proc_del(argv[1]);
	} else if (strcmp("get", argv[0]) == 0) {
		if (argc != 3) {
			// pr_info("argc = %d\n",argc);
			goto cmdErr;
		}
		if (hw_proc_get(argv[1], argv[2])) {
			goto cmdErr;
		}
	} else if (strcmp("iophy", argv[0]) == 0) {
		if (argc != 2) {
			// pr_info("argc = %d\n",argc);
			goto cmdErr;
		}
		hw_iophy_to_virt(argv[1]);
	} else {
		goto cmdErr;
	}

	return (ssize_t)count;
cmdErr:
	pr_info("cmd error, echo help > /proc/breakpoint\n");
	return (ssize_t)count;
}

#if LINUX_VERSION_CODE > KERNEL_VERSION(5, 1, 10)
static const struct proc_ops hw_proc_fops = {
	.proc_open = hw_proc_open,
	.proc_write = hw_proc_write,
	.proc_read = seq_read,
	.proc_lseek = seq_lseek,
	.proc_release = single_release,
};
#else
static const struct file_operations hw_proc_fops = {
	.proc_open = hw_proc_open,
	.proc_write = hw_proc_write,
	.proc_read = seq_read,
	.proc_lseek = seq_lseek,
	.proc_release = single_release,
};
#endif

int hw_proc_init(void)
{
	proc_file = proc_create(PROC_FILE_DEBUG, S_IRUGO | S_IWUGO, NULL,
				&hw_proc_fops);
	if (NULL == proc_file) {
		pr_info("hw proc init, Create %s proc file failed!\n",
			PROC_FILE_DEBUG);
		return -ENOMEM;
	}
	// pr_info(hw_proc_write_usag);
	// pr_info(hw_proc_write_example);
	return 0;
}

void hw_proc_exit(void)
{
	if (NULL != proc_file) {
		remove_proc_entry(PROC_FILE_DEBUG, NULL);
	}
}

```

`hw_breakpoint_smp.c`:

```c
#include <linux/slab.h>
#include <linux/capability.h>
#include <linux/cpu.h>
#include <linux/version.h>
#include "ext_hw_breakpoint.h"

typedef int (*hw_remote_func_f)(void *);

/*func extern*/
extern int hw_bp_arch_parse(struct hw_bp_info *bp, const hw_bp_attr *attr,
			    hw_bp_vc *hw);
extern int hw_bp_install(struct hw_bp_info *bp);
extern int hw_bp_uninstall(struct hw_bp_info *bp);
extern int hw_arch_check_bp_in_kspace(hw_bp_vc *hw);

struct hw_remote_func_call {
	struct hw_bp_info *p;
	hw_remote_func_f func;
	void *info;
	int ret;
};

static void hw_remote_func(void *data)
{
	struct hw_remote_func_call *tfc = data;

	/*callback*/
	tfc->ret = tfc->func(tfc->info);
}

static int hw_cpu_func_call(int cpu, hw_remote_func_f func, void *info)
{
	struct hw_remote_func_call data = {
		.p = NULL,
		.func = func,
		.info = info,
		.ret = -ENXIO, /* No such CPU */
	};

	preempt_disable();
	if (cpu != smp_processor_id()) {
		smp_call_function_single(cpu, hw_remote_func, &data, 1);
		goto out;
	}

	data.ret = func(info);

out:
	preempt_enable();
	return data.ret;
}

static int hw_bp_parse(struct hw_bp_info *bp, const hw_bp_attr *attr,
		       hw_bp_vc *hw)
{
	int err;

	err = hw_bp_arch_parse(bp, attr, hw);
	if (err)
		return err;

	if (hw_arch_check_bp_in_kspace(hw)) {
		/*Don't let unprivileged users set a breakpoint in the trappath to avoid trap recursion attacks.*/
		if (!capable(CAP_SYS_ADMIN))
			return -EPERM;
	}

	return 0;
}

static int hw_bp_info_del(void *p)
{
	struct hw_bp_info *bp = (struct hw_bp_info *)p;
	return hw_bp_uninstall(bp);
}

static int hw_bp_info_add(void *p)
{
	struct hw_bp_info *bp = (struct hw_bp_info *)p;
	return hw_bp_install(bp);
}

static int hw_bp_info_init(struct hw_bp_info *bp)
{
	int err;
	hw_bp_vc hw = {};

	/*parse*/
	err = hw_bp_parse(bp, &bp->attr, &hw);
	if (err)
		return err;

	bp->info = hw;

	return 0;
}

static struct hw_bp_info *hw_bp_info_alloc(const hw_bp_attr *attr, int cpu)
{
	struct hw_bp_info *bp = NULL;
	int err;

	bp = kzalloc(sizeof(*bp), GFP_KERNEL);
	if (!bp) {
		pr_info("bp alloc fail\n");
		return ERR_PTR(-ENOMEM);
	}

	bp->cpu = cpu;
	bp->attr = *attr;

	/*bp info init*/
	err = hw_bp_info_init(bp);
	if (err) {
		pr_info("hw_bp_info_init fail\n");
		return ERR_PTR(err);
	}
	/*smp_call_function_single in kgdb is error?*/
	err = hw_cpu_func_call(cpu, hw_bp_info_add, bp);
	if (err) {
		pr_info("hw_bp_info_add fail\n");
		return ERR_PTR(err);
	}

	return bp;
}

static void hw_bp_info_free(struct hw_bp_info *bp, int cpu)
{
	hw_cpu_func_call(cpu, hw_bp_info_del, bp);
	kfree(bp);
}

void hw_bp_unregister(struct hw_bp_info *__percpu *bp, int state)
{
	int cpu;

	if (bp == NULL) {
		return;
	}

#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
	cpus_read_lock();
#else
	get_online_cpus();
#endif
	for_each_possible_cpu(cpu) {
		if (state & 1 << cpu) {
			hw_bp_info_free(per_cpu(*bp, cpu), cpu);
		}
	}
#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
	cpus_read_unlock();
#else
	put_online_cpus();
#endif
}

int hw_bp_register(struct hw_bp_info *__percpu *cpu_events, hw_bp_attr *attr,
		   int *state)
{
	struct hw_bp_info *bp;
	int cpu;

	if (cpu_events == NULL || attr == NULL || state == NULL) {
		pr_info("hw_bp_register para is NULL\n");
		return -1;
	}

	*state = 0;
#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
	cpus_read_lock();
#else
	get_online_cpus();
#endif
	for_each_online_cpu(cpu) {
		bp = hw_bp_info_alloc(attr, cpu);
		if (IS_ERR(bp)) {
			pr_info("hw_bp_info_alloc error at CPU[%d]\n", cpu);
		}
		/*cpu success mask*/
		*state |= 1 << cpu;
		/*percpu bp*/
		per_cpu(*cpu_events, cpu) = bp;
	}
#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
	cpus_read_unlock();
#else
	put_online_cpus();
#endif

	return 0;
}

```

`hw_breakpoint_until.c`:

```c
#include <linux/version.h>
#include "ext_hw_breakpoint.h"
#include "hw_breakpoint_until.h"

#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 10, 72)
#define VM_LAZY_FREE 0x02
#define VM_VM_AREA 0x04
#endif

#ifdef HW_PROC_CMD_DEBUG
static void print_cmd_params(int argc, char *argv[])
{
	int loop = 0;

	for (loop = 0; loop < argc; loop++) {
		pr_info("loop:%d, %s\n", loop, argv[loop]);
	}
}
#endif

void process_cmd_string(char *p_buf, int *p_argc, char *p_argv[])
{
	int i_argc;
	char *p_tmp = p_buf;

	p_argv[0] = p_buf;
	i_argc = 1;

	while (*p_tmp) {
		if (' ' == *p_tmp) {
			*p_tmp = '\0';
			p_argv[i_argc++] = p_tmp + 1;
		}

		p_tmp++;
	}
	*p_argc = i_argc;
#ifdef HW_PROC_CMD_DEBUG
	print_cmd_params(*pArgc, pArgv);
#endif
}

void free_iophys_info(iophys_info *info)
{
	iophys_info *node = NULL, *next = NULL;

	if (info) {
		list_for_each_entry_safe (node, next, &info->list, list) {
			list_del(&node->list);
			kfree(node);
		}
		kfree(info);
	}
}
EXPORT_SYMBOL_GPL(free_iophys_info);

iophys_info *get_iophys_info(u64 addr)
{
	struct vmap_area *va = NULL;
	struct vm_struct *area = NULL;
	struct vm_struct *next = NULL;
	iophys_info *head = NULL;
	iophys_info *node = NULL;

	if (!HW_SYMS_VAL(vmap_area_lock) || !HW_SYMS_VAL(vmap_area_lock)) {
		pr_info("vmap_area_list or vmap_area_lock is NULL, can not get virt");
		return head;
	}

	spin_lock(HW_SYMS_VAL(vmap_area_lock));
	list_for_each_entry (va, HW_SYMS_VAL(vmap_area_list), list) {
#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 10, 72)
		if (!(va->flags & VM_VM_AREA)) {
			continue;
		}
#endif
		if (!va) {
			continue;
		}
		area = va->vm;
		if (!area) {
			continue;
		}
		if (!(area->flags & VM_IOREMAP) ||
		    area->flags & VM_UNINITIALIZED) {
			continue;
		}
		smp_rmb();
		/*If you find the I/O address, check whether the I/O address you want to query is within the I/O address range*/
		next = area;
		while (next) {
			if (next->phys_addr && next->size) {
				/*The IO address to be queried is within its range*/
				if (addr >= next->phys_addr &&
				    addr < next->phys_addr + next->size) {
					/*find it*/
					if (head == NULL) {
						head = kzalloc(
							sizeof(iophys_info),
							GFP_KERNEL);
						if (head == NULL) {
							goto err;
						}
						INIT_LIST_HEAD(&head->list);
						head->area = *next;
						head->virt_addr =
							(u64)next->addr + addr -
							next->phys_addr;
					}
					node = kzalloc(sizeof(iophys_info),
						       GFP_KERNEL);
					if (node == NULL) {
						goto free;
					}
					INIT_LIST_HEAD(&node->list);
					node->area = *next;
					node->virt_addr = (u64)next->addr +
							  addr -
							  next->phys_addr;
					list_add_tail(&node->list, &head->list);
				}
			}
			next = next->next;
			if (next == area) {
				break;
			}
		}
	}
	spin_unlock(HW_SYMS_VAL(vmap_area_lock));

	return head;

free:
	free_iophys_info(head);
err:
	spin_unlock(HW_SYMS_VAL(vmap_area_lock));
	return NULL;
}
EXPORT_SYMBOL_GPL(get_iophys_info);

```

`hw_breakpoint_until.h`:

```h
#ifndef __HW_BREAKPOINT_UNTIL_H
#define __HW_BREAKPOINT_UNTIL_H

#include <linux/vmalloc.h>

typedef struct iophys_info {
	struct list_head list;
	struct vm_struct area;
	u64 virt_addr;
} iophys_info;

void process_cmd_string(char *pBuf, int *pArgc, char *pArgv[]);
/*iophy to virt func*/
iophys_info *get_iophys_info(u64 addr);
void free_iophys_info(iophys_info *info);

#endif

```

`make.sh`:

```sh
#!/bin/sh
###
 # @Author: zwf 240970521@qq.com
 # @Date: 2023-08-25 21:21:01
 # @LastEditors: zwf 240970521@qq.com
 # @LastEditTime: 2023-08-25 21:27:58
 # @FilePath: /hardware-breakpoint/make.sh
 # @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
### 
KERNEL_DIR=/home/zwf/x3_src/kernel
hotbot_key=$KERNEL_DIR/certs/hobot_fixed_signing_key.pem
sign_key=$KERNEL_DIR/certs/signing_key.x509
sign_tools=$KERNEL_DIR/scripts/sign-file

rm -rf .vscode/compile_commands.json
make clean
bear make
mv compile_commands.json .vscode/compile_commands.json

#给驱动加签名
$sign_tools sha512 $hotbot_key $sign_key ./hw_break.ko

#copy到nfs目录
cp ./hw_break.ko ~/x3sdb/nfs/

```