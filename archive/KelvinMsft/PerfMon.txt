Project Path: arc_KelvinMsft_PerfMon_ljqx07p5

Source Tree:

```txt
arc_KelvinMsft_PerfMon_ljqx07p5
├── Debug
│   └── TestBp.exe
├── PerfMon
│   ├── Apic.h
│   ├── Common.cpp
│   ├── Common.h
│   ├── Driver.cpp
│   ├── Log.h
│   ├── PMI.cpp
│   ├── PMI.h
│   ├── PMU.cpp
│   ├── PMU.h
│   ├── PerfMon.inf
│   ├── PerfMon.vcxproj
│   ├── PerfMon.vcxproj.filters
│   ├── PerfMon.vcxproj.user
│   ├── SSDT.cpp
│   ├── SSDT.h
│   ├── Util.cpp
│   ├── Util.h
│   ├── x64
│   │   └── Debug
│   │       └── PerfMon.inf
│   └── x86.h
├── PerfMon.sln
├── README.md
├── TestBp
│   ├── Source.cpp
│   ├── TestBp.vcxproj
│   ├── TestBp.vcxproj.filters
│   ├── stdafx.cpp
│   ├── stdafx.h
│   └── targetver.h
├── doc
│   ├── 30320-Nehalem-PMU-Programming-Guide-Core.pdf
│   ├── 325462-sdm-vol-1-2abcd-3abcd.pdf
│   ├── CPUID.pdf
│   └── woot16-paper-spisak.pdf
└── x64
    └── Debug
        ├── TestBp.ilk
        └── TestBp.pdb

```

`PerfMon.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 14
VisualStudioVersion = 14.0.25420.1
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "PerfMon", "PerfMon\PerfMon.vcxproj", "{F01C4412-F73C-4BD8-A954-84E2F3BD1251}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "TestBp", "TestBp\TestBp.vcxproj", "{B4C142C1-5D8A-4C9A-8891-D8730C363B3A}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "TestBp3", "TestBp3\TestBp3.vcxproj", "{85004320-1B32-44D6-946C-83AC22369C89}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug_WDK|ARM = Debug_WDK|ARM
		Debug_WDK|ARM64 = Debug_WDK|ARM64
		Debug_WDK|x64 = Debug_WDK|x64
		Debug_WDK|x86 = Debug_WDK|x86
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release_WDK|ARM = Release_WDK|ARM
		Release_WDK|ARM64 = Release_WDK|ARM64
		Release_WDK|x64 = Release_WDK|x64
		Release_WDK|x86 = Release_WDK|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Debug_WDK|ARM.ActiveCfg = Debug|ARM
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Debug_WDK|ARM.Build.0 = Debug|ARM
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Debug_WDK|ARM.Deploy.0 = Debug|ARM
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Debug_WDK|ARM64.ActiveCfg = Debug|ARM64
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Debug_WDK|ARM64.Build.0 = Debug|ARM64
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Debug_WDK|ARM64.Deploy.0 = Debug|ARM64
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Debug_WDK|x64.ActiveCfg = Debug|x64
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Debug_WDK|x64.Build.0 = Debug|x64
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Debug_WDK|x64.Deploy.0 = Debug|x64
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Debug_WDK|x86.ActiveCfg = Debug|Win32
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Debug_WDK|x86.Build.0 = Debug|Win32
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Debug_WDK|x86.Deploy.0 = Debug|Win32
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Debug|ARM.ActiveCfg = Debug|ARM
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Debug|ARM.Build.0 = Debug|ARM
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Debug|ARM.Deploy.0 = Debug|ARM
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Debug|ARM64.Build.0 = Debug|ARM64
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Debug|x64.ActiveCfg = Debug|x64
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Debug|x64.Build.0 = Debug|x64
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Debug|x64.Deploy.0 = Debug|x64
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Debug|x86.ActiveCfg = Debug|Win32
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Debug|x86.Build.0 = Debug|Win32
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Debug|x86.Deploy.0 = Debug|Win32
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Release_WDK|ARM.ActiveCfg = Release|ARM
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Release_WDK|ARM.Build.0 = Release|ARM
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Release_WDK|ARM.Deploy.0 = Release|ARM
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Release_WDK|ARM64.ActiveCfg = Release|ARM64
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Release_WDK|ARM64.Build.0 = Release|ARM64
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Release_WDK|ARM64.Deploy.0 = Release|ARM64
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Release_WDK|x64.ActiveCfg = Release|x64
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Release_WDK|x64.Build.0 = Release|x64
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Release_WDK|x64.Deploy.0 = Release|x64
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Release_WDK|x86.ActiveCfg = Release|Win32
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Release_WDK|x86.Build.0 = Release|Win32
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Release_WDK|x86.Deploy.0 = Release|Win32
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Release|ARM.ActiveCfg = Release|ARM
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Release|ARM.Build.0 = Release|ARM
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Release|ARM.Deploy.0 = Release|ARM
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Release|ARM64.ActiveCfg = Release|ARM64
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Release|ARM64.Build.0 = Release|ARM64
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Release|ARM64.Deploy.0 = Release|ARM64
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Release|x64.ActiveCfg = Release|x64
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Release|x64.Build.0 = Release|x64
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Release|x64.Deploy.0 = Release|x64
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Release|x86.ActiveCfg = Release|Win32
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Release|x86.Build.0 = Release|Win32
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Release|x86.Deploy.0 = Release|Win32
		{B4C142C1-5D8A-4C9A-8891-D8730C363B3A}.Debug_WDK|ARM.ActiveCfg = Release|x64
		{B4C142C1-5D8A-4C9A-8891-D8730C363B3A}.Debug_WDK|ARM.Build.0 = Release|x64
		{B4C142C1-5D8A-4C9A-8891-D8730C363B3A}.Debug_WDK|ARM64.ActiveCfg = Release|x64
		{B4C142C1-5D8A-4C9A-8891-D8730C363B3A}.Debug_WDK|ARM64.Build.0 = Release|x64
		{B4C142C1-5D8A-4C9A-8891-D8730C363B3A}.Debug_WDK|x64.ActiveCfg = Debug|x64
		{B4C142C1-5D8A-4C9A-8891-D8730C363B3A}.Debug_WDK|x64.Build.0 = Debug|x64
		{B4C142C1-5D8A-4C9A-8891-D8730C363B3A}.Debug_WDK|x86.ActiveCfg = Debug|Win32
		{B4C142C1-5D8A-4C9A-8891-D8730C363B3A}.Debug_WDK|x86.Build.0 = Debug|Win32
		{B4C142C1-5D8A-4C9A-8891-D8730C363B3A}.Debug|ARM.ActiveCfg = Debug|Win32
		{B4C142C1-5D8A-4C9A-8891-D8730C363B3A}.Debug|ARM64.ActiveCfg = Debug|Win32
		{B4C142C1-5D8A-4C9A-8891-D8730C363B3A}.Debug|x64.ActiveCfg = Debug|x64
		{B4C142C1-5D8A-4C9A-8891-D8730C363B3A}.Debug|x64.Build.0 = Debug|x64
		{B4C142C1-5D8A-4C9A-8891-D8730C363B3A}.Debug|x86.ActiveCfg = Debug|Win32
		{B4C142C1-5D8A-4C9A-8891-D8730C363B3A}.Debug|x86.Build.0 = Debug|Win32
		{B4C142C1-5D8A-4C9A-8891-D8730C363B3A}.Release_WDK|ARM.ActiveCfg = Release|x64
		{B4C142C1-5D8A-4C9A-8891-D8730C363B3A}.Release_WDK|ARM.Build.0 = Release|x64
		{B4C142C1-5D8A-4C9A-8891-D8730C363B3A}.Release_WDK|ARM64.ActiveCfg = Release|x64
		{B4C142C1-5D8A-4C9A-8891-D8730C363B3A}.Release_WDK|ARM64.Build.0 = Release|x64
		{B4C142C1-5D8A-4C9A-8891-D8730C363B3A}.Release_WDK|x64.ActiveCfg = Release|x64
		{B4C142C1-5D8A-4C9A-8891-D8730C363B3A}.Release_WDK|x64.Build.0 = Release|x64
		{B4C142C1-5D8A-4C9A-8891-D8730C363B3A}.Release_WDK|x86.ActiveCfg = Release|Win32
		{B4C142C1-5D8A-4C9A-8891-D8730C363B3A}.Release_WDK|x86.Build.0 = Release|Win32
		{B4C142C1-5D8A-4C9A-8891-D8730C363B3A}.Release|ARM.ActiveCfg = Release|Win32
		{B4C142C1-5D8A-4C9A-8891-D8730C363B3A}.Release|ARM64.ActiveCfg = Release|Win32
		{B4C142C1-5D8A-4C9A-8891-D8730C363B3A}.Release|x64.ActiveCfg = Release|x64
		{B4C142C1-5D8A-4C9A-8891-D8730C363B3A}.Release|x64.Build.0 = Release|x64
		{B4C142C1-5D8A-4C9A-8891-D8730C363B3A}.Release|x86.ActiveCfg = Release|Win32
		{B4C142C1-5D8A-4C9A-8891-D8730C363B3A}.Release|x86.Build.0 = Release|Win32
		{85004320-1B32-44D6-946C-83AC22369C89}.Debug_WDK|ARM.ActiveCfg = Release|x64
		{85004320-1B32-44D6-946C-83AC22369C89}.Debug_WDK|ARM.Build.0 = Release|x64
		{85004320-1B32-44D6-946C-83AC22369C89}.Debug_WDK|ARM64.ActiveCfg = Release|x64
		{85004320-1B32-44D6-946C-83AC22369C89}.Debug_WDK|ARM64.Build.0 = Release|x64
		{85004320-1B32-44D6-946C-83AC22369C89}.Debug_WDK|x64.ActiveCfg = Debug|x64
		{85004320-1B32-44D6-946C-83AC22369C89}.Debug_WDK|x64.Build.0 = Debug|x64
		{85004320-1B32-44D6-946C-83AC22369C89}.Debug_WDK|x86.ActiveCfg = Debug|Win32
		{85004320-1B32-44D6-946C-83AC22369C89}.Debug_WDK|x86.Build.0 = Debug|Win32
		{85004320-1B32-44D6-946C-83AC22369C89}.Debug|ARM.ActiveCfg = Debug|Win32
		{85004320-1B32-44D6-946C-83AC22369C89}.Debug|ARM64.ActiveCfg = Debug|Win32
		{85004320-1B32-44D6-946C-83AC22369C89}.Debug|x64.ActiveCfg = Debug|x64
		{85004320-1B32-44D6-946C-83AC22369C89}.Debug|x64.Build.0 = Debug|x64
		{85004320-1B32-44D6-946C-83AC22369C89}.Debug|x86.ActiveCfg = Debug|Win32
		{85004320-1B32-44D6-946C-83AC22369C89}.Debug|x86.Build.0 = Debug|Win32
		{85004320-1B32-44D6-946C-83AC22369C89}.Release_WDK|ARM.ActiveCfg = Release|x64
		{85004320-1B32-44D6-946C-83AC22369C89}.Release_WDK|ARM.Build.0 = Release|x64
		{85004320-1B32-44D6-946C-83AC22369C89}.Release_WDK|ARM64.ActiveCfg = Release|x64
		{85004320-1B32-44D6-946C-83AC22369C89}.Release_WDK|ARM64.Build.0 = Release|x64
		{85004320-1B32-44D6-946C-83AC22369C89}.Release_WDK|x64.ActiveCfg = Release|x64
		{85004320-1B32-44D6-946C-83AC22369C89}.Release_WDK|x64.Build.0 = Release|x64
		{85004320-1B32-44D6-946C-83AC22369C89}.Release_WDK|x86.ActiveCfg = Release|Win32
		{85004320-1B32-44D6-946C-83AC22369C89}.Release_WDK|x86.Build.0 = Release|Win32
		{85004320-1B32-44D6-946C-83AC22369C89}.Release|ARM.ActiveCfg = Release|Win32
		{85004320-1B32-44D6-946C-83AC22369C89}.Release|ARM64.ActiveCfg = Release|Win32
		{85004320-1B32-44D6-946C-83AC22369C89}.Release|x64.ActiveCfg = Release|x64
		{85004320-1B32-44D6-946C-83AC22369C89}.Release|x64.Build.0 = Release|x64
		{85004320-1B32-44D6-946C-83AC22369C89}.Release|x86.ActiveCfg = Release|Win32
		{85004320-1B32-44D6-946C-83AC22369C89}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`PerfMon/Apic.h`:

```h
#pragma once


#include <ntddk.h>
extern "C"
{
	typedef ULONG DWORD;

 


 
}
```

`PerfMon/Common.cpp`:

```cpp
#include <ntddk.h>
#include "Common.h"
#include "Log.h"
extern "C"
{ 
	NTSTATUS UtilSleep(LONG Millisecond) 
	{
		PAGED_CODE();

		LARGE_INTEGER interval = {};
		interval.QuadPart = -(10000 * Millisecond);  // msec
		return KeDelayExecutionThread(KernelMode, FALSE, &interval);
	}

	//----------------------------------------------------------------------------------------//
	ULONG GetIndexByID(ULONG_PTR ID, ULONG TableSize)
	{
		return ID % TableSize;
	}
	//----------------------------------------------------------------------------------------//
	void ClearHashById(HASHTABLE* HashTable, ULONG TableSize, ULONG_PTR ID)
	{
		ULONG Index = GetIndexByID(ID, TableSize);
		HashTable[Index].ID = 0;
		HashTable[Index].Value = NULL;
		PMU_DEBUG_INFO_LN_EX("Clear - Index: %x Id: %I64x ", Index, ID);
	}

	//----------------------------------------------------------------------------------------//
	void SetHash(HASHTABLE* HashTable, ULONG TableSize, ULONG_PTR ID, ULONG lpNode)
	{
		ULONG Index = GetIndexByID(ID, TableSize);
		HashTable[Index].ID = ID;
		HashTable[Index].Value = lpNode;
		PMU_DEBUG_INFO_LN_EX("Add - Index: %x Id: %I64x ", Index, ID);
	}

	//----------------------------------------------------------------------------------------//
	BOOLEAN GetHashIndexById(HASHTABLE* HashTable, ULONG TableSize, ULONG_PTR ID, ULONG* count)
	{
		ULONG_PTR Index = GetIndexByID(ID, TableSize);
		if (HashTable[Index].ID == ID)
		{
			if (count)
			{
				*count = HashTable[Index].Value;
			}

			return TRUE;
		}
		return FALSE;
	}
	//--------------------------------------------------------------------------------------------//
	 
}
```

`PerfMon/Common.h`:

```h
#pragma once

#include <intrin.h>
#include "x86.h"
#include "Apic.h"
#include "Util.h" 

#define START_DO_WHILE do{
#define END_DO_WHILE   }while(FALSE); 

#define DRV_NAME	  "PerfMon"

extern "C" 
{
	typedef ULONG64 u64;

	typedef struct _PMU_INFORMATION
	{
		UCHAR SupportedVersion;
		UCHAR SupportedFixedFunction;
		UCHAR SupportedBitWidth;
		UCHAR SupportedAnyThread;
		UCHAR SupportedNumOfPMCs;
		UCHAR SupporteWidthPerPMCs;
		UCHAR SupportedPerfEvents;
		UCHAR IsSupportPebs;
		UCHAR IsSupportEmon;
	}PMUINFO, *PPMUINFO;



	struct pebs_v1 {
		u64 flags;
		u64 ip;
		u64 ax;
		u64 bx;
		u64 cx;
		u64 dx;
		u64 si;
		u64 di;
		u64 bp;
		u64 sp;
		u64 r8;
		u64 r9;
		u64 r10;
		u64 r11;
		u64 r12;
		u64 r13;
		u64 r14;
		u64 r15;
		u64 status;
		u64 dla;
		u64 dse;
		u64 lat;
	};

	struct pebs_v2 {
		struct pebs_v1 v1;
		u64 eventing_ip;
		u64 tsx;
	};

	struct pebs_v3 {
		struct pebs_v2 v2;
		u64 tsc;
	};


	struct debug_store {
		u64 bts_base;
		u64 bts_index;
		u64 bts_max;
		u64 bts_thresh;

		u64 pebs_base;
		u64 pebs_index;
		u64 pebs_max;
		u64 pebs_thresh;
		u64 pebs_reset[4];
	};


	typedef struct _HASH_TABLE
	{
		ULONG_PTR ID;
		ULONG	  Value;
	}HASHTABLE, *PHASHTABLE;

	void SetHash(HASHTABLE* HashTable, ULONG TableSize, ULONG_PTR ID, ULONG count);
	BOOLEAN GetHashIndexById(HASHTABLE* HashTable, ULONG TableSize, ULONG_PTR ID, ULONG* count);
	void ClearHashById(HASHTABLE* HashTable, ULONG TableSize, ULONG_PTR ID);
	ULONG GetIndexByID(ULONG_PTR ID, ULONG TableSize);

	NTSTATUS UtilSleep(LONG Millisecond);
}
```

`PerfMon/Driver.cpp`:

```cpp
  
#include <ntddk.h> 
#include "Apic.h"
#include "x86.h"
#include "PMU.h"
#include "Common.h"
#include "PMI.h"
#include "Log.h"
extern "C"
{
  
	//////////////////////////////////////////////////////////////////
	////	Prototype	
	////	
	////
 

	//////////////////////////////////////////////////////////////////
	////	Global Variable	
	////	
	////
 
	PMUINFO			   g_EnvironmentInfo;

	//////////////////////////////////////////////////////////////////
	////	Marco
	////	
	////
 
	 
 
	//--------------------------------------------------------------//
	VOID DrvUnload(
			_In_ struct _DRIVER_OBJECT *DriverObject)
	{
		UNREFERENCED_PARAMETER(DriverObject);
		UnregisterPmiInterrupt();
		return;
	} 
 
	//--------------------------------------------------------------//
	NTSTATUS DriverEntry(
		_In_	PDRIVER_OBJECT DrvObj,
		_In_	PCUNICODE_STRING RegistryString)
	{ 
		UNREFERENCED_PARAMETER(RegistryString);
		NTSTATUS status = STATUS_SUCCESS;
		START_DO_WHILE
		
		status = RegisterPmiInterrupt();
		if (!NT_SUCCESS(status))
		{ 
			break;
		}
		
		PMU_DEBUG_INFO_LN_EX("Starting Environment Check... ");

		status = PMUEnvironmentCheck(&g_EnvironmentInfo);
		if (!NT_SUCCESS(status))
		{ 
			break;
		}
		 
		status = UtilForEachProcessor(
			PMUInitiailization, &g_EnvironmentInfo
		);
		if (!NT_SUCCESS(status))
		{ 
			break;
		}

		PMU_DEBUG_INFO_LN_EX("----------------------------------------------------------------------");
		PMU_DEBUG_INFO_LN_EX("SupportedVersion:%-30d",g_EnvironmentInfo.SupportedVersion		);
		PMU_DEBUG_INFO_LN_EX("SupportedFixedFunction:%-30d",g_EnvironmentInfo.SupportedFixedFunction	);
		PMU_DEBUG_INFO_LN_EX("SupportedBitWidth:%-30d "	,g_EnvironmentInfo.SupportedBitWidth		);
		PMU_DEBUG_INFO_LN_EX("SupportedAnyThread:%-30d "	,g_EnvironmentInfo.SupportedAnyThread		);
		PMU_DEBUG_INFO_LN_EX("SupportedNumOfPMCs:%-30d"	,g_EnvironmentInfo.SupportedNumOfPMCs		);
		PMU_DEBUG_INFO_LN_EX("SupporteWidthPerPMCs:%-30d"	,g_EnvironmentInfo.SupporteWidthPerPMCs	);
		PMU_DEBUG_INFO_LN_EX("SupportedPerfEvents:%-30d"	,g_EnvironmentInfo.SupportedPerfEvents		);
		PMU_DEBUG_INFO_LN_EX("IsSupportPebs:%-30d"		,g_EnvironmentInfo.IsSupportPebs				); 
		PMU_DEBUG_INFO_LN_EX("IsSupportEmon:%-30d", g_EnvironmentInfo.IsSupportEmon);
		 
		PMU_DEBUG_INFO_LN_EX("-----------------------------------------------------------------------");
		
		DrvObj->DriverUnload = DrvUnload;

		END_DO_WHILE

		return status;
	}
	//--------------------------------------------------------------//
}
```

`PerfMon/Log.h`:

```h
#pragma once

#define PMU_NATIVE_DEBUG_INFO(format, ...)	DbgPrintEx(0,0,format,__VA_ARGS__) 
		
#define PMU_COMMON_DEBUG_INFO(format, ...)	PMU_NATIVE_DEBUG_INFO("[%s] => [%d] : "format, __FILE__ ,  __LINE__,  __VA_ARGS__)
#define PMU_DEBUG_INFO_LN()					PMU_NATIVE_DEBUG_INFO("\r\n")
#define PMU_DEBUG_INFO_LN_EX(format, ...)	PMU_COMMON_DEBUG_INFO(format"\r\n",__VA_ARGS__)


```

`PerfMon/PMI.cpp`:

```cpp
#include <ntddk.h>
#include "PMI.h"
#include "Apic.h"
#include "Common.h"
#include "Log.h"
#include "x86.h"  
#include "ntimage.h"
#include "PMU.h"
#include "SSDT.h"
extern "C"
{
	//////////////////////////////////////////////////////////////////
	////	Types
	////	 
 
	// The PMI Handler function prototype
	typedef VOID(*PMIHANDLER)(
		_In_ PKTRAP_FRAME TrapFrame
		);

	typedef struct _DRIVER_GLOBAL_DATA {
		BOOLEAN bPtSupported;								// TRUE if Intel PT is supported 
		BOOLEAN bCpuX2ApicMode;								// TRUE if the system processors are in x2Apic Mode   
		PMIHANDLER pOldPmiHandler;							// The OLD PMI handler routine (if any)   
		ULONG* lpApicBase;									// The APIC I/O memory VA    
	}DRIVER_GLOBAL_DATA, *PDRIVER_GLOBAL_DATA;
 

 

	///////////////////////////////////////////////////////////////////////
	//// Global Variable 
	////
	 
	DRIVER_GLOBAL_DATA			g_pDrvData = { 0 };
	bool						g_IsUninit = false;
	HASHTABLE					g_inst_table[10000] = { 0 };
	ULONG_PTR					g_InterruptFuncTable[256] = { 0 };
 

	///////////////////////////////////////////////////////////////////////
	//// Marco
	//// 
 
 

 
	//--------------------------------------------------------------//
	VOID HandleSyscall(PKTRAP_FRAME pTrapFrame)
	{
		SyscallHandler(pTrapFrame);
		return;
	}
	//--------------------------------------------------------------//
	NTSTATUS DispatchPmiEvent(PKTRAP_FRAME pTrapFrame)
	{
		ULONG64 SystemCall64 = 0;
		NTSTATUS status = STATUS_SUCCESS;
		status = UtilReadMsr(Msr::Ia32Lstar, &SystemCall64);
		if (!NT_SUCCESS(status))
		{
			return status;
		}

		if (pTrapFrame->Rip >= g_InterruptFuncTable[0xE] && pTrapFrame->Rip <= g_InterruptFuncTable[0xE] + 1000)
		{ 
		}

		if (pTrapFrame->Rip >= g_InterruptFuncTable[0x3] && pTrapFrame->Rip <= g_InterruptFuncTable[0x3] + 1000)
		{
			PMU_DEBUG_INFO_LN_EX("breakpoint: %p ", pTrapFrame->Rip);
			//	HandleBreakpointTrap(pTrapFrame);
		}

		if (pTrapFrame->Rip >= g_InterruptFuncTable[0xD] && pTrapFrame->Rip <= g_InterruptFuncTable[0xD] + 1000)
		{
			//	HandleGeneralProtectException(pTrapFrame);
		}

	 
		if (pTrapFrame->Rip >= SystemCall64 && pTrapFrame->Rip <= SystemCall64 + 1400)
		{ 
			HandleSyscall(pTrapFrame);
		}


		return status;
	} 


	//--------------------------------------------------------------//
	NTSTATUS InitInterrupt()
	{
		IDTDESC info = { 0 };
		PKIDTENTRY64 IdtEntry;
		__sidt(&info);
		IdtEntry = (PKIDTENTRY64)info.BASE;
		for (int i = 0; i < 256; i++)
		{
			ULONG64 handler = 0;
			handler = ((ULONG64)IdtEntry[i].u.OffsetLow | ((ULONG64)IdtEntry[i].u.OffsetMiddle << 16) | ((ULONG64)IdtEntry[i].u.OffsetHigh << 32));
			g_InterruptFuncTable[i] = handler;
			PMU_DEBUG_INFO_LN_EX("Idt[%x]: %p", i, handler);
		}
		return STATUS_SUCCESS;

	}
	//--------------------------------------------------------------//
	NTSTATUS InitApic()
	{
		// First of all we need to search for HalpLocalApic symbol
		MSR_IA32_APIC_BASE_DESC ApicBase = { 0 };				// In Multi-processors systems this address could change
		NTSTATUS status = STATUS_SUCCESS;
		status = UtilReadMsr(Msr::Ia32ApicBase, &ApicBase.All);			// In Windows systems all the processors LVT are mapped at the same physical address

		if (!NT_SUCCESS(status))
		{
			return status;
		}

		if (!ApicBase.Fields.EXTD)
		{
			ULONG* lpdwApicBase = NULL;
			PHYSICAL_ADDRESS apicPhys = { 0 };

			apicPhys.QuadPart = ApicBase.All & (~0xFFFi64);
			lpdwApicBase = (ULONG*)MmMapIoSpace(apicPhys, 0x1000, MmNonCached);

			if (lpdwApicBase)
			{
				DbgPrintEx(0, 0, "[" DRV_NAME "] Successfully mapped the local APIC to 0x%llX.\r\n", lpdwApicBase);
				g_pDrvData.lpApicBase = lpdwApicBase;
			}
			else
			{
				status = STATUS_NOT_SUPPORTED;
				return status;
			}
		}
		else
		{
			// Current system uses x2APIC mode, no need to map anything
			g_pDrvData.bCpuX2ApicMode = TRUE;
		}
		return status;
	}
	//--------------------------------------------------------------//
	NTSTATUS SetUpPerformanceInterrutpHandler(PMIHANDLER Handler)
	{
		PMIHANDLER pNewPmiHandler = Handler;
		NTSTATUS ntStatus = HalSetSystemInformation(HalProfileSourceInterruptHandler, sizeof(PMIHANDLER), (PVOID)&pNewPmiHandler);
		if (NT_SUCCESS(ntStatus))
		{
			DbgPrintEx(0, 0, "[" DRV_NAME "] Successfully registered system PMI handler to function 0x%llX.\r\n", (PVOID)pNewPmiHandler);
		}
		return ntStatus;
	}
	//--------------------------------------------------------------//
	NTSTATUS ResetApic()
	{
		LVT_Entry perfMonDesc = { 0 };
		PULONG lpdwApicBase = g_pDrvData.lpApicBase;
		NTSTATUS status = STATUS_SUCCESS;
		if (g_pDrvData.bCpuX2ApicMode)
		{
			// Check Intel Manuals, Vol. 3A section 10-37
			ULONGLONG perfMonEntry = 0;
			UtilReadMsr(Msr::Ia32x2ApivIvtPmi, &perfMonEntry);
			perfMonDesc.All = (ULONG)perfMonEntry;
			perfMonDesc.Fields.Masked = 0;
			perfMonEntry = (ULONGLONG)perfMonDesc.All;
			UtilWriteMsr(Msr::Ia32x2ApivIvtPmi, perfMonEntry);
		}
		else
		{
			if (!lpdwApicBase)
				// XXX: Not sure how to continue, No MmMapIoSpace at this IRQL (should not happen)
				KeBugCheckEx(INTERRUPT_EXCEPTION_NOT_HANDLED, NULL, NULL, NULL, NULL);

			perfMonDesc.All = lpdwApicBase[0x340 / 4];
			perfMonDesc.Fields.Masked = 0;
			lpdwApicBase[0x340 / 4] = perfMonDesc.All;
		}
		return status;
	}
	//--------------------------------------------------------------//
	VOID IntelPerformanceMonitorInterrupt(PKTRAP_FRAME pTrapFrame)
	{

		START_DO_WHILE

		if (g_IsUninit)
		{
			break;
		}

		//DisablePmi();

		DispatchPmiEvent(pTrapFrame);

		UtilWriteMsr(Msr::Ia32PerfEvtseLx, 0);

		UtilWriteMsr(Msr::Ia32PMCx, (ULONG)0xFFFFFFFE);

		MSR_IA32_PERFEVTSELX_VERSION3 PerfEvtSelx = { 0 };
		PerfEvtSelx.fields.Usr = false;
		PerfEvtSelx.fields.Os = true;
		PerfEvtSelx.fields.E = false;
		PerfEvtSelx.fields.Int = true;
		PerfEvtSelx.fields.CounterMask = 0;
		PerfEvtSelx.fields.En = true;
		PerfEvtSelx.fields.AnyThread = false;
		PerfEvtSelx.fields.EventSelect = 0xC4;
		PerfEvtSelx.fields.UnitMask = 0x40;
		PerfEvtSelx.fields.Inv = false;
		PerfEvtSelx.fields.Pc = false;

		UtilWriteMsr(Msr::Ia32PerfEvtseLx, PerfEvtSelx.all);


		UtilWriteMsr(Msr::Ia32PerfGlobalOvfCtrl, 0x1);
		//EnablePmi();

		END_DO_WHILE

			 
		ResetApic();

		return;
	}
	//--------------------------------------------------------------//
	VOID ClearPmuEnvironment()
	{
		UtilWriteMsr(Msr::Ia32PerfGlobalCtrl, 0);

		UtilWriteMsr(Msr::Ia32PerfGlobalOvfCtrl, 0);

		UtilWriteMsr(Msr::Ia32PMCx, 0);
		 
	}
	//--------------------------------------------------------------//
	NTSTATUS RegisterPmiInterrupt()
	{
		NTSTATUS ntStatus = STATUS_SUCCESS;
		ntStatus = InitSSDTHook();
		if (!NT_SUCCESS(ntStatus))
		{
			return ntStatus;
		}
		ntStatus = InitInterrupt();
		if (!NT_SUCCESS(ntStatus))
		{
			return ntStatus;
		}

		ntStatus = InitApic();
		if (!NT_SUCCESS(ntStatus))
		{
			return ntStatus;
		}
		ntStatus = SetUpPerformanceInterrutpHandler(IntelPerformanceMonitorInterrupt);
		if (!NT_SUCCESS(ntStatus))
		{
			return ntStatus;
		}

		return ntStatus;
	}
	//--------------------------------------------------------------//
	// Unregister and remove the LVT PMI interrupt 
	NTSTATUS UnregisterPmiInterrupt()
	{
		NTSTATUS ntStatus = STATUS_SUCCESS;						// Returned NTSTATUS
		PMIHANDLER pOldPmiHandler = g_pDrvData.pOldPmiHandler;	// The old PMI handler 

		ClearPmuEnvironment();

		g_IsUninit = TRUE;
 
		// This is currently not restoring old PMI handler since we don't know how to retrieve it, just nulling it out
		ntStatus = HalSetSystemInformation(HalProfileSourceInterruptHandler, sizeof(PMIHANDLER), (PVOID)&pOldPmiHandler);

		if (NT_SUCCESS(ntStatus))
		{
			return ntStatus;
		}
		 
		if (g_pDrvData.lpApicBase)
		{
			MmUnmapIoSpace(g_pDrvData.lpApicBase, 0x1000);
		}


		UninitSSDTHook();

		return ntStatus;
	}
}

```

`PerfMon/PMI.h`:

```h
#pragma once
#include <ntddk.h>

extern "C" {
	NTSTATUS RegisterPmiInterrupt();
	NTSTATUS UnregisterPmiInterrupt();
	VOID DisablePmi();
	VOID EnablePmi();
}
```

`PerfMon/PMU.cpp`:

```cpp
#include <ntddk.h>
#include "PMU.h"
#include "Common.h"
#include "Log.h"
#include <intrin.h>
#include "PMI.h"
extern "C"
{  
	////////////////////////////////////////////////////////////////////
	//// Types
	////  


	////////////////////////////////////////////////////////////////////
	////  Marcos
	////  
	#define PEBS_BUFFER_SIZE	(64 * 1024) /* PEBS buffer size */
	#define OUT_BUFFER_SIZE		(64 * 1024) /* must be multiple of 4k */
 
	////////////////////////////////////////////////////////////////////
	////  Global Variable
	////  
	UCHAR g_Event = 0;
	UCHAR g_Mask = 0;
	ULONG pebs_record_size = 0;

//--------------------------------------------------------------//
	NTSTATUS PMUEnvironmentCheck(
		_Out_ PMUINFO* Info
	)
	{
		UCHAR version = 0;
		UCHAR SupportedFixedFunction = 0;
		UCHAR SupportedBitWidth = 0;
		UCHAR SupportedPerfEvents = 0;
		UCHAR SupportedNumOfPMCs = 0;
		UCHAR SupportedPMCsWidth = 0;
		int cpu_info[4];
		NTSTATUS status = STATUS_SUCCESS;

		START_DO_WHILE

		if (!Info)
		{
			DbgPrintEx(0, 0, "Computer is not supported PMU Version : %d \r\n", cpu_info[0]);
			status = STATUS_UNSUCCESSFUL;
			break;
		}

		__cpuid(cpu_info, 0xA);
		version = (UCHAR)(cpu_info[0] & 0xFF);
		SupportedNumOfPMCs = (UCHAR)((cpu_info[0] >> 8) & 0xFF);
		SupportedPMCsWidth = (UCHAR)((cpu_info[0] >> 16) & 0xFF);
		SupportedPerfEvents = (UCHAR)((cpu_info[1] & 0xFF));
		SupportedFixedFunction = (UCHAR)(cpu_info[3] & 0x1F);
		SupportedBitWidth = (UCHAR)((cpu_info[3] >> 5) & 0xFF);

		if (!version)
		{
			DbgPrintEx(0, 0, "Computer is not supported PMU Version : %d \r\n", cpu_info[0]);
			status = STATUS_UNSUCCESSFUL;
			break;
		}

		MSR_IA32_MISC_ENABLE MiscEnable = {0 };

		UtilReadMsr(Msr::Ia32MiscEnable, &MiscEnable.all);

		Info->SupportedVersion = version;
		Info->SupportedFixedFunction = SupportedFixedFunction;
		Info->SupportedBitWidth = SupportedBitWidth;
		Info->SupportedNumOfPMCs = SupportedNumOfPMCs;
		Info->SupporteWidthPerPMCs = SupportedPMCsWidth;
		Info->SupportedAnyThread = (version == 3) ? 1 : 0;
		Info->SupportedPerfEvents = SupportedPerfEvents;
		Info->IsSupportPebs = (!MiscEnable.fields.PEBSUnavaiable);
		Info->IsSupportEmon = (MiscEnable.fields.PerfMonAvaliable);

		END_DO_WHILE

		return status;
	}
	//------------------------------------------------------//
	NTSTATUS CheckMircoArchitecture(
		_In_ ULONG Model)
	{ 
		switch (Model)
		{
		case 58: /* IvyBridge */
		case 60:
		case 63: /* Haswell_EP */
		case 69: /* Haswell_ULT */
		case 94: /* Skylake */
			g_Event = 0xc4; /* UOPS_RETIRED.ALL */
			g_Mask = 0x40;
			break;

		case 55: /* Bay Trail */
		case 76: /* Airmont */
		case 77: /* Avoton */
			g_Event = 0x0c5; /* BR_MISP_RETIRED.ALL_BRANCHES */
			break;

		default:
			PMU_DEBUG_INFO_LN_EX("Unknown CPU model %d\n", Model);
			return STATUS_UNSUCCESSFUL;
		}
		return STATUS_SUCCESS;
	}
	//------------------------------------------------------//
	NTSTATUS CheckPerfCap(
		_In_ ULONG feat1)
	{
		/* check perf capability */
		if (feat1 & (1 << 15))
		{
			ULONG64 cap;

			cap = __readmsr(static_cast<ULONG>(Msr::Ia32PerfCaps));
			switch ((cap >> 8) & 0xf) {
			case 1:
				pebs_record_size = sizeof(struct pebs_v1);
				break;
			case 2:
				pebs_record_size = sizeof(struct pebs_v2);
				break;
			case 3:
				pebs_record_size = sizeof(struct pebs_v3);
				break;
			default:
			{
				PMU_DEBUG_INFO_LN_EX("Unsupported PEBS format\n");
				return STATUS_UNSUCCESSFUL;
			}
			}
			/* Could check PEBS_TRAP */
		}
		else
		{
			PMU_DEBUG_INFO_LN_EX("No PERF_CAPABILITIES support\n"); 
			return STATUS_UNSUCCESSFUL;
		}

		return STATUS_SUCCESS;
	}
	//------------------------------------------------------//
	NTSTATUS CheckSupportDebugStore(
		_In_ ULONG Feat2)
	{
		/* check if we support DS */
		if (!(Feat2 & (1 << 21)))
		{
			PMU_DEBUG_INFO_LN_EX("No debug store support\n");
			return STATUS_UNSUCCESSFUL;
		}
		return STATUS_SUCCESS;
	}
	//------------------------------------------------------//
	NTSTATUS CheckArchPlatform(
		_In_ ULONG Max)
	{
		NTSTATUS status = STATUS_SUCCESS;
		START_DO_WHILE

		int cpu_info[4] = { 0 };
		if (Max >= 0xa) 
		{
			__cpuid(cpu_info, 0xA);
			if ((cpu_info[0] & 0xff) < 1)
			{
				PMU_DEBUG_INFO_LN_EX("No arch perfmon support\n");
				status = STATUS_UNSUCCESSFUL;
				break;
			}

			if (((cpu_info[0] >> 8) & 0xff) < 1)
			{
				PMU_DEBUG_INFO_LN_EX("No generic counters\n"); 
				status = STATUS_UNSUCCESSFUL;
				break;
			}
		}
		else
		{
			PMU_DEBUG_INFO_LN_EX("No arch perfmon support\n");

			status = STATUS_UNSUCCESSFUL;
			break;
		}

		END_DO_WHILE

		return status;
	} 
	//------------------------------------------------------//
	NTSTATUS GetFamilyAndModel(
		_In_ int* CpuInfo , 
		_In_ int* Model,
		_In_ int* Family
	)
	{
		NTSTATUS status = STATUS_SUCCESS;
		START_DO_WHILE
		if (!CpuInfo ||!Model || !Family)
		{
			status = STATUS_UNSUCCESSFUL;
			break;
		}
		 
		*Model = ((CpuInfo[0] >> 4) & 0xf);
		*Family = (CpuInfo[0] >> 8) & 0xf;
		if (*Family == 6 || *Family == 0xf)
		{
			*Model += ((CpuInfo[0] >> 16) & 0xf) << 4;
		}

		END_DO_WHILE  
		return status;
	}

	//------------------------------------------------------//
	NTSTATUS CheckCpu()
	{
		int cpu_info[4] = {0};
		int max, model, fam;
		unsigned feat1, feat2;
		NTSTATUS status = STATUS_SUCCESS;;
		START_DO_WHILE

		__cpuid(cpu_info, 0);
		if (memcmp(&cpu_info[1], "Genu", 4)) 
		{
			PMU_DEBUG_INFO_LN_EX("Not an Intel CPU\n");
			break;
		} 
		max = cpu_info[0];

		__cpuid(cpu_info, 1); 
		feat1 = cpu_info[2];
		feat2 = cpu_info[3]; 

		status = GetFamilyAndModel(cpu_info, &model, &fam);
		if (!NT_SUCCESS(status) || fam != 6)
		{
			PMU_DEBUG_INFO_LN_EX("Not an supported Intel CPU\n");
			break;
		}

		status = CheckMircoArchitecture(model);
		if (!NT_SUCCESS(status))
		{
			break;
		}

		status = CheckArchPlatform(max);
		if (!NT_SUCCESS(status))
		{
			break;
		}

		status = CheckSupportDebugStore(feat2);
		if (!NT_SUCCESS(status))
		{
			break;
		}

		status = CheckPerfCap(feat1);
		if (!NT_SUCCESS(status))
		{
			break;
		}

		PMU_DEBUG_INFO_LN_EX("Supported CPU : %x %x pebs_record_size: %x ", g_Mask, g_Event, pebs_record_size);

		END_DO_WHILE 
 
		return status;
	} 

	//--------------------------------------------------------------//
	VOID DisablePmi()
	{
		MSR_IA32_PERF_GLOBAL_CTRL_VERSION2 Ctrl = { 0 };
		UtilWriteMsr(Msr::Ia32PerfGlobalCtrl, Ctrl.all);
	}
	//--------------------------------------------------------------//
	VOID EnablePmi()
	{
		MSR_IA32_PERF_GLOBAL_CTRL_VERSION2 Ctrl = { 0 };
		Ctrl.fields.EnablePmc0 = true;
		UtilWriteMsr(Msr::Ia32PerfGlobalCtrl, Ctrl.all);
	}

	//--------------------------------------------------------------//
	NTSTATUS PMUInitiailization(
		_In_ PVOID info
	)
	{
		START_DO_WHILE

			PMUINFO* Info = (PMUINFO*)info;
		if (!Info || !NT_SUCCESS(CheckCpu()))
		{
			return STATUS_UNSUCCESSFUL;
		}
		 
		switch (Info->SupportedVersion)
		{
		case 0:
			break;
		case 1:
			break;
		case 2:
			break;
		case 3: 
	
			DisablePmi();

			UtilWriteMsr(Msr::Ia32PerfEvtseLx, 0);

			UtilWriteMsr(Msr::Ia32PMCx, (ULONG)0xFFFFFFFE);

			MSR_IA32_PERFEVTSELX_VERSION3 PerfEvtSelx = { 0 };
			PerfEvtSelx.fields.Usr = false;						//in case you want intercept user mode instruction...
			PerfEvtSelx.fields.Os = true;
			PerfEvtSelx.fields.E = false;
			PerfEvtSelx.fields.Int = true;
			PerfEvtSelx.fields.CounterMask = 0;
			PerfEvtSelx.fields.En = true;
			PerfEvtSelx.fields.AnyThread = false;
			PerfEvtSelx.fields.EventSelect = 0xC4;
			PerfEvtSelx.fields.UnitMask = 0x40;
			PerfEvtSelx.fields.Inv = false;
			PerfEvtSelx.fields.Pc = false;
			UtilWriteMsr(Msr::Ia32PerfEvtseLx, PerfEvtSelx.all);
		 
			EnablePmi();
		
			PMU_DEBUG_INFO_LN_EX("Id: %x %d Done....", PerfEvtSelx.all, KeGetCurrentProcessorNumber());

			break;
		}

		END_DO_WHILE
			return STATUS_SUCCESS;
	}

	//--------------------------------------------------------------//
	NTSTATUS PMUUnInitiailization(
		_In_ PVOID info
	)
	{
		PMUINFO* Info = (PMUINFO*)info;
		if (!Info)
		{
			return STATUS_UNSUCCESSFUL;
		}

		switch (Info->SupportedVersion)
		{
		case 0:
			break;
		case 1:
			break;
		case 2:
			break;
		case 3:
			break;
		}
		return STATUS_SUCCESS;
	}
}
```

`PerfMon/PMU.h`:

```h
#include <ntddk.h>
#include "Common.h"
///////////////////////////////////////////////////////
//// Prototype
////
////
extern "C" {
	NTSTATUS PMUEnvironmentCheck(
		_Out_ PMUINFO* Info
	);

	NTSTATUS PMUInitiailization(
		_In_ PVOID Info
	);

	NTSTATUS PMUUnInitiailization(
		_In_ PVOID Info
	);
}
```

`PerfMon/PerfMon.inf`:

```inf
;
; PerfMon.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=PerfMon.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages

[DestinationDirs]
DefaultDestDir = 12

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
PerfMon.sys  = 1,,

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%PerfMon.DeviceDesc%=PerfMon_Device, Root\PerfMon ; TODO: edit hw-id

[PerfMon_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
PerfMon.sys

;--- PerfMon_Device Coinstaller installation ------
;


[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "PerfMon Installation Disk"
PerfMon.DeviceDesc = "PerfMon Device"
PerfMon.SVCDESC = "PerfMon Service"

```

`PerfMon/PerfMon.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{F01C4412-F73C-4BD8-A954-84E2F3BD1251}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>PerfMon</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalDependencies>%(AdditionalDependencies);$(KernelBufferOverflowLib);$(DDK_LIB_PATH)ntoskrnl.lib;$(DDK_LIB_PATH)hal.lib;$(DDK_LIB_PATH)wmilib.lib; </AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="PerfMon.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Common.cpp" />
    <ClCompile Include="Driver.cpp" />
    <ClCompile Include="PMI.cpp" />
    <ClCompile Include="PMU.cpp" />
    <ClCompile Include="SSDT.cpp" />
    <ClCompile Include="Util.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Apic.h" />
    <ClInclude Include="Common.h" />
    <ClInclude Include="Log.h" />
    <ClInclude Include="PMI.h" />
    <ClInclude Include="PMU.h" />
    <ClInclude Include="SSDT.h" />
    <ClInclude Include="Util.h" />
    <ClInclude Include="x86.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`PerfMon/PerfMon.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="PerfMon.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Apic.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="x86.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="PMU.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Common.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="PMI.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Util.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Log.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="SSDT.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Driver.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="PMU.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="PMI.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Util.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Common.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="SSDT.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`PerfMon/PerfMon.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <SignMode>TestSign</SignMode>
  </PropertyGroup>
</Project>
```

`PerfMon/SSDT.cpp`:

```cpp
#include "SSDT.h"
#include "Log.h"
//////////////////////////////////////////////////////////////////
////	Types
////	 
extern "C" {


	typedef enum _MEMORY_INFORMATION_CLASS {
		MemoryBasicInformation
	} MEMORY_INFORMATION_CLASS;


	typedef NTSTATUS(__fastcall *pNtQueryVirtualMemory)(
		_In_      HANDLE                   ProcessHandle,
		_In_opt_  PVOID                    BaseAddress,
		_In_      MEMORY_INFORMATION_CLASS MemoryInformationClass,
		_Out_     PVOID                    MemoryInformation,
		_In_      SIZE_T                   MemoryInformationLength,
		_Out_opt_ PSIZE_T                  ReturnLength
		);


	typedef NTSTATUS(__fastcall *pNtQueryPerformanceCounter)(
		_Out_     PLARGE_INTEGER PerformanceCounter,
		_Out_opt_ PLARGE_INTEGER PerformanceFrequency
		);

	typedef NTSTATUS(__fastcall *pMyNtQuerySystemInformation)(
		_In_      ULONG SystemInformationClass,
		_Inout_   PVOID                    SystemInformation,
		_In_      ULONG                    SystemInformationLength,
		_Out_opt_ PULONG                   ReturnLength
		);
	typedef NTSTATUS(__fastcall *pMyNtCreateFile)(
		_Out_    PHANDLE            FileHandle,
		_In_     ACCESS_MASK        DesiredAccess,
		_In_     POBJECT_ATTRIBUTES ObjectAttributes,
		_Out_    PIO_STATUS_BLOCK   IoStatusBlock,
		_In_opt_ PLARGE_INTEGER     AllocationSize,
		_In_     ULONG              FileAttributes,
		_In_     ULONG              ShareAccess,
		_In_     ULONG              CreateDisposition,
		_In_     ULONG              CreateOptions,
		_In_     PVOID              EaBuffer,
		_In_     ULONG              EaLength
		);

	///////////////////////////////////////////////////////////////////////
	//// Prototype
	////
	NTSTATUS __fastcall MyNtQuerySystemInformation(
		_In_      ULONG  SystemInformationClass,
		_Inout_   PVOID  SystemInformation,
		_In_      ULONG  SystemInformationLength,
		_Out_opt_ PULONG ReturnLength
	);
	NTSTATUS __fastcall MyNtCreateFile(
		_Out_    PHANDLE            FileHandle,
		_In_     ACCESS_MASK        DesiredAccess,
		_In_     POBJECT_ATTRIBUTES ObjectAttributes,
		_Out_    PIO_STATUS_BLOCK   IoStatusBlock,
		_In_opt_ PLARGE_INTEGER     AllocationSize,
		_In_     ULONG              FileAttributes,
		_In_     ULONG              ShareAccess,
		_In_     ULONG              CreateDisposition,
		_In_     ULONG              CreateOptions,
		_In_     PVOID              EaBuffer,
		_In_     ULONG              EaLength
	);

	NTSTATUS __fastcall MyNtQueryVirtualMemory(
		_In_      HANDLE                   ProcessHandle,
		_In_opt_  PVOID                    BaseAddress,
		_In_      MEMORY_INFORMATION_CLASS MemoryInformationClass,
		_Out_     PVOID                    MemoryInformation,
		_In_      SIZE_T                   MemoryInformationLength,
		_Out_opt_ PSIZE_T                  ReturnLength
	);

	typedef struct _KeShadowTable
	{
		SYSTEM_SERVICE_TABLE NtKernel;
		SYSTEM_SERVICE_TABLE Win32k;
	}TKeShadowTable, *PKeShadowTable;

	///////////////////////////////////////////////////////////////////////
	//// Marco
	//// 
	#define NtQueryVirtualMemServiceNumber	32
	#define NtQuerySysInfoServiceNumber		51
	#define NtCreateFileServiceNumber		82 
	#define SETBIT(x,y) x|=(1<<y)  
	#define CLRBIT(x,y) x&=~(1<<y)  
	#define GETBIT(x,y) (x & (1 << y)) 

	
	///////////////////////////////////////////////////////////////////////
	//// Global Variable 
	////
	ULONG						g_SyscallQueryCount = 0;
	ULONG						g_Syscall51Count = 0;
	PVOID						g_FakeSsdt = NULL;
	PVOID						g_FakeSSsdt = NULL;
	PUCHAR						g_ShellCode = NULL;
	ULONG64						g_OrgSsdt = 0;
	ULONG64						g_OrgSSsdt = 0;
	ULONG64						g_OrgSssdtOffset = 0;
	pMyNtQuerySystemInformation g_MyNtQuerySystemInformation = NULL;
	pNtQueryVirtualMemory		g_MyNtQueryVirtualMemory = NULL;
	pMyNtCreateFile				g_MyNtCreateFile = NULL;
	PUCHAR			 			g_PrivateSsdtTable;
	PUCHAR			 			g_PrivateSSsdtTable;
	JMPCODE*					g_JmpCodeTable;
	JMPCODE*					g_ShadowJmpCodeTable;
	UCHAR						g_MyServiceSyscallTable[1024];
	UCHAR						g_MyServiceParamTable[1024];
	UCHAR						g_MyShadowServiceParamTable[1024];
	SYSTEM_SERVICE_TABLE*		g_MyServiceTableDescriptor;


	TKeShadowTable*				g_MyShadowServiceTableDescriptor;
	BOOLEAN						g_IsInit = FALSE;

	ULONG64						g_TargetAddress = NULL;
	ULONG						g_HookIndex[] = { NtQuerySysInfoServiceNumber };//NtQueryVirtualMemServiceNumber};//, NtQuerySysInfoServiceNumber ,// NtCreateFileServiceNumber };
 
//--------------------------------------------------------------//
	NTSTATUS SetSyscallProc(ULONG Index, ULONG64 NewAddr, PVOID* OldAddr)
	{
		NTSTATUS status = STATUS_SUCCESS;
		if (!g_ShellCode)
		{
			status = STATUS_UNSUCCESSFUL;
			return status;
		}

		if (OldAddr)
		{
			*OldAddr = (VOID*)g_JmpCodeTable[Index].JmpAddr;
		}

		g_JmpCodeTable[Index].JmpAddr = NewAddr;
		return status;
	}

	//--------------------------------------------------------------//
	NTSTATUS __fastcall MyNtQueryVirtualMemory(
		_In_      HANDLE                   ProcessHandle,
		_In_opt_  PVOID                    BaseAddress,
		_In_      MEMORY_INFORMATION_CLASS MemoryInformationClass,
		_Out_     PVOID                    MemoryInformation,
		_In_      SIZE_T                   MemoryInformationLength,
		_Out_opt_ PSIZE_T                  ReturnLength
	)
	{
		PMU_DEBUG_INFO_LN_EX("[SSDT NtQueryVirtualMemory] ProcessId: %x ProcessHandle: %x BaseAddress: %x MemoryInformationClass: %x MemoryInformation: %x MemoryInformationLength: %x ReturnLength: %x",
			PsGetCurrentProcessId(), ProcessHandle,
			BaseAddress,
			MemoryInformationClass,
			MemoryInformation,
			MemoryInformationLength,
			ReturnLength);

		if (!g_MyNtQueryVirtualMemory)
		{
			SYSTEM_SERVICE_TABLE* ssdt = (SYSTEM_SERVICE_TABLE*)g_OrgSsdt;
			g_MyNtQueryVirtualMemory = (pNtQueryVirtualMemory)GetSSDTProcAddress(ssdt, 82, NULL);
		}
		return g_MyNtQueryVirtualMemory(
			ProcessHandle,
			BaseAddress,
			MemoryInformationClass,
			MemoryInformation,
			MemoryInformationLength,
			ReturnLength);
	}



	//--------------------------------------------------------------//
	NTSTATUS __fastcall MyNtCreateFile(
		_Out_    PHANDLE            FileHandle,
		_In_     ACCESS_MASK        DesiredAccess,
		_In_     POBJECT_ATTRIBUTES ObjectAttributes,
		_Out_    PIO_STATUS_BLOCK   IoStatusBlock,
		_In_opt_ PLARGE_INTEGER     AllocationSize,
		_In_     ULONG              FileAttributes,
		_In_     ULONG              ShareAccess,
		_In_     ULONG              CreateDisposition,
		_In_     ULONG              CreateOptions,
		_In_     PVOID              EaBuffer,
		_In_     ULONG              EaLength
	)
	{
		PMU_DEBUG_INFO_LN_EX("[SSDT NtCreate file] ProcessId: %x FileHandle: %x DesiredAccess: %x ObjectAttributes: %x IoStatusBlock: %x AllocationSize: %x FileAttributes: %x ShareAccess:%x CreateDisposition: %x CreateOptions:%x EaBuffer: %x EaLength: %x",
			PsGetCurrentProcessId(), FileHandle, DesiredAccess, ObjectAttributes, IoStatusBlock, AllocationSize, FileAttributes, ShareAccess, CreateDisposition, CreateOptions, EaBuffer, EaLength);

		if (!g_MyNtCreateFile)
		{
			SYSTEM_SERVICE_TABLE* ssdt = (SYSTEM_SERVICE_TABLE*)g_OrgSsdt;
			g_MyNtCreateFile = (pMyNtCreateFile)GetSSDTProcAddress(ssdt, 82, NULL);
		}
		return g_MyNtCreateFile(
			FileHandle,
			DesiredAccess,
			ObjectAttributes,
			IoStatusBlock,
			AllocationSize,
			FileAttributes,
			ShareAccess,
			CreateDisposition,
			CreateOptions,
			EaBuffer,
			EaLength);
	}
	//--------------------------------------------------------------//
	NTSTATUS __fastcall MyNtQuerySystemInformation(
		_In_      ULONG  SystemInformationClass,
		_Inout_   PVOID  SystemInformation,
		_In_      ULONG  SystemInformationLength,
		_Out_opt_ PULONG ReturnLength
	)
	{

		PMU_DEBUG_INFO_LN_EX("[SSDT NtQuerySystemInformation] Core: %x ProcessId: %x SystemInformationClass: %X SystemInformationLength: %X ReturnLength: %X ",
			KeGetCurrentProcessorNumber(), PsGetCurrentProcessId(), SystemInformationClass,
			SystemInformation,
			SystemInformationLength,
			ReturnLength);


		if (SystemInformationClass == 0x4568)
		{
			PMU_DEBUG_INFO_LN_EX("@@@call count : %u Total: %u", g_SyscallQueryCount , g_Syscall51Count);
			g_SyscallQueryCount = 0;
			g_Syscall51Count = 0;
		}

		if (SystemInformationClass == 0x4567)
		{
			g_SyscallQueryCount++;
			return 0x5678;
		}

		if (!g_MyNtQuerySystemInformation)
		{
			SYSTEM_SERVICE_TABLE* ssdt = (SYSTEM_SERVICE_TABLE*)g_OrgSsdt;
			g_MyNtQuerySystemInformation = (pMyNtQuerySystemInformation)GetSSDTProcAddress(ssdt, 82, NULL);
		}
		return g_MyNtQuerySystemInformation(SystemInformationClass,
			SystemInformation,
			SystemInformationLength,
			ReturnLength
		);
	}
	//-------------------------------------------------------------------------------------------------------------
	VOID BuildPrivateSyscallTable(
		_In_  SYSTEM_SERVICE_TABLE* ServiceTableDescriptor,
		_In_  PULONG				PrivateServiceTable,
		_In_  UCHAR*				PrivateParamTable,
		_Out_ SYSTEM_SERVICE_TABLE* PrivateSSDT,
		_In_  JMPCODE*				PrivateHookTable)
	{

		int i = 0;
		UCHAR FixCode[6] = { 0xFF , 0x25 , 0x00 , 0x00 , 0x00 , 0x00 };
		ULONG ParamCount = 0;
		PVOID ServciceAddr = NULL;
		ULONG TestRealOffset = 0;
		ULONG Offset = 0;

		if (!ServiceTableDescriptor || !PrivateParamTable || !PrivateSSDT)
		{
			return;
		}


		memcpy(PrivateParamTable, ServiceTableDescriptor->ParamTableBase, ServiceTableDescriptor->NumberOfServices);

		//Service table
					/*----------
			  	----- |	Offset |
			----|---- | Offset |
			|	|	  |  ....  |
			|	|	   -----------
			|	|---->| shellCode |
			--------->| shellCode |
					  | ......... |
					   -----------
			*/
		for (i = 0; i < ServiceTableDescriptor->NumberOfServices; ++i)
		{
			ServciceAddr = GetSSDTProcAddress(ServiceTableDescriptor->ServiceTableBase, i, &ParamCount);
			TestRealOffset = GetOffsetAddress((PULONG)ServiceTableDescriptor->ServiceTableBase, (ULONG64)ServciceAddr, (CHAR)ParamCount);
			Offset = GetOffsetAddress((PULONG)PrivateServiceTable, (ULONG64)&PrivateHookTable[i], (CHAR)ParamCount);

			PrivateServiceTable[i] = Offset;
			RtlCopyMemory(&PrivateHookTable[i].FixCode, FixCode, 6);
			PrivateHookTable[i].JmpAddr = (ULONG64)ServciceAddr;

			PMU_DEBUG_INFO_LN_EX(" SSDT Proc: %p TestRealOffset: %x realoffset:%x MyOffset: %x g_PrivateSsdtTable: %p g_JmpCodeTable: %p ParamCount: %x HookTable: %p",
				ServciceAddr,
				TestRealOffset,
				*(PULONG)((ULONG64)ServiceTableDescriptor->ServiceTableBase + i * 4),
				Offset,
				g_PrivateSsdtTable,
				g_JmpCodeTable,
				PrivateParamTable[i],
				PrivateHookTable
			);
		}

		PrivateSSDT->NumberOfServices = ServiceTableDescriptor->NumberOfServices;
		PrivateSSDT->ServiceTableBase = PrivateServiceTable;
		PrivateSSDT->ParamTableBase = PrivateParamTable;
		PrivateSSDT->ServiceCounterTableBase = NULL;


		PMU_DEBUG_INFO_LN_EX("NumberOfServices: %X ServiceTableBase: %p ParamTableBase: %p ",
			PrivateSSDT->NumberOfServices,
			PrivateSSDT->ServiceTableBase,
			PrivateSSDT->ParamTableBase
		);

	}

	//-------------------------------------------------------------------------------------------------------------
	ULONG GetOffsetAddress(PULONG SSDTBase, ULONGLONG FuncAddr, CHAR paramCount)
	{
		ULONG dwtmp = 0, i;
		CHAR b = 0, bits[4] = { 0 };
		PULONG stb = NULL;
		stb = SSDTBase;
		dwtmp = (ULONG)(FuncAddr - (ULONGLONG)stb);
		dwtmp = dwtmp << 4;

		memcpy(&b, &dwtmp, 1);
		for (i = 0; i < 4; i++)
		{
			bits[i] = GETBIT(paramCount, i);
			if (bits[i])
			{
				SETBIT(b, i);
			}
			else
			{
				CLRBIT(b, i);
			}
		}
		memcpy(&dwtmp, &b, 1);
		return (ULONG)dwtmp;
	}
	//-------------------------------------------------------------------------------------------------------------
	void* GetSSDTProcAddress(void* SSTD, ULONG Index, PULONG lpParamCount)
	{
		ULONG* Table = NULL;
		ULONG  Offset;
		ULONGLONG Offset_U;

		if (!SSTD || Index == -1)
		{
			return NULL;
		}
		Table = (ULONG*)(SSTD);
		Offset = Table[Index];
		if (Offset & 0x80000000)
		{
			Offset_U = 0xfffffffff0000000 + (Offset >> 4);
		}
		else
		{
			Offset_U = (Offset >> 4);
		}

		if (lpParamCount)
		{
			*lpParamCount = Offset & 0x0000000F;
		}

		return (PCHAR)Table + Offset_U;
	}

	//-------------------------------------------------------------------------------------------------------------
	VOID SyscallHandler(PKTRAP_FRAME pTrapFrame)
	{		

		ULONG MyOffset = 0;
		UCHAR FixCode[6]   = { 0xFF , 0x25 , 0x00 , 0x00 , 0x00 , 0x00 };
		UCHAR Signature[6] = { 0x89 , 0x83, 0xF8 , 0x01 , 0x00 ,0x00 };
		BOOLEAN  IsHooked = FALSE;
		BOOLEAN bIsDanger = FALSE;
		 
		if (!g_ShellCode)
		{
			return;
		}

		if (PsGetCurrentProcessId() == (HANDLE)13720)
		{
			if (pTrapFrame->Rax == 51) 
			{
				g_Syscall51Count++;
				PMU_DEBUG_INFO_LN_EX("test flags pro: %d rip: %p rax: %d g_Syscall51Count: %d ", KeGetCurrentProcessorNumber() ,pTrapFrame->Rip, pTrapFrame->Rax, g_Syscall51Count);
			}
		}

		for (int k = 0; k < 6; k++)
		{
			if (((PUCHAR)pTrapFrame->Rip)[k] != Signature[k])
			{
				bIsDanger = TRUE ;
			}
		} 

		if (g_PrivateSsdtTable)
		{
			ULONG   ServiceNum = 0; 
			ULONG64 kThread = (ULONG64)KeGetCurrentThread(); 

			/*
				.text:000000014006EA90 FB                                      sti
				.text:000000014006EA91 48 89 8B E0 01 00 00                    mov     [rbx+1E0h], rcx
				.text:000000014006EA98 89 83 F8 01 00 00                       mov     [rbx+1F8h], eax 
			*/
			if (!bIsDanger)
			{
				for (int i = 0; i < sizeof(g_HookIndex) / sizeof(ULONG); i++)
				{
					if (g_HookIndex[i] == pTrapFrame->Rax)
					{ 
						pTrapFrame->Rip = (ULONG64)g_ShellCode;	
						PMU_DEBUG_INFO_LN_EX("@@@PID: %d Normal Case: %p", PsGetCurrentProcessId(), pTrapFrame->Rip);
						break;
					}
				} 
				return;
			}

			if (!kThread)
			{
				return;
			}

			ServiceNum = *(PULONG)(kThread + 0x1F8);

			for (int i = 0; i < sizeof(g_HookIndex) / sizeof(ULONG); i++)
			{
				if (g_HookIndex[i] == ServiceNum)
				{
					IsHooked = TRUE;
				}
			}

			if (!IsHooked)
			{
				return; 
			}

			/* 
				.text:000000014006EA9E
				.text:000000014006EA9E                         loc_14006EA9E:                          ; DATA XREF: sub_14006E900+5A↑o
				.text:000000014006EA9E                                                                 ; .data:00000001401EA838↓o
				.text:000000014006EA9E 48 89 A3 D8 01 00 00                    mov     [rbx+1D8h], rsp
				.text:000000014006EAA5 8B F8                                   mov     edi, eax
				.text:000000014006EAA7 C1 EF 07                                shr     edi, 7
				.text:000000014006EAAA 83 E7 20                                and     edi, 20h
				.text:000000014006EAAD 25 FF 0F 00 00                          and     eax, 0FFFh
				.text:000000014006EAB2
				.text:000000014006EAB2                         loc_14006EAB2:                          ; CODE XREF: sub_14006E980+47B↓j
				.text:000000014006EAB2 4C 8D 15 47 DE 23 00                    lea     r10, qword_1402AC900
				.text:000000014006EAB9 4C 8D 1D 00 DF 23 00                    lea     r11, byte_1402AC9C0
			*/ 
			if (pTrapFrame->Rip >= g_TargetAddress - 20 && pTrapFrame->Rip < g_TargetAddress )
			{	
				PMU_DEBUG_INFO_LN_EX("@@@PID: %d Smaller Case: %p", PsGetCurrentProcessId(), pTrapFrame->Rip);
				pTrapFrame->Rip = (ULONG64)g_ShellCode;			
				return;
			}
			/*
				.text:000000014006EAB2 4C 8D 15 47 DE 23 00                          lea     r10, qword_1402AC900		<< g_TargetAddress
				.text:000000014006EAB9 4C 8D 1D 00 DF 23 00                          lea     r11, byte_1402AC9C0
				.text:000000014006EAC0 F7 83 00 01 00 00 80 00 00 00                 test    dword ptr [rbx+100h], 80h
				.text:000000014006EACA 4D 0F 45 D3                                   cmovnz  r10, r11
				.text:000000014006EACE 42 3B 44 17 10                                cmp     eax, [rdi+r10+10h]
				.text:000000014006EAD3 0F 83 E9 02 00 00                             jnb     loc_14006EDC2
				.text:000000014006EAD9 4E 8B 14 17                                   mov     r10, [rdi+r10]
				.text:000000014006EADD 4D 63 1C 82                                   movsxd  r11, dword ptr [r10+rax*4]
				.text:000000014006EAE1 49 8B C3                                      mov     rax, r11					<< + 47
			*/
			else if ( pTrapFrame->Rip >= g_TargetAddress &&  pTrapFrame->Rip <= g_TargetAddress + 47 )
			{
				PMU_DEBUG_INFO_LN_EX("@@@PID: %d Middle Case: %p", PsGetCurrentProcessId(), pTrapFrame->Rip);
				pTrapFrame->Rip = (ULONG64)g_ShellCode + 26;
				
				return;
			} 
			/* May miss it.	
				.text:000000014006EAE4 49 C1 FB 04                                   sar     r11, 4						<< + 50
				.text:000000014006EAE8 4D 03 D3                                      add     r10, r11					
				.text:000000014006EAEB 83 FF 20                                      cmp     edi, 20h
				.text:000000014006EAEE 75 50                                         jnz     short loc_14006EB40
				.text:000000014006EAF0 4C 8B 9B B8 00 00 00                          mov     r11, [rbx+0B8h]			<< + 62
			*/
			else if (pTrapFrame->Rip >= g_TargetAddress + 50 && pTrapFrame->Rip <= g_TargetAddress + 62 )
			{
				PMU_DEBUG_INFO_LN_EX("@@@PID: %d Second Middle Case: %p", PsGetCurrentProcessId(),  pTrapFrame->Rip);
				return;
			}
			/*
				.text:000000014006EAF7 41 83 BB 40 17 00 00 00                       cmp     dword ptr [r11+1740h], 0
				.text:000000014006EAFF 74 3F                                         jz      short loc_14006EB40
				.text:000000014006EB01 48 89 45 B0                                   mov     [rbp-50h], rax
				.text:000000014006EB05 48 89 4D B8                                   mov     [rbp-48h], rcx
				.text:000000014006EB09 48 89 55 C0                                   mov     [rbp-40h], rdx
				.text:000000014006EB0D 49 8B D8                                      mov     rbx, r8
				.text:000000014006EB10 49 8B F9                                      mov     rdi, r9
				.text:000000014006EB13 49 8B F2                                      mov     rsi, r10
				.text:000000014006EB16 FF 15 D4 DC 23 00                             call    cs:qword_1402AC7F0
				.text:000000014006EB1C 48 8B 45 B0                                   mov     rax, [rbp-50h]
				.text:000000014006EB20 48 8B 4D B8                                   mov     rcx, [rbp-48h]
				.text:000000014006EB24 48 8B 55 C0                                   mov     rdx, [rbp-40h]
				.text:000000014006EB28 4C 8B C3                                      mov     r8, rbx
				.text:000000014006EB2B 4C 8B CF                                      mov     r9, rdi
				.text:000000014006EB2E 4C 8B D6                                      mov     r10, rsi
				.text:000000014006EB31                                               db      66h, 66h, 66h, 66h, 66h, 66h
				.text:000000014006EB31 66 66 66 66 66 66 66 0F 1F 84+                nop     word ptr [rax+rax+00000000h]
			*/
			else if (pTrapFrame->Rip >= g_TargetAddress + 69 && pTrapFrame->Rip <= g_TargetAddress + 127 )
			{
				PMU_DEBUG_INFO_LN_EX("@@@PID: %d Third Middle Case: %p", PsGetCurrentProcessId(),  pTrapFrame->Rip);
				return;
			}
			/* 
				.text:000000014006EB40 83 E0 0F                                      and     eax, 0Fh
				.text:000000014006EB43 0F 84 B7 00 00 00                             jz      loc_14006EC00
				.text:000000014006EB49 C1 E0 03                                      shl     eax, 3
				.text:000000014006EB4C 48 8D 64 24 90                                lea     rsp, [rsp-70h]
				.text:000000014006EB51 48 8D 7C 24 18                                lea     rdi, [rsp+70h+var_58]
				.text:000000014006EB56 48 8B B5 00 01 00 00                          mov     rsi, [rbp+100h]
				.text:000000014006EB5D 48 8D 76 20                                   lea     rsi, [rsi+20h]
				.text:000000014006EB61 F6 85 F0 00 00 00 01                          test    byte ptr [rbp+0F0h], 1
				.text:000000014006EB68 74 16                                         jz      short loc_14006EB80
				.text:000000014006EB6A 48 3B 35 8F D4 23 00                          cmp     rsi, cs:MmUserProbeAddress
				.text:000000014006EB71 48 0F 43 35 87 D4 23 00                       cmovnb  rsi, cs:MmUserProbeAddress
				.text:000000014006EB79 0F 1F 80 00 00 00 00                          nop     dword ptr [rax+00000000h]
				.text:000000014006EB80
				.text:000000014006EB80                               loc_14006EB80:                          ; CODE XREF: sub_14006E980+1E8↑j
				.text:000000014006EB80 4C 8D 1D 79 00 00 00                          lea     r11, loc_14006EC00
				.text:000000014006EB87 4C 2B D8                                      sub     r11, rax
				.text:000000014006EB8A 41 FF E3                                      jmp     r11 
			*/
			else if (pTrapFrame->Rip >= g_TargetAddress + 142 && pTrapFrame->Rip <= g_TargetAddress + 350 && IsHooked)
			{
				ULONG64 ProcAddr = 0; 
				ProcAddr = (ULONG64)GetSSDTProcAddress(g_MyServiceTableDescriptor->ServiceTableBase, ServiceNum, NULL);
				for (int i = 0; i < sizeof(g_HookIndex) / sizeof(ULONG); i++)
				{
					if (g_HookIndex[i] == ServiceNum)
					{
						pTrapFrame->R10 = ProcAddr;
						PMU_DEBUG_INFO_LN_EX("@@@PID: %d We should record down what is going on here ?? Rip: %p ProcAddr: %p Num: %x ", PsGetCurrentProcessId(),  pTrapFrame->Rip, ProcAddr, ServiceNum);
						return;
					}
				} 
				PMU_DEBUG_INFO_LN_EX("@@@PID: %d Overflowing", PsGetCurrentProcessId() );
				return;
			}   
			else
			{ 
				PMU_DEBUG_INFO_LN_EX("@@@PID: %d Uncover Area %p Middle Num: %d  TargetAddress: %p  IsHooked: %x", PsGetCurrentProcessId(), pTrapFrame->Rip, ServiceNum,  g_TargetAddress+47 , IsHooked);
			}

			return;
		}

		RtlZeroMemory(g_ShellCode, PAGE_SIZE);

		ULONG64 RetAddr = pTrapFrame->Rip + 40;
		RtlMoveMemory(g_ShellCode, (PUCHAR)pTrapFrame->Rip, 40);
		RtlCopyMemory(g_ShellCode + 40, FixCode, 6);
		RtlCopyMemory(g_ShellCode + 46, &RetAddr, 8);

		for (int i = 0; i < 40; i++)
		{
		
			if (g_ShellCode[i] == 0x4C && g_ShellCode[i + 1] == 0x8D && g_ShellCode[i + 2] == 0x15)
			{	
				SYSTEM_SERVICE_TABLE* Ssdt = NULL;
				if (!g_OrgSsdt)
				{
					g_OrgSsdt = *(PULONG)&g_ShellCode[i + 3];
					g_OrgSsdt = (g_OrgSsdt + pTrapFrame->Rip + i + 7);
				}
				g_TargetAddress = pTrapFrame->Rip + i;
				Ssdt = (SYSTEM_SERVICE_TABLE*)g_OrgSsdt;

				PMU_DEBUG_INFO_LN_EX(" NumberOfServices: %I64x Base: %I64x ", Ssdt->NumberOfServices, Ssdt->ServiceTableBase);

				if (!g_PrivateSsdtTable)
				{
 
					g_PrivateSsdtTable = (PUCHAR)ExAllocatePoolWithTag(NonPagedPool, (Ssdt->NumberOfServices * sizeof(JMPCODE)) + (Ssdt->NumberOfServices * sizeof(ULONG)), 'PSSD');
					g_JmpCodeTable = (JMPCODE*)(g_PrivateSsdtTable + (Ssdt->NumberOfServices * sizeof(ULONG)));
					if (g_PrivateSsdtTable)
					{
						RtlZeroMemory((void *)g_PrivateSsdtTable, (Ssdt->NumberOfServices * sizeof(JMPCODE)) + (Ssdt->NumberOfServices * sizeof(ULONG)));

						BuildPrivateSyscallTable(Ssdt, (PULONG)g_PrivateSsdtTable, g_MyServiceParamTable, g_MyServiceTableDescriptor, (JMPCODE*)g_JmpCodeTable); 
					}
					else
					{
						PMU_DEBUG_INFO_LN_EX("Break;;;;;;");
						break;
					}
				}


				MyOffset = (ULONG)(((ULONG64)g_MyServiceTableDescriptor & 0xFFFFFFFF) - ((ULONG64)&g_ShellCode[i] & 0xFFFFFFFF) - 7);
				PMU_DEBUG_INFO_LN_EX("[Calc2]g_MyServiceTableDescriptor: %p g_ShellCode: %p Result: %x ", g_MyServiceTableDescriptor, &g_ShellCode[i], MyOffset);
				PMU_DEBUG_INFO_LN_EX("[Calc2]Verification Result: %p ", (ULONG)(((ULONG64)&g_ShellCode[i] & 0xFFFFFFFF) + MyOffset + 7));

				// 	.text:000000014006EAB2 4C 8D 15 47 DE 23 00                    lea     r10, KeServiceDescriptorTable
				// put our offset on the lea instruction 
				*(PULONG)&g_ShellCode[i + 3] = MyOffset;
				  
				//we only need calculate low 32bit , if the offset < 0 , it will overflow for bit 33 , we dun need it ~  
				SYSTEM_SERVICE_TABLE* MySsdt = (SYSTEM_SERVICE_TABLE*)(((ULONG64)&g_ShellCode[i] & 0xFFFFFFFF00000000) + ((ULONG)(((ULONG64)&g_ShellCode[i] & 0xFFFFFFFF) + MyOffset + 7)));

				PMU_DEBUG_INFO_LN_EX("[FakeCallTable]SyscallTest:  %p g_MyServiceTableDescriptor: %p", MySsdt, g_MyServiceTableDescriptor);
				PMU_DEBUG_INFO_LN_EX("[FakeCallTable]Num: %x Base: %p CountBase: %p", MySsdt->NumberOfServices, MySsdt->ServiceTableBase, MySsdt->ParamTableBase);   
				PMU_DEBUG_INFO_LN_EX("g_ShellCode: %X ", g_ShellCode);

				SetSyscallProc(51, (ULONG64)MyNtQuerySystemInformation, (PVOID*)&g_MyNtQuerySystemInformation);
				//SetSyscallProc(82, (ULONG64)MyNtCreateFile, (PVOID*)&g_MyNtCreateFile);
				//SetSyscallProc(32, (ULONG64)MyNtQueryVirtualMemory, (PVOID*)&g_MyNtQueryVirtualMemory);
				///pTrapFrame->Rip = (ULONG64)g_ShellCode;
			}
			
			if (g_ShellCode[i] == 0x4C && g_ShellCode[i + 1] == 0x8D && g_ShellCode[i + 2] == 0x1D)
			{
				SYSTEM_SERVICE_TABLE* SSsdt = NULL;
				if (!g_OrgSSsdt)
				{
					g_OrgSSsdt = *(PULONG)&g_ShellCode[i + 3];
					g_OrgSSsdt = (g_OrgSSsdt + pTrapFrame->Rip + i + 7);
				} 

				SSsdt = ((SYSTEM_SERVICE_TABLE*)g_OrgSSsdt)+1;

				PMU_DEBUG_INFO_LN_EX("Shadow NumberOfServices: %I64x Base: %I64x ", SSsdt->NumberOfServices, SSsdt->ServiceTableBase);

				if (!g_PrivateSSsdtTable)
				{

					g_PrivateSSsdtTable = (PUCHAR)ExAllocatePoolWithTag(NonPagedPool, (SSsdt->NumberOfServices * sizeof(JMPCODE)) + (SSsdt->NumberOfServices * sizeof(ULONG)), 'PSSD');
					g_ShadowJmpCodeTable = (JMPCODE*)(g_PrivateSSsdtTable + (SSsdt->NumberOfServices * sizeof(ULONG)));
					if (g_PrivateSSsdtTable)
					{
						RtlZeroMemory((void *)g_PrivateSSsdtTable, (SSsdt->NumberOfServices * sizeof(JMPCODE)) + (SSsdt->NumberOfServices * sizeof(ULONG)));

						BuildPrivateSyscallTable(SSsdt, (PULONG)g_PrivateSSsdtTable, g_MyShadowServiceParamTable, &g_MyShadowServiceTableDescriptor->Win32k, (JMPCODE*)g_ShadowJmpCodeTable);
					}
					else
					{
						PMU_DEBUG_INFO_LN_EX("Break;;;;;;");
						break;
					} 
				}	
				
				memcpy(&g_MyShadowServiceTableDescriptor->NtKernel ,  g_MyServiceTableDescriptor , sizeof(SYSTEM_SERVICE_TABLE));

				MyOffset = (ULONG)(((ULONG64)g_MyShadowServiceTableDescriptor & 0xFFFFFFFF) - ((ULONG64)&g_ShellCode[i] & 0xFFFFFFFF) - 7);
				PMU_DEBUG_INFO_LN_EX("[Calc2]g_MyShadowServiceTableDescriptor: %p g_ShellCode: %p Result: %x ", &g_MyShadowServiceTableDescriptor->Win32k, &g_ShellCode[i], MyOffset);
				PMU_DEBUG_INFO_LN_EX("[Calc2]Verification Result: %p ", (ULONG)(((ULONG64)&g_ShellCode[i] & 0xFFFFFFFF) + MyOffset + 7));
				*(PULONG)&g_ShellCode[i + 3] = MyOffset;

				SYSTEM_SERVICE_TABLE* MySSsdt = (SYSTEM_SERVICE_TABLE*)(((ULONG64)&g_ShellCode[i] & 0xFFFFFFFF00000000) + ((ULONG)(((ULONG64)&g_ShellCode[i] & 0xFFFFFFFF) + MyOffset + 7)));
				PMU_DEBUG_INFO_LN_EX("[FakeCallTable]SyscallTest:  %p g_MyShadowServiceTableDescriptor: %p", MySSsdt, &g_MyShadowServiceTableDescriptor->Win32k);
				PMU_DEBUG_INFO_LN_EX("[FakeCallTable]Num: %x Base: %p CountBase: %p", MySSsdt->NumberOfServices, MySSsdt->ServiceTableBase, MySSsdt->ParamTableBase);
				PMU_DEBUG_INFO_LN_EX("g_ShellCode: %X ", g_ShellCode);
				pTrapFrame->Rip = (ULONG64)g_ShellCode;
			}

		}
	}


	//--------------------------------------------------------------//
	NTSTATUS InitSSDTHook()
	{

		g_FakeSsdt = ExAllocatePoolWithTag(NonPagedPool, PAGE_SIZE * 20, 'ssdt');
		if (!g_FakeSsdt)
		{
			return STATUS_UNSUCCESSFUL;
		} 

		g_ShellCode = (PUCHAR)ExAllocatePoolWithTag(NonPagedPool, PAGE_SIZE, 'cdee');
		if (!g_ShellCode)
		{
			return STATUS_UNSUCCESSFUL;
		}
		
		g_MyServiceTableDescriptor = (SYSTEM_SERVICE_TABLE*)ExAllocatePoolWithTag(NonPagedPool, PAGE_SIZE, 'stdt');
		if (!g_MyServiceTableDescriptor)
		{
			return STATUS_UNSUCCESSFUL;
		}

		g_MyShadowServiceTableDescriptor = (TKeShadowTable*)ExAllocatePoolWithTag(NonPagedPool, PAGE_SIZE, 'stdt');
		if (!g_MyShadowServiceTableDescriptor)
		{
			return STATUS_UNSUCCESSFUL;
		}
		RtlZeroMemory(g_MyShadowServiceTableDescriptor, PAGE_SIZE);
		RtlZeroMemory(g_MyServiceTableDescriptor, PAGE_SIZE);
		RtlZeroMemory(g_FakeSsdt, PAGE_SIZE * 20); 
		RtlZeroMemory(g_ShellCode, PAGE_SIZE); 

		g_IsInit = TRUE;

		return STATUS_SUCCESS;
	}
	//--------------------------------------------------------------//
	NTSTATUS UninitSSDTHook()
	{
		g_IsInit = FALSE;
		if (!g_FakeSsdt)
		{
			ExFreePool(g_FakeSsdt);
			g_FakeSsdt = NULL;
		}

		if (!g_FakeSSsdt)
		{
			ExFreePool(g_FakeSSsdt);
			g_FakeSSsdt = NULL;
		}

		if (!g_ShellCode)
		{
			ExFreePool(g_ShellCode);
			g_ShellCode = NULL;
		}
		return STATUS_SUCCESS;
	}
}
```

`PerfMon/SSDT.h`:

```h
#include <ntddk.h> 

#pragma pack(push , 1)
typedef struct _SYSTEM_SERVICE_TABLE {
	PVOID       ServiceTableBase;
	PVOID       ServiceCounterTableBase;
	ULONGLONG   NumberOfServices;
	PVOID       ParamTableBase;
} SYSTEM_SERVICE_TABLE, *PSYSTEM_SERVICE_TABLE;
#pragma pack(pop)

#pragma pack(push , 1)
	typedef struct
	{
		UCHAR    FixCode[6];
		ULONG64  JmpAddr;
	}JMPCODE;
#pragma pack(pop)
	  
EXTERN_C NTSTATUS InitSSDTHook();
EXTERN_C NTSTATUS UninitSSDTHook();
EXTERN_C VOID  SyscallHandler(PKTRAP_FRAME pTrapFrame);
EXTERN_C ULONG GetOffsetAddress(PULONG SSDTBase, ULONGLONG FuncAddr, CHAR paramCount);
EXTERN_C void* GetSSDTProcAddress(void* SSTD, ULONG Index, PULONG lpParamCount);

```

`PerfMon/Util.cpp`:

```cpp

#include <ntddk.h>  
#include "x86.h"
#include <intrin.h>
extern "C" 
{
	//-----------------------------------------------------------------------------//
	void* UtilGetSystemProcAddress(
		_In_ const wchar_t *proc_name
	) 
	{
		PAGED_CODE(); 
		UNICODE_STRING proc_name_U = {};
		RtlInitUnicodeString(&proc_name_U, proc_name);
		return MmGetSystemRoutineAddress(&proc_name_U);
	}
	 

	//-----------------------------------------------------------------------------//
	NTSTATUS UtilForEachProcessor(
		_In_ NTSTATUS(*callback_routine)(void *),
		_In_ void *context)
	{
		const auto number_of_processors =
			KeQueryActiveProcessorCountEx(ALL_PROCESSOR_GROUPS);
		for (ULONG processor_index = 0; processor_index < number_of_processors; processor_index++)
		{
			PROCESSOR_NUMBER processor_number = {};
			auto status = KeGetProcessorNumberFromIndex(processor_index, &processor_number);
			if (!NT_SUCCESS(status))
			{
				return status;
			}

			// Switch the current processor
			GROUP_AFFINITY affinity = {};
			affinity.Group = processor_number.Group;
			affinity.Mask = 1ull << processor_number.Number;
			GROUP_AFFINITY previous_affinity = {};
			KeSetSystemGroupAffinityThread(&affinity, &previous_affinity);

			// Execute callback
			status = callback_routine(context);

			KeRevertToUserGroupAffinityThread(&previous_affinity);
			if (!NT_SUCCESS(status))
			{
				return status;
			}
		}
		return STATUS_SUCCESS;
	}

	//-----------------------------------------------------------------------------//
	NTSTATUS UtilWriteMsr(Msr msr, ULONG64 Value)
	{
		NTSTATUS status = STATUS_SUCCESS;
		__try
		{
			__writemsr(static_cast<ULONG>(msr),Value);
		}
		__except (0)
		{
			status = STATUS_UNSUCCESSFUL;
		}
		return status;
	}
	
	//-----------------------------------------------------------------------------//
	NTSTATUS UtilReadMsr(Msr msr, ULONG64* Value)
	{
		NTSTATUS status = STATUS_SUCCESS;
		if (!Value)
		{
			status = STATUS_INVALID_PARAMETER;
			return status;
		}
		__try
		{	
			*Value = __readmsr(static_cast<ULONG>(msr));
		}
		__except (0) 
		{
			status = STATUS_UNSUCCESSFUL;
		}
		return status;
	}
	//-----------------------------------------------------------------------------//
}
```

`PerfMon/Util.h`:

```h
#pragma once
#include<ntddk.h>
#include "x86.h"
extern "C" { 
	void*	 UtilGetSystemProcAddress(
		_In_ const wchar_t *proc_name
	);
	
	NTSTATUS UtilForEachProcessor(
		_In_ NTSTATUS(*callback_routine)(void *), 
		_In_ void *context
	);

	NTSTATUS UtilReadMsr(
		Msr msr, 
		ULONG64* Value
	);

	NTSTATUS UtilWriteMsr(
		Msr msr,
		ULONG64 Value
	);
}
```

`PerfMon/x64/Debug/PerfMon.inf`:

```inf
;
; PerfMon.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=PerfMon.cat
DriverVer=09/24/2017,0.45.13.115

[DestinationDirs]
DefaultDestDir = 12

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
PerfMon.sys  = 1,,

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NTamd64

[Standard.NTamd64]
%PerfMon.DeviceDesc%=PerfMon_Device, Root\PerfMon ; TODO: edit hw-id

[PerfMon_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
PerfMon.sys

;--- PerfMon_Device Coinstaller installation ------
;


[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "PerfMon Installation Disk"
PerfMon.DeviceDesc = "PerfMon Device"
PerfMon.SVCDESC = "PerfMon Service"

```

`PerfMon/x86.h`:

```h
#pragma once

#define MSR_IA32_PERF_GLOBAL_STATUS		0x0000038E
#define MSR_IA32_APIC_BASE				0x0000001B			// The APIC base address register

#define MSR_IA32_RTIT_OUTPUT_BASE		0x00000560
#define MSR_IA32_RTIT_OUTPUT_MASK_PTRS	0x00000561
#define MSR_IA32_RTIT_CTL				0x00000570
#define MSR_IA32_RTIT_STATUS			0x00000571
#define MSR_IA32_X2APIC_LVT_PMI			0x00000834

// Filtering by CR3:
#define MSR_IA32_RTIT_CR3_MATCH			0x00000572

// Filtering by IP:
#define MSR_IA32_RTIT_ADDR0_START		0x00000580
#define MSR_IA32_RTIT_ADDR0_END			0x00000581
#define MSR_IA32_RTIT_ADDR1_START		0x00000582
#define MSR_IA32_RTIT_ADDR1_END			0x00000583
#define MSR_IA32_RTIT_ADDR2_START		0x00000584
#define MSR_IA32_RTIT_ADDR2_END			0x00000585
#define MSR_IA32_RTIT_ADDR3_START		0x00000586
#define MSR_IA32_RTIT_ADDR3_END			0x00000587

typedef ULONG DWORD;

/*------------------------------------------------------------------
18.2.1.2 Pre-defined Architectural Performance Events : 
----------------------------------------------------------------
| Bit Position | Event Name              | UMask | Event Select |
| (CPUID.AH.EBX)										        |
 ---------------------------------------------------------------
|  0			UnHalted Core Cycles       00H		 3CH		|
|  1			Instruction Retired        00H		 C0H		|
|  2			UnHalted Reference Cycles  01H		 3CH		|
|  3			LLC Reference			   4FH		 2EH		|
|  4			LLC Misses				   41H		 2EH		|
|  5			Branch Instruction Retired 00H		 C4H		|
|  6			Branch Misses Retired	   00H		 C5H		|
-----------------------------------------------------------------

------------------------------------------------------------------*/
union MSR_IA32_PERFEVTSLX_VERSION1
{
	struct
	{
		ULONG64 EventSelect : 8;	///< [7:0]	 Event Select Field
		ULONG64 UnitMask : 8;		///< [15:8]	 Unit Mask
		ULONG64 Usr : 1;			///< [16]	 User Mode
		ULONG64 Os : 1;				///< [17]	 Operating System Mode
		ULONG64 E : 1;				///< [18]	 Edge Detect
		ULONG64 Pc : 1;				///< [19]	 Pin Control
		ULONG64 Int : 1;			///< [20]	 APIC Interrupt Enable
		ULONG64 Reserved : 1;		///< [21]	 Resevred
		ULONG64 En : 1;				///< [22]	 Enable Counters
		ULONG64 Inv : 1;			///< [23]    Invert
		ULONG64 CounterMask : 8;	///< [31:24] Counter Mask
		ULONG64 Reserved2 : 32;		///< [63:32] Reserved
	}fields;
	ULONG64 all;
}; 
static_assert(sizeof(MSR_IA32_PERFEVTSLX_VERSION1) == 8, "Size check");

union MSR_IA32_PERFEVTSELX_VERSION3
{
	struct
	{
		ULONG64 EventSelect : 8;	///< [7:0]	 Event Select Field
		ULONG64 UnitMask : 8;		///< [15:8]	 Unit Mask
		ULONG64 Usr : 1;			///< [16]	 User Mode
		ULONG64 Os : 1;				///< [17]	 Operating System Mode
		ULONG64 E : 1;				///< [18]	 Edge Detect
		ULONG64 Pc : 1;				///< [19]	 Pin Control
		ULONG64 Int : 1;			///< [20]	 APIC Interrupt Enable
		ULONG64 AnyThread : 1;		///< [21]	 AnyThread
		ULONG64 En : 1;				///< [22]	 Enable Counters
		ULONG64 Inv : 1;			///< [23]    Invert
		ULONG64 CounterMask : 8;	///< [31:24] Counter Mask
		ULONG64 Reserved2 : 32;		///< [63:32] Reserved
	}fields;
	ULONG64 all;
}; 
static_assert(sizeof(MSR_IA32_PERFEVTSELX_VERSION3) == 8, "Size check");


//bit[0]:  0: disable; 1: OS; 2: User; 3: All ring levels 
//bit[1]   Controls for IA32_FIXED_CTRx , x < 3 , Enable for fixed-function PC to increment
union MSR_IA32_FIXED_CTR_CTRL_VERSION2
{
	struct
	{
		ULONG64 En : 2;			 /// < [1:0]	Enable Field,	 
		ULONG64 Reserved1 : 1;   /// < [2]		Reserved1	
		ULONG64 Pmi : 1;		 /// < [3]		PMI Field	,	Enable PMI Overflow	
		ULONG64 En2 : 2;		 /// < [5:4]	Enable Field2
		ULONG64 Reserved2 : 1;	 /// < [6]		Reserved2
		ULONG64 Pmi2 : 1;		 /// < [7]		PMI Field
		ULONG64 En3 : 2;		 /// < [9:8]	Enable Field2
		ULONG64 Reserved4 : 1;	 /// < [10]		Reserved2
		ULONG64 Pmi3 : 1;		 /// < [11]		PMI Field	
		ULONG64 Reserved5 : 52;  /// < [63:12]  Reserved	
	}fields;
	ULONG64 all;
};
static_assert(sizeof(MSR_IA32_FIXED_CTR_CTRL_VERSION2) == 8, "Size check");
 

//bit[0]:  0: disable; 1: OS; 2: User; 3: All ring levels 
//bit[1]   Controls for IA32_FIXED_CTRx , x < 3 , Enable for fixed-function PC to increment
union MSR_IA32_FIXED_CTR_CTRL_VERSION3
{
	struct
	{
		ULONG64 En : 2;			 /// < [1:0]	Enable Field,	 
		ULONG64 Any1 : 1;		 /// < [2]		Reserved1	
		ULONG64 Pmi : 1;		 /// < [3]		PMI Field	,	Enable PMI Overflow	
		ULONG64 En2 : 2;		 /// < [5:4]	Enable Field2
		ULONG64 Any12 : 1;		 /// < [6]		Reserved2
		ULONG64 Pmi2 : 1;		 /// < [7]		PMI Field
		ULONG64 En3 : 2;		 /// < [9:8]	Enable Field2
		ULONG64 Any13 : 1;		 /// < [10]		Reserved2
		ULONG64 Pmi3 : 1;		 /// < [11]		PMI Field	
		ULONG64 Reserved5 : 52;  /// < [63:12]  Reserved	
	}fields;
	ULONG64 all;
};
static_assert(sizeof(MSR_IA32_FIXED_CTR_CTRL_VERSION3) == 8, "Size check");

union MSR_IA32_PERF_GLOBAL_CTRL_VERSION2
{
	struct
	{
		ULONG64 EnablePmc0 : 1;			 /// < [0]	IA32_PMC0 Enabled
		ULONG64 EnablePmc1 : 1;			 /// < [1]	IA32_PMC0 Enabled
		ULONG64 Reserved   : 30;		 /// < [31:2]
		ULONG64	EnableCTR0 : 1;			 /// < [32] IA32_FIXED_CTR0 enable
		ULONG64	EnableCTR1 : 1;			 /// < [33] IA32_FIXED_CTR1 enable
		ULONG64	EnableCTR2 : 1;			 /// < [34] IA32_FIXED_CTR2 enable
		ULONG64	Reserved2  : 29;		 /// < [63:35]
	}fields;
	ULONG64 all;
};
static_assert(sizeof(MSR_IA32_PERF_GLOBAL_CTRL_VERSION2) == 8, "Size check");


union MSR_IA32_PERF_GLOBAL_STATUS_VERSION2
{
	struct
	{
		ULONG64 PMC0Overflow : 1;	 /// < [0]	IA32_PMC0 OverFlow
		ULONG64 PMC1Overflow : 1;	 /// < [1]	IA32_PMC0 OverFlow
		ULONG64 Reserved : 30;		 /// < [31:2]
		ULONG64	CTR0OverFlow : 1;	 /// < [32] IA32_FIXED_CTR0 OverFlow
		ULONG64	CTR1OverFlow : 1;	 /// < [33] IA32_FIXED_CTR1 OverFlow
		ULONG64	CTR2OverFlow : 1;	 /// < [34] IA32_FIXED_CTR2 OverFlow
		ULONG64	Reserved2 : 27;		 /// < [61:35]
		ULONG64 OvfDSBuffer : 1;	 /// < [62]
		ULONG64 CondChgd : 1;		 /// < [63]
	}fields;
	ULONG64 all;
};
static_assert(sizeof(MSR_IA32_PERF_GLOBAL_STATUS_VERSION2) == 8, "Size check");


union MSR_IA32_DEBUGCTL
{
	struct
	{
		ULONG64 LBR : 1;				/// < [0]	 
		ULONG64 BTF : 1;				/// < [1] 
		ULONG64 Reserved1 : 4;			/// < [5:2]
		ULONG64	TR : 1;					/// < [6]  
		ULONG64	BTS : 1;				/// < [7]  
		ULONG64	BTINT : 1;				/// < [8]  
		ULONG64	BTS_OFF_OS : 1;			/// < [9]
		ULONG64 BTS_OFF_USR: 1;			/// < [10]
		ULONG64 FRZ_LBRS_ON_PMI : 1	;	/// < [11]
		ULONG64 FRZ_PERFMON_ON_PMI : 1; /// < [12]
		ULONG64 UNCORE_PMI_EN : 1;		/// < [13]
		ULONG64 SMM_FRZ : 1;			/// < [14]
		ULONG64 Reserved2 : 49;			/// < [63:15]
	}fields;	
	ULONG64 all;
};
static_assert(sizeof(MSR_IA32_DEBUGCTL) == 8, "Size check");

union MSR_IA32_PERF_GLOBAL_CTRL
{
	struct
	{
		ULONG64 EN_PC0 : 1;				/// < [0]	 
		ULONG64 EN_PC1 : 1;				/// < [1] 
		ULONG64 EN_PC2 : 1;				/// < [2]
		ULONG64	EN_PC3 : 1;				/// < [3]  
		ULONG64	Reserved : 28;			/// < [31:4]  
		ULONG64	EN_FC0 : 1;				/// < [32]  
		ULONG64	EN_FC1 : 1;				/// < [33]
		ULONG64 EN_FC2 : 1;				/// < [34] 
		ULONG64 Reserved2 : 29;			/// < [63:35]
	}fields;
	ULONG64 all;
};
static_assert(sizeof(MSR_IA32_PERF_GLOBAL_CTRL) == 8, "Size check");


union MSR_IA32_MISC_ENABLE
{
	struct
	{
		ULONG64 FastStrEnable : 1;				/// < [0]	 
		ULONG64 Reserved : 2;					/// < [2:1] 
		ULONG64 AutoThermalCtrlCirEn: 1;		/// < [3]
		ULONG64	Reserved1 : 3;					/// < [6:4]  
		ULONG64	PerfMonAvaliable : 1;			/// < [7]  
		ULONG64	Reserved2 : 3;					/// < [10:8]  
		ULONG64	BTSUnavaliable : 1;				/// < [11]
		ULONG64 PEBSUnavaiable : 1;				/// < [12] 
		ULONG64 Reserved3 : 3;					/// < [15:13]
		ULONG64 SpeedStepEnable : 1;			/// < [16]
		ULONG64 Reserved5 : 1;					/// < [17]
		ULONG64 MonitorFsmEnable : 1;			/// < [18]
		ULONG64 Reserved6 : 3;					/// < [21:19]
		ULONG64 LimitCpuidMaxval : 1;			/// < [22]
		ULONG64 xTprMsgRwDisable : 1;			/// < [23]
		ULONG64 Reserved7 : 10;					/// < [33:24]
		ULONG64 XdDisable : 1;					/// < [34]
		ULONG64 Reserved8 : 29;					/// < [63:35]
	}fields;
	ULONG64 all;
};
static_assert(sizeof(MSR_IA32_MISC_ENABLE) == 8, "Size check");


union MSR_IA32_PEBS_ENABLE
{
	struct
	{
		ULONG64 EnablePmc0 : 1;	/// < [0]	 
		ULONG64 EnablePmc1 : 1;	/// < [1]	 
		ULONG64 EnablePmc2 : 1;	/// < [2]	 
		ULONG64 EnablePmc3 : 1;	/// < [3]	 
		ULONG64 Reserved : 28;	/// < [31:4]
		ULONG64 LL_EN_PMC0 : 1;	/// < [32]
		ULONG64 LL_EN_PMC1 : 1;	/// < [33]
		ULONG64 LL_EN_PMC2 : 1;	/// < [34]
		ULONG64 LL_EN_PMC3 : 1;	/// < [35]
		ULONG64 Reserved2 : 28;	/// < [63:36]
	}fields;
	ULONG64 all;
};
static_assert(sizeof(MSR_IA32_PEBS_ENABLE) == 8, "Size check");


union MSR_IA32_PERF_CAPABILITIES
{
	struct {
		ULONG64 LbrFormat : 6;			/// <[5:0]
		ULONG64 PebsTrap : 1;			/// <[6]
		ULONG64 PebsSaveArchRegs : 1;	/// <[7]
		ULONG64 PebsRecordFormat : 4;	/// <[11:8]
		ULONG64 FreezeWhenSmm : 1;		/// <[12]
		ULONG64 FullWidthCounter : 1;	/// <[13]
		ULONG64 Reserved : 50;			/// <[63:14]
	}fields;
	ULONG64 all;
};
static_assert(sizeof(MSR_IA32_PERF_CAPABILITIES) == 8, "Size check");


union MSR_IA32_PERF_GLOBAL_OVF_CTL
{
	struct
	{
		ULONG64 Ia32Pmc0Ovf : 1;
		ULONG64 Ia32Pmc1Ovf : 1;
		ULONG64 Reserved : 30;
		ULONG64 Ia32FixedCtr0Ovf : 1;
		ULONG64 Ia32FixedCtr1Ovf : 1;
		ULONG64 Ia32FixedCtr2Ovf : 1;
		ULONG64 Reserved1 : 27;
		ULONG64 ClrCondChgd : 1;		
		ULONG64 ClrOvfDSBuffer : 1; 
	}fields;
	ULONG64 all;
};
static_assert(sizeof(MSR_IA32_PERF_GLOBAL_OVF_CTL) == 8, "Size check");

union MSR_IA32_PERF_GLOBAL_OVF_CTRL
{
	struct
	{
		ULONG64 OvfPmc0 : 1;			/// <[0]
		ULONG64 OvfPmc1 : 1;			/// <[1]
		ULONG64 OvfPmc2 : 1;			/// <[2]
		ULONG64 OvfPmcn : 1;			/// <[3]
		ULONG64 Reserved : 28;			/// <[n:4] , n If CPUID.0AH: EAX[15:8] > n
		ULONG64 OvfFixedCtr0 : 1;		/// <[32]
		ULONG64 OvfFixedCtr1 : 1;		/// <[33]
		ULONG64 OvfFixedCtr2 : 1;		/// <[34]
		ULONG64 Reserved2 : 20;			/// <[54:35]
		ULONG64 TraceToPaPmi : 1;		/// <[55]
		ULONG64 Reserved3 : 5;			/// <[60:56]
		ULONG64  OvfUnCore : 1;			/// <[61]
		ULONG64  OvfBuf : 1;			/// <[62]
		ULONG64  CondChgd : 1;			/// <[63]
	}fields;
	ULONG64 all;
}; 
static_assert(sizeof(MSR_IA32_PERF_GLOBAL_OVF_CTRL) == 8, "Size check");


// A local vector table (LVT) entry
union LVT_Entry {
	struct {
		USHORT Vector : 8;					// [0:7] - The Vector number
		USHORT Reserved1 : 4;				// [8:11] - Reserved
		USHORT DeliveryStatus : 1;			// [12] - Delivery status: 0 - Idle; 1 - Send Pending;
		USHORT Reserved2 : 3;				// [13:15] - Reserved
		USHORT Masked : 1;					// [16] - Masked: 0 - Not Masked; 1 - Masked
		USHORT TimerMode : 2;				// [17:18] - Timer mode: 00 - One-shot; 01 - Periodic; 10 - TSC-Deadline;
		USHORT Reserved3 : 13;				// [19:31] - Reserved
	} Fields;
	DWORD All;
};
static_assert(sizeof(LVT_Entry) == 4, "Size check");

// The APIC Base physical address MSR in xAPIC Mode
union MSR_IA32_APIC_BASE_DESC {
	struct {
		ULONGLONG Reserved1 : 8;			// [0:7] - Reserved
		ULONGLONG Bsp : 1;					// [8] - Indicates if the processor is the bootstrap processor (BSP)
		ULONGLONG Reserved2 : 1;			// [9] - Reserved
		ULONGLONG EXTD : 1;					// [10] - Enable x2APIC mode
		ULONGLONG EN : 1;					// [11] - APIC global enable/disable
		ULONGLONG ApicBase : 24;			// [12:35] - Base Physical Address
	} Fields;
	ULONGLONG All;
};
static_assert(sizeof(MSR_IA32_APIC_BASE_DESC) == 8, "Size check");

// The IA32_PERF_GLOBAL_STATUS descriptor of Intel Broadwell microarchitecture 
union MSR_IA32_PERF_GLOBAL_STATUS_DESC {
	struct {
		DWORD PMC0_OVF : 1;					// [0] - Read only
		DWORD PMC1_OVF : 1;					// [1] - Read only 
		DWORD PMC2_OVF : 1;					// [2] - Read only
		DWORD PMC3_OVF : 1;					// [3] - Read only
		DWORD PMC4_OVF : 1;					// [4] - Read only (if PMC4 present)
		DWORD PMC5_OVF : 1;					// [5] - Read only (if PMC5 present) 
		DWORD PMC6_OVF : 1;					// [6] - Read only (if PMC6 present)
		DWORD PMC7_OVF : 1;					// [7] - Read only (if PMC7 present)
		DWORD Reserved : 24;				// [8:31] - Reserved
		DWORD FIXED_CTR0 : 1;				// [32] - FIXED_CTR0 Overflow (RO)
		DWORD FIXED_CTR1 : 1;				// [33] - FIXED_CTR1 Overflow (RO)
		DWORD FIXED_CTR2 : 1;				// [34] - FIXED_CTR2 Overflow (RO)
		DWORD Reserved2 : 20;				// [35:54] - Reserved
		DWORD TraceToPAPMI : 1;				// [55] - The ToPA PMI Interrupt status
		DWORD Reserved3 : 5;				// [56:60] - Reserved
		DWORD Ovf_UncorePMU : 1;			// [61]
		DWORD Ovf_Buffer : 1;				// [62]
		DWORD CondChgd : 1;					// [63]
	} Fields;
	ULONGLONG All;
};
static_assert(sizeof(MSR_IA32_PERF_GLOBAL_STATUS_DESC) == 8, "Size check");

#pragma pack(push,1)
typedef struct IDTDESC
{
	USHORT limit;
	ULONG64 BASE;
}IDTDESC, *PIDTDESC;
static_assert(sizeof(IDTDESC) == 10, "Size check");


typedef union _KIDTENTRY64
{
	struct
	{
		USHORT OffsetLow;
		USHORT Selector;
		USHORT IstIndex : 3;
		USHORT Reserved0 : 5;
		USHORT Type : 5;
		USHORT Dpl : 2;
		USHORT Present : 1;
		USHORT OffsetMiddle;
		ULONG  OffsetHigh;
		ULONG  Reserved1;
	}u;
	UINT64 Alignment;
} KIDTENTRY64, *PKIDTENTRY64;
#pragma pack(pop) 
/// See: MODEL-SPECIFIC REGISTERS (MSRS)
enum class Msr : unsigned int {
	Ia32ApicBase = 0x01B,

	Ia32FeatureControl = 0x03A,
	Ia32PMCx = 0xC1,
	Ia32SysenterCs = 0x174,
	Ia32SysenterEsp = 0x175,
	Ia32SysenterEip = 0x176,
	Ia32PerfEvtseLx = 0x186,
	Ia32Debugctl = 0x1D9,

	//PMU Related
	Ia32FixedCtrl0 = 0x309,
	Ia32FixedCtrl1 = 0x30A,
	Ia32FixedCtrl2 = 0x30B,
	Ia32PerfCaps = 0x345,
	Ia32FixedCtrl = 0x38D,
	Ia32PerfGlobalStatus = 0x38E,	// allows software to query counter overflow conditions on any combination of fixed - function PMCs or general - purpose PMCs via a single RDMSR.
	Ia32PerfGlobalCtrl = 0x38F,	// allows software to enable/disable event counting of all or any combination of fixed - function PMCs(IA32_FIXED_CTRx) or any general - purpose PMCs via a single WRMSR.
	Ia32PerfGlobalOvfCtrl = 0x390,  // allows software to clear counter overflow conditions on any combination of fixed - function PMCs or general - purpose PMCs via a single WRMSR.


	//PMU PEBS Related
	Ia32MiscEnable = 0x1A0,
	Ia32PebsEnable = 0x3F1,
	Ia32DsArea = 0x600,

	Ia32VmxBasic = 0x480,
	Ia32VmxPinbasedCtls = 0x481,
	Ia32VmxProcBasedCtls = 0x482,
	Ia32VmxExitCtls = 0x483,
	Ia32VmxEntryCtls = 0x484,
	Ia32VmxMisc = 0x485,
	Ia32VmxCr0Fixed0 = 0x486,
	Ia32VmxCr0Fixed1 = 0x487,
	Ia32VmxCr4Fixed0 = 0x488,
	Ia32VmxCr4Fixed1 = 0x489,
	Ia32VmxVmcsEnum = 0x48A,
	Ia32VmxProcBasedCtls2 = 0x48B,
	Ia32VmxEptVpidCap = 0x48C,
	Ia32VmxTruePinbasedCtls = 0x48D,
	Ia32VmxTrueProcBasedCtls = 0x48E,
	Ia32VmxTrueExitCtls = 0x48F,
	Ia32VmxTrueEntryCtls = 0x490,
	Ia32VmxVmfunc = 0x491,

	Ia32x2ApivIvtPmi = 0x00000834,

	Ia32Efer = 0xC0000080,
	Ia32Star = 0xC0000081,
	Ia32Lstar = 0xC0000082,

	Ia32Fmask = 0xC0000084,

	Ia32FsBase = 0xC0000100,
	Ia32GsBase = 0xC0000101,
	Ia32KernelGsBase = 0xC0000102,
	Ia32TscAux = 0xC0000103,
	 
};


enum class CpuMircoArchModel : unsigned int
{
	SandyBridge = 0x2A,
	SandyBridge_E = 0x2D,
	IvyBridge = 0x3A,

	Arrandale = 0x25,
	Gulftown  = 0x2C,
	Westmere_Ex = 0x2F,

};
```

`README.md`:

```md
# PerfMon

[![Codacy Badge](https://api.codacy.com/project/badge/Grade/cbd28311602e4273bf324fa2a6ebfe7b)](https://app.codacy.com/gh/Kelvinhack/PerfMon?utm_source=github.com&utm_medium=referral&utm_content=Kelvinhack/PerfMon&utm_campaign=Badge_Grade)

Performance Monitoring Unit Research for hooking SSDT on all kind Windows 10

```

`TestBp/Source.cpp`:

```cpp
#include "stdafx.h"
#include "Windows.h"

typedef NTSTATUS(__fastcall *pMyNtQuerySystemInformation)(
	_In_      ULONG SystemInformationClass,
	_Inout_   PVOID                    SystemInformation,
	_In_      ULONG                    SystemInformationLength,
	_Out_opt_ PULONG                   ReturnLength
	);

typedef NTSTATUS(__fastcall *pNtQueryVirtualMemory)(
	_In_      HANDLE                   ProcessHandle,
	_In_opt_  PVOID                    BaseAddress,
	_In_      ULONG					   MemoryInformationClass,
	_Out_     PVOID                    MemoryInformation,
	_In_      SIZE_T                   MemoryInformationLength,
	_Out_opt_ PSIZE_T                  ReturnLength
	);

pMyNtQuerySystemInformation pfn;

int main() 
{ 	
	pfn = (pMyNtQuerySystemInformation)GetProcAddress(LoadLibrary(L"ntdll.dll"), "NtQuerySystemInformation");
	if (!pfn)
	{
		printf("error getting func addr");
		
	}

	while (true) 
	{
		system("pause");
		for (int i = 0; i < 1000000; i++)
		{
			__try
			{
			
				printf("[i: %x] return: %x \r\n", i, pfn(0x4567 , 0, 0, 0)); 
		 
			}
			__except (1)
			{

			}
		} 
		pfn(0x4568, 0, 0, 0);
	}
	system("pause");
	return 0;
}
```

`TestBp/TestBp.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{B4C142C1-5D8A-4C9A-8891-D8730C363B3A}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>TestBp</RootNamespace>
    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Text Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Source.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="x64.asm" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`TestBp/TestBp.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Text Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Source.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="x64.asm">
      <Filter>Source Files</Filter>
    </None>
  </ItemGroup>
</Project>
```

`TestBp/stdafx.cpp`:

```cpp
// stdafx.cpp : source file that includes just the standard includes
// TestBp.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

```

`TestBp/stdafx.h`:

```h
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#include "targetver.h"

#include <stdio.h>
#include <tchar.h>



// TODO: reference additional headers your program requires here

```

`TestBp/targetver.h`:

```h
#pragma once

// Including SDKDDKVer.h defines the highest available Windows platform.

// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.

#include <SDKDDKVer.h>

```