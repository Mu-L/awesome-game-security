Project Path: arc_KelvinMsft_ThreadSpy_ahuskoru

Source Tree:

```txt
arc_KelvinMsft_ThreadSpy_ahuskoru
├── README.md
├── ThreadSpy
│   ├── Apic.h
│   ├── Common.cpp
│   ├── Common.h
│   ├── Driver.cpp
│   ├── Log.h
│   ├── PMI.cpp
│   ├── PMI.h
│   ├── PMU.cpp
│   ├── PMU.h
│   ├── ThreadSpy.inf
│   ├── ThreadSpy.vcxproj
│   ├── ThreadSpy.vcxproj.filters
│   ├── ThreadSpy.vcxproj.user
│   ├── Util.cpp
│   ├── Util.h
│   └── x86.h
└── ThreadSpy.sln

```

`README.md`:

```md
# ThreadSpy

[![Codacy Badge](https://api.codacy.com/project/badge/Grade/4df8791202a94e6aa6a8c678816230ab)](https://app.codacy.com/gh/Kelvinhack/ThreadSpy?utm_source=github.com&utm_medium=referral&utm_content=Kelvinhack/ThreadSpy&utm_campaign=Badge_Grade)

# Introduction
ThreadSpy is hardware assisted thread hijacker, it hijacks all executing thread on-the-fly without hooking any bytes of instruction, you can inject all kind of code or R/W memory in the desired process context for any purpose. You can adjust the frequency and make it randomly hijack threads, regardless of kernel / user mode.

# Build Environment
* Visual Studio 2015 update 3
* Windows SDK 10
* Windowr Driver Kit 10

# Demostration
<img src="https://user-images.githubusercontent.com/22551808/82997626-7642a000-9fbb-11ea-8ddb-868ecbb6ecab.PNG"> </img>

```

`ThreadSpy.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 14
VisualStudioVersion = 14.0.25420.1
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ThreadSpy", "ThreadSpy\ThreadSpy.vcxproj", "{F01C4412-F73C-4BD8-A954-84E2F3BD1251}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Debug|x64.ActiveCfg = Debug|x64
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Debug|x64.Build.0 = Debug|x64
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Debug|x64.Deploy.0 = Debug|x64
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Debug|x86.ActiveCfg = Debug|Win32
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Debug|x86.Build.0 = Debug|Win32
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Debug|x86.Deploy.0 = Debug|Win32
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Release|x64.ActiveCfg = Release|x64
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Release|x64.Build.0 = Release|x64
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Release|x64.Deploy.0 = Release|x64
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Release|x86.ActiveCfg = Release|Win32
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Release|x86.Build.0 = Release|Win32
		{F01C4412-F73C-4BD8-A954-84E2F3BD1251}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`ThreadSpy/Apic.h`:

```h
#pragma once


#include <ntddk.h>
extern "C"
{
	typedef ULONG DWORD;

 


 
}
```

`ThreadSpy/Common.cpp`:

```cpp
#include <ntddk.h>
#include "Common.h"
#include "Log.h"
extern "C"
{ 
	NTSTATUS UtilSleep(LONG Millisecond) 
	{
		PAGED_CODE();

		LARGE_INTEGER interval = {};
		interval.QuadPart = -(10000 * Millisecond);  // msec
		return KeDelayExecutionThread(KernelMode, FALSE, &interval);
	}

	//----------------------------------------------------------------------------------------//
	ULONG GetIndexByID(ULONG_PTR ID, ULONG TableSize)
	{
		return ID % TableSize;
	}
	//----------------------------------------------------------------------------------------//
	void ClearHashById(HASHTABLE* HashTable, ULONG TableSize, ULONG_PTR ID)
	{
		ULONG Index = GetIndexByID(ID, TableSize);
		HashTable[Index].ID = 0;
		HashTable[Index].Value = NULL;
		PMU_DEBUG_INFO_LN_EX("Clear - Index: %x Id: %I64x ", Index, ID);
	}

	//----------------------------------------------------------------------------------------//
	void SetHash(HASHTABLE* HashTable, ULONG TableSize, ULONG_PTR ID, ULONG lpNode)
	{
		ULONG Index = GetIndexByID(ID, TableSize);
		HashTable[Index].ID = ID;
		HashTable[Index].Value = lpNode;
		PMU_DEBUG_INFO_LN_EX("Add - Index: %x Id: %I64x ", Index, ID);
	}

	//----------------------------------------------------------------------------------------//
	BOOLEAN GetHashIndexById(HASHTABLE* HashTable, ULONG TableSize, ULONG_PTR ID, ULONG* count)
	{
		ULONG_PTR Index = GetIndexByID(ID, TableSize);
		if (HashTable[Index].ID == ID)
		{
			if (count)
			{
				*count = HashTable[Index].Value;
			}

			return TRUE;
		}
		return FALSE;
	}
	//--------------------------------------------------------------------------------------------//
	 
}
```

`ThreadSpy/Common.h`:

```h
#pragma once

#include <intrin.h>
#include "x86.h"
#include "Apic.h"
#include "Util.h" 

#define START_DO_WHILE do{
#define END_DO_WHILE   }while(FALSE); 

#define DRV_NAME	  "PerfMon"

extern "C" 
{
	typedef ULONG64 u64;

	typedef struct _PMU_INFORMATION
	{
		UCHAR SupportedVersion;
		UCHAR SupportedFixedFunction;
		UCHAR SupportedBitWidth;
		UCHAR SupportedAnyThread;
		UCHAR SupportedNumOfPMCs;
		UCHAR SupporteWidthPerPMCs;
		UCHAR SupportedPerfEvents;
		UCHAR IsSupportPebs;
		UCHAR IsSupportEmon;
	}PMUINFO, *PPMUINFO;



	struct pebs_v1 {
		u64 flags;
		u64 ip;
		u64 ax;
		u64 bx;
		u64 cx;
		u64 dx;
		u64 si;
		u64 di;
		u64 bp;
		u64 sp;
		u64 r8;
		u64 r9;
		u64 r10;
		u64 r11;
		u64 r12;
		u64 r13;
		u64 r14;
		u64 r15;
		u64 status;
		u64 dla;
		u64 dse;
		u64 lat;
	};

	struct pebs_v2 {
		struct pebs_v1 v1;
		u64 eventing_ip;
		u64 tsx;
	};

	struct pebs_v3 {
		struct pebs_v2 v2;
		u64 tsc;
	};


	struct debug_store {
		u64 bts_base;
		u64 bts_index;
		u64 bts_max;
		u64 bts_thresh;

		u64 pebs_base;
		u64 pebs_index;
		u64 pebs_max;
		u64 pebs_thresh;
		u64 pebs_reset[4];
	};


	typedef struct _HASH_TABLE
	{
		ULONG_PTR ID;
		ULONG	  Value;
	}HASHTABLE, *PHASHTABLE;

	void SetHash(HASHTABLE* HashTable, ULONG TableSize, ULONG_PTR ID, ULONG count);
	BOOLEAN GetHashIndexById(HASHTABLE* HashTable, ULONG TableSize, ULONG_PTR ID, ULONG* count);
	void ClearHashById(HASHTABLE* HashTable, ULONG TableSize, ULONG_PTR ID);
	ULONG GetIndexByID(ULONG_PTR ID, ULONG TableSize);

	NTSTATUS UtilSleep(LONG Millisecond);
}
```

`ThreadSpy/Driver.cpp`:

```cpp
  
#include <ntddk.h> 
#include "Apic.h"
#include "x86.h"
#include "PMU.h"
#include "Common.h"
#include "PMI.h"
#include "Log.h"
extern "C"
{
  
	//////////////////////////////////////////////////////////////////
	////	Prototype	
	////	
	////
 

	//////////////////////////////////////////////////////////////////
	////	Global Variable	
	////	
	////
 
	PMUINFO			   g_EnvironmentInfo;

	//////////////////////////////////////////////////////////////////
	////	Marco
	////	
	////
 
	 
 
	//--------------------------------------------------------------//
	VOID DrvUnload(
			_In_ struct _DRIVER_OBJECT *DriverObject)
	{
		UNREFERENCED_PARAMETER(DriverObject);
		UnregisterPmiInterrupt();
		return;
	} 
 
	//--------------------------------------------------------------//
	NTSTATUS DriverEntry(
		_In_	PDRIVER_OBJECT DrvObj,
		_In_	PCUNICODE_STRING RegistryString)
	{ 
		UNREFERENCED_PARAMETER(RegistryString);
		NTSTATUS status = STATUS_SUCCESS;
		START_DO_WHILE
		
		status = RegisterPmiInterrupt();
		if (!NT_SUCCESS(status))
		{ 
			break;
		}
		
		PMU_DEBUG_INFO_LN_EX("Starting Environment Check... ");

		status = PMUEnvironmentCheck(&g_EnvironmentInfo);
		if (!NT_SUCCESS(status))
		{ 
			break;
		}
		 
		status = UtilForEachProcessor(
			PMUInitiailization, &g_EnvironmentInfo
		);
		if (!NT_SUCCESS(status))
		{ 
			break;
		}

		PMU_DEBUG_INFO_LN_EX("----------------------------------------------------------------------");
		PMU_DEBUG_INFO_LN_EX("SupportedVersion:%-30d",g_EnvironmentInfo.SupportedVersion		);
		PMU_DEBUG_INFO_LN_EX("SupportedFixedFunction:%-30d",g_EnvironmentInfo.SupportedFixedFunction	);
		PMU_DEBUG_INFO_LN_EX("SupportedBitWidth:%-30d "	,g_EnvironmentInfo.SupportedBitWidth		);
		PMU_DEBUG_INFO_LN_EX("SupportedAnyThread:%-30d "	,g_EnvironmentInfo.SupportedAnyThread		);
		PMU_DEBUG_INFO_LN_EX("SupportedNumOfPMCs:%-30d"	,g_EnvironmentInfo.SupportedNumOfPMCs		);
		PMU_DEBUG_INFO_LN_EX("SupporteWidthPerPMCs:%-30d"	,g_EnvironmentInfo.SupporteWidthPerPMCs	);
		PMU_DEBUG_INFO_LN_EX("SupportedPerfEvents:%-30d"	,g_EnvironmentInfo.SupportedPerfEvents		);
		PMU_DEBUG_INFO_LN_EX("IsSupportPebs:%-30d"		,g_EnvironmentInfo.IsSupportPebs				); 
		PMU_DEBUG_INFO_LN_EX("IsSupportEmon:%-30d", g_EnvironmentInfo.IsSupportEmon);
		 
		PMU_DEBUG_INFO_LN_EX("-----------------------------------------------------------------------");
		
		DrvObj->DriverUnload = DrvUnload;

		END_DO_WHILE

		return status;
	}
	//--------------------------------------------------------------//
}
```

`ThreadSpy/Log.h`:

```h
#pragma once

#define PMU_NATIVE_DEBUG_INFO(format, ...)	DbgPrintEx(0,0,format,__VA_ARGS__) 
		
#define PMU_COMMON_DEBUG_INFO(format, ...)	PMU_NATIVE_DEBUG_INFO("[%s] => [%d] : "format, __FILE__ ,  __LINE__,  __VA_ARGS__)
#define PMU_DEBUG_INFO_LN()					PMU_NATIVE_DEBUG_INFO("\r\n")
#define PMU_DEBUG_INFO_LN_EX(format, ...)	PMU_COMMON_DEBUG_INFO(format"\r\n",__VA_ARGS__)


```

`ThreadSpy/PMI.cpp`:

```cpp
#include <ntddk.h>
#include "PMI.h"
#include "Apic.h"
#include "Common.h"
#include "Log.h"
#include "x86.h"  
#include "ntimage.h"
#include "PMU.h"
extern "C"
{
	//////////////////////////////////////////////////////////////////
	////	Types
	////	 

	PCHAR PsGetProcessImageFileName(PEPROCESS);
	
 
	// The PMI Handler function prototype
	typedef VOID(*PMIHANDLER)(
		_In_ PKTRAP_FRAME TrapFrame
		);

	typedef struct _DRIVER_GLOBAL_DATA {
		BOOLEAN bPtSupported;								// TRUE if Intel PT is supported 
		BOOLEAN bCpuX2ApicMode;								// TRUE if the system processors are in x2Apic Mode   
		PMIHANDLER pOldPmiHandler;							// The OLD PMI handler routine (if any)   
		ULONG* lpApicBase;									// The APIC I/O memory VA    
	}DRIVER_GLOBAL_DATA, *PDRIVER_GLOBAL_DATA;
 

 

	///////////////////////////////////////////////////////////////////////
	//// Global Variable 
	////
	 
	DRIVER_GLOBAL_DATA			g_pDrvData = { 0 };
	bool						g_IsUninit = false;
	HASHTABLE					g_inst_table[10000] = { 0 };
	ULONG_PTR					g_InterruptFuncTable[256] = { 0 };
 
	ULONG_PTR					g_IntCount = 0;

	///////////////////////////////////////////////////////////////////////
	//// Marco
	//// 
 
 
	 
	//--------------------------------------------------------------//
	NTSTATUS DispatchPmiEvent(PKTRAP_FRAME pTrapFrame)
	{
		pTrapFrame;
		NTSTATUS status = STATUS_SUCCESS;
		g_IntCount++;
		
		if (!g_IntCount || ((g_IntCount % 1000000) != 0)) {
			return status;
		}

		PMU_DEBUG_INFO_LN_EX("[%d] Process= %s \t PID= %p \t TID= %p ", KeGetCurrentProcessorNumber(), PsGetProcessImageFileName(PsGetCurrentProcess()), PsGetCurrentProcessId(), PsGetCurrentThreadId());
		PMU_DEBUG_INFO_LN_EX("RIP= %p RAX= %p RBX= %p RCX= %p \r\n RDX= %p RSI= %p RSP= %p RBP= %p ", pTrapFrame->Rip, pTrapFrame->Rax, pTrapFrame->Rbx, pTrapFrame->Rcx,
			pTrapFrame->Rdx, pTrapFrame->Rsi, pTrapFrame->Rsp, pTrapFrame->Rbp);
		return status;
	} 


	//--------------------------------------------------------------//
	NTSTATUS InitInterrupt()
	{
		IDTDESC info = { 0 };
		PKIDTENTRY64 IdtEntry;
		__sidt(&info);
		IdtEntry = (PKIDTENTRY64)info.BASE;
		for (int i = 0; i < 256; i++)
		{
			ULONG64 handler = 0;
			handler = ((ULONG64)IdtEntry[i].u.OffsetLow | ((ULONG64)IdtEntry[i].u.OffsetMiddle << 16) | ((ULONG64)IdtEntry[i].u.OffsetHigh << 32));
			g_InterruptFuncTable[i] = handler;
			PMU_DEBUG_INFO_LN_EX("Idt[%x]: %p", i, handler);
		}
		return STATUS_SUCCESS;

	}
	//--------------------------------------------------------------//
	NTSTATUS InitApic()
	{
		// First of all we need to search for HalpLocalApic symbol
		MSR_IA32_APIC_BASE_DESC ApicBase = { 0 };				// In Multi-processors systems this address could change
		NTSTATUS status = STATUS_SUCCESS;
		status = UtilReadMsr(Msr::Ia32ApicBase, &ApicBase.All);			// In Windows systems all the processors LVT are mapped at the same physical address

		if (!NT_SUCCESS(status))
		{
			return status;
		}

		if (!ApicBase.Fields.EXTD)
		{
			ULONG* lpdwApicBase = NULL;
			PHYSICAL_ADDRESS apicPhys = { 0 };

			apicPhys.QuadPart = ApicBase.All & (~0xFFFi64);
			lpdwApicBase = (ULONG*)MmMapIoSpace(apicPhys, 0x1000, MmNonCached);

			if (lpdwApicBase)
			{
				DbgPrintEx(0, 0, "[" DRV_NAME "] Successfully mapped the local APIC to 0x%llX.\r\n", lpdwApicBase);
				g_pDrvData.lpApicBase = lpdwApicBase;
			}
			else
			{
				status = STATUS_NOT_SUPPORTED;
				return status;
			}
		}
		else
		{
			// Current system uses x2APIC mode, no need to map anything
			g_pDrvData.bCpuX2ApicMode = TRUE;
		}
		return status;
	}
	//--------------------------------------------------------------//
	NTSTATUS SetUpPerformanceInterrutpHandler(PMIHANDLER Handler)
	{
		PMIHANDLER pNewPmiHandler = Handler;
		NTSTATUS ntStatus = HalSetSystemInformation(HalProfileSourceInterruptHandler, sizeof(PMIHANDLER), (PVOID)&pNewPmiHandler);
		if (NT_SUCCESS(ntStatus))
		{
			DbgPrintEx(0, 0, "[" DRV_NAME "] Successfully registered system PMI handler to function 0x%llX.\r\n", (PVOID)pNewPmiHandler);
		}
		return ntStatus;
	}
	//--------------------------------------------------------------//
	NTSTATUS ResetApic()
	{
		LVT_Entry perfMonDesc = { 0 };
		PULONG lpdwApicBase = g_pDrvData.lpApicBase;
		NTSTATUS status = STATUS_SUCCESS;
		if (g_pDrvData.bCpuX2ApicMode)
		{
			// Check Intel Manuals, Vol. 3A section 10-37
			ULONGLONG perfMonEntry = 0;
			UtilReadMsr(Msr::Ia32x2ApivIvtPmi, &perfMonEntry);
			perfMonDesc.All = (ULONG)perfMonEntry;
			perfMonDesc.Fields.Masked = 0;
			perfMonEntry = (ULONGLONG)perfMonDesc.All;
			UtilWriteMsr(Msr::Ia32x2ApivIvtPmi, perfMonEntry);
		}
		else
		{
			if (!lpdwApicBase)
				// XXX: Not sure how to continue, No MmMapIoSpace at this IRQL (should not happen)
				KeBugCheckEx(INTERRUPT_EXCEPTION_NOT_HANDLED, NULL, NULL, NULL, NULL);

			perfMonDesc.All = lpdwApicBase[0x340 / 4];
			perfMonDesc.Fields.Masked = 0;
			lpdwApicBase[0x340 / 4] = perfMonDesc.All;
		}
		return status;
	}
	//--------------------------------------------------------------//
	VOID IntelPerformanceMonitorInterrupt(PKTRAP_FRAME pTrapFrame)
	{

		START_DO_WHILE

		if (g_IsUninit)
		{
			break;
		}

		//DisablePmi();

		DispatchPmiEvent(pTrapFrame);

		UtilWriteMsr(Msr::Ia32PerfEvtseLx, 0);

		UtilWriteMsr(Msr::Ia32PMCx, (ULONG)0xFFFFFFF0);

		MSR_IA32_PERFEVTSELX_VERSION3 PerfEvtSelx = { 0 };
		PerfEvtSelx.fields.Usr = true;
		PerfEvtSelx.fields.Os = false;
		PerfEvtSelx.fields.E = false;
		PerfEvtSelx.fields.Int = true;
		PerfEvtSelx.fields.CounterMask = 0;
		PerfEvtSelx.fields.En = true;
		PerfEvtSelx.fields.AnyThread = false;
		PerfEvtSelx.fields.EventSelect = 0xC0;
		PerfEvtSelx.fields.UnitMask = 0x00;
		PerfEvtSelx.fields.Inv = false;
		PerfEvtSelx.fields.Pc = false;

		UtilWriteMsr(Msr::Ia32PerfEvtseLx, PerfEvtSelx.all);


		UtilWriteMsr(Msr::Ia32PerfGlobalOvfCtrl, 0x1);
		//EnablePmi();

		END_DO_WHILE

			 
		ResetApic();

		return;
	}
	//--------------------------------------------------------------//
	VOID ClearPmuEnvironment()
	{
		UtilWriteMsr(Msr::Ia32PerfGlobalCtrl, 0);

		UtilWriteMsr(Msr::Ia32PerfGlobalOvfCtrl, 0);

		UtilWriteMsr(Msr::Ia32PMCx, 0);
		 
	}
	//--------------------------------------------------------------//
	NTSTATUS RegisterPmiInterrupt()
	{
		NTSTATUS ntStatus = STATUS_SUCCESS;
	 
		ntStatus = InitInterrupt();
		if (!NT_SUCCESS(ntStatus))
		{
			return ntStatus;
		}

		ntStatus = InitApic();
		if (!NT_SUCCESS(ntStatus))
		{
			return ntStatus;
		}
		ntStatus = SetUpPerformanceInterrutpHandler(IntelPerformanceMonitorInterrupt);
		if (!NT_SUCCESS(ntStatus))
		{
			return ntStatus;
		}

		return ntStatus;
	}
	//--------------------------------------------------------------//
	// Unregister and remove the LVT PMI interrupt 
	NTSTATUS UnregisterPmiInterrupt()
	{
		NTSTATUS ntStatus = STATUS_SUCCESS;						// Returned NTSTATUS
		PMIHANDLER pOldPmiHandler = g_pDrvData.pOldPmiHandler;	// The old PMI handler 

		ClearPmuEnvironment();

		g_IsUninit = TRUE;
 
		// This is currently not restoring old PMI handler since we don't know how to retrieve it, just nulling it out
		ntStatus = HalSetSystemInformation(HalProfileSourceInterruptHandler, sizeof(PMIHANDLER), (PVOID)&pOldPmiHandler);

		if (NT_SUCCESS(ntStatus))
		{
			return ntStatus;
		}
		 
		if (g_pDrvData.lpApicBase)
		{
			MmUnmapIoSpace(g_pDrvData.lpApicBase, 0x1000);
		}


		 
		return ntStatus;
	}
}

```

`ThreadSpy/PMI.h`:

```h
#pragma once
#include <ntddk.h>

extern "C" {
	NTSTATUS RegisterPmiInterrupt();
	NTSTATUS UnregisterPmiInterrupt();
	VOID DisablePmi();
	VOID EnablePmi();
}
```

`ThreadSpy/PMU.cpp`:

```cpp
#include <ntddk.h>
#include "PMU.h"
#include "Common.h"
#include "Log.h"
#include <intrin.h>
#include "PMI.h"
extern "C"
{  
	////////////////////////////////////////////////////////////////////
	//// Types
	////  



	////////////////////////////////////////////////////////////////////
	////  Marcos
	////  
	#define PEBS_BUFFER_SIZE	(64 * 1024) /* PEBS buffer size */
	#define OUT_BUFFER_SIZE		(64 * 1024) /* must be multiple of 4k */
 
	////////////////////////////////////////////////////////////////////
	////  Global Variable
	////  
	UCHAR g_Event = 0;
	UCHAR g_Mask = 0;
	ULONG pebs_record_size = 0;

//--------------------------------------------------------------//
	NTSTATUS PMUEnvironmentCheck(
		_Out_ PMUINFO* Info
	)
	{
		UCHAR version = 0;
		UCHAR SupportedFixedFunction = 0;
		UCHAR SupportedBitWidth = 0;
		UCHAR SupportedPerfEvents = 0;
		UCHAR SupportedNumOfPMCs = 0;
		UCHAR SupportedPMCsWidth = 0;
		int cpu_info[4];
		NTSTATUS status = STATUS_SUCCESS;

		START_DO_WHILE

		if (!Info)
		{
			DbgPrintEx(0, 0, "Computer is not supported PMU Version : %d \r\n", cpu_info[0]);
			status = STATUS_UNSUCCESSFUL;
			break;
		}

		__cpuid(cpu_info, 0xA);
		version = (UCHAR)(cpu_info[0] & 0xFF);
		SupportedNumOfPMCs = (UCHAR)((cpu_info[0] >> 8) & 0xFF);
		SupportedPMCsWidth = (UCHAR)((cpu_info[0] >> 16) & 0xFF);
		SupportedPerfEvents = (UCHAR)((cpu_info[1] & 0xFF));
		SupportedFixedFunction = (UCHAR)(cpu_info[3] & 0x1F);
		SupportedBitWidth = (UCHAR)((cpu_info[3] >> 5) & 0xFF);

		if (!version)
		{
			DbgPrintEx(0, 0, "Computer is not supported PMU Version : %d \r\n", cpu_info[0]);
			status = STATUS_UNSUCCESSFUL;
			break;
		}

		MSR_IA32_MISC_ENABLE MiscEnable = {0 };

		UtilReadMsr(Msr::Ia32MiscEnable, &MiscEnable.all);

		Info->SupportedVersion = version;
		Info->SupportedFixedFunction = SupportedFixedFunction;
		Info->SupportedBitWidth = SupportedBitWidth;
		Info->SupportedNumOfPMCs = SupportedNumOfPMCs;
		Info->SupporteWidthPerPMCs = SupportedPMCsWidth;
		Info->SupportedAnyThread = (version == 3) ? 1 : 0;
		Info->SupportedPerfEvents = SupportedPerfEvents;
		Info->IsSupportPebs = (!MiscEnable.fields.PEBSUnavaiable);
		Info->IsSupportEmon = (MiscEnable.fields.PerfMonAvaliable);

		END_DO_WHILE

		return status;
	}
	
	//------------------------------------------------------//
	NTSTATUS CheckPerfCap(
		_In_ ULONG feat1)
	{
		/* check perf capability */
		if (feat1 & (1 << 15))
		{
			ULONG64 cap;

			cap = __readmsr(static_cast<ULONG>(Msr::Ia32PerfCaps));
			switch ((cap >> 8) & 0xf) {
			case 1:
				pebs_record_size = sizeof(struct pebs_v1);
				break;
			case 2:
				pebs_record_size = sizeof(struct pebs_v2);
				break;
			case 3:
				pebs_record_size = sizeof(struct pebs_v3);
				break;
			default:
			{
				PMU_DEBUG_INFO_LN_EX("Unsupported PEBS format\n");
				return STATUS_UNSUCCESSFUL;
			}
			}
			/* Could check PEBS_TRAP */
		}
		else
		{
			PMU_DEBUG_INFO_LN_EX("No PERF_CAPABILITIES support\n"); 
			return STATUS_UNSUCCESSFUL;
		}

		return STATUS_SUCCESS;
	}
	//------------------------------------------------------//
	NTSTATUS CheckSupportDebugStore(
		_In_ ULONG Feat2)
	{
		/* check if we support DS */
		if (!(Feat2 & (1 << 21)))
		{
			PMU_DEBUG_INFO_LN_EX("No debug store support\n");
			return STATUS_UNSUCCESSFUL;
		}
		return STATUS_SUCCESS;
	}
	//------------------------------------------------------//
	NTSTATUS CheckArchPlatform(
		_In_ ULONG Max)
	{
		NTSTATUS status = STATUS_SUCCESS;
		START_DO_WHILE

		int cpu_info[4] = { 0 };
		if (Max >= 0xa) 
		{
			__cpuid(cpu_info, 0xA);
			if ((cpu_info[0] & 0xff) < 1)
			{
				PMU_DEBUG_INFO_LN_EX("No arch perfmon support\n");
				status = STATUS_UNSUCCESSFUL;
				break;
			}

			if (((cpu_info[0] >> 8) & 0xff) < 1)
			{
				PMU_DEBUG_INFO_LN_EX("No generic counters\n"); 
				status = STATUS_UNSUCCESSFUL;
				break;
			}
		}
		else
		{
			PMU_DEBUG_INFO_LN_EX("No arch perfmon support\n");

			status = STATUS_UNSUCCESSFUL;
			break;
		}

		END_DO_WHILE

		return status;
	} 
	//------------------------------------------------------//
	NTSTATUS GetFamilyAndModel(
		_In_ int* CpuInfo , 
		_In_ int* Model,
		_In_ int* Family
	)
	{
		NTSTATUS status = STATUS_SUCCESS;
		START_DO_WHILE
		if (!CpuInfo ||!Model || !Family)
		{
			status = STATUS_UNSUCCESSFUL;
			break;
		}
		 
		*Model = ((CpuInfo[0] >> 4) & 0xf);
		*Family = (CpuInfo[0] >> 8) & 0xf;
		if (*Family == 6 || *Family == 0xf)
		{
			*Model += ((CpuInfo[0] >> 16) & 0xf) << 4;
		}

		END_DO_WHILE  
		return status;
	}

	//------------------------------------------------------//
	NTSTATUS CheckCpu()
	{
		int cpu_info[4] = {0};
		int max, model, fam;
		unsigned feat1, feat2;
		NTSTATUS status = STATUS_SUCCESS;;
		START_DO_WHILE

		__cpuid(cpu_info, 0);
		if (memcmp(&cpu_info[1], "Genu", 4)) 
		{
			PMU_DEBUG_INFO_LN_EX("Not an Intel CPU\n");
			break;
		} 
		max = cpu_info[0];

		__cpuid(cpu_info, 1); 
		feat1 = cpu_info[2];
		feat2 = cpu_info[3]; 

		status = GetFamilyAndModel(cpu_info, &model, &fam);
		if (!NT_SUCCESS(status) || fam != 6)
		{
			PMU_DEBUG_INFO_LN_EX("Not an supported Intel CPU\n");
			break;
		}

		status = CheckSupportDebugStore(feat2);
		if (!NT_SUCCESS(status))
		{
			break;
		}

		status = CheckPerfCap(feat1);
		if (!NT_SUCCESS(status))
		{
			break;
		}

		PMU_DEBUG_INFO_LN_EX("Supported CPU : %x %x pebs_record_size: %x ", g_Mask, g_Event, pebs_record_size);

		END_DO_WHILE 
 
		return status;
	} 

	//--------------------------------------------------------------//
	VOID DisablePmi()
	{
		MSR_IA32_PERF_GLOBAL_CTRL_VERSION2 Ctrl = { 0 };
		UtilWriteMsr(Msr::Ia32PerfGlobalCtrl, Ctrl.all);
	}
	//--------------------------------------------------------------//
	VOID EnablePmi()
	{
		MSR_IA32_PERF_GLOBAL_CTRL_VERSION2 Ctrl = { 0 };
		Ctrl.fields.EnablePmc0 = true;
		UtilWriteMsr(Msr::Ia32PerfGlobalCtrl, Ctrl.all);
	}

	//--------------------------------------------------------------//
	NTSTATUS PMUInitiailization(
		_In_ PVOID info
	)
	{
		START_DO_WHILE

		PMUINFO* Info = (PMUINFO*)info;
		if (!Info || !NT_SUCCESS(CheckCpu()))
		{
			return STATUS_UNSUCCESSFUL;
		}
		 
		switch (Info->SupportedVersion)
		{
		case 0:
		case 1:
		case 2:
		case 3: 
		case 4:
			DisablePmi();

			UtilWriteMsr(Msr::Ia32PerfEvtseLx, 0);

			UtilWriteMsr(Msr::Ia32PMCx, (ULONG)0xFFFFFFF0);

			MSR_IA32_PERFEVTSELX_VERSION3 PerfEvtSelx = { 0 };
			PerfEvtSelx.fields.Usr = true;						//in case you want intercept user mode instruction...
			PerfEvtSelx.fields.Os = false;
			PerfEvtSelx.fields.E = false;
			PerfEvtSelx.fields.Int = true;
			PerfEvtSelx.fields.CounterMask = 0;
			PerfEvtSelx.fields.En = true;
			PerfEvtSelx.fields.AnyThread = false;
			PerfEvtSelx.fields.EventSelect = 0xC0;
			PerfEvtSelx.fields.UnitMask = 0x00;
			PerfEvtSelx.fields.Inv = false;
			PerfEvtSelx.fields.Pc = false;
			UtilWriteMsr(Msr::Ia32PerfEvtseLx, PerfEvtSelx.all);
		 
			EnablePmi();
		
			PMU_DEBUG_INFO_LN_EX("Id: %x %d Done....", PerfEvtSelx.all, KeGetCurrentProcessorNumber());

			break;
		}

		END_DO_WHILE
			return STATUS_SUCCESS;
	}

	//--------------------------------------------------------------//
	NTSTATUS PMUUnInitiailization(
		_In_ PVOID info
	)
	{
		PMUINFO* Info = (PMUINFO*)info;
		if (!Info)
		{
			return STATUS_UNSUCCESSFUL;
		}

		switch (Info->SupportedVersion)
		{
		case 0:
			break;
		case 1:
			break;
		case 2:
			break;
		case 3:
			break;
		}
		return STATUS_SUCCESS;
	}
}
```

`ThreadSpy/PMU.h`:

```h
#include <ntddk.h>
#include "Common.h"
///////////////////////////////////////////////////////
//// Prototype
////
////
extern "C" {
	NTSTATUS PMUEnvironmentCheck(
		_Out_ PMUINFO* Info
	);

	NTSTATUS PMUInitiailization(
		_In_ PVOID Info
	);

	NTSTATUS PMUUnInitiailization(
		_In_ PVOID Info
	);
}
```

`ThreadSpy/ThreadSpy.inf`:

```inf
;
; PerfMon.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=PerfMon.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages

[DestinationDirs]
DefaultDestDir = 12

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
PerfMon.sys  = 1,,

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%PerfMon.DeviceDesc%=PerfMon_Device, Root\PerfMon ; TODO: edit hw-id

[PerfMon_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
PerfMon.sys

;--- PerfMon_Device Coinstaller installation ------
;


[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "PerfMon Installation Disk"
PerfMon.DeviceDesc = "PerfMon Device"
PerfMon.SVCDESC = "PerfMon Service"

```

`ThreadSpy/ThreadSpy.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{F01C4412-F73C-4BD8-A954-84E2F3BD1251}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>ThreadSpy</RootNamespace>
    <ProjectName>ThreadSpy</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalDependencies>%(AdditionalDependencies);$(KernelBufferOverflowLib);$(DDK_LIB_PATH)ntoskrnl.lib;$(DDK_LIB_PATH)hal.lib;$(DDK_LIB_PATH)wmilib.lib; </AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="ThreadSpy.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Common.cpp" />
    <ClCompile Include="Driver.cpp" />
    <ClCompile Include="PMI.cpp" />
    <ClCompile Include="PMU.cpp" />
    <ClCompile Include="Util.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Apic.h" />
    <ClInclude Include="Common.h" />
    <ClInclude Include="Log.h" />
    <ClInclude Include="PMI.h" />
    <ClInclude Include="PMU.h" />
    <ClInclude Include="SSDT.h" />
    <ClInclude Include="Util.h" />
    <ClInclude Include="x86.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`ThreadSpy/ThreadSpy.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="ThreadSpy.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Apic.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="x86.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="PMU.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Common.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="PMI.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Util.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Log.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="SSDT.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Driver.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="PMU.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="PMI.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Util.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Common.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`ThreadSpy/ThreadSpy.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <SignMode>TestSign</SignMode>
  </PropertyGroup>
</Project>
```

`ThreadSpy/Util.cpp`:

```cpp

#include <ntddk.h>  
#include "x86.h"
#include <intrin.h>
extern "C" 
{
	//-----------------------------------------------------------------------------//
	void* UtilGetSystemProcAddress(
		_In_ const wchar_t *proc_name
	) 
	{
		PAGED_CODE(); 
		UNICODE_STRING proc_name_U = {};
		RtlInitUnicodeString(&proc_name_U, proc_name);
		return MmGetSystemRoutineAddress(&proc_name_U);
	}
	 

	//-----------------------------------------------------------------------------//
	NTSTATUS UtilForEachProcessor(
		_In_ NTSTATUS(*callback_routine)(void *),
		_In_ void *context)
	{
		const auto number_of_processors =
			KeQueryActiveProcessorCountEx(ALL_PROCESSOR_GROUPS);
		for (ULONG processor_index = 0; processor_index < number_of_processors; processor_index++)
		{
			PROCESSOR_NUMBER processor_number = {};
			auto status = KeGetProcessorNumberFromIndex(processor_index, &processor_number);
			if (!NT_SUCCESS(status))
			{
				return status;
			}

			// Switch the current processor
			GROUP_AFFINITY affinity = {};
			affinity.Group = processor_number.Group;
			affinity.Mask = 1ull << processor_number.Number;
			GROUP_AFFINITY previous_affinity = {};
			KeSetSystemGroupAffinityThread(&affinity, &previous_affinity);

			// Execute callback
			status = callback_routine(context);

			KeRevertToUserGroupAffinityThread(&previous_affinity);
			if (!NT_SUCCESS(status))
			{
				return status;
			}
		}
		return STATUS_SUCCESS;
	}

	//-----------------------------------------------------------------------------//
	NTSTATUS UtilWriteMsr(Msr msr, ULONG64 Value)
	{
		NTSTATUS status = STATUS_SUCCESS;
		__try
		{
			__writemsr(static_cast<ULONG>(msr),Value);
		}
		__except (0)
		{
			status = STATUS_UNSUCCESSFUL;
		}
		return status;
	}
	
	//-----------------------------------------------------------------------------//
	NTSTATUS UtilReadMsr(Msr msr, ULONG64* Value)
	{
		NTSTATUS status = STATUS_SUCCESS;
		if (!Value)
		{
			status = STATUS_INVALID_PARAMETER;
			return status;
		}
		__try
		{	
			*Value = __readmsr(static_cast<ULONG>(msr));
		}
		__except (0) 
		{
			status = STATUS_UNSUCCESSFUL;
		}
		return status;
	}
	//-----------------------------------------------------------------------------//
}
```

`ThreadSpy/Util.h`:

```h
#pragma once
#include<ntddk.h>
#include "x86.h"
extern "C" { 
	void*	 UtilGetSystemProcAddress(
		_In_ const wchar_t *proc_name
	);
	
	NTSTATUS UtilForEachProcessor(
		_In_ NTSTATUS(*callback_routine)(void *), 
		_In_ void *context
	);

	NTSTATUS UtilReadMsr(
		Msr msr, 
		ULONG64* Value
	);

	NTSTATUS UtilWriteMsr(
		Msr msr,
		ULONG64 Value
	);
}
```

`ThreadSpy/x86.h`:

```h
#pragma once

#define MSR_IA32_PERF_GLOBAL_STATUS		0x0000038E
#define MSR_IA32_APIC_BASE				0x0000001B			// The APIC base address register

#define MSR_IA32_RTIT_OUTPUT_BASE		0x00000560
#define MSR_IA32_RTIT_OUTPUT_MASK_PTRS	0x00000561
#define MSR_IA32_RTIT_CTL				0x00000570
#define MSR_IA32_RTIT_STATUS			0x00000571
#define MSR_IA32_X2APIC_LVT_PMI			0x00000834

// Filtering by CR3:
#define MSR_IA32_RTIT_CR3_MATCH			0x00000572

// Filtering by IP:
#define MSR_IA32_RTIT_ADDR0_START		0x00000580
#define MSR_IA32_RTIT_ADDR0_END			0x00000581
#define MSR_IA32_RTIT_ADDR1_START		0x00000582
#define MSR_IA32_RTIT_ADDR1_END			0x00000583
#define MSR_IA32_RTIT_ADDR2_START		0x00000584
#define MSR_IA32_RTIT_ADDR2_END			0x00000585
#define MSR_IA32_RTIT_ADDR3_START		0x00000586
#define MSR_IA32_RTIT_ADDR3_END			0x00000587

typedef ULONG DWORD;

/*------------------------------------------------------------------
18.2.1.2 Pre-defined Architectural Performance Events : 
----------------------------------------------------------------
| Bit Position | Event Name              | UMask | Event Select |
| (CPUID.AH.EBX)										        |
 ---------------------------------------------------------------
|  0			UnHalted Core Cycles       00H		 3CH		|
|  1			Instruction Retired        00H		 C0H		|
|  2			UnHalted Reference Cycles  01H		 3CH		|
|  3			LLC Reference			   4FH		 2EH		|
|  4			LLC Misses				   41H		 2EH		|
|  5			Branch Instruction Retired 00H		 C4H		|
|  6			Branch Misses Retired	   00H		 C5H		|
-----------------------------------------------------------------

------------------------------------------------------------------*/
union MSR_IA32_PERFEVTSLX_VERSION1
{
	struct
	{
		ULONG64 EventSelect : 8;	///< [7:0]	 Event Select Field
		ULONG64 UnitMask : 8;		///< [15:8]	 Unit Mask
		ULONG64 Usr : 1;			///< [16]	 User Mode
		ULONG64 Os : 1;				///< [17]	 Operating System Mode
		ULONG64 E : 1;				///< [18]	 Edge Detect
		ULONG64 Pc : 1;				///< [19]	 Pin Control
		ULONG64 Int : 1;			///< [20]	 APIC Interrupt Enable
		ULONG64 Reserved : 1;		///< [21]	 Resevred
		ULONG64 En : 1;				///< [22]	 Enable Counters
		ULONG64 Inv : 1;			///< [23]    Invert
		ULONG64 CounterMask : 8;	///< [31:24] Counter Mask
		ULONG64 Reserved2 : 32;		///< [63:32] Reserved
	}fields;
	ULONG64 all;
}; 
static_assert(sizeof(MSR_IA32_PERFEVTSLX_VERSION1) == 8, "Size check");

union MSR_IA32_PERFEVTSELX_VERSION3
{
	struct
	{
		ULONG64 EventSelect : 8;	///< [7:0]	 Event Select Field
		ULONG64 UnitMask : 8;		///< [15:8]	 Unit Mask
		ULONG64 Usr : 1;			///< [16]	 User Mode
		ULONG64 Os : 1;				///< [17]	 Operating System Mode
		ULONG64 E : 1;				///< [18]	 Edge Detect
		ULONG64 Pc : 1;				///< [19]	 Pin Control
		ULONG64 Int : 1;			///< [20]	 APIC Interrupt Enable
		ULONG64 AnyThread : 1;		///< [21]	 AnyThread
		ULONG64 En : 1;				///< [22]	 Enable Counters
		ULONG64 Inv : 1;			///< [23]    Invert
		ULONG64 CounterMask : 8;	///< [31:24] Counter Mask
		ULONG64 Reserved2 : 32;		///< [63:32] Reserved
	}fields;
	ULONG64 all;
}; 
static_assert(sizeof(MSR_IA32_PERFEVTSELX_VERSION3) == 8, "Size check");


//bit[0]:  0: disable; 1: OS; 2: User; 3: All ring levels 
//bit[1]   Controls for IA32_FIXED_CTRx , x < 3 , Enable for fixed-function PC to increment
union MSR_IA32_FIXED_CTR_CTRL_VERSION2
{
	struct
	{
		ULONG64 En : 2;			 /// < [1:0]	Enable Field,	 
		ULONG64 Reserved1 : 1;   /// < [2]		Reserved1	
		ULONG64 Pmi : 1;		 /// < [3]		PMI Field	,	Enable PMI Overflow	
		ULONG64 En2 : 2;		 /// < [5:4]	Enable Field2
		ULONG64 Reserved2 : 1;	 /// < [6]		Reserved2
		ULONG64 Pmi2 : 1;		 /// < [7]		PMI Field
		ULONG64 En3 : 2;		 /// < [9:8]	Enable Field2
		ULONG64 Reserved4 : 1;	 /// < [10]		Reserved2
		ULONG64 Pmi3 : 1;		 /// < [11]		PMI Field	
		ULONG64 Reserved5 : 52;  /// < [63:12]  Reserved	
	}fields;
	ULONG64 all;
};
static_assert(sizeof(MSR_IA32_FIXED_CTR_CTRL_VERSION2) == 8, "Size check");
 

//bit[0]:  0: disable; 1: OS; 2: User; 3: All ring levels 
//bit[1]   Controls for IA32_FIXED_CTRx , x < 3 , Enable for fixed-function PC to increment
union MSR_IA32_FIXED_CTR_CTRL_VERSION3
{
	struct
	{
		ULONG64 En : 2;			 /// < [1:0]	Enable Field,	 
		ULONG64 Any1 : 1;		 /// < [2]		Reserved1	
		ULONG64 Pmi : 1;		 /// < [3]		PMI Field	,	Enable PMI Overflow	
		ULONG64 En2 : 2;		 /// < [5:4]	Enable Field2
		ULONG64 Any12 : 1;		 /// < [6]		Reserved2
		ULONG64 Pmi2 : 1;		 /// < [7]		PMI Field
		ULONG64 En3 : 2;		 /// < [9:8]	Enable Field2
		ULONG64 Any13 : 1;		 /// < [10]		Reserved2
		ULONG64 Pmi3 : 1;		 /// < [11]		PMI Field	
		ULONG64 Reserved5 : 52;  /// < [63:12]  Reserved	
	}fields;
	ULONG64 all;
};
static_assert(sizeof(MSR_IA32_FIXED_CTR_CTRL_VERSION3) == 8, "Size check");

union MSR_IA32_PERF_GLOBAL_CTRL_VERSION2
{
	struct
	{
		ULONG64 EnablePmc0 : 1;			 /// < [0]	IA32_PMC0 Enabled
		ULONG64 EnablePmc1 : 1;			 /// < [1]	IA32_PMC0 Enabled
		ULONG64 Reserved   : 30;		 /// < [31:2]
		ULONG64	EnableCTR0 : 1;			 /// < [32] IA32_FIXED_CTR0 enable
		ULONG64	EnableCTR1 : 1;			 /// < [33] IA32_FIXED_CTR1 enable
		ULONG64	EnableCTR2 : 1;			 /// < [34] IA32_FIXED_CTR2 enable
		ULONG64	Reserved2  : 29;		 /// < [63:35]
	}fields;
	ULONG64 all;
};
static_assert(sizeof(MSR_IA32_PERF_GLOBAL_CTRL_VERSION2) == 8, "Size check");


union MSR_IA32_PERF_GLOBAL_STATUS_VERSION2
{
	struct
	{
		ULONG64 PMC0Overflow : 1;	 /// < [0]	IA32_PMC0 OverFlow
		ULONG64 PMC1Overflow : 1;	 /// < [1]	IA32_PMC0 OverFlow
		ULONG64 Reserved : 30;		 /// < [31:2]
		ULONG64	CTR0OverFlow : 1;	 /// < [32] IA32_FIXED_CTR0 OverFlow
		ULONG64	CTR1OverFlow : 1;	 /// < [33] IA32_FIXED_CTR1 OverFlow
		ULONG64	CTR2OverFlow : 1;	 /// < [34] IA32_FIXED_CTR2 OverFlow
		ULONG64	Reserved2 : 27;		 /// < [61:35]
		ULONG64 OvfDSBuffer : 1;	 /// < [62]
		ULONG64 CondChgd : 1;		 /// < [63]
	}fields;
	ULONG64 all;
};
static_assert(sizeof(MSR_IA32_PERF_GLOBAL_STATUS_VERSION2) == 8, "Size check");


union MSR_IA32_DEBUGCTL
{
	struct
	{
		ULONG64 LBR : 1;				/// < [0]	 
		ULONG64 BTF : 1;				/// < [1] 
		ULONG64 Reserved1 : 4;			/// < [5:2]
		ULONG64	TR : 1;					/// < [6]  
		ULONG64	BTS : 1;				/// < [7]  
		ULONG64	BTINT : 1;				/// < [8]  
		ULONG64	BTS_OFF_OS : 1;			/// < [9]
		ULONG64 BTS_OFF_USR: 1;			/// < [10]
		ULONG64 FRZ_LBRS_ON_PMI : 1	;	/// < [11]
		ULONG64 FRZ_PERFMON_ON_PMI : 1; /// < [12]
		ULONG64 UNCORE_PMI_EN : 1;		/// < [13]
		ULONG64 SMM_FRZ : 1;			/// < [14]
		ULONG64 Reserved2 : 49;			/// < [63:15]
	}fields;	
	ULONG64 all;
};
static_assert(sizeof(MSR_IA32_DEBUGCTL) == 8, "Size check");

union MSR_IA32_PERF_GLOBAL_CTRL
{
	struct
	{
		ULONG64 EN_PC0 : 1;				/// < [0]	 
		ULONG64 EN_PC1 : 1;				/// < [1] 
		ULONG64 EN_PC2 : 1;				/// < [2]
		ULONG64	EN_PC3 : 1;				/// < [3]  
		ULONG64	Reserved : 28;			/// < [31:4]  
		ULONG64	EN_FC0 : 1;				/// < [32]  
		ULONG64	EN_FC1 : 1;				/// < [33]
		ULONG64 EN_FC2 : 1;				/// < [34] 
		ULONG64 Reserved2 : 29;			/// < [63:35]
	}fields;
	ULONG64 all;
};
static_assert(sizeof(MSR_IA32_PERF_GLOBAL_CTRL) == 8, "Size check");


union MSR_IA32_MISC_ENABLE
{
	struct
	{
		ULONG64 FastStrEnable : 1;				/// < [0]	 
		ULONG64 Reserved : 2;					/// < [2:1] 
		ULONG64 AutoThermalCtrlCirEn: 1;		/// < [3]
		ULONG64	Reserved1 : 3;					/// < [6:4]  
		ULONG64	PerfMonAvaliable : 1;			/// < [7]  
		ULONG64	Reserved2 : 3;					/// < [10:8]  
		ULONG64	BTSUnavaliable : 1;				/// < [11]
		ULONG64 PEBSUnavaiable : 1;				/// < [12] 
		ULONG64 Reserved3 : 3;					/// < [15:13]
		ULONG64 SpeedStepEnable : 1;			/// < [16]
		ULONG64 Reserved5 : 1;					/// < [17]
		ULONG64 MonitorFsmEnable : 1;			/// < [18]
		ULONG64 Reserved6 : 3;					/// < [21:19]
		ULONG64 LimitCpuidMaxval : 1;			/// < [22]
		ULONG64 xTprMsgRwDisable : 1;			/// < [23]
		ULONG64 Reserved7 : 10;					/// < [33:24]
		ULONG64 XdDisable : 1;					/// < [34]
		ULONG64 Reserved8 : 29;					/// < [63:35]
	}fields;
	ULONG64 all;
};
static_assert(sizeof(MSR_IA32_MISC_ENABLE) == 8, "Size check");


union MSR_IA32_PEBS_ENABLE
{
	struct
	{
		ULONG64 EnablePmc0 : 1;	/// < [0]	 
		ULONG64 EnablePmc1 : 1;	/// < [1]	 
		ULONG64 EnablePmc2 : 1;	/// < [2]	 
		ULONG64 EnablePmc3 : 1;	/// < [3]	 
		ULONG64 Reserved : 28;	/// < [31:4]
		ULONG64 LL_EN_PMC0 : 1;	/// < [32]
		ULONG64 LL_EN_PMC1 : 1;	/// < [33]
		ULONG64 LL_EN_PMC2 : 1;	/// < [34]
		ULONG64 LL_EN_PMC3 : 1;	/// < [35]
		ULONG64 Reserved2 : 28;	/// < [63:36]
	}fields;
	ULONG64 all;
};
static_assert(sizeof(MSR_IA32_PEBS_ENABLE) == 8, "Size check");


union MSR_IA32_PERF_CAPABILITIES
{
	struct {
		ULONG64 LbrFormat : 6;			/// <[5:0]
		ULONG64 PebsTrap : 1;			/// <[6]
		ULONG64 PebsSaveArchRegs : 1;	/// <[7]
		ULONG64 PebsRecordFormat : 4;	/// <[11:8]
		ULONG64 FreezeWhenSmm : 1;		/// <[12]
		ULONG64 FullWidthCounter : 1;	/// <[13]
		ULONG64 Reserved : 50;			/// <[63:14]
	}fields;
	ULONG64 all;
};
static_assert(sizeof(MSR_IA32_PERF_CAPABILITIES) == 8, "Size check");


union MSR_IA32_PERF_GLOBAL_OVF_CTL
{
	struct
	{
		ULONG64 Ia32Pmc0Ovf : 1;
		ULONG64 Ia32Pmc1Ovf : 1;
		ULONG64 Reserved : 30;
		ULONG64 Ia32FixedCtr0Ovf : 1;
		ULONG64 Ia32FixedCtr1Ovf : 1;
		ULONG64 Ia32FixedCtr2Ovf : 1;
		ULONG64 Reserved1 : 27;
		ULONG64 ClrCondChgd : 1;		
		ULONG64 ClrOvfDSBuffer : 1; 
	}fields;
	ULONG64 all;
};
static_assert(sizeof(MSR_IA32_PERF_GLOBAL_OVF_CTL) == 8, "Size check");

union MSR_IA32_PERF_GLOBAL_OVF_CTRL
{
	struct
	{
		ULONG64 OvfPmc0 : 1;			/// <[0]
		ULONG64 OvfPmc1 : 1;			/// <[1]
		ULONG64 OvfPmc2 : 1;			/// <[2]
		ULONG64 OvfPmcn : 1;			/// <[3]
		ULONG64 Reserved : 28;			/// <[n:4] , n If CPUID.0AH: EAX[15:8] > n
		ULONG64 OvfFixedCtr0 : 1;		/// <[32]
		ULONG64 OvfFixedCtr1 : 1;		/// <[33]
		ULONG64 OvfFixedCtr2 : 1;		/// <[34]
		ULONG64 Reserved2 : 20;			/// <[54:35]
		ULONG64 TraceToPaPmi : 1;		/// <[55]
		ULONG64 Reserved3 : 5;			/// <[60:56]
		ULONG64  OvfUnCore : 1;			/// <[61]
		ULONG64  OvfBuf : 1;			/// <[62]
		ULONG64  CondChgd : 1;			/// <[63]
	}fields;
	ULONG64 all;
}; 
static_assert(sizeof(MSR_IA32_PERF_GLOBAL_OVF_CTRL) == 8, "Size check");


// A local vector table (LVT) entry
union LVT_Entry {
	struct {
		USHORT Vector : 8;					// [0:7] - The Vector number
		USHORT Reserved1 : 4;				// [8:11] - Reserved
		USHORT DeliveryStatus : 1;			// [12] - Delivery status: 0 - Idle; 1 - Send Pending;
		USHORT Reserved2 : 3;				// [13:15] - Reserved
		USHORT Masked : 1;					// [16] - Masked: 0 - Not Masked; 1 - Masked
		USHORT TimerMode : 2;				// [17:18] - Timer mode: 00 - One-shot; 01 - Periodic; 10 - TSC-Deadline;
		USHORT Reserved3 : 13;				// [19:31] - Reserved
	} Fields;
	DWORD All;
};
static_assert(sizeof(LVT_Entry) == 4, "Size check");

// The APIC Base physical address MSR in xAPIC Mode
union MSR_IA32_APIC_BASE_DESC {
	struct {
		ULONGLONG Reserved1 : 8;			// [0:7] - Reserved
		ULONGLONG Bsp : 1;					// [8] - Indicates if the processor is the bootstrap processor (BSP)
		ULONGLONG Reserved2 : 1;			// [9] - Reserved
		ULONGLONG EXTD : 1;					// [10] - Enable x2APIC mode
		ULONGLONG EN : 1;					// [11] - APIC global enable/disable
		ULONGLONG ApicBase : 24;			// [12:35] - Base Physical Address
	} Fields;
	ULONGLONG All;
};
static_assert(sizeof(MSR_IA32_APIC_BASE_DESC) == 8, "Size check");

// The IA32_PERF_GLOBAL_STATUS descriptor of Intel Broadwell microarchitecture 
union MSR_IA32_PERF_GLOBAL_STATUS_DESC {
	struct {
		DWORD PMC0_OVF : 1;					// [0] - Read only
		DWORD PMC1_OVF : 1;					// [1] - Read only 
		DWORD PMC2_OVF : 1;					// [2] - Read only
		DWORD PMC3_OVF : 1;					// [3] - Read only
		DWORD PMC4_OVF : 1;					// [4] - Read only (if PMC4 present)
		DWORD PMC5_OVF : 1;					// [5] - Read only (if PMC5 present) 
		DWORD PMC6_OVF : 1;					// [6] - Read only (if PMC6 present)
		DWORD PMC7_OVF : 1;					// [7] - Read only (if PMC7 present)
		DWORD Reserved : 24;				// [8:31] - Reserved
		DWORD FIXED_CTR0 : 1;				// [32] - FIXED_CTR0 Overflow (RO)
		DWORD FIXED_CTR1 : 1;				// [33] - FIXED_CTR1 Overflow (RO)
		DWORD FIXED_CTR2 : 1;				// [34] - FIXED_CTR2 Overflow (RO)
		DWORD Reserved2 : 20;				// [35:54] - Reserved
		DWORD TraceToPAPMI : 1;				// [55] - The ToPA PMI Interrupt status
		DWORD Reserved3 : 5;				// [56:60] - Reserved
		DWORD Ovf_UncorePMU : 1;			// [61]
		DWORD Ovf_Buffer : 1;				// [62]
		DWORD CondChgd : 1;					// [63]
	} Fields;
	ULONGLONG All;
};
static_assert(sizeof(MSR_IA32_PERF_GLOBAL_STATUS_DESC) == 8, "Size check");

#pragma pack(push,1)
typedef struct IDTDESC
{
	USHORT limit;
	ULONG64 BASE;
}IDTDESC, *PIDTDESC;
static_assert(sizeof(IDTDESC) == 10, "Size check");


typedef union _KIDTENTRY64
{
	struct
	{
		USHORT OffsetLow;
		USHORT Selector;
		USHORT IstIndex : 3;
		USHORT Reserved0 : 5;
		USHORT Type : 5;
		USHORT Dpl : 2;
		USHORT Present : 1;
		USHORT OffsetMiddle;
		ULONG  OffsetHigh;
		ULONG  Reserved1;
	}u;
	UINT64 Alignment;
} KIDTENTRY64, *PKIDTENTRY64;
#pragma pack(pop) 
/// See: MODEL-SPECIFIC REGISTERS (MSRS)
enum class Msr : unsigned int {
	Ia32ApicBase = 0x01B,

	Ia32FeatureControl = 0x03A,
	Ia32PMCx = 0xC1,
	Ia32SysenterCs = 0x174,
	Ia32SysenterEsp = 0x175,
	Ia32SysenterEip = 0x176,
	Ia32PerfEvtseLx = 0x186,
	Ia32Debugctl = 0x1D9,

	//PMU Related
	Ia32FixedCtrl0 = 0x309,
	Ia32FixedCtrl1 = 0x30A,
	Ia32FixedCtrl2 = 0x30B,
	Ia32PerfCaps = 0x345,
	Ia32FixedCtrl = 0x38D,
	Ia32PerfGlobalStatus = 0x38E,	// allows software to query counter overflow conditions on any combination of fixed - function PMCs or general - purpose PMCs via a single RDMSR.
	Ia32PerfGlobalCtrl = 0x38F,	// allows software to enable/disable event counting of all or any combination of fixed - function PMCs(IA32_FIXED_CTRx) or any general - purpose PMCs via a single WRMSR.
	Ia32PerfGlobalOvfCtrl = 0x390,  // allows software to clear counter overflow conditions on any combination of fixed - function PMCs or general - purpose PMCs via a single WRMSR.


	//PMU PEBS Related
	Ia32MiscEnable = 0x1A0,
	Ia32PebsEnable = 0x3F1,
	Ia32DsArea = 0x600,

	Ia32VmxBasic = 0x480,
	Ia32VmxPinbasedCtls = 0x481,
	Ia32VmxProcBasedCtls = 0x482,
	Ia32VmxExitCtls = 0x483,
	Ia32VmxEntryCtls = 0x484,
	Ia32VmxMisc = 0x485,
	Ia32VmxCr0Fixed0 = 0x486,
	Ia32VmxCr0Fixed1 = 0x487,
	Ia32VmxCr4Fixed0 = 0x488,
	Ia32VmxCr4Fixed1 = 0x489,
	Ia32VmxVmcsEnum = 0x48A,
	Ia32VmxProcBasedCtls2 = 0x48B,
	Ia32VmxEptVpidCap = 0x48C,
	Ia32VmxTruePinbasedCtls = 0x48D,
	Ia32VmxTrueProcBasedCtls = 0x48E,
	Ia32VmxTrueExitCtls = 0x48F,
	Ia32VmxTrueEntryCtls = 0x490,
	Ia32VmxVmfunc = 0x491,

	Ia32x2ApivIvtPmi = 0x00000834,

	Ia32Efer = 0xC0000080,
	Ia32Star = 0xC0000081,
	Ia32Lstar = 0xC0000082,

	Ia32Fmask = 0xC0000084,

	Ia32FsBase = 0xC0000100,
	Ia32GsBase = 0xC0000101,
	Ia32KernelGsBase = 0xC0000102,
	Ia32TscAux = 0xC0000103,
	 
};


enum class CpuMircoArchModel : unsigned int
{
	SandyBridge = 0x2A,
	SandyBridge_E = 0x2D,
	IvyBridge = 0x3A,

	Arrandale = 0x25,
	Gulftown  = 0x2C,
	Westmere_Ex = 0x2F,

};
```