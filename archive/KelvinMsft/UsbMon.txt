Project Path: arc_KelvinMsft_UsbMon_rxgb2ru0

Source Tree:

```txt
arc_KelvinMsft_UsbMon_rxgb2ru0
├── README.md
└── UsbMon
    ├── UsbMon
    │   ├── CommonUtil.c
    │   ├── CommonUtil.h
    │   ├── Driver.c
    │   ├── HidHijack.c
    │   ├── HidHijack.h
    │   ├── HidType.h
    │   ├── IrpHook.c
    │   ├── IrpHook.h
    │   ├── LinkedList.h
    │   ├── OpenLoopBuffer.c
    │   ├── OpenLoopBuffer.h
    │   ├── Readme.txt
    │   ├── ReportUtil.c
    │   ├── ReportUtil.h
    │   ├── TList.c
    │   ├── TList.h
    │   ├── UsbHid.c
    │   ├── UsbHid.h
    │   ├── UsbMon
    │   │   ├── Driver.c
    │   │   ├── LinkedList.h
    │   │   ├── UsbMon.inf
    │   │   ├── UsbMon.vcxproj
    │   │   ├── UsbMon.vcxproj.filters
    │   │   ├── UsbMon.vcxproj.user
    │   │   ├── Util.h
    │   │   └── x64
    │   │       └── Debug
    │   │           ├── StackTrace.Build.CppClean.log
    │   │           ├── StackTrace.log
    │   │           ├── UsbMon.Build.CppClean.log
    │   │           ├── UsbMon.inf
    │   │           ├── UsbMon.log
    │   │           └── vc140.pdb
    │   ├── UsbMon.inf
    │   ├── UsbMon.sln
    │   ├── UsbMon.vcxproj
    │   ├── UsbMon.vcxproj.filters
    │   ├── UsbMon.vcxproj.user
    │   ├── UsbType.h
    │   ├── UsbUtil.c
    │   ├── UsbUtil.h
    │   ├── Util.h
    │   ├── WinParse.c
    │   ├── WinParse.h
    │   ├── hidtoken.h
    │   ├── local.h
    │   └── x64
    │       ├── Debug
    │       │   ├── StackTrace.Build.CppClean.log
    │       │   ├── StackTrace.log
    │       │   ├── UsbMon.Build.CppClean.log
    │       │   ├── UsbMon.inf
    │       │   ├── UsbMon.log
    │       │   └── vc140.pdb
    │       └── Release
    │           ├── UsbMon.inf
    │           ├── UsbMon.log
    │           └── vc140.pdb
    ├── UsbMon.sln
    ├── VTxRing3
    │   ├── IOCTL.h
    │   ├── VTxRing3.cpp
    │   ├── VTxRing3.h
    │   ├── VTxRing3.rc
    │   ├── VTxRing3.vcxproj
    │   ├── VTxRing3.vcxproj.filters
    │   ├── VTxRing3Dlg.cpp
    │   ├── VTxRing3Dlg.h
    │   ├── cDrvCtrl.cpp
    │   ├── cDrvCtrl.h
    │   ├── res
    │   │   ├── VTxRing3.ico
    │   │   └── VTxRing3.rc2
    │   ├── resource.h
    │   ├── stdafx.cpp
    │   ├── stdafx.h
    │   ├── targetver.h
    │   └── x64
    │       └── Debug
    │           └── VTxRing3.res
    ├── doc
    │   └── CreateionProcess2.png
    └── x64
        └── Debug
            ├── UsbMon
            │   ├── UsbMon.inf
            │   ├── UsbMon.sys
            │   └── stacktrace.cat
            ├── UsbMon.inf
            ├── UsbMon.pdb
            └── UsbMon.sys

```

`README.md`:

```md
# UsbMon

[![Codacy Badge](https://api.codacy.com/project/badge/Grade/d7385fae7dfa4af29831abc0bc97223c)](https://app.codacy.com/gh/Kelvinhack/UsbMon?utm_source=github.com&utm_medium=referral&utm_content=Kelvinhack/UsbMon&utm_campaign=Badge_Grade)

Usb Device Data Penerater from Usbhub to HID Device Data Consumer Process


```

`UsbMon/UsbMon.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 14
VisualStudioVersion = 14.0.25420.1
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "UsbMon", "UsbMon\UsbMon.vcxproj", "{7E68057F-E333-4F45-8C91-7E280838FF63}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "VTxRing3", "VTxRing3\VTxRing3.vcxproj", "{C5036DB1-D9D6-45F1-BFC9-720975850C7A}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{7E68057F-E333-4F45-8C91-7E280838FF63}.Debug|x64.ActiveCfg = Debug|x64
		{7E68057F-E333-4F45-8C91-7E280838FF63}.Debug|x64.Build.0 = Debug|x64
		{7E68057F-E333-4F45-8C91-7E280838FF63}.Debug|x64.Deploy.0 = Debug|x64
		{7E68057F-E333-4F45-8C91-7E280838FF63}.Debug|x86.ActiveCfg = Debug|Win32
		{7E68057F-E333-4F45-8C91-7E280838FF63}.Debug|x86.Build.0 = Debug|Win32
		{7E68057F-E333-4F45-8C91-7E280838FF63}.Debug|x86.Deploy.0 = Debug|Win32
		{7E68057F-E333-4F45-8C91-7E280838FF63}.Release|x64.ActiveCfg = Release|x64
		{7E68057F-E333-4F45-8C91-7E280838FF63}.Release|x64.Build.0 = Release|x64
		{7E68057F-E333-4F45-8C91-7E280838FF63}.Release|x64.Deploy.0 = Release|x64
		{7E68057F-E333-4F45-8C91-7E280838FF63}.Release|x86.ActiveCfg = Release|Win32
		{7E68057F-E333-4F45-8C91-7E280838FF63}.Release|x86.Build.0 = Release|Win32
		{7E68057F-E333-4F45-8C91-7E280838FF63}.Release|x86.Deploy.0 = Release|Win32
		{C5036DB1-D9D6-45F1-BFC9-720975850C7A}.Debug|x64.ActiveCfg = Debug|x64
		{C5036DB1-D9D6-45F1-BFC9-720975850C7A}.Debug|x64.Build.0 = Debug|x64
		{C5036DB1-D9D6-45F1-BFC9-720975850C7A}.Debug|x86.ActiveCfg = Debug|Win32
		{C5036DB1-D9D6-45F1-BFC9-720975850C7A}.Debug|x86.Build.0 = Debug|Win32
		{C5036DB1-D9D6-45F1-BFC9-720975850C7A}.Release|x64.ActiveCfg = Release|x64
		{C5036DB1-D9D6-45F1-BFC9-720975850C7A}.Release|x64.Build.0 = Release|x64
		{C5036DB1-D9D6-45F1-BFC9-720975850C7A}.Release|x86.ActiveCfg = Release|Win32
		{C5036DB1-D9D6-45F1-BFC9-720975850C7A}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`UsbMon/UsbMon/CommonUtil.c`:

```c
#include <ntddk.h> 
#include "CommonUtil.h"
#include "IrpHook.h" 

/////////////////////////////////////////////////////////////////////////////////////////////// 
//// Marco
//// 



/////////////////////////////////////////////////////////////////////////////////////////////// 
//// Global/Extern Variable
//// 
extern ULONG g_iClientUUID;
extern ULONG g_iGameID;

extern ULONG64			  g_IsEnableModuleChecksum;  
extern ULONG 			  g_EncryptKey[4];

extern POBJECT_TYPE *IoDriverObjectType;

extern NTSTATUS ObReferenceObjectByName(
	PUNICODE_STRING ObjectName,
	ULONG Attributes,
	PACCESS_STATE AccessState,
	ACCESS_MASK DesiredAccess,
	POBJECT_TYPE ObjectType,
	KPROCESSOR_MODE AccessMode,
	PVOID ParseContext,
	PVOID *Object
);

NTSTATUS ObQueryNameString(
	PVOID                    Object,
	POBJECT_NAME_INFORMATION ObjectNameInfo,
	ULONG                    Length,
	PULONG                   ReturnLength
);

ULONG g_MajorVersion = 0 ;
ULONG g_MinorVersion = 0 ;
ULONG g_BuildNumber  = 0 ; 

/////////////////////////////////////////////////////////////////////////////////////////////// 
//// Prototype
//// 
PVOID NTAPI RtlPcToFileHeader(_In_ PVOID PcValue, _Out_ PVOID *BaseOfImage);

/////////////////////////////////////////////////////////////////////////////////////////////// 
//// Implementation
////   
// A wrapper of RtlPcToFileHeader
PVOID UtilPcToFileHeader(PVOID pc_value) 
{
  void *base = NULL;
  return RtlPcToFileHeader(pc_value,&base); 
}
 


//----------------------------------------------------------------------------------------//
ULONG GetNextFdoExtOffset()
{
	ULONG Offset = 0;
	PsGetVersion(&g_MajorVersion, &g_MinorVersion, &g_BuildNumber, NULL);

	if(g_BuildNumber == 6000)
	{
		Offset = 0x1D0;
	}
	else if(g_BuildNumber==7600 || g_BuildNumber==7601)//windows7
	{
		Offset = 0x1E0; 
	}
	else if(g_BuildNumber==9200)//windows8
	{
		Offset = 0x1E0; 
	}
	else if(g_BuildNumber==9600)//windows8.1
	{
		Offset = 0x1A8; 
	}
	else if(g_BuildNumber > 10000)
	{
		Offset = 0x1A8;
	} 
	
	return Offset ; 
}
//----------------------------------------------------------------------------------------//
NTSTATUS GetDriverObjectByName(WCHAR* name, PDRIVER_OBJECT* pDriverObj)
{
	// use such API  
	NTSTATUS status = STATUS_UNSUCCESSFUL;
	UNICODE_STRING DriverName = { 0 };

	if (name && pDriverObj)
	{
		RtlInitUnicodeString(&DriverName, name);

		status = ObReferenceObjectByName(
			&DriverName,
			OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE,
			NULL,
			0,
			*IoDriverObjectType,
			KernelMode,
			NULL,
			(PVOID*)pDriverObj);
	}

	return status;
}
//----------------------------------------------------------------------------------------//
NTSTATUS ReleaseDriverObject(PDRIVER_OBJECT pDriverObj)
{
	// use such API  
	NTSTATUS status = STATUS_SUCCESS;
	if(!pDriverObj)
	{
		status = STATUS_UNSUCCESSFUL;
		return status;
	}
	
	ObDereferenceObject(pDriverObj);
	pDriverObj = NULL; 
	return status;
}
	 
//----------------------------------------------------------------------------------------//
NTSTATUS GetDeviceName(PDEVICE_OBJECT device_object, WCHAR* DeviceNameBuf)
{
	UCHAR	 Buffer[sizeof(OBJECT_NAME_INFORMATION) + 512] = { 0 };
	POBJECT_NAME_INFORMATION NameInfo = (PVOID)Buffer;
	ULONG Length	= 0;
	NTSTATUS status = STATUS_UNSUCCESSFUL;

	if (DeviceNameBuf && device_object)
	{
		status = ObQueryNameString(device_object, NameInfo, sizeof(Buffer), &Length);

		if (NT_SUCCESS(status))
		{
			RtlMoveMemory(DeviceNameBuf, NameInfo->Name.Buffer, NameInfo->Name.Length);
		} 
	} 
	return status;
}


//----------------------------------------------------------------------------------------//
NTSTATUS USBSymLinkToPath(PUNICODE_STRING pusSymLink, PUNICODE_STRING pusDosPath) 
{
	UNICODE_STRING usSymLinkPath;
	NTSTATUS       ntStatus;
	PFILE_OBJECT   pfVolume;
	PDEVICE_OBJECT pdVolume;

	// Check parameters
	if (!pusSymLink || !pusDosPath) return STATUS_INVALID_PARAMETER;

	// Create symbolic link path
	usSymLinkPath.Length = 0;
	usSymLinkPath.MaximumLength = pusSymLink->MaximumLength + 8;
	usSymLinkPath.Buffer = ExAllocatePoolWithTag(NonPagedPool, usSymLinkPath.MaximumLength, 'symp');
	RtlAppendUnicodeToString(&usSymLinkPath, L"\\??\\");
	RtlAppendUnicodeStringToString(&usSymLinkPath, pusSymLink);

	// Get file object and device object for volume
	ntStatus = IoGetDeviceObjectPointer(&usSymLinkPath, FILE_ALL_ACCESS, &pfVolume, &pdVolume);
	ExFreePool(usSymLinkPath.Buffer);
	if (!NT_SUCCESS(ntStatus)) return ntStatus;

	// Get DOS name for volume
	ntStatus = IoVolumeDeviceToDosName(pdVolume, pusDosPath);
	ObDereferenceObject(pfVolume);
	return ntStatus;
}
//-----------------------------------------------------------------------------------
void* MapNonpagedMemToSpace(void* base, ULONG size, PMDL* Lpmdl, KPROCESSOR_MODE  AccessMode, ULONG Protect)
{
	PMDL	 		Mdl = NULL;
	void*			ret = NULL;

	if (Lpmdl)
	{
		*Lpmdl = NULL;
	}

	Mdl = IoAllocateMdl(base, size, FALSE, FALSE, NULL);
	if (Mdl)
	{

		MmBuildMdlForNonPagedPool(Mdl);

		if (AccessMode == UserMode){
			ret = MmMapLockedPagesSpecifyCache(Mdl, AccessMode, MmCached, NULL, FALSE, NormalPagePriority);
		}

		if (ret == NULL)
		{
			IoFreeMdl(Mdl);
			return NULL;
		}

		if (Protect)
		{
			NTSTATUS  status = MmProtectMdlSystemAddress(Mdl, Protect);
			if (!NT_SUCCESS(status))
			{
				MmUnmapLockedPages(ret, Mdl);
				ret = NULL;
				IoFreeMdl(Mdl);
				Mdl = NULL;
				DbgPrint("MmProtectMdlSystemAddress.\n");
			}
		}
		if (Lpmdl)
		{
			*Lpmdl = Mdl;
		}
	}
	return ret;
}
```

`UsbMon/UsbMon/CommonUtil.h`:

```h
#ifndef __UTIL_HEADER__
#define __UTIL_HEADER__ 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
//// Type
//// 
typedef ULONG	 LOOKUP_STATUS;

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
//// Marco
//// 
#ifndef _In_
#define _In_
#endif // !
#ifndef _Out_
#define _Out_
#endif // !
#ifndef _Out_opt_
#define _Out_opt_
#endif // !
#ifndef _Inout_
#define _Inout_
#endif // !
#ifndef _Inout_opt_
#define _Inout_opt_
#endif // !
#ifndef _In_opt_
#define _In_opt_
#endif // !



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
//// Marco Utility
//// 
/// Sets a break point that works only when a debugger is present
#if !defined(HYPERPLATFORM_COMMON_DBG_BREAK)
#define USB_MON_COMMON_DBG_BREAK() \
  if (KD_DEBUGGER_NOT_PRESENT) {         \
  } else {                               \
    __debugbreak();                      \
  }                                      \
  (void*)(0)
#endif




#define USB_NATIVE_DEBUG_INFO(format, ...)	DbgPrintEx(0,0,format,__VA_ARGS__) 

#define USB_COMMON_DEBUG_INFO(format, ...)	USB_NATIVE_DEBUG_INFO("[%s] => [%d] : "format, __FILE__ ,  __LINE__,  __VA_ARGS__)
#define USB_DEBUG_INFO_LN()					USB_NATIVE_DEBUG_INFO("\r\n")
#define USB_DEBUG_INFO_LN_EX(format, ...)	USB_COMMON_DEBUG_INFO(format"\r\n", __VA_ARGS__)

#define DELAY_ONE_MICROSECOND 	(-10)
#define DELAY_ONE_MILLISECOND	(DELAY_ONE_MICROSECOND*1000)

#define DUMP_DEVICE_NAME(DeviceObject) \
		WCHAR DeviceName[256] = {0};		\
		GetDeviceName(DeviceObject, DeviceName);	\
		USB_DEBUG_INFO_LN_EX("DriverName: %ws DeviceName: %ws Flags: %x", DeviceObject->DriverObject->DriverName.Buffer, DeviceName, UrbGetTransferFlags(pContext->urb));	\

#define UNREFERENCED_PARAMETER(P)          (P)

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
//// Prototype
//// 
NTSTATUS ReleaseDriverObject(
	PDRIVER_OBJECT pDriverObj
);

NTSTATUS KernelSleep(
	_In_ LONG msec
);

NTSTATUS GetDriverObjectByName(
	_In_  WCHAR* name, 
	_Out_ PDRIVER_OBJECT* pDriverObj
);

NTSTATUS GetDeviceName(
	_In_  PDEVICE_OBJECT device_object, 
	_Out_ WCHAR* DeviceNameBuf
);

void* MapNonpagedMemToSpace(
	void* base,
	ULONG size,
	PMDL* Lpmdl,
	KPROCESSOR_MODE  AccessMode,
	ULONG Protect
);

  

#endif
```

`UsbMon/UsbMon/Driver.c`:

```c

#include <fltKernel.h> 
#include "HidHijack.h"

/////////////////////////////////////////////////////////////////////////////////////////////// 
////	Types
////  

///////////////////////////////////////////////////////////////////////////////////////////////
////	Marco Utilities
////  
////  

///////////////////////////////////////////////////////////////////////////////////////////////
////	Global Variable
////
//// 
PDEVICE_OBJECT				g_DeviceObject = NULL;

 
/////////////////////////////////////////////////////////////////////////////////////////////// 
////	Prototype
//// 
////

/////////////////////////////////////////////////////////////////////////////////////////////// 
////	Implementation
//// 
////

#define USBMON_WIN32_DEVICE_NAME_A		"\\\\.\\UsbMon"
#define USBMON_WIN32_DEVICE_NAME_W		L"\\\\.\\UsbMon"
#define USBMON_DEVICE_NAME_A			"\\Device\\UsbMon"
#define USBMON_DEVICE_NAME_W			L"\\Device\\UsbMon"
#define USBMON_DOS_DEVICE_NAME_A		"\\DosDevices\\UsbMon"
#define USBMON_DOS_DEVICE_NAME_W		L"\\DosDevices\\UsbMon"

typedef struct _DEVICE_EXTENSION
{
	ULONG  StateVariable;
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

#define FILE_DEVICE_HIDE	0x8000

#define IOCTL_BASE	0x800

#define CTL_CODE_HIDE(i)	\
	CTL_CODE(FILE_DEVICE_HIDE, IOCTL_BASE+i, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_USB_MAPPING_START		CTL_CODE_HIDE(1)			//初始化
#define IOCTL_USB_MAPPING_STOP		CTL_CODE_HIDE(2)			//初始化
#define IOCTL_HIDE_STOP				CTL_CODE_HIDE(3)			//初始化


//--------------------------------------------------------------------------------------//
NTSTATUS DispatchUsbInternalCtrl(
	IN PVOID InputBuffer,
	IN ULONG InputBufferLength,
	IN PVOID OutputBuffer,
	IN ULONG OutputBufferLength,
	IN ULONG IoControlCode,
	IN PIO_STATUS_BLOCK pIoStatus)
{	
	HANDLE hEvent = *(HANDLE*)InputBuffer;
	ULONG64 user_mode_addr = 0;
	PEPROCESS  hiddenProc;
	NTSTATUS	 status = STATUS_UNSUCCESSFUL;
 
	switch (IoControlCode)
	{
	case IOCTL_USB_MAPPING_START:

		if (!hEvent)
		{
			USB_COMMON_DEBUG_INFO("Null Event handle \r\n");
			break;
		}

		MapUsbDataToUserAddressSpace(&user_mode_addr, hEvent);

		if (user_mode_addr)
		{ 
			USB_COMMON_DEBUG_INFO("user_mode_addr: %I64x \r\n", user_mode_addr);
			*(PULONG64)OutputBuffer = user_mode_addr;
			pIoStatus->Information = sizeof(ULONG64);
			pIoStatus->Status = STATUS_SUCCESS;
		}
		break;

	case IOCTL_USB_MAPPING_STOP:
	{
 
	}
	break;

	case IOCTL_HIDE_STOP:
	{

	}
	break;

	default:
		break;
	}
	USB_COMMON_DEBUG_INFO("Return I/O \r\n");
	return status;
}
//--------------------------------------------------------------------------------------//
NTSTATUS UsbMonDeviceCtrlRoutine(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
)
{
	NTSTATUS			status = STATUS_SUCCESS;
	PIO_STATUS_BLOCK	ioStatus;
	PIO_STACK_LOCATION	pIrpStack;
	PDEVICE_EXTENSION	deviceExtension;
	PVOID				inputBuffer, outputBuffer;
	ULONG				inputBufferLength, outputBufferLength;
	ULONG				ioControlCode;
 
	pIrpStack = IoGetCurrentIrpStackLocation(Irp);
	deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;

	ioStatus = &Irp->IoStatus;
	ioStatus->Status = STATUS_SUCCESS;		// Assume success
 
											//
											// Get the pointer to the input/output buffer and it's length
	inputBuffer = Irp->AssociatedIrp.SystemBuffer;
	inputBufferLength = pIrpStack->Parameters.DeviceIoControl.InputBufferLength;
	outputBuffer = Irp->AssociatedIrp.SystemBuffer;
	outputBufferLength = pIrpStack->Parameters.DeviceIoControl.OutputBufferLength;
	ioControlCode = pIrpStack->Parameters.DeviceIoControl.IoControlCode;

	DbgPrintEx(0, 0, "MajorFunc :%x \n", pIrpStack->MajorFunction );


	switch (pIrpStack->MajorFunction)
	{
	case IRP_MJ_CREATE:
		DbgPrint("[$ARK]<-IRP_MJ_CREATE.\n");
		break;

	case IRP_MJ_CLOSE:
		DbgPrint("[$ARK]->IRP_MJ_CLOSE.\n");
		break;

	case IRP_MJ_SHUTDOWN:
		DbgPrint("[$ARK] IRP_MJ_SHUTDOWN.\n");
		break;

	case IRP_MJ_DEVICE_CONTROL: 

		DbgPrintEx(0, 0, "IRP_MJ_DEVICE_CONTROL: %X IOCTL_USB_MAPPING_START:%x \n", ioControlCode, IOCTL_USB_MAPPING_START);

		DispatchUsbInternalCtrl(inputBuffer,
			inputBufferLength,
			outputBuffer,
			outputBufferLength,
			ioControlCode,
			ioStatus);
		break;
	}

	//
	// TODO: if not pending, call IoCompleteRequest and Irp is freed.
	// 
	Irp->IoStatus.Status = ioStatus->Status;
	Irp->IoStatus.Information = ioStatus->Information;
	IoCompleteRequest(Irp, IO_NO_INCREMENT); 

	return  status;
}

//--------------------------------------------------------------------------------------//
NTSTATUS DeleteDevice()
{
	UNICODE_STRING		dosDeviceName;
	NTSTATUS			status;

	RtlInitUnicodeString(&dosDeviceName, USBMON_DOS_DEVICE_NAME_W);
	status = IoDeleteSymbolicLink(&dosDeviceName);
	IoDeleteDevice(g_DeviceObject);
	return status;
}
//--------------------------------------------------------------------------------------//
NTSTATUS CreateDevice(PDRIVER_OBJECT DriverObject, PDEVICE_OBJECT* DeviceObject)
{
	PDEVICE_OBJECT		   DeviceObj;
	UNICODE_STRING		ntDeviceName;
	UNICODE_STRING		dosDeviceName;
	NTSTATUS			status;
	RtlInitUnicodeString(&ntDeviceName, USBMON_DEVICE_NAME_W);

	status = IoCreateDevice(
		DriverObject,
		sizeof(DEVICE_EXTENSION),		// DeviceExtensionSize
		&ntDeviceName,					// DeviceName
		FILE_DEVICE_UNKNOWN,			// DeviceType
		0,								// DeviceCharacteristics
		TRUE,							// Exclusive
		&DeviceObj					// [OUT]
	);

	if (!NT_SUCCESS(status))
	{
		DbgPrintEx(0,0,"[$XTR] IoCreateDevice failed(0x%x).\n", status);
		return STATUS_UNSUCCESSFUL;
	}

	DeviceObj->Flags |= DO_BUFFERED_IO;
	  
	RtlInitUnicodeString(&dosDeviceName, USBMON_DOS_DEVICE_NAME_W);

	status = IoCreateSymbolicLink(&dosDeviceName, &ntDeviceName);

	if (!NT_SUCCESS(status))
	{
		DbgPrint(0,0,"[$XTR] IoCreateSymbolicLink failed(0x%x).\n", status);
		return STATUS_UNSUCCESSFUL;
	}

	DriverObject->MajorFunction[IRP_MJ_CREATE] =
	DriverObject->MajorFunction[IRP_MJ_CLOSE]  =
	DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = UsbMonDeviceCtrlRoutine;

	*DeviceObject = DeviceObj;

	return STATUS_SUCCESS;
}
//-----------------------------------------------------------------------------------------
VOID DriverUnload(
	_In_ struct _DRIVER_OBJECT *DriverObject
)
{ 
	UNREFERENCED_PARAMETER(DriverObject);
	UnInitializeHidPenetrate();
	//DeleteDevice();
	return;
} 

//----------------------------------------------------------------------------------------//
NTSTATUS DriverEntry(
	_In_ PDRIVER_OBJECT object, 
	_In_ PUNICODE_STRING String)
{ 
	NTSTATUS						  status = STATUS_UNSUCCESSFUL;
	status = UsbPenerateConfigInit();

	object->DriverUnload			     = DriverUnload;
	return status;
} 
//----------------------------------------------------------------------------------------//
```

`UsbMon/UsbMon/HidHijack.c`:

```c

#include <fltKernel.h>  
#include "UsbUtil.h" 
#include "UsbHid.h" 
#include "IrpHook.h"
#include "Usbioctl.h"
#include "ReportUtil.h"
#include "OpenLoopBuffer.h"
#include "WinParse.h"
#include "UsbType.h" 
#include "Tlist.h"

#pragma warning (disable : 4100) 


/////////////////////////////////////////////////////////////////////////////////////////////// 
//// Types
////  

#define SYSTEM_PTE_RANGE_START 0xFFFFF88000000000	
#define SYSTEM_PTE_RANGE_END   0xFFFFF89FFFFFFFFF	 

#define INSIDE_SYSTEM_PTE_RANGE(Address) (Address >= SYSTEM_PTE_RANGE_START && Address <= SYSTEM_PTE_RANGE_END)

#define NONE 0xFF

#define KPAD(_X_) 0x ## _X_ ## F0
#define SHFT(_X_) 0x ## _X_ ## F1
#define VEND(_X_) 0x ## _X_ ## F2


#define USB_MOU_DATA_HASH_MAKER(Data1)	\
	(Data1.x * Data1.x * 0x12356121 + Data1.y * Data1.y + 0x32151511 + Data1.z * Data1.z + Data1.Click * Data1.Click)

#define PRESS_MAKE 	0 
#define PRESS_BREAK 1

ULONG HidP_KeyboardToScanCodeTable[0x100] = {
	//
	// This is a straight lookup table
	//
	//     + 00     + 01     + 02     + 03     + 04     + 05     + 06    + 07
	//     + 08         + 09     + 0A     + 0B     + 0C     + 0D     + 0E    + OF
	/*0x00*/ NONE,    NONE,    NONE,    NONE,    0x1E,    0x30,    0x2E,   0x20,
	/*0x08*/ 0x12,    0x21,    0x22,    0x23,    0x17,    0x24,    0x25,   0x26,
	/*0x10*/ 0x32,    0x31,    0x18,    0x19,    0x10,    0x13,    0x1F,   0x14,
	/*0x18*/ 0x16,    0x2F,    0x11,    0x2D,    0x15,    0x2C,    0x02,   0x03,
	/*0x20*/ 0x04,    0x05,    0x06,    0x07,    0x08,    0x09,    0x0A,   0x0B,
	/*0x28*/ 0x1C,    0x01,    0x0E,    0x0F,    0x39,    0x0C,    0x0D,   0x1A,
	/*0x30*/ 0x1B,    0x2B,    0x2B,    0x27,    0x28,    0x29,    0x33,   0x34,
	/*0x38*/ 0x35,    SHFT(8), 0x3B,    0x3C,    0x3D,    0x3E,    0x3F,   0x40,
	/*0x40*/ 0x41,    0x42,    0x43,    0x44,    0x57,    0x58,    KPAD(0),SHFT(9),
	/*0x48*/ 0x451DE1,KPAD(1), KPAD(2), KPAD(3), KPAD(4), KPAD(5), KPAD(6),KPAD(7),
	/*0x50*/ KPAD(8), KPAD(9), KPAD(A), SHFT(A), 0x35E0,  0x37,    0x4A,   0x4E,
	/*0x58*/ 0x1CE0,  0x4F,    0x50,    0x51,    0x4B,    0x4C,    0x4D,   0x47,
	/*0x60*/ 0x48,    0x49,    0x52,    0x53,    0x56,    0x5DE0,  NONE,   0x59,
	/*0x68*/ 0x5d,    0x5e,    0x5f,    NONE,    NONE,    NONE,    NONE,   NONE,
	/*0x70*/ NONE,    NONE,    NONE,    NONE,    NONE,    NONE,    NONE,   NONE,
	/*0x78*/ NONE,    NONE,    NONE,    NONE,    NONE,    NONE,    NONE,   NONE,
	/*0x80*/ NONE,    NONE,    NONE,    NONE,    NONE,    0x7E,    NONE,   0x73,
	/*0x88*/ 0x70,    0x7d,    0x79,    0x7b,    0x5c,    NONE,    NONE,   NONE,
	/*0x90*/ VEND(0), VEND(1), 0x78,    0x77,    0x76,    NONE,    NONE,   NONE,
	/*0x98*/ NONE,    NONE,    NONE,    NONE,    NONE,    NONE,    NONE,   NONE,
	/*0xA0*/ NONE,    NONE,    NONE,    NONE,    NONE,    NONE,    NONE,   NONE,
	/*0xA8*/ NONE,    NONE,    NONE,    NONE,    NONE,    NONE,    NONE,   NONE,
	/*0xB0*/ NONE,    NONE,    NONE,    NONE,    NONE,    NONE,    NONE,   NONE,
	/*0xB8*/ NONE,    NONE,    NONE,    NONE,    NONE,    NONE,    NONE,   NONE,
	/*0xC0*/ NONE,    NONE,    NONE,    NONE,    NONE,    NONE,    NONE,   NONE,
	/*0xC8*/ NONE,    NONE,    NONE,    NONE,    NONE,    NONE,    NONE,   NONE,
	/*0xd0*/ NONE,    NONE,    NONE,    NONE,    NONE,    NONE,    NONE,   NONE,
	/*0xD8*/ NONE,    NONE,    NONE,    NONE,    NONE,    NONE,    NONE,   NONE,
	/*0xE0*/ SHFT(0), SHFT(1), SHFT(2), SHFT(3), SHFT(4), SHFT(5), SHFT(6),SHFT(7),
	/*0xE8*/ NONE,    NONE,    NONE,    NONE,    NONE,    NONE,    NONE,   NONE,
	/*KPAD*/ NONE,    NONE,    NONE,    NONE,    NONE,    NONE,    NONE,   NONE,
	/*0xF8*/ NONE,    NONE,    NONE,    NONE,    NONE,    NONE,    NONE,   NONE,
};


ULONG HidP_XlateKbdPadCodesSubTable[] = {
	/*     + 00    + 01    + 02     + 03    + 04    + 05    + 06     + 07 */
	/*     + 08    + 09    + 0A     + 0B    + 0C    + 0D    + 0E     + OF */
	/*0x40*/                                                  0x37E0,
	/*0x48*/         0x52E0, 0x47E0, 0x49E0,  0x53E0, 0x4FE0, 0x51E0,  0x4DE0,
	/*0x50*/ 0x4BE0, 0x50E0, 0x48E0
};


ULONG HidP_XlateModifierCodesSubTable[] = {
	//
	// NOTE These modifier codes in this table are in a VERY SPECIAL order.
	// that is: they are in the order of appearence in the
	// _HIDP_KEYBOARD_SHIFT_STATE union.
	//
	//     + 00   + 01   + 02   + 03    + 04    + 05   + 06    + 07
	//     + 08   + 09   + 0A   + 0B    + 0C    + 0D   + 0E    + OF
	//       LCtrl  LShft  LAlt   LGUI    RCtrl   RShft  RAlt    RGUI
	/*0xE0*/ 0x1D,  0x2A,  0x38,  0x5BE0, 0x1DE0, 0x36,  0x38E0, 0x5CE0,
	/*0x39 CAPS_LOCK*/     0x3A,
	/*0x47 SCROLL_LOCK*/   0x46,
	/*0x53 NUM_LOCK*/      0x45
	// This table is set up so that indices into this table greater than 7
	// are sticky.  HidP_ModifierCode uses this as an optimization for
	// updating the Modifier state table.
	//
};



typedef struct IRP_HOOK_INFORMATION
{
	PENDINGIRPLIST*   pendingList;
	PVOID			  CompletionRoutine;
	PVOID			  OldRoutine;
	PVOID			  NewRoutine;
	PDRIVER_OBJECT	  DriverObject;		//UsbHub DriverObject
	ULONG			  IrpCode;
}IRPHOOKINFO, *PIRPHOOKINFO;


typedef struct HIJACK_CONTEXT
{
	PENDINGIRP			    pending_irp;		// pending irp node for cancellation 
	PDEVICE_OBJECT		   DeviceObject;		// Hid deivce
	PURB							urb;		// Urb packet saved in IRP hook
	HID_DEVICE_NODE*			   node;		// An old context we need  
}HIJACK_CONTEXT, *PHIJACK_CONTEXT;

/*
multi-process struct
*/
#pragma pack(push, 8)
typedef struct _USERPROCESS_INFO
{
	PEPROCESS proc;
	PVOID     MappedMouseAddr;
	PVOID     MappedKeyboardAddr;
	PMDL      MouseMdl;
	PMDL      KeyboardMdl;
}USERPROCESSINFO, *PUSERPROCESSINFO;
#pragma pack(pop)

#pragma pack(push, 8)
typedef struct _REPORT_MACRO_INFO
{
	LONG	 Data[8];
	CHAR	str[256];
}REPORTMACROINFO, *PREPORTMACROINFO;
#pragma pack(pop)

///////////////////////////////////////////////////////////////////////////////////////////////
////	Marco Utilities
////  
//// 	 

#define IsSafeNode(x)					 (x->node)
//Hijack Context Marco

//urb Marco
#define UrbGetFunction(urb)				 (urb->UrbHeader.Function)
#define UrbGetTransferBuffer(urb)		 (urb->UrbBulkOrInterruptTransfer.TransferBuffer)
#define UrbGetTransferFlags(urb)		 (urb->UrbBulkOrInterruptTransfer.TransferFlags)
#define UrbGetTransferLength(urb)		 (urb->UrbBulkOrInterruptTransfer.TransferBufferLength) 
#define UrbGetTransferPipeHandle(urb)	 (urb->UrbBulkOrInterruptTransfer.PipeHandle)
#define UrbIsInputTransfer(urb)			 (UrbGetTransferFlags(urb) & (USBD_TRANSFER_DIRECTION_IN ))
#define UrbIsOutputTransfer(urb)		 (UrbGetTransferFlags(urb) & (USBD_TRANSFER_DIRECTION_OUT | USBD_DEFAULT_PIPE_TRANSFER))

#define USB_PEN_INIT_VERSION			 0x00000001
#define USB_PEN_PROTOCOL_VERSION		 0x00000001 


#define USB_MOUDATA_ABS_FLAGS 			 0x80000000
#define CB_SIZE 					 			128  
#define REPORT_MAX_COUNT 						  7
#define MAX_COORDINATE_ERROR					250
#define CONFIG_ARRAY_SIZE						  5 
#define COUNT_OF_REPORTID						  4
#define BITSIZE_OF_UCHAR				 		  8

#define RI_KEY_E0               				 2
#define RI_KEY_E1              					 4

#define IN_MATCH						 0xAF731671
#define NOT_IN_MATCH					 0x35781313
///////////////////////////////////////////////////////////////////////////////////////////////
////	Global Variable
////
////
DRIVER_DISPATCH*  g_HidPnpHandler = NULL;
BOOLEAN			  g_bLoaded = FALSE;
BOOLEAN 		  g_bUnloaded = FALSE;
TChainListHeader* g_ProcessInfo = NULL;
ULONG 			  g_ProcessCount = 0;
CIRCULARBUFFER*	  g_mou_data = NULL;
CIRCULARBUFFER*	  g_kbd_data = NULL;
ULONG 			  g_ReportRate = 8;
BOOLEAN			  g_IsFixedReportRate = FALSE;
BOOLEAN			  g_IsBugReported[2] = { 0 };
BOOLEAN			  g_IsReportRawDesc = FALSE;
BOOLEAN			  g_IsCheckIrpHook = FALSE;
ULONG 			  g_Index = 0;
LONG			  g_CompatibleRateX = 100;
LONG			  g_CompatibleRateY = 100;
LONG 		 	  g_RemainderX = 0;
LONG 			  g_RemainderY = 0;
HIDCONTEXT		  g_HidContext = { 0 };
BOOLEAN			  g_TpDataUsed[3] = { 0 };
BOOLEAN			  g_KeyStatus[512] = { 0 };
BOOLEAN 		  g_IsDifferentReport[2] = { 0 };
BOOLEAN			  g_KeyboardCompatibleMode = FALSE;
BOOLEAN			  g_IsEnableReportHidMiniDrv = FALSE;
BOOLEAN			  g_IsSelfProtect = FALSE;
ULONG64			  g_IsEnableModuleChecksum = 0;
ULONG 			  g_EncryptKey[4] = { 0 };
BOOLEAN			  g_bIsReportedCompFuncAttack = FALSE;
BOOLEAN			  g_bIsReportedCallbackHookAttack = FALSE;
BOOLEAN			  g_bIsReportedCompleteHookAttack = FALSE;

ULONG64 		  g_MaxPacketTime = 0;
BOOLEAN 		  g_EnableClick = 0;
BOOLEAN			  g_IsDetectHardwareMacro = 0;
LONG 			  g_SumOfYaxis = 0;
LONG			  g_LastAvgOfYaxis = 0;
LONG 			  g_CatchedTimes = 0;
LONG 			  g_CheatTimes = 0;
LONG 			  g_ClickTimes = 0;
ULONG64 		  g_StartTime = 0;
ULONG64 		  g_LastClickTime = 0;
ULONG64 		  g_LastTime = 0;
ULONG			  g_TimeOffset = 0;
LONG64			  g_ReportAvgMax = 0;
LONG			  g_TotalAvgOfYaxis = 0;
ULONG64			  g_MaxClickTimes = 0;
ULONG			  g_IsHwMacroReported = 0;
BOOLEAN			  g_LastKeyDown = FALSE;

extern PHID_DEVICE_LIST g_HidClientPdoList;
extern PUSB_HUB_LIST 	g_UsbHubList;


 PVOID UtilPcToFileHeader(
	_In_ PVOID pc_value
);
/////////////////////////////////////////////////////////////////////////////////////////////// 
//// Prototype
//// 
////

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

- Dispatch USB Keyboard Data to User Mode Mapped Buffer
It only called by HandleKeyboardData as it initilize
EXTRACTDATA structure.

Arguments:
pContext	- Hijack Context included all we need
see HIJACK_CONTEXT declaration.

Return Value:
NTSTATUS	- STATUS_SUCCESS 		if Handle successfully
- STATUS_UNSUCCESSFUL 	if failed
-------------------------------------------------------*/
NTSTATUS DispatchKeyboardData(
	_In_ HIJACK_CONTEXT* pContext
);

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

- Dispatch USB Mouse Data to User Mode Mapped Buffer
It only called by HandleMousedData as it initilize
EXTRACTDATA structure.

Arguments:
pContext	- Hijack Context included all we need
see HIJACK_CONTEXT declaration.

Return Value:
NTSTATUS	- STATUS_SUCCESS 		if Handle successfully
- STATUS_UNSUCCESSFUL 	if failed
-------------------------------------------------------*/
NTSTATUS DispatchMouseData(
	_In_ HIJACK_CONTEXT* pContext
);

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

Handling And Extract data from keyboard URB

Arguments:
pContext	- Hijack Context included all we need
see HIJACK_CONTEXT declaration.

reportType	- Hid Report Type
-	HidP_Input,
-	HidP_Output,
-	HidP_Feature

Return Value:
NTSTATUS	- STATUS_SUCCESS 		if Handle successfully
- STATUS_UNSUCCESSFUL 	if failed
-------------------------------------------------------*/
NTSTATUS HandleKeyboardData(
	_In_ HIJACK_CONTEXT* pContext,
	_In_ HIDP_REPORT_TYPE reportType
);


/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

Handling And Extract data from mouse URB

Arguments:

pContext	- Hijack Context included all we need ,
see HIJACK_CONTEXT declaration.

reportType  -	Hid Report Type
-	HidP_Input,
-	HidP_Output,
-	HidP_Feature

Return Value:
NTSTATUS	- STATUS_SUCCESS	  if Handle successfully
- STATUS_UNSUCCESSFUL if failed
-------------------------------------------------------*/
NTSTATUS HandleMouseData(
	_In_ HIJACK_CONTEXT* pContext,
	_In_ HIDP_REPORT_TYPE reportType
);


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

- Proxy Function of USB Hub 2 / 3 of Internal Control Irp

- It intercept all internal IOCTL ,

I.e. IOCTL_INTERNAL_USB_SUBMIT_URB -> URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER

1. Check is it mouse / keyboard

2. Save a IRP Context (included old IRP completion function and context)

3. Hook Completion of IRP

4. Insert into Pending IRP List

Arguments:

DeviceObject 		- USB Hub Device Object, iusb3hub , usbhub ,... etc

Irp			 		- IRP come from upper level

pPendingList 		- pre-allocated pending list , each hubs use private list for
storing pendign IRP

pCompletionRoutine  - IRP Completion Function Address

pOldFunction		- CALL Old Function

Return Value:

NTSTATUS	 - STATUS_UNSUCCESSFUL   , If failed of any one of argument check.
- STATUS_XXXXXXXXXXXX   , Depended on IRP Handler

-----------------------------------------------------------------------------------*/
NTSTATUS UsbhubIrpHandler(
	_Inout_ struct _DEVICE_OBJECT*	pDeviceObject,
	_Inout_ struct _IRP*			pIrp,
	_In_     PENDINGIRPLIST* 	   	pPendingList,
	_In_ 	 PIO_COMPLETION_ROUTINE pCompletionRoutine,
	_In_	 DRIVER_DISPATCH*		pOldFunction
);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

- Proxy Function of USB Hub IRP Completion Function (i.e. For URB IRP Request)
- It intercept all completion of Usbhub internal IOCTL ,

I.e. IOCTL_INTERNAL_USB_SUBMIT_URB -> URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER

1. Get its Collection first (one report descrirptor can own more than one
collection description) it distinct by reportID, if reportID = 0 ,
it means only one collection, vice versa.

2. Dispatch the data to the UserMode Mapped buffer (if it does exist)

Arguments:

DeviceObject 		- USB Hub Device Object, iusb3hub , usbhub ,... etc

Irp			 		- IRP that is going to be completed

Context 			- IRP Context , we modifiy the Completion context and saved
old context in new context

pPendingList  		- The pending IRP list we need to removed ( usb2 / usb3 uses
independent list. )


Return Value:

NTSTATUS	 - STATUS_UNSUCCESSFUL   , If failed of any one of argument check.
- STATUS_XXXXXXXXXXXX   , Depended on IRP Handler

-----------------------------------------------------------------------------------*/
NTSTATUS UsbIrpCompletionHandler(
	_In_     PDEVICE_OBJECT  	   DeviceObject,
	_In_     PIRP            	   Irp,
	_In_	 PVOID           	   Context,
	_In_     PENDINGIRPLIST* 	   pPendingList
);


//See HidHijack.h for detail
NTSTATUS InitializeHidPenetrate();

//See HidHijack.h for detail
NTSTATUS UnInitializeHidPenetrate();



/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

- Pnp Irp hook handler of UsbHid handler

- it verify the device first

- then insert or remove the node into the pipe list

- usbhub irp hook will next compared with it new device

Arguments:

DeviceObject - Client PDO we need

Irp		  - Irp request.

Return Value:

NTSTATUS	 - STATUS_UNSUCCESSFUL   , If failed of any one of argument check.
- STATUS_XXXXXXXXXXXX   , Depended on old completion

-----------------------------------------------------------------------------------*/
NTSTATUS HidUsbPnpIrpHandler(
	_Inout_ struct _DEVICE_OBJECT *DeviceObject,
	_Inout_ struct _IRP           *Irp
);



/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

- Free User-Mode Mapped Loop buffer

Arguments:

- No

Return Value:

NTSTATUS	 - STATUS_SUCCESS

-----------------------------------------------------------------------------------*/
NTSTATUS FreeMappedLoopBuffer();


//------------------------------------------------------------------------------------------//
extern PDO_EXTENSION*	GetClientPdoExtension(
	_In_ HIDCLASS_DEVICE_EXTENSION* HidCommonExt
);

//-----------------------------------------------------------------------------------------//
extern FDO_EXTENSION* GetFdoExtByClientPdoExt(
	_In_ PDO_EXTENSION* pdoExt
);


/*-----------------------------------------------------------------------------------*/
//	Stub
NTSTATUS  UsbCompletionCallback1(
	_In_     PDEVICE_OBJECT DeviceObject,
	_In_     PIRP           Irp,
	_In_	 PVOID          Context
);


/*-----------------------------------------------------------------------------------*/
//	Stub
NTSTATUS  UsbCompletionCallback2(
	_In_     PDEVICE_OBJECT DeviceObject,
	_In_     PIRP           Irp,
	_In_	 PVOID          Context
);

/*-----------------------------------------------------------------------------------*/
//	Stub
NTSTATUS  UsbCompletionCallback3(
	_In_     PDEVICE_OBJECT DeviceObject,
	_In_     PIRP           Irp,
	_In_	 PVOID          Context
);

/*-----------------------------------------------------------------------------------*/
//	Stub
NTSTATUS  UsbCompletionCallback4(
	_In_     PDEVICE_OBJECT DeviceObject,
	_In_     PIRP           Irp,
	_In_	 PVOID          Context
);


/*-----------------------------------------------------------------------------------*/
//	Stub
NTSTATUS  UsbCompletionCallback5(
	_In_     PDEVICE_OBJECT DeviceObject,
	_In_     PIRP           Irp,
	_In_	 PVOID          Context
);



/*-----------------------------------------------------------------------------------*/
//	Stub
NTSTATUS UsbHubInternalDeviceControl1(
	_Inout_ struct _DEVICE_OBJECT *DeviceObject,
	_Inout_ struct _IRP           *Irp
);



/*-----------------------------------------------------------------------------------*/
//	Stub
NTSTATUS UsbHubInternalDeviceControl2(
	_Inout_ struct _DEVICE_OBJECT *DeviceObject,
	_Inout_ struct _IRP           *Irp
);


/*-----------------------------------------------------------------------------------*/
//	Stub
NTSTATUS UsbHubInternalDeviceControl3(
	_Inout_ struct _DEVICE_OBJECT *DeviceObject,
	_Inout_ struct _IRP           *Irp
);



/*-----------------------------------------------------------------------------------*/
//	Stub
NTSTATUS UsbHubInternalDeviceControl4(
	_Inout_ struct _DEVICE_OBJECT *DeviceObject,
	_Inout_ struct _IRP           *Irp
);



/*-----------------------------------------------------------------------------------*/
//	Stub
NTSTATUS UsbHubInternalDeviceControl5(
	_Inout_ struct _DEVICE_OBJECT *DeviceObject,
	_Inout_ struct _IRP           *Irp
);

/*-----------------------------------------------------------------------------------*/


/////////////////////////////////////////////////////////////////////////////////////////////////
/// Hook Config

IRPHOOKINFO g_HookConfig[CONFIG_ARRAY_SIZE] =
{
	{
		NULL,                             //pendingList;
		UsbCompletionCallback1,		      //CompletionCallback ;
		NULL,                             //OldRoutine;
		UsbHubInternalDeviceControl1,     //NewRoutine;
		NULL,                             //DriverObject;		//UsbHub DriverObject
		IRP_MJ_INTERNAL_DEVICE_CONTROL    //IrpCode;
	}
	,
	{
		NULL,						       //pendingList;
		UsbCompletionCallback2,		       //CompletionCallback ;
		NULL,                              //OldRoutine;
		UsbHubInternalDeviceControl2,      //NewRoutine;
		NULL,                              //DriverObject;		//UsbHub DriverObject
		IRP_MJ_INTERNAL_DEVICE_CONTROL     //IrpCode;
	}
	,

	{
		NULL,						       //pendingList;
		UsbCompletionCallback3,		       //CompletionCallback ;
		NULL,                              //OldRoutine;
		UsbHubInternalDeviceControl3,      //NewRoutine;
		NULL,                              //DriverObject;		//UsbHub DriverObject
		IRP_MJ_INTERNAL_DEVICE_CONTROL     //IrpCode;
	}
	,

	{
		NULL,						        //pendingList;
		UsbCompletionCallback4,		        //CompletionCallback ;
		NULL,                               //OldRoutine;
		UsbHubInternalDeviceControl4,       //NewRoutine;
		NULL,                               //DriverObject;		//UsbHub DriverObject
		IRP_MJ_INTERNAL_DEVICE_CONTROL      //IrpCode;
	}
	,

	{
		NULL,						        //pendingList;
		UsbCompletionCallback5,		        //CompletionCallback ;
		NULL,                               //OldRoutine;
		UsbHubInternalDeviceControl5,       //NewRoutine;
		NULL,                               //DriverObject;		//UsbHub DriverObject
		IRP_MJ_INTERNAL_DEVICE_CONTROL      //IrpCode;
	}
};


/////////////////////////////////////////////////////////////////////////////////////////////// 
//// Implementation
////  



//----------------------------------------------------------------------------------------//
BOOLEAN GetKeyboardCompatibleMode()
{
	return g_KeyboardCompatibleMode;
}

//----------------------------------------------------------------------------------------//
VOID SetMouseDiffRate(
	_In_	LONG RateX,
	_In_	LONG RateY
)
{
	g_CompatibleRateX = RateX;
	g_CompatibleRateY = RateY;
}

//----------------------------------------------------------------------------------------//
NTSTATUS GetAndVerifyKeyboardUsageInCollection(
	_In_ UCHAR*					 pSourceReport,
	_In_ HIDP_DEVICE_DESC* 	 	 pDesc,
	_Out_ PHIDP_COLLECTION_DESC* pCollection
)
{
	return VerifyUsageInCollection(HID_KBD_USAGE, pSourceReport, pDesc, pCollection);
}

//----------------------------------------------------------------------------------------//
NTSTATUS GetAndVerifyMouseUsageInCollection(
	_In_ UCHAR*					 pSourceReport,
	_In_ HIDP_DEVICE_DESC* 	 	 pDesc,
	_Out_ PHIDP_COLLECTION_DESC* pCollection
)
{
	return VerifyUsageInCollection(HID_MOU_USAGE, pSourceReport, pDesc, pCollection);
}

//----------------------------------------------------------------------------------------//
NTSTATUS AllocateKeyboardDataStructure(
	_In_ HID_DEVICE_NODE* node,
	_In_ ULONG 			  ReportLen
)
{
	NTSTATUS status = STATUS_UNSUCCESSFUL;
	if (!node)
	{
		return STATUS_UNSUCCESSFUL;
	}
	if (node->PreviousUsageList)
	{
		return STATUS_SUCCESS;
	}

	if (!node->PreviousUsageList)
	{
		node->PreviousUsageList = ExAllocatePoolWithTag(NonPagedPool, PAGE_SIZE, 'kbdb');
	}

	if (node->PreviousUsageList)
	{
		RtlZeroMemory(node->PreviousUsageList, PAGE_SIZE);
		node->CurrentUsageList = node->PreviousUsageList + ReportLen;
		node->MakeUsageList = node->CurrentUsageList + ReportLen;
		node->BreakUsageList = node->MakeUsageList + ReportLen;
		status = STATUS_SUCCESS;
	}

	return status;
}
//----------------------------------------------------------------------------------------//
NTSTATUS DispatchKeyboardModifierState(PUCHAR RawUsbData, HID_DEVICE_NODE* KeyboardNode)
{
	int i = 0;

	if (!KeyboardNode || !RawUsbData)
	{
		return STATUS_UNSUCCESSFUL;
	}

	for (i = 0; i < BITSIZE_OF_UCHAR; i++)
	{
		UCHAR TestBit = 1 << i;
		if ((KeyboardNode->ModifierState.ul & TestBit) != (*(PUCHAR)RawUsbData & TestBit))
		{
			USERKBDDATA kbd_data = { 0 };
			if (*(PUCHAR)RawUsbData & TestBit)
			{
				KeyboardNode->ModifierState.ul |= TestBit;
				kbd_data.ScanCode = HidP_XlateModifierCodesSubTable[i];
				kbd_data.Flags = PRESS_MAKE;
				// if E0 key , special , since we use it for DX
				if ((kbd_data.ScanCode & 0xFF) == 0xE0)
				{
					kbd_data.ScanCode >>= 8;
					kbd_data.Flags |= RI_KEY_E0;
				}
				USB_DEBUG_INFO_LN_EX("Press Modifier[%d] ScanCode: %d ", i, kbd_data.ScanCode);
			}
			else
			{
				KeyboardNode->ModifierState.ul &= ~TestBit;
				kbd_data.ScanCode = HidP_XlateModifierCodesSubTable[i];
				kbd_data.Flags = PRESS_BREAK;

				// if E0 key , special , since we use it for DX
				if ((kbd_data.ScanCode & 0xFF) == 0xE0)
				{
					kbd_data.ScanCode >>= 8;
					kbd_data.Flags |= RI_KEY_E0;
				}

				USB_DEBUG_INFO_LN_EX("Release Modifier[%d] ScanCode: %d ", i, kbd_data.ScanCode);
			}
			OpenLoopBufferWrite(g_kbd_data, (const void*)&kbd_data);
		}
	}
	return STATUS_SUCCESS;
}
//----------------------------------------------------------------------------------------//
NTSTATUS GetUsageMakeAndBreakList(
	_In_  PCHAR  CurrentUsageList,
	_In_  PCHAR  PreviousUsageList,
	_In_  ULONG  NormalKeySizeInByte,
	_Out_ PCHAR  MakeUsageList,
	_Out_ PCHAR  BreakUsageList,
	_Out_ PULONG pMakeIndex,
	_Out_ PULONG pBreakIndex)
{
	BOOLEAN  IsFound = FALSE;
	ULONG  BreakIndex = 0;
	ULONG  MakeIndex = 0;
	ULONG  m, b = 0;
	ULONG i = 0, j = 0;;

	if (!CurrentUsageList || !PreviousUsageList || !MakeUsageList || !BreakUsageList)
	{
		return STATUS_UNSUCCESSFUL;
	}

	//calculate by bytes 
	for (i = 0; i < NormalKeySizeInByte; i++)
	{
		UCHAR UsageId = PreviousUsageList[i];
		IsFound = FALSE;
		for (j = 0; j < NormalKeySizeInByte; j++)
		{
			if (UsageId == CurrentUsageList[j])
			{
				IsFound = TRUE;
				break;
			}
		}
		if (!IsFound)
		{
			BreakUsageList[BreakIndex++] = UsageId;
		}
	}

	//calculate by bytes
	for (i = 0; i < NormalKeySizeInByte; i++)
	{
		UCHAR UsageId = CurrentUsageList[i];
		IsFound = FALSE;
		for (j = 0; j < NormalKeySizeInByte; j++)
		{
			if (UsageId == PreviousUsageList[j])
			{
				IsFound = TRUE;
				break;
			}
		}
		if (!IsFound)
		{
			MakeUsageList[MakeIndex++] = UsageId;
		}
	}

	b = BreakIndex;
	m = MakeIndex;

	while (b < NormalKeySizeInByte) {
		BreakUsageList[b++] = 0;
	}
	while (m < NormalKeySizeInByte) {
		MakeUsageList[m++] = 0;
	}

	if (pMakeIndex)
	{
		*pMakeIndex = MakeIndex;
	}

	if (pBreakIndex)
	{
		*pBreakIndex = BreakIndex;
	}

	return STATUS_SUCCESS;
}
//-----------------------------------------------------------------------------------------//
NTSTATUS PutKeyIntoBuffer(
	_In_ HID_DEVICE_NODE* KeyboardNode,
	_In_ CIRCULARBUFFER* LoopBuffer,
	_In_ UCHAR  HidKey,
	_In_ ULONG  MakeOrBreak
)
{
	USERKBDDATA kbd_data = { 0 };

	if (!LoopBuffer && HidKey <= 0xFF)
	{
		return STATUS_UNSUCCESSFUL;
	}
	//1. First Translation
	kbd_data.ScanCode = HidP_KeyboardToScanCodeTable[HidKey];
	kbd_data.Flags = MakeOrBreak;


	if (kbd_data.ScanCode == 0x451DE1)
	{
		//1. First Translation
		kbd_data.ScanCode = 0xC5;
		kbd_data.Flags = MakeOrBreak | RI_KEY_E0;
		OpenLoopBufferWrite(g_kbd_data, (const void*)&kbd_data);
		return STATUS_SUCCESS;
	}

	//2. Second Translation, if required choose table.
	if ((kbd_data.ScanCode & 0xFF) == 0xF0)
	{
		kbd_data.ScanCode = HidP_XlateKbdPadCodesSubTable[((kbd_data.ScanCode & 0xFF00) >> 8)];
		//All key of the Second translation table also are E0 key.
		//And change it to DIK Code
		kbd_data.ScanCode >>= 8;
		kbd_data.Flags |= RI_KEY_E0;
	}
	if ((kbd_data.ScanCode & 0xFF) == 0xF1)
	{
		int index = ((kbd_data.ScanCode & 0xFF00) >> 8);
		kbd_data.ScanCode = HidP_XlateModifierCodesSubTable[index];

		/*---

		FIXME:
		We are not able to be consistent with sticky physical keyboard modifier state. (NumLock/ ScrollLock / CapsLock)

		if(index > 7 && MakeOrBreak == 0)
		{
		KeyboardNode->ModifierState.ul = KeyboardNode->ModifierState.ul ^ (1 << index) ;
		}

		--- */

		// if E0 key , special , since we use it for DX
		if ((kbd_data.ScanCode & 0xFF) == 0xE0)
		{
			kbd_data.ScanCode >>= 8;
			kbd_data.Flags |= RI_KEY_E0;
		}
	}
	//No need second translation but it is direct E0 key in first table
	else if ((kbd_data.ScanCode & 0xFF) == 0xE0)
	{
		kbd_data.ScanCode >>= 8;
		kbd_data.Flags |= RI_KEY_E0;
	}

	if (HidKey != 0)
	{
		USB_DEBUG_INFO_LN_EX("Put [%d] key: %d DIKCode: %x ", MakeOrBreak, HidKey, kbd_data.ScanCode);
		OpenLoopBufferWrite(g_kbd_data, (const void*)&kbd_data);
	}

	return STATUS_SUCCESS;
}
//----------------------------------------------------------------------------------------//
NTSTATUS DispatchKeyboardNormalKey(
	_In_	PUCHAR 				RawUsbData,
	_In_	HID_DEVICE_NODE* 	KeyboardNode,
	_In_	ULONG 				NormalKeySizeInByte)
{
	ULONG OverrunErrorCheck = 0;
	ULONG i = 0, j = 0;
	CHAR* PreviousUsageList = NULL;
	CHAR* CurrentUsageList = NULL;
	CHAR* BreakUsageList = NULL;
	CHAR* MakeUsageList = NULL;
	ULONG MakeIndex = 0;
	ULONG BreakIndex = 0;

	NTSTATUS status = STATUS_UNSUCCESSFUL;


	if (!KeyboardNode || !RawUsbData)
	{
		return status;
	}

	PreviousUsageList = KeyboardNode->PreviousUsageList;
	CurrentUsageList = KeyboardNode->CurrentUsageList;
	BreakUsageList = KeyboardNode->BreakUsageList;
	MakeUsageList = KeyboardNode->MakeUsageList;

	if (!PreviousUsageList || !CurrentUsageList || !BreakUsageList || !MakeUsageList)
	{
		USB_DEBUG_INFO_LN_EX("FATAL: Empty Keyboard List Error");
		return status;
	}

	memcpy(CurrentUsageList, RawUsbData, NormalKeySizeInByte);

	GetUsageMakeAndBreakList(CurrentUsageList, PreviousUsageList, NormalKeySizeInByte, MakeUsageList, BreakUsageList, &MakeIndex, &BreakIndex);

	memcpy(&PreviousUsageList[0], &CurrentUsageList[0], NormalKeySizeInByte);

	USB_DEBUG_INFO_LN_EX("KeyboardNode->ModifierState: %x ", KeyboardNode->ModifierState);

	for (i = 0; i < BreakIndex; i++)
	{
		PutKeyIntoBuffer(KeyboardNode, g_kbd_data, BreakUsageList[i], 1);
	}

	for (i = 0; i < MakeIndex; i++)
	{
		PutKeyIntoBuffer(KeyboardNode, g_kbd_data, MakeUsageList[i], 0);
	}
	status = STATUS_SUCCESS;
	return status;
}
//----------------------------------------------------------------------------------------//
NTSTATUS DispatchKeyboardData(
	_In_ HIJACK_CONTEXT* pContext
)
{
	ULONG  i = 0;
	ULONG j = 0;
	NTSTATUS status = STATUS_UNSUCCESSFUL;
	EXTRACTDATA* data = NULL;
	ULONG OldState = 0;

	UCHAR IndexSpecialKey = 0xE0;
	ULONG SpecialKeySizeInByte = 0;
	ULONG ActiveReportLen = 0;
	ULONG NormalKeySizeInByte = 0;
	PUCHAR StartPtr = NULL;

	BOOLEAN IsFound = FALSE;

	if (!pContext)
	{
		return STATUS_UNSUCCESSFUL;
	}

	if (!pContext->node)
	{
		return STATUS_UNSUCCESSFUL;
	}

	data = pContext->node->ExtractedData[HidP_Input];
	if (!data)
	{
		status = STATUS_UNSUCCESSFUL;
		return status;
	}

	NormalKeySizeInByte = data->KBDDATA.NormalKeySize / 8;
	SpecialKeySizeInByte = data->KBDDATA.SpecialKeySize / 8;
	ActiveReportLen = SpecialKeySizeInByte + NormalKeySizeInByte;
	if (!ActiveReportLen)
	{
		USB_DEBUG_INFO_LN_EX("Zero Report Len");
		return status;
	}

	if (!pContext->node->PreviousUsageList)
	{
		status = AllocateKeyboardDataStructure(pContext->node, ActiveReportLen);
		if (!NT_SUCCESS(status))
		{
			USB_DEBUG_INFO_LN_EX("FATAL: Allocated Keyboard List Error");
			return status;
		}
	}

	StartPtr = (PUCHAR)UrbGetTransferBuffer(pContext->urb);
	if (data->KBDDATA.ReportId != 0)
	{
		if (data->KBDDATA.ReportId != *(PUCHAR)StartPtr)
		{
			status = STATUS_UNSUCCESSFUL;
			g_IsDifferentReport[1] = TRUE;
			return status;
		}
	}

	StartPtr += data->KBDDATA.SpecialKeyByteOffset;
	DispatchKeyboardModifierState(StartPtr, pContext->node);

	StartPtr = (PCHAR)UrbGetTransferBuffer(pContext->urb);
	StartPtr += data->KBDDATA.NormalKeyByteOffset;

	if (*StartPtr == 1)
	{
		USB_DEBUG_INFO_LN_EX("Overrun Packet");
		return status;
	}

	DispatchKeyboardNormalKey(StartPtr, pContext->node, NormalKeySizeInByte);

	USB_DEBUG_INFO_LN_EX("Kenrel USERKBDDATA size: %d", sizeof(USERKBDDATA));
	USB_DEBUG_INFO_LN_EX("Keyboard Request .... %x %x %x\r\n", data->KBDDATA.NormalKeyByteOffset, data->KBDDATA.SpecialKeyByteOffset, data->KBDDATA.NormalKeySize);

	return STATUS_SUCCESS;
}
//----------------------------------------------------------------------------------------//
void ReportMacroDetection(REPORTMACROINFO* info)
{
	if (!info)
	{
		return;
	}
	ExFreePool(info);
	info = NULL;

	return;
}

//----------------------------------------------------------------------------------------//
NTSTATUS DispatchMouseData(
	_In_	HIJACK_CONTEXT* pContext
)
{
	NTSTATUS status = STATUS_UNSUCCESSFUL;
	ULONG totalSize = 0;
	EXTRACTDATA* data = NULL;

	data = pContext->node->ExtractedData[HidP_Input];
	if (!data)
	{
		USB_DEBUG_INFO_LN_EX("data NULL");
		status = STATUS_UNSUCCESSFUL;
		return status;
	}

	if (data->MOUDATA.ReportIdDesc[0].ReportId)
	{
		if (data->MOUDATA.ReportIdDesc[0].ReportId != *(PCHAR)UrbGetTransferBuffer(pContext->urb) &&
			data->MOUDATA.ReportIdDesc[1].ReportId != *(PCHAR)UrbGetTransferBuffer(pContext->urb) &&
			data->MOUDATA.ReportIdDesc[2].ReportId != *(PCHAR)UrbGetTransferBuffer(pContext->urb) &&
			data->MOUDATA.ReportIdDesc[3].ReportId != *(PCHAR)UrbGetTransferBuffer(pContext->urb) &&
			!g_IsDifferentReport[0])
		{
			USB_DEBUG_INFO_LN_EX("ReportId Error");
			status = STATUS_UNSUCCESSFUL;
			return status;
		}
	}

	totalSize = data->MOUDATA.X_Descriptor.OffsetSize + data->MOUDATA.Y_Descriptor.OffsetSize + data->MOUDATA.Z_Descriptor.OffsetSize + data->MOUDATA.BtnDescriptor.BtnOffsetSize[0];
	if (!totalSize)
	{
		USB_DEBUG_INFO_LN_EX("Cannot Get Moudata \r\n");
		status = STATUS_UNSUCCESSFUL;
		return status;
	}


	if (g_mou_data)
	{
		USERMOUDATA mou_data = { 0 };
		LONG		BtnSet1, BtnSet2 = 0;
		LONG X, RemainderX = 0;
		LONG Y, RemainderY = 0;
		UCHAR DataReportID = *(UCHAR*)UrbGetTransferBuffer(pContext->urb);
		int i = 0;
		int j = 0;

		if (data->MOUDATA.ReportIdDesc[0].ReportId)
		{
			for (i = 0; i < COUNT_OF_REPORTID; i++)
			{
				// Case 1: Our target is same Report ID
				// Case 2: Our target is not same Report ID 
				if (data->MOUDATA.ReportIdDesc[i].ReportId == DataReportID)
				{
					switch (data->MOUDATA.ReportIdDesc[i].Usage)
					{
					case HID_NOT_RANGE_USAGE_X:
						mou_data.x =
							ReadHidCoordinate((PCHAR)UrbGetTransferBuffer(pContext->urb), data->MOUDATA.X_Descriptor.ByteOffset, data->MOUDATA.X_Descriptor.BitOffset, data->MOUDATA.X_Descriptor.OffsetSize);
						break;
					case HID_NOT_RANGE_USAGE_Y:
						mou_data.y =
							ReadHidCoordinate((PCHAR)UrbGetTransferBuffer(pContext->urb), data->MOUDATA.Y_Descriptor.ByteOffset, data->MOUDATA.Y_Descriptor.BitOffset, data->MOUDATA.Y_Descriptor.OffsetSize);
						break;
					case HID_NOT_RANGE_USAGE_WHELL:
						mou_data.z =
							ReadHidCoordinate((PCHAR)UrbGetTransferBuffer(pContext->urb), data->MOUDATA.Z_Descriptor.ByteOffset, data->MOUDATA.Z_Descriptor.BitOffset, data->MOUDATA.Z_Descriptor.OffsetSize);
						break;
					case HID_BUTTON:
						BtnSet1 = ReadHidCoordinate((PCHAR)UrbGetTransferBuffer(pContext->urb), data->MOUDATA.BtnDescriptor.ByteOffsetBtn[0], data->MOUDATA.BtnDescriptor.BitOffsetBtn[0], data->MOUDATA.BtnDescriptor.BtnOffsetSize[0]);
						break;
					default:
						break;
					}
				}
				USB_DEBUG_INFO_LN_EX("i: %d ReportId: %d Usage: %x", i, DataReportID, data->MOUDATA.ReportIdDesc[i].Usage);
			}
		}
		else
		{
			//Case 3: No Report id
			mou_data.x = ReadHidCoordinate((PCHAR)UrbGetTransferBuffer(pContext->urb), data->MOUDATA.X_Descriptor.ByteOffset, data->MOUDATA.X_Descriptor.BitOffset, data->MOUDATA.X_Descriptor.OffsetSize);
			mou_data.y = ReadHidCoordinate((PCHAR)UrbGetTransferBuffer(pContext->urb), data->MOUDATA.Y_Descriptor.ByteOffset, data->MOUDATA.Y_Descriptor.BitOffset, data->MOUDATA.Y_Descriptor.OffsetSize);
			mou_data.z = ReadHidCoordinate((PCHAR)UrbGetTransferBuffer(pContext->urb), data->MOUDATA.Z_Descriptor.ByteOffset, data->MOUDATA.Z_Descriptor.BitOffset, data->MOUDATA.Z_Descriptor.OffsetSize);
			BtnSet1 = ReadHidCoordinate((PCHAR)UrbGetTransferBuffer(pContext->urb), data->MOUDATA.BtnDescriptor.ByteOffsetBtn[0], data->MOUDATA.BtnDescriptor.BitOffsetBtn[0], data->MOUDATA.BtnDescriptor.BtnOffsetSize[0]);
		}

		mou_data.Click = BtnSet1;

//		EvaluateHardwareMacro(pContext, &mou_data);

		mou_data.IsAbsolute = (data->MOUDATA.IsAbsolute) ? (mou_data.IsAbsolute | USB_MOUDATA_ABS_FLAGS) : (mou_data.IsAbsolute & ~USB_MOUDATA_ABS_FLAGS);

		mou_data.Reserved1 = (ULONG)USB_MOU_DATA_HASH_MAKER(mou_data);

		OpenLoopBufferWrite(g_mou_data, (const void*)&mou_data);


#ifdef DBG
		{
			char str[REPORT_MAX_COUNT * 4 + 1] = { 0 };
			ULONG size = (UrbGetTransferLength(pContext->urb) > REPORT_MAX_COUNT) ? REPORT_MAX_COUNT : UrbGetTransferLength(pContext->urb);
			//binToString((PCHAR)UrbGetTransferBuffer(pContext->urb), size, str, REPORT_MAX_COUNT * 4 + 1);

			USB_DEBUG_INFO_LN_EX("ReportId: %d X: %d Y: %d Z: %d Click: %d Abs: %d Size: %d str: %s Device_obj: %I64x hash= %x",
				data->MOUDATA.ReportIdDesc[0].ReportId,
				mou_data.x,
				mou_data.y,
				mou_data.z,
				mou_data.Click,
				mou_data.IsAbsolute,
				data->MOUDATA.X_Descriptor.OffsetSize,
				str,
				pContext->DeviceObject,
				mou_data.Reserved1);
		}


#endif
		RtlZeroMemory(&mou_data, sizeof(USERMOUDATA));
	}

	status = STATUS_SUCCESS;
	return status;
}

//----------------------------------------------------------------------------------------//
NTSTATUS HandleKeyboardData(
	_In_ HIJACK_CONTEXT*    pContext,
	_In_ HIDP_REPORT_TYPE reportType
)
{
	NTSTATUS					status = STATUS_UNSUCCESSFUL;
	ULONG						colIndex = 0;
	USHORT						totalSize = 0;
	BOOLEAN						IsMouse = FALSE;
	BOOLEAN						IsKbd = FALSE;
	ULONG						index = 0;
	PCHAR 						StartPtr = NULL;
	int	 						i = 0;

	USERKBDDATA kbd_data = { 0 };
	if (!pContext)
	{
		USB_DEBUG_INFO_LN_EX("NULL pContext");
		status = STATUS_UNSUCCESSFUL;
		return status;
	}

	if (!pContext->urb || !pContext->DeviceObject || !IsSafeNode(pContext))
	{
		USB_DEBUG_INFO_LN_EX("Return without handle");
		status = STATUS_UNSUCCESSFUL;
		return status;
	}

	if (!pContext->node->ExtractedData[reportType])
	{
		if (!pContext->node->Collection)
		{
			status = GetAndVerifyKeyboardUsageInCollection(
				UrbGetTransferBuffer(pContext->urb),
				&pContext->node->parsedReport,
				&pContext->node->Collection
			);

			if (!NT_SUCCESS(status) || !pContext->node->Collection)
			{
				USB_DEBUG_INFO_LN_EX("NULL VerifyMouseUsageInCollection");
				status = STATUS_UNSUCCESSFUL;
				return status;
			}
		}

		status = AllocateExtractData(&pContext->node->ExtractedData[reportType]);
		if (!NT_SUCCESS(status) || (!pContext->node->ExtractedData[reportType]))
		{
		
			status = STATUS_UNSUCCESSFUL;
			return status;
		}

		status = ExtractKeyboardData(pContext->node->Collection, reportType, pContext->node->ExtractedData[reportType]);
		if (!NT_SUCCESS(status) || (pContext->node->ExtractedData[reportType]->KBDDATA.NormalKeyByteOffset == pContext->node->ExtractedData[reportType]->KBDDATA.SpecialKeyByteOffset))
		{
			status = STATUS_UNSUCCESSFUL;
			return status;
		}
	}
	if (g_kbd_data)
	{
		status = DispatchKeyboardData(pContext);
	}

	return status;
}
//----------------------------------------------------------------------------------------//
NTSTATUS HandleMouseData(
	_In_ HIJACK_CONTEXT*    pContext,
	_In_ HIDP_REPORT_TYPE reportType
)
{
	EXTRACTDATA*				data = NULL;
	NTSTATUS					status = STATUS_UNSUCCESSFUL;
	ULONG						colIndex = 0;
	USHORT						totalSize = 0;
	BOOLEAN						IsMouse = FALSE;
	BOOLEAN						IsKbd = FALSE;
	ULONG						index = 0;

	if (!pContext)
	{
		USB_DEBUG_INFO_LN_EX("NULL pContext");
		status = STATUS_UNSUCCESSFUL;
		return status;
	}
	if (!pContext->urb || !pContext->DeviceObject || !IsSafeNode(pContext))
	{
		USB_DEBUG_INFO_LN_EX("Return without handle");
		status = STATUS_UNSUCCESSFUL;
		return status;
	}

	if (!pContext->node->ExtractedData[reportType])
	{
		USB_COMMON_DEBUG_INFO("NULL ExtractedData");
		if (!pContext->node->Collection)
		{
			USB_COMMON_DEBUG_INFO("NULL Collection");
			status = GetAndVerifyMouseUsageInCollection(
				UrbGetTransferBuffer(pContext->urb),
				&pContext->node->parsedReport,
				&pContext->node->Collection
			);

			if (!NT_SUCCESS(status) || !pContext->node->Collection)
			{
				USB_DEBUG_INFO_LN_EX("NULL GetVerifyMouseUsageInCollection");
				status = STATUS_UNSUCCESSFUL;
				return status;
			}
		}

		status = AllocateExtractData(&pContext->node->ExtractedData[reportType]);
		if (!NT_SUCCESS(status) || (!pContext->node->ExtractedData[reportType]))
		{
			USB_COMMON_DEBUG_INFO("NULL AllocateExtractData");
			status = STATUS_UNSUCCESSFUL;
			return status;
		}

		status = ExtractMouseData(pContext->node->Collection, reportType, pContext->node->ExtractedData[reportType]);
		if (!NT_SUCCESS(status))
		{
			USB_COMMON_DEBUG_INFO("NULL ExtractMouseData");
			status = STATUS_UNSUCCESSFUL;
			return status;
		}
		USB_COMMON_DEBUG_INFO("Alloc Success");
	}

	if (g_mou_data)
	{
		status = DispatchMouseData(pContext);
	}
	return status;
}
//---------------------------------------------------------------------//
NTSTATUS VerifyClientPdoIrp(
	_In_ PDEVICE_OBJECT ClientPdo,
	_In_ PDEVICE_OBJECT VerifiedFdo)
{
	PDO_EXTENSION* pdoExt = NULL;
	FDO_EXTENSION* fdoExt = NULL;

	if (!ClientPdo || !VerifiedFdo)
	{
		return  STATUS_UNSUCCESSFUL;
	}
	/*
	-------------------------
	|	FDO (_HID0000001)	|				<< DeviceObject
	-------------------------
	-------|-------
	|			   |
	----------------	--------------
	| Client PDO1  |	| Client PDO2 |			<< Context->node->device_obj
	----------------	--------------

	*/

	pdoExt = GetClientPdoExtension(ClientPdo->DeviceExtension);
	if (!pdoExt)
	{
		return  STATUS_UNSUCCESSFUL;
	}

	fdoExt = GetFdoExtByClientPdoExt(pdoExt);
	if (!fdoExt)
	{
		return STATUS_UNSUCCESSFUL;
	}

	if (fdoExt->fdo != VerifiedFdo)
	{
		USB_DEBUG_INFO_LN_EX("IRPDevice HID: %I64x  %I64x --- ", fdoExt->fdo, VerifiedFdo);
		return STATUS_UNSUCCESSFUL;
	}

	return STATUS_SUCCESS;
}
//---------------------------------------------------------------------//
NTSTATUS UsbIrpCompletionHandler(
	_In_     PDEVICE_OBJECT  	   DeviceObject,
	_In_     PIRP            	   Irp,
	_In_	 PVOID           	   Context,
	_In_     PENDINGIRPLIST* 	   pPendingList
)
{
	HIJACK_CONTEXT*		   pContext = (HIJACK_CONTEXT*)Context;
	PVOID					context = NULL;
	IO_COMPLETION_ROUTINE* callback = NULL;
	if (!pContext)
	{
		return STATUS_SUCCESS;
	}

	context = pContext->pending_irp.oldContext;
	callback = pContext->pending_irp.oldRoutine;
	if (!callback)
	{
		return STATUS_UNSUCCESSFUL;
	}

	// Completion func is called when driver unloading.
	if (g_bUnloaded)
	{
		PENDINGIRP* entry = GetRealPendingIrpByIrp(pPendingList, Irp);
		if (entry)
		{
			context = entry->oldContext;
			callback = entry->oldRoutine;
			USB_DEBUG_INFO_LN_EX("Safety Call old Routine: %I64x Context: %I64x", callback, context);
		}
	}

	//Rarely call here when driver unloading, Safely call because driver_unload 
	//will handle all element in the list. we dun need to free and unlink it,
	//otherwise, system crash.
	if (g_bUnloaded)
	{
		if (!callback)
		{
			USB_DEBUG_INFO_LN_EX("callback Empty...");
			return STATUS_SUCCESS;
		}
		return callback(DeviceObject, Irp, context);
	}

	//If Driver is not unloading , delete it 
	if (!NT_SUCCESS(RemovePendingIrp(pPendingList, &pContext->pending_irp)))
	{
		USB_DEBUG_INFO_LN_EX("FATAL: Delete element FAILED");
	}

	if (!NT_SUCCESS(VerifyClientPdoIrp(pContext->node->device_object, DeviceObject)))
	{
		return callback(DeviceObject, Irp, context);
	}

	if (UrbIsInputTransfer(pContext->urb))
	{
		if (pContext->node->mini_extension->InterfaceDesc->Class == 3 &&			//HidClass Device
			pContext->node->mini_extension->InterfaceDesc->Protocol == 2)//Mouse
		{
			USB_DEBUG_INFO_LN_EX("IRPDevice HID: %I64x  ", DeviceObject);
			if (!NT_SUCCESS(HandleMouseData(pContext, HidP_Input)))
			{
				USB_DEBUG_INFO_LN_EX("It is not mouse data ");
			}
		}

		if (pContext->node->mini_extension->InterfaceDesc->Class == 3 &&			//HidClass Device
			pContext->node->mini_extension->InterfaceDesc->Protocol == 1)//Keyboard
		{
			if (!NT_SUCCESS(HandleKeyboardData(pContext, HidP_Input)))
			{
				USB_DEBUG_INFO_LN_EX("It is not Keyboard Data ");
			}
		}
	}

	if (UrbIsOutputTransfer(pContext->urb))
	{
		USB_COMMON_DEBUG_INFO("Output Data ");
	}

	if (pContext)
	{
	//	ExFreePool(pContext);
		pContext = NULL;
	}

	USB_COMMON_DEBUG_INFO("Completion ");

	return callback(DeviceObject, Irp, context);
}
//-------------------------------------------------------------------------------------------------//
NTSTATUS  UsbCompletionCallback1(
	_In_     PDEVICE_OBJECT DeviceObject,
	_In_     PIRP           Irp,
	_In_	 PVOID          Context
)
{
	PVOID NtBase = UtilPcToFileHeader(KdDebuggerEnabled);
	PVOID CallerBase = UtilPcToFileHeader(_ReturnAddress());

	if (NtBase != CallerBase && !g_bIsReportedCompFuncAttack)
	{
		g_bIsReportedCompFuncAttack = TRUE;
	}
	return UsbIrpCompletionHandler(DeviceObject, Irp, Context, g_HookConfig[0].pendingList);
}
//-------------------------------------------------------------------------------------------------//
NTSTATUS  UsbCompletionCallback2(
	_In_     PDEVICE_OBJECT DeviceObject,
	_In_     PIRP           Irp,
	_In_	 PVOID          Context
)
{
	return UsbIrpCompletionHandler(DeviceObject, Irp, Context, g_HookConfig[1].pendingList);
}
//-----------------------------------------------------------------------------------------------//
NTSTATUS  UsbCompletionCallback3(
	_In_     PDEVICE_OBJECT DeviceObject,
	_In_     PIRP           Irp,
	_In_	 PVOID          Context
)
{
	return UsbIrpCompletionHandler(DeviceObject, Irp, Context, g_HookConfig[2].pendingList);
}
//-------------------------------------------------------------------------------------------------//
NTSTATUS  UsbCompletionCallback4(
	_In_     PDEVICE_OBJECT DeviceObject,
	_In_     PIRP           Irp,
	_In_	 PVOID          Context
)
{
	return UsbIrpCompletionHandler(DeviceObject, Irp, Context, g_HookConfig[3].pendingList);
}
//-------------------------------------------------------------------------------------------------//
NTSTATUS  UsbCompletionCallback5(
	_In_     PDEVICE_OBJECT DeviceObject,
	_In_     PIRP           Irp,
	_In_	 PVOID          Context
)
{
	return UsbIrpCompletionHandler(DeviceObject, Irp, Context, g_HookConfig[4].pendingList);
}


//-------------------------------------------------------------------------------------------------//
NTSTATUS UsbhubIrpHandler(
	_Inout_ struct _DEVICE_OBJECT*	pDeviceObject,
	_Inout_ struct _IRP*			pIrp,
	_In_     PENDINGIRPLIST* 	   	pPendingList,
	_In_ 	 PIO_COMPLETION_ROUTINE pCompletionRoutine,
	_In_	 DRIVER_DISPATCH*		pOldFunction
)
{
	PIO_STACK_LOCATION irpStack = NULL;
	NTSTATUS status = STATUS_UNSUCCESSFUL;
	do
	{
		HIJACK_CONTEXT*		 hijack = NULL;

		PURB					urb = NULL;
		PENDINGIRP*		  new_entry = NULL;
		PHID_DEVICE_NODE	   node = NULL;

		if (!g_HidClientPdoList)
		{
			break;
		}

		if (!pPendingList)
		{
			break;
		}

		irpStack = IoGetCurrentIrpStackLocation(pIrp);
		if (irpStack->Parameters.DeviceIoControl.IoControlCode != IOCTL_INTERNAL_USB_SUBMIT_URB)
		{
			USB_DEBUG_INFO_LN_EX("not IOCTL_INTERNAL_USB_SUBMIT_URB ");
			break;
		}

		urb = (PURB)irpStack->Parameters.Others.Argument1;
		if (!urb)
		{
			USB_DEBUG_INFO_LN_EX("empty urb ");
			break;
		}

		if (UrbGetFunction(urb) != URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER)
		{
			USB_DEBUG_INFO_LN_EX("not URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER %x ", UrbGetFunction(urb));
			break;
		}

		//If Urb pipe handle is used by HID mouse / kbd device. 
		if (IsHidDevicePipe(g_HidClientPdoList->head, UrbGetTransferPipeHandle(urb), &node))
		{
#ifdef DBG	
			CHAR DriverName[256] = { 0 };
			WCHAR DeviceNameW[256] = { 0 };
			CHAR  DeviceName[256] = { 0 };
#endif
			HIDCLASS_DEVICE_EXTENSION* class_extension = NULL;

			if (!node ||
				!node->device_object)
			{
				USB_DEBUG_INFO_LN_EX("Is Null Node. ");
				break;
			}

			class_extension = (HIDCLASS_DEVICE_EXTENSION*)node->device_object->DeviceExtension;
			if (!class_extension->isClientPdo)
			{
				//if FDO (HID_000000x), then next
				USB_DEBUG_INFO_LN_EX("Is Not isClientPdo. ");
				break;
			}
#ifdef DBG			
			if (KeGetCurrentIrql() < DISPATCH_LEVEL)
			{
//				wcharTocharEN(node->device_object->DriverObject->DriverName.Buffer, DriverName, node->device_object->DriverObject->DriverName.Length);
//				GetDeviceName(node->device_object, DeviceNameW);
//				wcharTocharEN(DeviceNameW, DeviceName, 256);
//				USB_DEBUG_INFO_LN_EX("DrvName:  %s DeviceName: %s", DriverName, DeviceName);
			}
#endif
			hijack = (HIJACK_CONTEXT*)ExAllocatePoolWithTag(NonPagedPool, sizeof(HIJACK_CONTEXT), 'kcaj');
			if (!hijack)
			{
				break;
			}

			RtlZeroMemory(hijack, sizeof(HIJACK_CONTEXT));

			//Save all we need to use when unload driver / delete node , 
			//Add to linked list
			if (irpStack)
			{
				//Fake Context for Completion Routine
				hijack->DeviceObject = node->device_object;		//USBHUB device
				hijack->urb = urb;
				hijack->node = node;
				hijack->pending_irp.Irp = pIrp;
				hijack->pending_irp.oldRoutine = irpStack->CompletionRoutine;
				hijack->pending_irp.oldContext = irpStack->Context;
				hijack->pending_irp.IrpStack = irpStack;
				hijack->pending_irp.newRoutine = pCompletionRoutine;
				hijack->pending_irp.newContext = hijack;
				// List for bookkepping only.
				//1. Free From UnInit Function 
				//2. Free From IRP Completion Hook
				InsertPendingIrp(pPendingList, &hijack->pending_irp);
				irpStack->CompletionRoutine = pCompletionRoutine;

				//Completion Routine hook
				irpStack->Context = hijack;

				if (!INSIDE_SYSTEM_PTE_RANGE((ULONG64)pOldFunction))
				{
					if (!g_bIsReportedCallbackHookAttack)
					{
						g_bIsReportedCallbackHookAttack = TRUE;
						USB_DEBUG_INFO_LN_EX("IrpStack: pOldFunction: %p", pOldFunction);
					}
				}

				status = pOldFunction(pDeviceObject, pIrp);

				if (!NT_SUCCESS(IrpVerifyPendingIrpCompletionHookByIrp(pPendingList, pIrp)))
				{
					if (!g_bIsReportedCompleteHookAttack)
					{
						g_bIsReportedCompleteHookAttack = TRUE;
						USB_DEBUG_INFO_LN_EX("IrpStack: pOldFunction: %p Current Completion: %p MyCompletion: %p", pOldFunction, irpStack->CompletionRoutine, pCompletionRoutine);
					}
				}
				else
				{
					USB_DEBUG_INFO_LN_EX("Normal completion hook ");
				}

				return status;
			}
		}
	} while (0);

	status = pOldFunction(pDeviceObject, pIrp);

	return status;
}
//-------------------------------------------------------------------------------------------------//
NTSTATUS UsbHubInternalDeviceControl1(
	_Inout_ struct _DEVICE_OBJECT *DeviceObject,
	_Inout_ struct _IRP           *Irp
)
{
	return UsbhubIrpHandler(
		DeviceObject,
		Irp,
		g_HookConfig[0].pendingList,
		g_HookConfig[0].CompletionRoutine,
		g_HookConfig[0].OldRoutine
	);
}

//-------------------------------------------------------------------------------------------------//
NTSTATUS UsbHubInternalDeviceControl2(
	_Inout_ struct _DEVICE_OBJECT *DeviceObject,
	_Inout_ struct _IRP           *Irp
)
{
	return UsbhubIrpHandler(
		DeviceObject,
		Irp,
		g_HookConfig[1].pendingList,
		g_HookConfig[1].CompletionRoutine,
		g_HookConfig[1].OldRoutine
	);
}
//-------------------------------------------------------------------------------------------------//
NTSTATUS UsbHubInternalDeviceControl3(
	_Inout_ struct _DEVICE_OBJECT *DeviceObject,
	_Inout_ struct _IRP           *Irp
)
{
	return UsbhubIrpHandler(
		DeviceObject,
		Irp,
		g_HookConfig[2].pendingList,
		g_HookConfig[2].CompletionRoutine,
		g_HookConfig[2].OldRoutine
	);
}

//-------------------------------------------------------------------------------------------------//
NTSTATUS UsbHubInternalDeviceControl4(
	_Inout_ struct _DEVICE_OBJECT *DeviceObject,
	_Inout_ struct _IRP           *Irp
)
{
	return UsbhubIrpHandler(
		DeviceObject,
		Irp,
		g_HookConfig[3].pendingList,
		g_HookConfig[3].CompletionRoutine,
		g_HookConfig[3].OldRoutine
	);
}

//-------------------------------------------------------------------------------------------------//
NTSTATUS UsbHubInternalDeviceControl5(
	_Inout_ struct _DEVICE_OBJECT *DeviceObject,
	_Inout_ struct _IRP           *Irp
)
{
	return UsbhubIrpHandler(
		DeviceObject,
		Irp,
		g_HookConfig[4].pendingList,
		g_HookConfig[4].CompletionRoutine,
		g_HookConfig[4].OldRoutine
	);
}


//-------------------------------------------------------------------------------------------------//
NTSTATUS HidUsbPnpIrpHandler(
	_Inout_ struct _DEVICE_OBJECT *DeviceObject,
	_Inout_ struct _IRP           *Irp
)
{
	IRPHOOKOBJ* HookObject = NULL;
	PIO_STACK_LOCATION irpStack;

	do
	{
		HIDCLASS_DEVICE_EXTENSION* ClassExt = (HIDCLASS_DEVICE_EXTENSION*)DeviceObject->DeviceExtension;
		if (ClassExt->isClientPdo)
		{
			USB_DEBUG_INFO_LN_EX("IsClientPdo: %x", ClassExt->isClientPdo);

			irpStack = IoGetCurrentIrpStackLocation(Irp);
			if (irpStack->MinorFunction == IRP_MN_REMOVE_DEVICE)
			{
				RemoveNodeFromHidList(DeviceObject);
				USB_DEBUG_INFO_LN_EX("REMOVE Device ");
			}

			if (irpStack->MinorFunction == IRP_MN_START_DEVICE)
			{
				USB_DEBUG_INFO_LN_EX("Add Device");
				VerifyAndInsertIntoHidList(DeviceObject, &g_HidContext);
			}
		}
	} while (FALSE);

	return g_HidPnpHandler(DeviceObject, Irp);
}

//----------------------------------------------------------------------------------------//
PENDINGIRPLIST* AllocateUsbHubsPendingList()
{
	PENDINGIRPLIST* UsbPendingIrpList = NULL;
	if (!NT_SUCCESS(AllocatePendingIrpLinkedList(&UsbPendingIrpList)))
	{
		USB_DEBUG_INFO_LN_EX("AllocatePendingIrpLinkedList Error");
	}
	return UsbPendingIrpList;
}
//----------------------------------------------------------------------------------------------------------------------------------------------
ULONG __fastcall FindInfoByProcess(
	_In_  USERPROCESSINFO* Header,
	_In_ PEPROCESS proc
)
{
	if (Header)
	{
		if (Header->proc == proc)
		{
			return CLIST_FINDCB_RET;
		}
	}
	return CLIST_FINDCB_CTN;
}
//----------------------------------------------------------------------------------------------------------------------------------------------
USERPROCESSINFO*  __fastcall FindMappedUsbInfo(
	_In_ PEPROCESS proc
)
{
	if (g_ProcessInfo)
	{
		return (USERPROCESSINFO*)QueryFromChainListByCallback(g_ProcessInfo, &FindInfoByProcess, proc);
	}
	return NULL;
}

//-----------------------------------------------------------------------------------------//
NTSTATUS CreateProcessInfo(
	_Out_ PUSERPROCESSINFO* ProcessInfo,
	_In_ 	void* 	 source,
	_In_ 	ULONG 	 length,
	_In_ 	BOOLEAN  IsKeyoard
)
{
	NTSTATUS status = STATUS_UNSUCCESSFUL;
	USERPROCESSINFO* processInfo = NULL;

	if (!ProcessInfo || !source)
	{
		return status;
	}
	processInfo = (USERPROCESSINFO*)ExAllocatePoolWithTag(NonPagedPool, sizeof(USERPROCESSINFO), 'pinf');
	if (!processInfo)
	{
		return status;
	}
	RtlZeroMemory(processInfo, sizeof(USERPROCESSINFO));
	processInfo->proc = PsGetCurrentProcess();
	if (!IsKeyoard)
	{
		processInfo->MouseMdl = NULL;
		processInfo->MappedMouseAddr = NULL;
		processInfo->MappedMouseAddr = MapNonpagedMemToSpace(source, length, &processInfo->MouseMdl, UserMode, 0);
	}
	else
	{
		processInfo->KeyboardMdl = NULL;
		processInfo->MappedKeyboardAddr = NULL;
		processInfo->MappedKeyboardAddr = MapNonpagedMemToSpace(source, length, &processInfo->KeyboardMdl, UserMode, 0);
	}

	if (processInfo)
	{
		*ProcessInfo = processInfo;
		status = STATUS_SUCCESS;
	}
	return status;
}

//----------------------------------------------------------------------------------------------------------------------------------------------
NTSTATUS MappingUsbMemoryForMouse(
	_In_ void* 	 source,
	_In_ ULONG 	 length,
	_Out_ PVOID* mapped_user_address
)
{
	PEPROCESS proc = PsGetCurrentProcess();

	USERPROCESSINFO* processInfo = FindMappedUsbInfo(proc);

	if (!source ||
		!length)
	{
		USB_DEBUG_INFO_LN_EX("Mapped STATUS_INVALID_PARAMETER %x %x %x \r\n ", mapped_user_address, source, length);
		return STATUS_INVALID_PARAMETER;
	}

	if (!processInfo)
	{
		CreateProcessInfo(&processInfo, source, length, FALSE);
		if (!processInfo)
		{
			USB_DEBUG_INFO_LN_EX("Cannot Mapping Memory \r\n ");
			return STATUS_INSUFFICIENT_RESOURCES;
		}

		if (!AddToChainListTail(g_ProcessInfo, processInfo))
		{
			ExFreePool(processInfo);
			processInfo = NULL;
			USB_DEBUG_INFO_LN_EX("Cannot Mapping Memory \r\n ");
			return STATUS_INSUFFICIENT_RESOURCES;
		}
		USB_DEBUG_INFO_LN_EX("@@mouse mapped_user_address : %I64X \r\n ", processInfo->MappedMouseAddr);
	}

	if (!processInfo->MappedMouseAddr)
	{
		processInfo->MouseMdl = NULL;
		processInfo->MappedMouseAddr = MapNonpagedMemToSpace(source, length, &processInfo->MouseMdl, UserMode, 0);
	}

	*mapped_user_address = processInfo->MappedMouseAddr;

	return STATUS_SUCCESS;
}

//----------------------------------------------------------------------------------------------------------------------------------------------
NTSTATUS MappingUsbMemoryForKeyboard(
	_In_  void* 	 source,
	_In_  ULONG 	 length,
	_Out_ PVOID* mapped_user_address
)
{
	PEPROCESS proc = PsGetCurrentProcess();

	USERPROCESSINFO* processInfo = FindMappedUsbInfo(proc);

	if (!source ||
		!length)
	{
		USB_DEBUG_INFO_LN_EX("Mapped STATUS_INVALID_PARAMETER %x %x %x \r\n ", mapped_user_address, source, length);
		return STATUS_INVALID_PARAMETER;
	}

	if (!processInfo)
	{
		CreateProcessInfo(&processInfo, source, length, TRUE);
		if (!processInfo)
		{
			USB_DEBUG_INFO_LN_EX("Cannot Mapping Memory \r\n ");
			return STATUS_INSUFFICIENT_RESOURCES;
		}

		if (!AddToChainListTail(g_ProcessInfo, processInfo))
		{
			ExFreePool(processInfo);
			processInfo = NULL;
			USB_DEBUG_INFO_LN_EX("Cannot Mapping Memory \r\n ");
			return STATUS_INSUFFICIENT_RESOURCES;
		}
		USB_DEBUG_INFO_LN_EX("@@keyboard mapped_user_address : %I64X \r\n ", processInfo->MappedKeyboardAddr);
	}

	if (!processInfo->MappedKeyboardAddr)
	{
		processInfo->KeyboardMdl = NULL;
		processInfo->MappedKeyboardAddr = MapNonpagedMemToSpace(source, length, &processInfo->KeyboardMdl, UserMode, 0);
	}

	*mapped_user_address = processInfo->MappedKeyboardAddr;

	return STATUS_SUCCESS;
}
//--------------------------------------------------------------------------------------------------------------------------------------------------
NTSTATUS MapUsbDataToUserAddressSpace(
	_In_  	USERCONFIGEX*     UserModeConfigEx,
	_In_    ULONG		      Size,
	_In_ 	BOOLEAN			  IsKeyboard
)
{

	PVOID user_mode_addr = NULL;

	if (!UserModeConfigEx)
	{
		return STATUS_UNSUCCESSFUL;
	}

	if (!g_bLoaded)
	{
		UserModeConfigEx->Version = 0;
		UserModeConfigEx->ProtocolVersion = 0;
		UserModeConfigEx->UserData = 0;
		UserModeConfigEx->UserDataLen = 0;
		return STATUS_UNSUCCESSFUL;
	}

	if (Size != sizeof(USERCONFIGEX))
	{
		return STATUS_INVALID_PARAMETER;
	}

	if (!IsKeyboard)
	{
		if (!g_mou_data)
		{
			USB_DEBUG_INFO_LN_EX("MapUsbDataToUserAddressSpace UnSuccessfully");
			return STATUS_UNSUCCESSFUL;
		}
		if (NT_SUCCESS(MappingUsbMemoryForMouse(g_mou_data->Header, sizeof(CIRCULARBUFFER), &user_mode_addr)))
		{
			UserModeConfigEx->Version = USB_PEN_INIT_VERSION;
			UserModeConfigEx->ProtocolVersion = USB_PEN_PROTOCOL_VERSION;
			UserModeConfigEx->UserData = (ULONG64)user_mode_addr;
			UserModeConfigEx->UserDataLen = sizeof(user_mode_addr);
			return STATUS_SUCCESS;
		}
	}
	else
	{
		if (!g_kbd_data)
		{
			USB_DEBUG_INFO_LN_EX("MapUsbDataToUserAddressSpace UnSuccessfully");
			return STATUS_UNSUCCESSFUL;
		}

		if (NT_SUCCESS(MappingUsbMemoryForKeyboard(g_kbd_data->Header, sizeof(CIRCULARBUFFER), &user_mode_addr)))
		{
			UserModeConfigEx->Version = USB_PEN_INIT_VERSION;
			UserModeConfigEx->ProtocolVersion = USB_PEN_PROTOCOL_VERSION;
			UserModeConfigEx->UserData = (ULONG64)user_mode_addr;
			UserModeConfigEx->UserDataLen = sizeof(user_mode_addr);
			return STATUS_SUCCESS;
		}

	}
	USB_DEBUG_INFO_LN_EX("MapUsbDataToUserAddressSpace UnSuccessfully");

	return STATUS_UNSUCCESSFUL;
}
//-------------------------------------------------------------------------------------------------------------
ULONG   __fastcall ProcessListActionCallback(
	_In_ 	USERPROCESSINFO* Header,
	_In_ 	ULONG Act)
{
	if (Act == CLIST_ACTION_FREE)
	{
		if (!Header)
		{
			return 0;
		}

		if (Header->MouseMdl && Header->MappedMouseAddr)
		{
			MmUnmapLockedPages(Header->MappedMouseAddr, Header->MouseMdl);
			IoFreeMdl(Header->MouseMdl);
			Header->MouseMdl = NULL;
			Header->MappedMouseAddr = NULL;
		}

		if (Header->KeyboardMdl && Header->MappedKeyboardAddr)
		{
			MmUnmapLockedPages(Header->MappedKeyboardAddr, Header->KeyboardMdl);
			IoFreeMdl(Header->KeyboardMdl);
			Header->KeyboardMdl = NULL;
			Header->MappedKeyboardAddr = NULL;
		}

		Header->proc = NULL;
		ExFreePool(Header);
		Header = NULL;
	}
	return 0;
}
//-----------------------------------------------------------------------------------------//
ULONG   __fastcall DeleteProcessListCallback(
	_In_ USERPROCESSINFO* Header,
	_In_ PEPROCESS 		 proc
)
{
	if (Header)
	{
		if (Header->proc == proc)
		{
			USB_DEBUG_INFO_LN_EX("Found n delete Proc");
			return CLIST_FINDCB_DEL;
		}
	}
	return CLIST_FINDCB_CTN;
}

//----------------------------------------------------------------------------------------//
NTSTATUS OnProcessExitToUsbSystem(
	_In_ PEPROCESS eProcess
)
{
	if (g_ProcessInfo)
	{
		//call free_routine when delete a element
		QueryFromChainListByCallback(g_ProcessInfo, &DeleteProcessListCallback, eProcess);
	}
	return STATUS_SUCCESS;
}
//----------------------------------------------------------------------------------------//
NTSTATUS FreeProcessInfoList()
{
	NTSTATUS status = STATUS_UNSUCCESSFUL;
	//Free White List

	if (g_ProcessInfo)
	{
		CHAINLIST_SAFE_FREE(g_ProcessInfo);
	}

	status = STATUS_SUCCESS;
	return status;
}
//----------------------------------------------------------------------------------------//
NTSTATUS UnInitialUsbHubIrpHook()
{
	ULONG i = 0;
	for (i = 0; i < g_Index; i++)
	{
		if (g_HookConfig[i].pendingList)
		{
			FreePendingList(g_HookConfig[i].pendingList);
			g_HookConfig[i].pendingList = NULL;
		}
	}
	g_Index = 0;
	return STATUS_SUCCESS;
}
//----------------------------------------------------------------------------------------//
ULONG __fastcall InitialUsbHubIrpHookCallback(
	_In_ USBHUBNODE* HubNode,
	_In_ PVOID Context
)
{
	IRPHOOKINFO* Info = NULL;
	PENDINGIRPLIST*  IrpPendingList = NULL;

	USB_DEBUG_INFO_LN_EX("g_Index: %d", g_Index);

	if (g_Index >= CONFIG_ARRAY_SIZE)
	{
		return CLIST_FINDCB_RET;
	}

	if (!HubNode)
	{
		return CLIST_FINDCB_CTN;
	}

	IrpPendingList = AllocateUsbHubsPendingList();

	if (!IrpPendingList)
	{
		return CLIST_FINDCB_CTN;
	}

	g_HookConfig[g_Index].pendingList = IrpPendingList;
	g_HookConfig[g_Index].DriverObject = HubNode->HubDriverObject;
	g_HookConfig[g_Index].OldRoutine = HubNode->HubDriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL];

	DoIrpHook(g_HookConfig[g_Index].DriverObject, g_HookConfig[g_Index].IrpCode, g_HookConfig[g_Index].NewRoutine, Start);

	if (KeGetCurrentIrql() < DISPATCH_LEVEL)
	{
		USB_DEBUG_INFO_LN_EX("Index: %x IRPHook DriverObject: %I64x Name: %ws", g_Index, g_HookConfig[g_Index].DriverObject, HubNode->HubName);
	}
	else
	{
		USB_DEBUG_INFO_LN_EX("IRQL TOO HIGH ");
	}

	g_Index++;

	return 	CLIST_FINDCB_CTN;
}
//-----------------------------------------------------------------------------------------------//
NTSTATUS InitialUsbHubIrpHook()
{
	NTSTATUS status = STATUS_UNSUCCESSFUL;
	if (!g_UsbHubList)
	{
		USB_DEBUG_INFO_LN_EX("FATAL: Usb Hub List cannot be Found ! Quit Now");
		return status;
	}

	USB_DEBUG_INFO_LN_EX("g_UsbHubList->currentSize: %d ", g_UsbHubList->currentSize);

	QueryFromChainListByCallback(g_UsbHubList->head, &InitialUsbHubIrpHookCallback, NULL);

	if (g_Index == 0)
	{
		return status;
	}

	status = STATUS_SUCCESS;
	return status;
}
//---------------------------------------------------------------------------------------//
BOOLEAN AllocateKeyboardResource(PVOID Context)
{
	BOOLEAN ret = TRUE;
	if (!g_kbd_data)
	{
		g_kbd_data = NewOpenLoopBuffer(CB_SIZE, sizeof(USERKBDDATA), OPENLOOPBUFF_FALGS_PEASUDOHEADER);
		if (!g_kbd_data)
		{
			ret = FALSE;
		}
	}
	return ret;
}
//---------------------------------------------------------------------------------------//
BOOLEAN AllocateMouseResource(PVOID Context)
{
	BOOLEAN ret = TRUE;
	if (!g_mou_data)
	{
		g_mou_data = NewOpenLoopBuffer(CB_SIZE, sizeof(USERMOUDATA), OPENLOOPBUFF_FALGS_PEASUDOHEADER);
		if (!g_mou_data)
		{
			ret = FALSE;
		}
	}
	return ret;
}
//---------------------------------------------------------------------------------------//
NTSTATUS InitializeUserModeResource(
	_In_	ULONG RequiredDevice
)
{
	NTSTATUS status = STATUS_UNSUCCESSFUL;
	if (!g_ProcessInfo)
	{
		g_ProcessInfo = NewChainListHeaderEx(LISTFLAG_FTMUTEXLOCK | LISTFLAG_AUTOFREE, ProcessListActionCallback, 0);
		if (!g_ProcessInfo)
		{
			status = STATUS_UNSUCCESSFUL;
			return status;
		}
	}

	USB_DEBUG_INFO_LN_EX("g_mou_data: %I64x g_kbd_data: %I64x g_ProcessInfo : %I64x ", g_mou_data, g_kbd_data, g_ProcessInfo);
	status = STATUS_SUCCESS;
	return status;
}
//----------------------------------------------------------------------------------------//
NTSTATUS InitializeHidPenetrate(
	_In_ ULONG RequiredDevice
)
{
	PDRIVER_OBJECT			  pHidDriverObj = NULL;
	NTSTATUS						 status = STATUS_UNSUCCESSFUL;
	ULONG						   ListSize = 0;

	if (g_bLoaded)
	{
		status = STATUS_SUCCESS;
		return status;
	}

	status = GetDriverObjectByName(HID_USB_DEVICE, &pHidDriverObj);
	if (!NT_SUCCESS(status) || !pHidDriverObj)
	{
		USB_DEBUG_INFO_LN_EX("GetUsbHub Error");
		return status;
	}

	status = InitializeUserModeResource(RequiredDevice);
	if (!NT_SUCCESS(status) || !g_ProcessInfo)
	{
		USB_DEBUG_INFO_LN_EX("InitializeUserModeResource Error");
		UnInitializeHidPenetrate();
		ReleaseDriverObject(pHidDriverObj);
		USB_DEBUG_INFO_LN_EX("InitHidSubSystem Error");
		return status;
	}

	g_HidContext.MouseCallback = AllocateMouseResource;
	g_HidContext.KeyboardCallback = AllocateKeyboardResource;
	g_HidContext.RequiredDevice = RequiredDevice;

	//Prepare HID PipeList AND UsbList
	status = InitHidSubSystem(&g_HidContext, &ListSize);
	if (!NT_SUCCESS(status) || !ListSize)
	{
		
		USB_DEBUG_INFO_LN_EX("InitHidSubSystem Error Size= %d", ListSize);
		UnInitializeHidPenetrate();
		ReleaseDriverObject(pHidDriverObj);
		status = STATUS_UNSUCCESSFUL;
		return status;
	}

	USB_DEBUG_INFO_LN_EX("HID SubSystem Initalization Successfully List size: %x ", ListSize);

	//Prepare IRP Hook 
	status = InitIrpHookSystem(g_IsCheckIrpHook);
	if (!NT_SUCCESS(status))
	{
		USB_DEBUG_INFO_LN_EX("InitIrpHookSystem Error");
		UnInitializeHidPenetrate();
		ReleaseDriverObject(pHidDriverObj);
		status = STATUS_UNSUCCESSFUL;
		return status;
	}

	USB_DEBUG_INFO_LN_EX("IRP Hook SubSystem Initalization Successfully");

	g_HidPnpHandler = (PDRIVER_DISPATCH)DoIrpHook(pHidDriverObj, IRP_MJ_PNP, HidUsbPnpIrpHandler, Start);
	if (!g_HidPnpHandler)
	{
		USB_DEBUG_INFO_LN_EX("DoIrpHook Error ");
		UnInitializeHidPenetrate();
		ReleaseDriverObject(pHidDriverObj);
		status = STATUS_UNSUCCESSFUL;
		return status;
	}

	USB_DEBUG_INFO_LN_EX("IRP Hook HidUsb PnP Successfully");

	status = InitialUsbHubIrpHook();
	if (!NT_SUCCESS(status))
	{
		USB_DEBUG_INFO_LN_EX("InitialUsbHubIrpHook Error");
		UnInitializeHidPenetrate();
		ReleaseDriverObject(pHidDriverObj);
		status = STATUS_UNSUCCESSFUL;
		return status;
	}

	USB_DEBUG_INFO_LN_EX("InitialUsbHubIrpHook Successfully");
	ReleaseDriverObject(pHidDriverObj);

	g_bLoaded = TRUE;

	USB_DEBUG_INFO_LN_EX("InitializeHidPenetrate Successfully");

	return status;
}
//----------------------------------------------------------------------------------------//
NTSTATUS FreeMappedLoopBuffer()
{
	PVOID TmpPointer = g_mou_data;
	PVOID TmpPointer2 = g_kbd_data;
	g_kbd_data = NULL;
	g_mou_data = NULL;

	if (TmpPointer)
	{
		OpenLoopBufferRelease(TmpPointer);
		TmpPointer = NULL;
	}


	if (TmpPointer2)
	{
		OpenLoopBufferRelease(TmpPointer2);
		TmpPointer2 = NULL;
	}

	return STATUS_SUCCESS;
}
//----------------------------------------------------------------------------------------//
NTSTATUS UnInitializeHidPenetrate()
{

	g_bUnloaded = TRUE;
	g_bLoaded = FALSE;

	//Recovery Irp all hook and Free the List
	UnInitIrpHookSystem();

	//Recovery Completion hook and Free all List 
	UnInitialUsbHubIrpHook();

	//Free the HID Client PDO pipe list 
	UnInitHidSubSystem();

	//Free Process Info List
	FreeProcessInfoList();

	//Free Loop Buffer
	FreeMappedLoopBuffer();
	USB_DEBUG_INFO_LN_EX("UnInitializeHidPenetrate");

	g_Index = 0;

	return STATUS_SUCCESS;
}
//----------------------------------------------------------------------------------------------------------------------------------------------
BOOLEAN IsReportHidRawDesc()
{
	return g_IsReportRawDesc;
}

//----------------------------------------------------------------------------------------------------------------------------------------------
BOOLEAN IsReportHidMiniDrv()
{
	return g_IsEnableReportHidMiniDrv;
}

//----------------------------------------------------------------------------------------------------------------------------------------------
NTSTATUS UsbPenerateConfigInit()
{
	NTSTATUS ntStatus = STATUS_SUCCESS;
	ntStatus = InitializeHidPenetrate(MOUSE_FLAGS  | KEYBOARD_FLAGS);
	return ntStatus;
}

//----------------------------------------------------------------------------------------------------------------------------------------------
BOOLEAN GetTpDataUsageStatus()
{
	return g_TpDataUsed[0];
}


```

`UsbMon/UsbMon/HidHijack.h`:

```h
#ifndef __HIJACK_HEADER__
#define __HIJACK_HEADER__ 


#include <ntddk.h> 
#include "UsbUtil.h"

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

	- Init Usb Penetrate System
		1.	 Create and Initial Hid Client Pdo List
		2.   Init Pending IRP list
		3.	 Init Active IRP Linked List
		4.	 

Arguments:

	 UsbVersion - USB hub version

Return Value:

	 NTSTATUS	- STATUS_SUCCES if initial successed
				- STATUS_UNSUCCESSFUL if failed

-------------------------------------------------------*/
NTSTATUS InitializeHidPenetrate(
	_In_ ULONG RequiredDevice
);


  
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

	- UnInit Usb Penetrate System
		1.	 Set Unloading Flag
		2.   Remove All IRP Hook
		3.	 Remove All Pending IRP (recover Completion hook) 
		
Arguments:

	 No
	
Return Value:

	  NTSTATUS	- STATUS_SUCCESS if initial successed
				- STATUS_UNSUCCESSFIL if initial failed

	-------------------------------------------------------*/
NTSTATUS UnInitializeHidPenetrate();



/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

	- MapUsbDataToUserAddressSpace
		1.	Mapped the mouse / keyboard data struct to 
			user mode address space.
			
		2.  Once structure is updated, Set Event object 
		
Arguments:

	  UserModeConfigEx - Pointer to the User Mode Config struct with 
						 mapped address
	
	  Size			   - size of struct
	  
Return Value:	

	  NTSTATUS	- STATUS_SUCCESS if initial successed
				- STATUS_UNSUCCESSFIL if initial failed

	-------------------------------------------------------*/
NTSTATUS MapUsbDataToUserAddressSpace( 
	_Inout_  	void*     UserModeConfigEx,
	_In_		ULONG			  Size
);


/*-----------------------------------------------------
Routine Description:
	-	OnProcessExitToUsbSystem
		
Arguments:

	PEPROCESS   - Pointer of exiting's process
		
Return Value:

	  NTSTATUS	- STATUS_SUCCESS if initial successed
				- STATUS_UNSUCCESSFIL if initial failed
-----------------------------------------------------*/ 
NTSTATUS OnProcessExitToUsbSystem(
	_In_ PEPROCESS eProcess
);
	
	
	

/*-----------------------------------------------------
Routine Description:

	- UsbPenerateConfigInit
			1. Config Init
Arguments:
		
	No 
	
Return Value:

	  NTSTATUS	- STATUS_SUCCESS if initial successed
				- STATUS_UNSUCCESSFIL if initial failed
-----------------------------------------------------*/
NTSTATUS UsbPenerateConfigInit();


NTSTATUS InitializeHidPenetrate();


///////////////////////////////////////////////////////
//// Types
 

///////////////////////////////////////////////////////
//// Marcos and Utilies
 
#endif

```

`UsbMon/UsbMon/HidType.h`:

```h
/*!@file
*@brief HID parser type definitions
*
* Header GPL
* @todo Properly tag all files with GPL (as appropriate)
*/

#ifndef TYPE_H
#define TYPE_H

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */
#include <fltKernel.h>
#include <sys/types.h>

	/*
	* Types
	*/
#if !AIX
	typedef unsigned char  uchar;
#endif

#if HPUX || __APPLE__
	typedef unsigned long  ULONG;
#endif

	typedef short          wchar;

	/*
	* Constants
	*/
#define PATH_SIZE               10 /*!< maximum depth for Path */
#define USAGE_TAB_SIZE          50 /*!< Size of usage stack */

	/*! Including FEATURE, INPUT and OUTPUT */
#define MAX_REPORT             300

	/*! Size max of Report Descriptor */
#define REPORT_DSC_SIZE       6144

	/*
	* Items
	* -------------------------------------------------------------------------- */
#define SIZE_0                0x00
#define SIZE_1                0x01
#define SIZE_2                0x02
#define SIZE_4                0x03
#define SIZE_MASK             0x03

#define TYPE_MAIN             0x00
#define TYPE_GLOBAL           0x04
#define TYPE_LOCAL            0x08
#define TYPE_MASK             0x0C

	/* Main items */
#define ITEM_COLLECTION       0xA0
#define ITEM_END_COLLECTION   0xC0
#define ITEM_FEATURE          0xB0
#define ITEM_INPUT            0x80
#define ITEM_OUTPUT           0x90

	/* Global items */
#define ITEM_UPAGE            0x04
#define ITEM_LOG_MIN          0x14
#define ITEM_LOG_MAX          0x24
#define ITEM_PHY_MIN          0x34
#define ITEM_PHY_MAX          0x44
#define ITEM_UNIT_EXP         0x54
#define ITEM_UNIT             0x64
#define ITEM_REP_SIZE         0x74
#define ITEM_REP_ID           0x84
#define ITEM_REP_COUNT        0x94

	/* Local items */
#define ITEM_USAGE            0x08
#define ITEM_STRING           0x78

	/* Long item */
#define ITEM_LONG	      0xFC

#define ITEM_MASK             0xFC

	/* Attribute Flags */
#define ATTR_DATA_CST         0x01
#define ATTR_NVOL_VOL         0x80

	/*!
	* Describe a HID Path point
	*/
	typedef struct
	{
		USHORT UPage;
		USHORT Usage;
	} HIDNode;

	/*!
	* Describe a HID Path
	*/
	typedef struct
	{
		uchar   Size;             /*!< HID Path size */
		HIDNode Node[PATH_SIZE];  /*!< HID Path */
	} HIDPath;

	/*!
	* Describe a HID Data with its location in report
	*/
	typedef struct
	{
		long    Value;            /*!< HID Object Value                             */
		HIDPath Path;             /*!< HID Path                                     */

		uchar   ReportID;         /*!< Report ID, (from incoming report) ???        */
		uchar   Offset;           /*!< Offset of data in report                     */
		uchar   Size;             /*!< Size of data in bit                          */

		uchar   Type;             /*!< Type : FEATURE / INPUT / OUTPUT              */
		uchar   Attribute;        /*!< Report field attribute                       */

		ULONG   Unit;             /*!< HID Unit                                     */
		char    UnitExp;          /*!< Unit exponent                                */

		long    LogMin;           /*!< Logical Min                                  */
		long    LogMax;           /*!< Logical Max                                  */
		long    PhyMin;           /*!< Physical Min                                 */
		long    PhyMax;           /*!< Physical Max                                 */
	} HIDData;

	/* -------------------------------------------------------------------------- */
	typedef struct
	{
		uchar   ReportDesc[REPORT_DSC_SIZE];  /*!< Store Report Descriptor          */
		USHORT  ReportDescSize;               /*!< Size of Report Descriptor        */
		USHORT  Pos;                          /*!< Store current pos in descriptor  */
		uchar   Item;                         /*!< Store current Item               */
		long    Value;                        /*!< Store current Value              */

		HIDData Data;                         /*!< Store current environment        */

		uchar   OffsetTab[MAX_REPORT][3];     /*!< Store ID, type & offset of report*/
		uchar   ReportCount;                  /*!< Store Report Count               */
		uchar   Count;                        /*!< Store local report count         */

		USHORT  UPage;                        /*!< Global UPage                     */
		HIDNode UsageTab[USAGE_TAB_SIZE];     /*!< Usage stack                      */
		uchar   UsageSize;                    /*!< Design number of usage used      */

		uchar   nObject;                      /*!< Count objects in Report Descriptor */
		uchar   nReport;                      /*!< Count reports in Report Descriptor */
	} HIDParser;

#ifdef __cplusplus
} /* extern "C" */
#endif /* __cplusplus */

#endif
```

`UsbMon/UsbMon/IrpHook.c`:

```c

#include "IrpHook.h" 

///////////////////////////////////////////////////////////////////////////////////////////////
////	Types
////
////

typedef struct _IRPHOOK_LIST {
	TChainListHeader*  head;
	ULONG		   RefCount;
}IRPHOOKLIST, *PIRPHOOKLIST;

typedef struct SEARCHPARAM
{
	PDRIVER_OBJECT driver_object;
	ULONG				 IrpCode;
}SEARCHPARAM, *PSEARCHPARAM;



///////////////////////////////////////////////////////////////////////////////////////////////
////	Marco
////
////

#define GetNodeByPTR(ListHead,NodeValue) QueryFromChainListByULONGPTR(ListHead, (ULONG_PTR)NodeValue)

///////////////////////////////////////////////////////////////////////////////////////////////
////	Global Variable
////
////
IRPHOOKLIST*   	  g_IrpHookList = NULL;
BOOLEAN			  g_IsInit = FALSE;


///////////////////////////////////////////////////////////////////////////////////////////////
////	Prototype
////
////


/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

Lookup Pending IRP callback, in callback, we
recovered the completion hook

Arguments:

pending_irp_node - Each node inside IRP pending list

context			 - Not used

Return Value:

LOOKUP_STATUS	 - CLIST_FINDCB_CTN, traverse whole
list
-------------------------------------------------------*/
LOOKUP_STATUS	LookupPendingIrpCallback(
	_In_ PENDINGIRP* pending_irp_node,
	_In_ PVOID		 context
);

///////////////////////////////////////////////////////////////////////////////////////////////
////	Implementation
////
////
//// 
//----------------------------------------------------------------------------------------//
PENDINGIRP* GetRealPendingIrpByIrp(
	_In_	PENDINGIRPLIST* ListHeader,
	_In_	PIRP irp
)
{
	if (!irp || !ListHeader)
	{
		return NULL;
	}
	return GetNodeByPTR(ListHeader->head, irp);
}


//----------------------------------------------------------------------------------------//
NTSTATUS InsertPendingIrp(
	_In_ 	PENDINGIRPLIST*  ListHeader,
	_In_ 	PENDINGIRP* 	 PendingIrp
)
{
	NTSTATUS status = STATUS_UNSUCCESSFUL;
	if (!PendingIrp || !ListHeader)
	{
		return status;
	}
	if (AddToChainListTail(ListHeader->head, PendingIrp))
	{
		status = STATUS_SUCCESS;
	}
	return status;
}

//----------------------------------------------------------------------------------------//
NTSTATUS RemovePendingIrp(
	_In_ 	PENDINGIRPLIST*  ListHeader,
	_In_ 	PENDINGIRP* 	 PendingIrp
)
{
	NTSTATUS status = STATUS_UNSUCCESSFUL;
	if (!PendingIrp || !ListHeader)
	{
		USB_DEBUG_INFO_LN_EX("Both empty");
		return status;
	}
	if (DelFromChainListByPointer(ListHeader->head, PendingIrp))
	{
		USB_DEBUG_INFO_LN_EX("Errrrrrrr empty");
		status = STATUS_SUCCESS;
	}

	USB_DEBUG_INFO_LN_EX("ErrrrWWrrrr empty");

	return status;
}

//----------------------------------------------------------------------------------------//
NTSTATUS AllocatePendingIrpLinkedList(
	_Inout_ 	PENDINGIRPLIST**  ListHeader
)
{
	NTSTATUS status = STATUS_UNSUCCESSFUL;
	do
	{
		if (!*ListHeader)
		{
			*ListHeader = (PENDINGIRPLIST*)ExAllocatePoolWithTag(NonPagedPool, sizeof(PENDINGIRPLIST), 'kcaj');
			if (!*ListHeader)
			{
				status = STATUS_UNSUCCESSFUL;
				break;
			}
			RtlZeroMemory(*ListHeader, sizeof(PENDINGIRPLIST));
		}

		if (!(*ListHeader)->head)
		{
			(*ListHeader)->head = NewChainListHeaderEx(LISTFLAG_SPINLOCK | LISTFLAG_AUTOFREE, NULL, 0);
			if (!(*ListHeader)->head)
			{
				ExFreePool(*ListHeader);
				*ListHeader = NULL;
				status = STATUS_UNSUCCESSFUL;
				break;
			}
			(*ListHeader)->RefCount = 1;
		}

		status = STATUS_SUCCESS;
	} while (FALSE);
	return status;
}
//----------------------------------------------------------------------------------------//
NTSTATUS FreePendingIrpList(
	_In_ 	PENDINGIRPLIST*  ListHeader
)
{
	if (ListHeader)
	{
		if (ListHeader->head)
		{
			CHAINLIST_SAFE_FREE(ListHeader->head);
		}
		ExFreePool(ListHeader);
		ListHeader = NULL;
	}
	return STATUS_SUCCESS;
}

//-------------------------------------------------------------------------------------------//
LOOKUP_STATUS LookupPendingIrpCallback(
	_In_ PENDINGIRP* pending_irp_node,
	_In_ void*		 context
)
{


	NTSTATUS    status = STATUS_UNSUCCESSFUL;
	PENDINGIRP* pending_irp = pending_irp_node;
	if (pending_irp)
	{
		InterlockedExchange64((LONG64 volatile*)&pending_irp->IrpStack->Context, (ULONG64)pending_irp->oldContext);
		InterlockedExchange64((LONG64 volatile*)&pending_irp->IrpStack->CompletionRoutine, (ULONG64)pending_irp->oldRoutine);
		USB_DEBUG_INFO_LN_EX("RemovePendingIrpCallback Once %I64x", pending_irp_node);
	}
	return CLIST_FINDCB_CTN;
}

//----------------------------------------------------------------------------------------- 
NTSTATUS RecoverAllCompletionHook(
	_In_ 	PENDINGIRPLIST*  ListHeader
)
{
	NTSTATUS						   status = STATUS_UNSUCCESSFUL;
	if (QueryFromChainListByCallback(ListHeader->head, LookupPendingIrpCallback, NULL))
	{
		status = STATUS_SUCCESS;
	}
	return status;
}

//--------------------------------------------------------------------------------------------//
ULONG SearchIrpHookObjectCallback(
	_In_ IRPHOOKOBJ* IrpObject,
	_In_ void* Context
)
{
	SEARCHPARAM* param = (SEARCHPARAM*)Context;
	if (IrpObject->driver_object == param->driver_object && IrpObject->IrpCode == param->IrpCode)
	{
		return CLIST_FINDCB_RET;
	}
	return CLIST_FINDCB_CTN;
}
//--------------------------------------------------------------------------------------------//
IRPHOOKOBJ* GetIrpHookObject(
	_In_ PDRIVER_OBJECT driver_object,
	_In_ ULONG IrpCode)
{
	SEARCHPARAM param = { 0 };
	param.driver_object = driver_object;
	param.IrpCode = IrpCode;
	return QueryFromChainListByCallback(g_IrpHookList->head, SearchIrpHookObjectCallback, &param);
}

//--------------------------------------------------------------------------------------------//
ULONG RemoveIrpHookCallback(
	_In_ IRPHOOKOBJ* IrpObject,
	_In_ void* Context
)
{

	IRPHOOKOBJ* hook_obj = IrpObject;
	if (hook_obj)
	{
		DoIrpHook(hook_obj->driver_object, hook_obj->IrpCode, hook_obj->oldFunction, Stop);
		USB_DEBUG_INFO_LN_EX("RemoveIrpHookCallback Once hook_obj->driver_object: %ws ", hook_obj->driver_object->DriverName.Buffer);
		hook_obj = NULL;
	}
	return CLIST_FINDCB_CTN | CLIST_FINDCB_DEL;
}

//--------------------------------------------------------------------------------------------//
NTSTATUS RecoverAllIrpHook()
{
	NTSTATUS    status = STATUS_UNSUCCESSFUL;
	if (g_IrpHookList)
	{
		QueryFromChainListByCallback(g_IrpHookList->head, RemoveIrpHookCallback, NULL);
		ExFreePool(g_IrpHookList);
		g_IrpHookList = NULL;
		status = STATUS_SUCCESS;
	}

	return status;
}

//--------------------------------------------------------------------------------------------//
IRPHOOKOBJ* CreateIrpHookObject(
	_In_ PDRIVER_OBJECT DriverObject,
	_In_ ULONG IrpCode,
	_In_ PVOID oldFunction,
	_In_ PVOID newFunction)
{
	IRPHOOKOBJ* HookObj = (IRPHOOKOBJ*)ExAllocatePoolWithTag(NonPagedPool, sizeof(IRPHOOKOBJ), 'opri');

	if (!g_IrpHookList)
	{
		USB_DEBUG_INFO_LN_EX("Empty Hook Object \r\n");
		return NULL;
	}
	if (!HookObj)
	{
		USB_DEBUG_INFO_LN_EX("Empty Hook Object \r\n");
		return NULL;
	}

	RtlZeroMemory(HookObj, sizeof(IRPHOOKOBJ));

	HookObj->driver_object = DriverObject;
	HookObj->IrpCode = IrpCode;
	HookObj->newFunction = newFunction;
	HookObj->oldFunction = oldFunction;

	if (!AddToChainListTail(g_IrpHookList->head, HookObj))
	{
		USB_DEBUG_INFO_LN_EX("Cannot Add to list ");
		ExFreePool(HookObj);
		HookObj = NULL;
	}

	USB_DEBUG_INFO_LN_EX("IRP List Size: %x with DriverName: %ws ", g_IrpHookList->head->Count, DriverObject->DriverName.Buffer);

	return HookObj;
}

//--------------------------------------------------------------------------------------------//
NTSTATUS AllocateIrpHookLinkedList()
{
	NTSTATUS status = STATUS_UNSUCCESSFUL;
	do {
		if (!g_IrpHookList)
		{
			g_IrpHookList = (IRPHOOKLIST*)ExAllocatePoolWithTag(NonPagedPool, sizeof(IRPHOOKLIST), 'opri');
			if (!g_IrpHookList)
			{
				status = STATUS_UNSUCCESSFUL;
				break;
			}
			RtlZeroMemory(g_IrpHookList, sizeof(IRPHOOKLIST));
		}
		if (!g_IrpHookList->head)
		{
			g_IrpHookList->head = NewChainListHeaderEx(LISTFLAG_SPINLOCK | LISTFLAG_AUTOFREE, NULL, 0);
			if (!g_IrpHookList->head)
			{
				ExFreePool(g_IrpHookList);
				g_IrpHookList = NULL;
				status = STATUS_UNSUCCESSFUL;
				break;
			}
			g_IrpHookList->RefCount = 1;
		}
		status = STATUS_SUCCESS;
	} while (FALSE);
	return status;
}

//--------------------------------------------------------------------------------------------//
PVOID DoIrpHook(
	_In_	  PDRIVER_OBJECT DriverObject,
	_In_	  ULONG IrpCode,
	_In_	  PVOID NewFunction,
	_In_  	  Action action
)
{
	PVOID old_irp_function = NULL;
	if (!DriverObject || !NewFunction || !g_IrpHookList)
	{
		return old_irp_function;
	}

	old_irp_function = (DRIVER_DISPATCH*)InterlockedExchange64(
		(LONG64 volatile *)&DriverObject->MajorFunction[IrpCode],
		(LONG64)NewFunction
	);

	if (action == Start && old_irp_function)
	{
		//Create Object
		if (!CreateIrpHookObject(DriverObject, IrpCode, old_irp_function, NewFunction))
		{
			//repair hook, if created fail.
			InterlockedExchange64((LONG64 volatile *)&DriverObject->MajorFunction[IrpCode], (LONG64)old_irp_function);
			old_irp_function = NULL;
		}
	}

	return old_irp_function;
}
//--------------------------------------------------------------------------------------------//
NTSTATUS InitIrpHookSystem()
{
	if (!NT_SUCCESS(AllocateIrpHookLinkedList()))
	{
		return STATUS_UNSUCCESSFUL;
	}
	g_IsInit = TRUE;
	return STATUS_SUCCESS;
}


//--------------------------------------------------------------------------------------------//
NTSTATUS UnInitIrpHookSystem()
{
	if (!NT_SUCCESS(RecoverAllIrpHook()))
	{
		USB_DEBUG_INFO_LN_EX("AllocatePendingIrpLinkedList Error");
		return STATUS_UNSUCCESSFUL;
	}

	g_IsInit = FALSE;

	return STATUS_SUCCESS;
}

//--------------------------------------------------------------------------------------------//
NTSTATUS FreePendingList(PENDINGIRPLIST* PendingIrpList)
{

	//1. Recovery
	RecoverAllCompletionHook(PendingIrpList);

	//2. Free Memory
	if (!NT_SUCCESS(FreePendingIrpList(PendingIrpList)))
	{
		return STATUS_UNSUCCESSFUL;
	}

	return STATUS_SUCCESS;
}
//--------------------------------------------------------------------------------------------//

//----------------------------------------------------------------------------------------//
NTSTATUS IrpVerifyPendingIrpCompletionHookCallback(
	_In_ PENDINGIRP* pending_irp_node,
	_In_ void*		 context
)
{
	NTSTATUS  	     status = STATUS_UNSUCCESSFUL;
	PENDINGIRP* pending_irp = pending_irp_node;

	if (!pending_irp)
	{
		return CLIST_FINDCB_CTN;
	}

	// if one of them is modified, return it.
	if ((ULONG_PTR)pending_irp->IrpStack->CompletionRoutine != (ULONG_PTR)pending_irp->newRoutine)
	{
		return CLIST_FINDCB_RET;
	}

	return CLIST_FINDCB_CTN;
}

NTSTATUS IrpVerifyPendingIrpCompletionHookByIrp(
	_In_	PENDINGIRPLIST* ListHeader,
	_In_	PIRP Irp
)
{
	NTSTATUS  status = STATUS_UNSUCCESSFUL;

	//Return NOT NULL, if and only if a completion callback is modified.
	//See: IrpVerifyPendingIrpCompletionHookCallback
	if (!QueryFromChainListByCallback(ListHeader->head, IrpVerifyPendingIrpCompletionHookCallback, Irp))
	{
		status = STATUS_SUCCESS;
	}
	return status;
}


```

`UsbMon/UsbMon/IrpHook.h`:

```h
#pragma once

#include <ntddk.h> 
#include "CommonUtil.h"
#include "TList.h"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////	Types
////

typedef enum
{
	Start = 0,
	Stop,
}Action;

#pragma pack (8)
typedef struct PENDINGIRP
{
	PIRP						  Irp;			//Irp
	PIO_STACK_LOCATION		 IrpStack;			//Old IRP stack
	PVOID					oldContext;			//Old IRP routine argument
	IO_COMPLETION_ROUTINE*	oldRoutine;			//Old IRP routine address
	IO_COMPLETION_ROUTINE*	newRoutine;			//new IRP routine address
	PVOID					newContext;			//new IRP routine argument
}PENDINGIRP, *PPENDINGIRP;
#pragma pack()
 
#pragma pack (8)
typedef struct IRPHOOKOBJ
{  
	PDRIVER_OBJECT driver_object;
	ULONG				 IrpCode;
	PDRIVER_DISPATCH oldFunction;
	PDRIVER_DISPATCH newFunction;
	BOOLEAN 		 IsAttacked;
	BOOLEAN 		 IsAttacked2;
	ULONG64			ObjCheckSum;
}IRPHOOKOBJ, *PIRPHOOKOBJ;
#pragma pack() 

#pragma pack (8) 
 typedef struct _PENDINGIRP_LIST
{
	TChainListHeader*	head;
	ULONG				RefCount;
	KTIMER				m_Timer;
	KDPC				m_DPCP ;
	LARGE_INTEGER		m_Timeout ;
	BOOLEAN         	bIsStartedCheckSum;	
	BOOLEAN				bIsAttackReported;
}PENDINGIRPLIST, *PPENDINGIRPLIST;
#pragma pack() 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////	Prototype
////


//--------------------------------------------------------------------------------------
//	
//
NTSTATUS InsertPendingIrp(
	_In_ PENDINGIRPLIST* ListHeader,
	_In_ PENDINGIRP* PendingIrp
);


//--------------------------------------------------------------------------------------
//	
//
NTSTATUS RemovePendingIrp(
	_In_ PENDINGIRPLIST* Listheader,
	_In_ PENDINGIRP* PendingIrp
);


//--------------------------------------------------------------------------------------
//	
//
NTSTATUS InitIrpHookSystem(BOOLEAN IsChecksum);



//--------------------------------------------------------------------------------------
//	
//
NTSTATUS UnInitIrpHookSystem();




//--------------------------------------------------------------------------------------
//	
//
PVOID	DoIrpHook(
	_In_		PDRIVER_OBJECT	driver_object, 
	_In_		ULONG			IrpCode, 
	_In_		PVOID			NewFunction,  
	_In_		Action			action
);

//--------------------------------------------------------------------------------------
//	
//
IRPHOOKOBJ*	CreateIrpHookObject(
	_In_	PDRIVER_OBJECT driver_object,
	_In_	ULONG		   IrpCode,
	_In_	PVOID		   oldFunction,
	_In_	PVOID		   newFunction
);

//--------------------------------------------------------------------------------------
//	
//
IRPHOOKOBJ* GetIrpHookObject(
	_In_ PDRIVER_OBJECT driver_object,
	_In_ ULONG IrpCode
);

//--------------------------------------------------------------------------------------
//	
//
NTSTATUS IrpVerifyPendingIrpCompletionHookByIrp(	
	_In_	PENDINGIRPLIST* ListHeader,
	_In_	PIRP Irp
);

//--------------------------------------------------------------------------------------
//	
//
PENDINGIRP* GetRealPendingIrpByIrp(
	_In_	PENDINGIRPLIST* ListHeader,
	_In_ PIRP irp
);

//--------------------------------------------------------------------------------------
//	
// 
NTSTATUS AllocatePendingIrpLinkedList(
	_Inout_ 	PENDINGIRPLIST**  ListHeader
);

//--------------------------------------------------------------------------------------
//	
//  
NTSTATUS FreePendingList(
	_In_ PENDINGIRPLIST* PendingIrpList
);

//--------------------------------------------------------------------------------------
//	
//  
VOID StartTimeBoom(void* params);

```

`UsbMon/UsbMon/LinkedList.h`:

```h
#ifndef __INC_LINKLIST_H
#define __INC_LINKLIST_H

//
//  Doubly linked list structure.  Can be used as either a list head, or
//  as link words.
//
typedef struct _RT_LIST_ENTRY {
	struct _RT_LIST_ENTRY *Flink;
	struct _RT_LIST_ENTRY *Blink;
} RT_LIST_ENTRY, *PRT_LIST_ENTRY;

#define	RTIsUnInitializedListHead(ListHead)	\
	(NULL == (ListHead)->Flink || NULL == (ListHead)->Blink)

#define	RTIsListHead(ListHead, __Entry)	\
	((ListHead) == (__Entry))

//
//  Doubly-linked list manipulation routines.  Implemented as macros
//
#define RTInitializeListHead(ListHead)				\
	((ListHead)->Flink = (ListHead)->Blink = (ListHead))


#define RTIsListEmpty(ListHead)					\
	((ListHead)->Flink == NULL || (ListHead)->Flink == (ListHead))

#define RTIsListNotEmpty(ListHead)					\
	((ListHead)->Flink != (ListHead))

#define RTGetHeadList(ListHead)					\
	((ListHead)->Flink)

#define RTGetTailList(ListHead)					\
	(ListHead)->Blink

#define RTRemoveHeadList(ListHead)				\
	(ListHead)->Flink;							\
	{RTRemoveEntryList((ListHead)->Flink)}


#define RTRemoveTailList(ListHead)				\
	(ListHead)->Blink;							\
	{RTRemoveEntryList((ListHead)->Blink)}


#define RTNextEntryList(Entry)					\
	(Entry)->Flink

#define RTForeEntryList(Entry)					\
	(Entry)->Blink


#define RTRemoveEntryList(Entry)					\
	{											\
		PRT_LIST_ENTRY _EX_Blink;					\
		PRT_LIST_ENTRY _EX_Flink;					\
		_EX_Flink = (Entry)->Flink;					\
		_EX_Blink = (Entry)->Blink;				\
		_EX_Blink->Flink = _EX_Flink;				\
		_EX_Flink->Blink = _EX_Blink;				\
	}


#define RTInsertTailList(ListHead,Entry)			\
	{											\
		PRT_LIST_ENTRY _EX_Blink;					\
		PRT_LIST_ENTRY _EX_ListHead;				\
		_EX_ListHead = (ListHead);					\
		_EX_Blink = _EX_ListHead->Blink;			\
		(Entry)->Flink = _EX_ListHead;				\
		(Entry)->Blink = _EX_Blink;				\
		_EX_Blink->Flink = (Entry);					\
		_EX_ListHead->Blink = (Entry);				\
	}


#define RTInsertHeadList(ListHead,Entry)			\
	{											\
		PRT_LIST_ENTRY _EX_Flink;					\
		PRT_LIST_ENTRY _EX_ListHead;				\
		_EX_ListHead = (ListHead);					\
		_EX_Flink = _EX_ListHead->Flink;			\
		(Entry)->Flink = _EX_Flink;					\
		(Entry)->Blink = _EX_ListHead;				\
		_EX_Flink->Blink = (Entry);					\
		_EX_ListHead->Flink = (Entry);				\
	}


#define RTPopEntryList(ListHead)					\
	(ListHead)->Next;							\
	{											\
		PRT_SINGLE_LIST_ENTRY FirstEntry;			\
		FirstEntry = (ListHead)->Next;				\
		if (FirstEntry != NULL)						\
		{										\
			(ListHead)->Next = FirstEntry->Next;	\
		}										\
	}


#define RTPushEntryList(ListHead,Entry)			\
	(Entry)->Next = (ListHead)->Next;				\
	(ListHead)->Next = (Entry)

// Insert __InsertedEntry before __Entry
#define	RTInsertEntryBeforeEntry(__InsertedEntry,	__Entry)	\
	{											\
		PRT_LIST_ENTRY _EX_Blink;					\
		_EX_Blink = (__Entry)->Blink;				\
		_EX_Blink->Flink = (__InsertedEntry);			\
		(__InsertedEntry)->Blink = _EX_Blink;			\
		(__InsertedEntry)->Flink = (__Entry);			\
		(__Entry)->Blink = (__InsertedEntry);			\
	}

// Insert __InsertedEntry after __Entry
#define	RTInsertEntryAfterEntry(__InsertedEntry,	__Entry)	\
	{											\
		PRT_LIST_ENTRY _EX_Flink;					\
		_EX_Flink = (__Entry)->Flink;				\
		_EX_Flink->Blink = (__InsertedEntry);			\
		(__InsertedEntry)->Flink = _EX_Flink;			\
		(__InsertedEntry)->Blink = (__Entry);			\
		(__Entry)->Flink = (__InsertedEntry);			\
	}

//---------------------------------------------------------------------------
// The following MACROs do the same with the above MACROs except the Cnt parameter.
// Cnt is a pointer to counter which will be modified.

#define RTRemoveHeadListWithCnt(ListHead,Cnt)				\
	(ListHead)->Flink;										\
	RTRemoveEntryListWithCnt((ListHead)->Flink, Cnt)

#define RTRemoveTailListWithCnt(ListHead,Cnt)					\
	(ListHead)->Blink;										\
	RTRemoveEntryListWithCnt((ListHead)->Blink, Cnt)

#define RTRemoveEntryListWithCnt(Entry,Cnt)					\
	RTRemoveEntryList(Entry)								\
	(*Cnt)--;

#define RTInsertTailListWithCnt(ListHead,Entry,Cnt)				\
	RTInsertTailList(ListHead,Entry)							\
	(*Cnt)++;

#define RTInsertHeadListWithCnt(ListHead,Entry,Cnt)			\
	RTInsertHeadList(ListHead,Entry)							\
	(*Cnt)++;

#define RTPopEntryListWithCnt(ListHead,Cnt)					\
	RTPopEntryList(ListHead)									\
	(*Cnt)--;

#define RTPushEntryListWithCnt(ListHead,Entry,Cnt)				\
	RTPushEntryList(ListHead,Entry)							\
	(*Cnt)++;



#define RTSwitchListHead(orgListHead,	newListHead)			\
{															\
	RTNextEntryList(newListHead) = RTNextEntryList(orgListHead);	\
	RTForeEntryList(RTNextEntryList(orgListHead)) = newListHead;	\
	RTNextEntryList(RTForeEntryList(orgListHead)) = newListHead;	\
	RTForeEntryList(newListHead) = RTForeEntryList(orgListHead);	\
	RTInitializeListHead(orgListHead);						\
}	

#define RtEntryListForEach(__pListHead, __itEntry) \
	for((__itEntry) = RTGetHeadList((__pListHead)); \
		(__itEntry) != (__pListHead); \
		(__itEntry) = RTNextEntryList((__itEntry)) \
		)

#define RtEntryListForEachSafe(__pListHead, __itEntry, __n) \
	for((__itEntry) = RTGetHeadList((__pListHead)), \
			(__n) = (__itEntry)->Flink; \
		(__itEntry) != (__pListHead); \
		(__itEntry) = (__n), (__n) = RTNextEntryList((__n)) \
		)

//
//  Singly linked list structure. 
//  Only used as link words.
//
typedef struct _RT_SINGLE_LIST_ENTRY {
	struct _RT_SINGLE_LIST_ENTRY *Next;
} RT_SINGLE_LIST_ENTRY, *PRT_SINGLE_LIST_ENTRY;

//
//  Singly linked list structure. 
//  Only used as link head.
//
typedef struct _RT_SINGLE_LIST_HEAD {
	PRT_SINGLE_LIST_ENTRY First;
	PRT_SINGLE_LIST_ENTRY Last;
} RT_SINGLE_LIST_HEAD, *PRT_SINGLE_LIST_HEAD;



//
//	Single link list routines.
//
#define RTInitializeSListHead(SListHead) \
	((SListHead)->First = (SListHead)->Last = NULL)

#define RTIsSListEmpty(SListHead) \
	((SListHead)->First == NULL)

#define RTGetHeadSList(SListHead) \
	(PRT_SINGLE_LIST_ENTRY)((SListHead)->First)

#define RTGetTailSList(SListHead) \
	(PRT_SINGLE_LIST_ENTRY)((SListHead)->Last)

#define RTRemoveHeadSList(SListHead) \
	RTGetHeadSList(SListHead); \
	RT_ASSERT(!RTIsSListEmpty(SListHead), ("RTRemoveHeadSList(): SList(%p) is empty!!!\n", SListHead)); \
	{ \
		PRT_SINGLE_LIST_ENTRY pToRemove = (SListHead)->First; \
		if((SListHead)->First == (SListHead)->Last) \
		{ \
			(SListHead)->First = (SListHead)->Last = NULL; \
		} \
		else \
		{ \
			(SListHead)->First = pToRemove->Next; \
		} \
		pToRemove->Next = NULL; \
	}

#define RTInsertTailSList(SListHead, SListEntry) \
	{ \
		PRT_SINGLE_LIST_ENTRY pOldTail = (SListHead)->Last; \
		(SListEntry)->Next = NULL; \
		if(RTIsSListEmpty(SListHead)) \
		{ \
			(SListHead)->First = (SListHead)->Last = SListEntry; \
		} \
		else \
		{ \
			pOldTail->Next = SListEntry; \
			(SListHead)->Last = SListEntry; \
		} \
	}


#endif // #ifndef __INC_LINKLIST_H
```

`UsbMon/UsbMon/OpenLoopBuffer.c`:

```c
#include "OpenLoopBuffer.h"
 

#pragma intrinsic(_ReturnAddress) 
CIRCULARBUFFER* NewOpenLoopBuffer(
	_In_ ULONG MaxCount, 
	_In_ ULONG CellSize,
	_In_ ULONG Flags)
{
	char* Buffer = NULL;
	CIRCULARBUFFER* cb;
	CIRCULARBUFFER* header=NULL;
	ULONG memsize= MaxCount * CellSize + sizeof(CIRCULARBUFFER);
	 
	memsize = BYTES_TO_PAGES(memsize) * 0x1000;
	Buffer  = (char*)ExAllocatePoolWithTag(NonPagedPool, memsize, 'cbne');
	
	if(!Buffer)
	{
		return NULL;
	}
	
	RtlZeroMemory(Buffer, memsize);

	cb = (CIRCULARBUFFER*)Buffer;

	cb->Flags=Flags;
	cb->MaxCount = MaxCount;
	cb->CellSize = CellSize;
	cb->LatestIndex = 0 ;
	cb->WriteIndex=0;
	cb->WriteRef=0;
	cb->Buffer=cb->Data;
	
	if(Flags&OPENLOOPBUFF_FALGS_PEASUDOHEADER)
	{
		header=(CIRCULARBUFFER*)ExAllocatePoolWithTag(NonPagedPool,sizeof(CIRCULARBUFFER) , 'cbne');
		if(!header)
		{
			ExFreePool(cb);
			cb= NULL;
			return cb;
		}
		
		memcpy(header,cb,sizeof(CIRCULARBUFFER));
		
		cb->Buffer=NULL;
		header->Header=cb;
		header->Flags=Flags;
		
		return header;
	}

	return cb;
}
 
//--------------------------------------------------------------------------------------------//
void  OpenLoopBufferWrite(
	_In_ CIRCULARBUFFER* cb, 
	_In_ const void *item)
{
	ULONG Index = 0; 

	if(!cb || !cb->Header)
	{
		return ;	
	}
	
	InterlockedIncrement(&cb->WriteRef);

	Index = cb->WriteIndex % cb->MaxCount;
	
	memcpy(cb->Buffer + Index * cb->CellSize, item, cb->CellSize);
	
	cb->WriteIndex = InterlockedAdd64((LONG64 volatile*)&cb->WriteIndex, 1);
	
	if (InterlockedDecrement(&cb->WriteRef) == 0)
	{		
		InterlockedExchange64((LONG64 volatile*)&cb->LatestIndex, cb->WriteIndex); 
		if(cb->Flags&OPENLOOPBUFF_FALGS_PEASUDOHEADER)
		{
			cb->Header->MaxCount=cb->MaxCount;
			cb->Header->CellSize=cb->CellSize;
			cb->Header->WriteIndex=cb->WriteIndex;
			cb->Header->LatestIndex=cb->LatestIndex;
			
			USB_DEBUG_INFO_LN_EX("_ReturnAddress: %p KernelModeIndex: %d WriteIndex: %I64u LatestIndex: %I64u ", _ReturnAddress(), Index, cb->WriteIndex, cb->LatestIndex );
		}	

	}
}

//------------------------------------------------//
ULONG64  OpenLoopBufferRead(
	_In_	CIRCULARBUFFER* cb, 
	_In_	PVOID			RequestedBuffer,  
	_In_	ULONG			RequestedCount,
	_In_	ULONG64			TargetIndex, 
	_Inout_ ULONG64*		LastIndex
)
{
	ULONG64 i = 0;
	ULONG64 base = 0;
	ULONG64 Offset = 0;	
	ULONG64 WritecacheLen = 0;
	
	if(!cb || !cb->Header)
	{
		return 0;	
	}
	
	if (TargetIndex < cb->LatestIndex)
	{
		base = InterlockedAdd64((LONG64 volatile*)&cb->LatestIndex, 0) - 1;
		Offset = base - TargetIndex;
		WritecacheLen = InterlockedAdd64((LONG64 volatile*)&cb->WriteIndex, 0) - InterlockedAdd64((LONG64 volatile*)&cb->LatestIndex, 0);

		if (WritecacheLen > cb->MaxCount / 2)
		{
			WritecacheLen = cb->MaxCount / 2;
		}
		else if(WritecacheLen<8)
		{
			WritecacheLen = 8;
		}

		if (Offset > cb->MaxCount - 1- WritecacheLen)
		{
			Offset = cb->MaxCount - 1- WritecacheLen;
		}
		if (Offset > base)
		{
			Offset = base;
		}

		for ( i = 0; i <= Offset && i < RequestedCount ; i++)
		{
			ULONG Index = (ULONG)(( base - Offset + i ) % cb->MaxCount); 
			  
			memcpy((PUCHAR)RequestedBuffer+i*cb->CellSize, cb->Buffer+Index*cb->CellSize, cb->CellSize);

			/*printf(" base: %d Offset: %d j: %d SerialCode: %d g_InfoDataIndex: %d\r\n",
				base, Offset, Index, TargetIndex, cb->LatestIndex); 
				*/
		}
		*LastIndex = base - Offset + i ;
		if (*LastIndex == 0)
		{
			USB_DEBUG_INFO_LN_EX(" base: %d Offset: %d i: %d TargetIndex: %d LatestIndex: %d\r\n",
				base, Offset,  i , TargetIndex, cb->LatestIndex);
		}
	}

	return i;
}

//------------------------------------------------//
VOID   OpenLoopBufferRelease(
	_In_	CIRCULARBUFFER* cb
)
{
	PVOID CBufferHeader = NULL;
	if(!cb)
	{
		return ; 
	}
	
	CBufferHeader = cb->Header;
	ExFreePool(cb);
	cb = NULL;
	
	if(!CBufferHeader)
	{
		return ;
	}
	
	ExFreePool(CBufferHeader);
	CBufferHeader = NULL;  
}
```

`UsbMon/UsbMon/OpenLoopBuffer.h`:

```h
#pragma once

#include <ntddk.h>
#include "CommonUtil.h"

#pragma pack (push, 4)
typedef struct circular_buffer
{ 
    ULONG    		Ver;
	ULONG    		Flags;
	ULONG	 		MaxCount;		// maximum number of items in the buffer
	ULONG	 		CellSize;		// size of each item in the buffer  
	ULONG64  		LatestIndex;
	ULONG64  		WriteIndex;
	ULONG    		WriteRef;
	union {
		ULONG64 			   iHeader;
		struct circular_buffer* Header;
	};
	union{
		ULONG64		   iBuffer;
		PUCHAR   		Buffer;
	};
	
	UCHAR	 		Data[4];     // data buffer 
} CIRCULARBUFFER, *PCIRCULARBUFFER;
#pragma pack (pop)


#define OPENLOOPBUFF_FALGS_PEASUDOHEADER  0x80000000


CIRCULARBUFFER* NewOpenLoopBuffer(
	_In_ ULONG MaxCount, 
	_In_ ULONG CellSize,
	_In_ ULONG Flags
);


//-------------------------------------------------------------------------------------------//
void OpenLoopBufferWrite(
	_In_ CIRCULARBUFFER* cb, 
	_In_ const void *item
);
	
//------------------------------------------------//
ULONG64 OpenLoopBufferRead(
	_In_	CIRCULARBUFFER* cb, 
	_In_	PVOID			RequestedBuffer,  
	_In_	ULONG			RequestedCount,
	_In_	ULONG64			TargetIndex, 
	_Inout_ ULONG64*		LastIndex
);


//------------------------------------------------//
VOID  OpenLoopBufferRelease(
	_In_	CIRCULARBUFFER* cb
);
 
```

`UsbMon/UsbMon/Readme.txt`:

```txt
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///
//

 Usb Hid Device Createion Process:
----------------------------------------------------
Driver Stack:

----->	  Filter 
			|
			|
			|
			|
-----> MouClass / KbdClass.sys	(KbdServiceCallback)
			|
			|
			|
			|
-----> MouHid / Kbdhid.sys			
			|
			|
			|
			|
			|	　＿＿＿＿＿＿＿ HID Usb Device Stack			
			|	 /				----------------	 ＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿ 
			|	｜				+  Client PDO  +								               ＼
			|	｜				+--------------+	 ＿＿＿＿＿								    |
			|	｜				+	  FDO	   +			　＼			　　			            |
			|	｜				----------------			   |								| Query Pnp Relations by FDO:
-----> UsbHid.sys(miniclass driver)							   |							   (7)		- Create Client Pdo	 
			|       /\										   | AddDevice:						|			(0000000xx)	　				　
			|	 　　|										  (2)	- Create FDO            	|							　
			| 　ｘ   |									       |	 (HID_xxxxxxx)				|							　
			|	|　　|     Call Mini-Class AddDevice		       |								|								                                    <<<<<<<<<<<
			|	|　　|＿＿＿＿＿＿＿＿(3)＿＿＿＿＿＿＿＿＿＿＿＿ / ＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿／ ＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿   ＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿ HidClass.sys(Class driver)							　
			|	|											　  /\			　　　/\					　　/\					   　\  
			|   |					　　							｜				  |						|		                 |
			|   |					　　							｜ Actual		  | IRP Query Pnp		| IRP StartDevice Pnp	 |	　
			|   |					　　							｜ AddDevice		 (6) Reations			(4) Reations             |	 
			|   |					　　						    (1)Path           |  					|                        |
			|   |					　　							｜                |  					|　　　　　　　　　　　   (5) IoInvalidateDeviceRelations
			|   |					　　							｜                |  					|　　　　　　　　　　　    |
			|   |					　　							｜                |  					|　　　　　　　　　　　    |
			|	|					　　							｜                |  					|　　　　　　　　　　　    |											
-----> UsbHub   |					　　							｜                |  					|　　　　　　　　　　　    |										
   (Bus Driver) |	 UsbHid Expected AddDevice Call Path		｜                |  					|　　　　　　　　　　　    |									 
				＼＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿ ＼＿＿＿＿＿＿＿＿ ＼＿＿＿＿＿＿＿＿＿    ＼＿＿＿＿＿＿＿          \/ ＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿   	 PnP		  
																																									   Manager	  



/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Windows 7 - 10 x64 structure:

struct _CHANNEL_REPORT_HEADER
{
	USHORT Offset;  // Position in the _CHANNEL_ITEM array
	USHORT Size;    // Length in said array
	USHORT Index;
	USHORT ByteLen; // The length of the data including reportID.
					// This is the longest such report that might be received
					// for the given collection.
};

/*
typedef struct _HIDP_CHANNEL_DESC
{
	USHORT   UsagePage;		  //+0x0
	UCHAR    ReportID;		  //+0x2
	UCHAR    BitOffset;		  // 0 to 8 value describing bit alignment	+0x3
	USHORT   ReportSize;	  // HID defined report size	+0x4
	USHORT   ReportCount;	  // HID defined report count	+0x6
	USHORT   ByteOffset;	  // byte position of start of field in report packet +0x8
	USHORT   BitLength;		  // total bit length of this channel	+0xA
	ULONG    BitField;		  // The 8 (plus extra) bits associated with a main item +0xC
	USHORT   ByteEnd;		  // First byte not containing bits of this channel. +0x10
	USHORT   LinkCollection;  // A unique internal index pointer	+0x12
	USHORT   LinkUsagePage;   // +0x14
	USHORT   LinkUsage;		  // +0x16
	union
	{
		struct
		{
			ULONG  MoreChannels : 1; // Are there more channel desc associated with
									 // this array.  This happens if there is a
									 // several usages for one main item.
			ULONG  IsConst : 1;		// Does this channel represent filler
			ULONG  IsButton : 1;	// Is this a channel of binary usages, not value usages.
			ULONG  IsAbsolute : 1;  // As apposed to relative
			ULONG  IsRange : 1;
			ULONG  IsAlias : 1;		// a usage described in a delimiter
			ULONG  IsStringRange : 1;
			ULONG  IsDesignatorRange : 1;
			ULONG  Reserved : 20;
			ULONG  NumGlobalUnknowns : 4;
		};
		ULONG  all;
	};
	struct _HIDP_UNKNOWN_TOKEN GlobalUnknowns[HIDP_MAX_UNKNOWN_ITEMS];

	union {
		struct {
			USHORT   UsageMin, UsageMax;
			USHORT   StringMin, StringMax;
			USHORT   DesignatorMin, DesignatorMax;
			USHORT   DataIndexMin, DataIndexMax;
		} Range;
		struct {
			USHORT   Usage, Reserved1;
			USHORT   StringIndex, Reserved2;
			USHORT   DesignatorIndex, Reserved3;
			USHORT   DataIndex, Reserved4;
		} NotRange;
	};

	union {
		struct {
			LONG     LogicalMin, LogicalMax;
		} button;
		struct {
			BOOLEAN  HasNull;  // Does this channel have a null report
			UCHAR    Reserved[3];
			LONG     LogicalMin, LogicalMax;
			LONG     PhysicalMin, PhysicalMax;
		} Data;
	};

	ULONG Units;
	ULONG UnitExp;
} HIDP_CHANNEL_DESC, *PHIDP_CHANNEL_DESC;

typedef struct _HIDP_SYS_POWER_INFO {
	ULONG   PowerButtonMask;

} HIDP_SYS_POWER_INFO, *PHIDP_SYS_POWER_INFO;
typedef struct _HIDP_PREPARSED_DATA
{
	LONG   Signature1, Signature2;
	USHORT Usage;
	USHORT UsagePage;

	HIDP_SYS_POWER_INFO;

	// The following channel report headers point to data within
	// the Data field below using array indices.
	struct _CHANNEL_REPORT_HEADER Input;
	struct _CHANNEL_REPORT_HEADER Output;
	struct _CHANNEL_REPORT_HEADER Feature;

	// After the CANNEL_DESC array the follows a LinkCollection array nodes.
	// LinkCollectionArrayOffset is the index given to RawBytes to find
	// the first location of the _HIDP_LINK_COLLECTION_NODE structure array
	// (index zero) and LinkCollectionArrayLength is the number of array
	// elements in that array.
	USHORT LinkCollectionArrayOffset;
	USHORT LinkCollectionArrayLength;

	union {
		HIDP_CHANNEL_DESC    Data[];
		UCHAR                RawBytes[];
	};
} HIDP_PREPARSED_DATA;
-------------------------------------------------------------------------------------------------------*/
```

`UsbMon/UsbMon/ReportUtil.c`:

```c

#include "ReportUtil.h" 
#include "WinParse.h" 

typedef struct _SELECTED_CHANNEL
{
	HIDP_CHANNEL_DESC*            channel;
	ULONG							start;
	ULONG							  end;
	CHAR				  reportType[256];
}SELETEDCHANNEL, *PSELECTEDCHANNEL;

BOOLEAN g_IsCompatibleModeReported = FALSE;
extern BOOLEAN GetKeyboardCompatibleMode();

//------------------------------------------------------------------------------------------------------------------------------//
VOID DumpReport(
	_In_ HIDP_DEVICE_DESC* report)
{
	ULONG i = 0;
	PHIDP_REPORT_IDS      reportDesc = NULL;
	PHIDP_COLLECTION_DESC collectionDesc = &report->CollectionDesc[0];
	for (i = 0; i < report->CollectionDescLength; i++)
	{
		ASSERT(collectionDesc[i].PreparsedData->Signature1 == HIDP_PREPARSED_DATA_SIGNATURE1);
		ASSERT(collectionDesc[i].PreparsedData->Signature2 == HIDP_PREPARSED_DATA_SIGNATURE2);

		USB_DEBUG_INFO_LN_EX("+++++++++++++++++++++++++++++++++++++++++++++++++++++++");
		USB_DEBUG_INFO_LN_EX("[Collection] Usage: %xh", collectionDesc[i].Usage);
		USB_DEBUG_INFO_LN_EX("[Collection] UsagePage: %xh ", collectionDesc[i].UsagePage);
		USB_DEBUG_INFO_LN_EX("[Collection] InputLength: %xh ", collectionDesc[i].InputLength);
		USB_DEBUG_INFO_LN_EX("[Collection] OutputLength: %xh ", collectionDesc[i].OutputLength);
		USB_DEBUG_INFO_LN_EX("[Collection] FeatureLength: %xh ", collectionDesc[i].FeatureLength);
		USB_DEBUG_INFO_LN_EX("[Collection] CollectionNumber: %x ", collectionDesc[i].CollectionNumber);
		USB_DEBUG_INFO_LN_EX("[Collection] PreparsedData: %I64x ", collectionDesc[i].PreparsedData);

		USB_DEBUG_INFO_LN_EX("[Collection] Input Offset: %x  Index: %x ", collectionDesc[i].PreparsedData->Input.Offset, collectionDesc[i].PreparsedData->Input.Index);
		USB_DEBUG_INFO_LN_EX("[Collection] Output Offset: %x Index: %x ", collectionDesc[i].PreparsedData->Output.Offset, collectionDesc[i].PreparsedData->Output.Index);
		USB_DEBUG_INFO_LN_EX("[Collection] Feature Offset: %x Index: %x ", collectionDesc[i].PreparsedData->Feature.Offset, collectionDesc[i].PreparsedData->Feature.Index);


		DumpChannel(&collectionDesc[i], HidP_Input, CHANNEL_DUMP_ALL);
		DumpChannel(&collectionDesc[i], HidP_Output, CHANNEL_DUMP_ALL);
		DumpChannel(&collectionDesc[i], HidP_Feature, CHANNEL_DUMP_ALL);

		USB_DEBUG_INFO_LN_EX("+++++++++++++++++++++++++++++++++++++++++++++++++++++++");
		collectionDesc++;
	}

	reportDesc = &report->ReportIDs[0];
	for (i = 0; i < report->ReportIDsLength; i++)
	{
		USB_DEBUG_INFO_LN_EX("*******************************************************");
		USB_DEBUG_INFO_LN_EX("[Report] ReportID: %xh ", reportDesc->ReportID);
		USB_DEBUG_INFO_LN_EX("[Report] InputLength: %xh ", reportDesc->InputLength);
		USB_DEBUG_INFO_LN_EX("[Report] OutputLength: %xh ", reportDesc->OutputLength);
		USB_DEBUG_INFO_LN_EX("[Report] FeatureLength: %xh ", reportDesc->FeatureLength);
		USB_DEBUG_INFO_LN_EX("[Report] CollectionNumber: %x ", reportDesc->CollectionNumber);
		USB_DEBUG_INFO_LN_EX("*******************************************************");
		reportDesc++;
	}
}

//------------------------------------------------------------------------------------------------------------------------------//
VOID DumpChannel(
	_In_ PHIDP_COLLECTION_DESC collectionDesc,
	_In_ HIDP_REPORT_TYPE type,
	_In_ ULONG Flags)
{
	ULONG k = 0;
	HIDP_CHANNEL_DESC* channel = NULL;
	ULONG start = 0;
	ULONG end = 0;
	CHAR* reportType = NULL;

	if (!collectionDesc)
	{
		return;
	}

	switch (type)
	{
	case HidP_Input:
		channel = &collectionDesc->PreparsedData->Data[collectionDesc->PreparsedData->Input.Offset];
		start = collectionDesc->PreparsedData->Input.Offset;
		end = collectionDesc->PreparsedData->Input.Index;
		reportType = "Input Report";
		break;
	case HidP_Output:
		channel = &collectionDesc->PreparsedData->Data[collectionDesc->PreparsedData->Output.Offset];
		start = collectionDesc->PreparsedData->Output.Offset;
		end = collectionDesc->PreparsedData->Output.Index;
		reportType = "Output Report";

		break;
	case HidP_Feature:
		channel = &collectionDesc->PreparsedData->Data[collectionDesc->PreparsedData->Feature.Offset];
		start = collectionDesc->PreparsedData->Feature.Offset;
		end = collectionDesc->PreparsedData->Feature.Index;
		reportType = "Feature Report";
		break;
	default:
		break;
	}

	for (k = start; k < end; k++)
	{
		USB_DEBUG_INFO_LN_EX("+++++++++++++++++++++++ %s +++++++++++++++++++++", reportType);
		if (Flags & CHANNEL_DUMP_REPORT_REALTED)
		{
			USB_DEBUG_INFO_LN_EX(" UsagePage: %x		OFFSET_FIELD: %x ", channel->UsagePage, FIELD_OFFSET(HIDP_CHANNEL_DESC, UsagePage));
			USB_DEBUG_INFO_LN_EX(" ReportID: %d		OFFSET_FIELD: %x ", channel->ReportID, FIELD_OFFSET(HIDP_CHANNEL_DESC, ReportID));
			USB_DEBUG_INFO_LN_EX(" ReportSize: %d		OFFSET_FIELD: %x ", channel->ReportSize, FIELD_OFFSET(HIDP_CHANNEL_DESC, ReportSize));
			USB_DEBUG_INFO_LN_EX(" ReportCount: %d		OFFSET_FIELD: %x ", channel->ReportCount, FIELD_OFFSET(HIDP_CHANNEL_DESC, ReportCount));
		}
		if (Flags & CHANNEL_DUMP_REPORT_BYTE_OFFSET_REALTED)
		{
			USB_DEBUG_INFO_LN_EX(" BitLength: %d		OFFSET_FIELD: %x ", channel->BitLength, FIELD_OFFSET(HIDP_CHANNEL_DESC, BitLength));
			USB_DEBUG_INFO_LN_EX(" ByteEnd: %d			OFFSET_FIELD: %x ", channel->ByteEnd, FIELD_OFFSET(HIDP_CHANNEL_DESC, ByteEnd));
			USB_DEBUG_INFO_LN_EX(" BitOffset: %d		OFFSET_FIELD: %x ", channel->BitOffset, FIELD_OFFSET(HIDP_CHANNEL_DESC, BitOffset));
			USB_DEBUG_INFO_LN_EX(" ByteOffset: %d		OFFSET_FIELD: %x ", channel->ByteOffset, FIELD_OFFSET(HIDP_CHANNEL_DESC, ByteOffset));
		}
		if (Flags & CHANNEL_DUMP_LINK_COL_RELATED)
		{
			USB_DEBUG_INFO_LN_EX(" LinkCollection: %x  OFFSET_FIELD: %x ", channel->LinkCollection, FIELD_OFFSET(HIDP_CHANNEL_DESC, LinkCollection));
			USB_DEBUG_INFO_LN_EX(" LinkUsage: %x		OFFSET_FIELD: %x ", channel->LinkUsage, FIELD_OFFSET(HIDP_CHANNEL_DESC, LinkUsage));
			USB_DEBUG_INFO_LN_EX(" LinkUsagePage: %x	OFFSET_FIELD: %x ", channel->LinkUsagePage, FIELD_OFFSET(HIDP_CHANNEL_DESC, LinkUsagePage));
		}

		if (Flags & CHANNEL_DUMP_ATTRIBUTE_RELATED)
		{
			USB_DEBUG_INFO_LN_EX(" IsRange: %x ", channel->IsRange);
			USB_DEBUG_INFO_LN_EX(" IsButton: %x   ", channel->IsButton);
			USB_DEBUG_INFO_LN_EX(" IsAbsolute: %x ", channel->IsAbsolute);
			USB_DEBUG_INFO_LN_EX(" IsConst: %x ", channel->IsConst);
			USB_DEBUG_INFO_LN_EX(" IsAlias: %x ", channel->IsAlias);
			USB_DEBUG_INFO_LN_EX(" IsDesignatorRange: %x ", channel->IsDesignatorRange);
			USB_DEBUG_INFO_LN_EX(" IsStringRange: %x ", channel->IsStringRange);


			if (!channel->IsButton)
			{
				USB_DEBUG_INFO_LN_EX(" Data.LogicalMin: %d	 OFFSET_FIELD: %X ", channel->Data.HasNull, FIELD_OFFSET(HIDP_CHANNEL_DESC, Data.HasNull));
				USB_DEBUG_INFO_LN_EX(" Data.LogicalMin: %d	 OFFSET_FIELD: %X ", channel->Data.LogicalMax, FIELD_OFFSET(HIDP_CHANNEL_DESC, Data.LogicalMin));
				USB_DEBUG_INFO_LN_EX(" Data.LogicalMax: %d	 OFFSET_FIELD: %X ", channel->Data.LogicalMin, FIELD_OFFSET(HIDP_CHANNEL_DESC, Data.LogicalMax));
				USB_DEBUG_INFO_LN_EX(" Data.PhysicalMax: %d OFFSET_FIELD: %X  ", channel->Data.PhysicalMin, FIELD_OFFSET(HIDP_CHANNEL_DESC, Data.PhysicalMin));
				USB_DEBUG_INFO_LN_EX(" Data.PhysicalMax: %d OFFSET_FIELD: %X  ", channel->Data.PhysicalMax, FIELD_OFFSET(HIDP_CHANNEL_DESC, Data.PhysicalMax));
			}
			if (channel->IsButton)
			{
				USB_DEBUG_INFO_LN_EX(" button.LogicalMin %d OFFSET_FIELD: %X  ", channel->button.LogicalMin, FIELD_OFFSET(HIDP_CHANNEL_DESC, button.LogicalMin));
				USB_DEBUG_INFO_LN_EX(" button.LogicalMax %d OFFSET_FIELD: %X  ", channel->button.LogicalMax, FIELD_OFFSET(HIDP_CHANNEL_DESC, button.LogicalMax));
			}

			if (channel->MoreChannels) {
				USB_DEBUG_INFO_LN_EX("MoreChannels ");
			}
			if (channel->IsConst) {
				USB_DEBUG_INFO_LN_EX("Const ");
			}
			if (channel->IsButton) {
				USB_DEBUG_INFO_LN_EX("Button ");
			}
			else {
				USB_DEBUG_INFO_LN_EX("Value ");
			}
			if (channel->IsAbsolute) {
				USB_DEBUG_INFO_LN_EX("Absolute ");
			}
			if (channel->IsAlias) {
				USB_DEBUG_INFO_LN_EX("ALIAS! ");
			}
		}

		//USB_DEBUG_INFO_LN();

		if (Flags & CHANNEL_DUMP_RANGE_RELATED)
		{
			if (channel->IsRange)
			{
				USB_DEBUG_INFO_LN_EX(" Range.UsageMin:  %d		   OFFSET_FIELD: %X  ", channel->Range.UsageMin, FIELD_OFFSET(HIDP_CHANNEL_DESC, Range.UsageMin));
				USB_DEBUG_INFO_LN_EX(" Range.UsageMax:  %d		   OFFSET_FIELD: %X  ", channel->Range.UsageMax, FIELD_OFFSET(HIDP_CHANNEL_DESC, Range.UsageMax));
				USB_DEBUG_INFO_LN_EX(" Range.DataIndexMax:  %d	   OFFSET_FIELD: %X  ", channel->Range.DataIndexMax, FIELD_OFFSET(HIDP_CHANNEL_DESC, Range.DataIndexMax));
				USB_DEBUG_INFO_LN_EX(" Range.DataIndexMin: %d	   OFFSET_FIELD: %X  ", channel->Range.DataIndexMin, FIELD_OFFSET(HIDP_CHANNEL_DESC, Range.DataIndexMin));
			}
			else
			{
				USB_DEBUG_INFO_LN_EX(" NotRange.Usage:  %x		     OFFSET_FIELD: %X  ", channel->NotRange.Usage, FIELD_OFFSET(HIDP_CHANNEL_DESC, NotRange.Usage));
				USB_DEBUG_INFO_LN_EX(" NotRange.DataIndex:  %x		 OFFSET_FIELD: %X  ", channel->NotRange.DataIndex, FIELD_OFFSET(HIDP_CHANNEL_DESC, NotRange.DataIndex));
			}

			if (channel->IsDesignatorRange)
			{
				USB_DEBUG_INFO_LN_EX(" Range.DesignatorMax: %d OFFSET_FIELD: %X  ", channel->Range.DesignatorMax, FIELD_OFFSET(HIDP_CHANNEL_DESC, Range.DesignatorMax));
				USB_DEBUG_INFO_LN_EX(" Range.DesignatorMin: %d OFFSET_FIELD: %X  ", channel->Range.DesignatorMin, FIELD_OFFSET(HIDP_CHANNEL_DESC, Range.DesignatorMin));
			}
			else
			{
				USB_DEBUG_INFO_LN_EX(" Range.DesignatorMax: %d OFFSET_FIELD: %X  ", channel->NotRange.DesignatorIndex, FIELD_OFFSET(HIDP_CHANNEL_DESC, NotRange.DesignatorIndex));
			}

			if (channel->IsStringRange)
			{
				USB_DEBUG_INFO_LN_EX(" Range.StringMax: %d	   OFFSET_FIELD: %X  ", channel->Range.StringMax, FIELD_OFFSET(HIDP_CHANNEL_DESC, Range.StringMax));
				USB_DEBUG_INFO_LN_EX(" Range.StringMin: %d	   OFFSET_FIELD: %X  ", channel->Range.StringMin, FIELD_OFFSET(HIDP_CHANNEL_DESC, Range.StringMin));
			}
			else
			{
				USB_DEBUG_INFO_LN_EX(" NotRange.StringIndex:  %d	 OFFSET_FIELD: %X  ", channel->NotRange.StringIndex, FIELD_OFFSET(HIDP_CHANNEL_DESC, NotRange.StringIndex));
			}
		}

		if (channel->NumGlobalUnknowns)
		{
			ULONG z = 0;
			for (z = 0; z < channel->NumGlobalUnknowns; z++)
			{
				USB_DEBUG_INFO_LN_EX(" UnknownsToken:  %d	 OFFSET_FIELD: %X  ", channel->GlobalUnknowns[z].Token, FIELD_OFFSET(HIDP_CHANNEL_DESC, GlobalUnknowns));
			}
		}

		//USB_DEBUG_INFO_LN();

		channel++;
	}
}

//---------------------------------------------------------------------------------------------
NTSTATUS AllocateExtractData(
	_Inout_  PEXTRACTDATA* ExtractedData)
{
	NTSTATUS status = STATUS_UNSUCCESSFUL;

	if (!ExtractedData)
	{
		return status;
	}

	*ExtractedData = (EXTRACTDATA*)ExAllocatePoolWithTag(NonPagedPoolMustSucceed, sizeof(EXTRACTDATA), 'exdt');
	if (!*ExtractedData)
	{
		return status;
	}
	RtlZeroMemory(*ExtractedData, sizeof(EXTRACTDATA));
	status = STATUS_SUCCESS;
	return status;
}

//------------------------------------------------------------------------------------------------------------------------------//
NTSTATUS SelectChannel(
	_In_ HIDP_REPORT_TYPE				type,
	_In_ PHIDP_COLLECTION_DESC	collectionDesc,
	_Out_ SELETEDCHANNEL*       selectedChannel
)
{
	NTSTATUS status = STATUS_UNSUCCESSFUL;
	if (!collectionDesc || !selectedChannel)
	{
		return status;
	}
	switch (type)
	{
	case HidP_Input:
		selectedChannel->channel = &collectionDesc->PreparsedData->Data[collectionDesc->PreparsedData->Input.Offset];
		selectedChannel->start = collectionDesc->PreparsedData->Input.Offset;
		selectedChannel->end = collectionDesc->PreparsedData->Input.Index;
		strncpy(selectedChannel->reportType, "Input Report", sizeof("Input Report"));
		break;
	case HidP_Output:
		selectedChannel->channel = &collectionDesc->PreparsedData->Data[collectionDesc->PreparsedData->Output.Offset];
		selectedChannel->start = collectionDesc->PreparsedData->Output.Offset;
		selectedChannel->end = collectionDesc->PreparsedData->Output.Index;
		strncpy(selectedChannel->reportType, "Output Report", sizeof("Output Report"));
		break;
	case HidP_Feature:
		selectedChannel->channel = &collectionDesc->PreparsedData->Data[collectionDesc->PreparsedData->Feature.Offset];
		selectedChannel->start = collectionDesc->PreparsedData->Feature.Offset;
		selectedChannel->end = collectionDesc->PreparsedData->Feature.Index;
		strncpy(selectedChannel->reportType, "Feature Report", sizeof("Feature Report"));
		break;
	default:
		break;
	}
	status = STATUS_SUCCESS;
	return status;
}

//------------------------------------------------------------------------------------------------------------------------------//
NTSTATUS ExtractKeyboardData(
	_In_	 PHIDP_COLLECTION_DESC collectionDesc,
	_In_	 HIDP_REPORT_TYPE type,
	_Inout_  EXTRACTDATA* ExtractedData)
{
	HIDP_CHANNEL_DESC*            channel = NULL;
	SELETEDCHANNEL			     selected_channel = { 0 };
	NTSTATUS status = STATUS_SUCCESS;
	ULONG k = 0;
	if (!collectionDesc || !ExtractedData)
	{
		status = STATUS_UNSUCCESSFUL;
		return status;
	}

	SelectChannel(type, collectionDesc, &selected_channel);

	USB_DEBUG_INFO_LN_EX("Start: %x End: %x ReportType: %s", selected_channel.start, selected_channel.end, selected_channel.reportType);

	channel = selected_channel.channel;
	for (k = selected_channel.start; k < selected_channel.end; k++)
	{
		USB_DEBUG_INFO_LN_EX("###$ UsagePage: %d Max : %d Min: %d ", channel->UsagePage, channel->Range.UsageMax, channel->Range.UsageMin);
		switch (channel->UsagePage)
		{
		case HID_KEYBOARD_OR_KEYPAD:
		{
			if (channel->button.LogicalMin == 0 && channel->button.LogicalMax == 255)
			{
				ExtractedData->KBDDATA.NormalKeyByteOffset = channel->ByteOffset - 1;
				ExtractedData->KBDDATA.NormalKeyBitOffset = channel->BitOffset;
				ExtractedData->KBDDATA.NormalKeySize = channel->BitLength;
				ExtractedData->KBDDATA.ReportId = channel->ReportID;
				if (channel->ReportID)
				{
					ExtractedData->KBDDATA.NormalKeyByteOffset++;
				}
				USB_DEBUG_INFO_LN_EX("###$Normal key Offset: %X", ExtractedData->KBDDATA.NormalKeyByteOffset);
			}
			else if (channel->Range.UsageMax == 231 && channel->Range.UsageMin == 224)
			{
				ExtractedData->KBDDATA.SpecialKeyByteOffset = channel->ByteOffset - 1;
				ExtractedData->KBDDATA.SpecialKeyBitOffset = channel->BitOffset;
				ExtractedData->KBDDATA.SpecialKeySize = channel->BitLength;
				if (channel->ReportID)
				{
					ExtractedData->KBDDATA.SpecialKeyByteOffset++;
				}
				USB_DEBUG_INFO_LN_EX("###$Special key Offset: %X", ExtractedData->KBDDATA.SpecialKeyByteOffset);
			}
			else
			{
				if (!ExtractedData->KBDDATA.NormalKeyByteOffset && GetKeyboardCompatibleMode())
				{
					ExtractedData->KBDDATA.NormalKeyByteOffset = channel->ByteOffset - 1;
					ExtractedData->KBDDATA.NormalKeyBitOffset = channel->BitOffset;
					ExtractedData->KBDDATA.NormalKeySize = channel->BitLength;
					ExtractedData->KBDDATA.ReportId = channel->ReportID;
					if (channel->ReportID)
					{
						ExtractedData->KBDDATA.NormalKeyByteOffset++;
					}
					if (!g_IsCompatibleModeReported)
					{
						g_IsCompatibleModeReported = TRUE;
					}
					USB_DEBUG_INFO_LN_EX("###Compatible Mode Is On ");
				}
			}
		}
		break;
		default:
			USB_MON_COMMON_DBG_BREAK();
			break;
		}
		channel++;
	}

#ifdef DBG	
	DumpChannel(collectionDesc, type, CHANNEL_DUMP_ATTRIBUTE_RELATED | CHANNEL_DUMP_RANGE_RELATED);
#endif

	return status;
}

//------------------------------------------------------------------------------------------------------------------------------//
NTSTATUS ExtractMouseData(
	_In_	 PHIDP_COLLECTION_DESC collectionDesc,
	_In_	 HIDP_REPORT_TYPE type,
	_Inout_  EXTRACTDATA* ExtractedData)
{
	HIDP_CHANNEL_DESC*            channel = NULL;
	SELETEDCHANNEL			     selected_channel = { 0 };
	NTSTATUS status = STATUS_SUCCESS;
	ULONG k = 0;
	ULONG btnIndex = 0;
	if (!collectionDesc || !ExtractedData)
	{
		status = STATUS_UNSUCCESSFUL;
		return status;
	}

	if (!NT_SUCCESS(SelectChannel(type, collectionDesc, &selected_channel)))
	{
		status = STATUS_UNSUCCESSFUL;
		return status;
	}

	USB_DEBUG_INFO_LN_EX("Start: %x End: %x ReportType: %s", selected_channel.start, selected_channel.end, selected_channel.reportType);

	channel = selected_channel.channel;
	for (k = selected_channel.start; k < selected_channel.end; k++)
	{
		if (channel->IsButton)
		{
			//skip if more than one set button (binary set)
			if (btnIndex >= 2)
			{
				channel++;
				continue;
			}

			if (channel->IsRange)
			{
				ExtractedData->MOUDATA.BtnDescriptor.ByteOffsetBtn[btnIndex] = channel->ByteOffset - 1;
				ExtractedData->MOUDATA.BtnDescriptor.BitOffsetBtn[btnIndex] = channel->BitOffset;
				ExtractedData->MOUDATA.BtnDescriptor.BtnOffsetSize[btnIndex] = channel->BitLength;
				ExtractedData->MOUDATA.ReportIdDesc[0].Usage = channel->UsagePage; 	//Diff from X/Y/Z Usage , it is usage page.
				ExtractedData->MOUDATA.ReportIdDesc[0].ReportId = channel->ReportID;
				// Compatible for those report with id or without id 
				if (channel->ReportID)
				{
					ExtractedData->MOUDATA.BtnDescriptor.ByteOffsetBtn[btnIndex]++;
				}

				ExtractedData->MOUDATA.BtnDescriptor.BtnUsageMin[btnIndex] = channel->Range.UsageMin;
			}
			btnIndex++;
		}
		else // not a btn means it is data.
		{
			// Not a range data 
			if (!channel->IsRange)
			{
				//Meaning X , Y, Z
				switch (channel->NotRange.Usage)
				{
				case HID_NOT_RANGE_USAGE_X:		 //coordinate - X  
					ExtractedData->MOUDATA.X_Descriptor.ByteOffset = channel->ByteOffset - 1;
					ExtractedData->MOUDATA.X_Descriptor.BitOffset = channel->BitOffset; //(channel->ByteOffset - 1) * 8 +channel->BitOffset;
					ExtractedData->MOUDATA.X_Descriptor.OffsetSize = channel->BitLength; //channel->ByteEnd - channel->ByteOffset; 
					ExtractedData->MOUDATA.IsAbsolute = channel->IsAbsolute;
					ExtractedData->MOUDATA.ReportIdDesc[1].Usage = channel->NotRange.Usage;
					ExtractedData->MOUDATA.ReportIdDesc[1].ReportId = channel->ReportID;
					if (channel->ReportID)
					{
						ExtractedData->MOUDATA.X_Descriptor.ByteOffset++;
					}
					break;
				case HID_NOT_RANGE_USAGE_Y:		 //coordinate - Y
					ExtractedData->MOUDATA.Y_Descriptor.ByteOffset = channel->ByteOffset - 1;
					ExtractedData->MOUDATA.Y_Descriptor.BitOffset = channel->BitOffset; //	ExtractedData->MOUDATA.BitOffsetY  = (channel->ByteOffset - 1) * 8 +channel->BitOffset; 
					ExtractedData->MOUDATA.Y_Descriptor.OffsetSize = channel->BitLength; //channel->ByteEnd - channel->ByteOffset;  
					ExtractedData->MOUDATA.IsAbsolute = channel->IsAbsolute;
					ExtractedData->MOUDATA.ReportIdDesc[2].Usage = channel->NotRange.Usage;
					ExtractedData->MOUDATA.ReportIdDesc[2].ReportId = channel->ReportID;
					if (channel->ReportID)
					{
						ExtractedData->MOUDATA.Y_Descriptor.ByteOffset++;
					}
					break;
				case HID_NOT_RANGE_USAGE_WHELL:  //coordinate - Z
					ExtractedData->MOUDATA.Z_Descriptor.ByteOffset = channel->ByteOffset - 1;
					ExtractedData->MOUDATA.Z_Descriptor.BitOffset = channel->BitOffset; //	ExtractedData->MOUDATA.BitOffsetY  = (channel->ByteOffset - 1) * 8 +channel->BitOffset;  
					ExtractedData->MOUDATA.Z_Descriptor.OffsetSize = channel->BitLength; //channel->ByteEnd - channel->ByteOffset; 
					ExtractedData->MOUDATA.ReportIdDesc[3].Usage = channel->NotRange.Usage;
					ExtractedData->MOUDATA.ReportIdDesc[3].ReportId = channel->ReportID;
					if (channel->ReportID)
					{
						ExtractedData->MOUDATA.Z_Descriptor.ByteOffset++;
					}
					break;
				default:
					//USB_MON_COMMON_DBG_BREAK();	//FATAL ! Ignore it
					break;
				}


			}
		}

		channel++;
	}

	return status;
}
```

`UsbMon/UsbMon/ReportUtil.h`:

```h
#ifndef __REPORT_UTIL_HEARER__
#define __REPORT_UTIL_HEADER__


#include <ntddk.h> 
#include "CommonUtil.h"
#include "UsbType.h"

#define DUMP_INPUT_REPORT_FLAG   1
#define DUMP_OUTPUT_REPORT_FLAG  2
#define DUMP_FEATURE_REPORT_FLAG 4  

//usage page-id
//-------------------------------------------// 
#define HID_GENERIC_DESKTOP_PAGE		0x1
#define HID_SIMULATION_CONTROL		0x2
#define HID_VR_CONTROL				0x3 
#define HID_SPORT_CONTROL			0x4
#define HID_GAME_CONTROL			0x5
#define HID_GENERIC_DEVICE_CONTROL	0x6
#define HID_KEYBOARD_OR_KEYPAD		0x7
#define HID_LEDS						0x8
#define HID_BUTTON					0x9
#define HID_ORIDINAL					0xA
#define HID_TELEPHONY				0xB
#define HID_CONSUMER				0xC
#define HID_DIGITILZER					0xD
#define HID_RESERVED					0xE
#define HID_PID_PAGE					0xF
#define HID_UNICODE					0x10
#define HID_RESERVED1				0x11
#define HID_RESERVED2				0x12
#define HID_RESERVED3				0x13
#define HID_ALPHA_DISPLAY				0x14 
#define HID_MEDICAL_INSTR				0x40
#define HID_MONITOR_PAGES			0x80
#define HID_MONITOR_PAGES1			0x81
#define HID_MONITOR_PAGES2			0x82 
#define HID_MONITOR_PAGES3			0x83 
#define HID_POWER_PAGES1			0x84
#define HID_POWER_PAGES2			0x85
#define HID_POWER_PAGES3			0x86
#define HID_POWER_PAGES4			0x87 
#define HID_BARCODE_SCANNER			0x8C
#define HID_SCALE_PAGE				0x8D 
#define HID_RESEVRED_POS_PAGE		0x8F
#define HID_CAMERA_PAGE				0x90
#define HID_ARCADE_PAGE				0x91
#define HID_MAX_PAGE				HID_ARCADE_PAGE
//-------------------------------------------//


//There is a sub-usage id For HID_GENERIC_DESKTOP_PAGE
//-------------------------------------------//
#define HID_POINTER_USAGE	       0x1
#define HID_MOU_USAGE		       0x2
#define HID_RESERVED_USAGE	       0x3
#define HID_JOYSTICK_USAGE	       0x4
#define HID_GAMEPAD_USAGE	       0x5  
#define HID_KBD_USAGE		       0x6
#define HID_KBYPAD_USAGE	       0x7
#define HID_LED_USAGE		       0x8
#define HID_MULTI_AXIS_USAGE	   0x9 

//0xA-0x2f reserved 
#define HID_NOT_RANGE_USAGE_X	  0x30
#define HID_NOT_RANGE_USAGE_Y	  0x31
#define HID_NOT_RANGE_USAGE_Z	  0x32 

#define HID_NOT_RANGE_USAGE_RX	  0x33
#define HID_NOT_RANGE_USAGE_RY	  0x34
#define HID_NOT_RANGE_USAGE_RZ	  0x35 

#define HID_USAGE_SLIDER		  0x36 
#define HID_USAGE_DIAL			  0x37 
#define HID_NOT_RANGE_USAGE_WHELL 0x38  
 
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

			pContext 	- HIJACK_CONTEXT for allocation.
			reportType	- specify which report typ
Arguments:
			report	- structure of HIDP_DEVICE_DESC, it saved all report, 
					  we dump it all

Return Value: 
			No 
-----------------------------------------------------------------------------------*/
NTSTATUS 
AllocateExtractData(
	PEXTRACTDATA* Data
);
	
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

			ExtractKeyboardData
			 
Arguments:
			collectionDesc	- Which collection should be extracted
			type			- which report type
			ExtractedData   - EXTRACTDATA* result
Return Value: 
			STATUS_SUCCESS		- Fetch SUCCESS
			STATUS_UNSUCESSFUL	- Fetch FAIL
-----------------------------------------------------------------------------------*/
NTSTATUS
ExtractKeyboardData(
	_In_	 PHIDP_COLLECTION_DESC collectionDesc,
	_In_	 HIDP_REPORT_TYPE type,
	_Inout_  EXTRACTDATA* ExtractedData
);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

			ExtractKeyboardData
			 
Arguments:
			collectionDesc	- Which collection should be extracted
			type			- which report type
			ExtractedData   - EXTRACTDATA* result
Return Value: 
			STATUS_SUCCESS		- Fetch SUCCESS
			STATUS_UNSUCESSFUL	- Fetch FAIL
-----------------------------------------------------------------------------------*/
NTSTATUS
ExtractMouseData(
	PHIDP_COLLECTION_DESC collectionDesc,
	HIDP_REPORT_TYPE type,
	EXTRACTDATA* ExtractedData
);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

			DumpReport
			 
Arguments:
			report	- structure of HIDP_DEVICE_DESC, it saved all report, 
					  we dump it all

Return Value: 
			No 
-----------------------------------------------------------------------------------*/
VOID 
DumpReport(
	HIDP_DEVICE_DESC* report
);





/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

			DumpChannel


Arguments:
			collectionDesc - Collection Description , it saved all channel. a channel
							 respect to the Usage in report descriptor 

			type		   - what report type of channel to be dumped

			Flags		   - which part of channel need to be dumped

Return Value: 
			No

-----------------------------------------------------------------------------------*/
VOID 
DumpChannel(
	PHIDP_COLLECTION_DESC collectionDesc, 
	HIDP_REPORT_TYPE type, 
	ULONG Flags
);

#endif
```

`UsbMon/UsbMon/TList.c`:

```c
#include "TList.h"
 

#ifndef PAGE_SIZE
#define PAGE_SIZE  4096
#endif

void EntryListLock(PChainListHeader List);
void LeaveListLock(PChainListHeader List);
void FreeListCell(PChainListHeader List,PListCell Cell);
ULONG OnRefListCell(PChainListHeader List,PListCell Cell);
ULONG OnDefListCell(PChainListHeader List,PListCell Cell);

//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////
//------------------------------------------------------------------------------
PChainListHeader NewChainListHeaderEx(ULONG Flag,TChainLisActionCallback  ChainLisActionCallback,ULONG ReferenceOffSet)
{
	PChainListHeader List;
	ULONG       mmLen;
	
	mmLen=sizeof(TChainListHeader)-sizeof(TListCellBlock)+sizeof(TListCell)*16;
	mmLen=mmLen+((PAGE_SIZE-(mmLen%PAGE_SIZE))%PAGE_SIZE);
	
	List=(PChainListHeader)ExAllocatePoolWithTag(NonPagedPool,mmLen,'MMGR');
	if(List)
	{
		PListCellBlock BlockHeader;
		ULONG					 i;
			
		memset(List,0,PAGE_SIZE);
		
		List->Version=1;
		List->Flag=Flag;
		List->Count=0;
		List->g_IrpHookList=NULL;
		List->BlockHeader=NULL;
		List->ChainLisActionCallback=ChainLisActionCallback;
		List->LockType=Flag&MASKFLAG_LOCK;
		List->ReferenceOffSet=ReferenceOffSet;
		List->RefCount=0;
		
		InterlockedExchange(&List->RefCount,0);
		

		BlockHeader=(PListCellBlock)((PCHAR)List+sizeof(TChainListHeader));
		BlockHeader->Flag=LISTBLOCK_NOTFREE;
		BlockHeader->Next=BlockHeader;
		BlockHeader->Prev=BlockHeader;
		BlockHeader->MaxCount=((mmLen-sizeof(TChainListHeader)-sizeof(TListCellBlock))/sizeof(TListCell))+1;
		BlockHeader->Count=1;	
		
		List->BlockHeader=BlockHeader;
		
		if(List->LockType==LISTFLAG_SPINLOCK)
		{
			KeInitializeSpinLock(&List->SpinLock);
		}
		else if(List->LockType==LISTFLAG_FTMUTEXLOCK)
		{
			ExInitializeFastMutex(&List->FastMutex);
		}
		else if(List->LockType==LISTFLAG_NLMUTEXLOCK)
		{
			KeInitializeMutex(&List->Mutex,0);
		}
		
		List->g_IrpHookList=&BlockHeader->ListCell[0];
		List->g_IrpHookList->Next=List->g_IrpHookList;
		List->g_IrpHookList->Prev=List->g_IrpHookList;
	}

	return List;
}
//------------------------------------------------------------------------------
PChainListHeader NewChainListHeader()
{
		return NewChainListHeaderEx(LISTFLAG_SPINLOCK,NULL,0);
}
//------------------------------------------------------------------------------
void  FreeChainListHeader(PChainListHeader List)
{
	if(List)
	{
			PListCellBlock  BlockHeader,bDelBlock;
			PListCell		g_IrpHookList,ListCell,beDelCell;
			
			EntryListLock(List);
			
			g_IrpHookList=List->g_IrpHookList;
			ListCell=g_IrpHookList->Next;
			
			while(ListCell!=g_IrpHookList)
			{
	            beDelCell=ListCell;
	            ListCell=ListCell->Next;
				OnDefListCell(List,beDelCell);
	            FreeListCell(List,beDelCell);
			}
			
			BlockHeader=List->BlockHeader;
			for(;;)
			{
       			bDelBlock=BlockHeader;
      		 	BlockHeader=BlockHeader->Next;
				if(!(bDelBlock->Flag&LISTBLOCK_NOTFREE))
				{
						ExFreePool(bDelBlock);
				}
				if(BlockHeader==List->BlockHeader)
				{
					break;
				}
			}
			LeaveListLock(List);
			
			ExFreePool(List);
	}
	return;
}
//------------------------------------------------------------------------------
static void  EntryListLock(PChainListHeader List)
{

	if(List->LockType==LISTFLAG_SPINLOCK)
	{
		KeAcquireSpinLock(&List->SpinLock,&List->Irql);	
	}
	else if(List->LockType==LISTFLAG_FTMUTEXLOCK)
	{
		ExAcquireFastMutex(&List->FastMutex);
	}
	else if(List->LockType==LISTFLAG_NLMUTEXLOCK)
	{
		KeWaitForSingleObject(&List->Mutex,Executive,KernelMode,FALSE,NULL);
	}
	else if(List->LockType==LISTFLAG_LOCKCALLBCK)
	{
		List->ChainLisActionCallback(List,CLIST_ACTION_LOCKENTRY);
	}
	
	if(InterlockedIncrement(&List->RefCount)>1)
	{
		//说明访问链表没有做同步
		//暂时去掉，如果使用外边读写锁，是会有问题的
		//KeBugCheckEx(BUGCHECK_MODULEID_COMMM,CHAINLIST_LOCKERROR_REF,0,0,0);
		
	}
	
}
//------------------------------------------------------------------------------
static  void LeaveListLock(PChainListHeader List)
{
	if(InterlockedDecrement(&List->RefCount)<0)
	{
		//暂时去掉，如果使用外边读写锁，是会有问题的
		//KeBugCheckEx(BUGCHECK_MODULEID_COMMM,CHAINLIST_LOCKERROR_DEF,0,0,0);
	}
	
	if(List->LockType==LISTFLAG_SPINLOCK)
	{
		KeReleaseSpinLock(&List->SpinLock,List->Irql);
	}
	else if(List->LockType==LISTFLAG_FTMUTEXLOCK)
	{
		ExReleaseFastMutex(&List->FastMutex);
	}
	else if(List->LockType==LISTFLAG_NLMUTEXLOCK)
	{
		KeReleaseMutex(&List->Mutex,FALSE);
	}
	else if(List->LockType==LISTFLAG_LOCKCALLBCK)
	{
		List->ChainLisActionCallback(List,CLIST_ACTION_LOCKLEAVE);
	}
	
}
//------------------------------------------------------------------------------
static void AddToListComm(PListComm S,PListComm D)
{
	D->Next=S;
	D->Prev=S->Prev;
	
	S->Prev->Next=D;
	S->Prev=D;
}
//------------------------------------------------------------------------------
static void InsertToListComm(PListComm S,PListComm D)
{
    D->Next=S;
    D->Prev=S->Prev;

    S->Prev->Next=D;
    S->Prev=D;
}
//------------------------------------------------------------------------------
static void DelListComm(PListComm D)
{
	D->Prev->Next=D->Next;
	D->Next->Prev=D->Prev;
	
	D->Next=NULL;
	D->Prev=NULL;
}
//------------------------------------------------------------------------------
static PListCell AllocListCell(PChainListHeader List)
{
	PListCellBlock BlockHeader;
	PListCell			 ListCell;
	PListCell			 Ret=NULL;
	ULONG					 i;
	
	BlockHeader=List->BlockHeader;
	for(;;)
	{
		if(BlockHeader->Count<BlockHeader->MaxCount)
		{
				ListCell=BlockHeader->ListCell;
				for(i=0;i<BlockHeader->MaxCount;i++)
				{
						if(ListCell[i].Next==NULL&&ListCell[i].Prev==NULL)
						{
								break;
						}
				}
				if(i<BlockHeader->MaxCount)
				{
					BlockHeader->Count++;
					Ret=&ListCell[i];
				}
		}
		BlockHeader=BlockHeader->Next;
		if(BlockHeader==List->BlockHeader)
		{
			break;
		}
		
	}
	if(!Ret)
	{
		BlockHeader=(PListCellBlock)ExAllocatePoolWithTag(NonPagedPool,PAGE_SIZE,'MMGR');
		if(BlockHeader)
		{
				memset(BlockHeader,0,sizeof(TListCellBlock));
				BlockHeader->Flag=0;
				BlockHeader->MaxCount=((PAGE_SIZE-sizeof(TListCellBlock))/sizeof(TListCell))+1;
				BlockHeader->Count=1;
				AddToListComm((PListComm)List->BlockHeader,(PListComm)BlockHeader);
				Ret=&BlockHeader->ListCell[0];
		}
	}
	return Ret;
}
//------------------------------------------------------------------------------
static void FreeListCell(PChainListHeader List,PListCell Cell)
{
	PListCellBlock  BlockHeader;
	PListCell		Ret=NULL;
	ULONG			i;
	
	BlockHeader=List->BlockHeader;
	while(TRUE)
	{
		if(BlockHeader->Count&&Cell>=BlockHeader->ListCell&&Cell<BlockHeader->ListCell+BlockHeader->MaxCount)
		{
			if(!(List->Flag&LISTFLAG_REF))
			{
				if(List->ChainLisActionCallback)
				{
					List->ChainLisActionCallback(Cell->Pointer,CLIST_ACTION_FREE);
				}
				else if(Cell->Pointer&&(List->Flag&LISTFLAG_AUTOFREE))
		 		{
		 			ExFreePool(Cell->Pointer);
		 		}
	 		}
	 		
			Cell->Next=NULL;
			Cell->Prev=NULL;
			Cell->Pointer=NULL;
			BlockHeader->Count--;
			
			if(BlockHeader->Count==0&&(!(BlockHeader->Flag&LISTBLOCK_NOTFREE)))
			{
					DelListComm((PListComm)BlockHeader);
					ExFreePool(BlockHeader);
					BlockHeader=NULL;
			}
			break;
		}
		
		BlockHeader=BlockHeader->Next;
		if(BlockHeader==List->BlockHeader)
		{
			break;
		}
	}
	return;
}
//------------------------------------------------------------------------------
static PListCell GetListCellByIndex(PChainListHeader List,ULONG Index)
{
	ULONG i;
	PListCell Cell=List->g_IrpHookList;
	for(i=0;;i++)
	{
			Cell=Cell->Next;
			if(Cell==List->g_IrpHookList)
			{
				Cell=NULL;
				break;
			}
			if(i>=Index)
			{
				break;
			}
	}
	return Cell;
} 
//------------------------------------------------------------------------------
static PListCell GetListCellByData(PChainListHeader List,void* Data)
{
	ULONG i;
	PListCell Cell=List->g_IrpHookList;
	for(i=0;;i++)
	{
		Cell=Cell->Next;
		if(Cell==List->g_IrpHookList)
		{
			Cell=NULL;
			break;
		}
		if(Cell->Pointer==Data)
		{
			break;
		}
	}
	return Cell;
} 
//------------------------------------------------------------------------------
static ULONG IniRefListCell(PChainListHeader List,PListCell Cell)
{
	if(List->Flag&LISTFLAG_REF)
	{
		long Ret=InterlockedExchange((PLONG)((char*)Cell->Pointer+List->ReferenceOffSet),1);
		List->ChainLisActionCallback(Cell->Pointer,CLIST_ACTION_REF);
		return Ret;
	}
	return 0;
}
//------------------------------------------------------------------------------
static ULONG OnRefListCell(PChainListHeader List,PListCell Cell)
{
	if(List->Flag&LISTFLAG_REF)
	{
		long Ret=InterlockedIncrement((PLONG)((char*)Cell->Pointer+List->ReferenceOffSet));
		List->ChainLisActionCallback(Cell->Pointer,CLIST_ACTION_REF);
		return Ret;
	}
	return 0;
}
//------------------------------------------------------------------------------
static ULONG OnDefListCell(PChainListHeader List,PListCell Cell)
{
	if(List->Flag&LISTFLAG_REF)
	{
		long Ret=(long)InterlockedDecrement((PLONG)((char*)Cell->Pointer+List->ReferenceOffSet));
		List->ChainLisActionCallback(Cell->Pointer,CLIST_ACTION_DEF);
		if(Ret<0)
		{
			DbgPrint("OnDefListCell Error\n");
		}
		if(Ret==0)
		{
			List->ChainLisActionCallback(Cell->Pointer,CLIST_ACTION_FREE);
			Cell->Pointer=NULL;
		}
		return Ret;
	}
	return 1;
}
//------------------------------------------------------------------------------
static void DelAndFreeListCell(PChainListHeader List,PListCell Cell)
{
	  DelListComm((PListComm)Cell);
	  OnDefListCell(List,Cell);
	  FreeListCell(List,Cell);
}
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////
//------------------------------------------------------------------------------
BOOLEAN AddToChainListTail(PChainListHeader List,void* Data)
{
	PListCell Cell;
	BOOLEAN 	Ret=FALSE;
	if(!List)
	{
			return FALSE;
	}
	EntryListLock(List);
	Cell=AllocListCell(List);
	if(Cell)
	{
			Cell->Pointer=Data;
			AddToListComm((PListComm)List->g_IrpHookList,(PListComm)Cell);
			IniRefListCell(List,Cell);
			List->Count++;
			Ret=TRUE;
	}
	LeaveListLock(List);	
	return Ret;
}
//------------------------------------------------------------------------------
BOOLEAN InsertToChainList(PChainListHeader List,ULONG Index,void* Data)
{
	PListCell Cell,Header;
	BOOLEAN Ret=FALSE;
	if(!List)
	{
			return FALSE;
	}
	EntryListLock(List);
	Header=GetListCellByIndex(List,Index);
	Cell=AllocListCell(List);
	if(Cell)
	{
		Cell->Pointer=Data;
	    if(!Header)
	    {
	            AddToListComm((PListComm)List->g_IrpHookList,(PListComm)Cell);
	    }
	    else
	    {
	            InsertToListComm((PListComm)Header,(PListComm)Cell);
	    }
	    IniRefListCell(List,Cell);

		List->Count++;
		Ret=TRUE;
	}
	LeaveListLock(List);
	return Ret;
}
//------------------------------------------------------------------------------
BOOLEAN  DelFromChainListByPointer(PChainListHeader List,void* Data)
{
	PListCell Cell,Header;
	BOOLEAN Ret=FALSE;

	if(!List)
	{
		return Ret;
	}

	EntryListLock(List);
	Header=List->g_IrpHookList;
	for(Cell=Header->Next;Cell!=Header;Cell=Cell->Next)
	{
		 if(Cell->Pointer==Data)
		 {
		 		DelAndFreeListCell(List,Cell);

		 		List->Count--;

		 		Ret=TRUE;
		 		break;
		 }
	}
	LeaveListLock(List);
	return Ret;
}
//------------------------------------------------------------------------------
BOOLEAN  DelFromChainListByIndex(PChainListHeader List,ULONG Index)
{
	PListCell Cell,Header;
        ULONG    i;
	BOOLEAN Ret=FALSE;


	if(!List)
	{
		return Ret;
	}

	EntryListLock(List);
	Header=List->g_IrpHookList;
	Cell=Header->Next;
	for(i=0;Cell!=Header&&i<Index;i++)
	{
		Cell=Cell->Next;
	}
	if(i>=Index&&Cell!=Header)
	{
	  DelAndFreeListCell(List,Cell);
	
	  List->Count--;
	
	  Ret=TRUE;
	}
	LeaveListLock(List);
	return Ret;
}
//------------------------------------------------------------------------------
BOOLEAN DelFromChainList(PChainListHeader List,PListCell delCell)
{
	PListCell Cell,Header;
	BOOLEAN Ret=FALSE;

	if(!List)
	{
		return Ret;
	}

	EntryListLock(List);
	Header=List->g_IrpHookList;
	for(Cell=Header->Next;Cell!=Header;Cell=Cell->Next)
	{
		 if(Cell==delCell)
		 {
		 		DelAndFreeListCell(List,Cell);

		 		List->Count--;

		 		Ret=TRUE;
		 		break;
		 }
	}
	LeaveListLock(List);
	return Ret;
}
//------------------------------------------------------------------------------
BOOLEAN DelNoneFromChainList(PChainListHeader List,BOOLEAN isTail)
{
	PListCell Cell,Header;
	BOOLEAN Ret=FALSE;

	if(!List)
	{
		return Ret;
	}

	EntryListLock(List);
	Header=List->g_IrpHookList;
	if(List->Count)
	{
		if(isTail)
		{
			Cell=Header->Prev;
		}
		else 
		{
			Cell=Header->Next;
		}
		if(Cell!=Header)
		{
	 		DelAndFreeListCell(List,Cell);
	 		Cell=NULL;
	 		List->Count--;
	 		Ret=TRUE;
		 }
	}
	LeaveListLock(List);
	return Ret;
}
//------------------------------------------------------------------------------
void* QueryFromChainListByIndex(PChainListHeader List,ULONG Index)
{
	PListCell Cell;
	void*			Ret=NULL;
	if(List)
	{
		EntryListLock(List);
		Cell=GetListCellByIndex(List,Index);
		if(Cell)
		{
			 Ret=Cell->Pointer;
			 OnRefListCell(List,Cell);
		}
		LeaveListLock(List);
	}
	return Ret;
}
//------------------------------------------------------------------------------
void* QueryFromChainListByULONG(PChainListHeader List,ULONG ID)
{
	PListCell Cell,Header;
	void*		  Ret=NULL;
	if(!List)
	{
			return NULL;
	}
	EntryListLock(List);
	Header=List->g_IrpHookList;
	for(Cell=Header->Next;Cell!=Header;Cell=Cell->Next)
	{
		 if(*(ULONG*)Cell->Pointer==ID)
		 {
		 		OnRefListCell(List,Cell);
		 		Ret=Cell->Pointer;
		 		break;
		 }
	}
	LeaveListLock(List);
	return Ret;
}
//------------------------------------------------------------------------------
void* QueryFromChainListByULONG64(PChainListHeader List,ULONGLONG ID)
{
	PListCell Cell,Header;
	void*		  Ret=NULL;
	if(!List)
	{
			return NULL;
	}
	EntryListLock(List);
	Header=List->g_IrpHookList;
	for(Cell=Header->Next;Cell!=Header;Cell=Cell->Next)
	{
		 if(*(ULONGLONG*)Cell->Pointer==ID)
		 {
		 		OnRefListCell(List,Cell);
		 		Ret=Cell->Pointer;
		 		break;
		 }
	}
	LeaveListLock(List);
	return Ret;
}
//------------------------------------------------------------------------------
void* QueryFromChainListByULONGPTR(PChainListHeader List,ULONG_PTR ID)
{
	PListCell Cell,Header;
	void*		  Ret=NULL;
	if(!List)
	{
			return NULL;
	}
	EntryListLock(List);
	Header=List->g_IrpHookList;
	for(Cell=Header->Next;Cell!=Header;Cell=Cell->Next)
	{
		 if(*(ULONG_PTR*)Cell->Pointer==ID)
		 {
		 		OnRefListCell(List,Cell);
		 		Ret=Cell->Pointer;
		 		break;
		 }
	}
	LeaveListLock(List);
	return Ret;
}
//------------------------------------------------------------------------------
void* QueryFromChainListByMemEx(PChainListHeader List,ULONG Offset,void* Mem,ULONG Length,ULONG Flag)
{
	PListCell Cell,Header;
	void*		  Ret=NULL;
	if(!List)
	{
			return NULL;
	}
	EntryListLock(List);
	Header=List->g_IrpHookList;
	for(Cell=Header->Next;Cell!=Header;Cell=Cell->Next)
	{
		 if(RtlCompareMemory((char*)Cell->Pointer+Offset,Mem,Length)==Length)
		 {
		 		OnRefListCell(List,Cell);
		 		Ret=Cell->Pointer;
		 		if(Flag&CLIST_FINDCB_DEL)
		 		{
		 			DelAndFreeListCell(List,Cell);
					List->Count--;
		 		}
		 		break;
		 }
	}
	LeaveListLock(List);
	return Ret;
}
//------------------------------------------------------------------------------
void* QueryFromChainListByMem(PChainListHeader List,ULONG Offset,void* Mem,ULONG Length)
{
	return QueryFromChainListByMemEx(List,Offset,Mem,Length,0);
}
//------------------------------------------------------------------------------
void* QueryFromChainListByCallback(PChainListHeader List,TQueryChainListCallback Callback,void* Context)
{
	PListCell 	  Cell,Header;
	void*		  Ret=NULL;
	if(!List)
	{
			return NULL;
	}
	EntryListLock(List);
	Header=List->g_IrpHookList;
	for(Cell=Header->Next;Cell!=Header;Cell=Cell->Next)
	{
		ULONG   Error=Callback(Cell->Pointer,Context);
		void*	Pointer=Cell->Pointer;
		if(Error&CLIST_FINDCB_DEL)
		{
			PListCell beDel=Cell;
			Cell=Cell->Prev;
			DelAndFreeListCell(List,beDel);
			List->Count--;
		}
		if((Error&CLIST_FINDCB_BKMASK)==CLIST_FINDCB_RET)
		{
			if(!(Error&CLIST_FINDCB_DEL))
			{
				OnRefListCell(List,Cell);	
			}
			Ret=Pointer;
			break;
		}
	}
	LeaveListLock(List);
	return Ret;
}
//------------------------------------------------------------------------------
ULONG GetChainListCount(PChainListHeader List)
{
	ULONG Count=0;
	if(List)
	{
		EntryListLock(List);
		Count=List->Count;
		LeaveListLock(List);
	}
	return Count;
}
//------------------------------------------------------------------------------
BOOLEAN DefChainListPointer(PChainListHeader List,void* Data)
{
	if(List&&Data&&(List->Flag&LISTFLAG_REF))
	{
		long Ret;
		
		EntryListLock(List);
		
		Ret=InterlockedDecrement((PLONG)((char*)Data+List->ReferenceOffSet));
		List->ChainLisActionCallback(Data,CLIST_ACTION_DEF);
		if(Ret<0)
		{
			DbgPrint("OnDefListCell Error\n");
		}
		if(Ret==0)
		{
			PListCell Cell=GetListCellByData(List,Data);
			if(Cell)
			{
				DelListComm((PListComm)Cell);
				List->Count--;

				List->ChainLisActionCallback(Data,CLIST_ACTION_FREE);
				FreeListCell(List,Cell);
			}
			else 
			{
				List->ChainLisActionCallback(Data,CLIST_ACTION_FREE);
			}
		}
		
		LeaveListLock(List);
		
		return TRUE;
	}
	return FALSE;
}
//------------------------------------------------------------------------------
```

`UsbMon/UsbMon/TList.h`:

```h
#ifndef _TLIST_H_2WAZXDE456TGNM8907YH23EDC9IUJ0OKM2
#define _TLIST_H_2WAZXDE456TGNM8907YH23EDC9IUJ0OKM2

#include <ntddk.h>

#define   MASKFLAG_LOCK          0x0000000F

#define   LISTFLAG_UNLOCK        0x00000000
#define   LISTFLAG_SPINLOCK      0x00000001
#define   LISTFLAG_FTMUTEXLOCK   0x00000002
#define   LISTFLAG_NLMUTEXLOCK   0x00000003
#define   LISTFLAG_LOCKCALLBCK   0x00000004
#define   LISTFLAG_REF   		 0x00000010
#define   LISTFLAG_AUTOFREE      0x80000000



typedef struct _ListComm
{
	struct _ListComm* Next;
	struct _ListComm* Prev;
}TListComm,*PListComm;

typedef struct _ListCell
{
	struct _ListCell* 	Next;
	struct _ListCell* 	Prev;
	void*  				Pointer;
}TListCell,*PListCell;


#define LISTBLOCK_NOTFREE  0x00000001

typedef struct _ListCellBlock
{
	struct _ListCellBlock* 	Next;
	struct _ListCellBlock* 	Prev;
	ULONG					Flag;
	ULONG					MaxCount;
	ULONG					Count;
	TListCell				ListCell[1];
}TListCellBlock,*PListCellBlock;


#define   CLIST_FINDCB_BKMASK 0x000000FF
#define   CLIST_FINDCB_CTN 	  0x00000000
#define   CLIST_FINDCB_RET 	  0x00000001
#define   CLIST_FINDCB_DEL 	  0x80000000

#define   CLIST_ACTION_TYPEMASK     0x0000000F 
#define   CLIST_ACTION_REF	        0x00000001
#define   CLIST_ACTION_DEF	        0x00000002
#define   CLIST_ACTION_FREE	        0x00000003
#define   CLIST_ACTION_LOCKENTRY    0x00000010
#define   CLIST_ACTION_LOCKLEAVE	0x00000020

typedef ULONG   (__fastcall *TQueryChainListCallback)(void* Data,void* Context);
typedef ULONG   (__fastcall *TChainLisActionCallback)(void* Data,ULONG Act);


typedef struct 
{
	ULONG		             Version;
	ULONG		             Flag;
	ULONG 		             Count;
	PListCell                g_IrpHookList;
	PListCellBlock           BlockHeader;
	
	TChainLisActionCallback  ChainLisActionCallback;
	ULONG				     ReferenceOffSet;
	ULONG     			     LockType;
	union
	{
		struct
		{
			KSPIN_LOCK   SpinLock;
			KIRQL		 Irql;
		};
		struct
		{
			 FAST_MUTEX  FastMutex;
		};
		struct 
		{
			 KMUTEX      Mutex; 
		};
	};
	ULONG   		   HashDataOffset;	
	ULONG			   HashListSize;//保留，后在加入hash的快速查找
	PListCell		   CellHashList;			   
	char*			   Buffer;
	ULONG			   RefCount;//用于交验访问数据前是否有做加锁处理。	
	ULONG              Reserved[16];
}TChainListHeader,*PChainListHeader;

#define  CHAINLIST_SAFE_FREE(header) { \
	PChainListHeader beFreeObj=(header);\
	(header) = NULL;\
	FreeChainListHeader(beFreeObj);\
	beFreeObj=NULL;\
    }



PChainListHeader     NewChainListHeaderEx(ULONG Flag,TChainLisActionCallback  ChainLisActionCallback,ULONG ReferenceOffSet);
PChainListHeader     NewChainListHeader();
void  			     FreeChainListHeader(PChainListHeader List);
BOOLEAN 		     AddToChainListTail(PChainListHeader List,void* Data);
BOOLEAN 		     InsertToChainList(PChainListHeader List,ULONG Index,void* Data);
BOOLEAN  		     DelFromChainListByPointer(PChainListHeader List,void* Data);
BOOLEAN              DelFromChainListByIndex(PChainListHeader List,ULONG Index);
BOOLEAN              DelFromChainList(PChainListHeader List,PListCell delCell);
BOOLEAN              DelNoneFromChainList(PChainListHeader List,BOOLEAN isTail);

void* 			     QueryFromChainListByIndex(PChainListHeader List,ULONG Index);
void* 			     QueryFromChainListByULONG(PChainListHeader List,ULONG ID);
void* 			     QueryFromChainListByULONG64(PChainListHeader List,ULONGLONG ID);
void* 			     QueryFromChainListByULONGPTR(PChainListHeader List,ULONG_PTR ID);
void*                QueryFromChainListByMem(PChainListHeader List,ULONG Offset,void* Mem,ULONG Length);
void*                QueryFromChainListByMemEx(PChainListHeader List,ULONG Offset,void* Mem,ULONG Length,ULONG Flag);
void* 			     QueryFromChainListByCallback(PChainListHeader List,TQueryChainListCallback Callback,void* Context);
ULONG 			     GetChainListCount(PChainListHeader List);
BOOLEAN              DefChainListPointer(PChainListHeader List,void* Data);




























#endif
```

`UsbMon/UsbMon/UsbHid.c`:

```c
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    #include "UsbHid.h"
#include "UsbUtil.h"  
#include "Winparse.h"
#include "ReportUtil.h"   
#include "IrpHook.h"
#include "UsbType.h"
#include "HidHijack.h"
#include "OpenLoopBuffer.h"


/////////////////////////////////////////////////////////////////////////////////////
//// Type
//// 

typedef struct _PARAM
{
	BOOLEAN 					 Ret;
	USBD_PIPE_HANDLE	  PipeHandle;
}PARAM, *PPARAM;

 typedef struct _HASH_TABLE
{
	ULONG_PTR ID;
	PVOID	  Value;
}HASHTABLE, *PHASHTABLE;
 
  
/////////////////////////////////////////////////////////////////////////////////////
//// Marco
//// 
#define ARRAY_SIZE						 100
#define HIDP_PREPARSED_DATA_SIGNATURE1	 'PdiH'
#define HIDP_PREPARSED_DATA_SIGNATURE2   'RDK '
#define HASHSIZE 0x10000
#define HIDP_MAX_UNKNOWN_ITEMS 				4  
/////////////////////////////////////////////////////////////////////////////////////
//// Global/Extern Variable 
//// 
USB_HUB_LIST*		g_UsbHubList	   = NULL;			// container of USBHUBNODE  - APC_LEVEL List
HID_DEVICE_LIST*    g_HidClientPdoList = NULL;  		// container of hid device -- mouse pipe handle APC_LEVEL List
BOOLEAN				g_IsHidModuleInit  = FALSE; 		// it init 
HASHTABLE 			g_ThirdPartyHidDevice[HASHSIZE] = {0};
HASHTABLE 			g_HidDevicePipeHashTable[HASHSIZE] = {0};
HASHTABLE 			g_UsbHubDrvObjHashTable[HASHSIZE] = {0};
BOOLEAN 			g_UsbHubListInit   = FALSE;
BOOLEAN				g_IsReportedVmware = FALSE;
BOOLEAN				g_IsReportedKeyboard = FALSE;
BOOLEAN				g_IsReportedMouse = FALSE;
BOOLEAN				g_bIsHidEnumerated = FALSE;
 
/////////////////////////////////////////////////////////////////////////////////////
//// Prototype
//// 
 
PDEVICE_OBJECT IoGetLowerDeviceObject(IN PDEVICE_OBJECT  DeviceObject); 
  
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 

Routine Description:
		See a detail in UsbHid.h
		  
Arguments:
		See a detail in UsbHid.h
		 
Return Value:	
		See a detail in UsbHid.h

-----------------------------------------------------------------------------------*/
BOOLEAN IsHidDevicePipe(
	_In_ TChainListHeader* PipeListHeader,
	_In_ USBD_PIPE_HANDLE  PipeHandle,
	_Out_ PHID_DEVICE_NODE*		node
);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:
		Core function it translates a report descriptor into a human-readable structure

Arguments:

		HidClassExtension	- HidClassExtension, which is shared by all hid mini-driver  
		
		AllReport			- Get all pointer from it device

Return Value:
		NTSTATUS			- STATUS_SUCCESS				, if translate success
							- STATUS_UNSUCCESSFUL or others	, if translate error
-----------------------------------------------------------------------------------*/
NTSTATUS GetParsedReport(
	_In_  HIDCLASS_DEVICE_EXTENSION* HidClassExtension,
	_Out_ HIDP_DEVICE_DESC* AllReport
);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:
		Create a device node for when it is a Hid Client Pdo

Arguments:

		DeviceObject			- Hid Device Object (Hid Client Pdo)
		
		MiniExtension			- MiniExtension stored in ClassExtension

Return Value:
		HID_DEVICE_NODE			- Created Node, if created success
								- NULL		  , if failed			
-----------------------------------------------------------------------------------*/
HID_DEVICE_NODE* CreateHidDeviceNode(
	_In_ PDEVICE_OBJECT DeviceObject,
	_In_ HID_USB_DEVICE_EXTENSION* MiniExtension,
	_In_ HIDP_DEVICE_DESC* parsedReport
);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

		Deteremine a device objects if it is a Client PDO for Keyboard / Mouse.
		set a MiniExtension and return TRUE. Otherwise, FALSE
		For More Information between Cient PDO and class FDO, See Doc/ README.txt.

Arguments:

		DeviceObject			- Hid Device Object (Hid Client Pdo, created by )
		
		MiniExtension			- MiniExtension stored in ClassExtension

Return Value:
		NTSTATUS			- STATUS_SUCCESS				, if translate success
							- STATUS_UNSUCCESSFUL or others	, if translate error

-----------------------------------------------------------------------------------*/
BOOLEAN  IsHidTypeDevice(
	_In_  PDEVICE_OBJECT				  DeviceObject,	
	_In_  HIDCONTEXT*					  RequiredDevice,
	_Out_ PHID_USB_DEVICE_EXTENSION*	  MiniExtension
);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:
		- Verify Hid Device Object, just simply call VerifyAndInsertIntoHidList and
		  walk through each device object in the HID device object stack.

Arguments:

		DriverObject			- Hid Driver Object
		
		ClientPdoCount			- Total of Client Pdo 		

Return Value:
		NTSTATUS			- STATUS_SUCCESS				, if translate success
							- STATUS_UNSUCCESSFUL or others	, if translate error

-----------------------------------------------------------------------------------*/
NTSTATUS VerifyAllHidDevice(
	_In_  PDRIVER_OBJECT DriverObject, 
	_In_  HIDCONTEXT*	Context,
	_Out_ ULONG*		ClientPdoCount
);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

		Init Pdo List, basically get a Hid Driver Object and call VerifyHidDeviceObject.

Arguments:

		ListSize			- Size of List

Return Value:
		NTSTATUS			- STATUS_SUCCESS				, if translate success
							- STATUS_UNSUCCESSFUL or others	, if translate error

-----------------------------------------------------------------------------------*/ 
NTSTATUS InitClientPdoList(
	_In_  HIDCONTEXT*  RequiredDevice,
	_Out_ PULONG 	   ListSize
);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

		Allocate Pdo List memory

Arguments:

		No

Return Value:
		NTSTATUS			- STATUS_SUCCESS				, if alloc success
							- STATUS_UNSUCCESSFUL or others	, if alloc error

-----------------------------------------------------------------------------------*/
NTSTATUS AllocateClientPdoList();

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

		Free Hid Client Pdo List

Arguments:

		No

Return Value:

		NTSTATUS			- STATUS_SUCCESS				, if translate success
							- STATUS_UNSUCCESSFUL or others	, if translate error

-----------------------------------------------------------------------------------*/
NTSTATUS FreeHidClientPdoList(); 

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

		Verify a Device is it hid device and add it into linked list

Arguments:

		DeviceObject		- Device to be verify

Return Value:

		NTSTATUS			- STATUS_SUCCESS				, if verify device success
							- STATUS_UNSUCCESSFUL or others	, if verify device error

-----------------------------------------------------------------------------------*/
NTSTATUS VerifyDevice(
	_In_  PDEVICE_OBJECT DeviceObject, 
	_In_  HIDCONTEXT*	 RequiredDevice,
	_Out_ PHID_DEVICE_NODE* Node
	);

	
	
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

		Verify a Device is it hid device and add it into linked list

Arguments:

		DeviceObject		- Device to be verify

Return Value:

		NTSTATUS			- STATUS_SUCCESS				, if verify device success
							- STATUS_UNSUCCESSFUL or others	, if verify device error

-----------------------------------------------------------------------------------*/
NTSTATUS AllocateUsbHubList();


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

		Verify a Device is it hid device and add it into linked list

Arguments:

		DeviceObject		- Device to be verify

Return Value:

		NTSTATUS			- STATUS_SUCCESS				, if verify device success
							- STATUS_UNSUCCESSFUL or others	, if verify device error

-----------------------------------------------------------------------------------*/
NTSTATUS FreeUsbHubList();


 /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

	- Get Client Physical Device Object Extension by HIDCLASS EXTENSION

Arguments:

	 HidCommonExt - Device Extension of HIDCLASS

Return Value:

NTSTATUS	 - STATUS_UNSUCCESSFUL   , If failed of any one of argument check.
			 - STATUS_XXXXXXXXXXXX   , Depended on old completion
-----------------------------------------------------------------------------------*/ 
PDO_EXTENSION*	GetClientPdoExtension(
	_In_ HIDCLASS_DEVICE_EXTENSION* HidCommonExt
);

 /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

	- Get Functional Device Object Extension by Client PDO Extension
	
Arguments:

	 pdoExt - Device Extension of Client PDO

Return Value:

NTSTATUS	 - STATUS_UNSUCCESSFUL   , If failed of any one of argument check.
			 - STATUS_XXXXXXXXXXXX   , Depended on old completion
-----------------------------------------------------------------------------------*/ 
FDO_EXTENSION* GetFdoExtByClientPdoExt(
	_In_ PDO_EXTENSION* pdoExt
);

 /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

	- Enumerate all hid mini driver
	
Arguments:

	 fdoExt - Device Extension of Fdo (_HID000000x)

Return Value:

NTSTATUS	 - STATUS_UNSUCCESSFUL   , If failed of any one of argument check.
			 - STATUS_XXXXXXXXXXXX   , Depended on old completion
-----------------------------------------------------------------------------------*/ 
NTSTATUS ReportAllHidMiniDriver(FDO_EXTENSION* fdoExt);

NTSTATUS GetAllUsbHub();


/////////////////////////////////////////////////////////////////////////////////////////////// 
//// Implementation
////
 
 
//------------------------------------------------------------------------------------------//
PDO_EXTENSION*	GetClientPdoExtension(
	_In_ HIDCLASS_DEVICE_EXTENSION* HidCommonExt
)
{
	PDO_EXTENSION* pdoExt  = NULL;
	if(!HidCommonExt)
	{
		return pdoExt;
	}	
	if(!HidCommonExt->isClientPdo)
	{ 		
		return pdoExt;
	}
	pdoExt = &HidCommonExt->pdoExt;
	return pdoExt ;
}

//-----------------------------------------------------------------------------------------//
FDO_EXTENSION* GetFdoExtByClientPdoExt(
	_In_ PDO_EXTENSION* pdoExt
)
{
	FDO_EXTENSION* fdoExt = NULL;
	if(!pdoExt)
	{
		return fdoExt;
	}
	if(!pdoExt->deviceFdoExt)
	{ 	
		return fdoExt;
	}
		
	fdoExt = &pdoExt->deviceFdoExt->fdoExt; 
	return fdoExt; 
}
 
//----------------------------------------------------------------------------------------//
ULONG GetIndexByID(ULONG_PTR ID, ULONG TableSize) 
{
   return ID % TableSize;
}
 //----------------------------------------------------------------------------------------//
void ClearHashById(HASHTABLE* HashTable, ULONG TableSize , ULONG_PTR ID)
{
	ULONG Index = GetIndexByID(ID, TableSize); 
	HashTable[Index].ID = 0;
	HashTable[Index].Value = NULL; 
	USB_DEBUG_INFO_LN_EX("Clear - Index: %x Id: %I64x ", Index, ID);
}

//----------------------------------------------------------------------------------------//
void SetHash(HASHTABLE* HashTable, ULONG TableSize, ULONG_PTR ID, PVOID lpNode)
{
	ULONG Index = GetIndexByID(ID, TableSize); 
	HashTable[Index].ID = ID;
	HashTable[Index].Value = lpNode;
	USB_DEBUG_INFO_LN_EX("Add - Index: %x Id: %I64x ", Index, ID);
}

//----------------------------------------------------------------------------------------//
BOOLEAN GetHashIndexById(HASHTABLE* HashTable, ULONG TableSize, ULONG_PTR ID, PVOID* lpNode)
{
	ULONG_PTR Index = GetIndexByID(ID, TableSize); 
	if(HashTable[Index].ID == ID)
	{
		*lpNode =  HashTable[Index].Value;
		return TRUE;
	}	
	return FALSE;
}
//--------------------------------------------------------------------------------------------//
VOID ClearPipeHandleHashByHidNode(PHID_DEVICE_NODE HidNode)
{
	ULONG i = 0;
	USBD_PIPE_INFORMATION* PipeHandleFromWhiteLists = HidNode->mini_extension->InterfaceDesc->Pipes;
	ULONG 	NumberOfPipes =  HidNode->mini_extension->InterfaceDesc->NumberOfPipes;    
	for (i = 0; i < NumberOfPipes; i++)
	{
		USB_DEBUG_INFO_LN_EX("ppHandle: %I64x", PipeHandleFromWhiteLists[i].PipeHandle);
		ClearHashById(g_HidDevicePipeHashTable, HASHSIZE ,(ULONG_PTR)PipeHandleFromWhiteLists[i].PipeHandle); 
	} 
}
//--------------------------------------------------------------------------------------------//
ULONG __fastcall SearchHidNodeCallback(
	_In_ PHID_DEVICE_NODE HidNode,
	_In_ void* pDeviceObject
)
{
	PDEVICE_OBJECT DeviceObject = (PDEVICE_OBJECT)pDeviceObject;
	if (DeviceObject == HidNode->device_object)
	{	 
		return CLIST_FINDCB_RET;
	}
	return CLIST_FINDCB_CTN;
}

//--------------------------------------------------------------------------------------------//
PHID_DEVICE_NODE GetHidNodeByDeviceObject(
	_In_ PDEVICE_OBJECT DeviceObject
)
{ 	  
	USB_DEBUG_INFO_LN_EX("GetHidNodeByDeviceObject"); 
	return QueryFromChainListByCallback(g_HidClientPdoList->head, SearchHidNodeCallback, DeviceObject);
}

//--------------------------------------------------------------------------------------------//
NTSTATUS VerifyAndInsertIntoHidList(
	_In_ PDEVICE_OBJECT DeviceObject,
	_In_ HIDCONTEXT*	Context
)
{
	HID_DEVICE_NODE* node = NULL;
	NTSTATUS status = STATUS_UNSUCCESSFUL;

	if (!DeviceObject || !g_HidClientPdoList)
	{
		return status;
	}
	 
	status = VerifyDevice(DeviceObject, Context,  &node);
	
	if (!NT_SUCCESS(status))
	{
		return status;
	}

	if (!node)
	{
		status = STATUS_UNSUCCESSFUL;
		return status;
	}
		
	if (AddToChainListTail(g_HidClientPdoList->head, node))
	{
		status = STATUS_SUCCESS;
		g_HidClientPdoList->currentSize++;
	}

	return status;
}

//--------------------------------------------------------------------------------------------//
NTSTATUS RemoveNodeFromHidList(
	_In_ PDEVICE_OBJECT DeviceObject
)
{
	PHID_DEVICE_NODE node = NULL;
	NTSTATUS status = STATUS_UNSUCCESSFUL;
	if (!DeviceObject || !g_HidClientPdoList)
	{
		return status;
	}
	node = GetHidNodeByDeviceObject(DeviceObject);
	if (!node)
	{
		return status;
	}

	ClearPipeHandleHashByHidNode(node);
	
	if (DelFromChainListByPointer(g_HidClientPdoList->head, node))
	{ 
		status = STATUS_SUCCESS;
		g_HidClientPdoList->currentSize--;
	}

	return status;
} 

//----------------------------------------------------------------------------------------//
LOOKUP_STATUS __fastcall LookupPipeHandleCallback(
	PHID_DEVICE_NODE Data,
	PARAM* Context
)
{	NTSTATUS								   status = STATUS_UNSUCCESSFUL;
	USBD_PIPE_HANDLE				PipeHandleFromUrb = NULL;
	USBD_PIPE_INFORMATION*	 PipeHandleFromWhiteLists = NULL;
	ULONG								NumberOfPipes = 0;
	ULONG 										   i  = 0 ;
	if (!Data || !Context)
	{
		USB_DEBUG_INFO_LN_EX("Empty Data / Context");
		return CLIST_FINDCB_CTN;
	}
	if (!Data->mini_extension)
	{
		USB_DEBUG_INFO_LN_EX("Empty mini_extension");
		return CLIST_FINDCB_CTN;
	}
	if (!Data->mini_extension->InterfaceDesc)
	{
		USB_DEBUG_INFO_LN_EX("Empty InterfaceDesc");
		return CLIST_FINDCB_CTN;
	}
	if (!Data->mini_extension->InterfaceDesc->Pipes)
	{
		USB_DEBUG_INFO_LN_EX("Empty Pipes");
		return CLIST_FINDCB_CTN;
	}
	
	PipeHandleFromUrb = Context->PipeHandle;
	PipeHandleFromWhiteLists = Data->mini_extension->InterfaceDesc->Pipes;
	NumberOfPipes = Data->mini_extension->InterfaceDesc->NumberOfPipes;
	USB_DEBUG_INFO_LN_EX("PipeDevice: %p", Data->device_object);
	for (i = 0; i < NumberOfPipes; i++)
	{ 
		if (PipeHandleFromUrb == PipeHandleFromWhiteLists[i].PipeHandle)
		{	
			USB_DEBUG_INFO_LN_EX("Found Pipe: %I64x %I64x",PipeHandleFromUrb, PipeHandleFromWhiteLists[i].PipeHandle); 
			status = STATUS_SUCCESS;
			Context->Ret = TRUE;
			break;
		}
		USB_DEBUG_INFO_LN_EX("Try to find : %I64x %I64x",PipeHandleFromUrb, PipeHandleFromWhiteLists[i].PipeHandle); 
	}

	if (!NT_SUCCESS(status))
	{
		return 	CLIST_FINDCB_CTN;
	}
	return CLIST_FINDCB_RET;
}
 

 
//----------------------------------------------------------------------------------------// 
BOOLEAN IsHidDevicePipe(
	_In_ TChainListHeader* 		PipeListHeader,
	_In_ USBD_PIPE_HANDLE  		PipeHandle,
	_Out_ PHID_DEVICE_NODE*		lpNode
)
{	 
	PHID_DEVICE_NODE Node = NULL;
	BOOLEAN ret = GetHashIndexById(g_HidDevicePipeHashTable, HASHSIZE, (ULONG_PTR)PipeHandle, &Node) ;
	if(ret && Node)
	{
		USB_DEBUG_INFO_LN_EX("Get Value By Hash %I64x ", Node );
		*lpNode = Node;
		return TRUE;
	}
	else
	{ 	
		PARAM params = { FALSE , PipeHandle };
		Node = QueryFromChainListByCallback(PipeListHeader, LookupPipeHandleCallback, &params);  
		if(Node && params.Ret)
		{		 
			*lpNode = Node;
			SetHash(g_HidDevicePipeHashTable,HASHSIZE,(ULONG_PTR)PipeHandle, Node);
			return TRUE;
		}
		else
		{	
			*lpNode = NULL;
			SetHash(g_HidDevicePipeHashTable,HASHSIZE,(ULONG_PTR)PipeHandle, NULL);
		}
	}	 
	return FALSE;
}
//----------------------------------------------------------------------------------------------------------//
NTSTATUS HidGetRawDescriptorByClientPdo(
	_In_  		DEVICE_OBJECT* 	 ClientPdo,
	_Out_ 		PCHAR*		 HidDescriptor,
	_Inout_opt_ ULONG*	 HidDescriptorHash
)
{
	HIDCLASS_DEVICE_EXTENSION*  HidClassExtension = NULL;
	PDO_EXTENSION* 				pdoExt = NULL;
	FDO_EXTENSION* 				fdoExt = NULL; 
	HIDCLASS_DEVICE_EXTENSION*  fdoBackPtr = NULL;
	ULONG						DescriptorHash = 0;
	ULONG 						i=0; 
	NTSTATUS 			   		status = STATUS_SUCCESS;
	CHAR* 						HidDesc = NULL;
	do
	{ 
		if (!ClientPdo || !HidDescriptor)
		{
			//USB_DEBUG_INFO_LN_EX("STATUS_INVALID_PARAMETER 1 ");
			status = STATUS_INVALID_PARAMETER;
			break;
		}

		HidClassExtension = ClientPdo->DeviceExtension;
		if(!HidClassExtension)
		{	
			//USB_DEBUG_INFO_LN_EX("STATUS_INVALID_PARAMETER2 ");
			status = STATUS_INVALID_PARAMETER;
			break;
		}
		
		pdoExt = &HidClassExtension->pdoExt; 
		if (!pdoExt)
		{
			//USB_DEBUG_INFO_LN_EX("STATUS_INVALID_PARAMETER3 ");
			status = STATUS_INVALID_PARAMETER;
			break;
		}

		fdoBackPtr = (HIDCLASS_DEVICE_EXTENSION*)pdoExt->deviceFdoExt;
		if (!fdoBackPtr)
		{
			//USB_DEBUG_INFO_LN_EX("STATUS_INVALID_PARAMETER4");
			status = STATUS_INVALID_PARAMETER;
			break;
		}

		fdoExt = &fdoBackPtr->fdoExt;
		if (!fdoExt)
		{	
			//USB_DEBUG_INFO_LN_EX("STATUS_INVALID_PARAMETER5");
			status = STATUS_INVALID_PARAMETER;
			break;
		} 
		   
		HidDesc = (CHAR*)ExAllocatePoolWithTag(NonPagedPool ,  fdoExt->rawReportDescriptionLength * 2 + 1 , 'rept' ); 
		if(!HidDesc)
		{	
			//USB_DEBUG_INFO_LN_EX("STATUS_INVALID_PARAMETER6");
			break;
		}

		RtlZeroMemory(HidDesc, fdoExt->rawReportDescriptionLength * 2 + 1);
		
//		binToBcd(fdoExt->rawReportDescription, fdoExt->rawReportDescriptionLength, HidDesc ,fdoExt->rawReportDescriptionLength * 2 + 1 );
			
		
		for(i = 0 ; i < fdoExt->rawReportDescriptionLength ; i++)
		{
			DescriptorHash = DescriptorHash + ((*HidDesc * i) ^ 0x32567711);
		} 
		
		//Free By Caller
		*HidDescriptor = HidDesc; 
		
		if(HidDescriptorHash)
		{
			*HidDescriptorHash = DescriptorHash;
		}
	
	} while (FALSE);

	return status;
} 

//----------------------------------------------------------------------------------------------------------//
NTSTATUS GetParsedReport(
	_In_  HIDCLASS_DEVICE_EXTENSION* HidClassExtension,
	_Out_ HIDP_DEVICE_DESC* AllReport
)
{
	PDO_EXTENSION* pdoExt = NULL;
	FDO_EXTENSION* fdoExt = NULL; 
	HIDCLASS_DEVICE_EXTENSION* addr = NULL;
	WCHAR name[256] = { 0 };
	HIDP_DEVICE_DESC hid_device_desc = { 0 };
	NTSTATUS status = STATUS_SUCCESS;
	char* str = NULL;
	do
	{
		if (!HidClassExtension || !AllReport)
		{
			USB_DEBUG_INFO_LN_EX("STATUS_INVALID_PARAMETER");
			status = STATUS_INVALID_PARAMETER;
			break;
		}

		pdoExt = &HidClassExtension->pdoExt;

		if (!pdoExt)
		{
			status = STATUS_INVALID_PARAMETER;
			break;
		}

		addr = (HIDCLASS_DEVICE_EXTENSION*)pdoExt->deviceFdoExt;
		if (!addr)
		{
			status = STATUS_INVALID_PARAMETER;
			break;
		}

		fdoExt = &addr->fdoExt;
		if (!fdoExt)
		{
			status = STATUS_INVALID_PARAMETER;
			break;
		}

		GetDeviceName(fdoExt->fdo, name);
		USB_DEBUG_INFO_LN_EX("Pdo->fdoExt: %I64x ", fdoExt);
		USB_DEBUG_INFO_LN_EX("Pdo->fdo: %I64x ", fdoExt->fdo);
		if(KeGetCurrentIrql() < DISPATCH_LEVEL)
		{
			USB_DEBUG_INFO_LN_EX("Pdo->fdo DriverName: %ws ", fdoExt->fdo->DriverObject->DriverName.Buffer);
		}
		else
		{
			USB_DEBUG_INFO_LN_EX("IRQL TOO HIGH ");
		}
	
		USB_DEBUG_INFO_LN_EX("Pdo->CollectionIndex: %I64x", pdoExt->collectionIndex);
		USB_DEBUG_INFO_LN_EX("Pdo->CollectionNum: %I64x", pdoExt->collectionNum);

		status = GetCollectionDescription(fdoExt->rawReportDescription, fdoExt->rawReportDescriptionLength, NonPagedPool, &hid_device_desc);//==(HIDP_DEVICE_DESC*)((PUCHAR)fdoExt + 0x58);
		
		RtlMoveMemory(AllReport, &hid_device_desc, sizeof(HIDP_DEVICE_DESC));

	} while (FALSE);

	return status;
} 

//-------------------------------------------------------------------------------------------//
HID_DEVICE_NODE* CreateHidDeviceNode(
	_In_ PDEVICE_OBJECT DeviceObject,
	_In_ HID_USB_DEVICE_EXTENSION* MiniExtension,
	_In_ HIDP_DEVICE_DESC* ParsedReport
)
{
	HID_DEVICE_NODE* node = NULL;
	if (!DeviceObject || !MiniExtension || !ParsedReport)
	{
		return NULL;
	}

	node = ExAllocatePoolWithTag(NonPagedPool, sizeof(HID_DEVICE_NODE), 'edon');
	if (!node)
	{
		return NULL;
	}

	RtlZeroMemory(node, sizeof(HID_DEVICE_NODE));
	node->device_object  		= DeviceObject;
	node->mini_extension 		= MiniExtension;
	node->ExtractedData[0]      = NULL;
	node->ExtractedData[1]      = NULL;
	node->ExtractedData[2]      = NULL;
	node->Collection			= NULL;
	
	RtlMoveMemory(&node->parsedReport , ParsedReport, sizeof(HIDP_DEVICE_DESC));

	return node;
} 
//---------------------------------------------------------------------------------------------------------//
NTSTATUS VerifyDevice(
	_In_  PDEVICE_OBJECT DeviceObject, 
	_In_  HIDCONTEXT*	 Context,
	_Out_ PHID_DEVICE_NODE* Node)
{
	HIDP_DEVICE_DESC* ParsedReport = NULL;
	NTSTATUS status = STATUS_UNSUCCESSFUL; 
	PHID_USB_DEVICE_EXTENSION MiniExtension = NULL;
	HID_DEVICE_NODE* node = NULL;
	do {

		if (!DeviceObject || !g_HidClientPdoList)
		{
			status = STATUS_UNSUCCESSFUL; 
			break;
		} 

		if (!IsHidTypeDevice(DeviceObject, Context, &MiniExtension))
		{  		
			USB_DEBUG_INFO_LN_EX("IsHidTypeDevice");
			status = STATUS_UNSUCCESSFUL; 
			break; 
		}

		ParsedReport = (HIDP_DEVICE_DESC*)ExAllocatePoolWithTag(NonPagedPool, sizeof(HIDP_DEVICE_DESC), 'csed');
		if (!ParsedReport)
		{
			USB_DEBUG_INFO_LN_EX("Empty report");
			status = STATUS_UNSUCCESSFUL; 
			break;
		}
		
		RtlZeroMemory(ParsedReport, sizeof(HIDP_DEVICE_DESC));

		status = GetParsedReport(DeviceObject->DeviceExtension, ParsedReport);
		if (!NT_SUCCESS(status))
		{
			USB_DEBUG_INFO_LN_EX("GetParsedReport Failed");
			break;
		}
		
		node = CreateHidDeviceNode(DeviceObject, MiniExtension, ParsedReport);
		if (!node)
		{
			USB_DEBUG_INFO_LN_EX("CreateNode Failed");
			status = STATUS_UNSUCCESSFUL;
			break;
		}

		*Node = node;
		status = STATUS_SUCCESS;
		 
	} while (FALSE);

	if (ParsedReport)
	{
		ExFreePool(ParsedReport);
		ParsedReport = NULL;
	}

	return status; 
}
//---------------------------------------------------------------------------------------------------------//
BOOLEAN  IsHidTypeDevice(
	_In_  PDEVICE_OBJECT				  DeviceObject,
	_In_  HIDCONTEXT*					  Context,
	_Out_ PHID_USB_DEVICE_EXTENSION*      MiniExtension
)
{
	HID_USB_DEVICE_EXTENSION*  pMiniExtension   = NULL;
	HIDCLASS_DEVICE_EXTENSION* pClassExtension  = NULL;
	WCHAR						DeviceName[256] = { 0 };
	BOOLEAN			 					   ret  = FALSE; 
	do
	{
		if (!DeviceObject)
		{
			USB_DEBUG_INFO_LN_EX("Empty Device Object");
			ret = FALSE;
			break;
		}

		pClassExtension = (HIDCLASS_DEVICE_EXTENSION*)DeviceObject->DeviceExtension;
		if (!pClassExtension)
		{
			USB_DEBUG_INFO_LN_EX("Empty pClassExtension");
			ret = FALSE;
			break; 
		}

		//USB_MON_DEBUG_INFO("Extension_common: %I64X sizeof: %x \r\n", HidCommonExt, sizeof(HID_USB_DEVICE_EXTENSION));
		pMiniExtension = (HID_USB_DEVICE_EXTENSION*)pClassExtension->hidExt.MiniDeviceExtension;
		if (!pMiniExtension)
		{
			USB_DEBUG_INFO_LN_EX("Empty pMiniExtension"); 
			ret = FALSE;
			break; 
		}

		//DumpHidMiniDriverExtension(hid_common_extension); 

		//Device Name = HID_0000000X
		if (!pClassExtension->isClientPdo)
		{
			USB_DEBUG_INFO_LN_EX("is not ClientPdo");
			*MiniExtension = NULL;
			ret = FALSE;
			break; 
		}
		
		//HidClass Device
		if(pMiniExtension->InterfaceDesc->Class	!= 3)
		{
			ret = FALSE;
			break;
		}
		
		if ((pMiniExtension->InterfaceDesc->Protocol == 2) && (Context->RequiredDevice & MOUSE_FLAGS))	 
		{
			USB_DEBUG_INFO_LN_EX("Found Mouse Device %p ", DeviceObject);
			if(Context->MouseCallback && DeviceObject->AttachedDevice)
			{
				ret = Context->MouseCallback(NULL);
				*MiniExtension = pMiniExtension;
			}	 
			ret = TRUE;
		} 
		if((pMiniExtension->InterfaceDesc->Protocol == 1) && (Context->RequiredDevice & KEYBOARD_FLAGS))
		{			
			USB_DEBUG_INFO_LN_EX("Found Keyboard Device %p ", DeviceObject);
			if(Context->KeyboardCallback && DeviceObject->AttachedDevice )
			{
				ret = Context->KeyboardCallback(NULL);
				*MiniExtension = pMiniExtension;
			}
			ret = TRUE;
		}
		
		USB_DEBUG_INFO_LN_EX("----------------------------------------------------------------------------------------------------");
		USB_DEBUG_INFO_LN_EX("Protocol: %x ",pMiniExtension->InterfaceDesc->Protocol);
		USB_DEBUG_INFO_LN_EX("DeviceObject: %I64x HidCommonExt: %I64x", DeviceObject, pClassExtension); 
		if(KeGetCurrentIrql() < DISPATCH_LEVEL)
		{ 
			GetDeviceName(DeviceObject, DeviceName);
			USB_DEBUG_INFO_LN_EX("DeviceObj: %I64X  DriverName: %ws DeviceName: %ws", DeviceObject, DeviceObject->DriverObject->DriverName.Buffer, DeviceName);
		}
		else
		{
			USB_DEBUG_INFO_LN_EX("IRQL TOO HIGH ");
		}

		USB_DEBUG_INFO_LN_EX("collectionIndex: %x collectionNum: %x", pClassExtension->pdoExt.collectionIndex, pClassExtension->pdoExt.collectionNum);
		USB_DEBUG_INFO_LN_EX("----------------------------------------------------------------------------------------------------");

			
		if(pMiniExtension->InterfaceDesc->Class	== 3 &&			//HidClass Device
		   pMiniExtension->InterfaceDesc->Protocol == 0 &&
		   !g_IsReportedVmware)
		{
			//VMWare 
			g_IsReportedVmware = TRUE;
		}
	
		if(pMiniExtension->InterfaceDesc->Class	== 3 &&			//HidClass Device
		   pMiniExtension->InterfaceDesc->Protocol == 1 &&
		   !g_IsReportedKeyboard)
		{
			//VMWare 
			g_IsReportedKeyboard = TRUE;
		}
		
		
		if(pMiniExtension->InterfaceDesc->Class	== 3 &&			//HidClass Device
		   pMiniExtension->InterfaceDesc->Protocol == 2 &&
		   !g_IsReportedMouse)
		{
			//VMWare 
			g_IsReportedMouse = TRUE;
		}
		
	} while (FALSE);

	return ret;
}
//----------------------------------------------------------------------------------------------------------//
NTSTATUS VerifyAllHidDevice(
	_In_ PDRIVER_OBJECT DriverObject,
	_In_  HIDCONTEXT*	Context,
	_Out_ ULONG*		ClientPdoCount
)
{
	PDEVICE_OBJECT	DeviceObject = NULL;
	ULONG		HidClientPdoCount = 0;
	NTSTATUS			   status = STATUS_UNSUCCESSFUL;

	if (!g_HidClientPdoList || !DriverObject)
	{
		return status;
	}

	DeviceObject = DriverObject->DeviceObject;
	while (DeviceObject)
	{
		if(NT_SUCCESS(VerifyAndInsertIntoHidList(DeviceObject, Context)))
		{ 
			HidClientPdoCount++;
		}
		DeviceObject = DeviceObject->NextDevice;
	}

	if (HidClientPdoCount)
	{
		*ClientPdoCount = HidClientPdoCount;
		status = STATUS_SUCCESS;
	}
	

	USB_DEBUG_INFO_LN_EX("HidClientPdoCount: %x", HidClientPdoCount);
	return status;
}
//----------------------------------------------------------------------------------------------------------//
NTSTATUS InitClientPdoList(
	_In_  HIDCONTEXT*  Context,
	_Out_ PULONG 	  ListSize
)
{
	NTSTATUS	   		  status = STATUS_SUCCESS;
	PDRIVER_OBJECT HidDriverObj = NULL;
	ULONG			 return_size = 0;

	do {
		if (!ListSize || !g_HidClientPdoList)
		{
			USB_DEBUG_INFO_LN_EX("Empty Params");
			status = STATUS_UNSUCCESSFUL;
			break;
		}

		if (!NT_SUCCESS(GetDriverObjectByName(HID_USB_DEVICE, &HidDriverObj)))
		{
			USB_DEBUG_INFO_LN_EX("Get Drv Obj Error");
			status = STATUS_UNSUCCESSFUL;
			break;
		} 

		if (!HidDriverObj)
		{
			USB_DEBUG_INFO_LN_EX("Empty DrvObj");
			status = STATUS_UNSUCCESSFUL; 
			break;
		}

		
		if (!NT_SUCCESS(VerifyAllHidDevice(HidDriverObj, Context , ListSize)))
		{
			USB_DEBUG_INFO_LN_EX("VerifyHidDeviceObject Error");
			status = STATUS_UNSUCCESSFUL;
			break; 
		}  
	} while (FALSE);
	
	if(HidDriverObj)
	{
		ReleaseDriverObject(HidDriverObj);
		HidDriverObj = NULL;
	}
	
	return status;
}
//----------------------------------------------------------------------------------------------------------//
ULONG   __fastcall FreeHidNodeCallback(PHID_DEVICE_NODE Header,ULONG Act)
{
	if(Act == CLIST_ACTION_FREE)
	{
		if(Header->ExtractedData[HidP_Input])
		{
			ExFreePool(Header->ExtractedData[HidP_Input]);
			Header->ExtractedData[HidP_Input] = NULL;
		}
		
		if(Header->PreviousUsageList)
		{
			ExFreePool(Header->PreviousUsageList);
			Header->PreviousUsageList = NULL;
		}
	}
	return 0 ;
}
//----------------------------------------------------------------------------------------------------------//
NTSTATUS AllocateClientPdoList()
{
	NTSTATUS status = STATUS_UNSUCCESSFUL;
	do
	{
		if (!g_HidClientPdoList)
		{
			g_HidClientPdoList = (HID_DEVICE_LIST*)ExAllocatePoolWithTag(NonPagedPool, sizeof(HID_DEVICE_LIST), 'ldih');	
			if (!g_HidClientPdoList)
			{
 				status = STATUS_UNSUCCESSFUL;
				break;
			}
			RtlZeroMemory(g_HidClientPdoList, sizeof(HID_DEVICE_LIST));
		} 
		if (!g_HidClientPdoList->head)
		{
			g_HidClientPdoList->head = NewChainListHeaderEx(LISTFLAG_SPINLOCK | LISTFLAG_AUTOFREE, FreeHidNodeCallback, 0);
			if (!g_HidClientPdoList->head)
			{
				ExFreePool(g_HidClientPdoList);
				g_HidClientPdoList = NULL;
				status = STATUS_UNSUCCESSFUL;
				break;
			}
		}
		status = STATUS_SUCCESS;
	} while (0);
	return status;
} 
//----------------------------------------------------------------------------------------------------------//
NTSTATUS AllocateUsbHubList()
{
	NTSTATUS status = STATUS_UNSUCCESSFUL;
	do
	{
		if (!g_UsbHubList)
		{
			g_UsbHubList = (USB_HUB_LIST*)ExAllocatePoolWithTag(NonPagedPool, sizeof(USB_HUB_LIST), 'ldih');	
			if (!g_UsbHubList)
			{
 				status = STATUS_UNSUCCESSFUL;
				break;
			}
			RtlZeroMemory(g_UsbHubList, sizeof(USB_HUB_LIST));
		} 
		if (!g_UsbHubList->head)
		{
			g_UsbHubList->head = NewChainListHeaderEx(LISTFLAG_FTMUTEXLOCK | LISTFLAG_AUTOFREE, NULL, 0);
			if (!g_UsbHubList->head)
			{
				ExFreePool(g_UsbHubList);
				g_UsbHubList = NULL;
				status = STATUS_UNSUCCESSFUL;
				break;
			}
		}
		status = STATUS_SUCCESS;
	} while (0);
	return status;
} 

//----------------------------------------------------------------------------------------------------------//
NTSTATUS UnInitHidSubSystem()
{
	NTSTATUS status = STATUS_UNSUCCESSFUL;
	if (!g_IsHidModuleInit)
	{
		USB_DEBUG_INFO_LN_EX("UsbHid Resource Already Freed");
		return status;
	}

	status = FreeHidClientPdoList();
	
	status = FreeUsbHubList();
	
	g_IsHidModuleInit = FALSE;
	
	return status;
}
//----------------------------------------------------------------------------------------------------------//
NTSTATUS CreateUsbHubNode(
	_In_  PDRIVER_OBJECT DriverObject,
	_Out_ PUSBHUBNODE* Node
)
{
	USBHUBNODE* HubNode = NULL; 
	if(!Node || !DriverObject)
	{
		return STATUS_UNSUCCESSFUL;
	}
 
	HubNode = (USBHUBNODE*)ExAllocatePoolWithTag(NonPagedPool, sizeof(USBHUBNODE), 'bnhu');  
	if(HubNode)
	{	
 		if(KeGetCurrentIrql() < DISPATCH_LEVEL)
		{
			USB_DEBUG_INFO_LN_EX("DriverObject->DriverName.Buffer: %ws", DriverObject->DriverName.Buffer);
		}
		else
		{
			USB_DEBUG_INFO_LN_EX("IRQL TOO HIGH ");
		}
		RtlZeroMemory(HubNode, sizeof(USBHUBNODE));
		HubNode->HubNameLen   =  DriverObject->DriverName.Length;
		wcsncpy(HubNode->HubName, DriverObject->DriverName.Buffer, DriverObject->DriverName.Length);
		HubNode->HubDriverObject =  DriverObject; 
		HubNode->IsHooked		= FALSE;
	} 		 
	
	*Node = HubNode;
	
	return STATUS_SUCCESS;
}
//--------------------------------------------------------------------------------------------//
NTSTATUS AddUsbHubToList(
	_In_ PDRIVER_OBJECT HubDriverObj
)
{
	NTSTATUS status = STATUS_UNSUCCESSFUL;
	PVOID Value = NULL; 
	if(!HubDriverObj || !g_UsbHubList)
	{
		return status; 
	}
	
	if(!GetHashIndexById(g_UsbHubDrvObjHashTable, HASHSIZE, (ULONG_PTR)HubDriverObj, &Value))
	{
		CHAR DriverName[256]= {0};
		USBHUBNODE* HubNode = NULL;			
		status = CreateUsbHubNode(HubDriverObj, &HubNode); 
		if(HubNode && NT_SUCCESS(status))
		{
			SetHash(g_UsbHubDrvObjHashTable, HASHSIZE, (ULONG_PTR)HubDriverObj, HubDriverObj);
			if(AddToChainListTail(g_UsbHubList->head, HubNode))
			{
#ifdef DBG		
				if(KeGetCurrentIrql() < DISPATCH_LEVEL)
				{ 
					USB_DEBUG_INFO_LN_EX("Insert Success --- DriverName: %ws DriverObject: %I64x ", HubNode->HubName, HubNode->HubDriverObject);
				}
				else
				{
					USB_DEBUG_INFO_LN_EX("IRQL TOO HIGH ");
				}			
 #endif 					
					 
				g_UsbHubList->currentSize++;
					
				status = STATUS_SUCCESS; 
			}	 
		}
	}
	else
	{
		status = STATUS_SUCCESS;
	}
	
	return status; 
}
//--------------------------------------------------------------------------------------------//
NTSTATUS GetLowestDeviceObject(
	_In_  PDEVICE_OBJECT   DeviceObject,
	_Out_ PDEVICE_OBJECT* LowestDeviceObject
)
{
	WCHAR DeviceName[256] ={0};
	PDEVICE_OBJECT BackupDeviceObject = NULL;
	NTSTATUS status = STATUS_UNSUCCESSFUL; 
	if(!DeviceObject || !LowestDeviceObject)
	{
		return status; 
	}
	
	while(DeviceObject)
	{		 
		BackupDeviceObject	= DeviceObject;
#ifdef DBG
		if(KeGetCurrentIrql() < DISPATCH_LEVEL)
		{
			RtlZeroMemory(DeviceName, 256) ; 
			GetDeviceName(BackupDeviceObject, DeviceName);
			USB_DEBUG_INFO_LN_EX("UsbHub Stack: %ws DriverName: %ws", DeviceName, BackupDeviceObject->DriverObject->DriverName.Buffer);
		}
		else
		{
			USB_DEBUG_INFO_LN_EX("IRQL TOO HIGH ");
		}
#endif	
		DeviceObject = IoGetLowerDeviceObject(BackupDeviceObject);   
		if (DeviceObject)
	    {
	       ObDereferenceObject(DeviceObject);
	    }
	} 
	
	if(!DeviceObject)
	{
		*LowestDeviceObject = BackupDeviceObject;
		status = STATUS_SUCCESS;
	}
	
	return status ;
}
//--------------------------------------------------------------------------------------------//
/*
	
	Case 1: 						 
									 
		 ----------------		 
		| HID Client PDO |		 
		 ----------------        
				 |               
		------------------       
		| HID CLASS FDO  |       
		------------------       
				 |               
		------------------       
		|    UsbHub Fdo  |       
		------------------       
		                         
	

	Case 2 :	
	
		 ----------------		
		| HID Client PDO |		
         ----------------
        		 |
        ------------------
        | HID CLASS FDO  |
        ------------------
        		 |
        ------------------	 Next 	------------------	Next   ------------------
        |  UsbCcgp C-Pdo  | -----> |  UsbCcgp C-Pdo2  | ----> |  UsbCcgp C-Pdo3  |	
        ------------------          ------------------         ------------------ 
        		 /
       	------------------  
        | ccgp class Fdo1 |  <--- created by UsbHub  
       	------------------ 
				 | 			 <--- attach to Usbhub (AddDevice)
		------------------ 
		|   UsbHub's Fdo  |
		------------------ 
		
See: https://msdn.microsoft.com/en-us/library/windows/hardware/ff551670(v=vs.85).aspx


IRQL:	APC_LEVEL 

*/                      
ULONG __fastcall SearchUsbhubFromHidNodeCallback(
	_In_ PHID_DEVICE_NODE HidNode,
	_In_ void* 		  	  context
)
{ 
	
	PDRIVER_OBJECT UsbCcgpDO  = NULL ;   
	WCHAR DeviceName[256] = {0}; 
	PDEVICE_OBJECT HidClientPdo 		= NULL;
	PDEVICE_OBJECT HidFdo				= NULL;
	PDEVICE_OBJECT BackupDeviceObject	= NULL; 
	PDEVICE_OBJECT HubDeviceObject  	= NULL; 
	PDO_EXTENSION* PdoExt = NULL;
	FDO_EXTENSION* FdoExt = NULL;
	HIDCLASS_DEVICE_EXTENSION* 	HidCommonExt = NULL;
	
	if(context){}
	
	GetDriverObjectByName(L"\\Driver\\Usbccgp", &UsbCcgpDO);
	
	if(!g_UsbHubList || !HidNode->device_object)
	{
		return CLIST_FINDCB_RET;
	}
  
	//1. HID Basic 
	HidClientPdo = HidNode->device_object; //Hid Client Pdo
	
	HidCommonExt = (HIDCLASS_DEVICE_EXTENSION*)(HidNode->device_object->DeviceExtension);
	
	if(!HidCommonExt)
	{
		return CLIST_FINDCB_CTN;
	}
	
	PdoExt = GetClientPdoExtension(HidCommonExt);
	if(!PdoExt)
	{
		return CLIST_FINDCB_CTN;
	}
	
	FdoExt = GetFdoExtByClientPdoExt(PdoExt);
	if(!FdoExt)
	{
		return CLIST_FINDCB_CTN;
	}
	
	//1. Get Each Hid Fdo which we need to monitor  (name : HID_0000000X)
	HidFdo = FdoExt->fdo ; 
	
	//2. Get each HID lower-level device	
	if(!NT_SUCCESS(GetLowestDeviceObject(HidFdo, &BackupDeviceObject)))
	{
		return CLIST_FINDCB_CTN;
	}
	
	if(!BackupDeviceObject)
	{
		return CLIST_FINDCB_CTN;
	}
	
	//3. If Lowest level is ccgp ,  continue to get hub
	//case 2
 	if(BackupDeviceObject->DriverObject == UsbCcgpDO)
	{
		PDEVICE_OBJECT UsbCcgpClientPdo = UsbCcgpDO->DeviceObject;		
		
		//4. Enumerate Ccgp Device list
		while(UsbCcgpClientPdo)
		{		
			//change meaning
			PDEVICE_OBJECT UsbCcgpParentFdo = UsbCcgpClientPdo;  
			
			//5. Not UsbHub FDO , skip
			if(UsbCcgpClientPdo->AttachedDevice != NULL)
			{					
				//try to find next usb hub.
				UsbCcgpClientPdo = UsbCcgpClientPdo->NextDevice;  		
				continue;
			}
			
			//Found UsbHub FDO
			//6. enumerate its device stack unti the end , then it is going to UsbHub.
			if(!NT_SUCCESS(GetLowestDeviceObject(UsbCcgpParentFdo, &BackupDeviceObject)))
			{		
				UsbCcgpClientPdo = UsbCcgpClientPdo->NextDevice;  		
				continue;
			}
	
			AddUsbHubToList(BackupDeviceObject->DriverObject);
			g_UsbHubListInit = TRUE;
			
			//try to find next usb hub.
			UsbCcgpClientPdo = UsbCcgpClientPdo->NextDevice;  			
		}  
	}
	//case 1
	else
	{  
		AddUsbHubToList(BackupDeviceObject->DriverObject);
		g_UsbHubListInit = TRUE;
	}
	
	if(UsbCcgpDO)
	{
		ReleaseDriverObject(UsbCcgpDO);
		UsbCcgpDO = NULL;
	}
	return CLIST_FINDCB_CTN;
}

//-----------------------------------------------------------------------------------------------------------//
NTSTATUS GetAllUsbHub()
{ 	    
	NTSTATUS status = STATUS_UNSUCCESSFUL;
	
	USB_DEBUG_INFO_LN_EX("Enum GetAllUsbHub... "); 
	
	QueryFromChainListByCallback(g_HidClientPdoList->head, SearchUsbhubFromHidNodeCallback, NULL);
	
	if(g_UsbHubListInit)
	{	
		status = STATUS_SUCCESS; 
	}
	return status;
} 

//----------------------------------------------------------------------------------------------------------//
NTSTATUS InitHidSubSystem(
	_In_  HIDCONTEXT* Context,
	_Out_ PULONG 	  ClientPdoListSize)
{
 	PDRIVER_OBJECT	    pDriverObj = NULL;
	NTSTATUS			status = STATUS_UNSUCCESSFUL;

	do {   
		if (g_IsHidModuleInit)
		{
			USB_DEBUG_INFO_LN_EX("Module Already Init");  
			status = STATUS_SUCCESS;
			break; 
		}

		if (!NT_SUCCESS(AllocateClientPdoList()))
		{
			USB_DEBUG_INFO_LN_EX("Create List Error");
			status = STATUS_UNSUCCESSFUL;
			break;
		}
		
		if(!NT_SUCCESS(AllocateUsbHubList()))
		{				
			FreeUsbHubList();
			FreeHidClientPdoList(); 
			USB_DEBUG_INFO_LN_EX("Create List Error");
			status = STATUS_UNSUCCESSFUL;
			break;
		}
		if (!NT_SUCCESS(InitClientPdoList(Context, ClientPdoListSize)))
		{
			USB_DEBUG_INFO_LN_EX("Init HID List Error"); 
			FreeUsbHubList();
			FreeHidClientPdoList();
			status = STATUS_UNSUCCESSFUL;
			break;
		} 
	
		if (!NT_SUCCESS(GetAllUsbHub()))
		{			
			USB_DEBUG_INFO_LN_EX("Init USBhub List Error"); 
			FreeUsbHubList();
			FreeHidClientPdoList();
			status = STATUS_UNSUCCESSFUL;
			break;
		}
		
		if (g_HidClientPdoList && g_UsbHubList->currentSize > 0 )
		{
			g_HidClientPdoList->RefCount = 1; 
			USB_DEBUG_INFO_LN_EX("Create Success list: %I64x currentSize: %x ", g_HidClientPdoList, g_UsbHubList->currentSize );
			g_IsHidModuleInit = TRUE; 
			status = STATUS_SUCCESS;
			break;
		}
		
	} while (FALSE);
	return status;
}

//---------------------------------------------------------------------------------------------------------//
NTSTATUS FreeHidClientPdoList()
{
	NTSTATUS status = STATUS_UNSUCCESSFUL;
	//Free White List
 
	if (g_HidClientPdoList)
	{
		if (g_HidClientPdoList->head)
		{
			CHAINLIST_SAFE_FREE(g_HidClientPdoList->head);
		}
		ExFreePool(g_HidClientPdoList);
		g_HidClientPdoList	  = NULL; 
		status = STATUS_SUCCESS;
	}

	return status;
} 
//---------------------------------------------------------------------------------------------------------//
NTSTATUS FreeUsbHubList()
{
	NTSTATUS status = STATUS_UNSUCCESSFUL;
	//Free White List
 
	if (g_UsbHubList)
	{
		if (g_UsbHubList->head)
		{
			CHAINLIST_SAFE_FREE(g_UsbHubList->head);
		}
		ExFreePool(g_UsbHubList);
		g_UsbHubList	  = NULL; 
		status = STATUS_SUCCESS;
		
		USB_DEBUG_INFO_LN_EX("Free Hub List ");
	}
	  
	RtlZeroMemory(g_UsbHubDrvObjHashTable, HASHSIZE);
	USB_DEBUG_INFO_LN_EX("Free Hub hash table ");
	
	RtlZeroMemory(g_HidDevicePipeHashTable, HASHSIZE);
	USB_DEBUG_INFO_LN_EX("Free Device hash table ");

	RtlZeroMemory(g_ThirdPartyHidDevice	, HASHSIZE);
	USB_DEBUG_INFO_LN_EX("Free Device hash table ");
	
	g_UsbHubListInit = FALSE;
	
	return status;
} 
//---------------------------------------------------------------------------------------------------------// 
```

`UsbMon/UsbMon/UsbHid.h`:

```h
#ifndef __USB_HID_HEADER__
#define __USB_HID_HEADER__ 

#include <fltKernel.h>  
#include "CommonUtil.h"
#include "local.h"
#include "UsbType.h"

#define HID_USB_DEVICE				 	 L"\\Driver\\hidusb"


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:
		Determine is it HID device pipe

Arguments:
		TChainListHeader - list header of HID device pipe
		handle			 - handle of HID device pipe 
		node			 - output node which is found
		 
Return Value:	
		BOOLEAN			 - true  , if it handle in list
						 - false , Depended on old completion
-----------------------------------------------------------------------------------*/
BOOLEAN  IsHidDevicePipe(
	_In_ TChainListHeader* PipeListHeader,
	_In_ USBD_PIPE_HANDLE  PipeHandle,
	_Out_ PHID_DEVICE_NODE*  node
);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:
		UnInitialize Hid Sub System, Simply free the list

Arguments:
 		 No 

Return Value:	
		NTSTATUS		 - STATUS_SUCCESS      , if it is Freed
						 - STATUS_UNSUCCESSFUL , if is can't be freed
-----------------------------------------------------------------------------------*/
NTSTATUS UnInitHidSubSystem();

 
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:
		Initialize Hid Sub System, Simply free the list
			1. Allocate Client Pdo List memory
			2. Init Client Pdo List by getting all of client PDO
	 
Arguments:
		 ULONG			 - Size of List 
		 
Return Value:	
		NTSTATUS		 - true  , if it initial succesfully
						 - false , if it initial faile
-----------------------------------------------------------------------------------*/
NTSTATUS InitHidSubSystem(
	_In_  HIDCONTEXT* Context,
	_Out_ PULONG 	  ClientPdoListSize);


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:
		1. To verify a Device Object, determine is it that hid type we need to catch up 
		2. If verify success, Insert Node into a list
	 
Arguments:
		PDEVICE_OBJECT	 - Pointer of Deivce object that is going to be identified
		 
Return Value:	
		NTSTATUS		 - STATUS_SUCCESS	   , if it is hid device and Insert succesfully
						 - STATUS_UNSUCCESSFUL , if it is hid device and unsuccessfully
-----------------------------------------------------------------------------------*/
NTSTATUS VerifyAndInsertIntoHidList(
	_In_ PDEVICE_OBJECT DeviceObject,
	_In_ HIDCONTEXT*	Context
);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:
		1. Remove a node for the device object in the internal list
	 
Arguments:
		PDEVICE_OBJECT	 - Pointer of Deivce object that is going to be removed

		 
Return Value:	
		NTSTATUS		 - STATUS_SUCCESS	   , if it Remove succesfully
						 - STATUS_UNSUCCESSFUL , if it Remove unsuccessfully
-----------------------------------------------------------------------------------*/
NTSTATUS RemoveNodeFromHidList(
	_In_ PDEVICE_OBJECT DeviceObject
); 
 
#endif
```

`UsbMon/UsbMon/UsbMon.inf`:

```inf
;
; StackTrace.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=StackTrace.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages
 

[DestinationDirs]
DefaultDestDir = 12


[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]


[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]


[Strings]
ManufacturerName="StackTrace"
ClassName=""
DiskName="StackTrace Source Disk"

```

`UsbMon/UsbMon/UsbMon.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 14
VisualStudioVersion = 14.0.25420.1
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "UsbMon", "UsbMon\UsbMon.vcxproj", "{7E68057F-E333-4F45-8C91-7E280838FF63}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{7E68057F-E333-4F45-8C91-7E280838FF63}.Debug|ARM.ActiveCfg = Debug|ARM
		{7E68057F-E333-4F45-8C91-7E280838FF63}.Debug|ARM.Build.0 = Debug|ARM
		{7E68057F-E333-4F45-8C91-7E280838FF63}.Debug|ARM.Deploy.0 = Debug|ARM
		{7E68057F-E333-4F45-8C91-7E280838FF63}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{7E68057F-E333-4F45-8C91-7E280838FF63}.Debug|ARM64.Build.0 = Debug|ARM64
		{7E68057F-E333-4F45-8C91-7E280838FF63}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{7E68057F-E333-4F45-8C91-7E280838FF63}.Debug|x64.ActiveCfg = Debug|x64
		{7E68057F-E333-4F45-8C91-7E280838FF63}.Debug|x64.Build.0 = Debug|x64
		{7E68057F-E333-4F45-8C91-7E280838FF63}.Debug|x64.Deploy.0 = Debug|x64
		{7E68057F-E333-4F45-8C91-7E280838FF63}.Debug|x86.ActiveCfg = Debug|Win32
		{7E68057F-E333-4F45-8C91-7E280838FF63}.Debug|x86.Build.0 = Debug|Win32
		{7E68057F-E333-4F45-8C91-7E280838FF63}.Debug|x86.Deploy.0 = Debug|Win32
		{7E68057F-E333-4F45-8C91-7E280838FF63}.Release|ARM.ActiveCfg = Release|ARM
		{7E68057F-E333-4F45-8C91-7E280838FF63}.Release|ARM.Build.0 = Release|ARM
		{7E68057F-E333-4F45-8C91-7E280838FF63}.Release|ARM.Deploy.0 = Release|ARM
		{7E68057F-E333-4F45-8C91-7E280838FF63}.Release|ARM64.ActiveCfg = Release|ARM64
		{7E68057F-E333-4F45-8C91-7E280838FF63}.Release|ARM64.Build.0 = Release|ARM64
		{7E68057F-E333-4F45-8C91-7E280838FF63}.Release|ARM64.Deploy.0 = Release|ARM64
		{7E68057F-E333-4F45-8C91-7E280838FF63}.Release|x64.ActiveCfg = Release|x64
		{7E68057F-E333-4F45-8C91-7E280838FF63}.Release|x64.Build.0 = Release|x64
		{7E68057F-E333-4F45-8C91-7E280838FF63}.Release|x64.Deploy.0 = Release|x64
		{7E68057F-E333-4F45-8C91-7E280838FF63}.Release|x86.ActiveCfg = Release|Win32
		{7E68057F-E333-4F45-8C91-7E280838FF63}.Release|x86.Build.0 = Release|Win32
		{7E68057F-E333-4F45-8C91-7E280838FF63}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`UsbMon/UsbMon/UsbMon.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{7E68057F-E333-4F45-8C91-7E280838FF63}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>UsbMon</RootNamespace>
    <ProjectName>UsbMon</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <CallingConvention>FastCall</CallingConvention>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
    </ClCompile>
    <Link>
      <AdditionalDependencies>%(AdditionalDependencies);$(KernelBufferOverflowLib);$(DDK_LIB_PATH)ntoskrnl.lib;$(DDK_LIB_PATH)hal.lib;$(DDK_LIB_PATH)wmilib.lib;hidparse.lib;win32k.lib</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <TreatLinkerWarningAsErrors>false</TreatLinkerWarningAsErrors>
    </Link>
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
    </ClCompile>
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="UsbMon.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="HidHijack.h" />
    <ClInclude Include="OpenLoopBuffer.h" />
    <ClInclude Include="ReportUtil.h" />
    <ClInclude Include="hidtoken.h" />
    <ClInclude Include="IrpHook.h" />
    <ClInclude Include="TList.h" />
    <ClInclude Include="UsbHid.h" />
    <ClInclude Include="UsbType.h" />
    <ClInclude Include="UsbUtil.h" />
    <ClInclude Include="CommonUtil.h" />
    <ClInclude Include="WinParse.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Driver.c" />
    <ClCompile Include="HidHijack.c" />
    <ClCompile Include="OpenLoopBuffer.c" />
    <ClCompile Include="ReportUtil.c" />
    <ClCompile Include="WinParse.c" />
    <ClCompile Include="IrpHook.c" />
    <ClCompile Include="TList.c" />
    <ClCompile Include="UsbHid.c" />
    <ClCompile Include="UsbUtil.c" />
    <ClCompile Include="CommonUtil.c" />
  </ItemGroup>
  <ItemGroup>
    <Text Include="Readme.txt" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`UsbMon/UsbMon/UsbMon.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="UsbMon.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="UsbType.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="UsbUtil.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="CommonUtil.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IrpHook.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="TList.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="UsbHid.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="WinParse.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="hidtoken.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ReportUtil.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="HidHijack.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="OpenLoopBuffer.h">
      <Filter>Source Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Driver.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="UsbUtil.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="CommonUtil.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="UsbHid.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IrpHook.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="TList.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="WinParse.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ReportUtil.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="HidHijack.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="OpenLoopBuffer.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <Text Include="Readme.txt" />
  </ItemGroup>
</Project>
```

`UsbMon/UsbMon/UsbMon.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`UsbMon/UsbMon/UsbMon/Driver.c`:

```c
 
#include <fltKernel.h>
#include "Util.h" 
#include "usb.h"
#include "Usbioctl.h"
#include "LinkedList.h"
#include "Hidport.h"
#pragma warning (disable : 4100)

extern POBJECT_TYPE *IoDriverObjectType;

extern NTSTATUS ObReferenceObjectByName(
	PUNICODE_STRING ObjectName,
	ULONG Attributes,
	PACCESS_STATE AccessState,
	ACCESS_MASK DesiredAccess,
	POBJECT_TYPE ObjectType,
	KPROCESSOR_MODE AccessMode,
	PVOID ParseContext,
	PVOID *Object
); 

DRIVER_DISPATCH* pDispatchInternalDeviceControl;

volatile LONG g_irp_count = 0;

typedef struct PENDINGIRP
{
	RT_LIST_ENTRY entry;
	PIRP irp; 
}PENDINGIRP, *PPENDINGIRP;
  
typedef struct HIJACK_CONTEXT
{
	PDEVICE_OBJECT		  DeviceObject;
	PIRP				  Irp;
	PVOID				  Context;
	IO_COMPLETION_ROUTINE* routine;
	PURB				  urb;
	PENDINGIRP*			  pending_irp;
}HIJACK_CONTEXT, *PHIJACK_CONTEXT;

typedef enum
{
	USB = 0,
	USB2 ,
	USB3 ,
}USB_HUB_VERSION;

PENDINGIRP head;
VOID	   DumpUrb(PURB urb); 
NTSTATUS   GetUsbHub(USB_HUB_VERSION usb_hub_version, PDRIVER_OBJECT* pDriverObj);
 

//-----------------------------------------------------------------------------------------
 VOID RemoveAllPendingIrpFromList()
 { 
	 RT_LIST_ENTRY* pEntry = head.entry.Flink;
	 while (pEntry != &head.entry && !pEntry)
	 {
		 PENDINGIRP* pStrct;
		 pStrct = CONTAINING_RECORD(pEntry, PENDINGIRP, entry);
		 if (pStrct)
		 {
			 if (pStrct->irp)
			 { 
				 IoCancelIrp(pStrct->irp);
			 }
			 if (&(pStrct->entry))
			 {
				 RTRemoveEntryList(&(pStrct->entry));
			 } 
			 ExFreePool(pStrct);
		 }
		 pEntry = pEntry->Flink;
	 } 
 } 
 
 
 PVOID  ThreadObject = NULL;
//-----------------------------------------------------------------------------------------
VOID DriverUnload(
	_In_ struct _DRIVER_OBJECT *DriverObject
)
{
	UNREFERENCED_PARAMETER(DriverObject);
	 
	//RemoveAllPendingIrpFromList();
	

	PDRIVER_OBJECT pDriverObj = NULL; 

	if (NT_SUCCESS(GetUsbHub(USB3, &pDriverObj)))
	{
		if (pDriverObj)
		{
			InterlockedExchange64((LONG64 volatile *)&pDriverObj->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL], (LONG64)pDispatchInternalDeviceControl);
			STACK_TRACE_DEBUG_INFO("Unloaded Driver");
		}
	} 
	
	while (g_irp_count)
	{
		KeSleep(0);
	}
	 
	STACK_TRACE_DEBUG_INFO("IRP finished All \r\n"); 
	return;
}
//----------------------------------------------------------------------------------------//
NTSTATUS  MyCompletionCallback(
	_In_     PDEVICE_OBJECT DeviceObject,
	_In_     PIRP           Irp,
	_In_opt_ PVOID          Context
)
{ 
	HIJACK_CONTEXT* pContext = (HIJACK_CONTEXT*)Context;
	  
 	DumpUrb(pContext->urb);

	RTRemoveEntryList(&pContext->pending_irp->entry);  

	if (&pContext->pending_irp->entry)
	{
		ExFreePool(&pContext->pending_irp->entry);
	}
	// Extract HIJACK_CONTEXT

	// ......................

	// if mouse 
	// ....
	// if keyboard 
	// ....

	//Extract HIJACK_CONTEXT

	InterlockedDecrement(&g_irp_count);

	return pContext->routine(DeviceObject, Irp, pContext->Context);
}
NTSTATUS CheckDeviceObject(PDEVICE_OBJECT device_object) 
{ 

	return STATUS_SUCCESS;
}
//----------------------------------------------------------------------------------------// 
NTSTATUS DispatchInternalDeviceControl(
	_Inout_ struct _DEVICE_OBJECT *DeviceObject,
	_Inout_ struct _IRP           *Irp
)
{

	PIO_STACK_LOCATION irpStack = NULL; 
	PURB urb = NULL;
	irpStack = IoGetCurrentIrpStackLocation(Irp);
	urb = (PURB)irpStack->Parameters.Others.Argument1;
	if (irpStack->Parameters.DeviceIoControl.IoControlCode == IOCTL_INTERNAL_USB_SUBMIT_URB)
	{ 
		 
 		
		if (urb->UrbHeader.Function == URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER)
		{
			 
			HIJACK_CONTEXT* hijack	   = (HIJACK_CONTEXT*)ExAllocatePoolWithTag(NonPagedPool, sizeof(HIJACK_CONTEXT), 'kcaj'); 
			PENDINGIRP*		new_entry  = (PENDINGIRP*)ExAllocatePoolWithTag(NonPagedPool, sizeof(PENDINGIRP), 'kcaj');		
			
			// TODO: Insert if keyboard / mouse device
			new_entry->irp = Irp;
			RTInsertTailList(&head.entry, &new_entry->entry); 

			hijack->routine = irpStack->CompletionRoutine;
			hijack->Context = irpStack->Context;
			hijack->DeviceObject = DeviceObject;
			hijack->Irp = Irp;
			hijack->urb = urb;
			hijack->pending_irp = new_entry;

			irpStack->CompletionRoutine = MyCompletionCallback;
			irpStack->Context = hijack;
 
			InterlockedIncrement(&g_irp_count);
		}
	}  
	return pDispatchInternalDeviceControl(DeviceObject, Irp);
}

//----------------------------------------------------------------------------------------//
WCHAR* GetUsbHubDriverNameByVersion(USB_HUB_VERSION usb_hub_version) 
{
	WCHAR* ret = L"";
	switch (usb_hub_version)
	{
		case USB:
			ret = L"\\Driver\\usbhub";
		case USB2:
			ret = L"\\Driver\\usbhub"; 
		case USB3:
			ret = L"\\Driver\\iusb3hub"; 
	} 
	return ret;
} 
//----------------------------------------------------------------------------------------//
NTSTATUS GetUsbHub(USB_HUB_VERSION usb_hub_version , PDRIVER_OBJECT* pDriverObj)
{
	// use such API  
	NTSTATUS status			  = STATUS_SUCCESS;
	UNICODE_STRING DriverName = { 0 };

	WCHAR* Usbhub			  =	 GetUsbHubDriverNameByVersion(usb_hub_version);

	RtlInitUnicodeString(&DriverName, Usbhub);

	status = ObReferenceObjectByName(
		&DriverName,
		OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE,
		NULL,
		0,
		*IoDriverObjectType,
		KernelMode,
		NULL,
		(PVOID*) pDriverObj);

	return status;
}

//----------------------------------------------------------------------------------------//
NTSTATUS DriverEntry(PDRIVER_OBJECT object, PUNICODE_STRING String)
{

	PDRIVER_OBJECT pDriverObj;

	RTInitializeListHead(&head.entry);
  
	WCHAR* Usbhub = GetUsbHubDriverNameByVersion(USB);  
	STACK_TRACE_DEBUG_INFO("Usb Hun: %ws \r\n", Usbhub);

	WCHAR* Usbhub2 = GetUsbHubDriverNameByVersion(USB2); 
	STACK_TRACE_DEBUG_INFO("Usb Hun2: %ws \r\n", Usbhub2);

	WCHAR* Usbhub3 = GetUsbHubDriverNameByVersion(USB3); 
	STACK_TRACE_DEBUG_INFO("Usb Hun3: %ws \r\n", Usbhub3);

	pDriverObj = NULL;
	GetUsbHub(USB3, &pDriverObj);

	if (pDriverObj)
	{
		STACK_TRACE_DEBUG_INFO("DriverObj: %I64X \r\n", pDriverObj);
		pDispatchInternalDeviceControl = (DRIVER_DISPATCH*)InterlockedExchange64(
			(LONG64 volatile *)&pDriverObj->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL],
			(LONG64)DispatchInternalDeviceControl
		);
	}   

	object->DriverUnload = DriverUnload;

	return 0;
}
 
```

`UsbMon/UsbMon/UsbMon/LinkedList.h`:

```h
#ifndef __INC_LINKLIST_H
#define __INC_LINKLIST_H

//
//  Doubly linked list structure.  Can be used as either a list head, or
//  as link words.
//
typedef struct _RT_LIST_ENTRY {
	struct _RT_LIST_ENTRY *Flink;
	struct _RT_LIST_ENTRY *Blink;
} RT_LIST_ENTRY, *PRT_LIST_ENTRY;

#define	RTIsUnInitializedListHead(ListHead)	\
	(NULL == (ListHead)->Flink || NULL == (ListHead)->Blink)

#define	RTIsListHead(ListHead, __Entry)	\
	((ListHead) == (__Entry))

//
//  Doubly-linked list manipulation routines.  Implemented as macros
//
#define RTInitializeListHead(ListHead)				\
	((ListHead)->Flink = (ListHead)->Blink = (ListHead))


#define RTIsListEmpty(ListHead)					\
	((ListHead)->Flink == NULL || (ListHead)->Flink == (ListHead))

#define RTIsListNotEmpty(ListHead)					\
	((ListHead)->Flink != (ListHead))

#define RTGetHeadList(ListHead)					\
	((ListHead)->Flink)

#define RTGetTailList(ListHead)					\
	(ListHead)->Blink

#define RTRemoveHeadList(ListHead)				\
	(ListHead)->Flink;							\
	{RTRemoveEntryList((ListHead)->Flink)}


#define RTRemoveTailList(ListHead)				\
	(ListHead)->Blink;							\
	{RTRemoveEntryList((ListHead)->Blink)}


#define RTNextEntryList(Entry)					\
	(Entry)->Flink

#define RTForeEntryList(Entry)					\
	(Entry)->Blink


#define RTRemoveEntryList(Entry)					\
	{											\
		PRT_LIST_ENTRY _EX_Blink;					\
		PRT_LIST_ENTRY _EX_Flink;					\
		_EX_Flink = (Entry)->Flink;					\
		_EX_Blink = (Entry)->Blink;				\
		_EX_Blink->Flink = _EX_Flink;				\
		_EX_Flink->Blink = _EX_Blink;				\
	}


#define RTInsertTailList(ListHead,Entry)			\
	{											\
		PRT_LIST_ENTRY _EX_Blink;					\
		PRT_LIST_ENTRY _EX_ListHead;				\
		_EX_ListHead = (ListHead);					\
		_EX_Blink = _EX_ListHead->Blink;			\
		(Entry)->Flink = _EX_ListHead;				\
		(Entry)->Blink = _EX_Blink;				\
		_EX_Blink->Flink = (Entry);					\
		_EX_ListHead->Blink = (Entry);				\
	}


#define RTInsertHeadList(ListHead,Entry)			\
	{											\
		PRT_LIST_ENTRY _EX_Flink;					\
		PRT_LIST_ENTRY _EX_ListHead;				\
		_EX_ListHead = (ListHead);					\
		_EX_Flink = _EX_ListHead->Flink;			\
		(Entry)->Flink = _EX_Flink;					\
		(Entry)->Blink = _EX_ListHead;				\
		_EX_Flink->Blink = (Entry);					\
		_EX_ListHead->Flink = (Entry);				\
	}


#define RTPopEntryList(ListHead)					\
	(ListHead)->Next;							\
	{											\
		PRT_SINGLE_LIST_ENTRY FirstEntry;			\
		FirstEntry = (ListHead)->Next;				\
		if (FirstEntry != NULL)						\
		{										\
			(ListHead)->Next = FirstEntry->Next;	\
		}										\
	}


#define RTPushEntryList(ListHead,Entry)			\
	(Entry)->Next = (ListHead)->Next;				\
	(ListHead)->Next = (Entry)

// Insert __InsertedEntry before __Entry
#define	RTInsertEntryBeforeEntry(__InsertedEntry,	__Entry)	\
	{											\
		PRT_LIST_ENTRY _EX_Blink;					\
		_EX_Blink = (__Entry)->Blink;				\
		_EX_Blink->Flink = (__InsertedEntry);			\
		(__InsertedEntry)->Blink = _EX_Blink;			\
		(__InsertedEntry)->Flink = (__Entry);			\
		(__Entry)->Blink = (__InsertedEntry);			\
	}

// Insert __InsertedEntry after __Entry
#define	RTInsertEntryAfterEntry(__InsertedEntry,	__Entry)	\
	{											\
		PRT_LIST_ENTRY _EX_Flink;					\
		_EX_Flink = (__Entry)->Flink;				\
		_EX_Flink->Blink = (__InsertedEntry);			\
		(__InsertedEntry)->Flink = _EX_Flink;			\
		(__InsertedEntry)->Blink = (__Entry);			\
		(__Entry)->Flink = (__InsertedEntry);			\
	}

//---------------------------------------------------------------------------
// The following MACROs do the same with the above MACROs except the Cnt parameter.
// Cnt is a pointer to counter which will be modified.

#define RTRemoveHeadListWithCnt(ListHead,Cnt)				\
	(ListHead)->Flink;										\
	RTRemoveEntryListWithCnt((ListHead)->Flink, Cnt)

#define RTRemoveTailListWithCnt(ListHead,Cnt)					\
	(ListHead)->Blink;										\
	RTRemoveEntryListWithCnt((ListHead)->Blink, Cnt)

#define RTRemoveEntryListWithCnt(Entry,Cnt)					\
	RTRemoveEntryList(Entry)								\
	(*Cnt)--;

#define RTInsertTailListWithCnt(ListHead,Entry,Cnt)				\
	RTInsertTailList(ListHead,Entry)							\
	(*Cnt)++;

#define RTInsertHeadListWithCnt(ListHead,Entry,Cnt)			\
	RTInsertHeadList(ListHead,Entry)							\
	(*Cnt)++;

#define RTPopEntryListWithCnt(ListHead,Cnt)					\
	RTPopEntryList(ListHead)									\
	(*Cnt)--;

#define RTPushEntryListWithCnt(ListHead,Entry,Cnt)				\
	RTPushEntryList(ListHead,Entry)							\
	(*Cnt)++;



#define RTSwitchListHead(orgListHead,	newListHead)			\
{															\
	RTNextEntryList(newListHead) = RTNextEntryList(orgListHead);	\
	RTForeEntryList(RTNextEntryList(orgListHead)) = newListHead;	\
	RTNextEntryList(RTForeEntryList(orgListHead)) = newListHead;	\
	RTForeEntryList(newListHead) = RTForeEntryList(orgListHead);	\
	RTInitializeListHead(orgListHead);						\
}	

#define RtEntryListForEach(__pListHead, __itEntry) \
	for((__itEntry) = RTGetHeadList((__pListHead)); \
		(__itEntry) != (__pListHead); \
		(__itEntry) = RTNextEntryList((__itEntry)) \
		)

#define RtEntryListForEachSafe(__pListHead, __itEntry, __n) \
	for((__itEntry) = RTGetHeadList((__pListHead)), \
			(__n) = (__itEntry)->Flink; \
		(__itEntry) != (__pListHead); \
		(__itEntry) = (__n), (__n) = RTNextEntryList((__n)) \
		)

//
//  Singly linked list structure. 
//  Only used as link words.
//
typedef struct _RT_SINGLE_LIST_ENTRY {
	struct _RT_SINGLE_LIST_ENTRY *Next;
} RT_SINGLE_LIST_ENTRY, *PRT_SINGLE_LIST_ENTRY;

//
//  Singly linked list structure. 
//  Only used as link head.
//
typedef struct _RT_SINGLE_LIST_HEAD {
	PRT_SINGLE_LIST_ENTRY First;
	PRT_SINGLE_LIST_ENTRY Last;
} RT_SINGLE_LIST_HEAD, *PRT_SINGLE_LIST_HEAD;



//
//	Single link list routines.
//
#define RTInitializeSListHead(SListHead) \
	((SListHead)->First = (SListHead)->Last = NULL)

#define RTIsSListEmpty(SListHead) \
	((SListHead)->First == NULL)

#define RTGetHeadSList(SListHead) \
	(PRT_SINGLE_LIST_ENTRY)((SListHead)->First)

#define RTGetTailSList(SListHead) \
	(PRT_SINGLE_LIST_ENTRY)((SListHead)->Last)

#define RTRemoveHeadSList(SListHead) \
	RTGetHeadSList(SListHead); \
	RT_ASSERT(!RTIsSListEmpty(SListHead), ("RTRemoveHeadSList(): SList(%p) is empty!!!\n", SListHead)); \
	{ \
		PRT_SINGLE_LIST_ENTRY pToRemove = (SListHead)->First; \
		if((SListHead)->First == (SListHead)->Last) \
		{ \
			(SListHead)->First = (SListHead)->Last = NULL; \
		} \
		else \
		{ \
			(SListHead)->First = pToRemove->Next; \
		} \
		pToRemove->Next = NULL; \
	}

#define RTInsertTailSList(SListHead, SListEntry) \
	{ \
		PRT_SINGLE_LIST_ENTRY pOldTail = (SListHead)->Last; \
		(SListEntry)->Next = NULL; \
		if(RTIsSListEmpty(SListHead)) \
		{ \
			(SListHead)->First = (SListHead)->Last = SListEntry; \
		} \
		else \
		{ \
			pOldTail->Next = SListEntry; \
			(SListHead)->Last = SListEntry; \
		} \
	}


#endif // #ifndef __INC_LINKLIST_H
```

`UsbMon/UsbMon/UsbMon/UsbMon.inf`:

```inf
;
; StackTrace.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=StackTrace.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages
 

[DestinationDirs]
DefaultDestDir = 12


[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]


[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]


[Strings]
ManufacturerName="StackTrace"
ClassName=""
DiskName="StackTrace Source Disk"

```

`UsbMon/UsbMon/UsbMon/UsbMon.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{7E68057F-E333-4F45-8C91-7E280838FF63}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>UsbMon</RootNamespace>
    <ProjectName>UsbMon</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <CallingConvention>FastCall</CallingConvention>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="UsbMon.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="LinkedList.h" />
    <ClInclude Include="Util.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Driver.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`UsbMon/UsbMon/UsbMon/UsbMon.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="UsbMon.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Util.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="LinkedList.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Driver.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`UsbMon/UsbMon/UsbMon/UsbMon.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`UsbMon/UsbMon/UsbMon/Util.h`:

```h
#pragma once
#include "usb.h"
/// Sets a break point that works only when a debugger is present
#if !defined(HYPERPLATFORM_COMMON_DBG_BREAK)
#define STACK_TRACE_COMMON_DBG_BREAK() \
  if (KD_DEBUGGER_NOT_PRESENT) {         \
  } else {                               \
    __debugbreak();                      \
  }                                      \
  (void*)(0)
#endif

#define STACK_TRACE_DEBUG_INFO(format, ...) DbgPrintEx(0,0,format,__VA_ARGS__)

#define DELAY_ONE_MICROSECOND 	(-10)
#define DELAY_ONE_MILLISECOND	(DELAY_ONE_MICROSECOND*1000)

VOID KeSleep(LONG msec)
{
	LARGE_INTEGER my_interval;
	my_interval.QuadPart = DELAY_ONE_MILLISECOND;
	my_interval.QuadPart *= msec;
	KeDelayExecutionThread(KernelMode, 0, &my_interval);
} 

VOID DumpUrb(PURB urb)
{
	struct _URB_HEADER urb_header = urb->UrbHeader;;

	STACK_TRACE_DEBUG_INFO("---------------URB HEADER------------- \r\n");
	STACK_TRACE_DEBUG_INFO("- Length: %x \r\n", urb_header.Length);
	STACK_TRACE_DEBUG_INFO("- Function: %x \r\n", urb_header.Function);
	STACK_TRACE_DEBUG_INFO("- Status: %x \r\n", urb_header.Status);
	STACK_TRACE_DEBUG_INFO("- UsbdDeviceHandle: %x \r\n", urb_header.UsbdDeviceHandle);
	STACK_TRACE_DEBUG_INFO("- UsbdFlags: %x \r\n", urb_header.UsbdFlags);
	STACK_TRACE_DEBUG_INFO("---------------URB Function------------- \r\n"); 
	switch (urb_header.Function)
	{
#if (NTDDI_VERSION >= NTDDI_WIN8)
	case URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER_USING_CHAINED_MDL:
		break;
	case URB_FUNCTION_OPEN_STATIC_STREAMS:
		break;
	case URB_FUNCTION_CLOSE_STATIC_STREAMS:
		break;
#endif
	case URB_FUNCTION_SELECT_CONFIGURATION:
		break;
	case URB_FUNCTION_SELECT_INTERFACE:
		break;
	case URB_FUNCTION_ABORT_PIPE:
		break;
	case URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL:
		break;
	case URB_FUNCTION_RELEASE_FRAME_LENGTH_CONTROL:
		break;
	case URB_FUNCTION_GET_FRAME_LENGTH:
		break;
	case URB_FUNCTION_SET_FRAME_LENGTH:
		break;
	case URB_FUNCTION_GET_CURRENT_FRAME_NUMBER:
		break;
	case URB_FUNCTION_CONTROL_TRANSFER:
		break;
	case URB_FUNCTION_CONTROL_TRANSFER_EX:
		break;
	case URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER:
	{
		//			struct _URB_BULK_OR_INTERRUPT_TRANSFER* data  = (struct _URB_BULK_OR_INTERRUPT_TRANSFER*) &urb->UrbHeader;

		//			STACK_TRACE_COMMON_DBG_BREAK("_URB_BULK_OR_INTERRUPT_TRANSFER \r\n"); 
		/*			if (data->TransferFlags & USBD_TRANSFER_DIRECTION_IN)
		{
		STACK_TRACE_COMMON_DBG_BREAK("USBD_TRANSFER_DIRECTION_IN \r\n");
		}
		if (data->TransferFlags & USBD_TRANSFER_DIRECTION_OUT)
		{
		STACK_TRACE_COMMON_DBG_BREAK("USBD_TRANSFER_DIRECTION_OUT \r\n");

		}
		if (data->TransferFlags & USBD_SHORT_TRANSFER_OK)
		{
		STACK_TRACE_COMMON_DBG_BREAK("USBD_SHORT_TRANSFER_OK \r\n");
		}*/

	}
	break;
	case URB_FUNCTION_RESET_PIPE:
		break;
	case URB_FUNCTION_SYNC_RESET_PIPE:
		break;
	case URB_FUNCTION_SYNC_CLEAR_STALL:
		break;
	case URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE:
		break;
	case URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT:
		break;
	case URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE:
		break;
	case URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT:
		break;
	case URB_FUNCTION_SET_FEATURE_TO_DEVICE:
		break;
	case URB_FUNCTION_SET_FEATURE_TO_INTERFACE:
		break;
	case URB_FUNCTION_SET_FEATURE_TO_ENDPOINT:
		break;
	case URB_FUNCTION_SET_FEATURE_TO_OTHER:
		break;
	case URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE:
		break;
	case URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE:
		break;
	case URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT:
		break;
	case URB_FUNCTION_CLEAR_FEATURE_TO_OTHER:
		break;
	case URB_FUNCTION_GET_STATUS_FROM_DEVICE:
		break;
	case URB_FUNCTION_GET_STATUS_FROM_INTERFACE:
		break;
	case URB_FUNCTION_GET_STATUS_FROM_ENDPOINT:
		break;
	case URB_FUNCTION_GET_STATUS_FROM_OTHER:
		break;
	case URB_FUNCTION_VENDOR_DEVICE:
		break;
	case URB_FUNCTION_VENDOR_INTERFACE:
		break;
	case URB_FUNCTION_VENDOR_ENDPOINT:
		break;
	case URB_FUNCTION_VENDOR_OTHER:
		break;
	case URB_FUNCTION_CLASS_DEVICE:
		break;
	case URB_FUNCTION_CLASS_INTERFACE:
		break;
	case URB_FUNCTION_CLASS_ENDPOINT:
		break;
	case URB_FUNCTION_CLASS_OTHER:
		break;
	case URB_FUNCTION_GET_CONFIGURATION:
		break;
	case URB_FUNCTION_GET_INTERFACE:
		break;
	case URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE:
		break;
	case URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE:
		break;
	case URB_FUNCTION_GET_MS_FEATURE_DESCRIPTOR:
		break;

	}
}




```

`UsbMon/UsbMon/UsbMon/x64/Debug/StackTrace.Build.CppClean.log`:

```log
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\vc140.pdb
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\driver.obj
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\x64\debug\stacktrace\stacktrace.cat
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\x64\debug\stacktrace.sys
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\x64\debug\stacktrace.pdb
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\x64.obj
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.inf
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\x64\debug\stacktrace.cer
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\x64\debug\stacktrace.inf
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.tlog\cl.command.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.tlog\cl.read.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.tlog\cl.write.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.tlog\inf2cat-expand.11928.read.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.tlog\inf2cat-expand.11928.write.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.tlog\inf2cat-expand.read.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.tlog\inf2cat-expand.write.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.tlog\inf2cat.command.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.tlog\inf2cat.read.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.tlog\inf2cat.write.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.tlog\link.command.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.tlog\link.read.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.tlog\link.write.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.tlog\signtool.command.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.tlog\signtool.read.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.tlog\signtool.timestamp.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.tlog\signtool.write.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.tlog\stacktrace.write.1u.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.tlog\stampinf.command.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.tlog\stampinf.read.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.tlog\stampinf.write.1.tlog

```

`UsbMon/UsbMon/UsbMon/x64/Debug/StackTrace.log`:

```log
  Building 'UsbMon' with toolset 'WindowsKernelModeDriver10.0' and the 'Desktop' target platform.
  Stamping x64\Debug\StackTrace.inf [Version] section with DriverVer=02/21/2017,18.33.29.455
  Assembling x64.asm...
  Driver.c
  StackTrace.vcxproj -> C:\Users\kelvinchan\Documents\Visual Studio 2015\Projects\usb\StackTrace\x64\Debug\UsbMon.sys
  StackTrace.vcxproj -> C:\Users\kelvinchan\Documents\Visual Studio 2015\Projects\usb\StackTrace\x64\Debug\UsbMon.pdb (Full PDB)
  Done Adding Additional Store
  Successfully signed: C:\Users\kelvinchan\Documents\Visual Studio 2015\Projects\usb\StackTrace\x64\Debug\UsbMon.sys
  
  ........................
  Signability test complete.
  
  Errors:
  None
  
  Warnings:
  None
  
  Catalog generation complete.
  C:\Users\kelvinchan\Documents\Visual Studio 2015\Projects\usb\StackTrace\x64\Debug\UsbMon\stacktrace.cat
  Done Adding Additional Store
  Successfully signed: C:\Users\kelvinchan\Documents\Visual Studio 2015\Projects\usb\StackTrace\x64\Debug\UsbMon\stacktrace.cat
  

```

`UsbMon/UsbMon/UsbMon/x64/Debug/UsbMon.Build.CppClean.log`:

```log
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\vc140.pdb
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\driver.obj
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\x64\debug\usbmon\stacktrace.cat
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\x64\debug\usbmon.sys
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\x64\debug\usbmon.pdb
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\usbmon.inf
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\x64\debug\usbmon.cer
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\x64\debug\usbmon.inf
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\usbmon.tlog\cl.command.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\usbmon.tlog\cl.read.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\usbmon.tlog\cl.write.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\usbmon.tlog\inf2cat-expand.14528.read.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\usbmon.tlog\inf2cat-expand.14528.write.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\usbmon.tlog\inf2cat-expand.read.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\usbmon.tlog\inf2cat-expand.write.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\usbmon.tlog\inf2cat.command.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\usbmon.tlog\inf2cat.read.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\usbmon.tlog\inf2cat.write.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\usbmon.tlog\link.command.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\usbmon.tlog\link.read.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\usbmon.tlog\link.write.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\usbmon.tlog\signtool.command.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\usbmon.tlog\signtool.read.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\usbmon.tlog\signtool.timestamp.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\usbmon.tlog\signtool.write.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\usbmon.tlog\stampinf.command.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\usbmon.tlog\stampinf.read.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\usbmon.tlog\stampinf.write.1.tlog

```

`UsbMon/UsbMon/UsbMon/x64/Debug/UsbMon.inf`:

```inf
;
; StackTrace.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=StackTrace.cat
DriverVer=02/21/2017,19.45.3.174
 

[DestinationDirs]
DefaultDestDir = 12


[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]


[Manufacturer]
%ManufacturerName%=Standard,NTamd64

[Standard.NTamd64]


[Strings]
ManufacturerName="StackTrace"
ClassName=""
DiskName="StackTrace Source Disk"

```

`UsbMon/UsbMon/UsbMon/x64/Debug/UsbMon.log`:

```log
  Building 'UsbMon' with toolset 'WindowsKernelModeDriver10.0' and the 'Desktop' target platform.
  Stamping x64\Debug\UsbMon.inf [Version] section with DriverVer=02/21/2017,19.45.3.174
  Driver.c
  UsbMon.vcxproj -> C:\Users\kelvinchan\Documents\Visual Studio 2015\Projects\UsbMon\x64\Debug\UsbMon.sys
  UsbMon.vcxproj -> C:\Users\kelvinchan\Documents\Visual Studio 2015\Projects\UsbMon\x64\Debug\UsbMon.pdb (Full PDB)
  Done Adding Additional Store
  Successfully signed: C:\Users\kelvinchan\Documents\Visual Studio 2015\Projects\UsbMon\x64\Debug\UsbMon.sys
  
  ........................
  Signability test complete.
  
  Errors:
  None
  
  Warnings:
  None
  
  Catalog generation complete.
  C:\Users\kelvinchan\Documents\Visual Studio 2015\Projects\UsbMon\x64\Debug\UsbMon\stacktrace.cat
  Done Adding Additional Store
  Successfully signed: C:\Users\kelvinchan\Documents\Visual Studio 2015\Projects\UsbMon\x64\Debug\UsbMon\stacktrace.cat
  

```

`UsbMon/UsbMon/UsbType.h`:

```h
#ifndef __USB_TYPE_HEADER__
#define __USB_TYPE_HEADER__ 

#include <ntddk.h> 
#include "Hidport.h"
#include "usb.h" 
#include "TList.h"
#include "hidpddi.h"


/////////////////////////////////////////////////////////////////////////////////////////
//	Marco 
//
#define MAX_LEN 256
#define SUPPORTED_BUTTON_COUNT 	2

#define MOUSE_FLAGS						 0x1
#define KEYBOARD_FLAGS					 0x2


#define CHANNEL_DUMP_ATTRIBUTE_RELATED					1
#define CHANNEL_DUMP_REPORT_REALTED						2
#define CHANNEL_DUMP_REPORT_BYTE_OFFSET_REALTED			4 
#define CHANNEL_DUMP_RANGE_RELATED						8
#define CHANNEL_DUMP_LINK_COL_RELATED					16
#define CHANNEL_DUMP_ALL  CHANNEL_DUMP_ATTRIBUTE_RELATED | CHANNEL_DUMP_REPORT_REALTED | CHANNEL_DUMP_RANGE_RELATED | CHANNEL_DUMP_LINK_COL_RELATED | CHANNEL_DUMP_REPORT_BYTE_OFFSET_REALTED

////////////////////////////////////////////////////////////////////////////////////////
//  Types
// 
typedef BOOLEAN(*PFOUNDHIDDEVICECALLBACK)(PVOID);

#pragma pack(push, 4)
typedef struct _HID_CONTEXT
{
	PFOUNDHIDDEVICECALLBACK MouseCallback;
	PFOUNDHIDDEVICECALLBACK KeyboardCallback;
	ULONG RequiredDevice;
}HIDCONTEXT, *PHIDCONTEXT;
#pragma pack(push, 4)


#pragma pack(push, 4)
typedef struct _USER_KBDDATA
{
	ULONG  ScanCode;
	ULONG  Flags;
	ULONG Reserved1;
	ULONG Reserved2;
}USERKBDDATA, *PUSERKBDDATA;
#pragma pack(pop)


#pragma pack(push, 4)
typedef struct _USER_MOUDATA
{
	LONG  x;
	LONG  y;
	LONG  z;
	LONG  Click;
	ULONG IsAbsolute;
	ULONG Reserved1;
	ULONG Reserved2;
}USERMOUDATA, *PUSERMOUDATA;;
#pragma pack(pop)


#pragma pack(push, 4)
typedef struct _USB_HUB_LIST
{
	TChainListHeader*					  	 head;
	ULONG							  currentSize;
	ULONG								 RefCount;
} USB_HUB_LIST, *PUSB_HUB_LIST;
#pragma pack(pop)

#pragma pack(push, 4)
typedef struct _HID_DEVICE_LIST
{
	TChainListHeader*					  	 head;
	ULONG							  currentSize;
	ULONG								 RefCount;
} HID_DEVICE_LIST, *PHID_DEVICE_LIST;
#pragma pack(pop)

typedef struct _HID_USB_DEVICE_EXTENSION {
	ULONG64							   status;			//+0x0	
	PUSB_DEVICE_DESCRIPTOR		    DeviceDesc;			//+0x8
	PUSBD_INTERFACE_INFORMATION		InterfaceDesc;		//+0x10
	USBD_CONFIGURATION_HANDLE 		ConfigurationHandle;//+0x18
	ULONG                           NumPendingRequests;
	KEVENT                          AllRequestsCompleteEvent;
	ULONG                           DeviceFlags;
	PIO_WORKITEM                    ResetWorkItem;
	HID_DESCRIPTOR				    HidDescriptor;
	PDEVICE_OBJECT                  functionalDeviceObject;
}HID_USB_DEVICE_EXTENSION, *PHID_USB_DEVICE_EXTENSION;

typedef struct _COORDINATE_DESCRIPTOR
{
	USHORT ByteOffset;
	USHORT BitOffset;
	USHORT OffsetSize;
}COORDESC, *PCOORDESC;

typedef struct _MOUSE_BTN_DESCRIPTOR
{
	USHORT ByteOffsetBtn[SUPPORTED_BUTTON_COUNT];
	USHORT BitOffsetBtn[SUPPORTED_BUTTON_COUNT];
	USHORT BtnOffsetSize[SUPPORTED_BUTTON_COUNT];
	USHORT BtnUsageMin[SUPPORTED_BUTTON_COUNT];
}BTNDESC, *PBTHESC;

typedef struct _REPORT_ID_DESCRIPTOR
{
	USHORT ReportId;
	USHORT Usage;
	USHORT UsageIndex;
}REPORTIDDESC, *PREPORTIDDESC;


typedef struct _EXTRACT_DATA
{
	union
	{
		struct
		{
			COORDESC X_Descriptor;
			COORDESC Y_Descriptor;
			COORDESC Z_Descriptor;
			BTNDESC	 BtnDescriptor;
			ULONG  	 IsAbsolute;
			REPORTIDDESC 	ReportIdDesc[4];
		}MOUDATA;

		struct
		{
			USHORT  SpecialKeyByteOffset;
			USHORT	SpecialKeyBitOffset;
			USHORT  SpecialKeySize;
			USHORT  NormalKeyByteOffset;
			USHORT	NormalKeyBitOffset;
			USHORT  NormalKeySize;
			USHORT  LedKeyByteOffset;
			USHORT	LedKeyBitOffset;
			USHORT  LedKeySize;
			USHORT  ReportId;
		}KBDDATA;

	};

}EXTRACTDATA, *PEXTRACTDATA;


#pragma pack(push, 4)
typedef struct USBHUBNODE1
{
	PDRIVER_OBJECT HubDriverObject;
	WCHAR 		   HubName[MAX_LEN];
	ULONG	 	   HubNameLen;
	BOOLEAN		   IsHooked;
}USBHUBNODE, *PUSBHUBNODE;
#pragma pack(pop)


#pragma pack(push, 4)
typedef struct _HID_DEVICE_NODE
{
	PDEVICE_OBJECT					device_object;
	HID_USB_DEVICE_EXTENSION*		mini_extension;
	HIDP_DEVICE_DESC				parsedReport;
	EXTRACTDATA* 					ExtractedData[3];
	PHIDP_COLLECTION_DESC 			Collection;
	LONG							LastClickStatus;
	//keyboard
	UCHAR* 							PreviousUsageList;
	UCHAR* 							CurrentUsageList;
	UCHAR* 							MakeUsageList;
	UCHAR* 							BreakUsageList;
	HIDP_KEYBOARD_MODIFIER_STATE	ModifierState;
}HID_DEVICE_NODE, *PHID_DEVICE_NODE;
#pragma pack(pop)


#pragma pack(push, 4)
typedef struct _USER_CONFIG_EX
{
	ULONG 	  Version;
	ULONG	  ProtocolVersion;
	ULONGLONG UserData;
	ULONG	  UserDataLen;
	ULONG 	  Flags;
}USERCONFIGEX, *PUSERCONFIGEX;
#pragma pack(pop)

//--------------------------------------//
#endif
```

`UsbMon/UsbMon/UsbUtil.c`:

```c
#include "UsbUtil.h"
#include "ReportUtil.h"

/////////////////////////////////////////////////////////////////////////////////////////////// 
////	Global/Extern Variable 
//// 

extern POBJECT_TYPE *IoDriverObjectType;

extern NTSTATUS ObReferenceObjectByName(
	PUNICODE_STRING ObjectName,
	ULONG Attributes,
	PACCESS_STATE AccessState,
	ACCESS_MASK DesiredAccess,
	POBJECT_TYPE ObjectType,
	KPROCESSOR_MODE AccessMode,
	PVOID ParseContext,
	PVOID *Object
);

BOOLEAN g_IsTestReported[0xFF] = {0};
/////////////////////////////////////////////////////////////////////////////////////////////// 
////	Marco
//// 


/////////////////////////////////////////////////////////////////////////////////////////////// 
////	Prototype
//// 

/////////////////////////////////////////////////////////////////////////////////////////////// 
////	Implementation
//// 

//----------------------------------------------------------------------------------------//
VOID PrintAllHidDriverName()
{
	WCHAR* Usbhub = NULL;
	
	
	Usbhub = GetUsbHubDriverNameByVersion(USB);
	USB_DEBUG_INFO_LN_EX("Usb Hub: %ws ", Usbhub);

	Usbhub = GetUsbHubDriverNameByVersion(USB2);
	USB_DEBUG_INFO_LN_EX("Usb Hub2: %ws ", Usbhub);

	Usbhub = GetUsbHubDriverNameByVersion(USB3);
	USB_DEBUG_INFO_LN_EX("Usb Hub3: %ws ", Usbhub);

	Usbhub = GetUsbHubDriverNameByVersion(USB3_NEW);
	USB_DEBUG_INFO_LN_EX("Usb Hub3_w8 above: %ws", Usbhub);

	Usbhub = GetUsbHubDriverNameByVersion(USB_COMPOSITE);
	USB_DEBUG_INFO_LN_EX("Usb CCGP: %ws ", Usbhub);

}

//----------------------------------------------------------------------------------------//
WCHAR* GetUsbHubDriverNameByVersion(
	_In_ USB_HUB_VERSION usb_hub_version
)
{
	WCHAR* ret = L"";
	switch (usb_hub_version)
	{
	case USB:
		ret = L"\\Driver\\usbhub";
		break;
	case USB2:
		ret = L"\\Driver\\usbhub";
		break;
	case USB3:
		ret = L"\\Driver\\iusb3hub";
		break;
	case USB3_NEW:
		ret = L"\\Driver\\USBHUB3";
	default:
		break;
	}
	return ret;
}

//----------------------------------------------------------------------------------------//
NTSTATUS GetUsbHub(
	_In_ USB_HUB_VERSION usb_hub_version, 
	_Out_ PDRIVER_OBJECT* pDriverObj
)
{
	// use such API  
	NTSTATUS status = STATUS_SUCCESS;
	UNICODE_STRING DriverName = { 0 };

	WCHAR* Usbhub = GetUsbHubDriverNameByVersion(usb_hub_version);

	RtlInitUnicodeString(&DriverName, Usbhub);

	status = ObReferenceObjectByName(
		&DriverName,
		OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE,
		NULL,
		0,
		*IoDriverObjectType,
		KernelMode,
		NULL,
		(PVOID*)pDriverObj);

	return status;
}


void DumpHidExtension(
	_In_ HID_DEVICE_EXTENSION* hid_common_extension, 
	_In_ HID_USB_DEVICE_EXTENSION* mini_extension
)
{
	ULONG i = 0; 
	HID_DESCRIPTOR* hid_desc = NULL;
	
	USB_DEBUG_INFO_LN_EX("-----------------------------------------------------------------------------\r\n");
	USB_DEBUG_INFO_LN_EX(" --->PhysicalDeviceObject: %I64X \r\n", hid_common_extension->PhysicalDeviceObject);
	USB_DEBUG_INFO_LN_EX(" --->DriverObject: %I64X \r\n", hid_common_extension->PhysicalDeviceObject->DriverObject);
	USB_DEBUG_INFO_LN_EX(" --->NextDeviceObject: %I64X \r\n", hid_common_extension->NextDeviceObject);
	USB_DEBUG_INFO_LN_EX("  --->Status: %I64X \r\n", mini_extension->status);
	USB_DEBUG_INFO_LN_EX("  --->DeviceDesc: %I64X \r\n", mini_extension->DeviceDesc);
	USB_DEBUG_INFO_LN_EX("		--->bDeviceClass: %I64X \r\n", mini_extension->DeviceDesc->bDeviceClass);
	USB_DEBUG_INFO_LN_EX("		--->bDeviceSubClass: %I64X \r\n", mini_extension->DeviceDesc->bDeviceSubClass);
	USB_DEBUG_INFO_LN_EX("		--->bDeviceProtocol: %I64X \r\n", mini_extension->DeviceDesc->bDeviceProtocol);
	USB_DEBUG_INFO_LN_EX("		--->bDescriptorType: %I64X \r\n", mini_extension->DeviceDesc->bDescriptorType);
	USB_DEBUG_INFO_LN_EX("		--->bLength: %I64X \r\n", mini_extension->DeviceDesc->bLength);
	USB_DEBUG_INFO_LN_EX("		--->bMaxPacketSize0: %I64X \r\n", mini_extension->DeviceDesc->bMaxPacketSize0);
	USB_DEBUG_INFO_LN_EX("		--->bcdUSB: %I64X \r\n", mini_extension->DeviceDesc->bcdUSB);
	USB_DEBUG_INFO_LN_EX("		--->idProduct: %I64X \r\n", mini_extension->DeviceDesc->idProduct);
	USB_DEBUG_INFO_LN_EX("		--->idVendor: %I64X \r\n", mini_extension->DeviceDesc->idVendor);
	USB_DEBUG_INFO_LN_EX("  --->InterfaceDescDesc: %I64X \r\n", mini_extension->InterfaceDesc);
	USB_DEBUG_INFO_LN_EX("		--->Class: %I64X \r\n", mini_extension->InterfaceDesc->Class);
	USB_DEBUG_INFO_LN_EX("		--->SubClass: %I64X \r\n", mini_extension->InterfaceDesc->SubClass);
	USB_DEBUG_INFO_LN_EX("		--->Protocol: %I64X \r\n", mini_extension->InterfaceDesc->Protocol);
	USB_DEBUG_INFO_LN_EX("		--->NumOfPipes: %I64X \r\n", mini_extension->InterfaceDesc->NumberOfPipes);
	USB_DEBUG_INFO_LN_EX("		--->Length: %I64X \r\n", mini_extension->InterfaceDesc->Length);
	USB_DEBUG_INFO_LN_EX("		--->AlternateSetting: %I64X \r\n\r\n", mini_extension->InterfaceDesc->AlternateSetting);

 	for (i = 0; i < mini_extension->InterfaceDesc->NumberOfPipes; i++)
	{
		USBD_PIPE_INFORMATION* Pipe_Information = &mini_extension->InterfaceDesc->Pipes[i];
		USB_DEBUG_INFO_LN_EX("  --->Pipe id: %x Information: %I64X ",i, Pipe_Information);
		USB_DEBUG_INFO_LN_EX("		--->PipeHandle: %I64X ", Pipe_Information->PipeHandle); 
		USB_DEBUG_INFO_LN_EX("		--->PipeAddress: %I64X ", Pipe_Information->EndpointAddress); 
		USB_DEBUG_INFO_LN_EX("		--->PipeInterval: %I64X ", Pipe_Information->Interval);
		USB_DEBUG_INFO_LN_EX("		--->PipeInterval: %I64X ", Pipe_Information->MaximumPacketSize);
		USB_DEBUG_INFO_LN_EX("		--->PipeInterval: %I64X ", Pipe_Information->MaximumTransferSize);
	}


	hid_desc = &(mini_extension)->HidDescriptor; 
	 
	USB_DEBUG_INFO_LN_EX("  --->HidDescriptor: %IX ", &hid_desc);
	USB_DEBUG_INFO_LN_EX("		--->bcdHID: %X ", hid_desc->bcdHID);
	USB_DEBUG_INFO_LN_EX("		--->bCountry: %X ", hid_desc->bCountry);
	USB_DEBUG_INFO_LN_EX("		--->bDescriptorType: %X ", hid_desc->bDescriptorType);
	USB_DEBUG_INFO_LN_EX("		--->bLength: %X ", hid_desc->bLength);
	USB_DEBUG_INFO_LN_EX("		--->bNumDescriptors: %X ", hid_desc->bNumDescriptors);
	USB_DEBUG_INFO_LN_EX("		--->bReportType: %X ", hid_desc->DescriptorList->bReportType);
	USB_DEBUG_INFO_LN_EX("		--->wReportLength: %X ", hid_desc->DescriptorList->wReportLength);

	USB_DEBUG_INFO_LN_EX("-----------------------------------------------------------------------------");

}


VOID	  DumpHidMiniDriverExtension(
	_In_ HID_DEVICE_EXTENSION* hid_common_extension
)
{
	if (!hid_common_extension)
	{
		return;
	}

	if (!hid_common_extension->MiniDeviceExtension)
	{
		return;
	}

	DumpHidExtension(hid_common_extension, hid_common_extension->MiniDeviceExtension);
}

VOID DumpUrb(
	_In_ PURB urb
)
{
	struct _URB_HEADER urb_header = urb->UrbHeader;;

	USB_DEBUG_INFO_LN_EX("---------------URB HEADER------------- ");
	USB_DEBUG_INFO_LN_EX("- Length: %x ", urb_header.Length);
	USB_DEBUG_INFO_LN_EX("- Function: %x ", urb_header.Function);
	USB_DEBUG_INFO_LN_EX("- Status: %x ", urb_header.Status);
	USB_DEBUG_INFO_LN_EX("- UsbdDeviceHandle: %x ", urb_header.UsbdDeviceHandle);
	USB_DEBUG_INFO_LN_EX("- UsbdFlags: %x ", urb_header.UsbdFlags);
	USB_DEBUG_INFO_LN_EX("---------------URB Function------------- ");

	switch (urb_header.Function)
	{
		/*
#if (NTDDI_VERSION >= NTDDI_WIN8)
	case URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER_USING_CHAINED_MDL:
		break;
	case URB_FUNCTION_OPEN_STATIC_STREAMS:
		break;
	case URB_FUNCTION_CLOSE_STATIC_STREAMS:
		break;
#endif*/
	case URB_FUNCTION_SELECT_CONFIGURATION:
		break;
	case URB_FUNCTION_SELECT_INTERFACE:
		break;
	case URB_FUNCTION_ABORT_PIPE:
		break;
	case URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL:
		break;
	case URB_FUNCTION_RELEASE_FRAME_LENGTH_CONTROL:
		break;
	case URB_FUNCTION_GET_FRAME_LENGTH:
		break;
	case URB_FUNCTION_SET_FRAME_LENGTH:
		break;
	case URB_FUNCTION_GET_CURRENT_FRAME_NUMBER:
		break;
	case URB_FUNCTION_CONTROL_TRANSFER:
		break;
	case URB_FUNCTION_CONTROL_TRANSFER_EX:
		break;
	case URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER:
	{
		//			struct _URB_BULK_OR_INTERRUPT_TRANSFER* data  = (struct _URB_BULK_OR_INTERRUPT_TRANSFER*) &urb->UrbHeader;

		//			USB_MON_COMMON_DBG_BREAK("_URB_BULK_OR_INTERRUPT_TRANSFER \r\n"); 
		/*			if (data->TransferFlags & USBD_TRANSFER_DIRECTION_IN)
		{
		USB_MON_COMMON_DBG_BREAK("USBD_TRANSFER_DIRECTION_IN \r\n");
		}
		if (data->TransferFlags & USBD_TRANSFER_DIRECTION_OUT)
		{
		USB_MON_COMMON_DBG_BREAK("USBD_TRANSFER_DIRECTION_OUT \r\n");

		}
		if (data->TransferFlags & USBD_SHORT_TRANSFER_OK)
		{
		USB_MON_COMMON_DBG_BREAK("USBD_SHORT_TRANSFER_OK \r\n");
		}*/

	}
	break;
	case URB_FUNCTION_RESET_PIPE:
		break;
	case URB_FUNCTION_SYNC_RESET_PIPE:
		break;
	case URB_FUNCTION_SYNC_CLEAR_STALL:
		break;
	case URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE:
		break;
	case URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT:
		break;
	case URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE:
		break;
	case URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT:
		break;
	case URB_FUNCTION_SET_FEATURE_TO_DEVICE:
		break;
	case URB_FUNCTION_SET_FEATURE_TO_INTERFACE:
		break;
	case URB_FUNCTION_SET_FEATURE_TO_ENDPOINT:
		break;
	case URB_FUNCTION_SET_FEATURE_TO_OTHER:
		break;
	case URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE:
		break;
	case URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE:
		break;
	case URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT:
		break;
	case URB_FUNCTION_CLEAR_FEATURE_TO_OTHER:
		break;
	case URB_FUNCTION_GET_STATUS_FROM_DEVICE:
		break;
	case URB_FUNCTION_GET_STATUS_FROM_INTERFACE:
		break;
	case URB_FUNCTION_GET_STATUS_FROM_ENDPOINT:
		break;
	case URB_FUNCTION_GET_STATUS_FROM_OTHER:
		break;
	case URB_FUNCTION_VENDOR_DEVICE:
		break;
	case URB_FUNCTION_VENDOR_INTERFACE:
		break;
	case URB_FUNCTION_VENDOR_ENDPOINT:
		break;
	case URB_FUNCTION_VENDOR_OTHER:
		break;
	case URB_FUNCTION_CLASS_DEVICE:
		break;
	case URB_FUNCTION_CLASS_INTERFACE:
		break;
	case URB_FUNCTION_CLASS_ENDPOINT:
		break;
	case URB_FUNCTION_CLASS_OTHER:
		break;
	case URB_FUNCTION_GET_CONFIGURATION:
		break;
	case URB_FUNCTION_GET_INTERFACE:
		break;
	case URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE:
		break;
	case URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE:
		break;
	case URB_FUNCTION_GET_MS_FEATURE_DESCRIPTOR:
		break;

	}
}
 
//-----------------------------------------------------------------------------------//
PHIDP_REPORT_IDS GetReportIdentifier(	
	_In_ HIDP_DEVICE_DESC* 	 	 pDesc, 
	_In_ ULONG 				  reportId
)
{
    PHIDP_REPORT_IDS result = NULL;
    PHIDP_DEVICE_DESC deviceDesc = pDesc;
    ULONG i;
	if(!deviceDesc)
	{
		return result;
	}
	if(!deviceDesc->ReportIDs)
	{
		return result;
	}
	
	 
    for (i = 0; i < deviceDesc->ReportIDsLength; i++)
	{
        if (deviceDesc->ReportIDs[i].ReportID == reportId)
		{
            result = &deviceDesc->ReportIDs[i];
            break;
		}
    }  
    return result;
}

//-----------------------------------------------------------------------------------//
PHIDP_COLLECTION_DESC GetCollectionDesc(	
	_In_ HIDP_DEVICE_DESC* 	 	 pDesc,
	_In_ ULONG 				collectionId
)
{
    PHIDP_COLLECTION_DESC result = NULL;
    PHIDP_DEVICE_DESC deviceDesc =  pDesc;
    ULONG i;

    if (deviceDesc->CollectionDesc){
        for (i = 0; i < deviceDesc->CollectionDescLength; i++){
            if (deviceDesc->CollectionDesc[i].CollectionNumber == collectionId){
                result = &deviceDesc->CollectionDesc[i];
                break;
            }
        }
    }
    return result;
}
//-----------------------------------------------------------------------------------// 
NTSTATUS VerifyUsageInCollection( 
	_In_ ULONG					 Usage,
	_In_ UCHAR*					 pSourceReport, 
	_In_ HIDP_DEVICE_DESC* 	 	 pDesc,
	_Out_ PHIDP_COLLECTION_DESC* pCollection
)
{
	NTSTATUS status  = STATUS_UNSUCCESSFUL;
	ULONG 	colIndex = 0;
	UCHAR ReportId = 0;
    PHIDP_REPORT_IDS 		reportIdentifier;
	PHIDP_COLLECTION_DESC	collectionDesc; 
 
	if(!pSourceReport  || !pDesc || !pCollection)
	{	
		USB_DEBUG_INFO_LN_EX("pSourceReport: %I64x  pDesc: %I64x pCollection: %I64x",
			pSourceReport, 
			pDesc, 
			pCollection
		); 
		
		if(pCollection)
		{
			*pCollection = NULL;	
		}
		
 		return status;
	} 
	
	if(pDesc->ReportIDs[0].ReportID == 0)
	{
		ReportId = 0; 
	}
	else
	{
		ReportId = (ULONG)*pSourceReport; 
	}
	
	USB_DEBUG_INFO_LN_EX("Report ID: %x", ReportId);

 	reportIdentifier = GetReportIdentifier(pDesc, ReportId);	
	
	USB_DEBUG_INFO_LN_EX("Report Identifier: %I64x ", reportIdentifier);
	
    if (!reportIdentifier)
	{       
		USB_DEBUG_INFO_LN_EX("reportIdentifier: %I64x",reportIdentifier );
		
		*pCollection = NULL;	
		status =  STATUS_UNSUCCESSFUL;
		return status;
	}	

    collectionDesc = GetCollectionDesc(pDesc, reportIdentifier->CollectionNumber);
	
	USB_DEBUG_INFO_LN_EX("CollectionDesc: %I64x  reportIdentifier->CollectionNumber: %x ", collectionDesc,  reportIdentifier->CollectionNumber);

	if(!collectionDesc)
	{	
		USB_DEBUG_INFO_LN_EX("collectionDesc: %I64x",collectionDesc);
		
		*pCollection = NULL;	
		status =  STATUS_UNSUCCESSFUL;
		return status;
	}
	
	if(collectionDesc->Usage == Usage  && collectionDesc->UsagePage == HID_GENERIC_DESKTOP_PAGE)
	{
		if(!g_IsTestReported[Usage])
		{
			USB_DEBUG_INFO_LN_EX("It is mou collection");
			g_IsTestReported[Usage] = TRUE;			
		} 
		
		*pCollection = collectionDesc;
		status = STATUS_SUCCESS; 
	}	
	else
	{	
		*pCollection = NULL;		
		status =  STATUS_UNSUCCESSFUL;
	}
	return status;
}
 
//----------------------------------------------------------------------------------------//
 
LONG ReadHidCoordinate(
	_In_	PCHAR Src , 
	_In_	ULONG ByteOffset, 
	_In_	ULONG BitOffset,  
	_In_	ULONG BitLen)
{
	LONG64    Ret=0;
	UCHAR*    lpret = (UCHAR*)&Ret ; 
	long      higthNullbitlen=64-(BitLen+BitOffset);
	
	if(!Src)
	{
		return 0; 
	}
	
	memcpy(lpret,Src+ByteOffset,(BitLen+BitOffset+7)/8);
	
	Ret=(Ret<<higthNullbitlen);
	
	if(Ret&0x8000000000000000)
	{
		ULONGLONG tmp = -1;
		Ret=(Ret>>(higthNullbitlen+BitOffset));
		Ret=Ret|(tmp<<BitLen);
	}
	else 
	{
		Ret=(Ret>>(higthNullbitlen+BitOffset));
	}
	
	return (long)Ret;
}  

//-----------------------------------------------------------------------------------//

```

`UsbMon/UsbMon/UsbUtil.h`:

```h
#ifndef __USB_UTIL_HEADER__
#define __USB_UTIL_HEADER__

#include <ntddk.h> 
#include "UsbType.h"
#include "CommonUtil.h"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
//// Type
//// 
typedef enum
{
	USB = 0,
	USB2,
	USB3,
	USB3_NEW,
	USB_COMPOSITE,
}USB_HUB_VERSION;

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
//// Prototype
//// 
/* -----------------------------------------------------------------------------------------------------------------
*/
VOID DumpUrb(
	_In_ PURB urb
);

/* -----------------------------------------------------------------------------------------------------------------
*/

VOID DumpHidMiniDriverExtension(
	_In_ HID_DEVICE_EXTENSION* hid_common_extension
);

/* -----------------------------------------------------------------------------------------------------------------
*/
NTSTATUS GetUsbHub(
	_In_  USB_HUB_VERSION usb_hub_version,
	_Out_ PDRIVER_OBJECT* pDriverObj
);

/* -----------------------------------------------------------------------------------------------------------------
*/
WCHAR* GetUsbHubDriverNameByVersion(
	_In_ USB_HUB_VERSION usb_hub_version
);
/* -----------------------------------------------------------------------------------------------------------------
*/
PHIDP_REPORT_IDS GetReportIdentifier(	
	_In_ HIDP_DEVICE_DESC* 	 	 pDesc, 
	_In_ ULONG 				  reportId
);

/* -----------------------------------------------------------------------------------------------------------------
*/
PHIDP_COLLECTION_DESC GetCollectionDesc(	
	_In_ HIDP_DEVICE_DESC* 	 	 pDesc,
	_In_ ULONG 				collectionId
);



 /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

	- VerifyUsageInCollection gets mouse usage collection in collections array
	
	- One Interface (End point) can has more than one Collection
	
	- It get the collection corresponding to the reportId

Arguments:
	 Usage		   - Usage ID you are looking for. such as, keyboard / mouse.
	 
	 pSourceReport - The pointer of raw usb data report

	 pDesc		   - The pointer of HIDP_DEVICE_DESC struct which included all reportId 
					 the reportId struct has an unique collection number, it can be used
					 for finding the collection by enumerating the collections array.

	 pCollection   - The pointer of output collection
	 
Return Value:

NTSTATUS	 - STATUS_UNSUCCESSFUL   , If failed of any one of argument check.
			 - STATUS_XXXXXXXXXXXX   , Depended on old completion
-----------------------------------------------------------------------------------*/  
NTSTATUS VerifyUsageInCollection( 
	_In_ ULONG					 Usage,
	_In_ UCHAR*					 pSourceReport, 
	_In_ HIDP_DEVICE_DESC* 	 	 pDesc,
	_Out_ PHIDP_COLLECTION_DESC* pCollection
);

 
 /*----------------------------------------------------
Description: 

	//Little-endian : 
	//Src[0] Src[1] Src[2] Src[3]
	//  0x11   0x22   0x33   0x44
	
	//Memory Order:
	//0x00000000 - 0x44 0x33 0x22 0x11
	
	//For example:
	//  X ByteOffset = 0  , Y ByteOffset = 1
	//  X BitOffset  = 0  , Y BitOffset  = 4	; BitOffset means the data read should be start from this bit in a byte
	//	X BitSize    = 12 , Y BitSize    = 12
	//  
	//
	//			 Shared bit in a byte
	//			  ----------- 	-----------   -----------
	//usb data - | 1111 1111 | | 1111 1111 | | 1111 1111 |	
	//			  -----------   -----------   -----------
	//Shared Bit: 	 		     ^^^^ ^^^^ 
				  |-----------------| |-----------------|
				  
	//For dealing with this problem, we copied two byte first, and shift

Arguments:
	Src 			- 		UsbHid Data Source
	ByteOffset  	- 		which byte we start start to read
	BitOffset   	- 		which bit in byte we start to read
	BitLen			- 		how many bits we read 
	
Return Value:			
	LONG 			- 		Read data  
	
------------------------------------------------------*/
LONG ReadHidCoordinate(
	_In_	PCHAR Src , 
	_In_	ULONG ByteOffset, 
	_In_	ULONG BitOffset,  
	_In_	ULONG BitLen);
   
#endif
```

`UsbMon/UsbMon/Util.h`:

```h
#pragma once
#include "usb.h"
extern POBJECT_TYPE *IoDriverObjectType;

extern NTSTATUS ObReferenceObjectByName(
	PUNICODE_STRING ObjectName,
	ULONG Attributes,
	PACCESS_STATE AccessState,
	ACCESS_MASK DesiredAccess,
	POBJECT_TYPE ObjectType,
	KPROCESSOR_MODE AccessMode,
	PVOID ParseContext,
	PVOID *Object
);

/// Sets a break point that works only when a debugger is present
#if !defined(HYPERPLATFORM_COMMON_DBG_BREAK)
#define STACK_TRACE_COMMON_DBG_BREAK() \
  if (KD_DEBUGGER_NOT_PRESENT) {         \
  } else {                               \
    __debugbreak();                      \
  }                                      \
  (void*)(0)
#endif

#define STACK_TRACE_DEBUG_INFO(format, ...) DbgPrintEx(0,0,format,__VA_ARGS__)

#define DELAY_ONE_MICROSECOND 	(-10)
#define DELAY_ONE_MILLISECOND	(DELAY_ONE_MICROSECOND*1000)

VOID KeSleep(LONG msec)
{
	LARGE_INTEGER my_interval;
	my_interval.QuadPart = DELAY_ONE_MILLISECOND;
	my_interval.QuadPart *= msec;
	KeDelayExecutionThread(KernelMode, 0, &my_interval);
} 
//----------------------------------------------------------------------------------------//
NTSTATUS GetDriverObjectByName(WCHAR* name, PDRIVER_OBJECT* pDriverObj)
{
	// use such API  
	NTSTATUS status = STATUS_SUCCESS;
	UNICODE_STRING DriverName = { 0 };

	RtlInitUnicodeString(&DriverName, name);

	status = ObReferenceObjectByName(
		&DriverName,
		OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE,
		NULL,
		0,
		*IoDriverObjectType,
		KernelMode,
		NULL,
		(PVOID*)pDriverObj);

	return status;
}

void GetDeviceName(PDEVICE_OBJECT device_object, WCHAR* DeviceNameBuf)
{
	UCHAR	 Buffer[sizeof(OBJECT_NAME_INFORMATION) + 512];
	POBJECT_NAME_INFORMATION NameInfo = (PVOID)Buffer;
	ULONG Length;
	if (device_object)
	{
		ObQueryNameString(device_object, NameInfo, sizeof(Buffer), &Length);
	}
	RtlMoveMemory(DeviceNameBuf, NameInfo->Name.Buffer, NameInfo->Name.Length);
}

VOID DumpUrb(PURB urb)
{
	struct _URB_HEADER urb_header = urb->UrbHeader;;

	STACK_TRACE_DEBUG_INFO("---------------URB HEADER------------- \r\n");
	STACK_TRACE_DEBUG_INFO("- Length: %x \r\n", urb_header.Length);
	STACK_TRACE_DEBUG_INFO("- Function: %x \r\n", urb_header.Function);
	STACK_TRACE_DEBUG_INFO("- Status: %x \r\n", urb_header.Status);
	STACK_TRACE_DEBUG_INFO("- UsbdDeviceHandle: %x \r\n", urb_header.UsbdDeviceHandle);
	STACK_TRACE_DEBUG_INFO("- UsbdFlags: %x \r\n", urb_header.UsbdFlags);
	STACK_TRACE_DEBUG_INFO("---------------URB Function------------- \r\n"); 
	switch (urb_header.Function)
	{
#if (NTDDI_VERSION >= NTDDI_WIN8)
	case URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER_USING_CHAINED_MDL:
		break;
	case URB_FUNCTION_OPEN_STATIC_STREAMS:
		break;
	case URB_FUNCTION_CLOSE_STATIC_STREAMS:
		break;
#endif
	case URB_FUNCTION_SELECT_CONFIGURATION:
		break;
	case URB_FUNCTION_SELECT_INTERFACE:
		break;
	case URB_FUNCTION_ABORT_PIPE:
		break;
	case URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL:
		break;
	case URB_FUNCTION_RELEASE_FRAME_LENGTH_CONTROL:
		break;
	case URB_FUNCTION_GET_FRAME_LENGTH:
		break;
	case URB_FUNCTION_SET_FRAME_LENGTH:
		break;
	case URB_FUNCTION_GET_CURRENT_FRAME_NUMBER:
		break;
	case URB_FUNCTION_CONTROL_TRANSFER:
		break;
	case URB_FUNCTION_CONTROL_TRANSFER_EX:
		break;
	case URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER:
	{
		//			struct _URB_BULK_OR_INTERRUPT_TRANSFER* data  = (struct _URB_BULK_OR_INTERRUPT_TRANSFER*) &urb->UrbHeader;

		//			STACK_TRACE_COMMON_DBG_BREAK("_URB_BULK_OR_INTERRUPT_TRANSFER \r\n"); 
		/*			if (data->TransferFlags & USBD_TRANSFER_DIRECTION_IN)
		{
		STACK_TRACE_COMMON_DBG_BREAK("USBD_TRANSFER_DIRECTION_IN \r\n");
		}
		if (data->TransferFlags & USBD_TRANSFER_DIRECTION_OUT)
		{
		STACK_TRACE_COMMON_DBG_BREAK("USBD_TRANSFER_DIRECTION_OUT \r\n");

		}
		if (data->TransferFlags & USBD_SHORT_TRANSFER_OK)
		{
		STACK_TRACE_COMMON_DBG_BREAK("USBD_SHORT_TRANSFER_OK \r\n");
		}*/

	}
	break;
	case URB_FUNCTION_RESET_PIPE:
		break;
	case URB_FUNCTION_SYNC_RESET_PIPE:
		break;
	case URB_FUNCTION_SYNC_CLEAR_STALL:
		break;
	case URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE:
		break;
	case URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT:
		break;
	case URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE:
		break;
	case URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT:
		break;
	case URB_FUNCTION_SET_FEATURE_TO_DEVICE:
		break;
	case URB_FUNCTION_SET_FEATURE_TO_INTERFACE:
		break;
	case URB_FUNCTION_SET_FEATURE_TO_ENDPOINT:
		break;
	case URB_FUNCTION_SET_FEATURE_TO_OTHER:
		break;
	case URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE:
		break;
	case URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE:
		break;
	case URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT:
		break;
	case URB_FUNCTION_CLEAR_FEATURE_TO_OTHER:
		break;
	case URB_FUNCTION_GET_STATUS_FROM_DEVICE:
		break;
	case URB_FUNCTION_GET_STATUS_FROM_INTERFACE:
		break;
	case URB_FUNCTION_GET_STATUS_FROM_ENDPOINT:
		break;
	case URB_FUNCTION_GET_STATUS_FROM_OTHER:
		break;
	case URB_FUNCTION_VENDOR_DEVICE:
		break;
	case URB_FUNCTION_VENDOR_INTERFACE:
		break;
	case URB_FUNCTION_VENDOR_ENDPOINT:
		break;
	case URB_FUNCTION_VENDOR_OTHER:
		break;
	case URB_FUNCTION_CLASS_DEVICE:
		break;
	case URB_FUNCTION_CLASS_INTERFACE:
		break;
	case URB_FUNCTION_CLASS_ENDPOINT:
		break;
	case URB_FUNCTION_CLASS_OTHER:
		break;
	case URB_FUNCTION_GET_CONFIGURATION:
		break;
	case URB_FUNCTION_GET_INTERFACE:
		break;
	case URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE:
		break;
	case URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE:
		break;
	case URB_FUNCTION_GET_MS_FEATURE_DESCRIPTOR:
		break;

	}
}




```

`UsbMon/UsbMon/WinParse.c`:

```c
/*++

Module Name:

descript.c

Abstract:
This module contains the code for parsing HID descriptors.

Environment:

Kernel & user mode

--*/
#include <fltKernel.h> 
#include "hidpddi.h"
#include "hidusage.h"
#include "WinParse.h"
#include "poclass.h"
#define FAR


typedef struct _HIDP_COLLECTION_DESC_LIST
{
	struct _HIDP_COLLECTION_DESC;
	struct _HIDP_COLLECTION_DESC_LIST * NextCollection;
} HIDP_COLLECTION_DESC_LIST, *PHIDP_COLLECTION_DESC_LIST;

typedef struct _HIDP_PARSE_GLOBAL_PUSH
{
	USHORT UsagePage;
	USHORT ReportSize, ReportCount;
	USHORT NumGlobalUnknowns;

	LONG   LogicalMin, LogicalMax;
	LONG   PhysicalMin, PhysicalMax;
	ULONG  UnitExp, Unit;
	HIDP_UNKNOWN_TOKEN    GlobalUnknowns[HIDP_MAX_UNKNOWN_ITEMS];

	struct _HIDP_REPORT_IDS        * ReportIDs;
	struct _HIDP_PARSE_GLOBAL_PUSH * Pop;
} HIDP_PARSE_GLOBAL_PUSH, *PHIDP_PARSE_GLOBAL_PUSH;


typedef struct _HIDP_PARSE_LOCAL_RANGE
{
	BOOLEAN  Range;
	BOOLEAN  IsAlias;
	// This usage is an alias (as declaired with a delimiter)
	// An alias of the next LOCAL_RANGE on the LOCAL_RANGE stack
	USHORT   UsagePage;
	USHORT   Value, Min, Max;
} HIDP_PARSE_LOCAL_RANGE, *PHIDP_PARSE_LOCAL_RANGE;

typedef struct _HIDP_PARSE_LOCAL_RANGE_LIST
{
	HIDP_PARSE_LOCAL_RANGE;
	UCHAR       Depth;
	UCHAR       Reserved2[1];
	struct _HIDP_PARSE_LOCAL_RANGE_LIST * Next;
} HIDP_PARSE_LOCAL_RANGE_LIST, *PHIDP_PARSE_LOCAL_RANGE_LIST;

NTSTATUS HidP_AllocateCollections(PHIDP_REPORT_DESCRIPTOR, ULONG, POOL_TYPE, PHIDP_COLLECTION_DESC_LIST *, PULONG, PHIDP_GETCOLDESC_DBG, PHIDP_DEVICE_DESC);
NTSTATUS HidP_ParseCollections(PHIDP_REPORT_DESCRIPTOR, ULONG, POOL_TYPE, PHIDP_COLLECTION_DESC_LIST, ULONG, PHIDP_GETCOLDESC_DBG, PHIDP_DEVICE_DESC);
void HidP_AssignDataIndices(PHIDP_PREPARSED_DATA, PHIDP_GETCOLDESC_DBG);
PHIDP_PARSE_LOCAL_RANGE_LIST HidP_FreeUsageList(PHIDP_PARSE_LOCAL_RANGE_LIST);
PHIDP_PARSE_LOCAL_RANGE_LIST HidP_PushUsageList(PHIDP_PARSE_LOCAL_RANGE_LIST, POOL_TYPE, BOOLEAN);
PHIDP_PARSE_LOCAL_RANGE_LIST HidP_PopUsageList(PHIDP_PARSE_LOCAL_RANGE_LIST);
/*
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, HidP_AllocateCollections)
#pragma alloc_text(PAGE, HidP_ParseCollections)
#pragma alloc_text(PAGE, HidP_AssignDataIndices)
#pragma alloc_text(PAGE, HidP_GetCollectionDescription)
#pragma alloc_text(PAGE, HidP_FreeUsageList)
#pragma alloc_text(PAGE, HidP_PushUsageList)
#pragma alloc_text(PAGE, HidP_PopUsageList)
#endif
*/
#pragma warning(disable: 4100)

NTSTATUS
GetCollectionDescription(
	IN     PHIDP_REPORT_DESCRIPTOR   ReportDesc,
	IN     ULONG                     DescLength,
	IN     POOL_TYPE                 PoolType,
	OUT    PHIDP_DEVICE_DESC         DeviceDesc
)
/*++
Routine Description:
see hidpi.h for a description of this function.

GetCollectionDescription is a one time cost.
The following function and its support functions were put together
in as straight forward (as HID will allow) manner.
Not major opt. has been made.

--*/
{
	NTSTATUS                   status = STATUS_SUCCESS;
	PHIDP_COLLECTION_DESC_LIST collectDesc = 0;
	PHIDP_COLLECTION_DESC_LIST nextCollectDesc = 0;
	ULONG                      numCols = 0;
	ULONG                      collectionDescLength = 0;

	// First Pass allocate memory for the collections.

	DeviceDesc->Dbg.ErrorCode = HIDP_GETCOLDESC_SUCCESS;

	RtlZeroMemory(DeviceDesc, sizeof(HIDP_DEVICE_DESC));

	HidP_KdPrint(0, ("'Preparing to Allocate memory\n"));
	
	status = HidP_AllocateCollections(ReportDesc,
		DescLength,
		PoolType,
		&collectDesc,
		&numCols,
		&DeviceDesc->Dbg,
		DeviceDesc);
	if (0 == numCols)
	{
		// No collections were reported.  That means that this device did not
		// report any top level collections in its report descriptor.
		// This is most bad.
		status = STATUS_NO_DATA_DETECTED;
		goto HIDP_GETCOLLECTIONS_REJECT;
	}
	if (!NT_SUCCESS(status))
	{
		// Something went wrong in the allocation of the memory.
		goto HIDP_GETCOLLECTIONS_REJECT;
	}

	// Second Pass fill in the data.
	
	HidP_KdPrint(0, ("'Starting Parsing Pass\n"));
	status = HidP_ParseCollections(ReportDesc,
		DescLength,
		PoolType,
		collectDesc,
		numCols,
		&DeviceDesc->Dbg,
		DeviceDesc);
	
	if (NT_SUCCESS(status))
	{
		DeviceDesc->CollectionDesc =
			(PHIDP_COLLECTION_DESC)
			ExAllocatePool(PoolType, numCols * sizeof(HIDP_COLLECTION_DESC));

		if (!(DeviceDesc->CollectionDesc))
		{
			status = STATUS_INSUFFICIENT_RESOURCES;
			HidP_KdPrint(2, ("Insufficitent Resources at VERY END\n"));
			DeviceDesc->Dbg.BreakOffset = DescLength;
			DeviceDesc->Dbg.ErrorCode = HIDP_GETCOLDESC_RESOURCES;
			goto HIDP_GETCOLLECTIONS_REJECT;
		}

		//
		// Here we flatten out the collection descriptions but we never
		// flatten the PHIDP_PREPARSED_DATA data.  We could (should) do that as
		// well if we ever optimize.
		//
		DeviceDesc->CollectionDescLength = numCols;
		numCols = 0;
		while (collectDesc)
		{
			nextCollectDesc = collectDesc->NextCollection;
			RtlCopyMemory(DeviceDesc->CollectionDesc + (numCols++),
				collectDesc,
				sizeof(HIDP_COLLECTION_DESC));
			HidP_AssignDataIndices(collectDesc->PreparsedData, &DeviceDesc->Dbg);
			ExFreePool(collectDesc);
			collectDesc = nextCollectDesc;
		}
		
		return STATUS_SUCCESS;
	}
HIDP_GETCOLLECTIONS_REJECT:
	while (collectDesc)
	{
		nextCollectDesc = collectDesc->NextCollection;
		if (collectDesc->PreparsedData)
		{
			ExFreePool(collectDesc->PreparsedData);
		}
		ExFreePool(collectDesc);
		collectDesc = nextCollectDesc;
	}

	if (DeviceDesc->ReportIDs)
	{
		ExFreePool(DeviceDesc->ReportIDs);
	}
	return status;
}

#define MORE_DATA(_pos_, _len_) \
      if (!((_pos_) < (_len_))) \
      { \
        DeviceDesc->Dbg.BreakOffset = descIndex; \
        DeviceDesc->Dbg.ErrorCode = HIDP_GETCOLDESC_BUFFER; \
        return STATUS_BUFFER_TOO_SMALL; \
      }

NTSTATUS
HidP_AllocateCollections(
	IN  PHIDP_REPORT_DESCRIPTOR      RepDesc,
	IN  ULONG                        RepDescLen,
	IN  POOL_TYPE                    PoolType,
	OUT PHIDP_COLLECTION_DESC_LIST * ColsRet,
	OUT PULONG                       NumCols,
	OUT PHIDP_GETCOLDESC_DBG         Dbg,
	OUT PHIDP_DEVICE_DESC            DeviceDesc)
	/*++
	Routine Description:
	Allocate a link list of Collection descriptors for use by the preparser.
	Each collection descriptor represents a top level app collection found
	in the given report descriptor, and contains enough memory (scratch space)
	into which to write the preparsed data.
	Return a linked list of such collections.

	In each collection also allocate enough space for the preparsed data, based
	on the number of channels required.

	Also allocate memory for the three report ID structures.

	Parameters:
	Rep      The given raw report descriptor.
	RepLen   Length of this said descriptor.
	ColsRet  The head of the list of collection descriptors.
	NumCols  Then number of collection descriptors in said list.
	--*/
{
	PHIDP_COLLECTION_DESC_LIST preCol = 0;
	PHIDP_COLLECTION_DESC_LIST curCol = 0;
	PHIDP_PREPARSED_DATA       preparsed = 0;

	HIDP_ITEM    item;
	ULONG        descIndex = 0;
	LONG         colDepth = 0; // nested collections
	SHORT        usageDepth = 0; // How many usages for each main item

	USHORT       inputChannels = 0;
	USHORT       outputChannels = 0;
	USHORT       featureChannels = 0;
	USHORT       length;
	USHORT       numLinkCollections = 0;
	// Link Collections within a top level collection.
	UCHAR        tmpBitField = 0;

	BOOLEAN      newReportID = FALSE;
	UCHAR        numReports = 0;
	BOOLEAN      defaultReportIDUsed = FALSE;
	BOOLEAN      noDefaultReportIDAllowed = FALSE;
	//
	// numReports indicates the number of HIDP_REPORT_IDS structures needed
	// to describe this device.  If the device has only one top level collection
	// then the report descriptor need not contain a report id declaration, and
	// the given device will not prepend a report ID to the input report packets.
	// newReportID indicates the parser has found no report id declaration thus
	// far in the report descriptor.
	//
	// newReportID is set to TRUE with each entrance of a top level collection,
	// this allocation routine sets this to FALSE when it see a report ID
	// declaration.
	//
	// We start newReportID as FALSE so that we can test for TRUE on entering
	// a top level collection.  If, for some reason, we enter an additional top
	// level collection and newReportID is still set to TRUE then we have a
	// violation of the HID spec.  `No report may span a top level collection.'
	//
	// Also a report ID of zero is not allowed.  If there is no declaration
	// of a report id then (1) all channels will have there report id field set
	// to zero (aka none) (2) only one top level collection may be encountered.
	// We track this with the defaultReportIDUsed noDefaultReportIDAllowed
	// locals.
	//

	*NumCols = 0;
	// currentTopCollection = 1;
	//
	// each collection returned from the preparser has a unique collection number
	// associated with it.  The preparser only concerns itself with top-level
	// collections.  This number DOES NOT in any way correspond with the
	// accessor functions, used by the client, described in hidpi.h.  The client
	// receives only one collection at a time, and within each top level
	// collection there are subcollections (link collections) which are
	// given another set of numberings.
	// We track the current collection number by the number of collections,
	// argument passed in by the caller.
	//


	while (descIndex < RepDescLen)
	{
		item = *(RepDesc + descIndex++);
		switch (item)
		{
		case HIDP_MAIN_COLLECTION:
			MORE_DATA(descIndex, RepDescLen);
			item = *(RepDesc + descIndex++);
			if (1 == ++colDepth)
			{  // We will regard any top level collection as an application
			   // collection.
			   // We will regard second level collections as a linked collection
			   // (or sub collection defined by the HIDP_LINK_COLLECTION_NODE)
			   //

				inputChannels = outputChannels = featureChannels = 0;
				numLinkCollections = 1;
				// Link collection zero is understood to be the top level
				// collection so we need to start out with at least one node
				// allocated.

				if (0 == usageDepth) {
					HidP_KdPrint(2, ("No usage for top level collection: %d!\n",
						*NumCols));
					Dbg->BreakOffset = descIndex;
					Dbg->ErrorCode = HIDP_GETCOLDESC_TOP_COLLECTION_USAGE;
					Dbg->Args[0] = *NumCols;
					return STATUS_COULD_NOT_INTERPRET;
				}
				else if (1 < usageDepth) {
					HidP_KdPrint(2, ("Multiple usages for top level collection: %d\n",
						*NumCols));
					Dbg->BreakOffset = descIndex;
					Dbg->ErrorCode = HIDP_GETCOLDESC_TOP_COLLECTION_USAGE;
					Dbg->Args[0] = *NumCols;
					return STATUS_COULD_NOT_INTERPRET;
				}

				if (newReportID) {
					// This is not the first top collection since this variable is
					// initialized to false.
					// Seeing this set means we have parsed an entire top level
					// collection without seing a report id.  This is bad.
					// A device with more than one top level colletion must have
					// more than one report.  And the last top level collection
					// declared no such report.
					HidP_KdPrint(2, ("No report ID for collection: %d\n", *NumCols));
					Dbg->BreakOffset = descIndex;
					Dbg->ErrorCode = HIDP_GETCOLDESC_NO_REPORT_ID;
					Dbg->Args[0] = *NumCols;
					return STATUS_COULD_NOT_INTERPRET;

				}
				else if (defaultReportIDUsed) {
					// This is not the first top collection since this variable is
					// initialized to FALSE;
					// So if ever we see this as true we are starting a new top
					// level collection which means there must be report ID from the
					// device and therefore there cannot exist a single channel
					// that has no declared report ID.
					HidP_KdPrint(2, ("Default report ID used inappropriately\n"));
					Dbg->BreakOffset = descIndex;
					Dbg->ErrorCode = HIDP_GETCOLDESC_DEFAULT_ID_ERROR;
					Dbg->Args[0] = *NumCols;
					return STATUS_COULD_NOT_INTERPRET;

				}

				numReports++;
				newReportID = TRUE;

				(*NumCols)++; // One more top level collection found.
				HidP_KdPrint(2, ("'Top Level Collection %d found\n", *NumCols));
				preCol = curCol;
				curCol = (PHIDP_COLLECTION_DESC_LIST)
					ExAllocatePool(PoolType, sizeof(HIDP_COLLECTION_DESC_LIST));
				if (!curCol) {
					HidP_KdPrint(2, ("No Resources to make Top level collection\n"));
					Dbg->BreakOffset = descIndex;
					Dbg->ErrorCode = HIDP_GETCOLDESC_LINK_RESOURCES;
					return STATUS_INSUFFICIENT_RESOURCES;

				}
				RtlZeroMemory(curCol, sizeof(HIDP_COLLECTION_DESC_LIST));

				if (preCol) {
					preCol->NextCollection = curCol;

				}
				else {
					*ColsRet = curCol;
				}
			}
			else if (1 < colDepth) {  // a linked collection

				HidP_KdPrint(0, ("'Enter Link Collection\n"));
				if (0 == usageDepth) {
					HidP_KdPrint(1, ("***************************************\n"));
					HidP_KdPrint(1, ("Warning! Link collection without usage \n"));
					HidP_KdPrint(1, ("Pos (%d), depth (%d)\n", descIndex, colDepth));
					HidP_KdPrint(1, ("***************************************\n"));
					usageDepth = 1;
				}
				else if (1 < usageDepth) {
					HidP_KdPrint(1, ("Link Collection with multiple usage decls\n"));
				}
				numLinkCollections += usageDepth;
			}
			usageDepth = 0;
			break;

		case HIDP_MAIN_ENDCOLLECTION:
			usageDepth = 0;
			if (--colDepth < 0) {
				HidP_KdPrint(2, ("Extra End Collection\n"));
				Dbg->BreakOffset = descIndex;
				Dbg->ErrorCode = HIDP_GETCOLDESC_UNEXP_END_COL;

				return STATUS_COULD_NOT_INTERPRET;
			}
			if (0 < colDepth) {
				HidP_KdPrint(0, ("'Exit Link Collection\n"));
				continue;
			}
			HidP_KdPrint(0, ("'Collection %d exit\n", *NumCols));
			curCol->CollectionNumber = (UCHAR)*NumCols;
			length = sizeof(HIDP_PREPARSED_DATA)
				+ (sizeof(HIDP_CHANNEL_DESC)
					* (inputChannels
						+ outputChannels
						+ featureChannels))
				+ (sizeof(HIDP_LINK_COLLECTION_NODE))
				* numLinkCollections;

			curCol->PreparsedDataLength = length;
			curCol->PreparsedData =
				(PHIDP_PREPARSED_DATA)ExAllocatePool(PoolType, length);

			if (!curCol->PreparsedData) {
				HidP_KdPrint(2, ("Could not allocate space for PreparsedData\n"));
				Dbg->BreakOffset = descIndex;
				Dbg->ErrorCode = HIDP_GETCOLDESC_PREPARSE_RESOURCES;
				return STATUS_INSUFFICIENT_RESOURCES;
			}

			RtlZeroMemory(curCol->PreparsedData, curCol->PreparsedDataLength);
			// Set the offsets
			preparsed = curCol->PreparsedData;

			preparsed->Signature1 = HIDP_PREPARSED_DATA_SIGNATURE1;
			preparsed->Signature2 = HIDP_PREPARSED_DATA_SIGNATURE2;
			preparsed->Input.Index = (UCHAR)preparsed->Input.Offset = 0;
			length = preparsed->Input.Size = inputChannels;

			preparsed->Output.Index = preparsed->Output.Offset = (UCHAR)length;
			length += (preparsed->Output.Size = outputChannels);

			preparsed->Feature.Index = preparsed->Feature.Offset = (UCHAR)length;
			length += (preparsed->Feature.Size = featureChannels);

			preparsed->LinkCollectionArrayOffset =
				length * sizeof(HIDP_CHANNEL_DESC);
			preparsed->LinkCollectionArrayLength = numLinkCollections;

			break;

		case HIDP_LOCAL_USAGE_4:
		case HIDP_LOCAL_USAGE_MIN_4:
			descIndex += 2;

		case HIDP_LOCAL_USAGE_2:
		case HIDP_LOCAL_USAGE_MIN_2:
			descIndex++;

		case HIDP_LOCAL_USAGE_1:
		case HIDP_LOCAL_USAGE_MIN_1:
			MORE_DATA(descIndex++, RepDescLen);
			usageDepth++;
			break;

		case HIDP_LOCAL_DELIMITER:
			if (1 != (item = *(RepDesc + descIndex))) {
				HidP_KdPrint(2, ("Delimiter not start %x\n", item));
				Dbg->BreakOffset = descIndex;
				Dbg->ErrorCode = HIDP_GETCOLDESC_MISMATCH_OC_DELIMITER;
				Dbg->Args[0] = item;
				return STATUS_COULD_NOT_INTERPRET;
			}

			MORE_DATA(descIndex++, RepDescLen);
			while (TRUE) {
				if (descIndex >= RepDescLen) {
					HidP_KdPrint(2, ("End delimiter NOT found!\n"));
					Dbg->BreakOffset = descIndex;
					Dbg->ErrorCode = HIDP_GETCOLDESC_NO_CLOSE_DELIMITER;
					return STATUS_COULD_NOT_INTERPRET;
				}
				item = *(RepDesc + descIndex++);

				if (HIDP_LOCAL_DELIMITER == item) {
					if (0 != (item = *(RepDesc + descIndex))) {
						HidP_KdPrint(2, ("Delimiter not stop %x\n", item));
						Dbg->BreakOffset = descIndex;
						Dbg->ErrorCode = HIDP_GETCOLDESC_MISMATCH_OC_DELIMITER;
						Dbg->Args[0] = item;
						return STATUS_COULD_NOT_INTERPRET;
					}
					MORE_DATA(descIndex++, RepDescLen);
					break;
				}

				switch (item) {
					//
					// BUGBUG
					//
					// Usage Min / Max not yet supported within delimiter.
					//
					//            case HIDP_LOCAL_USAGE_MAX_4:
					//               descIndex += 2;
					//            case HIDP_LOCAL_USAGE_MAX_2:
					//               descIndex++;
					//            case HIDP_LOCAL_USAGE_MAX_1:
					//               descIndex++;
					//               break;

				case HIDP_LOCAL_USAGE_4:
					//            case HIDP_LOCAL_USAGE_MIN_4:
					descIndex += 2;
				case HIDP_LOCAL_USAGE_2:
					//            case HIDP_LOCAL_USAGE_MIN_2:
					descIndex++;
				case HIDP_LOCAL_USAGE_1:
					//            case HIDP_LOCAL_USAGE_MIN_1:
					MORE_DATA(descIndex++, RepDescLen);
					usageDepth++;
					break;

				default:
					HidP_KdPrint(2, ("Invalid token found within delimiter!\n"));
					HidP_KdPrint(2, ("Only Usages are allowed within a delimiter\n"));
					//               HidP_KdPrint (("IE: Only Usage, UsageMin, UsageMax tokens\n"));
					HidP_KdPrint(2, ("IE: Only Usage token allowes (no min or max)\n"));
					Dbg->BreakOffset = descIndex;
					Dbg->ErrorCode = HIDP_GETCOLDESC_NOT_VALID_DELIMITER;
					Dbg->Args[0] = item;
					return STATUS_COULD_NOT_INTERPRET;
				}
			}
			break;

		case HIDP_MAIN_INPUT_2:
			MORE_DATA(descIndex + 1, RepDescLen);
			tmpBitField = *(RepDesc + descIndex++);
			descIndex++;
			goto HIDP_ALLOC_MAIN_INPUT;

		case HIDP_MAIN_INPUT_1:
			MORE_DATA(descIndex, RepDescLen);
			tmpBitField = *(RepDesc + descIndex++);

		HIDP_ALLOC_MAIN_INPUT:
			if (0 == usageDepth) {
				if (HIDP_ISCONST(tmpBitField)) {
					break;
				}
				HidP_KdPrint(2, ("Non constant main item found without usage decl\n"));
				Dbg->BreakOffset = descIndex;
				Dbg->ErrorCode = HIDP_GETCOLDESC_MAIN_ITEM_NO_USAGE;
				return STATUS_COULD_NOT_INTERPRET;
			}

			inputChannels += (usageDepth ? usageDepth : 1);
			if (newReportID) {
				if (noDefaultReportIDAllowed) {
					// A report ID declaration was found somewhere earlier in this
					// report descriptor.  This means that ALL main items must
					// have a declared report ID.
					HidP_KdPrint(2, ("Default report ID used inappropriately\n"));
					Dbg->BreakOffset = descIndex;
					Dbg->ErrorCode = HIDP_GETCOLDESC_DEFAULT_ID_ERROR;
					Dbg->Args[0] = *NumCols;
					return STATUS_COULD_NOT_INTERPRET;
				}
				defaultReportIDUsed = TRUE;
			}
			if (0 == colDepth) {
				HidP_KdPrint(2, ("Main item found not in top level collection\n"));
				Dbg->BreakOffset = descIndex;
				Dbg->ErrorCode = HIDP_GETCOLDESC_INVALID_MAIN_ITEM;
				return STATUS_COULD_NOT_INTERPRET;
			}
			usageDepth = 0;
			break;

		case HIDP_MAIN_OUTPUT_2:
			MORE_DATA(descIndex + 1, RepDescLen);
			tmpBitField = *(RepDesc + descIndex++);
			descIndex++;
			goto HIDP_ALLOC_MAIN_OUTPUT;

		case HIDP_MAIN_OUTPUT_1:
			MORE_DATA(descIndex, RepDescLen);
			tmpBitField = *(RepDesc + descIndex++);

		HIDP_ALLOC_MAIN_OUTPUT:
			if (0 == usageDepth) {
				if (HIDP_ISCONST(tmpBitField)) {
					break;
				}
				HidP_KdPrint(2, ("Non constant main item found without usage decl\n"));
				Dbg->BreakOffset = descIndex;
				Dbg->ErrorCode = HIDP_GETCOLDESC_MAIN_ITEM_NO_USAGE;
				return STATUS_COULD_NOT_INTERPRET;
			}

			outputChannels += (usageDepth ? usageDepth : 1);
			if (newReportID) {
				if (noDefaultReportIDAllowed) {
					// A report ID declaration was found somewhere earlier in this
					// report descriptor.  This means that ALL main items must
					// have a declared report ID.
					HidP_KdPrint(2, ("Default report ID used inappropriately\n"));
					Dbg->BreakOffset = descIndex;
					Dbg->ErrorCode = HIDP_GETCOLDESC_DEFAULT_ID_ERROR;
					Dbg->Args[0] = *NumCols;
					return STATUS_COULD_NOT_INTERPRET;
				}
				defaultReportIDUsed = TRUE;
			}
			if (0 == colDepth) {
				HidP_KdPrint(2, ("Main item found not in top level collection\n"));
				Dbg->BreakOffset = descIndex;
				Dbg->ErrorCode = HIDP_GETCOLDESC_INVALID_MAIN_ITEM;
				return STATUS_COULD_NOT_INTERPRET;
			}
			usageDepth = 0;
			break;

		case HIDP_MAIN_FEATURE_2:
			MORE_DATA(descIndex + 1, RepDescLen);
			tmpBitField = *(RepDesc + descIndex++);
			descIndex++;
			goto HIDP_ALLOC_MAIN_FEATURE;

		case HIDP_MAIN_FEATURE_1:
			MORE_DATA(descIndex, RepDescLen);
			tmpBitField = *(RepDesc + descIndex++);

		HIDP_ALLOC_MAIN_FEATURE:
			if (0 == usageDepth) {
				if (HIDP_ISCONST(tmpBitField)) {
					break;
				}
				HidP_KdPrint(2, ("Non constant main item found without usage decl\n"));
				Dbg->BreakOffset = descIndex;
				Dbg->ErrorCode = HIDP_GETCOLDESC_MAIN_ITEM_NO_USAGE;
				return STATUS_COULD_NOT_INTERPRET;
			}

			featureChannels += (usageDepth ? usageDepth : 1);
			if (newReportID) {
				if (noDefaultReportIDAllowed) {
					// A report ID declaration was found somewhere earlier in this
					// report descriptor.  This means that ALL main items must
					// have a declared report ID.
					HidP_KdPrint(2, ("Default report ID used inappropriately\n"));
					Dbg->BreakOffset = descIndex;
					Dbg->ErrorCode = HIDP_GETCOLDESC_DEFAULT_ID_ERROR;
					Dbg->Args[0] = *NumCols;
					return STATUS_COULD_NOT_INTERPRET;
				}
				defaultReportIDUsed = TRUE;
			}
			if (0 == colDepth) {
				HidP_KdPrint(2, ("Main item found not in top level collection\n"));
				Dbg->BreakOffset = descIndex;
				Dbg->ErrorCode = HIDP_GETCOLDESC_INVALID_MAIN_ITEM;
				return STATUS_COULD_NOT_INTERPRET;
			}
			usageDepth = 0;
			break;

		case HIDP_GLOBAL_REPORT_ID:
			MORE_DATA(descIndex, RepDescLen);
			item = *(RepDesc + descIndex++);

			if (0 < colDepth) {
				ASSERT(curCol);
			}
			else {
				HidP_KdPrint(2, ("Report ID outside of Top level collection\n"));
				HidP_KdPrint(2, ("Reports cannot span more than one top level \n"));
				HidP_KdPrint(2, ("Report ID found: %d", (ULONG)item));
				Dbg->BreakOffset = descIndex;
				Dbg->ErrorCode = HIDP_GETCOLDESC_REPORT_ID;
				Dbg->Args[0] = item;
				return STATUS_COULD_NOT_INTERPRET;
			}

			if (newReportID) {
				newReportID = FALSE;
			}
			else {
				numReports++;
			}

			noDefaultReportIDAllowed = TRUE;
			if (defaultReportIDUsed) {
				// A report ID declaration was found somewhere earlier in this
				// report descriptor.  This means that ALL main items must
				// have a declared report ID.
				HidP_KdPrint(2, ("Default report ID used inappropriately\n"));
				Dbg->BreakOffset = descIndex;
				Dbg->ErrorCode = HIDP_GETCOLDESC_DEFAULT_ID_ERROR;
				Dbg->Args[0] = *NumCols;
				return STATUS_COULD_NOT_INTERPRET;
			}
			break;

		case HIDP_ITEM_LONG:
			HidP_KdPrint(2, ("Long Items not supported %x\n", item));
			Dbg->BreakOffset = descIndex;
			Dbg->ErrorCode = HIDP_GETCOLDESC_ITEM_UNKNOWN;
			Dbg->Args[0] = item;
			return STATUS_COULD_NOT_INTERPRET;

		default:
			// Bump past the data bytes in the descriptor.
			length = (item & HIDP_ITEM_LENGTH_DATA);
			length = (3 == length) ? 4 : length;
			if (!((descIndex + length) <= RepDescLen)) {
				// OK the lower 2 bits in the item represent the length of the
				// data if this is 3 then there are 4 data bytes following this
				// item.  DescPos already points to the next data item.
				Dbg->BreakOffset = descIndex;
				Dbg->ErrorCode = HIDP_GETCOLDESC_ONE_BYTE;
				return STATUS_BUFFER_TOO_SMALL;
			}
			descIndex += length;
			break;
		}
	}

	//
	// According to the HID spec no report id may span a top level collection.
	// which means that each collection must have at least one report, and there
	// should be at least as many report IDs as collections.  Unless there is
	// only one report (therefore only one collection).  In this case no report
	// ID will be sent from the device.  But in this case we return saying there
	// was indeed one report anyway.  The ReportID decsriptor was of length one.
	// Therefore numReports must always be greater than or equal to the number
	// of collections.
	//
	// For output and feature reports, report ids are sent as an extra argument
	// so they will always be present even if they are zero.  (Zero means that
	// the device did not list a report ID in the descriptor.)
	//
	// However with input packets the report ID is part of the packet itself:
	// the first byte.  UNLESS there is only one report, and then it is not
	// present.
	//
	// __For input packets___
	// the device can have a report ID even if it has only one
	// report.  This is silly, as it wastes a byte, but then again who knows the
	// mind of an IHV.  For this reason, hidparse must check to see if the
	// reportID  list is of length one and the report id itself (in the one and
	// only one space) is zero in order to determine if the device sends no
	// reports ids.
	// If it is zero (the device is not allowed to send report ids of zero)
	// than that report id was simulated meaning the number of bytes in the
	// packet from the device is one less than the number of byte given to the
	// user.
	// If is is non-zero, then the number of bytes from the device is the same
	// as the number of bytes given to the user.
	//

	if (numReports < *NumCols) {
		HidP_KdPrint(2, ("Report IDS cannot span collections.\n"));
		HidP_KdPrint(2, ("This means that you must have at least one report ID\n"));
		HidP_KdPrint(2, ("For each TOP level collection, unless you have only\n"));
		HidP_KdPrint(2, ("report.\n"));
		Dbg->BreakOffset = descIndex;
		Dbg->ErrorCode = HIDP_GETCOLDESC_NO_REPORT_ID;
		return STATUS_COULD_NOT_INTERPRET;
	}

	//
	// Now that we have seen the entire structure, allocate the structure for
	// holding the report id switch table.
	//

	if (0 == numReports) {
		HidP_KdPrint(2, ("No top level collections were found! \n"));
		Dbg->BreakOffset = descIndex;
		Dbg->ErrorCode = HIDP_GETCOLDESC_NO_DATA;
		return STATUS_NO_DATA_DETECTED;
	}

	DeviceDesc->ReportIDsLength = numReports;
	DeviceDesc->ReportIDs = (PHIDP_REPORT_IDS)
		ExAllocatePool(PoolType, numReports * sizeof(HIDP_REPORT_IDS));

	if (!DeviceDesc->ReportIDs) {
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	RtlZeroMemory(DeviceDesc->ReportIDs, numReports * sizeof(HIDP_REPORT_IDS));

	return STATUS_SUCCESS;
}


PHIDP_PARSE_LOCAL_RANGE_LIST
HidP_FreeUsageList(
	PHIDP_PARSE_LOCAL_RANGE_LIST  Usage
)
/*++
RoutineDescription:
clear off all the usages in the linked list
But do not free the first element in the list.
--*/
{
	PHIDP_PARSE_LOCAL_RANGE_LIST curUsage;
	while (Usage->Next) {
		curUsage = Usage;
		Usage = curUsage->Next;
		ExFreePool(curUsage);
	}
	RtlZeroMemory(Usage, sizeof(HIDP_PARSE_LOCAL_RANGE_LIST));
	return Usage;
}

PHIDP_PARSE_LOCAL_RANGE_LIST
HidP_PushUsageList(
	PHIDP_PARSE_LOCAL_RANGE_LIST  Usage,
	POOL_TYPE                     PoolType,
	BOOLEAN                       WithinDelimiter
)
/*++
RoutineDescription:
allocate another Usage node and add it to the top O the list.
--*/
{
	PHIDP_PARSE_LOCAL_RANGE_LIST newUsage;

	newUsage = (PHIDP_PARSE_LOCAL_RANGE_LIST)
		ExAllocatePool(PoolType, sizeof(HIDP_PARSE_LOCAL_RANGE_LIST));
	if (newUsage) {
		RtlZeroMemory(newUsage, sizeof(HIDP_PARSE_LOCAL_RANGE_LIST));
		newUsage->Next = Usage;
		if (!WithinDelimiter) {
			newUsage->Depth = Usage->Depth
				+ (Usage->Range ? (Usage->Max - Usage->Min + 1) : 1);
		}
		else {
			newUsage->Depth = Usage->Depth;
			//
			// Note ranges are not allowed in delimiters therefore we know
			// that all entries in the delimiter are equal and are length 1
			//
		}
	}
	else {
		HidP_FreeUsageList(Usage);
	}
	return newUsage;
}

PHIDP_PARSE_LOCAL_RANGE_LIST
HidP_PopUsageList(
	PHIDP_PARSE_LOCAL_RANGE_LIST  Usage
)
{
	PHIDP_PARSE_LOCAL_RANGE_LIST  newUsage;

	if (Usage->Next) {
		newUsage = Usage->Next;
		ExFreePool(Usage);
	}
	else {
		newUsage = Usage;
#if DBG
		RtlFillMemory(newUsage, sizeof(HIDP_PARSE_LOCAL_RANGE_LIST), 0xDB);
		newUsage->Depth = 0;
#endif
	}
	return newUsage;
}


#define ONE_BYTE_DATA(_data_, _pos_, _dbg_)    \
         if (!((_pos_) < RepDescLen)) { \
               status = STATUS_BUFFER_TOO_SMALL; \
               KdPrint(("More Data Expected\n")); \
               _dbg_->ErrorCode = HIDP_GETCOLDESC_ONE_BYTE; \
               _dbg_->BreakOffset = descIndex; \
               goto HIDP_PARSE_REJECT; \
            } \
         (_data_) = *(RepDesc + (_pos_)++);

#define TWO_BYTE_DATA(_data_, _pos_, _dbg_)      \
         if (!((_pos_) + 1 < RepDescLen)) { \
               status = STATUS_BUFFER_TOO_SMALL; \
               KdPrint(("More Data Expected\n")); \
               _dbg_->ErrorCode = HIDP_GETCOLDESC_TWO_BYTE; \
               _dbg_->BreakOffset = descIndex; \
               goto HIDP_PARSE_REJECT; \
            } \
         (_data_) = *(RepDesc + (_pos_)++);        \
         (_data_) |= *(RepDesc + (_pos_)++) << 8;


#define FOUR_BYTE_DATA(_data_, _pos_, _dbg_)     \
         if (!((_pos_) + 3 < RepDescLen)) { \
               status = STATUS_BUFFER_TOO_SMALL; \
               KdPrint(("More Data Expected\n")); \
               _dbg_->ErrorCode = HIDP_GETCOLDESC_FOUR_BYTE; \
               _dbg_->BreakOffset = descIndex; \
               goto HIDP_PARSE_REJECT; \
            } \
         (_data_) = *(RepDesc + (_pos_)++);        \
         (_data_) |= *(RepDesc + (_pos_)++) << 8;  \
         (_data_) |= *(RepDesc + (_pos_)++) << 16; \
         (_data_) |= *(RepDesc + (_pos_)++) << 24;

#define BIT_EXTEND_1(_data_) \
         (_data_) = ((_data_) & 0xFF) \
                  | (((_data_) & 0x80) ? 0xFFFFFF00 : 0)

#define BIT_EXTEND_2(_data_) \
         (_data_) = ((_data_) & 0xFFFF) \
                  | (((_data_) & 0x8000) ? 0xFFFF0000 : 0)


NTSTATUS
HidP_ParseCollections(
	IN     PHIDP_REPORT_DESCRIPTOR      RepDesc,
	IN     ULONG                        RepDescLen,
	IN     POOL_TYPE                    PoolType,
	IN OUT PHIDP_COLLECTION_DESC_LIST   Cols,
	IN     ULONG                        NumCols,
	OUT    PHIDP_GETCOLDESC_DBG         Dbg,
	IN OUT PHIDP_DEVICE_DESC            DeviceDesc)
	/*++
	Routine Description:
	Given a nice linked list of collection descriptors parse into those
	descriptors the information descerned from the Raw Report Descriptor.
	Each given CollectionDescriptor already has the proper amount of memory
	in the PreparsedData field.

	Parameters:
	Rep      The given raw report descriptor.
	RepLen   Length of this said descriptor.
	ColsRet  The head of the list of collection descriptors.
	NumCols  Then number of collection descriptors in said list.
	--*/
{
	HIDP_PREPARSED_DATA           safeData;
	HIDP_PARSE_GLOBAL_PUSH        firstPush = { 0,0,0,0,0,0,0,0,0,0,0 };
	HIDP_PARSE_LOCAL_RANGE_LIST   firstUsage = { 0,0,0,0,0 };
	HIDP_PARSE_LOCAL_RANGE        designator = { 0,0,0,0 };
	HIDP_PARSE_LOCAL_RANGE        string = { 0,0,0,0 };
	HIDP_PARSE_LOCAL_RANGE        zeroLocal = { 0,0,0,0 };

	PHIDP_COLLECTION_DESC_LIST    appCol = 0;
	PHIDP_PREPARSED_DATA          preparsed = &safeData;
	PHIDP_PARSE_GLOBAL_PUSH       push = &firstPush;
	PHIDP_PARSE_GLOBAL_PUSH       tmpPush = 0;
	PHIDP_PARSE_LOCAL_RANGE_LIST  usage = &firstUsage;
	PHIDP_PARSE_LOCAL_RANGE_LIST  tmpUsage = 0;
	PHIDP_CHANNEL_DESC            channel = 0;
	PHIDP_LINK_COLLECTION_NODE    linkNodeArray = 0;
	PHIDP_LINK_COLLECTION_NODE    parentLCNode = 0;
	PHIDP_LINK_COLLECTION_NODE    currentLCNode = 0;
	struct _HIDP_UNKNOWN_TOKEN *  unknownToken;
	USHORT                        linkNodeIndex = 0;

	ULONG        descIndex = 0;
	ULONG        colDepth = 0;
	NTSTATUS     status = STATUS_SUCCESS;
	USHORT       bitPos;
	HIDP_ITEM    item;
	USHORT       tmpBitField = 0;
	USHORT       tmpCount = 0;
	USHORT       i;
	PUSHORT      channelIndex = 0;

	PHIDP_REPORT_IDS              currentReportIDs = DeviceDesc->ReportIDs;
	PHIDP_REPORT_IDS              tmpReportIDs;
	BOOLEAN                       isFirstReportID = TRUE;
	BOOLEAN                       withinDelimiter = FALSE;
	BOOLEAN                       firstUsageWithinDelimiter = TRUE;
	BOOLEAN                       isAlias = FALSE;
	UCHAR                         collectionType;
	UCHAR                         tmpID;

	UNREFERENCED_PARAMETER(NumCols);

	while (descIndex < RepDescLen)
	{
		item = *(RepDesc + descIndex++);
		switch (item)
		{
		case HIDP_MAIN_COLLECTION:
			ONE_BYTE_DATA(collectionType, descIndex, Dbg);
			if (1 == ++colDepth)
			{
				//
				// We will regard any top level collection as an application
				// collection as approved by the HID committee
				//
				// we will regard second level collections as a link collection.
				//

				if (appCol)
				{
					appCol = appCol->NextCollection;
				}
				else
				{
					appCol = Cols;
				}
				ASSERT(appCol);

				HidP_KdPrint(0, ("'Parse Collection %d \n", appCol->CollectionNumber));

				preparsed = appCol->PreparsedData;

				//
				// Set up the report IDs for this collection
				// There is one report ID array for all top level collections
				//
				push->ReportIDs = currentReportIDs;
				isFirstReportID = TRUE;
				// Make room for the Report ID as the first byte.
				currentReportIDs->InputLength = 8;
				currentReportIDs->OutputLength = 8;
				currentReportIDs->FeatureLength = 8;
				currentReportIDs->ReportID = 0;
				currentReportIDs->CollectionNumber = appCol->CollectionNumber;
				currentReportIDs++;

				preparsed->UsagePage = appCol->UsagePage = usage->UsagePage ?
					usage->UsagePage :
					push->UsagePage;
				if (usage->Range)
				{
					preparsed->Usage = appCol->Usage = usage->Min;
				}
				else
				{
					preparsed->Usage = appCol->Usage = usage->Value;
				}
				designator = string = zeroLocal;
				usage = HidP_FreeUsageList(usage);


				//
				// Initialize the Link node array for this top level collection.
				// There is a link node array for each top level collection
				//
				linkNodeArray = (PHIDP_LINK_COLLECTION_NODE)
					(preparsed->RawBytes +
						preparsed->LinkCollectionArrayOffset);

				ASSERT(0 < preparsed->LinkCollectionArrayLength);
				parentLCNode = &(linkNodeArray[0]);
				currentLCNode = &(linkNodeArray[0]);
				linkNodeIndex = 0;

				parentLCNode->LinkUsagePage = appCol->UsagePage;
				parentLCNode->LinkUsage = appCol->Usage;
				parentLCNode->Parent = 0;
				parentLCNode->NumberOfChildren = 0;
				parentLCNode->NextSibling = 0;
				parentLCNode->FirstChild = 0;
				parentLCNode->CollectionType = collectionType;

			}
			else if (1 < colDepth)
			{
				linkNodeIndex++;
				parentLCNode = currentLCNode;
				ASSERT(linkNodeIndex < preparsed->LinkCollectionArrayLength);
				currentLCNode = &linkNodeArray[linkNodeIndex];

				//
				// Pop of the usage stack all the usages which are aliases, and
				// create a link collection node for each one.
				// Each allias link collection node has the IsAlias bit set.
				// The last one does not have the bit set, and becomes the
				// collection number for all controls list within this aliased
				// link collection.
				//
				//

				while (TRUE) {
					currentLCNode->LinkUsagePage = usage->UsagePage ?
						usage->UsagePage :
						push->UsagePage;
					currentLCNode->LinkUsage = usage->Range ?
						usage->Min :
						usage->Value;
					currentLCNode->Parent = (USHORT)(parentLCNode - linkNodeArray);
					ASSERT(currentLCNode->Parent < preparsed->LinkCollectionArrayLength);
					currentLCNode->NumberOfChildren = 0;
					currentLCNode->FirstChild = 0;
					currentLCNode->NextSibling = parentLCNode->FirstChild;
					parentLCNode->FirstChild = linkNodeIndex;
					parentLCNode->NumberOfChildren++;
					currentLCNode->CollectionType = collectionType;

					if (usage->IsAlias) {
						currentLCNode->IsAlias = TRUE;
						linkNodeIndex++;
						ASSERT(linkNodeIndex < preparsed->LinkCollectionArrayLength);
						currentLCNode = &linkNodeArray[linkNodeIndex];
					}
					else {
						break;
					}
				}
				designator = string = zeroLocal;
				usage = HidP_FreeUsageList(usage);
			}
			break;

		case HIDP_MAIN_ENDCOLLECTION:
			if (0 == colDepth--) {
				status = STATUS_COULD_NOT_INTERPRET;
				goto HIDP_PARSE_REJECT;

			}
			else if (0 < colDepth) {
				ASSERT((parentLCNode - linkNodeArray) == currentLCNode->Parent);
				currentLCNode = parentLCNode;
				ASSERT(currentLCNode->Parent < preparsed->LinkCollectionArrayLength);
				parentLCNode = &linkNodeArray[currentLCNode->Parent];
				break;
			}

			HidP_KdPrint(0, ("'X Parse Collection %d \n", appCol->CollectionNumber));


			//
			// Walk the report IDs for this collection
			//
			for (tmpReportIDs = currentReportIDs - 1;
				tmpReportIDs != DeviceDesc->ReportIDs - 1;
				tmpReportIDs--)
			{
				if (tmpReportIDs->CollectionNumber != appCol->CollectionNumber)
				{
					continue;
				}
				if ((0 != (tmpReportIDs->InputLength & 7)) ||
					(0 != (tmpReportIDs->OutputLength & 7)) ||
					(0 != (tmpReportIDs->FeatureLength & 7)))
				{
					HidP_KdPrint(2, ("Col %x Report %x NOT byte alligned!! %x %x %x\n",
						appCol->CollectionNumber,
						tmpReportIDs->ReportID,
						tmpReportIDs->InputLength,
						tmpReportIDs->OutputLength,
						tmpReportIDs->FeatureLength));
					Dbg->BreakOffset = descIndex;
					Dbg->ErrorCode = HIDP_GETCOLDESC_BYTE_ALLIGN;
					Dbg->Args[0] = appCol->CollectionNumber,
						Dbg->Args[1] = tmpReportIDs->ReportID,
						Dbg->Args[2] = tmpReportIDs->InputLength;
					Dbg->Args[3] = tmpReportIDs->OutputLength;
					Dbg->Args[4] = tmpReportIDs->FeatureLength;
					status = STATUS_COULD_NOT_INTERPRET;
					goto HIDP_PARSE_REJECT;
				}

				preparsed->Input.ByteLen = MAX(preparsed->Input.ByteLen,
					tmpReportIDs->InputLength >> 3);
				preparsed->Output.ByteLen = MAX(preparsed->Output.ByteLen,
					tmpReportIDs->OutputLength >> 3);
				preparsed->Feature.ByteLen = MAX(preparsed->Feature.ByteLen,
					tmpReportIDs->FeatureLength >> 3);

				//
				// We are now done with this report so convert the length to
				// bytes instead of bits, and remove the report id, if the
				// device will not send one.
				//

				if (0 == tmpReportIDs->ReportID)
				{
					// The report ID was never set; therefore, for input the device
					// will not send a report id.
					tmpReportIDs->InputLength = (tmpReportIDs->InputLength >> 3) - 1;
					tmpReportIDs->OutputLength = (tmpReportIDs->OutputLength >> 3) - 1;
					tmpReportIDs->FeatureLength = (tmpReportIDs->FeatureLength >> 3) - 1;
				}
				else
				{
					tmpReportIDs->InputLength = (8 == tmpReportIDs->InputLength)
						? 0
						: tmpReportIDs->InputLength >> 3;
					tmpReportIDs->OutputLength = (8 == tmpReportIDs->OutputLength)
						? 0
						: tmpReportIDs->OutputLength >> 3;
					tmpReportIDs->FeatureLength = (8 == tmpReportIDs->FeatureLength)
						? 0
						: tmpReportIDs->FeatureLength >> 3;
				}
			}

			//
			// This field is adjusted and always accounts for a space for the
			// included report ID, even if the device itslef has only one report
			// and therefore sends no report ids.  (The input report is one byte
			// smaller.
			//
			// BUT if the length is one, then only the report ID exists.
			// This means that the device has no data to send for that field.
			// Therefore return zero.
			//
			// Remember that the BitLen fields were spiked earlier with values
			// of 8 (one byte).
			//
			// appCol->XXXLength is the length expected from/by the client
			// currentReportID->XxLength == the length expected from/by the device
			//
			if (1 == (appCol->InputLength = preparsed->Input.ByteLen))
			{
				appCol->InputLength = preparsed->Input.ByteLen = 0;
			}
			if (1 == (appCol->OutputLength = preparsed->Output.ByteLen))
			{
				appCol->OutputLength = preparsed->Output.ByteLen = 0;
			}
			if (1 == (appCol->FeatureLength = preparsed->Feature.ByteLen))
			{
				appCol->FeatureLength = preparsed->Feature.ByteLen = 0;
			}

			break;

		case HIDP_GLOBAL_USAGE_PAGE_1:
			ONE_BYTE_DATA(push->UsagePage, descIndex, Dbg);
			break;

		case HIDP_GLOBAL_USAGE_PAGE_2:
			TWO_BYTE_DATA(push->UsagePage, descIndex, Dbg);
			break;

			//
			// 16 bits allowed only.
			//      case HIDP_GLOBAL_USAGE_PAGE_4:
			//         FOUR_BYTE_DATA (push->UsagePage, descIndex, Dbg);
			//         break;
			//

		case HIDP_GLOBAL_LOG_MIN_1:
			ONE_BYTE_DATA(push->LogicalMin, descIndex, Dbg);
			BIT_EXTEND_1(push->LogicalMin);
			break;

		case HIDP_GLOBAL_LOG_MIN_2:
			TWO_BYTE_DATA(push->LogicalMin, descIndex, Dbg);
			BIT_EXTEND_2(push->LogicalMin);
			break;

		case HIDP_GLOBAL_LOG_MIN_4:
			FOUR_BYTE_DATA(push->LogicalMin, descIndex, Dbg);
			break;

		case HIDP_GLOBAL_LOG_MAX_1:
			ONE_BYTE_DATA(push->LogicalMax, descIndex, Dbg);
			BIT_EXTEND_1(push->LogicalMax);
			break;

		case HIDP_GLOBAL_LOG_MAX_2:
			TWO_BYTE_DATA(push->LogicalMax, descIndex, Dbg);
			BIT_EXTEND_2(push->LogicalMax);
			break;

		case HIDP_GLOBAL_LOG_MAX_4:
			FOUR_BYTE_DATA(push->LogicalMax, descIndex, Dbg);
			break;

		case HIDP_GLOBAL_PHY_MIN_1:
			ONE_BYTE_DATA(push->PhysicalMin, descIndex, Dbg);
			BIT_EXTEND_1(push->PhysicalMin);
			break;

		case HIDP_GLOBAL_PHY_MIN_2:
			TWO_BYTE_DATA(push->PhysicalMin, descIndex, Dbg);
			BIT_EXTEND_2(push->PhysicalMin);
			break;

		case HIDP_GLOBAL_PHY_MIN_4:
			FOUR_BYTE_DATA(push->PhysicalMin, descIndex, Dbg);
			break;

		case HIDP_GLOBAL_PHY_MAX_1:
			ONE_BYTE_DATA(push->PhysicalMax, descIndex, Dbg);
			BIT_EXTEND_1(push->PhysicalMax);
			break;

		case HIDP_GLOBAL_PHY_MAX_2:
			TWO_BYTE_DATA(push->PhysicalMax, descIndex, Dbg);
			BIT_EXTEND_2(push->PhysicalMax);
			break;

		case HIDP_GLOBAL_PHY_MAX_4:
			FOUR_BYTE_DATA(push->PhysicalMax, descIndex, Dbg);
			break;

		case HIDP_GLOBAL_UNIT_EXP_1:
			ONE_BYTE_DATA(push->UnitExp, descIndex, Dbg);
			BIT_EXTEND_1(push->UnitExp);
			break;

		case HIDP_GLOBAL_UNIT_EXP_2:
			TWO_BYTE_DATA(push->UnitExp, descIndex, Dbg);
			BIT_EXTEND_2(push->UnitExp);
			break;

		case HIDP_GLOBAL_UNIT_EXP_4:
			FOUR_BYTE_DATA(push->UnitExp, descIndex, Dbg);
			break;

		case HIDP_GLOBAL_UNIT_1:
			ONE_BYTE_DATA(push->Unit, descIndex, Dbg);
			break;

		case HIDP_GLOBAL_UNIT_2:
			TWO_BYTE_DATA(push->Unit, descIndex, Dbg);
			break;

		case HIDP_GLOBAL_UNIT_4:
			FOUR_BYTE_DATA(push->Unit, descIndex, Dbg);
			break;

		case HIDP_GLOBAL_REPORT_SIZE:
			ONE_BYTE_DATA(push->ReportSize, descIndex, Dbg);
			break;

		case HIDP_GLOBAL_REPORT_COUNT_1:
			ONE_BYTE_DATA(push->ReportCount, descIndex, Dbg);
			break;

		case HIDP_GLOBAL_REPORT_COUNT_2:
			TWO_BYTE_DATA(push->ReportCount, descIndex, Dbg);
			break;

		case HIDP_GLOBAL_REPORT_ID:
			//
			// If a device has no report GLOBAL_REPORT_ID token in its descriptor
			// then it will never transmit a report ID in its input reports,
			// and the report ID for each channel will be set to zero.
			//
			// But, if anywhere in the report, a device declares a report ID
			// that device must always transmit a report ID with input reports,
			// AND more importantly that report ID MUST NOT BE ZERO.
			//
			// This means that if we find a report id token, that we can just
			// overwrite the first report ID structure with the given report ID
			// because we know that the first ID structure (initialized to zero
			// and therefore not valid) will not be used for any of the channels.
			//
			ONE_BYTE_DATA(tmpID, descIndex, Dbg);

			//
			// Search to see if this report id has been used before.
			//
			for (tmpReportIDs = DeviceDesc->ReportIDs;
				tmpReportIDs != currentReportIDs;
				tmpReportIDs++) {

				if (tmpReportIDs->ReportID == tmpID) {
					//
					// A duplicate!
					// Make sure that it is for this same collection
					//
					if (tmpReportIDs->CollectionNumber != appCol->CollectionNumber) {
						HidP_KdPrint(2, ("Reports cannot span more than one top level \n"));
						HidP_KdPrint(2, ("Report ID %d found in collections [%d %d]",
							(ULONG)tmpID,
							(ULONG)tmpReportIDs->CollectionNumber,
							(ULONG)appCol->CollectionNumber));
						Dbg->BreakOffset = descIndex;
						Dbg->ErrorCode = HIDP_GETCOLDESC_REPORT_ID;
						Dbg->Args[0] = item;
						status = HIDP_STATUS_INVALID_REPORT_TYPE;
						goto HIDP_PARSE_REJECT;
					}
					//
					// Use this report ID.
					//
					push->ReportIDs = tmpReportIDs;
					break;
				}
			} // continue looking.

			if (isFirstReportID) {
				isFirstReportID = FALSE;
			}
			else if (tmpReportIDs == currentReportIDs) {
				//
				// We have not seen this report ID before.
				// make a new container.
				//
				push->ReportIDs = currentReportIDs;
				// Make room for the Report ID as the first byte.
				currentReportIDs->InputLength = 8;
				currentReportIDs->OutputLength = 8;
				currentReportIDs->FeatureLength = 8;
				currentReportIDs->CollectionNumber = appCol->CollectionNumber;
				currentReportIDs++;
			}

			push->ReportIDs->ReportID = tmpID;

			if (0 == push->ReportIDs->ReportID) {
				status = HIDP_STATUS_INVALID_REPORT_TYPE;
				HidP_KdPrint(2, ("Report IDs cannot be zero (0)\n"));
				Dbg->ErrorCode = HIDP_GETCOLDESC_BAD_REPORT_ID;
				Dbg->BreakOffset = descIndex;
				goto HIDP_PARSE_REJECT;
			}
			break;

		case HIDP_GLOBAL_PUSH:
			tmpPush = (PHIDP_PARSE_GLOBAL_PUSH)
				ExAllocatePool(PoolType, sizeof(HIDP_PARSE_GLOBAL_PUSH));
			if (!tmpPush)
			{
				status = STATUS_INSUFFICIENT_RESOURCES;
				HidP_KdPrint(2, ("No Resources to Push global stack\n"));
				Dbg->BreakOffset = descIndex;
				Dbg->ErrorCode = HIDP_GETCOLDESC_PUSH_RESOURCES;
				goto HIDP_PARSE_REJECT;
			}
			HidP_KdPrint(0, ("Push Global Stack\n"));
			*tmpPush = *push;
			tmpPush->Pop = push;
			push = tmpPush;
			break;

		case HIDP_GLOBAL_POP:
			tmpPush = push->Pop;
			ExFreePool(push);
			push = tmpPush;
			HidP_KdPrint(0, ("Pop Global Stack\n"));

			break;

			//
			// Local Items
			//

			//
			// We already verified that only "approved" tokens will be within
			// the open / close of the following delimiter.  This simplifies
			// our parsing here tremendously.
			//
		case HIDP_LOCAL_DELIMITER:
			ONE_BYTE_DATA(item, descIndex, Dbg);
			if (1 == item) {
				withinDelimiter = TRUE;
				firstUsageWithinDelimiter = TRUE;
			}
			else if (0 == item) {
				withinDelimiter = FALSE;
			}
			else {
				TRAP();
			}
			break;

		case HIDP_LOCAL_USAGE_1:
		case HIDP_LOCAL_USAGE_2:
		case HIDP_LOCAL_USAGE_4:
			if ((&firstUsage == usage) || usage->Value || usage->Max || usage->Min) {
				usage = HidP_PushUsageList(usage, PoolType, withinDelimiter);
				if (!usage) {
					status = STATUS_INSUFFICIENT_RESOURCES;
					HidP_KdPrint(2, ("No Resources to Push Usage stack\n"));
					Dbg->BreakOffset = descIndex;
					Dbg->ErrorCode = HIDP_GETCOLDESC_PUSH_RESOURCES;
					goto HIDP_PARSE_REJECT;
				}
			}
			usage->Range = FALSE;
			if (HIDP_LOCAL_USAGE_1 == item) {
				ONE_BYTE_DATA(usage->Value, descIndex, Dbg);
			}
			else if (HIDP_LOCAL_USAGE_2 == item) {
				TWO_BYTE_DATA(usage->Value, descIndex, Dbg);
			}
			else {
				TWO_BYTE_DATA(usage->Value, descIndex, Dbg);
				TWO_BYTE_DATA(usage->UsagePage, descIndex, Dbg);
				// upper 16 bits overwrite the default usage page.
			}

			if (withinDelimiter) {
				usage->IsAlias = !firstUsageWithinDelimiter;
				firstUsageWithinDelimiter = FALSE;
			}
			break;

			//
			// NB: before we can add delimiters to usage ranges we must insure
			// that the range is identical for all entries within the delimiter.
			//

		case HIDP_LOCAL_USAGE_MIN_1:
		case HIDP_LOCAL_USAGE_MIN_2:
		case HIDP_LOCAL_USAGE_MIN_4:
			if ((&firstUsage == usage) || (usage->Min) || (usage->Value)) {
				usage = HidP_PushUsageList(usage, PoolType, FALSE);
				if (!usage) {
					status = STATUS_INSUFFICIENT_RESOURCES;
					HidP_KdPrint(2, ("No Resources to Push Usage stack\n"));
					Dbg->BreakOffset = descIndex;
					Dbg->ErrorCode = HIDP_GETCOLDESC_PUSH_RESOURCES;
					goto HIDP_PARSE_REJECT;
				}
			}
			usage->Range = TRUE;
			if (HIDP_LOCAL_USAGE_MIN_1 == item) {
				ONE_BYTE_DATA(usage->Min, descIndex, Dbg);
			}
			else if (HIDP_LOCAL_USAGE_MIN_2 == item) {
				TWO_BYTE_DATA(usage->Min, descIndex, Dbg);
			}
			else {
				TWO_BYTE_DATA(usage->Min, descIndex, Dbg);
				TWO_BYTE_DATA(usage->UsagePage, descIndex, Dbg);
				// upper 16 bits overwrite the default usage page.
			}
			break;

		case HIDP_LOCAL_USAGE_MAX_1:
		case HIDP_LOCAL_USAGE_MAX_2:
		case HIDP_LOCAL_USAGE_MAX_4:
			if ((&firstUsage == usage) || (usage->Max) || (usage->Value)) {
				usage = HidP_PushUsageList(usage, PoolType, FALSE);
				if (!usage) {
					status = STATUS_INSUFFICIENT_RESOURCES;
					HidP_KdPrint(2, ("No Resources to Push Usage stack\n"));
					Dbg->BreakOffset = descIndex;
					Dbg->ErrorCode = HIDP_GETCOLDESC_PUSH_RESOURCES;
					goto HIDP_PARSE_REJECT;
				}
			}
			usage->Range = TRUE;
			if (HIDP_LOCAL_USAGE_MAX_1 == item) {
				ONE_BYTE_DATA(usage->Max, descIndex, Dbg);
			}
			else if (HIDP_LOCAL_USAGE_MAX_2 == item) {
				TWO_BYTE_DATA(usage->Max, descIndex, Dbg);
			}
			else {
				TWO_BYTE_DATA(usage->Max, descIndex, Dbg);
				TWO_BYTE_DATA(usage->UsagePage, descIndex, Dbg);
				// upper 16 bits overwrite the default usage page.
			}
			break;

		case HIDP_LOCAL_DESIG_INDEX:
			designator.Range = FALSE;
			ONE_BYTE_DATA(designator.Value, descIndex, Dbg);
			break;

		case HIDP_LOCAL_DESIG_MIN:
			designator.Range = TRUE;
			ONE_BYTE_DATA(designator.Min, descIndex, Dbg);
			break;

		case HIDP_LOCAL_DESIG_MAX:
			designator.Range = TRUE;
			ONE_BYTE_DATA(designator.Max, descIndex, Dbg);
			break;

		case HIDP_LOCAL_STRING_INDEX:
			string.Range = FALSE;
			ONE_BYTE_DATA(string.Value, descIndex, Dbg);
			break;

		case HIDP_LOCAL_STRING_MIN:
			string.Range = TRUE;
			ONE_BYTE_DATA(string.Min, descIndex, Dbg);
			break;

		case HIDP_LOCAL_STRING_MAX:
			string.Range = TRUE;
			ONE_BYTE_DATA(string.Max, descIndex, Dbg);
			break;

		case HIDP_MAIN_INPUT_1:
			tmpReportIDs = push->ReportIDs;
			bitPos = tmpReportIDs->InputLength; // The distance into the report
			HidP_KdPrint(0, ("'Main Offset:%x \n", bitPos));
			tmpReportIDs->InputLength += push->ReportSize * push->ReportCount;
			channelIndex = &(preparsed->Input.Index);
			ONE_BYTE_DATA(tmpBitField, descIndex, Dbg);
			goto HIDP_PARSE_MAIN_ITEM;

		case HIDP_MAIN_INPUT_2:
			tmpReportIDs = push->ReportIDs;
			bitPos = tmpReportIDs->InputLength; // The distance into the report
			HidP_KdPrint(0, ("'Main2 offset:%x \n", bitPos));
			tmpReportIDs->InputLength += push->ReportSize * push->ReportCount;
			channelIndex = &(preparsed->Input.Index);
			TWO_BYTE_DATA(tmpBitField, descIndex, Dbg);
			goto HIDP_PARSE_MAIN_ITEM;

		case HIDP_MAIN_OUTPUT_1:
			tmpReportIDs = push->ReportIDs;
			bitPos = tmpReportIDs->OutputLength; // The distance into the report
			HidP_KdPrint(0, ("'Out offset:%x \n", bitPos));
			tmpReportIDs->OutputLength += push->ReportSize * push->ReportCount;
			channelIndex = &(preparsed->Output.Index);
			ONE_BYTE_DATA(tmpBitField, descIndex, Dbg);
			goto HIDP_PARSE_MAIN_ITEM;

		case HIDP_MAIN_OUTPUT_2:
			tmpReportIDs = push->ReportIDs;
			bitPos = tmpReportIDs->OutputLength; // The distance into the report
			HidP_KdPrint(0, ("'Out2 offset:%x \n", bitPos));
			tmpReportIDs->OutputLength += push->ReportSize * push->ReportCount;
			channelIndex = &(preparsed->Output.Index);
			TWO_BYTE_DATA(tmpBitField, descIndex, Dbg);
			goto HIDP_PARSE_MAIN_ITEM;

		case HIDP_MAIN_FEATURE_1:
			tmpReportIDs = push->ReportIDs;
			bitPos = tmpReportIDs->FeatureLength; // The distance into the report
			HidP_KdPrint(0, ("'Feature offset:%x \n", bitPos));
			tmpReportIDs->FeatureLength += push->ReportSize * push->ReportCount;
			channelIndex = &(preparsed->Feature.Index);
			ONE_BYTE_DATA(tmpBitField, descIndex, Dbg);
			goto HIDP_PARSE_MAIN_ITEM;

		case HIDP_MAIN_FEATURE_2:
			tmpReportIDs = push->ReportIDs;
			bitPos = tmpReportIDs->FeatureLength; // The distance into the report
			HidP_KdPrint(0, ("'Feature2 offset:%x \n", bitPos));
			tmpReportIDs->FeatureLength += push->ReportSize * push->ReportCount;
			channelIndex = &(preparsed->Feature.Index);
			TWO_BYTE_DATA(tmpBitField, descIndex, Dbg);

		HIDP_PARSE_MAIN_ITEM:

			// You can have a constant field that does return data.
			// so we probably shouldn't skip it.
			// BUT it should NOT be an array style button field.
			if (HIDP_ISARRAY(tmpBitField)) {
				if (HIDP_ISCONST(tmpBitField)) {
					break;
				}
				//
				// Here we have a list of indices that refer to the usages
				// described prior.  For each of the prior usages, up to the depth
				// found, we allocate a channel structure to describe the given
				// usages.  These channels are linked so that we will later know
				// that they all describe the same filled.
				//

				//
				// BUGBUG we do no support delimiteres in array declairations.
				// To do so would require a large change to Index2Usage which
				// instead of returning only one usage would have to return
				// several.
				//

				if (usage->IsAlias) {
					status = STATUS_COULD_NOT_INTERPRET;
					HidP_KdPrint(2, ("Currently this parser does not support\n"));
					HidP_KdPrint(2, ("Delimiters for array declairations\n"));
					Dbg->BreakOffset = descIndex;
					Dbg->ErrorCode = HIDP_GETCOLDESC_UNSUPPORTED;
					goto HIDP_PARSE_REJECT;
				}

				for (;
					usage != &firstUsage;
					(*channelIndex)++,
					usage = HidP_PopUsageList(usage))
				{

					channel = &(preparsed->Data[*channelIndex]);

					channel->BitField = tmpBitField;

					// field that says this channel is linked
					channel->MoreChannels = TRUE;

					// say what link collection number we are in.
					channel->LinkCollection = (USHORT)(currentLCNode - linkNodeArray);
					channel->LinkUsage = currentLCNode->LinkUsage;
					channel->LinkUsagePage = currentLCNode->LinkUsagePage;

					if (usage->UsagePage) {
						// The default usage page been overwritten.
						channel->UsagePage = usage->UsagePage;
					}
					else {
						channel->UsagePage = push->UsagePage;
					}

					channel->BitOffset = (UCHAR)bitPos & 7;
					channel->ByteOffset = (USHORT)bitPos >> 3;
					channel->ReportSize = push->ReportSize;
					channel->ReportCount = push->ReportCount;

					channel->BitLength = push->ReportSize * push->ReportCount;
					channel->ByteEnd = (channel->BitOffset + channel->BitLength);
					channel->ByteEnd = (channel->ByteEnd >> 3)
						+ ((channel->ByteEnd & 7) ? 1 : 0)
						+ channel->ByteOffset;


					channel->ReportID = push->ReportIDs->ReportID;
					channel->Units = push->Unit;
					channel->UnitExp = push->UnitExp;

					channel->IsConst = FALSE;

					channel->IsButton = TRUE;
					channel->IsAbsolute = HIDP_ISABSOLUTE(tmpBitField);
					channel->button.LogicalMin = push->LogicalMin;
					channel->button.LogicalMax = push->LogicalMax;

					channel->IsRange = usage->Range;
					channel->IsDesignatorRange = designator.Range;
					channel->IsStringRange = string.Range;

					if (usage->Range) {
						channel->Range.UsageMin = usage->Min;
						channel->Range.UsageMax = usage->Max;
					}
					else {
						channel->Range.UsageMin =
							channel->Range.UsageMax = usage->Value;
					}
					if (designator.Range) {
						channel->Range.DesignatorMin = designator.Min;
						channel->Range.DesignatorMax = designator.Max;
					}
					else {
						channel->Range.DesignatorMin =
							channel->Range.DesignatorMax = designator.Value;
					}

					if (string.Range) {
						channel->Range.StringMin = string.Min;
						channel->Range.StringMax = string.Max;
					}
					else {
						channel->Range.StringMin =
							channel->Range.StringMax = string.Value;
					}

					channel->NumGlobalUnknowns = push->NumGlobalUnknowns;

					if (push->NumGlobalUnknowns) {
						RtlCopyMemory(channel->GlobalUnknowns,
							push->GlobalUnknowns,
							push->NumGlobalUnknowns
							* sizeof(HIDP_UNKNOWN_TOKEN));
					}

					//
					// Check for power buttons
					//
					if (HIDP_USAGE_SYSCTL_PAGE == channel->UsagePage) {
						if ((channel->Range.UsageMin <= HIDP_USAGE_SYSCTL_POWER) &&
							(HIDP_USAGE_SYSCTL_POWER <= channel->Range.UsageMax)) {
							preparsed->PowerButtonMask |= SYS_BUTTON_POWER;
						}
						if ((channel->Range.UsageMin <= HIDP_USAGE_SYSCTL_SLEEP) &&
							(HIDP_USAGE_SYSCTL_SLEEP <= channel->Range.UsageMax)) {
							preparsed->PowerButtonMask |= SYS_BUTTON_SLEEP;
						}
						if ((channel->Range.UsageMin <= HIDP_USAGE_SYSCTL_WAKE) &&
							(HIDP_USAGE_SYSCTL_WAKE <= channel->Range.UsageMax)) {
							preparsed->PowerButtonMask |= SYS_BUTTON_WAKE;
						}
					}

				}

				ASSERT(0 == usage->Depth);

				channel->MoreChannels = FALSE;
				designator = string = zeroLocal;
				break;
			} // end array style channel


			channel = &(preparsed->Data[*channelIndex]);
			if (HIDP_ISCONST(tmpBitField)) {
				if ((0 == usage->Depth) ||
					((0 == usage->Value) && (0 == usage->Min)
						&& (0 == usage->Max))) {
					//
					// A constant channel with no usage.  Skip it.
					//
		
					usage = HidP_FreeUsageList(usage);
					ASSERT(usage == &firstUsage);
					ASSERT(0 == usage->Depth);
					break;
				}
				channel->IsConst = TRUE;
			}
			else {
				channel->IsConst = FALSE;
			}

			tmpCount = usage->Depth // - 1
				+ (usage->Range ? (usage->Max - usage->Min) : 0);  // + 1

			while (tmpCount > push->ReportCount) {
				// Get rid of excess usages.
				tmpCount = usage->Depth - 1;
				usage = HidP_PopUsageList(usage);

				ASSERT(tmpCount == (usage->Depth +
					(usage->Range ? (usage->Max - usage->Min) : 0)));
			}
			//
			// The last value in the link (aka the top) must be
			// repeated if there are less usages than there are
			// report counts.  That particular usage applies to all
			// field in this main item not yet accounted for.  In this
			// case a single channel descriptor is allocated and
			// report count is set to the number of fields referenced
			// by this usage.
			//
			// Not the usages are listed in reverse order of there appearence
			// in the report descriptor, so the first usage found in this list
			// is the one that should be repeated.
			//
			// tmpCount is the number of field to which this first usage applies.
			//

			tmpCount = 1 + push->ReportCount - tmpCount
				+ usage->Max - usage->Min;

			//
			// The following loop assigns the usage to the fields in this main
			// item in reverse order.
			//
			bitPos += push->ReportSize * (push->ReportCount - tmpCount);
			for (i = 0;
				i < push->ReportCount;

				i += tmpCount, // Bump i by the number of fields for this channel
				tmpCount = 1 + (usage->Range ? (usage->Max - usage->Min) : 0),
				bitPos -= (push->ReportSize * tmpCount)) {

				do { // do for all the aliases.
					channel = &(preparsed->Data[(*channelIndex)++]);

					// set the IsAlias flag now and then clear the last one
					// at the close of this Do while loop.
					channel->IsAlias = TRUE;

					channel->BitField = tmpBitField;
					channel->MoreChannels = FALSE; // only valid for arrays
					channel->LinkCollection = (USHORT)(currentLCNode - linkNodeArray);
					channel->LinkUsage = currentLCNode->LinkUsage;
					channel->LinkUsagePage = currentLCNode->LinkUsagePage;

					if (usage->UsagePage) {
						// The default usage page been overwritten.
						channel->UsagePage = usage->UsagePage;
					}
					else {
						channel->UsagePage = push->UsagePage;
					}

					channel->BitOffset = (UCHAR)bitPos & 7;
					channel->ByteOffset = (USHORT)bitPos >> 3;
					channel->ReportSize = push->ReportSize;
					channel->ReportCount = tmpCount;

					channel->BitLength = push->ReportSize * tmpCount;
					channel->ByteEnd = (channel->BitOffset + channel->BitLength);
					channel->ByteEnd = (channel->ByteEnd >> 3)
						+ ((channel->ByteEnd & 7) ? 1 : 0)
						+ channel->ByteOffset;

					channel->ReportID = push->ReportIDs->ReportID;

					channel->IsAbsolute = HIDP_ISABSOLUTE(tmpBitField);

					channel->Units = push->Unit;
					channel->UnitExp = push->UnitExp;

					if (1 == push->ReportSize) {
						channel->IsButton = TRUE;
					}
					else {
						channel->IsButton = FALSE;
						channel->Data.HasNull = HIDP_HASNULL(channel->BitField);
						channel->Data.LogicalMin = push->LogicalMin;
						channel->Data.LogicalMax = push->LogicalMax;
						channel->Data.PhysicalMin = push->PhysicalMin;
						channel->Data.PhysicalMax = push->PhysicalMax;
					}

					channel->IsDesignatorRange = designator.Range;
					channel->IsStringRange = string.Range;
					channel->IsRange = usage->Range;
					if (usage->Range) {
						channel->Range.UsageMin = usage->Min;
						channel->Range.UsageMax = usage->Max;
					}
					else {
						channel->Range.UsageMin =
							channel->Range.UsageMax = usage->Value;
					}

					if (designator.Range) {
						channel->Range.DesignatorMin = designator.Min;
						channel->Range.DesignatorMax = designator.Max;
					}
					else {
						channel->Range.DesignatorMin =
							channel->Range.DesignatorMax = designator.Value;
					}

					if (string.Range) {
						channel->Range.StringMin = string.Min;
						channel->Range.StringMax = string.Max;
					}
					else {
						channel->Range.StringMin =
							channel->Range.StringMax = string.Value;
					}
					isAlias = usage->IsAlias;
					usage = HidP_PopUsageList(usage); // discard used usage

					channel->NumGlobalUnknowns = push->NumGlobalUnknowns;
					if (push->NumGlobalUnknowns) {
						RtlCopyMemory(channel->GlobalUnknowns,
							push->GlobalUnknowns,
							push->NumGlobalUnknowns
							* sizeof(HIDP_UNKNOWN_TOKEN));
					}

					//
					// Check for power buttons
					//
					if (HIDP_USAGE_SYSCTL_PAGE == channel->UsagePage) {
						if ((channel->Range.UsageMin <= HIDP_USAGE_SYSCTL_POWER) &&
							(HIDP_USAGE_SYSCTL_POWER <= channel->Range.UsageMax)) {
							preparsed->PowerButtonMask |= SYS_BUTTON_POWER;
						}
						if ((channel->Range.UsageMin <= HIDP_USAGE_SYSCTL_SLEEP) &&
							(HIDP_USAGE_SYSCTL_SLEEP <= channel->Range.UsageMax)) {
							preparsed->PowerButtonMask |= SYS_BUTTON_SLEEP;
						}
						if ((channel->Range.UsageMin <= HIDP_USAGE_SYSCTL_WAKE) &&
							(HIDP_USAGE_SYSCTL_WAKE <= channel->Range.UsageMax)) {
							preparsed->PowerButtonMask |= SYS_BUTTON_WAKE;
						}
					}

				} while (isAlias);

				channel->IsAlias = FALSE;
			} // for all channels in this main item

			  // Zero out the locals.
			designator = string = zeroLocal;

			// Hopefully we have used all the local usages now
			ASSERT(usage == &firstUsage);
			break;

		default:
#ifdef HIDP_REJECT_UNDEFINED
			HidP_KdPrint(2, ("Item Unknown %x\n", item));
			Dbg->BreakOffset = descIndex;
			Dbg->ErrorCode = HIDP_GETCOLDESC_ITEM_UNKNOWN;
			Dbg->Args[0] = item;
			status = STATUS_ILLEGAL_INSTRUCTION;
			goto HIDP_PARSE_REJECT;
#else
			if (HIDP_IS_MAIN_ITEM(item)) {
				HidP_KdPrint(2, ("Unknown MAIN item: %x\n", item));
				Dbg->BreakOffset = descIndex;
				Dbg->ErrorCode = HIDP_GETCOLDESC_ITEM_UNKNOWN;
				Dbg->Args[0] = item;
				status = STATUS_ILLEGAL_INSTRUCTION;
				goto HIDP_PARSE_REJECT;

			}
			else if (HIDP_IS_GLOBAL_ITEM(item)) {
				if (HIDP_MAX_UNKNOWN_ITEMS == push->NumGlobalUnknowns) {
					push->NumGlobalUnknowns--;
					// overwrite the last entry;
				}
				unknownToken = &push->GlobalUnknowns[push->NumGlobalUnknowns];
				unknownToken->Token = item;
				switch (item & HIDP_ITEM_LENGTH_DATA) {
				case 0:
					break;
				case 1:
					ONE_BYTE_DATA(unknownToken->BitField, descIndex, Dbg);
					break;
				case 2:
					TWO_BYTE_DATA(unknownToken->BitField, descIndex, Dbg);
					break;
				case 3:
					FOUR_BYTE_DATA(unknownToken->BitField, descIndex, Dbg);
					break;
				}
				push->NumGlobalUnknowns++;

			}
			else if (HIDP_IS_LOCAL_ITEM(item)) {
				HidP_KdPrint(2, ("Unknown LOCAL item: %x\n", item));
				Dbg->BreakOffset = descIndex;
				Dbg->ErrorCode = HIDP_GETCOLDESC_ITEM_UNKNOWN;
				Dbg->Args[0] = item;
				status = STATUS_ILLEGAL_INSTRUCTION;
				goto HIDP_PARSE_REJECT;

			}
			else if (HIDP_IS_RESERVED_ITEM(item)) {
				HidP_KdPrint(2, ("Unknown RESERVED item: %x\n", item));
				Dbg->BreakOffset = descIndex;
				Dbg->ErrorCode = HIDP_GETCOLDESC_ITEM_UNKNOWN;
				Dbg->Args[0] = item;
				status = STATUS_ILLEGAL_INSTRUCTION;
				goto HIDP_PARSE_REJECT;
			}

#endif

			break;
		}
	}

	HidP_FreeUsageList(usage);
	//
	// Since the number of report IDs could be less than the total allocated,
	// due to the fact that some might be repeated, reset the length of the
	// array to reflect the total amount which we found.
	//
	DeviceDesc->ReportIDsLength =
		(ULONG)(currentReportIDs - DeviceDesc->ReportIDs);

	return status;

HIDP_PARSE_REJECT:
	while (push != &firstPush)
	{
		tmpPush = push;
		push = push->Pop;
		ExFreePool(tmpPush);
	}
	if (NULL != usage) {
		//
		// If usage is null, that means that something went wrong. (probably
		// in the push usage routine).  In this case the usage memory should
		// have already been freed.
		//
		HidP_FreeUsageList(usage);
	}
	return status;
}

VOID
HidP_FreeCollectionDescription(
	IN  PHIDP_DEVICE_DESC   Desc
)
{
	ULONG i;

	for (i = 0; i < Desc->CollectionDescLength; i++) {
		ExFreePool(Desc->CollectionDesc[i].PreparsedData);
	}
	ExFreePool(Desc->CollectionDesc);
	ExFreePool(Desc->ReportIDs);

	//
	// Do NOT free Desc itself.
	//
}

#define PHIDP_SYS_POWER_EVENT_BUTTON_LENGTH 0x20

NTSTATUS
HidP_SysPowerCaps(
	IN  PHIDP_PREPARSED_DATA    Ppd,
	OUT PULONG                  OutputBuffer
)
{
	*OutputBuffer = Ppd->PowerButtonMask;
	return STATUS_SUCCESS;
}

void
HidP_AssignDataIndices(
	PHIDP_PREPARSED_DATA Ppd,
	PHIDP_GETCOLDESC_DBG Dbg
)
{
	struct _CHANNEL_REPORT_HEADER * iof;
	PHIDP_CHANNEL_DESC   channel;
	PHIDP_CHANNEL_DESC   scan;
	PHIDP_CHANNEL_DESC   end;
	USHORT i;
	USHORT dataIndex;

	UNREFERENCED_PARAMETER(Dbg);

	iof = &Ppd->Input;

	while (TRUE) {
		dataIndex = 0;

		for (i = iof->Offset, channel = &Ppd->Data[iof->Offset];
			i < iof->Index;
			i++, channel++) {

			if (!channel->MoreChannels) {
				channel->Range.DataIndexMin = dataIndex;
				dataIndex += channel->Range.UsageMax - channel->Range.UsageMin;
				channel->Range.DataIndexMax = dataIndex;
				dataIndex++;
			}
			else {
				//
				// An array channel.  We must number these backwards.
				//

				scan = channel;

				while (scan->MoreChannels) {
					scan++;
					i++;
				}
				end = scan;

				do {
					scan->Range.DataIndexMin = dataIndex;
					dataIndex += scan->Range.UsageMax
						- scan->Range.UsageMin;

					scan->Range.DataIndexMax = dataIndex;
					dataIndex++;
					scan--;

				} while (channel <= scan);
				channel = end;
			}
		}

		if (&Ppd->Input == iof) {
			iof = &Ppd->Output;
		}
		else if (&Ppd->Output == iof) {
			iof = &Ppd->Feature;
		}
		else {
			ASSERT(&Ppd->Feature == iof);
			break;
		}
	}
}


```

`UsbMon/UsbMon/WinParse.h`:

```h
/*++

Module Name:

HIDPARSE.H

Abstract:

This module contains the PRIVATE (driver-only) definitions for the
code that implements the usbd driver.

Environment:

Kernel & user mode

Revision History:

--*/


#ifndef _HIDPARSE_H
#define _HIDPARSE_H

 
#include "hidtoken.h"

#define HIDP_POOL_TAG (ULONG) 'PdiH'
#undef ExAllocatePool
#define ExAllocatePool(type, size) \
            ExAllocatePoolWithTag (type, size, HIDP_POOL_TAG);
// ExAllocatePool is only called in the descript.c and hidparse.c code.
// all other modules are linked into the user DLL.  They cannot allocate any
// memory.

#pragma warning(error:4100)   // Unreferenced formal parameter
#pragma warning(error:4705)   // Statement has no effect

#define DEFAULT_DBG_LEVEL 1 // errors AND warnings

#if DBG
#define HidP_KdPrint(_level_,_x_) \
            if (DEFAULT_DBG_LEVEL <= _level_) { \
               DbgPrint ("'HidParse.SYS: "); \
               DbgPrint _x_; \
            }

#define TRAP() DbgBreakPoint()

#else
#define HidP_KdPrint(_level_,_x_)
#define TRAP()

#endif

#define MIN(a,b) (((a) < (b)) ? (a) : (b))
#define MAX(a,b) (((a) < (b)) ? (b) : (a))

#define HIDP_ISCONST(x)    ((BOOLEAN) ((  (x) & 0x01)  ? TRUE : FALSE))
#define HIDP_ISARRAY(x)    ((BOOLEAN) ((!((x) & 0x02)) ? TRUE : FALSE))
#define HIDP_ISABSOLUTE(x) ((BOOLEAN) ((!((x) & 0x04)) ? TRUE : FALSE))
#define HIDP_HASNULL(x)    ((BOOLEAN) ((  (x) & 0x40)  ? TRUE : FALSE))

#define HIDP_MAX_UNKNOWN_ITEMS 4

typedef struct _HIDP_CHANNEL_DESC
{
	USHORT   UsagePage;
	UCHAR    ReportID;
	UCHAR    BitOffset;       // 0 to 8 value describing bit alignment
						      
	ULONG    BitField;	      // The 8 (plus extra) bits associated with a main item
						      
	USHORT   ReportSize;      // HID defined report size
	USHORT   ReportCount;     // HID defined report count
	USHORT   ByteOffset;      // byte position of start of field in report packet
	USHORT   BitLength;       // total bit length of this channel
						      
	USHORT   ByteEnd;         // First byte not containing bits of this channel.
	USHORT   LinkCollection;  // A unique internal index pointer
	USHORT   LinkUsagePage;
	USHORT   LinkUsage;

	ULONG    Units;
	ULONG    UnitExp;

	ULONG  MoreChannels : 1; // Are there more channel desc associated with
							 // this array.  This happens if there is a
							 // several usages for one main item.
	ULONG  IsConst : 1;		 // Does this channel represent filler
	ULONG  IsButton : 1;	 // Is this a channel of binary usages, not value usages.
	ULONG  IsAbsolute : 1;	 // As apposed to relative
	ULONG  IsRange : 1;
	ULONG  IsAlias : 1;		 // a usage described in a delimiter
	ULONG  IsStringRange : 1;
	ULONG  IsDesignatorRange : 1;
	ULONG  Reserved : 20;
	ULONG  NumGlobalUnknowns : 4;

	struct _HIDP_UNKNOWN_TOKEN GlobalUnknowns[4];


	//Describing a Local Usage for a Usage Page :
	//E.g. Usage Page: 0x9 Usage Min : 0x1 ,  Max : 0x5 
	//mean: This report for Button ( btn1~btn5 )
	union {
		struct {
			USHORT   UsageMin, UsageMax;
			USHORT   StringMin, StringMax;
			USHORT   DesignatorMin, DesignatorMax;
			USHORT   DataIndexMin, DataIndexMax;
		} Range;							
		struct {
			USHORT   Usage, Reserved1;
			USHORT   StringIndex, Reserved2;
			USHORT   DesignatorIndex, Reserved3;
			USHORT   DataIndex, Reserved4;
		} NotRange;
	};

	union {
		struct {
			LONG     LogicalMin, LogicalMax;
		} button;
		struct {
			BOOLEAN  HasNull;  // Does this channel have a null report
			UCHAR    Reserved[3];
			LONG     LogicalMin, LogicalMax;
			LONG     PhysicalMin, PhysicalMax;
		} Data;
	};
} HIDP_CHANNEL_DESC, *PHIDP_CHANNEL_DESC;

struct _CHANNEL_REPORT_HEADER
{
	USHORT Offset;  // Position in the _CHANNEL_ITEM array
	USHORT Size;    // Length in said array
	USHORT Index;
	USHORT ByteLen; // The length of the data including reportID.
					// This is the longest such report that might be received
					// for the given collection.
};

#define HIDP_PREPARSED_DATA_SIGNATURE1 'PdiH'
#define HIDP_PREPARSED_DATA_SIGNATURE2 'RDK '

typedef struct _HIDP_SYS_POWER_INFO {
	ULONG   PowerButtonMask;
} HIDP_SYS_POWER_INFO, *PHIDP_SYS_POWER_INFO;

typedef struct _HIDP_PREPARSED_DATA
{
	LONG   Signature1, Signature2;
	USHORT Usage;
	USHORT UsagePage;

	HIDP_SYS_POWER_INFO;

	// The following channel report headers point to data within
	// the Data field below using array indices.
	struct _CHANNEL_REPORT_HEADER Input;
	struct _CHANNEL_REPORT_HEADER Output;
	struct _CHANNEL_REPORT_HEADER Feature;

	// After the CANNEL_DESC array the follows a LinkCollection array nodes.
	// LinkCollectionArrayOffset is the index given to RawBytes to find
	// the first location of the _HIDP_LINK_COLLECTION_NODE structure array
	// (index zero) and LinkCollectionArrayLength is the number of array
	// elements in that array.
	USHORT LinkCollectionArrayOffset;
	USHORT LinkCollectionArrayLength;

	union {
		HIDP_CHANNEL_DESC    Data[];
		UCHAR                RawBytes[];
	};
} HIDP_PREPARSED_DATA;

// +++++++++++++++++++++++++++++++++++
// The ITEMS supported by this Parser
// +++++++++++++++++++++++++++++++++++

typedef UCHAR HIDP_ITEM;


//
// Power buttons supported by this parser
//
#define HIDP_USAGE_SYSCTL_PAGE HID_USAGE_PAGE_GENERIC
#define HIDP_USAGE_SYSCTL_POWER HID_USAGE_GENERIC_SYSCTL_POWER
#define HIDP_USAGE_SYSCTL_SLEEP HID_USAGE_GENERIC_SYSCTL_SLEEP
#define HIDP_USAGE_SYSCTL_WAKE  HID_USAGE_GENERIC_SYSCTL_WAKE


//
//
// Keyboard Translation
// translation tables from usages to i8042 scan codes.
//

typedef ULONG HIDP_LOOKUP_TABLE_PROC(
	IN  PULONG    Table,
	IN  ULONG     Usage
);
typedef HIDP_LOOKUP_TABLE_PROC * PHIDP_LOOKUP_TABLE_PROC;

typedef BOOLEAN HIDP_SCANCODE_SUBTRANSLATION(
	IN     ULONG                         * Table,
	IN     UCHAR                           Index,
	IN     PHIDP_INSERT_SCANCODES          Insert,
	IN     PVOID                           Context,
	IN     HIDP_KEYBOARD_DIRECTION         KeyAction,
	IN OUT PHIDP_KEYBOARD_MODIFIER_STATE   ModifierState
);
typedef HIDP_SCANCODE_SUBTRANSLATION * PHIDP_SCANCODE_SUBTRANSLATION;

typedef struct _HIDP_SCANCODE_SUBTABLE {
	PHIDP_SCANCODE_SUBTRANSLATION ScanCodeFcn;
	PULONG                        Table;
} HIDP_SCANCODE_SUBTABLE, *PHIDP_SCANCODE_SUBTABLE;


NTSTATUS HidP_TranslateUsage(
	USAGE                         Usage,
	HIDP_KEYBOARD_DIRECTION       KeyAction,
	PHIDP_KEYBOARD_MODIFIER_STATE ModifierState,
	PHIDP_LOOKUP_TABLE_PROC       LookupTableProc,
	PULONG                        TranslationTable,
	PHIDP_SCANCODE_SUBTABLE       SubTranslationTable,
	PHIDP_INSERT_SCANCODES        InsertCodesProcedure,
	PVOID                         InsertCodesContext
);

NTSTATUS
GetCollectionDescription(
	IN     PHIDP_REPORT_DESCRIPTOR   ReportDesc,
	IN     ULONG                     DescLength,
	IN     POOL_TYPE                 PoolType,
	OUT    PHIDP_DEVICE_DESC         DeviceDesc
);

HIDP_LOOKUP_TABLE_PROC HidP_StraightLookup;
HIDP_LOOKUP_TABLE_PROC HidP_AssociativeLookup;

HIDP_SCANCODE_SUBTRANSLATION HidP_KeyboardKeypadCode;
HIDP_SCANCODE_SUBTRANSLATION HidP_ModifierCode;
HIDP_SCANCODE_SUBTRANSLATION HidP_VendorBreakCodesAsMakeCodes;

#endif


```

`UsbMon/UsbMon/hidtoken.h`:

```h
/*++

Copyright (c) 1996      Microsoft Corporation

Module Name:

HIDPI.H

Abstract:

Public Definitions of HID USAGES.

Environment:

Kernel & user mode

Revision History:

Aug-1996 : created Kenneth D. Ray

--*/

#ifndef _HIDTOKEN_H
#define _HIDTOKEN_H

#define HIDP_ITEM_LONG           0xFE
#define HIDP_ITEM_LENGTH_DATA    0x03

#define HIDP_IS_MAIN_ITEM(item)  (((item) & 0xC) == 0x0)
#define HIDP_IS_GLOBAL_ITEM(item) (((item) & 0xC) == 0x4)
#define HIDP_IS_LOCAL_ITEM(item)  (((item) & 0xC) == 0x8)
#define HIDP_IS_RESERVED_ITEM(item) (((item) & 0xC) == 0xC)

// Main Items
// Only main items with one byte data (bSize = 1) are supported.
#define HIDP_MAIN_INPUT_1        0x81
#define HIDP_MAIN_INPUT_2        0x82
#define HIDP_MAIN_OUTPUT_1       0x91
#define HIDP_MAIN_OUTPUT_2       0x92
#define HIDP_MAIN_FEATURE_1      0xB1
#define HIDP_MAIN_FEATURE_2      0xB2
#define HIDP_MAIN_COLLECTION     0xA1
#define HIDP_MAIN_ENDCOLLECTION  0xC0
#define HIDP_ISMAIN(x) (0 == ((x) & 0x0C))
#define HIDP_MAIN_COLLECTION_LINK 0x00
#define HIDP_MAIN_COLLECTION_APP  0x01

// Global Items
#define HIDP_GLOBAL_USAGE_PAGE_1   0x05  // UsagePage of 1 byte
#define HIDP_GLOBAL_USAGE_PAGE_2   0x06  // UsagePage of 2 bytes
#define HIDP_GLOBAL_USAGE_PAGE_4   0x07  // UsagePage of 4 bytes
#define HIDP_GLOBAL_LOG_MIN_1      0x15  // minimum value of size 1 byte.
#define HIDP_GLOBAL_LOG_MIN_2      0x16  // minimum value of size 2 bytes.
#define HIDP_GLOBAL_LOG_MIN_4      0x17  // minimum value of size 4 bytes.
#define HIDP_GLOBAL_LOG_MAX_1      0X25  // maximum of size 1 byte.
#define HIDP_GLOBAL_LOG_MAX_2      0X26  // maximum of size 2 bytes.
#define HIDP_GLOBAL_LOG_MAX_4      0X27  // maximum of size 4 bytes.

#define HIDP_GLOBAL_PHY_MIN_1      0x35  // minimum value of size 1 byte.
#define HIDP_GLOBAL_PHY_MIN_2      0x36  // minimum value of size 2 bytes.
#define HIDP_GLOBAL_PHY_MIN_4      0x37  // minimum value of size 4 bytes.
#define HIDP_GLOBAL_PHY_MAX_1      0X45  // maximum of size 1 byte.
#define HIDP_GLOBAL_PHY_MAX_2      0X46  // maximum of size 2 bytes.
#define HIDP_GLOBAL_PHY_MAX_4      0X47  // maximum of size 4 bytes.

#define HIDP_GLOBAL_UNIT_EXP_1     0x55  // Exponent of size 1 byte.
#define HIDP_GLOBAL_UNIT_EXP_2     0x56  // Exponent of size 2 bytes.
#define HIDP_GLOBAL_UNIT_EXP_4     0x57  // Exponent of size 4 bytes.
#define HIDP_GLOBAL_UNIT_1         0x65  // UNIT of size 1 byte.
#define HIDP_GLOBAL_UNIT_2         0x66  // UNIT of size 2 bytes.
#define HIDP_GLOBAL_UNIT_4         0x67  // UNIT of size 4 bytes.

#define HIDP_GLOBAL_REPORT_SIZE    0x75  // Report size in bits
#define HIDP_GLOBAL_REPORT_ID      0x85  // ID only size 1 byte supported
#define HIDP_GLOBAL_REPORT_COUNT_1 0x95  // Number of data fields 1 byte
#define HIDP_GLOBAL_REPORT_COUNT_2 0x96  // Number of data fields 2 bytes
#define HIDP_GLOBAL_PUSH           0xA4  // The dreaded PUSH command
#define HIDP_GLOBAL_POP            0xB4  // And the dreaded POP command

// Local Items
#define HIDP_LOCAL_USAGE_1         0x09  //
#define HIDP_LOCAL_USAGE_2         0x0A  //
#define HIDP_LOCAL_USAGE_4         0x0B  //
#define HIDP_LOCAL_USAGE_MIN_1     0x19
#define HIDP_LOCAL_USAGE_MIN_2     0x1A
#define HIDP_LOCAL_USAGE_MIN_4     0x1B
#define HIDP_LOCAL_USAGE_MAX_1     0x29
#define HIDP_LOCAL_USAGE_MAX_2     0x2A
#define HIDP_LOCAL_USAGE_MAX_4     0x2B
#define HIDP_LOCAL_DESIG_INDEX     0x39  // Designators of byte size supported
#define HIDP_LOCAL_DESIG_MIN       0x49
#define HIDP_LOCAL_DESIG_MAX       0x59
#define HIDP_LOCAL_STRING_INDEX    0x79  // String indices of size byte supported
#define HIDP_LOCAL_STRING_MIN      0x89
#define HIDP_LOCAL_STRING_MAX      0x99
#define HIDP_LOCAL_DELIMITER       0xA9

#endif
#pragma once

```

`UsbMon/UsbMon/local.h`:

```h
#include <ntddk.h>
#include "UsbType.h"
#include "Hidpddi.h" 

typedef VOID(t_BluescreenFunction)(PVOID Context, PCHAR Buffer);
// Blue Screen IOCTL struct
typedef struct _BlueScreen {
	PVOID Context;                          // Context to pass to processing routine
	t_BluescreenFunction *BluescreenFunction;// Processing routine
	ULONG *IsBluescreenTime;                // Non zero -> blue screen happening
} BLUESCREEN, *PBLUESCREEN;


typedef struct _HID_DESCRIPTOR            *PHID_DESCRIPTOR;
typedef struct _HIDCLASS_COLLECTION       *PHIDCLASS_COLLECTION;
typedef struct _HIDCLASS_DEVICE_EXTENSION *PHIDCLASS_DEVICE_EXTENSION;
typedef struct _HIDCLASS_DRIVER_EXTENSION *PHIDCLASS_DRIVER_EXTENSION;
typedef struct _HIDCLASS_FILE_EXTENSION   *PHIDCLASS_FILE_EXTENSION;
typedef struct _HIDCLASS_PINGPONG         *PHIDCLASS_PINGPONG;
typedef struct _HIDCLASS_REPORT           *PHIDCLASS_REPORT;
typedef struct _FDO_EXTENSION             *PFDO_EXTENSION;
typedef struct _PDO_EXTENSION             *PPDO_EXTENSION;


#if DBG
#define LockFileExtension( f, i )                               \
        {                                                           \
            KeAcquireSpinLock( &(f)->ListSpinLock, (i) );           \
            (f)->ListSpinLockTaken = TRUE;                          \
        }

#define UnlockFileExtension(f, i)                               \
        {                                                           \
            (f)->ListSpinLockTaken = FALSE;                         \
            KeReleaseSpinLock( &(f)->ListSpinLock, (i) );           \
        }

VOID DbgLogIntStart();
VOID DbgLogIntEnd();
#define DBGLOG_INTSTART() DbgLogIntStart()
#define DBGLOG_INTEND() DbgLogIntEnd()

VOID DbgTestGetDeviceString(PFDO_EXTENSION fdoExt);
VOID DbgTestGetIndexedString(PFDO_EXTENSION fdoExt);

#else
#define LockFileExtension(f, i) KeAcquireSpinLock(&(f)->ListSpinLock, (i));
#define UnlockFileExtension(f, i) KeReleaseSpinLock(&(f)->ListSpinLock, (i));

#define DBGLOG_INTSTART()
#define DBGLOG_INTEND()
#endif

#define ALLOCATEPOOL(poolType, size) ExAllocatePoolWithTag((poolType), (size), 'CdiH')

/*
*  String constants for use in compatible-id multi-string.
*/
//                                             0123456789 123456789 1234
#define HIDCLASS_COMPATIBLE_ID_STANDARD_NAME L"HID_DEVICE\0"
#define HIDCLASS_COMPATIBLE_ID_GENERIC_NAME  L"HID_DEVICE_UP:XXXX_U:XXXX\0"
#define HIDCLASS_COMPATIBLE_ID_PAGE_OFFSET  14
#define HIDCLASS_COMPATIBLE_ID_USAGE_OFFSET 21
#define HIDCLASS_COMPATIBLE_ID_STANDARD_LENGTH 11
#define HIDCLASS_COMPATIBLE_ID_GENERIC_LENGTH 26
//                                        0123456789 123456789 123456
#define HIDCLASS_SYSTEM_KEYBOARD        L"HID_DEVICE_SYSTEM_KEYBOARD\0"
#define HIDCLASS_SYSTEM_MOUSE           L"HID_DEVICE_SYSTEM_MOUSE\0"
#define HIDCLASS_SYSTEM_GAMING_DEVICE   L"HID_DEVICE_SYSTEM_GAME\0"
#define HIDCLASS_SYSTEM_CONTROL         L"HID_DEVICE_SYSTEM_CONTROL\0"
#define HIDCLASS_SYSTEM_CONSUMER_DEVICE L"HID_DEVICE_SYSTEM_CONSUMER\0"

#define NO_STATUS 0x80000000    // this will never be a STATUS_xxx constant in NTSTATUS.H

//
// Valid values for HIDCLASS_DEVICE_EXTENSION.state
//
enum deviceState {
	DEVICE_STATE_INITIALIZED,
	DEVICE_STATE_STARTING,
	DEVICE_STATE_START_SUCCESS,
	DEVICE_STATE_START_FAILURE,
	DEVICE_STATE_STOPPED,
	DEVICE_STATE_REMOVING,
	DEVICE_STATE_REMOVED,
	DEVICE_STATE_SUSPENDED
};

enum collectionState {
	COLLECTION_STATE_UNINITIALIZED,
	COLLECTION_STATE_INITIALIZED,
	COLLECTION_STATE_RUNNING,
	COLLECTION_STATE_STOPPED,
	COLLECTION_STATE_REMOVING
};


//
// _HIDCLASS_DRIVER_EXTENSION contains per-minidriver extension information
// for the class driver.  It is created upon a HidRegisterMinidriver() call.
//

typedef struct _HIDCLASS_DRIVER_EXTENSION {

	//
	// Pointer to the minidriver's driver object.
	//

	PDRIVER_OBJECT      MinidriverObject;

	//
	// RegistryPath is a pointer to the minidriver's RegistryPath that it
	// received as a DriverEntry() parameter.
	//

	PUNICODE_STRING     RegistryPath;

	//
	// DeviceExtensionSize is the size of the minidriver's per-device
	// extension.
	//

	ULONG               DeviceExtensionSize;

	//
	// Dispatch routines for the minidriver.  These are the only dispatch
	// routines that the minidriver should ever care about, no others will
	// be forwarded.
	//

	PDRIVER_DISPATCH    MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + 1];

	/*
	*  These are the minidriver's original entrypoints,
	*  to which we chain.
	*/
	PDRIVER_ADD_DEVICE  AddDevice;
	PDRIVER_UNLOAD      DriverUnload;

	//
	// Number of pointers to this structure that we've handed out
	//

	LONG                ReferenceCount;

	//
	// Linkage onto our global list of driver extensions
	//

	LIST_ENTRY          ListEntry;


	/*
	*  Either all or none of the devices driven by a given minidriver are polled.
	*/
	BOOLEAN             DevicesArePolled;


#if DBG

	ULONG               Signature;

#endif

} HIDCLASS_DRIVER_EXTENSION;

#if DBG
#define HID_DRIVER_EXTENSION_SIG 'EdiH'
#endif



#define MIN_POLL_INTERVAL_MSEC      1
#define MAX_POLL_INTERVAL_MSEC      10000
#define DEFAULT_POLL_INTERVAL_MSEC  5


/*
*  Device-specific flags
*/
//  Nanao depends on a Win98G bug that allows GetFeature on input collection
#define DEVICE_FLAG_ALLOW_FEATURE_ON_NON_FEATURE_COLLECTION  (1 << 0)


//
// HIDCLASS_COLLECTION is where we keep our per-collection information.
//

typedef struct _HIDCLASS_COLLECTION {


	ULONG                       CollectionNumber;
	ULONG                       CollectionIndex;

	//
	// DeviceExtension is the pointer to the device extension of which
	// this collection is a member.
	//

	PHIDCLASS_DEVICE_EXTENSION  DeviceExtension;

	//
	// NumOpens is a count of open handles against this collection.
	//

	ULONG                       NumOpens;

	// Number of pending reads for all clients on this collection.
	ULONG                       numPendingReads;

	//
	// FileExtensionList is the head of a list of file extensions, i.e.
	// open instances against this collection.
	//

	LIST_ENTRY                  FileExtensionList;
	KSPIN_LOCK                  FileExtensionListSpinLock;

	/*
	*  For polled devices, we only read from the device
	*  once every poll interval.  We queue read IRPs
	*  here until the poll timer expiration.
	*
	*  Note:  for a polled device, we keep a separate background
	*         loop for each collection.  This way, queued-up read IRPs
	*         remain associated with the right collection.
	*         Also, this will keep the number of reads we do on each
	*         timer period roughly equal to the number of collections.
	*/
	ULONG                       PollInterval_msec;
	KTIMER                      polledDeviceTimer;
	KDPC                        polledDeviceTimerDPC;
	LIST_ENTRY                  polledDeviceReadQueue;
	KSPIN_LOCK                  polledDeviceReadQueueSpinLock;

	/*
	*  We save old reports on polled devices for
	*  "opportunistic" readers who want to get a result right away.
	*  The polledDataIsStale flag indicates that the saved report
	*  is at least one poll interval old (so we should not use it).
	*/
	PUCHAR                      savedPolledReportBuf;
	ULONG                       savedPolledReportLen;
	BOOLEAN                     polledDataIsStale;

	UNICODE_STRING              SymbolicLinkName;
	UNICODE_STRING              SymbolicLinkName_SystemControl;

	/*
	*  HID collection information descriptor for this collection.
	*/
	HID_COLLECTION_INFORMATION  hidCollectionInfo;
	PHIDP_PREPARSED_DATA        phidDescriptor;

	/*
	*  This buffer is used to "cook" a raw report when it's been received.
	*  This is only used for non-polled (interrupt) devices.
	*/
	PUCHAR                      cookedInterruptReportBuf;

	/*
	*  This is an IRP that we queue and complete
	*  when a read report contains a power event.
	*
	*  The powerEventIrp field retains an IRP
	*  so it needs a spinlock to synchronize cancellation.
	*/
	PIRP                        powerEventIrp;
	KSPIN_LOCK                  powerEventSpinLock;


#if DBG
	ULONG                   Signature;
#endif

} HIDCLASS_COLLECTION;

#if DBG
#define HIDCLASS_COLLECTION_SIG 'EccH'
#endif

//
// For HID devices that have at least one interrupt-style collection, we
// try to keep a set of "ping-pong" report-read IRPs pending in the minidriver
// in the event we get a report.
//
// HIDCLASS_PINGPONG contains a pointer to an IRP as well as an event
// and status block.  Each device has a pointer to an array of these structures,
// the array size depending on the number of such IRPs we want to keep in
// motion.
//
// Right now the default number is 2.
//

#define MIN_PINGPONG_IRPS   2

typedef struct _HIDCLASS_PINGPONG {

#define PINGPONG_SIG (ULONG)'gnoP'
	ULONG           sig;

	PIRP    irp;
	PUCHAR  reportBuffer;
	LONG    weAreCancelling;

	KEVENT sentEvent;       // When a read has been sent.
	KEVENT pumpDoneEvent;   // When the read loop is finally exitting.

	PFDO_EXTENSION   myFdoExt;

	/*
	*  Timeout context for back-off algorithm applied to broken devices.
	*/
	KTIMER          backoffTimer;
	KDPC            backoffTimerDPC;
	LARGE_INTEGER   backoffTimerPeriod; // in negative 100-nsec units

} HIDCLASS_PINGPONG;

#if DBG
#define HIDCLASS_REPORT_BUFFER_GUARD    'draG'
#endif


/*
*  Stores information about a Functional Device Object (FDO) which HIDCLASS attaches
*  to the top of the Physical Device Object (PDO) that it get from the minidriver below.
*/
#pragma pack(push, 8)
typedef struct _FDO_EXTENSION {

	//
	// Back pointer to the functional device object
	//
	PDEVICE_OBJECT          fdo;

	//
	// HidDriverExtension is a pointer to our driver extension for the
	// minidriver that gave us the PDO.
	//

	PHIDCLASS_DRIVER_EXTENSION driverExt;

	//
	// Hid descriptor that we get from the device.
	//

	HID_DESCRIPTOR          hidDescriptor;  // 9 bytes

											//
											// The attributes of this hid device.
											//

	HID_DEVICE_ATTRIBUTES   hidDeviceAttributes;  // 0x20 bytes

												  //
												  // Pointer to and length of the raw report descriptor.
												  //

	PUCHAR                  rawReportDescription;
	ULONG                   rawReportDescriptionLength;

	//
	// This device has one or more collections.  We store the count and
	// pointer to an array of our HIDCLASS_COLLECTION structures (one per
	// collection) here.
	//

	PHIDCLASS_COLLECTION    classCollectionArray;  // BUGBUG put each of these into pdoExt.

												   /*
												   *  This is initialized for us by HIDPARSE's HidP_GetCollectionDescription().
												   *  It includes an array of HIDP_COLLECTION_DESC structs corresponding
												   *  the classCollectionArray declared above.
												   */
	HIDP_DEVICE_DESC        deviceDesc;     // 0x30 bytes
	BOOLEAN                 devDescInitialized;

	//
	// The maximum input size amongst ALL report types.
	//
	ULONG                   maxReportSize;

	//
	// For devices that have at least one interrupt collection, we keep
	// a couple of ping-pong IRPs and associated structures.
	// The ping-pong IRPs ferry data up from the USB hub.
	//
	ULONG                   numPingPongs;
	PHIDCLASS_PINGPONG      pingPongs;

	//
	// OpenCount represents the number of file objects aimed at this device
	//
	ULONG                   openCount;


	/*
	*  This is the number of IRPs still outstanding in the minidriver.
	*/

	ULONG                   outstandingRequests;

	enum deviceState        state;

	UNICODE_STRING          name;

	/*
	*  deviceRelations contains an array of client PDO pointers.
	*
	*  As the HID bus driver, HIDCLASS produces this data structure to report
	*  collection-PDOs to the system.
	*/
	PDEVICE_RELATIONS       deviceRelations;

	/*
	*  This is an array of device extensions for the collection-PDOs of this
	*  device-FDO.
	*/
	PHIDCLASS_DEVICE_EXTENSION   *collectionPdoExtensions;


	/*
	*  This includes a
	*  table mapping system power states to device power states.
	*/
	DEVICE_CAPABILITIES deviceCapabilities;

	/*
	*  Track current system power state
	*/
	SYSTEM_POWER_STATE  systemPowerState;

	/*
	*  Wait Wake Irp sent to parent PDO
	*/
	PIRP        waitWakeIrp;
	KSPIN_LOCK  waitWakeSpinLock;
	BOOLEAN isWaitWakePending;


	BOOLEAN isOutputOnlyDevice;

	/*
	*  This is a list of WaitWake IRPs sent to the collection-PDOs
	*  on this device, which we just save and complete when the
	*  base device's WaitWake IRP completes.
	*/
	LIST_ENTRY  collectionWaitWakeIrpQueue;
	KSPIN_LOCK  collectionWaitWakeIrpQueueSpinLock;

	struct _FDO_EXTENSION       *nextFdoExt;

	/*
	*  Device-specific flags (DEVICE_FLAG_xxx).
	*/
	ULONG deviceSpecificFlags;

	/*
	*  This is our storage space for the systemState IRP that we need to hold
	*  on to and complete in DevicePowerRequestCompletion.
	*/
	PIRP currentSystemStateIrp;

#if DBG
	WCHAR dbgDriverKeyName[64];
#endif


} FDO_EXTENSION;
#pragma pack(pop)

/*
*  Stores information about a Physical Device Object (PDO) which HIDCLASS creates
*  for each HID device-collection.
*/
#pragma pack(push, 8)
typedef struct _PDO_EXTENSION {

	enum collectionState    state;

	ULONG                   collectionNum;
	ULONG                   collectionIndex;
	PDEVICE_OBJECT          pdo;                // represents a collection on the HID "bus"
	PUNICODE_STRING         name;
	char					reserved[28];
	/*
	*  This is a back-pointer to the original FDO's extension.
	*/
	PHIDCLASS_DEVICE_EXTENSION  deviceFdoExt;


	/*
	*  Access protection information.
	*  We count the number of opens for read and write on the collection.
	*  We also count the number of opens which RESTRICT future
	*  read/write opens on the collection.
	*
	*  Note that desired access is independent of restriction.
	*  A client may, for example, do an open-for-read-only but
	*  (by not setting the FILE_SHARE_WRITE bit)
	*  restrict other clients from doing an open-for-write.
	*/
	ULONG                       openCount;
	ULONG                       opensForRead;
	ULONG                       opensForWrite;
	ULONG                       restrictionsForRead;
	ULONG                       restrictionsForWrite;
	ULONG                       restrictionsForAnyOpen;

} PDO_EXTENSION;
#pragma pack(pop)
/*
*  This contains info about either a device FDO or a device-collection PDO.
*  Some of the same functions process both, so we need one structure.
*/
typedef struct _HIDCLASS_DEVICE_EXTENSION {

	/*
	*  This is the public part of a HID FDO device extension, and
	*  must be the first entry in this structure.
	*/
	HID_DEVICE_EXTENSION    hidExt;     // size== 0x0C.

										/*
										*  Determines whether this is a device extension for a device-FDO or a
										*  device-collection-PDO; this resolves the following union.
										*/
	BOOLEAN                 isClientPdo;

	/*
	*  Include this signature for both debug and retail --
	*  kenray's debug extensions look for this.
	*/
#define             HID_DEVICE_EXTENSION_SIG 'EddH'
	ULONG               Signature;

	union {
		FDO_EXTENSION       fdoExt;
		PDO_EXTENSION       pdoExt;
	};


} HIDCLASS_DEVICE_EXTENSION;

//
// HIDCLASS_FILE_EXTENSION is private data we keep per file object.
//

typedef struct _HIDCLASS_FILE_EXTENSION {

	//
	// CollectionNumber is the ordinal of the collection in the device
	//

	ULONG                       CollectionNumber;


	PFDO_EXTENSION              fdoExt;

	//
	// PendingIrpList is a list of READ IRPs currently waiting to be satisfied.
	//

	LIST_ENTRY                  PendingIrpList;

	//
	// ReportList is a list of reports waiting to be read on this handle.
	//

	LIST_ENTRY                  ReportList;

	//
	// FileList provides a way to link all of a collection's
	// file extensions together.
	//

	LIST_ENTRY                  FileList;

	//
	// Both PendingIrpList and ReportList are protected by the same spinlock,
	// ListSpinLock.
	//
	KSPIN_LOCK                  ListSpinLock;

	//
	// MaximumInputReportAge is only applicable for polled collections.
	// It represents the maximum acceptable input report age for this handle.
	// There is a value in the HIDCLASS_COLLECTION,
	// CurrentMaximumInputReportAge, that represents the current minimum value
	// of all of the file extensions open against the collection.
	//

	LARGE_INTEGER               MaximumInputReportAge;

	//
	// CurrentInputReportQueueSize is the current size of the report input
	// queue.
	//

	ULONG                       CurrentInputReportQueueSize;

	/*
	*  This is the maximum number of reports that will be queued for the file extension.
	*  This starts at a default value and can be adjusted (within a fixed range) by an IOCTL.
	*/
	ULONG                       MaximumInputReportQueueSize;
#define MIN_INPUT_REPORT_QUEUE_SIZE MIN_PINGPONG_IRPS
#define MAX_INPUT_REPORT_QUEUE_SIZE (MIN_INPUT_REPORT_QUEUE_SIZE*100)
#define DEFAULT_INPUT_REPORT_QUEUE_SIZE (MIN_INPUT_REPORT_QUEUE_SIZE*4)

	//
	// Back pointer to the file object that this extension is for
	//

	PFILE_OBJECT                FileObject;


	/*
	*  File-attributes passed in irpSp->Parameters.Create.FileAttributes
	*  when this open was made.
	*/
	USHORT                      FileAttributes;
	ACCESS_MASK                 accessMask;
	USHORT                      shareMask;

	//
	// Closing is set when this file object is closing and will be removed
	// shortly.  Don't queue any more reports or IRPs to this object
	// when this flag is set.
	//

	BOOLEAN                     Closing;

	//
	// Security has been checked.
	//

	BOOLEAN                     SecurityCheck;

	//
	// DWORD allignment
	//
	BOOLEAN                     Reserved[2];

	/*
	*  This flag indicates that this client does irregular, opportunistic
	*  reads on the device, which is a polled device.
	*  Instead of waiting for the background timer-driven read loop,
	*  this client should have his reads completed immediately.
	*/
	BOOLEAN                     isOpportunisticPolledDeviceReader;
	ULONG                       nowCompletingIrpForOpportunisticReader;


	/*
	*  haveReadPrivilege TRUE indicates that the client has full
	*  permissions on the device, including read.
	*/
	BOOLEAN                     haveReadPrivilege;

	//
	// Memphis Blue Screen info
	//
	BLUESCREEN                  BlueScreenData;


	/*
	*  If a read fails, some clients reissue the read on the same thread.
	*  If this happens repeatedly, we can run out of stack space.
	*  So we keep track of the depth
	*/
#define INSIDE_READCOMPLETE_MAX 4
	ULONG						insideReadCompleteCount;

#if DBG
	BOOLEAN                     ListSpinLockTaken;
	ULONG                       Signature;
#endif

} HIDCLASS_FILE_EXTENSION;

#if DBG
#define HIDCLASS_FILE_EXTENSION_SIG 'efcH'
#endif


typedef struct {

#define ASYNC_COMPLETE_CONTEXT_SIG 'cnsA'
	ULONG sig;

	WORK_QUEUE_ITEM workItem;
	PIRP irp;
	PDEVICE_OBJECT devObj;
} ASYNC_COMPLETE_CONTEXT;


//
// HIDCLASS_REPORT is the structure we use to track a report returned from
// the minidriver.
//

typedef struct _HIDCLASS_REPORT {

	//
	// ListEntry queues this report onto a file extension.
	//

	LIST_ENTRY  ListEntry;

	ULONG reportLength;
	//
	// UnparsedReport is a data area for the unparsed report data as returned
	// from the minidriver.  The lengths of all input reports for a given
	// class are the same, so we don't need to store the length in each
	// report.
	//

	UCHAR       UnparsedReport[];

} HIDCLASS_REPORT;




```

`UsbMon/UsbMon/x64/Debug/StackTrace.Build.CppClean.log`:

```log
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\vc140.pdb
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\driver.obj
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\x64\debug\stacktrace\stacktrace.cat
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\x64\debug\stacktrace.sys
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\x64\debug\stacktrace.pdb
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\x64.obj
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.inf
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\x64\debug\stacktrace.cer
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\x64\debug\stacktrace.inf
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.tlog\cl.command.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.tlog\cl.read.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.tlog\cl.write.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.tlog\inf2cat-expand.11928.read.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.tlog\inf2cat-expand.11928.write.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.tlog\inf2cat-expand.read.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.tlog\inf2cat-expand.write.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.tlog\inf2cat.command.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.tlog\inf2cat.read.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.tlog\inf2cat.write.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.tlog\link.command.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.tlog\link.read.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.tlog\link.write.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.tlog\signtool.command.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.tlog\signtool.read.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.tlog\signtool.timestamp.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.tlog\signtool.write.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.tlog\stacktrace.write.1u.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.tlog\stampinf.command.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.tlog\stampinf.read.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usb\stacktrace\stacktrace\x64\debug\stacktrace.tlog\stampinf.write.1.tlog

```

`UsbMon/UsbMon/x64/Debug/StackTrace.log`:

```log
  Building 'UsbMon' with toolset 'WindowsKernelModeDriver10.0' and the 'Desktop' target platform.
  Stamping x64\Debug\StackTrace.inf [Version] section with DriverVer=02/21/2017,18.33.29.455
  Assembling x64.asm...
  Driver.c
  StackTrace.vcxproj -> C:\Users\kelvinchan\Documents\Visual Studio 2015\Projects\usb\StackTrace\x64\Debug\UsbMon.sys
  StackTrace.vcxproj -> C:\Users\kelvinchan\Documents\Visual Studio 2015\Projects\usb\StackTrace\x64\Debug\UsbMon.pdb (Full PDB)
  Done Adding Additional Store
  Successfully signed: C:\Users\kelvinchan\Documents\Visual Studio 2015\Projects\usb\StackTrace\x64\Debug\UsbMon.sys
  
  ........................
  Signability test complete.
  
  Errors:
  None
  
  Warnings:
  None
  
  Catalog generation complete.
  C:\Users\kelvinchan\Documents\Visual Studio 2015\Projects\usb\StackTrace\x64\Debug\UsbMon\stacktrace.cat
  Done Adding Additional Store
  Successfully signed: C:\Users\kelvinchan\Documents\Visual Studio 2015\Projects\usb\StackTrace\x64\Debug\UsbMon\stacktrace.cat
  

```

`UsbMon/UsbMon/x64/Debug/UsbMon.Build.CppClean.log`:

```log
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\vc140.pdb
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\driver.obj
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\x64\debug\usbmon\stacktrace.cat
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\x64\debug\usbmon.sys
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\x64\debug\usbmon.pdb
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\usbmon.inf
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\x64\debug\usbmon.cer
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\x64\debug\usbmon.inf
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\usbmon.tlog\cl.command.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\usbmon.tlog\cl.read.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\usbmon.tlog\cl.write.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\usbmon.tlog\inf2cat-expand.14528.read.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\usbmon.tlog\inf2cat-expand.14528.write.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\usbmon.tlog\inf2cat-expand.read.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\usbmon.tlog\inf2cat-expand.write.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\usbmon.tlog\inf2cat.command.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\usbmon.tlog\inf2cat.read.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\usbmon.tlog\inf2cat.write.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\usbmon.tlog\link.command.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\usbmon.tlog\link.read.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\usbmon.tlog\link.write.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\usbmon.tlog\signtool.command.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\usbmon.tlog\signtool.read.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\usbmon.tlog\signtool.timestamp.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\usbmon.tlog\signtool.write.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\usbmon.tlog\stampinf.command.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\usbmon.tlog\stampinf.read.1.tlog
c:\users\kelvinchan\documents\visual studio 2015\projects\usbmon\usbmon\x64\debug\usbmon.tlog\stampinf.write.1.tlog

```

`UsbMon/UsbMon/x64/Debug/UsbMon.inf`:

```inf
;
; StackTrace.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=StackTrace.cat
DriverVer=09/26/2019,0.36.53.522
 

[DestinationDirs]
DefaultDestDir = 12


[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]


[Manufacturer]
%ManufacturerName%=Standard,NTamd64

[Standard.NTamd64]


[Strings]
ManufacturerName="StackTrace"
ClassName=""
DiskName="StackTrace Source Disk"

```

`UsbMon/UsbMon/x64/Debug/UsbMon.log`:

```log
  Building 'UsbMon' with toolset 'WindowsKernelModeDriver10.0' and the 'Desktop' target platform.
  Stamping x64\Debug\UsbMon.inf [Version] section with DriverVer=09/26/2019,0.36.53.522
  CommonUtil.c
  Driver.c
  HidHijack.c
  IrpHook.c
  OpenLoopBuffer.c
  ReportUtil.c
  UsbHid.c
  UsbUtil.c
  Generating Code...
  UsbMon.vcxproj -> C:\github\UsbMon\UsbMon\x64\Debug\UsbMon.sys
  UsbMon.vcxproj -> C:\github\UsbMon\UsbMon\x64\Debug\UsbMon.pdb (Full PDB)
  Done Adding Additional Store
  Successfully signed: C:\github\UsbMon\UsbMon\x64\Debug\UsbMon.sys
  
  .........................
  Signability test complete.
  
  Errors:
  None
  
  Warnings:
  None
  
  Catalog generation complete.
  C:\github\UsbMon\UsbMon\x64\Debug\UsbMon\stacktrace.cat
  Done Adding Additional Store
  Successfully signed: C:\github\UsbMon\UsbMon\x64\Debug\UsbMon\stacktrace.cat
  

```

`UsbMon/UsbMon/x64/Release/UsbMon.inf`:

```inf
;
; StackTrace.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=StackTrace.cat
DriverVer=09/26/2019,0.37.4.518
 

[DestinationDirs]
DefaultDestDir = 12


[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]


[Manufacturer]
%ManufacturerName%=Standard,NTamd64

[Standard.NTamd64]


[Strings]
ManufacturerName="StackTrace"
ClassName=""
DiskName="StackTrace Source Disk"

```

`UsbMon/UsbMon/x64/Release/UsbMon.log`:

```log
  Building 'UsbMon' with toolset 'WindowsKernelModeDriver10.0' and the 'Desktop' target platform.
  Stamping x64\Release\UsbMon.inf [Version] section with DriverVer=09/26/2019,0.37.4.518
  CommonUtil.c
  Driver.c
  HidHijack.c
  IrpHook.c
  OpenLoopBuffer.c
  ReportUtil.c
  UsbHid.c
  UsbUtil.c
  Generating Code...
  UsbMon.vcxproj -> C:\github\UsbMon\UsbMon\x64\Release\UsbMon.sys
  UsbMon.vcxproj -> C:\github\UsbMon\UsbMon\x64\Release\UsbMon.pdb (Full PDB)
  Done Adding Additional Store
  Successfully signed: C:\github\UsbMon\UsbMon\x64\Release\UsbMon.sys
  
  .........................
  Signability test complete.
  
  Errors:
  None
  
  Warnings:
  None
  
  Catalog generation complete.
  C:\github\UsbMon\UsbMon\x64\Release\UsbMon\stacktrace.cat
  Done Adding Additional Store
  Successfully signed: C:\github\UsbMon\UsbMon\x64\Release\UsbMon\stacktrace.cat
  

```

`UsbMon/VTxRing3/IOCTL.h`:

```h
#pragma once	
#include <winioctl.h>
#define FILE_DEVICE_HIDE	0x8000

#define IOCTL_BASE	0x800

#define CTL_CODE_HIDE(i)	\
	CTL_CODE(FILE_DEVICE_HIDE, IOCTL_BASE+i, METHOD_BUFFERED, FILE_ANY_ACCESS)


#define IOCTL_HIDE_ADD				CTL_CODE_HIDE(1)			//初始化
#define IOCTL_HIDE_START			CTL_CODE_HIDE(2)			//初始化
#define IOCTL_HIDE_STOP				CTL_CODE_HIDE(3)			//初始化
```

`UsbMon/VTxRing3/VTxRing3.cpp`:

```cpp

// VTxRing3.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "VTxRing3.h"
#include "VTxRing3Dlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif


// CVTxRing3App

BEGIN_MESSAGE_MAP(CVTxRing3App, CWinApp)
	ON_COMMAND(ID_HELP, &CWinApp::OnHelp)
END_MESSAGE_MAP()


// CVTxRing3App construction

CVTxRing3App::CVTxRing3App()
{
	// support Restart Manager
	m_dwRestartManagerSupportFlags = AFX_RESTART_MANAGER_SUPPORT_RESTART;

	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}


// The one and only CVTxRing3App object

CVTxRing3App theApp;


// CVTxRing3App initialization

BOOL CVTxRing3App::InitInstance()
{
	// InitCommonControlsEx() is required on Windows XP if an application
	// manifest specifies use of ComCtl32.dll version 6 or later to enable
	// visual styles.  Otherwise, any window creation will fail.
	INITCOMMONCONTROLSEX InitCtrls;
	InitCtrls.dwSize = sizeof(InitCtrls);
	// Set this to include all the common control classes you want to use
	// in your application.
	InitCtrls.dwICC = ICC_WIN95_CLASSES;
	InitCommonControlsEx(&InitCtrls);

	CWinApp::InitInstance();


	AfxEnableControlContainer();

	// Create the shell manager, in case the dialog contains
	// any shell tree view or shell list view controls.
	CShellManager *pShellManager = new CShellManager;

	// Activate "Windows Native" visual manager for enabling themes in MFC controls
	CMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows));

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	// of your final executable, you should remove from the following
	// the specific initialization routines you do not need
	// Change the registry key under which our settings are stored
	// TODO: You should modify this string to be something appropriate
	// such as the name of your company or organization
	SetRegistryKey(_T("Local AppWizard-Generated Applications"));

	CVTxRing3Dlg dlg;
	m_pMainWnd = &dlg;
	INT_PTR nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}
	else if (nResponse == -1)
	{
		TRACE(traceAppMsg, 0, "Warning: dialog creation failed, so application is terminating unexpectedly.\n");
		TRACE(traceAppMsg, 0, "Warning: if you are using MFC controls on the dialog, you cannot #define _AFX_NO_MFC_CONTROLS_IN_DIALOGS.\n");
	}

	// Delete the shell manager created above.
	if (pShellManager != NULL)
	{
		delete pShellManager;
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}


```

`UsbMon/VTxRing3/VTxRing3.h`:

```h

// VTxRing3.h : main header file for the PROJECT_NAME application
//

#pragma once

#ifndef __AFXWIN_H__
	#error "include 'stdafx.h' before including this file for PCH"
#endif

#include "resource.h"		// main symbols


// CVTxRing3App:
// See VTxRing3.cpp for the implementation of this class
//

class CVTxRing3App : public CWinApp
{
public:
	CVTxRing3App();

// Overrides
public:
	virtual BOOL InitInstance();

// Implementation

	DECLARE_MESSAGE_MAP()
};

extern CVTxRing3App theApp;
```

`UsbMon/VTxRing3/VTxRing3.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#ifndef APSTUDIO_INVOKED
#include "targetver.h"
#endif
#include "afxres.h"
#include "verrsrc.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// Chinese (Traditional, Taiwan) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHT)
LANGUAGE LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#ifndef APSTUDIO_INVOKED\r\n"
    "#include ""targetver.h""\r\n"
    "#endif\r\n"
    "#include ""afxres.h""\r\n"
    "#include ""verrsrc.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "#define _AFX_NO_SPLITTER_RESOURCES\r\n"
    "#define _AFX_NO_OLE_RESOURCES\r\n"
    "#define _AFX_NO_TRACKER_RESOURCES\r\n"
    "#define _AFX_NO_PROPERTY_RESOURCES\r\n"
    "\r\n"
    "#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)\r\n"
    "LANGUAGE 9, 1\r\n"
    "#include ""res\\VTxRing3.rc2""  // non-Microsoft Visual C++ edited resources\r\n"
    "#include ""afxres.rc""      // Standard components\r\n"
    "#if !defined(_AFXDLL)\r\n"
    "#include ""afxribbon.rc""   // MFC ribbon and control bar resources\r\n"
    "#endif\r\n"
    "#endif\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDR_MAINFRAME           ICON                    "res\\VTxRing3.ico"

#endif    // Chinese (Traditional, Taiwan) resources
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

IDD_ABOUTBOX DIALOGEX 0, 0, 170, 62
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "About VTxRing3"
FONT 8, "MS Shell Dlg", 0, 0, 0x1
BEGIN
    ICON            IDR_MAINFRAME,IDC_STATIC,14,14,21,20
    LTEXT           "VTxRing3, Version 1.0",IDC_STATIC,42,14,114,8,SS_NOPREFIX
    LTEXT           "Copyright (C) 2016",IDC_STATIC,42,26,114,8
    DEFPUSHBUTTON   "OK",IDOK,113,41,50,14,WS_GROUP
END

IDD_VTXRING3_DIALOG DIALOGEX 0, 0, 116, 30
STYLE DS_SETFONT | DS_FIXEDSYS | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME
EXSTYLE WS_EX_APPWINDOW
CAPTION "VTxRing3"
FONT 8, "MS Shell Dlg", 0, 0, 0x1
BEGIN
    DEFPUSHBUTTON   "Load Driver",IDOK,7,7,50,16
    PUSHBUTTON      "Unload Driver",IDC_BUTTON2,59,7,50,16
END


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,1
 PRODUCTVERSION 1,0,0,1
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x1L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904B0"
        BEGIN
            VALUE "CompanyName", "TODO: <Company name>"
            VALUE "FileDescription", "VTxRing3"
            VALUE "FileVersion", "1.0.0.1"
            VALUE "InternalName", "VTxRing3.exe"
            VALUE "LegalCopyright", "TODO: (c) <Company name>.  All rights reserved."
            VALUE "OriginalFilename", "VTxRing3.exe"
            VALUE "ProductName", "TODO: <Product name>"
            VALUE "ProductVersion", "1.0.0.1"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// DESIGNINFO
//

#ifdef APSTUDIO_INVOKED
GUIDELINES DESIGNINFO
BEGIN
    IDD_ABOUTBOX, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 163
        TOPMARGIN, 7
        BOTTOMMARGIN, 55
    END

    IDD_VTXRING3_DIALOG, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 109
        TOPMARGIN, 7
        BOTTOMMARGIN, 23
    END
END
#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// AFX_DIALOG_LAYOUT
//

IDD_VTXRING3_DIALOG AFX_DIALOG_LAYOUT
BEGIN
    0
END


/////////////////////////////////////////////////////////////////////////////
//
// String Table
//

STRINGTABLE
BEGIN
    IDS_ABOUTBOX            "&About VTxRing3..."
END

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
#define _AFX_NO_SPLITTER_RESOURCES
#define _AFX_NO_OLE_RESOURCES
#define _AFX_NO_TRACKER_RESOURCES
#define _AFX_NO_PROPERTY_RESOURCES

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE 9, 1
#include "res\VTxRing3.rc2"  // non-Microsoft Visual C++ edited resources
#include "afxres.rc"      // Standard components
#if !defined(_AFXDLL)
#include "afxribbon.rc"   // MFC ribbon and control bar resources
#endif
#endif

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`UsbMon/VTxRing3/VTxRing3.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{C5036DB1-D9D6-45F1-BFC9-720975850C7A}</ProjectGuid>
    <RootNamespace>VTxRing3</RootNamespace>
    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
    <Keyword>MFCProj</Keyword>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Static</UseOfMfc>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Static</UseOfMfc>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Static</UseOfMfc>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Static</UseOfMfc>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_WINDOWS;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <ValidateAllParameters>true</ValidateAllParameters>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <Culture>0x0409</Culture>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_WINDOWS;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <ValidateAllParameters>true</ValidateAllParameters>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <Culture>0x0409</Culture>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;_WINDOWS;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <ValidateAllParameters>true</ValidateAllParameters>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <Culture>0x0409</Culture>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>_WINDOWS;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <ValidateAllParameters>true</ValidateAllParameters>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <Culture>0x0409</Culture>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Text Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="cDrvCtrl.h" />
    <ClInclude Include="IOCTL.h" />
    <ClInclude Include="Resource.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
    <ClInclude Include="VTxRing3.h" />
    <ClInclude Include="VTxRing3Dlg.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="cDrvCtrl.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="VTxRing3.cpp" />
    <ClCompile Include="VTxRing3Dlg.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="VTxRing3.rc" />
  </ItemGroup>
  <ItemGroup>
    <None Include="res\VTxRing3.rc2" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="res\VTxRing3.ico" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
  <ProjectExtensions>
    <VisualStudio>
      <UserProperties RESOURCE_FILE="VTxRing3.rc" />
    </VisualStudio>
  </ProjectExtensions>
</Project>
```

`UsbMon/VTxRing3/VTxRing3.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Text Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="VTxRing3.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="VTxRing3Dlg.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="cDrvCtrl.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IOCTL.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="VTxRing3.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="VTxRing3Dlg.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="stdafx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="cDrvCtrl.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="VTxRing3.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="res\VTxRing3.rc2">
      <Filter>Resource Files</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <Image Include="res\VTxRing3.ico">
      <Filter>Resource Files</Filter>
    </Image>
  </ItemGroup>
</Project>
```

`UsbMon/VTxRing3/VTxRing3Dlg.cpp`:

```cpp

// VTxRing3Dlg.cpp : implementation file
//

#include "stdafx.h"
#include "VTxRing3.h"
#include "VTxRing3Dlg.h"
#include "afxdialogex.h"
#include "cDrvCtrl.h"
#include "IOCTL.h"	
#include "tlhelp32.h"
#ifdef _DEBUG
#define new DEBUG_NEW
#endif

#include <winternl.h>

#pragma comment(lib,"ntdll.lib") // Need to link with ntdll.lib import library. You can find the ntdll.lib from the Windows DDK.

typedef struct _TRANSFER_IOCTL
{
	ULONG64 ProcID;
	ULONG64 HiddenType;
	ULONG64 Address;
}TRANSFERIOCTL, *PTRANSFERIOCTL;
// CAboutDlg dialog used for App About

#define FILE_DEVICE_HIDE	0x8000

#define IOCTL_BASE	0x800

#define CTL_CODE_HIDE(i)	\
	CTL_CODE(FILE_DEVICE_HIDE, IOCTL_BASE+i, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_USB_MAPPING_START		CTL_CODE_HIDE(1)			//初始化
#define IOCTL_USB_MAPPING_STOP		CTL_CODE_HIDE(2)			//初始化
#define IOCTL_HIDE_STOP				CTL_CODE_HIDE(3)			//初始化

class CAboutDlg : public CDialogEx
{
public:
	CAboutDlg();

// Dialog Data
#ifdef AFX_DESIGN_TIME
	enum { IDD = IDD_ABOUTBOX };
#endif

	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Implementation
protected:
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialogEx(IDD_ABOUTBOX)
{
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx)
END_MESSAGE_MAP()


// CVTxRing3Dlg dialog



CVTxRing3Dlg::CVTxRing3Dlg(CWnd* pParent /*=NULL*/)
	: CDialogEx(IDD_VTXRING3_DIALOG, pParent)
{
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CVTxRing3Dlg::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CVTxRing3Dlg, CDialogEx)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDOK, &CVTxRing3Dlg::OnBnClickedOk)
	ON_BN_CLICKED(IDCANCEL, &CVTxRing3Dlg::OnBnClickedCancel)
	ON_BN_CLICKED(IDC_BUTTON1, &CVTxRing3Dlg::OnBnClickedButton1)
	ON_BN_CLICKED(IDC_BUTTON2, &CVTxRing3Dlg::OnBnClickedButton2)
END_MESSAGE_MAP()


// CVTxRing3Dlg message handlers

BOOL CVTxRing3Dlg::OnInitDialog()
{
	CDialogEx::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		BOOL bNameValid;
		CString strAboutMenu;
		bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX);
		ASSERT(bNameValid);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon

	// TODO: Add extra initialization here

	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CVTxRing3Dlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialogEx::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CVTxRing3Dlg::OnPaint()
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialogEx::OnPaint();
	}
}

// The system calls this function to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CVTxRing3Dlg::OnQueryDragIcon()
{
	return static_cast<HCURSOR>(m_hIcon);
}
DWORD FindProcessId(WCHAR*processname)
{
	HANDLE hProcessSnap;
	PROCESSENTRY32 pe32;
	DWORD result = NULL;

	// Take a snapshot of all processes in the system.
	hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (INVALID_HANDLE_VALUE == hProcessSnap) return(FALSE);

	pe32.dwSize = sizeof(PROCESSENTRY32); // <----- IMPORTANT

										  // Retrieve information about the first process,
										  // and exit if unsuccessful
	if (!Process32First(hProcessSnap, &pe32))
	{
		CloseHandle(hProcessSnap);          // clean the snapshot object
	//	OutputDebugStringA("!!! Failed to gather information on system processes! \n");
		return(NULL);
	}

	do
	{
//		OutputDebugStringA("Checking process\n");
		if (0 == _wcsicmp(processname, pe32.szExeFile))
		{
			result = pe32.th32ProcessID;
			break;
		}
	} while (Process32Next(hProcessSnap, &pe32));

	CloseHandle(hProcessSnap);

	return result;
}
cDrvCtrl drv;
HANDLE g_hEvent;


#define DRV_PATH		"C:\\UsbMon.sys"
#define SERVICE_NAME	"UsbMontest5"
#define DISPLAY_NAME	SERVICE_NAME

 

typedef struct _USER_MOUDATA
{
	UCHAR x;
	UCHAR y;
	UCHAR z;
	UCHAR Click;
	BOOLEAN IsAbsolute;
}USERMOUDATA, *PUSERDATA;
BOOLEAN bStart = TRUE;
//-------------------------------------------------------------------------------------------//
PVOID WINAPI UsbReadThreadStart(PVOID params)
{
	USERMOUDATA* data = (USERMOUDATA*)params;
	while (bStart)
	{
		WaitForSingleObject(g_hEvent, INFINITE);
		if (data->x != 0 || data->y != 0 | data->z != 0 || data->Click != 0)
		{
			CString msg;
			msg.Format(L"x: %x, y: %x z: %x click: %x \r\n", data->x, data->y, data->z, data->Click, data->IsAbsolute);
			OutputDebugString(msg);
		}
	}
	return NULL;
}
//---------------------------------------------------------------------------------------//
void CVTxRing3Dlg::OnBnClickedOk()
{ 
	ULONG64	OutBuffer;
	DWORD	RetBytes;  
	g_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL); // 创建事件
  
	CString err;
  
	//Create Service
	if (!drv.Install(DRV_PATH, SERVICE_NAME, DISPLAY_NAME))
	{
		OutputDebugStringA("Change Page A222\r\n");
		CloseHandle(g_hEvent);
		return;
	} 

	//Start Service
	if (!drv.Start(SERVICE_NAME))
	{
		OutputDebugStringA("Change Page 333Attribute to Writable \r\n");

		drv.Remove(SERVICE_NAME);
		CloseHandle(g_hEvent);
		return;
	}
 
	if (!drv.IoControl("\\\\.\\UsbMon", IOCTL_USB_MAPPING_START, g_hEvent, sizeof(HANDLE), &OutBuffer, sizeof(ULONG64), &RetBytes))
	{
		drv.Stop(SERVICE_NAME);
		drv.Remove(SERVICE_NAME);
		CloseHandle(g_hEvent);
		err.Format(L"Cannot IOCTL device : %x \r\n", GetLastError());
		AfxMessageBox(err);
		return;
	}

	err.Format(L"Out: %I64x \r\n", OutBuffer);
	OutputDebugString(err); 

	if (OutBuffer)
	{
		CreateThread(0, 0, (LPTHREAD_START_ROUTINE)UsbReadThreadStart, (PVOID)OutBuffer, 0, 0);
	}
	OutputDebugStringA("Successfully Hide \r\n"); 
}


void CVTxRing3Dlg::OnBnClickedCancel()
{
	CDialog::OnCancel(); 
	drv.Stop(SERVICE_NAME);
	drv.Remove(SERVICE_NAME);
}


void CVTxRing3Dlg::OnBnClickedButton1()
{
}

void CVTxRing3Dlg::OnBnClickedButton2()
{
	// TODO: Add your control notification handler code here
	drv.Stop(SERVICE_NAME);
	drv.Remove(SERVICE_NAME);
}

```

`UsbMon/VTxRing3/VTxRing3Dlg.h`:

```h

// VTxRing3Dlg.h : header file
//

#pragma once


// CVTxRing3Dlg dialog
class CVTxRing3Dlg : public CDialogEx
{
// Construction
public:
	CVTxRing3Dlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
#ifdef AFX_DESIGN_TIME
	enum { IDD = IDD_VTXRING3_DIALOG };
#endif

	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support


// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	DECLARE_MESSAGE_MAP()
public:
	afx_msg void OnBnClickedOk();
	afx_msg void OnBnClickedCancel();
	afx_msg void OnBnClickedButton1();
	afx_msg void OnBnClickedButton2();
};

```

`UsbMon/VTxRing3/cDrvCtrl.cpp`:

```cpp
/*============================
Drvier Control Class (SCM way)
============================*/
#include "stdafx.h"
#pragma comment(lib,"advapi32.lib")
#include <winioctl.h>
#include "cDrvCtrl.h"
 

#define LOG_LAST_ERROR()	\
	CString err;		\
	err.Format(L"Line: %d Err: %d \r\n", __LINE__, GetLastError());	\
	OutputDebugString(err); \
//--------------------------------------------------------------------------------//
BOOL WINAPI InstallService(
	_In_ LPCSTR ServiceName,
	_In_ LPCSTR DisplayName,
	_In_ LPCSTR szPath) 
{
	SC_HANDLE hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
	if (!hSCManager)
	{
		LOG_LAST_ERROR();
		return FALSE;
	}

	SC_HANDLE hService = CreateServiceA(
		hSCManager, 
		ServiceName, 
		DisplayName, 
		SERVICE_ALL_ACCESS, 
		SERVICE_KERNEL_DRIVER, 
		SERVICE_DEMAND_START, 
		SERVICE_ERROR_NORMAL, 
		szPath, NULL, NULL, NULL, NULL, NULL
	);

	if (!hService) 
	{
		LOG_LAST_ERROR();
		return FALSE;
	}

	CloseServiceHandle(hService);
	CloseServiceHandle(hSCManager);

	return TRUE;
}
//--------------------------------------------------------------------------------//
BOOL WINAPI RemoveService(
	_In_ LPCSTR ServiceName
) 
{	
	SC_HANDLE hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
	
	if (!hSCManager) 
	{
		LOG_LAST_ERROR();
		return FALSE;
	}

	SC_HANDLE hService = OpenServiceA(hSCManager, ServiceName, DELETE);
	if (!hService)
	{
		LOG_LAST_ERROR();
		CloseServiceHandle(hSCManager);
		return FALSE;
	}
	 
	if (!DeleteService(hService))
	{
		LOG_LAST_ERROR();
		CloseServiceHandle(hService);
		CloseServiceHandle(hSCManager);
		return FALSE;
	}

	CloseServiceHandle(hService);
	CloseServiceHandle(hSCManager);
	return TRUE;
}
//--------------------------------------------------------------------------------//
BOOL WINAPI StartDrvService(LPCSTR ServiceName) 
{
	SC_HANDLE hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
	if (!hSCManager) 
	{
		LOG_LAST_ERROR();
		return FALSE;
	}
	SC_HANDLE hService = OpenServiceA(hSCManager, ServiceName, SERVICE_START);
	if (!hService)
	{
		LOG_LAST_ERROR();
		CloseServiceHandle(hSCManager);
	}
	if (!StartService(hService, 0, NULL))
	{
		LOG_LAST_ERROR();
		CloseServiceHandle(hService);
		CloseServiceHandle(hSCManager);
		return FALSE;
	}
	CloseServiceHandle(hService);
	CloseServiceHandle(hSCManager);
	return TRUE;
}
//---------------------------------------------------------------------------------//
BOOL WINAPI StopService(LPCSTR ServiceName) 
{
	CString LogMsg;
	SC_HANDLE hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
	SERVICE_STATUS svcsta = { 0 };
	if (!hSCManager)
	{
		LOG_LAST_ERROR();
		return FALSE;
	}

	SC_HANDLE hService = OpenServiceA(hSCManager, ServiceName, SERVICE_STOP);
	if (!hService)
	{
		LOG_LAST_ERROR();
		CloseServiceHandle(hSCManager);
		return FALSE;
	}
	
	if (!ControlService(hService, SERVICE_CONTROL_STOP, &svcsta))
	{
		LOG_LAST_ERROR();
		LogMsg.Format(L"State: %x", svcsta.dwCurrentState);
		OutputDebugString(LogMsg);
		CloseServiceHandle(hService);
		CloseServiceHandle(hSCManager);
		return FALSE;
	}

	CloseServiceHandle(hService);
	CloseServiceHandle(hSCManager);
	return TRUE;
}
//----------------------------------------------------------------------------------//
BOOL cDrvCtrl::Install(
	_In_ PCHAR pSysPath, 
	_In_ PCHAR pServiceName, 
	_In_ PCHAR pDisplayName)
{
	if (!InstallService(pServiceName, pDisplayName, pSysPath))
	{
		LOG_LAST_ERROR();
		return FALSE;
	}
	return TRUE;
}

//----------------------------------------------------------------------------------//
BOOL cDrvCtrl::Start(
	_In_ PCHAR pServiceName)
{
	if (!StartDrvService(pServiceName))
	{
		LOG_LAST_ERROR();
		return FALSE;
	}
	return TRUE;
}

//----------------------------------------------------------------------------------//
BOOL cDrvCtrl::Stop(
	_In_ PCHAR pServiceName)
{
	if (!StopService(pServiceName))
	{
		LOG_LAST_ERROR();
		return FALSE;
	}
	return TRUE;
}

//----------------------------------------------------------------------------------//
BOOL cDrvCtrl::Remove(
	_In_ PCHAR pServiceName)
{
	if (!RemoveService(pServiceName))
	{
		LOG_LAST_ERROR();
		return FALSE;
	}
	return TRUE;
} 

//----------------------------------------------------------------------------------//
BOOL cDrvCtrl::IoControl(PCHAR SymbolicNames, DWORD dwIoCode, PVOID InBuff, DWORD InBuffLen, PVOID OutBuff, DWORD OutBuffLen, DWORD *RealRetBytes)
{
	DWORD dw;
	BOOL   b;
	HANDLE hDriver = CreateFileA(SymbolicNames, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
	if(!hDriver)
	{
		CString str;
		str.Format(L"cannot create file(Io: %x , err:%x ) \r\n", dwIoCode, GetLastError());
		OutputDebugString(str); 
		return FALSE;
	}

	b = DeviceIoControl(hDriver, dwIoCode, InBuff, InBuffLen, OutBuff, OutBuffLen, &dw, NULL);
	
	if (!b)
	{
		CString str;
		str.Format(L"cannot DeviceIoControl file(Io: %x , err:%x) \r\n", dwIoCode, GetLastError());
		OutputDebugString(str);
	}
	
	if (RealRetBytes)
		*RealRetBytes = dw;

	CloseHandle(hDriver);
	return b;
}

DWORD cDrvCtrl::CTL_CODE_GEN(DWORD lngFunction)
{
	return (FILE_DEVICE_UNKNOWN * 65536) | (FILE_ANY_ACCESS * 16384) | (lngFunction * 4) | METHOD_BUFFERED;
}
```

`UsbMon/VTxRing3/cDrvCtrl.h`:

```h
#include "Windows.h"
#include <winsvc.h>
class cDrvCtrl
{
public:
	cDrvCtrl()
	{
		m_pSysPath = NULL;
		m_pServiceName = NULL;
		m_pDisplayName = NULL;
		m_hSCManager = NULL;
		m_hService = NULL;
		m_hDriver = INVALID_HANDLE_VALUE;
	}
	~cDrvCtrl()
	{
		CloseServiceHandle(m_hService);
		CloseServiceHandle(m_hSCManager);
		CloseHandle(m_hDriver);
	}
public:
	DWORD m_dwLastError;
	PCHAR m_pSysPath;
	PWCHAR m_pServiceName;
	PCHAR m_pDisplayName;
	HANDLE m_hDriver;
	SC_HANDLE m_hSCManager;
	SC_HANDLE m_hService;
public:
	BOOL Install(PCHAR pSysPath, PCHAR pServiceName, PCHAR pDisplayName);
	BOOL Start(PCHAR pSysPath);
	BOOL Stop(PCHAR pSysPath);
	BOOL Remove(PCHAR pSysPath);
	BOOL IoControl(PCHAR SymbolicName, DWORD dwIoCode, PVOID InBuff, DWORD InBuffLen, PVOID OutBuff, DWORD OutBuffLen, DWORD *RealRetBytes);
private:
	DWORD CTL_CODE_GEN(DWORD lngFunction);
protected:
	//null
};
```

`UsbMon/VTxRing3/res/VTxRing3.rc2`:

```rc2
//
// VTxRing3.RC2 - resources Microsoft Visual C++ does not edit directly
//

#ifdef APSTUDIO_INVOKED
#error this file is not editable by Microsoft Visual C++
#endif //APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
// Add manually edited resources here...

/////////////////////////////////////////////////////////////////////////////

```

`UsbMon/VTxRing3/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by VTxRing3.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_VTXRING3_DIALOG             102
#define IDR_MAINFRAME                   128
#define IDC_BUTTON1                     1000
#define IDC_BUTTON2                     1001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        130
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`UsbMon/VTxRing3/stdafx.cpp`:

```cpp

// stdafx.cpp : source file that includes just the standard includes
// VTxRing3.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"



```

`UsbMon/VTxRing3/stdafx.h`:

```h

// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently,
// but are changed infrequently

#pragma once

#ifndef VC_EXTRALEAN
#define VC_EXTRALEAN            // Exclude rarely-used stuff from Windows headers
#endif

#include "targetver.h"

#define _ATL_CSTRING_EXPLICIT_CONSTRUCTORS      // some CString constructors will be explicit

// turns off MFC's hiding of some common and often safely ignored warning messages
#define _AFX_ALL_WARNINGS

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions


#include <afxdisp.h>        // MFC Automation classes



#ifndef _AFX_NO_OLE_SUPPORT
#include <afxdtctl.h>           // MFC support for Internet Explorer 4 Common Controls
#endif
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>             // MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <afxcontrolbars.h>     // MFC support for ribbons and control bars









#ifdef _UNICODE
#if defined _M_IX86
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='x86' publicKeyToken='6595b64144ccf1df' language='*'\"")
#elif defined _M_X64
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='amd64' publicKeyToken='6595b64144ccf1df' language='*'\"")
#else
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
#endif
#endif



```

`UsbMon/VTxRing3/targetver.h`:

```h
#pragma once

// Including SDKDDKVer.h defines the highest available Windows platform.

// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.

#include <SDKDDKVer.h>

```

`UsbMon/x64/Debug/UsbMon.inf`:

```inf
;
; StackTrace.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=StackTrace.cat
DriverVer=09/26/2019,0.36.53.522
 

[DestinationDirs]
DefaultDestDir = 12


[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]


[Manufacturer]
%ManufacturerName%=Standard,NTamd64

[Standard.NTamd64]


[Strings]
ManufacturerName="StackTrace"
ClassName=""
DiskName="StackTrace Source Disk"

```

`UsbMon/x64/Debug/UsbMon/UsbMon.inf`:

```inf
;
; StackTrace.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=StackTrace.cat
DriverVer=09/26/2019,0.36.53.522
 

[DestinationDirs]
DefaultDestDir = 12


[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]


[Manufacturer]
%ManufacturerName%=Standard,NTamd64

[Standard.NTamd64]


[Strings]
ManufacturerName="StackTrace"
ClassName=""
DiskName="StackTrace Source Disk"

```