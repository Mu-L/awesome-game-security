Project Path: arc_brew02_BudgetEPT_mnk65g3p

Source Tree:

```txt
arc_brew02_BudgetEPT_mnk65g3p
├── BudgetEPT.sln
├── BudgetEPT.vcxproj
├── BudgetEPT.vcxproj.filters
├── Files
│   ├── BudgetEPT.cpp
│   ├── BudgetEPT.h
│   ├── BudgetEPTASM.asm
│   ├── CIA32.h
│   ├── CTypes.h
│   ├── Handlers.h
│   ├── HandlersASM.asm
│   ├── Memory.cpp
│   ├── Memory.h
│   ├── x64.h
│   └── x64ASM.asm
└── README.md

```

`BudgetEPT.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.10.35122.118
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BudgetEPT", "BudgetEPT.vcxproj", "{9E487B0A-3002-4F30-A042-E185D0EE0777}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{9E487B0A-3002-4F30-A042-E185D0EE0777}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{9E487B0A-3002-4F30-A042-E185D0EE0777}.Debug|ARM64.Build.0 = Debug|ARM64
		{9E487B0A-3002-4F30-A042-E185D0EE0777}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{9E487B0A-3002-4F30-A042-E185D0EE0777}.Debug|x64.ActiveCfg = Debug|x64
		{9E487B0A-3002-4F30-A042-E185D0EE0777}.Debug|x64.Build.0 = Debug|x64
		{9E487B0A-3002-4F30-A042-E185D0EE0777}.Debug|x64.Deploy.0 = Debug|x64
		{9E487B0A-3002-4F30-A042-E185D0EE0777}.Release|ARM64.ActiveCfg = Release|ARM64
		{9E487B0A-3002-4F30-A042-E185D0EE0777}.Release|ARM64.Build.0 = Release|ARM64
		{9E487B0A-3002-4F30-A042-E185D0EE0777}.Release|ARM64.Deploy.0 = Release|ARM64
		{9E487B0A-3002-4F30-A042-E185D0EE0777}.Release|x64.ActiveCfg = Release|x64
		{9E487B0A-3002-4F30-A042-E185D0EE0777}.Release|x64.Build.0 = Release|x64
		{9E487B0A-3002-4F30-A042-E185D0EE0777}.Release|x64.Deploy.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {505853CB-AC00-4B5D-B481-AB62F9234CAD}
	EndGlobalSection
EndGlobal

```

`BudgetEPT.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{9E487B0A-3002-4F30-A042-E185D0EE0777}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">x64</Platform>
    <RootNamespace>BudgetEPT</RootNamespace>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings" />
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <SDLCheck>false</SDLCheck>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <SDLCheck>false</SDLCheck>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Files\BudgetEPT.cpp" />
    <ClCompile Include="Files\Memory.cpp" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="Files\BudgetEPTASM.asm">
      <FileType>Document</FileType>
    </MASM>
    <MASM Include="Files\HandlersASM.asm">
      <FileType>Document</FileType>
    </MASM>
    <MASM Include="Files\x64ASM.asm">
      <FileType>Document</FileType>
    </MASM>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Files\BudgetEPT.h" />
    <ClInclude Include="Files\CIA32.h" />
    <ClInclude Include="Files\CTypes.h" />
    <ClInclude Include="Files\Handlers.h" />
    <ClInclude Include="Files\Memory.h" />
    <ClInclude Include="Files\x64.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets" />
</Project>
```

`BudgetEPT.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Files\BudgetEPT.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Files\Memory.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Files\BudgetEPT.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Files\Handlers.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Files\Memory.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Files\x64.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Files\CIA32.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Files\CTypes.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="Files\BudgetEPTASM.asm">
      <Filter>Source Files</Filter>
    </MASM>
    <MASM Include="Files\HandlersASM.asm">
      <Filter>Source Files</Filter>
    </MASM>
    <MASM Include="Files\x64ASM.asm">
      <Filter>Source Files</Filter>
    </MASM>
  </ItemGroup>
</Project>
```

`Files/BudgetEPT.cpp`:

```cpp
#include <ntddk.h>
#include <intrin.h>

#include "CIA32.h"

#include "BudgetEPT.h"
#include "Handlers.h"
#include "Memory.h"
#include "x64.h"

/*
	Checks if SMEP and SMAP are supported.

	@return True if SMAP and SMEP are supported, false otherwise
*/
bool SupportsSMEPSMAP()
{
	CPUID cpuid{ 0 };
	__cpuid(cpuid.all, 7);

	if (!cpuid.EAX07hECX0h.EBX.smep)
	{
		DbgPrint("SMEP is not supported on this processor!\n");
	}

	if (!cpuid.EAX07hECX0h.EBX.smap)
	{
		DbgPrint("SMAP is not supported on this processor!\n");
		return false;
	}

	return true;
}

/*
	Updates the supervisor privileges by toggling bits in the CR4 and RFLAG registers.
*/
void UpdateSupervisorPrivileges()
{
	static bool smepRemoved = false;
	static bool smapSet = false;
	static bool acCleared = false;
	static bool ntCleared = false;

	CR4 cr4{ __readcr4() };
	if (cr4.smep)
	{
		smepRemoved = true;
		cr4.smep = 0;
	}
	else if (smepRemoved)
	{
		smepRemoved = false;
		cr4.smep = 1;
	}

	if (!cr4.smap)
	{
		smapSet = true;
		cr4.smap = 1;
	}
	else if (smapSet)
	{
		smapSet = false;
		cr4.smap = 1;
	}

	RFlags rflags{ __readeflags() };
	if (rflags.ac)
	{
		acCleared = true;
		rflags.ac = 0;
	}
	else if (acCleared)
	{
		acCleared = false;
		rflags.ac = 1;
	}

	if (rflags.nt)
	{
		ntCleared = true;
		rflags.nt = 0;
	}
	else if (ntCleared)
	{
		ntCleared = false;
		rflags.nt;
	}

	__writecr4(cr4.all);
	WriteRFlags(rflags);
}

/*
	Creates a GDT copy with a new privilege level entry.

	@param gdtr - The original GDTR as input, new GDTR as output
	@param cs - The output CS value
	@param ss - The output SS value
	@param tr - The output TR value
	@param pl - The privilege value for the GDT entry

	@return The new GDT's virtual address
*/
void* CreateGDT(GDTR* gdtr, SegmentSelector* cs, SegmentSelector* ss, SegmentSelector* tr, uint64 pl)
{
	ReadGDTR(gdtr);
	OldGDTR = *gdtr;

	if (!gdtr->base)
	{
		DbgPrint("Failed to find GDT base\n");
		return nullptr;
	}

	SegmentDescriptor32* gdt = reinterpret_cast<SegmentDescriptor32*>
		(AllocateContiguousMemory(PAGE_SIZE, PAGE_READWRITE));

	if (!gdt)
	{
		DbgPrint("Failed to allocate new GDT\n");
		return nullptr;
	}

	memcpy(gdt, reinterpret_cast<void*>(gdtr->base), static_cast<size_t>(gdtr->limit) + 1);

	constexpr uint16 newEntriesSize = (sizeof(SegmentDescriptor32) * 2 + sizeof(SegmentDescriptor64));

	if ((gdtr->limit + newEntriesSize) > MAX_GDT_LIMIT)
		gdtr->limit = MAX_GDT_LIMIT;
	else
		gdtr->limit += newEntriesSize;

	uint64 idx = (static_cast<uint64>(gdtr->limit) + 1) / sizeof(SegmentDescriptor32);

	*cs = OldCS = ReadCS();
	SegmentDescriptor32* csEntry = &gdt[--idx];
	if (csEntry->all)
	{
		/*
			I'm too lazy, but the fix is simple:
			Just search the whole GDT for empty entries.
		*/
		FreeContiguousMemory(gdt);
		DbgPrint("CS entry is already initialized\n");
		return nullptr;
	}

	*csEntry = gdt[cs->index];

	csEntry->type = CODE_DATA_TYPE_EXECUTE_CONFORMING_READ; /* The conforming flag may be unnecessary */
	csEntry->dpl = pl;
	cs->index = idx;
	cs->rpl = pl;

	*ss = OldSS = ReadSS();
	SegmentDescriptor32* ssEntry = &gdt[--idx];
	if (ssEntry->all)
	{
		FreeContiguousMemory(gdt);
		DbgPrint("SS entry is already initialized\n");
		return nullptr;
	}

	*ssEntry = gdt[ss->index];

	ssEntry->type = CODE_DATA_TYPE_WRITE;
	ssEntry->dpl = pl;
	ss->index = idx;
	ss->rpl = pl;

	*tr = OldTR = ReadTR();
	idx -= 2;
	SegmentDescriptor64* trEntry = reinterpret_cast<SegmentDescriptor64*>(&gdt[idx]);
	if (trEntry->all[0] || trEntry->all[1])
	{
		FreeContiguousMemory(gdt);
		DbgPrint("TR entry is already initialized\n");
		return nullptr;
	}

	*trEntry = *reinterpret_cast<SegmentDescriptor64*>(&gdt[tr->index]);

	trEntry->desc.type = SYSTEM_TYPE_NOT_BUSY;
	trEntry->desc.dpl = pl;
	tr->index = idx;
	tr->rpl = pl;

	gdtr->base = reinterpret_cast<uint64>(gdt);

	return gdt;
}

/*
	Creates an IDT copy with certain modified interrupt handlers.

	@param idtr - The original IDTR as input, new IDTR as output

	@return The new IDT's virtual address
*/
void* CreateIDT(IDTR* idtr)
{
	__sidt(idtr);

	if (!idtr->base)
	{
		DbgPrint("Failed to find IDT base\n");
		return nullptr;
	}

	IDTEntry* idt = reinterpret_cast<IDTEntry*>(
		AllocateContiguousMemory(PAGE_SIZE, PAGE_READWRITE));
	
	if (!idt)
	{
		DbgPrint("Failed to allocate new IDT\n");
		return nullptr;
	}

	memcpy(idt, reinterpret_cast<void*>(idtr->base), static_cast<size_t>(idtr->limit) + 1);

	idt[INTERRUPT_VECTOR_DB].baseLow = (reinterpret_cast<uint64>(DBHandler) & MAXUINT16);
	idt[INTERRUPT_VECTOR_DB].baseMiddle = ((reinterpret_cast<uint64>(DBHandler) >> 16) & MAXUINT16);
	idt[INTERRUPT_VECTOR_DB].baseHigh = ((reinterpret_cast<uint64>(DBHandler) >> 32) & MAXUINT32);

	idt[INTERRUPT_VECTOR_GP].baseLow = (reinterpret_cast<uint64>(GPHandler) & MAXUINT16);
	idt[INTERRUPT_VECTOR_GP].baseMiddle = ((reinterpret_cast<uint64>(GPHandler) >> 16) & MAXUINT16);
	idt[INTERRUPT_VECTOR_GP].baseHigh = ((reinterpret_cast<uint64>(GPHandler) >> 32) & MAXUINT32);

	idt[INTERRUPT_VECTOR_PF].baseLow = (reinterpret_cast<uint64>(PFHandler) & MAXUINT16);
	idt[INTERRUPT_VECTOR_PF].baseMiddle = ((reinterpret_cast<uint64>(PFHandler) >> 16) & MAXUINT16);
	idt[INTERRUPT_VECTOR_PF].baseHigh = ((reinterpret_cast<uint64>(PFHandler) >> 32) & MAXUINT32);

	idtr->base = reinterpret_cast<uint64>(idt);

	return idt;
}

/*
	Runs a budget EPT test with a CR3 value, shellcode address, and privilege level.

	@param cr3 - The CR3 value to use for the budget EPT test.
	@param shellAddress - The shellcode address to execute.
	@param pl - The privilege value for the GDT entry

	@return The result of running the budget EPT test
*/
uint64 RunBudgetEPTTest(CR3* cr3, void* shellAddress, uint64 pl)
{
	CR3 oldCR3{ __readcr3() };

	SegmentSelector cs{ 0 };
	SegmentSelector ss{ 0 };
	SegmentSelector tr{ 0 };

	GDTR gdtr{ 0 };
	void* gdt = CreateGDT(&gdtr, &cs, &ss, &tr, pl);
	if (!gdt)
	{
		DbgPrint("Failed to create GDT\n");
		return 0;
	}

	IDTR oldIDTR{ 0 };
	__sidt(&oldIDTR);

	IDTR idtr{ 0 };
	void* idt = CreateIDT(&idtr);
	if (!idt)
	{
		FreeContiguousMemory(gdt);
		DbgPrint("Failed to create IDT\n");
		return 0;
	}

	_disable();

	__writecr3(cr3->all);

	FlushCaches(shellAddress);
	UpdateSupervisorPrivileges();
	WriteGDTR(&gdtr);

	__lidt(&idtr);

	uint64 result = BudgetEPTTest(cs, ss, tr, shellAddress);

	__lidt(&oldIDTR);

	UpdateSupervisorPrivileges();

	__writecr3(oldCR3.all);
	FlushCaches(shellAddress);

	_enable();

	FreeContiguousMemory(idt);
	FreeContiguousMemory(gdt);

	return result;
}

extern "C" PTE* ptEntry = nullptr;
extern "C" uint64 originalPFN = 0;
extern "C" uint64 hookPFN = 0;

/*
	The main code of the program.

	@param context - The starting context

	@return An NTSTATUS value
*/
NTSTATUS Startup(void* context)
{
	UNREFERENCED_PARAMETER(context);

	if (!SupportsSMEPSMAP())
	{
		DbgPrint("Unsupported processor features, unable to continue\n");
		return PsTerminateSystemThread(STATUS_UNSUCCESSFUL);
	}

	DbgPrint("All processor features supported\n");

	uint64 flags = (TABLE_FLAG_READ | TABLE_FLAG_WRITE | TABLE_FLAG_USERMODE);

	/*
		Put this into a separate function probably
		Maybe just call PFNToVirt on each entry within
		the pml4 (and the pml4 itself) and free the memory,
		allowing for recursion perhaps?
	*/
	PML4E* pml4 = reinterpret_cast<PML4E*>(
		NewTableEntry(nullptr, nullptr, flags));

	if (!pml4)
	{
		DbgPrint("Failed to allocate new PML4\n");
		return PsTerminateSystemThread(STATUS_UNSUCCESSFUL);
	}

	DbgPrint("New PML4: 0x%p\n", pml4);

	CR3 oldCR3{ __readcr3() };
	CR3 cr3{ oldCR3 };

	cr3.pfn = VirtToPFN(pml4);

	void* oldPML4 = PFNToVirt(oldCR3.pfn);
	if (!oldPML4)
	{
		FreeContiguousMemory(pml4);
		DbgPrint("Failed to get PML4\n");
		return PsTerminateSystemThread(STATUS_UNSUCCESSFUL);
	}

	DbgPrint("Old PML4: 0x%p\n", oldPML4);
	memcpy(pml4, oldPML4, PAGE_SIZE);

	VAddress virt{ 0 };

	int idx = 0;

	PDPTE* pdpt = reinterpret_cast<PDPTE*>(
		NewTableEntry(pml4, &idx, flags));

	if (!pdpt)
	{
		FreeContiguousMemory(pml4);
		DbgPrint("Failed to allocate new PDPT\n");
		return PsTerminateSystemThread(STATUS_UNSUCCESSFUL);
	}

	/*
		Make it canonical
	*/
	virt.pml4 = idx;
	if (virt.pml4 & BIT_FLAG(8))
	{
		virt.reserved = MAXUINT16;
	}

	PDE* pd = reinterpret_cast<PDE*>(
		NewTableEntry(pdpt, &idx, flags));

	if (!pd)
	{
		FreeContiguousMemory(pdpt);
		FreeContiguousMemory(pml4);
		DbgPrint("Failed to allocate new PD\n");
		return PsTerminateSystemThread(STATUS_UNSUCCESSFUL);
	}

	virt.pdpt = idx;

	PTE* pt = reinterpret_cast<PTE*>(
		NewTableEntry(pd, &idx, flags));

	if (!pt)
	{
		FreeContiguousMemory(pd);
		FreeContiguousMemory(pdpt);
		FreeContiguousMemory(pml4);
		DbgPrint("Failed to allocate new PT\n");
		return PsTerminateSystemThread(STATUS_UNSUCCESSFUL);
	}

	virt.pd = idx;

	void* hookedEntry = NewTableEntry(pt, &idx, flags);
	if (!hookedEntry)
	{
		FreeContiguousMemory(pt);
		FreeContiguousMemory(pd);
		FreeContiguousMemory(pdpt);
		FreeContiguousMemory(pml4);
		DbgPrint("Failed to allocate hook entry\n");
		return PsTerminateSystemThread(STATUS_UNSUCCESSFUL);
	}

	virt.pt = idx;

	ptEntry = &pt[idx];
	hookPFN = VirtToPFN(hookedEntry);

	void* originalEntry = AllocateContiguousMemory(PAGE_SIZE, PAGE_READWRITE);
	if (!originalEntry)
	{
		FreeContiguousMemory(hookedEntry);
		FreeContiguousMemory(pt);
		FreeContiguousMemory(pd);
		FreeContiguousMemory(pdpt);
		FreeContiguousMemory(pml4);
		DbgPrint("Failed to allocate original entry\n");
		return PsTerminateSystemThread(STATUS_UNSUCCESSFUL);
	}

	originalPFN = VirtToPFN(originalEntry);

	/*
		mov eax, 0xdeadbeef
		mov rcx, cr3							; #GP only on test 2
		mov ecx, dword ptr [rip - 13]			; #PF on both tests
		cmp ecx, 0xcafefeed
		jz ExitShellcode
		xor rax, rax
	ExitShellcode:
		ret
	*/
	uint8 hookedShellcode[] =
	{
		0xB8, 0xEF, 0xBE, 0xAD, 0xDE, 
		0x0F, 0x20, 0xD9, 
		0x8B, 0x0D, 0xF3, 0xFF, 0xFF, 0xFF, 
		0x81, 0xF9, 0xED, 0xFE, 0xFE, 0xCA, 
		0x74, 0x03, 
		0x48, 0x31, 0xC0, 
		0xC3
	};

	/*
		mov eax, 0xcafefeed
		mov rcx, cr3
		mov ecx, dword ptr [rip - 13]
		cmp ecx, 0xcafefeed
		jz ExitShellcode
		xor rax, rax
	ExitShellcode:
		ret
	*/
	uint8 originalShellcode[] =
	{
		0xB8, 0xED, 0xFE, 0xFE, 0xCA,
		0x0F, 0x20, 0xD9,
		0x8B, 0x0D, 0xF3, 0xFF, 0xFF, 0xFF,
		0x81, 0xF9, 0xED, 0xFE, 0xFE, 0xCA,
		0x74, 0x03,
		0x48, 0x31, 0xC0,
		0xC3
	};

	memcpy(hookedEntry, hookedShellcode, sizeof(hookedShellcode));
	memcpy(originalEntry, originalShellcode, sizeof(originalShellcode));

	uint64 result = RunBudgetEPTTest(&cr3, reinterpret_cast<void*>(virt.all), 0);
	if (!result)
		DbgPrint("Budget EPT Test 2 Failed\n");
	else
		DbgPrint("Budget EPT Test 2 Passed: 0x%llx\n", result);

	result = RunBudgetEPTTest(&cr3, reinterpret_cast<void*>(virt.all), 1);
	if(!result)
		DbgPrint("Budget EPT Test 2 Failed\n");
	else
		DbgPrint("Budget EPT Test 2 Passed: 0x%llx\n", result);
		
	
	FreeContiguousMemory(originalEntry);
	FreeContiguousMemory(hookedEntry);
	FreeContiguousMemory(pt);
	FreeContiguousMemory(pd);
	FreeContiguousMemory(pdpt);
	FreeContiguousMemory(pml4);

	return PsTerminateSystemThread(STATUS_SUCCESS);
}

/*
	The initial entry point.

	@param DriverObject - The driver object
	@param RegistryPath - The registry path

	@return An NTSTATUS value
*/
NTSTATUS DriverEntry(DRIVER_OBJECT* DriverObject, UNICODE_STRING* RegistryPath)
{
	UNREFERENCED_PARAMETER(DriverObject);
	UNREFERENCED_PARAMETER(RegistryPath);

	OBJECT_ATTRIBUTES obj{ 0 };
	InitializeObjectAttributes(&obj, nullptr, OBJ_KERNEL_HANDLE, nullptr, nullptr);

	HANDLE threadHandle = nullptr;
	if (!NT_SUCCESS(PsCreateSystemThread(&threadHandle, GENERIC_ALL, &obj,
		nullptr, nullptr, reinterpret_cast<PKSTART_ROUTINE>(Startup), nullptr)))
	{
		DbgPrint("Failed to create system thread\n");
		return STATUS_UNSUCCESSFUL;
	}

	if (threadHandle)
		ZwClose(threadHandle);

	return STATUS_SUCCESS;
}
```

`Files/BudgetEPT.h`:

```h
#pragma once
#include "CIA32.h"

/*
	Executes a budget EPT test with specified cs, ss, tr, and rip values.

	@param cs - The CS value to use for the budget EPT test.
	@param ss - The SS value to use for the budget EPT test.
	@param tr - The TR value to use for the budget EPT test.
	@param rip - The rip value to execute for the budget EPT test.

	@return The result of running the budget EPT test
*/
extern "C" uint64 BudgetEPTTest(SegmentSelector cs, SegmentSelector ss, SegmentSelector tr, void* rip);
```

`Files/BudgetEPTASM.asm`:

```asm
.code 

	BudgetEPTTest proc

		xor rax, rax
		mov ax, r8w
		ltr ax

		movzx rdx, dx
		push rdx

		lea rax, [rsp + 8]
		push rax

		pushfq

		btr qword ptr [rsp], 18

		movzx rcx, cx
		push rcx

		push r9
		iretq

	BudgetEPTTest endp

end
```

`Files/CIA32.h`:

```h
#pragma once
#include <xmmintrin.h>

#include "CTypes.h"

#define BIT_FLAG(index) (1llu << index)

#define PAGE_SIZE 0x1000
#define PAGE_MASK (~(PAGE_SIZE - 1))
// #define PAGE_ALIGN(address) (void*)((uint64)address & PAGE_MASK)
#define PAGE_ROUND(address) (void*)((uint64)(PAGE_ALIGN((uint64)address - 1)) + PAGE_SIZE)

#if defined(_MSC_EXTENSIONS)
#pragma warning(push)
#pragma warning(disable: 4201)
#endif

/*
	General Purpose Registers
*/

union RFlags
{
	uint64 all;

	struct
	{
		uint64 cf : 1;
		uint64 reserved1 : 1; /* Always 1 */
		uint64 pf : 1;
		uint64 reserved2 : 1; /* Always 0 */
		uint64 af : 1;
		uint64 reserved3 : 1; /* Always 0 */
		uint64 zf : 1;
		uint64 sf : 1;
		uint64 tf : 1;
		uint64 intf : 1;
		uint64 df : 1;
		uint64 of : 1;
		uint64 iopl : 2;
		uint64 nt : 1;
		uint64 reserved4 : 1; /* Always 0 */
		uint64 rf : 1;
		uint64 vm : 1;
		uint64 ac : 1;
		uint64 vif : 1;
		uint64 vip : 1;
		uint64 id : 1;
		uint64 reserved5 : 42; /* Always 0 */
	};
};

/*
	Interrupts
*/

#define IDT_TYPE_INTERRUPT_GATE 0xE

#define INTERRUPT_VECTOR_DE 0
#define INTERRUPT_VECTOR_DB 1
#define INTERRUPT_VECTOR_GP 13
#define INTERRUPT_VECTOR_PF 14

#include <pshpack1.h>
struct IDTR
{
	uint16 limit;
	uint64 base;
};
#include <poppack.h>

union IDTEntry
{
	uint32 all[4];

	struct
	{
		uint16 baseLow;
		uint16 segmentSelector;
		uint8 ist : 3;
		uint8 reserved1 : 5;
		uint8 type : 4;
		uint8 reserved2 : 1;
		uint8 dpl : 2;
		uint8 p : 1;
		uint16 baseMiddle;
		uint32 baseHigh;
		uint32 reserved3;
	};
};

struct InterruptFrame
{
	uint64 rip;
	uint64 cs;
	uint64 rflags;
	uint64 rsp;
	uint64 ss;
};

struct InterruptFrameErrorCode
{
	uint64 errorCode;
	InterruptFrame frame;
};

/*
	Segmentation
*/

#define CODE_DATA_TYPE_WRITE BIT_FLAG(1)

#define CODE_DATA_TYPE_READ BIT_FLAG(1)
#define CODE_DATA_TYPE_CONFORMING BIT_FLAG(2)
#define CODE_DATA_TYPE_EXECUTE BIT_FLAG(3)
#define CODE_DATA_TYPE_EXECUTE_CONFORMING_READ (CODE_DATA_TYPE_EXECUTE | CODE_DATA_TYPE_CONFORMING | CODE_DATA_TYPE_READ)

#define SYSTEM_TYPE_NOT_BUSY (BIT_FLAG(3) | BIT_FLAG(0))

#define MAX_GDT_SIZE 8196
#define MAX_GDT_LIMIT (MAX_GDT_SIZE - 1)

typedef IDTR GDTR;

union SegmentSelector
{
	uint16 all;
	struct
	{
		uint16 rpl : 2;					// Requested Privilege Level
		uint16 ti : 1;					// Table Indicator
		uint16 index: 13;
	};
};

union SegmentDescriptor32
{
	uint64 all;
	struct
	{
		uint64 segmentLimitLow : 16;
		uint64 baseLow : 16;
		uint64 baseMid : 8;
		uint64 type : 4;
		uint64 descriptorType : 1;
		uint64 dpl : 2;					// Descriptor Privilege Level
		uint64 p : 1;					// Present
		uint64 segmentLimitHigh : 4;
		uint64 system : 1;
		uint64 longMode : 1;
		uint64 defaultBig : 1;
		uint64 granularity : 1;
		uint64 baseHigh : 8;
	};
};

union SegmentDescriptor64
{
	uint64 all[2];
	struct
	{
		SegmentDescriptor32 desc;
		uint32 baseUpper;
		uint32 setZero;
	};
};

/*
	Debug Registers
*/

typedef uint64 DR0;
typedef uint64 DR1;
typedef uint64 DR2;
typedef uint64 DR3;

union DR7
{
	uint64 all;

	struct
	{
		uint64 l0 : 1;
		uint64 g0 : 1;
		uint64 l1 : 1;
		uint64 g1 : 1;
		uint64 l2 : 1;
		uint64 g2 : 1;
		uint64 l3 : 1;
		uint64 g3 : 1;
		uint64 le : 1;
		uint64 ge : 1;
		uint64 set_10_1 : 1;
		uint64 rtm : 1;
		uint64 set_12_0 : 1;
		uint64 gd : 1;
		uint64 set_14_15_0 : 2;
		uint64 rw0 : 2;
		uint64 len0 : 2;
		uint64 rw1 : 2;
		uint64 len1 : 2;
		uint64 rw2 : 2;
		uint64 len2 : 2;
		uint64 rw3 : 2;
		uint64 len3 : 2;

	};
};

/*
	Control Registers
*/

union CR0
{
	uint64 all;

	struct
	{
		uint64 pe : 1;			// [0] Protected mode enabled
		uint64 mp : 1;			// [1] Monitor co-processor
		uint64 em : 1;			// [2] Emulation
		uint64 ts : 1;			// [3] Task switched
		uint64 et : 1;			// [4] Extension type
		uint64 ne : 1;			// [5] Numeric error
		uint64 reserved_1 : 10;	// [6:15]
		uint64 wp : 1;			// [16] Write protect
		uint64 reserved_2 : 1;		// [17]
		uint64 am : 1;			// [18] Alignment mask
		uint64 reserved_3 : 10;	// [19:28]
		uint64 nw : 1;			// [29] Not write-through
		uint64 cd : 1;			// [30] Cache disable
		uint64 pg : 1;			// [31] Paging
		uint64 reserved_4 : 32;	// [32:63]
	};
};

union CR3
{
	uint64 all;

	struct
	{
		uint64 ignored1 : 3;		// [0:2]
		uint64 pwt : 1;			// [3] Page-level write-through
		uint64 pcd : 1;			// [4] Page-level cache disable
		uint64 ignored2 : 7;		// [5:11]
		uint64 pfn : 36;			// [12:47] Page frame number
		uint64 reserved_1 : 16;	// [48:63]
	} pcide0;

	struct
	{
		uint64 pcid : 12; 			// [0:11] Process context identifier
		uint64 pfn : 36;			// [12:47] Page frame number
		uint64 reserved_1 : 16;	// [48:63]
	} pcide1;

	struct
	{
		uint64 varied : 12;
		uint64 pfn : 36;
		uint64 reserved : 16;
	};
};

union CR4
{
	uint64 all;
	struct
	{
		uint64 vme : 1;
		uint64 pvi : 1;
		uint64 tsd : 1;
		uint64 de : 1;
		uint64 pse : 1;
		uint64 pae : 1;
		uint64 mce : 1;
		uint64 pge : 1;
		uint64 pce : 1;
		uint64 osfxsr : 1;
		uint64 osxmmexcpt : 1;
		uint64 umip : 1;
		uint64 la57 : 1;
		uint64 vmxe : 1;
		uint64 smxe : 1;
		uint64 reserved1 : 1;
		uint64 fsgsbase : 1;
		uint64 pcide : 1;
		uint64 osxsave : 1;
		uint64 kl : 1;
		uint64 smep : 1;
		uint64 smap : 1;
		uint64 pke : 1;
		uint64 cet : 1;
		uint64 pks : 1;
		uint64 reserved2 : 39;
	};
};

/*
	Page Tables
*/

#define TABLE_FLAG_READ		BIT_FLAG(0)
#define TABLE_FLAG_WRITE	BIT_FLAG(1)
#define TABLE_FLAG_USERMODE BIT_FLAG(2)
#define TABLE_FLAG_NX		BIT_FLAG(63)

#define TABLE_LEVEL_PML4 4
#define TABLE_LEVEL_PDPT 3
#define TABLE_LEVEL_PD 2
#define TABLE_LEVEL_PT 1

union PML4E
{
	uint64 all;

	struct
	{
		uint64 p : 1;				// [0] Present
		uint64 rw : 1;			// [1] Read/Write; if 0, writes may not be allowed
		uint64 us : 1;			// [2] User/Supervisor; if 0, user-mode accesses are not allowed
		uint64 pwt : 1;			// [3] Page-level write-through
		uint64 pcd : 1;			// [4] Page-level cache disable
		uint64 a : 1;				// [5] Accessed
		uint64 ignored_1 : 1;		// [6]
		uint64 ps : 1;			// [7] Page size (must be zero)
		uint64 ignored_2 : 4;		// [8:11]
		uint64 pfn : 36;			// [12:47] Page frame number
		uint64 reserved_1 : 4;		// [48:51]
		uint64 ignored_3 : 11;		// [52:62]
		uint64 xd : 1;			// [63] Execute disable
	};
};

union PDPTE
{
	uint64 all;

	struct
	{
		uint64 p : 1;				// [0] Present
		uint64 rw : 1;			// [1] Read/Write; if 0, writes may not be allowed
		uint64 us : 1;			// [2] User/Supervisor; if 0, user-mode accesses are not allowed
		uint64 pwt : 1;			// [3] Page-level write-through
		uint64 pcd : 1;			// [4] Page-level cache disable
		uint64 a : 1;				// [5] Accessed
		uint64 d : 1;				// [6] Dirty
		uint64 ps : 1;				// [7] Page size
		uint64 g : 1;				// [8] Global
		uint64 ignored_1 : 3;		// [9:11]
		uint64 pat : 1;			// [12] Page access type
		uint64 reserved_1 : 17;	// [13:29]
		uint64 pfn : 18;			// [30:47] Page frame number
		uint64 reserved_2 : 4;		// [48:51]
		uint64 ignored_2 : 7;		// [52:58]
		uint64 pk : 4;			// [59:62] Protection key
		uint64 xd : 1;			// [63] Execute disable
	} map;

	struct
	{
		uint64 p : 1;				// [0] Present
		uint64 rw : 1;			// [1] Read/Write; if 0, writes may not be allowed
		uint64 us : 1;			// [2] User/Supervisor; if 0, user-mode accesses are not allowed
		uint64 pwt : 1;			// [3] Page-level write-through
		uint64 pcd : 1;			// [4] Page-level cache disable
		uint64 a : 1;				// [5] Accessed
		uint64 ignored_1 : 1;		// [6]
		uint64 ps : 1;			// [7] Page size
		uint64 ignored_2 : 4;		// [8:11]
		uint64 pfn : 36;			// [12:47] Page frame number
		uint64 reserved_1 : 4;		// [48:51]
		uint64 ignored_3 : 11;		// [52:62]
		uint64 xd : 1;			// [63] Execute disable
	} ref;
};

union PDE
{
	uint64 all;

	struct
	{
		uint64 p : 1;				// [0] Present
		uint64 rw : 1;			// [1] Read/Write; if 0, writes may not be allowed
		uint64 us : 1;			// [2] User/Supervisor; if 0, user-mode accesses are not allowed
		uint64 pwt : 1;			// [3] Page-level write-through
		uint64 pcd : 1;			// [4] Page-level cache disable
		uint64 a : 1;				// [5] Accessed
		uint64 d : 1;				// [6] Dirty
		uint64 ps : 1;			// [7] Page size
		uint64 g : 1;				// [8] Global
		uint64 ignored_1 : 3;		// [9:11]
		uint64 pat : 1;			// [12] Page access type
		uint64 reserved_1 : 8;		// [13:20]
		uint64 pfn : 27;			// [21:47] Page frame number
		uint64 reserved_2 : 4;		// [48:51]
		uint64 ignored_2 : 7;		// [52:58]
		uint64 pk : 4;			// [59:62] Protection key
		uint64 xd : 1;			// [63] Execute disable
	} map;

	struct
	{
		uint64 p : 1;				// [0] Present
		uint64 rw : 1;			// [1] Read/Write; if 0, writes may not be allowed
		uint64 us : 1;			// [2] User/Supervisor; if 0, user-mode accesses are not allowed
		uint64 pwt : 1;			// [3] Page-level write-through
		uint64 pcd : 1;			// [4] Page-level cache disable
		uint64 a : 1;				// [5] Accessed
		uint64 ignored_1 : 1;		// [6]
		uint64 ps : 1;			// [7] Page size
		uint64 ignored_2 : 4;		// [8:11]
		uint64 pfn : 36;			// [12:47] Page frame number
		uint64 reserved_1 : 4;		// [48:51]
		uint64 ignored_3 : 11;		// [52:62]
		uint64 xd : 1;			// [63] Execute disable
	} ref;
};

union PTE
{
	uint64 all;
	struct
	{
		uint64 p : 1;				// [0] Present
		uint64 rw : 1;			// [1] Read/Write; if 0, writes may not be allowed
		uint64 us : 1;			// [2] User/Supervisor; if 0, user-mode accesses are not allowed
		uint64 pwt : 1;			// [3] Page-level write-through
		uint64 pcd : 1;			// [4] Page-level cache disable
		uint64 a : 1;				// [5] Accessed
		uint64 d : 1;				// [6] Dirty
		uint64 pat : 1;			// [7] Page access type
		uint64 g : 1;             // [8] Global
		uint64 ignored_1 : 3;		// [9:11]
		uint64 pfn : 36;          // [12:47] Page frame number
		uint64 reserved_1 : 4;		// [48:51]
		uint64 ignored_2 : 7;		// [52:58]
		uint64 pk : 4;			// [59:62] Protection key
		uint64 xd : 1;            // [63] Execute disable
	};
};

inline constexpr int PageTableEntries = (PAGE_SIZE / sizeof(PTE));

/*
	Memory
*/

union VAddress
{
	uint64 all;

	struct
	{
		uint64 offset : 12;
		uint64 pt : 9;
		uint64 pd : 9;
		uint64 pdpt : 9;
		uint64 pml4 : 9;
		uint64 reserved : 16;
	};
};

/*
	CPUID
*/

union CPUID
{
	__int32 all[4];
	struct
	{
		struct
		{
			__int32 all;
		} EAX;

		struct
		{
			__int32 pad1 : 7;
			__int32 smep : 1;
			__int32 pad2 : 12;
			__int32 smap : 1;
			__int32 pad3 : 11;
		} EBX;

		struct 
		{
			__int32 all;
		} ECX;

		struct
		{
			__int32 all;
		} EDX;

	} EAX07hECX0h;
};

#if defined(_MSC_EXTENSIONS)
#pragma warning(pop)
#endif
```

`Files/CTypes.h`:

```h
#pragma once
#include <xmmintrin.h>

typedef __m128				uint128;
typedef unsigned __int64	uint64;
typedef unsigned __int32	uint32;
typedef unsigned __int16	uint16;
typedef unsigned __int8		uint8;

typedef __int64				int64;
typedef __int32				int32;
typedef __int16				int16;
typedef __int8				int8;

typedef unsigned long long	ulonglong;
typedef unsigned long		ulong;
typedef unsigned short		ushort;
typedef unsigned char		uchar;

typedef wchar_t wchar;

#ifdef _WIN64
	typedef unsigned __int64 uintn;
	typedef __int64 intn;
#else
	typedef unsigned __int32 uintn;
	typedef __int32 intn;
#endif
```

`Files/Handlers.h`:

```h
#pragma once
#include "CIA32.h"

extern "C" inline SegmentSelector OldCS{ 0 };
extern "C" inline SegmentSelector OldSS{ 0 };
extern "C" inline SegmentSelector OldTR{ 0 };

extern "C" inline GDTR OldGDTR{ 0 };

/*
	The debug fault handler for the modified IDT.
*/
extern "C" void DBHandler(void);

/*
	The general protection fault handler for the modified IDT.
*/
extern "C" void GPHandler(void);

/*
	The page fault handler for the modified IDT.
*/
extern "C" void PFHandler(void);
```

`Files/HandlersASM.asm`:

```asm
extern ptEntry : qword
extern hookPFN : qword
extern originalPFN : qword

extern OldCS : word
extern OldSS : word
extern OldTR : word
extern OldGDTR : fword

.code

	DBHandler proc

		btr qword ptr [rsp + 10h], 18		; Reset access check
		btr qword ptr [rsp + 10h], 8		; Reset trap flag
											
											; Just restoring stuff for the demo
		push rax
		push rcx

		lea rax, [oldGDTR]
		lgdt fword ptr [rax]

		mov rcx, qword ptr [rax + 2h]
		xor rax, rax
		mov ax, OldTR
		shr ax, 3
		btr qword ptr [rcx + rax * 8h], 41	; Remove TSS busy flag (prevents #GP)

		xor rax, rax
		mov ax, OldCS
		mov qword ptr [rsp + 18h], rax		; Restore CS value

		mov ax, OldSS
		mov qword ptr [rsp + 30h], rax		; Restore SS value

		mov ax, OldTR
		ltr ax								; Restore TR value

		push rdx

											; Swap PFN back to "hooked" page
		mov rax, ptEntry
		mov rcx, hookPFN
		mov rdx, 0FFFFFFFFFh
		shl rdx, 12
		not rdx
		and [rax], rdx
		shl rcx, 12
		or [rax], rcx

		invlpg [rsp + 18h]

		pop rdx
		pop rcx
		pop rax

		shl rax, 16
		mov ax, 0feedh						; For demo purposes

		iretq

	DBHandler endp

	GPHandler proc

		add rsp, 8h
		add qword ptr [rsp], 3h				; Skip instruction (mov rcx, cr3)
		shl rax, 16
		mov ax, 0cafeh						; For demo purposes
		iretq

	GPHandler endp

	PFHandler proc

		add rsp, 8h
		bts qword ptr [rsp + 10h], 18		; Set access check
		bts qword ptr [rsp + 10h], 8		; Set trap flag
		btr qword ptr [rsp + 10h], 16		; Reset resume flag

		push rax
		push rcx
		push rdx

											; Swap PFN to "original" page
		mov rax, ptEntry
		mov rcx, originalPFN
		mov rdx, 0FFFFFFFFFh
		shl rdx, 12
		not rdx
		and [rax], rdx
		shl rcx, 12
		or [rax], rcx

		invlpg [rsp + 18h]

		pop rdx
		pop rcx
		pop rax

		shl rax, 16
		mov ax, 0dadeh						; For demo purposes

		iretq

	PFHandler endp

end
```

`Files/Memory.cpp`:

```cpp
#include <ntddk.h>
#include <intrin.h>

#include "Memory.h"

void* AllocateContiguousMemory(size_t size, ULONG protect, bool zero)
{
	PHYSICAL_ADDRESS high{ 0 };
	high.QuadPart = ~0llu;

	void* mem = MmAllocateContiguousNodeMemory(size, PHYSICAL_ADDRESS{ 0 },
		high, PHYSICAL_ADDRESS{ 0 }, protect, MM_ANY_NODE_OK);

	if (mem && zero)
		RtlSecureZeroMemory(mem, size);

	return mem;
}

void FreeContiguousMemory(void* virt)
{
	return MmFreeContiguousMemory(virt);
}

uint64 VirtToPhys(void* virt)
{
	return MmGetPhysicalAddress(virt).QuadPart;
}

uint64 VirtToPFN(void* virt)
{
	return VirtToPhys(virt) >> 12;
}

void* PhysToVirt(uint64 phys)
{
	PHYSICAL_ADDRESS address{ 0 };
	address.QuadPart = phys;

	return MmGetVirtualForPhysical(address);
}

void* PFNToVirt(uint64 pfn)
{
	return PhysToVirt(pfn << 12);
}

void* NewTableEntry(void* currentTable, int* idx, uint64 flags)
{
	void* newTable = AllocateContiguousMemory(PAGE_SIZE, PAGE_READWRITE);
	if (!newTable)
		return nullptr;

	PTE* table = reinterpret_cast<PTE*>(currentTable);
	if (!table)
		return newTable;

	for (int i = PageTableEntries - 1; i >= 0; --i)
	{
		PTE* entry = &table[i];
		if (!entry->p && !entry->pfn)
		{
			entry->all = 0;

			entry->pfn = VirtToPFN(newTable);
			if (idx)
				*idx = i;

			entry->all |= flags;
			return newTable;
		}
	}

	return nullptr;
}

void FlushCaches(void* address)
{
	CR4 cr4{ __readcr4() };
	if (cr4.pcide || cr4.pge)
	{
		cr4.pge = ~(cr4.pge);
		__writecr4(cr4.all);
		cr4.pge = ~(cr4.pge);
		__writecr4(cr4.all);
	}
	else
	{
		__writecr3(__readcr3());
	}

	__wbinvd();
	__invlpg(address);
}
```

`Files/Memory.h`:

```h
#pragma once
#include "CIA32.h"

/*
	Allocates physically contiguous memory using MmAllocateContiguousNodeMemory.

	@param size - The size of memory to allocate
	@param protect - The memory protection for the allocation
	@param zero - Zero the allocation or not

	@return The virtual address of the allocated memory
*/
void* AllocateContiguousMemory(size_t size, ULONG protect, bool zero = true);

/*
	Frees physically contiguous memory using MmFreeContiguousMemory.

	@param virt - The virtual address of the allocated memory.
*/
void FreeContiguousMemory(void* virt);

/*
	Converts a virtual address to a physical address.

	@param virt - The virtual address to convert

	@return The physical address
*/
uint64 VirtToPhys(void* virt);

/*
	Converts a virtual address to a page frame number (PFN).

	@param virt - The virtual address to convert

	@return The PFN
*/
uint64 VirtToPFN(void* virt);

/*
	Converts a physical address to a virtual address.

	@param virt - The physical address to convert

	@return The virtual address
*/
void* PhysToVirt(uint64 phys);

/*
	Converts a PFN to a virtual address.

	@param virt - The PFN to convert

	@return The virtual address
*/
void* PFNToVirt(uint64 pfn);

/*
	Creates a new table entry for a supplied page table structure.

	@param currentTable - The current page table structure to create a new entry for.
	@param idx - The new table entry's index
	@param flags - The flags for the new table entry

	@return The virtual address of the new table entry
*/
void* NewTableEntry(void* currentTable, int* idx, uint64 flags);

/*
	Flushes the translation lookaside buffer (TLB) for the address and instruction cache.

	@param address - The address to flush
*/
void FlushCaches(void* address);
```

`Files/x64.h`:

```h
#pragma once
#include "CIA32.h"

/*
	When operating in protected, compatibility, or 64-bit mode at privilege
	level 0 (or in real-address mode, the equivalent to privilege level 0),
	all non-reserved flags in the EFLAGS register except RF, VIP, VIF, and
	VM may be modified. VIP, VIF, and VM remain unaffected.
*/

/*
	Writes to the RFLAG register with the specified value.

	@param rflags - The updated RFLAG value
*/
extern "C" void WriteRFlags(RFlags rflags);

/*
	Reads the GDTR value.

	@param gdtr - A variable to recieve the GDTR value
*/
extern "C" void ReadGDTR(GDTR* gdtr);

/*
	Writes the GDTR value.

	@param gdtr - A variable to write the GDTR value
*/
extern "C" void WriteGDTR(GDTR* gdtr);

/*
	Reads the CS value.

	@return The CS value
*/
extern "C" SegmentSelector ReadCS(void);

/*
	Reads the SS value.

	@return The SS value
*/
extern "C" SegmentSelector ReadSS(void);

/*
	Reads the TR value.

	@return The TR value
*/
extern "C" SegmentSelector ReadTR(void);
```

`Files/x64ASM.asm`:

```asm
.code

	WriteRFlags proc

		push rcx
		popfq
		ret

	WriteRFlags endp

	ReadGDTR proc

		sgdt [rcx]
		ret

	ReadGDTR endp

	WriteGDTR proc

		lgdt fword ptr [rcx]
		ret

	WriteGDTR endp

	ReadCS proc

		xor rax, rax
		mov ax, cs
		ret

	ReadCS endp

	ReadSS proc

		xor rax, rax
		mov ax, ss
		ret

	ReadSS endp

	ReadTR proc

		xor rax, rax
		str ax
		ret

	ReadTR endp

end
```

`README.md`:

```md
# BudgetEPT

This project is a proof-of-concept (POC) demonstrating a method of using supervisor-mode access prevention (SMAP)
and supervisor-mode execution prevention (SMEP) to create inline hooks that are functionally
similar to extended page table (EPT) hooks. The project also demonstrates a limited
example of how software virtualization could be used in conjunction with this project 
to better hide the presence of such hooks. A more detailed write-up can be found 
[here](https://brew02.github.io/posts/2024/budget-ept-hooks.html). 
```