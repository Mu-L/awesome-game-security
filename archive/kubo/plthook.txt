Project Path: arc_kubo_plthook_94ka4ls5

Source Tree:

```txt
arc_kubo_plthook_94ka4ls5
├── README.md
├── images
│   ├── figure1.dia
│   ├── figure1.png
│   ├── figure2.dia
│   ├── figure2.png
│   ├── figure3.dia
│   ├── figure3.png
│   ├── figure4.dia
│   └── figure4.png
├── plthook.h
├── plthook_elf.c
├── plthook_osx.c
├── plthook_win32.c
└── test
    ├── Makefile
    ├── Makefile.win32
    ├── android
    │   ├── jni
    │   │   ├── Android.mk
    │   │   └── Application.mk
    │   └── run_tests
    ├── libtest.c
    ├── libtest.def
    ├── libtest.h
    ├── run-test.bat
    ├── testprog.c
    └── uclibc-test.sh

```

`README.md`:

```md
PLTHook
=======

> [!CAUTION]
> Due to a shift in my personal interests, this repository is no longer maintained and has been archived.
> If you're looking for a successor project, please check [the network graph](https://github.com/kubo/plthook/network) to see if any forks have continued development.
> At the time of archiving, [metacall's fork](https://github.com/metacall/plthook) seems to be the best.

What is plthook.
----------------

A utility library to hook library function calls issued by
specified object files (executable and libraries). This modifies
PLT (Procedure Linkage Table) entries in [ELF][] format used on most Unixes
or [IAT (Import Address Table)][IAT] entries in PE format used on Windows.

[IAT]: https://en.wikipedia.org/wiki/Portable_Executable#Import_Table
[ELF]: https://en.wikipedia.org/wiki/Executable_and_Linkable_Format

### What is PLT (or IAT)

Note: This isn't precise explanation. Some details are omitted.

When a function calls another function in another file, it is called via PLT (on
Unix using ELF) or IAT (on Windows).

![figure1](images/figure1.png)

In order to call `foo_func()` in `libfoo.so`, the address of the callee must be
known. When callers are in the same file, the relative address to the callee is
known at compile time regardless of the absolute address at run time. So
`some_func()` calls `foo_func()` using relative addressing.

When callers are in other files, the address of the callee cannot be known at
compile time. To resolve it, each file has a mapping from external function names
to addresses. The callers directly look at the address in the PLT entry for
`foo_func()` and jump to the address.

The addresses in PLT entries are resolved (1) at process startup or (2) at first
function call (lazy binding). It depends on OSes or on settings.

### What plthook does.

![figure2](images/figure2.png)

Plthook changes the address in PLT entries as above.
When `foo_func()` is called from `program`, `hook_foo_func()` is called instead.
It doesn't change function calls from `libfoo.so` and `libbar.so`.

### How to call original functions from hook functions.

#### When hook functions are outside of modified files

![figure3](images/figure3.png)

When the hook function `hook_foo_func()` is in `libbar.so`, just call the
original function `foo_func()`. It looks the PLT entry in `libbar.so` and jumps
to the original.

#### When hook functions are inside of modified files

![figure4](images/figure4.png)

When the hook function `hook_foo_func()` is in `program`, do not call the
original function `foo_func()` because it jumps to `hook_foo_func()` repeatedly
and crashes the process after memory for stack is exhausted. You need to get the
address of the original function and set it to the function pointer variable
`foo_func_addr`. Use the fourth argument of `plthook_replace()` to get the
address on Windows. Use the return value of `dlsym(RTLD_DEFAULT, "foo_func")` on
Unixes. The fourth argument of `plthook_replace()` isn't available on Unixes
because it doesn't set the address of the original before the address in the PLT
entry is resolved.

Changes
-------

**2024-09-02:** Fix issues on macOS ([#48])

**2024-08-05:** Add `plthook_enum_with_prot()` to enumerate entries with memory protection information. (plthook_elf.c and plthook_osx.c)

**2023-06-01:** Add riscv support. (plthook_elf.c) ([#45])

**2022-09-19:** Drop macOS 32-bit application support. Drop support for macOS 10.14 Mojave or before.

**2022-08-12:** Support LC_DYLD_CHAINED_FIXUPS on macOS intel

**2020-03-30:** Check _start also in plthook_open_by_handle() (plthook_elf.c) ([#29])

**2020-03-09:** Add support for uClibc. ([#28])

**2019-11-14:** Fix potential incorrect parsing of /proc/self/maps on linux. ([#24])

**2019-11-14:** Fix possible double-close issue in plthook_elf.c ([#23])

**2019-09-27:** Fix resource leaks when the format of /proc/self/maps is unexpected on Linux. ([#20])

**2019-09-26:** Fix SEGV when plthook_open(..., "/usr/lib/libc.dylib") on macOS. ([#19])

**2019-02-17:** Support `plthook_open_by_address()` and change
internal logic of `plthook_open()` on Android.

**2019-02-17:** Stop checking RELRO and check memory protection at
runtime instead.

**2019-02-03:** Fix crash when programs are compiled with compiler options
`-Wl,-z,relro` and `-fno-plt` with the help of [JC Liang][]. ([#10][])

**2018-02-06:** Android support was contributed by [Daniel Deptford][].

**2017-10-01:** `plthook_elf.c` was rewritten. Plthook had needed to
read files on filesystem to get various information about target
object files. It now do it only for full RELRO object files.
Note that plthook before 2017-10-01 gets segmentation fault while
hooking a [prelinked file](https://en.wikipedia.org/wiki/Prelink#Linux) on Linux.

**2017-09-18:** Fixed for processes on [valgrind](https://valgrind.org) on Linux.

Usage
-----

If you have a library `libfoo.so.1` and want to intercept
a function call `recv()` without modifying the library,
put `plthook.h` and `plthook_elf.c`, `plthook_win32.c` or `plthook_osx.c`
in your source tree and add the following code.

```c
#include "plthook.h"

/* This function is called instead of recv() called by libfoo.so.1  */
static ssize_t my_recv(int sockfd, void *buf, size_t len, int flags)
{
    ssize_t rv;
    
    ... do your task: logging, etc. ...
    rv = recv(sockfd, buf, len, flags); /* call real recv(). */
    ... do your task: logging, check received data, etc. ...
    return rv;
}
    
int install_hook_function()
{
    plthook_t *plthook;
    
    if (plthook_open(&plthook, "libfoo.so.1") != 0) {
        printf("plthook_open error: %s\n", plthook_error());
        return -1;
    }
    if (plthook_replace(plthook, "recv", (void*)my_recv, NULL) != 0) {
        printf("plthook_replace error: %s\n", plthook_error());
        plthook_close(plthook);
        return -1;
    }
    plthook_close(plthook);
    return 0;
}
```

The above code doesn't work when `my_recv()` is in the file opened by
`plthook_open()` as described [here](#when-hook-functions-are-inside-of-modified-files).
Use the following code instead in the case.

```c
static ssize_t (*recv_func)(int sockfd, void *buf, size_t len, int flags);

/* This function is called instead of recv() called by libfoo.so.1  */
static ssize_t my_recv(int sockfd, void *buf, size_t len, int flags)
{
    ssize_t rv;
    
    ... do your task: logging, etc. ...
    rv = (*recv_func)(sockfd, buf, len, flags); /* call real recv(). */
    ... do your task: logging, check received data, etc. ...
    return rv;
}
    
int install_hook_function()
{
    plthook_t *plthook;
    
    if (plthook_open_by_address(&plthook, &recv_func) != 0) {
        printf("plthook_open error: %s\n", plthook_error());
        return -1;
    }
    if (plthook_replace(plthook, "recv", (void*)my_recv, (void**)&recv_func) != 0) {
        printf("plthook_replace error: %s\n", plthook_error());
        plthook_close(plthook);
        return -1;
    }
#ifndef WIN32
    // The address passed to the fourth argument of plthook_replace() is
    // available on Windows. But not on Unixes. Get the real address by dlsym().
    recv_func = (ssize_t (*)(int, void *, size_t, int))dlsym(RTLD_DEFAULT, "recv");
#endif
    plthook_close(plthook);
    return 0;
}
```

Note that built-in functions cannot be hooked. For example the C
compiler in macOS Sierra compiles `ceil()` as inline assembly code,
not as function call of `ceil` in the system library.

When a functions is imported by [ordinal][] on Windows,
the function name is specified by `export_dll_name:@ordinal`.
For example `api-ms-win-shcore-path-l1-1-0.dll:@170`.

[ordinal]: https://msdn.microsoft.com/en-us/library/e7tsx612.aspx

Another Usage
-------------

PLTHook provides a function enumerating PLT/IAT entries.

```c
void print_plt_entries(const char *filename)
{
    plthook_t *plthook;
    unsigned int pos = 0; /* This must be initialized with zero. */
    const char *name;
    void **addr;

    if (plthook_open(&plthook, filename) != 0) {
        printf("plthook_open error: %s\n", plthook_error());
        return -1;
    }
    while (plthook_enum(plthook, &pos, &name, &addr) == 0) {
        printf("%p(%p) %s\n", addr, *addr, name);
    }
    plthook_close(plthook);
    return 0;
}
```

Supported Platforms
-------------------

| Platform | source file | status |
| -------- | ----------- | ------ |
| Linux i386 and x86_64 | plthook_elf.c | tested using [github actions] |
| Linux arm, aarch64, powerpc and powerpc64le | plthook_elf.c | tested on [QEMU][] using [github actions] |
| Windows 32-bit and x64 (MSVC) | plthook_win32.c | tested using [github actions] |
| macOS (intel) (*4) | plthook_osx.c | tested using [github actions] |
| macOS (arm) | plthook_osx.c | tested using [github actions] |
| Windows 32-bit and x64 (Mingw32 and Cygwin) | plthook_win32.c | perhaps(*2) |
| Solaris x86_64 | plthook_elf.c | perhaps(*1) |
| FreeBSD i386 and x86_64 except i386 program on x86_64 OS | plthook_elf.c | perhaps(*1) |
| Android(*3) | plthook_elf.c | perhaps(*2) |

*1 Tested on a local VM before.  
*2 Tested on travis-ci.org before.  
*3 Contributed by [Daniel Deptford][].  
*4 macOS 10.14 Mojave support was dropped on 2022-09-19.  

[QEMU]: http://www.qemu.org/
[Daniel Deptford]: https://github.com/redmercury
[JC Liang]: https://github.com/tntljc
[#10]: https://github.com/kubo/plthook/pull/10
[#19]: https://github.com/kubo/plthook/issues/19
[#20]: https://github.com/kubo/plthook/issues/20
[#23]: https://github.com/kubo/plthook/pull/23
[#24]: https://github.com/kubo/plthook/issues/24
[#28]: https://github.com/kubo/plthook/pull/28
[#29]: https://github.com/kubo/plthook/issues/29
[#45]: https://github.com/kubo/plthook/pull/45
[#48]: https://github.com/kubo/plthook/issues/48
[github actions]: https://github.com/kubo/plthook/actions/workflows/run-tests.yml

License
-------

2-clause BSD-style license.

```

`plthook.h`:

```h
/* -*- indent-tabs-mode: nil -*-
 *
 * plthook.h -- the header file of plthook
 *
 * URL: https://github.com/kubo/plthook
 *
 * ------------------------------------------------------
 *
 * Copyright 2013-2024 Kubo Takehiro <kubo@jiubao.org>
 *
 * Redistribution and use in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 *
 *    1. Redistributions of source code must retain the above copyright notice, this list of
 *       conditions and the following disclaimer.
 *
 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
 *       of conditions and the following disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ''AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation are those of the
 * authors and should not be interpreted as representing official policies, either expressed
 * or implied, of the authors.
 *
 */
#ifndef PLTHOOK_H
#define PLTHOOK_H 1

#define PLTHOOK_SUCCESS              0
#define PLTHOOK_FILE_NOT_FOUND       1
#define PLTHOOK_INVALID_FILE_FORMAT  2
#define PLTHOOK_FUNCTION_NOT_FOUND   3
#define PLTHOOK_INVALID_ARGUMENT     4
#define PLTHOOK_OUT_OF_MEMORY        5
#define PLTHOOK_INTERNAL_ERROR       6
#define PLTHOOK_NOT_IMPLEMENTED      7

typedef struct plthook plthook_t;

#ifdef __cplusplus
extern "C" {
#endif

int plthook_open(plthook_t **plthook_out, const char *filename);
int plthook_open_by_handle(plthook_t **plthook_out, void *handle);
int plthook_open_by_address(plthook_t **plthook_out, void *address);
int plthook_enum(plthook_t *plthook, unsigned int *pos, const char **name_out, void ***addr_out);
int plthook_replace(plthook_t *plthook, const char *funcname, void *funcaddr, void **oldfunc);
void plthook_close(plthook_t *plthook);
const char *plthook_error(void);

/* enumerate entries with memory protection information (bitwise-OR of PROT_READ, PROT_WRITE and PROT_EXEC)
 *
 * source: plthook_elf.c and plthook_osx.c
 */
int plthook_enum_with_prot(plthook_t *plthook, unsigned int *pos, const char **name_out, void ***addr_out, int *prot);

typedef struct {
    const char *name;
    void **addr;
#ifdef __APPLE__
    int addend;
    // memory protection information. bitwise-OR of PROT_READ, PROT_WRITE and PROT_EXEC
    int prot;
    char weak;
#endif
} plthook_entry_t;

int plthook_enum_entry(plthook_t *plthook, unsigned int *pos, plthook_entry_t *entry);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif

```

`plthook_elf.c`:

```c
/* -*- indent-tabs-mode: nil -*-
 *
 * plthook_elf.c -- implementation of plthook for ELF format
 *
 * URL: https://github.com/kubo/plthook
 *
 * ------------------------------------------------------
 *
 * Copyright 2013-2019 Kubo Takehiro <kubo@jiubao.org>
 *
 * Redistribution and use in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 *
 *    1. Redistributions of source code must retain the above copyright notice, this list of
 *       conditions and the following disclaimer.
 *
 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
 *       of conditions and the following disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ''AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation are those of the
 * authors and should not be interpreted as representing official policies, either expressed
 * or implied, of the authors.
 *
 */
#if defined(__sun) && defined(_XOPEN_SOURCE) && !defined(__EXTENSIONS__)
#define __EXTENSIONS__
#endif
#if defined(__linux__) && !defined(_GNU_SOURCE)
#define _GNU_SOURCE
#endif
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <limits.h>
#include <sys/mman.h>
#include <errno.h>
#include <dlfcn.h>
#ifdef __sun
#include <sys/auxv.h>
#include <procfs.h>
#define ELF_TARGET_ALL
#endif /* __sun */
#ifdef __FreeBSD__
#include <sys/types.h>
#include <sys/user.h>
#include <libutil.h>
#endif
#include <elf.h>
#include <link.h>
#include "plthook.h"

#if defined __UCLIBC__ && !defined RTLD_NOLOAD
#define RTLD_NOLOAD 0
#endif

#ifndef __GNUC__
#define __attribute__(arg)
#endif

#if defined __FreeBSD__ && defined __i386__ && __ELF_WORD_SIZE == 64
#error 32-bit application on 64-bit OS is not supported.
#endif

#if !defined(R_X86_64_JUMP_SLOT) && defined(R_X86_64_JMP_SLOT)
#define R_X86_64_JUMP_SLOT R_X86_64_JMP_SLOT
#endif

#if defined __x86_64__ || defined __x86_64
#define R_JUMP_SLOT   R_X86_64_JUMP_SLOT
#define R_GLOBAL_DATA R_X86_64_GLOB_DAT
#elif defined __i386__ || defined __i386
#define R_JUMP_SLOT   R_386_JMP_SLOT
#define R_GLOBAL_DATA R_386_GLOB_DAT
#define USE_REL
#elif defined __arm__ || defined __arm
#define R_JUMP_SLOT   R_ARM_JUMP_SLOT
#define R_GLOBAL_DATA R_ARM_GLOB_DAT
#define USE_REL
#elif defined __aarch64__ || defined __aarch64 /* ARM64 */
#define R_JUMP_SLOT   R_AARCH64_JUMP_SLOT
#define R_GLOBAL_DATA R_AARCH64_GLOB_DAT
#elif defined __powerpc64__
#define R_JUMP_SLOT   R_PPC64_JMP_SLOT
#define R_GLOBAL_DATA R_PPC64_GLOB_DAT
#elif defined __powerpc__
#define R_JUMP_SLOT   R_PPC_JMP_SLOT
#define R_GLOBAL_DATA R_PPC_GLOB_DAT
#elif defined __riscv
#define R_JUMP_SLOT   R_RISCV_JUMP_SLOT
#if __riscv_xlen == 32
#define R_GLOBAL_DATA R_RISCV_32
#elif __riscv_xlen == 64
#define R_GLOBAL_DATA R_RISCV_64
#else
#error unsupported RISCV implementation
#endif
#elif 0 /* disabled because not tested */ && (defined __sparcv9 || defined __sparc_v9__)
#define R_JUMP_SLOT   R_SPARC_JMP_SLOT
#elif 0 /* disabled because not tested */ && (defined __sparc || defined __sparc__)
#define R_JUMP_SLOT   R_SPARC_JMP_SLOT
#elif 0 /* disabled because not tested */ && (defined __ia64 || defined __ia64__)
#define R_JUMP_SLOT   R_IA64_IPLTMSB
#else
#error unsupported OS
#endif

#ifdef USE_REL
#define Elf_Plt_Rel   Elf_Rel
#define PLT_DT_REL    DT_REL
#define PLT_DT_RELSZ  DT_RELSZ
#define PLT_DT_RELENT DT_RELENT
#else
#define Elf_Plt_Rel   Elf_Rela
#define PLT_DT_REL    DT_RELA
#define PLT_DT_RELSZ  DT_RELASZ
#define PLT_DT_RELENT DT_RELAENT
#endif

#if defined __LP64__
#ifndef ELF_CLASS
#define ELF_CLASS     ELFCLASS64
#endif
#define SIZE_T_FMT "lu"
#define ELF_WORD_FMT "u"
#ifdef __ANDROID__
#define ELF_XWORD_FMT "llu"
#else
#define ELF_XWORD_FMT "lu"
#endif
#define ELF_SXWORD_FMT "ld"
#define Elf_Half Elf64_Half
#define Elf_Xword Elf64_Xword
#define Elf_Sxword Elf64_Sxword
#define Elf_Ehdr Elf64_Ehdr
#define Elf_Phdr Elf64_Phdr
#define Elf_Sym  Elf64_Sym
#define Elf_Dyn  Elf64_Dyn
#define Elf_Rel  Elf64_Rel
#define Elf_Rela Elf64_Rela
#ifndef ELF_R_SYM
#define ELF_R_SYM ELF64_R_SYM
#endif
#ifndef ELF_R_TYPE
#define ELF_R_TYPE ELF64_R_TYPE
#endif
#else /* __LP64__ */
#ifndef ELF_CLASS
#define ELF_CLASS     ELFCLASS32
#endif
#define SIZE_T_FMT "u"
#ifdef __sun
#define ELF_WORD_FMT "lu"
#define ELF_XWORD_FMT "lu"
#define ELF_SXWORD_FMT "ld"
#else
#define ELF_WORD_FMT "u"
#define ELF_XWORD_FMT "u"
#define ELF_SXWORD_FMT "d"
#endif
#define Elf_Half Elf32_Half
#define Elf_Xword Elf32_Word
#define Elf_Sxword Elf32_Sword
#define Elf_Ehdr Elf32_Ehdr
#define Elf_Phdr Elf32_Phdr
#define Elf_Sym  Elf32_Sym
#define Elf_Dyn  Elf32_Dyn
#define Elf_Rel  Elf32_Rel
#define Elf_Rela Elf32_Rela
#ifndef ELF_R_SYM
#define ELF_R_SYM ELF32_R_SYM
#endif
#ifndef ELF_R_TYPE
#define ELF_R_TYPE ELF32_R_TYPE
#endif
#endif /* __LP64__ */

typedef struct mem_prot {
    size_t start;
    size_t end;
    int prot;
} mem_prot_t;

#define NUM_MEM_PROT 20

struct plthook {
    const Elf_Sym *dynsym;
    const char *dynstr;
    size_t dynstr_size;
    const char *plt_addr_base;
    const Elf_Plt_Rel *rela_plt;
    size_t rela_plt_cnt;
#ifdef R_GLOBAL_DATA
    const Elf_Plt_Rel *rela_dyn;
    size_t rela_dyn_cnt;
#endif
    mem_prot_t mem_prot[NUM_MEM_PROT];
};

static char errmsg[512];
static size_t page_size;
#define ALIGN_ADDR(addr) ((void*)((size_t)(addr) & ~(page_size - 1)))

static int plthook_open_executable(plthook_t **plthook_out);
static int plthook_open_shared_library(plthook_t **plthook_out, const char *filename);
static const Elf_Dyn *find_dyn_by_tag(const Elf_Dyn *dyn, Elf_Sxword tag);

typedef struct mem_prot_iter mem_prot_iter_t;
static int mem_prot_begin(mem_prot_iter_t *iter);
static int mem_prot_next(mem_prot_iter_t *iter, mem_prot_t *mem_prot);
static void mem_prot_end(mem_prot_iter_t *iter);

static int plthook_open_real(plthook_t **plthook_out, struct link_map *lmap);
static int plthook_set_mem_prot(plthook_t *plthook);
static int plthook_get_mem_prot(plthook_t *plthook, void *addr);
#if defined __FreeBSD__ || defined __sun
static int check_elf_header(const Elf_Ehdr *ehdr);
#endif
static void set_errmsg(const char *fmt, ...) __attribute__((__format__ (__printf__, 1, 2)));

#if defined __ANDROID__ || defined __UCLIBC__
struct dl_iterate_data {
    char* addr;
    struct link_map lmap;
};

static int dl_iterate_cb(struct dl_phdr_info *info, size_t size, void *cb_data)
{
    struct dl_iterate_data *data = (struct dl_iterate_data*)cb_data;
    Elf_Half idx = 0;

    for (idx = 0; idx < info->dlpi_phnum; ++idx) {
        const Elf_Phdr *phdr = &info->dlpi_phdr[idx];
        char* base = (char*)info->dlpi_addr + phdr->p_vaddr;
        if (base <= data->addr && data->addr < base + phdr->p_memsz) {
            break;
        }
    }
    if (idx == info->dlpi_phnum) {
        return 0;
    }
    for (idx = 0; idx < info->dlpi_phnum; ++idx) {
        const Elf_Phdr *phdr = &info->dlpi_phdr[idx];
        if (phdr->p_type == PT_DYNAMIC) {
            data->lmap.l_addr = info->dlpi_addr;
            data->lmap.l_ld = (Elf_Dyn*)(info->dlpi_addr + phdr->p_vaddr);
            return 1;
        }
    }
    return 0;
}
#endif

int plthook_open(plthook_t **plthook_out, const char *filename)
{
    *plthook_out = NULL;
    if (filename == NULL) {
        return plthook_open_executable(plthook_out);
    } else {
        return plthook_open_shared_library(plthook_out, filename);
    }
}

int plthook_open_by_handle(plthook_t **plthook_out, void *hndl)
{
#if defined __ANDROID__ || defined __UCLIBC__
    const static char *symbols[] = {
        "__INIT_ARRAY__",
        "_end",
        "_start"
    };
    size_t i;

    if (hndl == NULL) {
        set_errmsg("NULL handle");
        return PLTHOOK_FILE_NOT_FOUND;
    }
    for (i = 0; i < sizeof(symbols)/sizeof(symbols[0]); i++) {
        char *addr = dlsym(hndl, symbols[i]);
        if (addr != NULL) {
            return plthook_open_by_address(plthook_out, addr - 1);
        }
    }
    set_errmsg("Could not find an address in the specified handle.");
    return PLTHOOK_INTERNAL_ERROR;
#else
    struct link_map *lmap = NULL;

    if (hndl == NULL) {
        set_errmsg("NULL handle");
        return PLTHOOK_FILE_NOT_FOUND;
    }
    if (dlinfo(hndl, RTLD_DI_LINKMAP, &lmap) != 0) {
        set_errmsg("dlinfo error");
        return PLTHOOK_FILE_NOT_FOUND;
    }
    return plthook_open_real(plthook_out, lmap);
#endif
}

int plthook_open_by_address(plthook_t **plthook_out, void *address)
{
#if defined __FreeBSD__
    return PLTHOOK_NOT_IMPLEMENTED;
#elif defined __ANDROID__ || defined __UCLIBC__
    struct dl_iterate_data data = {0,};
    data.addr = address;
    dl_iterate_phdr(dl_iterate_cb, &data);
    if (data.lmap.l_ld == NULL) {
        set_errmsg("Could not find memory region containing address %p", address);
        return PLTHOOK_INTERNAL_ERROR;
    }
    return plthook_open_real(plthook_out, &data.lmap);
#else
    Dl_info info;
    struct link_map *lmap = NULL;

    *plthook_out = NULL;
    if (dladdr1(address, &info, (void**)&lmap, RTLD_DL_LINKMAP) == 0) {
        set_errmsg("dladdr error");
        return PLTHOOK_FILE_NOT_FOUND;
    }
    return plthook_open_real(plthook_out, lmap);
#endif
}

static int plthook_open_executable(plthook_t **plthook_out)
{
#if defined __ANDROID__ || defined __UCLIBC__
    return plthook_open_shared_library(plthook_out, NULL);
#elif defined __linux__
    return plthook_open_real(plthook_out, _r_debug.r_map);
#elif defined __sun
    const char *auxv_file = "/proc/self/auxv";
#define NUM_AUXV_CNT 10
    FILE *fp = fopen(auxv_file, "r");
    auxv_t auxv;
    struct r_debug *r_debug = NULL;

    if (fp == NULL) {
        set_errmsg("Could not open %s: %s", auxv_file,
                   strerror(errno));
        return PLTHOOK_INTERNAL_ERROR;
    }
    while (fread(&auxv, sizeof(auxv_t), 1, fp) == 1) {
        if (auxv.a_type == AT_SUN_LDDATA) {
            r_debug = (struct r_debug *)auxv.a_un.a_ptr;
            break;
        }
    }
    fclose(fp);
    if (r_debug == NULL) {
        set_errmsg("Could not find r_debug");
        return PLTHOOK_INTERNAL_ERROR;
    }
    return plthook_open_real(plthook_out, r_debug->r_map);
#elif defined __FreeBSD__
    return plthook_open_shared_library(plthook_out, NULL);
#else
    set_errmsg("Opening the main program is not supported on this platform.");
    return PLTHOOK_NOT_IMPLEMENTED;
#endif
}

static int plthook_open_shared_library(plthook_t **plthook_out, const char *filename)
{
    void *hndl = dlopen(filename, RTLD_LAZY | RTLD_NOLOAD);
#if defined __ANDROID__ || defined __UCLIBC__
    int rv;
#else
    struct link_map *lmap = NULL;
#endif

    if (hndl == NULL) {
        set_errmsg("dlopen error: %s", dlerror());
        return PLTHOOK_FILE_NOT_FOUND;
    }
#if defined __ANDROID__ || defined __UCLIBC__
    rv = plthook_open_by_handle(plthook_out, hndl);
    dlclose(hndl);
    return rv;
#else
    if (dlinfo(hndl, RTLD_DI_LINKMAP, &lmap) != 0) {
        set_errmsg("dlinfo error");
        dlclose(hndl);
        return PLTHOOK_FILE_NOT_FOUND;
    }
    dlclose(hndl);
    return plthook_open_real(plthook_out, lmap);
#endif
}

static const Elf_Dyn *find_dyn_by_tag(const Elf_Dyn *dyn, Elf_Sxword tag)
{
    while (dyn->d_tag != DT_NULL) {
        if (dyn->d_tag == tag) {
            return dyn;
        }
        dyn++;
    }
    return NULL;
}

#ifdef __linux__
struct mem_prot_iter {
    FILE *fp;
};

static int mem_prot_begin(mem_prot_iter_t *iter)
{
    iter->fp = fopen("/proc/self/maps", "r");
    if (iter->fp == NULL) {
        set_errmsg("failed to open /proc/self/maps");
        return -1;
    }
    return 0;
}

static int mem_prot_next(mem_prot_iter_t *iter, mem_prot_t *mem_prot)
{
    char buf[PATH_MAX];
    char perms[5];
    int bol = 1; /* beginnng of line */

    while (fgets(buf, PATH_MAX, iter->fp) != NULL) {
        unsigned long start, end;
        int eol = (strchr(buf, '\n') != NULL); /* end of line */
        if (bol) {
            /* The fgets reads from the beginning of a line. */
            if (!eol) {
                /* The next fgets reads from the middle of the same line. */
                bol = 0;
            }
        } else {
            /* The fgets reads from the middle of a line. */
            if (eol) {
                /* The next fgets reads from the beginning of a line. */
                bol = 1;
            }
            continue;
        }

        if (sscanf(buf, "%lx-%lx %4s", &start, &end, perms) != 3) {
            continue;
        }
        mem_prot->start = start;
        mem_prot->end = end;
        mem_prot->prot = 0;
        if (perms[0] == 'r') {
            mem_prot->prot |= PROT_READ;
        }
        if (perms[1] == 'w') {
            mem_prot->prot |= PROT_WRITE;
        }
        if (perms[2] == 'x') {
            mem_prot->prot |= PROT_EXEC;
        }
        return 0;
    }
    return -1;
}

static void mem_prot_end(mem_prot_iter_t *iter)
{
    if (iter->fp != NULL) {
        fclose(iter->fp);
    }
}
#elif defined __FreeBSD__
struct mem_prot_iter {
    struct kinfo_vmentry *kve;
    int idx;
    int num;
};

static int mem_prot_begin(mem_prot_iter_t *iter)
{
    iter->kve = kinfo_getvmmap(getpid(), &iter->num);
    if (iter->kve == NULL) {
         set_errmsg("failed to call kinfo_getvmmap()\n");
         return -1;
    }
    iter->idx = 0;
    return 0;
}

static int mem_prot_next(mem_prot_iter_t *iter, mem_prot_t *mem_prot)
{
    if (iter->idx >= iter->num) {
        return -1;
    }
    struct kinfo_vmentry *kve = &iter->kve[iter->idx++];
    mem_prot->start = kve->kve_start;
    mem_prot->end = kve->kve_end;
    mem_prot->prot = 0;
    if (kve->kve_protection & KVME_PROT_READ) {
        mem_prot->prot |= PROT_READ;
    }
    if (kve->kve_protection & KVME_PROT_WRITE) {
        mem_prot->prot |= PROT_WRITE;
    }
    if (kve->kve_protection & KVME_PROT_EXEC) {
        mem_prot->prot |= PROT_EXEC;
    }
    return 0;
}

static void mem_prot_end(mem_prot_iter_t *iter)
{
    if (iter->kve != NULL) {
        free(iter->kve);
    }
}
#elif defined(__sun)
struct mem_prot_iter {
    FILE *fp;
    prmap_t maps[20];
    size_t idx;
    size_t num;
};

static int mem_prot_begin(mem_prot_iter_t *iter)
{
    iter->fp = fopen("/proc/self/map", "r");
    if (iter->fp == NULL) {
        set_errmsg("failed to open /proc/self/map");
        return -1;
    }
    iter->idx = iter->num = 0;
    return 0;
}

static int mem_prot_next(mem_prot_iter_t *iter, mem_prot_t *mem_prot)
{
    prmap_t *map;

    if (iter->idx == iter->num) {
        iter->num = fread(iter->maps, sizeof(iter->maps[0]), sizeof(iter->maps) / sizeof(iter->maps[0]), iter->fp);
        if (iter->num == 0) {
            return -1;
        }
        iter->idx = 0;
    }
    map = &iter->maps[iter->idx++];
    mem_prot->start = map->pr_vaddr;
    mem_prot->end = map->pr_vaddr + map->pr_size;
    mem_prot->prot = 0;
    if (map->pr_mflags & MA_READ) {
        mem_prot->prot |= PROT_READ;
    }
    if (map->pr_mflags & MA_WRITE) {
        mem_prot->prot |= PROT_WRITE;
    }
    if (map->pr_mflags & MA_EXEC) {
        mem_prot->prot |= PROT_EXEC;
    }
    return 0;
}

static void mem_prot_end(mem_prot_iter_t *iter)
{
    if (iter->fp != NULL) {
        fclose(iter->fp);
    }
}
#else
#error Unsupported platform
#endif

static int plthook_open_real(plthook_t **plthook_out, struct link_map *lmap)
{
    plthook_t plthook = {NULL,};
    const Elf_Dyn *dyn;
    const char *dyn_addr_base = NULL;

    if (page_size == 0) {
        page_size = sysconf(_SC_PAGESIZE);
    }

#if defined __linux__
    plthook.plt_addr_base = (char*)lmap->l_addr;
#if defined __riscv
    const Elf_Ehdr *ehdr = (const Elf_Ehdr*)lmap->l_addr;
    if (ehdr->e_type == ET_DYN) {
        dyn_addr_base = (const char*)lmap->l_addr;
    }
#endif
#if defined __ANDROID__ || defined __UCLIBC__
    dyn_addr_base = (const char*)lmap->l_addr;
#endif
#elif defined __FreeBSD__ || defined __sun
#if __FreeBSD__ >= 13
    const Elf_Ehdr *ehdr = (const Elf_Ehdr*)lmap->l_base;
#else
    const Elf_Ehdr *ehdr = (const Elf_Ehdr*)lmap->l_addr;
#endif
    int rv_ = check_elf_header(ehdr);
    if (rv_ != 0) {
        return rv_;
    }
    if (ehdr->e_type == ET_DYN) {
        dyn_addr_base = (const char*)lmap->l_addr;
        plthook.plt_addr_base = (const char*)lmap->l_addr;
    }
#else
#error unsupported OS
#endif

    /* get .dynsym section */
    dyn = find_dyn_by_tag(lmap->l_ld, DT_SYMTAB);
    if (dyn == NULL) {
        set_errmsg("failed to find DT_SYMTAB");
        return PLTHOOK_INTERNAL_ERROR;
    }
    plthook.dynsym = (const Elf_Sym*)(dyn_addr_base + dyn->d_un.d_ptr);

    /* Check sizeof(Elf_Sym) */
    dyn = find_dyn_by_tag(lmap->l_ld, DT_SYMENT);
    if (dyn == NULL) {
        set_errmsg("failed to find DT_SYMTAB");
        return PLTHOOK_INTERNAL_ERROR;
    }
    if (dyn->d_un.d_val != sizeof(Elf_Sym)) {
        set_errmsg("DT_SYMENT size %" ELF_XWORD_FMT " != %" SIZE_T_FMT, dyn->d_un.d_val, sizeof(Elf_Sym));
        return PLTHOOK_INTERNAL_ERROR;
    }

    /* get .dynstr section */
    dyn = find_dyn_by_tag(lmap->l_ld, DT_STRTAB);
    if (dyn == NULL) {
        set_errmsg("failed to find DT_STRTAB");
        return PLTHOOK_INTERNAL_ERROR;
    }
    plthook.dynstr = dyn_addr_base + dyn->d_un.d_ptr;

    /* get .dynstr size */
    dyn = find_dyn_by_tag(lmap->l_ld, DT_STRSZ);
    if (dyn == NULL) {
        set_errmsg("failed to find DT_STRSZ");
        return PLTHOOK_INTERNAL_ERROR;
    }
    plthook.dynstr_size = dyn->d_un.d_val;

    /* get .rela.plt or .rel.plt section */
    dyn = find_dyn_by_tag(lmap->l_ld, DT_JMPREL);
    if (dyn != NULL) {
        plthook.rela_plt = (const Elf_Plt_Rel *)(dyn_addr_base + dyn->d_un.d_ptr);
        dyn = find_dyn_by_tag(lmap->l_ld, DT_PLTRELSZ);
        if (dyn == NULL) {
            set_errmsg("failed to find DT_PLTRELSZ");
            return PLTHOOK_INTERNAL_ERROR;
        }
        plthook.rela_plt_cnt = dyn->d_un.d_val / sizeof(Elf_Plt_Rel);
    }
#ifdef R_GLOBAL_DATA
    /* get .rela.dyn or .rel.dyn section */
    dyn = find_dyn_by_tag(lmap->l_ld, PLT_DT_REL);
    if (dyn != NULL) {
        size_t total_size, elem_size;

        plthook.rela_dyn = (const Elf_Plt_Rel *)(dyn_addr_base + dyn->d_un.d_ptr);
        dyn = find_dyn_by_tag(lmap->l_ld, PLT_DT_RELSZ);
        if (dyn == NULL) {
            set_errmsg("failed to find PLT_DT_RELSZ");
            return PLTHOOK_INTERNAL_ERROR;
        }
        total_size = dyn->d_un.d_ptr;

        dyn = find_dyn_by_tag(lmap->l_ld, PLT_DT_RELENT);
        if (dyn == NULL) {
            set_errmsg("failed to find PLT_DT_RELENT");
            return PLTHOOK_INTERNAL_ERROR;
        }
        elem_size = dyn->d_un.d_ptr;
        plthook.rela_dyn_cnt = total_size / elem_size;
    }
#endif

#ifdef R_GLOBAL_DATA
    if (plthook.rela_plt == NULL && plthook.rela_dyn == NULL) {
        set_errmsg("failed to find either of DT_JMPREL and DT_REL");
        return PLTHOOK_INTERNAL_ERROR;
    }
#else
    if (plthook.rela_plt == NULL) {
        set_errmsg("failed to find DT_JMPREL");
        return PLTHOOK_INTERNAL_ERROR;
    }
#endif
    if (plthook_set_mem_prot(&plthook)) {
        return PLTHOOK_INTERNAL_ERROR;
    }

    *plthook_out = malloc(sizeof(plthook_t));
    if (*plthook_out == NULL) {
        set_errmsg("failed to allocate memory: %" SIZE_T_FMT " bytes", sizeof(plthook_t));
        return PLTHOOK_OUT_OF_MEMORY;
    }
    **plthook_out = plthook;
    return 0;
}

static int plthook_set_mem_prot(plthook_t *plthook)
{
    unsigned int pos = 0;
    const char *name;
    void **addr;
    size_t start = (size_t)-1;
    size_t end = 0;
    mem_prot_iter_t iter;
    mem_prot_t mem_prot;
    int idx = 0;

    while (plthook_enum(plthook, &pos, &name, &addr) == 0) {
        if (start > (size_t)addr) {
            start = (size_t)addr;
        }
        if (end < (size_t)addr) {
            end = (size_t)addr;
        }
    }
    end++;

    if (mem_prot_begin(&iter) != 0) {
        return PLTHOOK_INTERNAL_ERROR;
    }
    while (mem_prot_next(&iter, &mem_prot) == 0 && idx < NUM_MEM_PROT) {
        if (mem_prot.prot != 0 && mem_prot.start < end && start < mem_prot.end) {
            plthook->mem_prot[idx++] = mem_prot;
        }
    }
    mem_prot_end(&iter);
    return 0;
}

static int plthook_get_mem_prot(plthook_t *plthook, void *addr)
{
    mem_prot_t *ptr = plthook->mem_prot;
    mem_prot_t *end = ptr + NUM_MEM_PROT;

    while (ptr < end && ptr->prot != 0) {
        if (ptr->start <= (size_t)addr && (size_t)addr < ptr->end) {
            return ptr->prot;
        }
        ++ptr;
    }
    return 0;
}

#if defined __FreeBSD__ || defined __sun
static int check_elf_header(const Elf_Ehdr *ehdr)
{
    static const unsigned short s = 1;
    /* Check endianness at runtime. */
    unsigned char elfdata = (*(const char*)&s) ? ELFDATA2LSB : ELFDATA2MSB;

    if (ehdr == NULL) {
        set_errmsg("invalid elf header address: NULL");
        return PLTHOOK_INTERNAL_ERROR;
    }

    if (memcmp(ehdr->e_ident, ELFMAG, SELFMAG) != 0) {
        set_errmsg("invalid file signature: 0x%02x,0x%02x,0x%02x,0x%02x",
                   ehdr->e_ident[0], ehdr->e_ident[1], ehdr->e_ident[2], ehdr->e_ident[3]);
        return PLTHOOK_INVALID_FILE_FORMAT;
    }
    if (ehdr->e_ident[EI_CLASS] != ELF_CLASS) {
        set_errmsg("invalid elf class: 0x%02x", ehdr->e_ident[EI_CLASS]);
        return PLTHOOK_INVALID_FILE_FORMAT;
    }
    if (ehdr->e_ident[EI_DATA] != elfdata) {
        set_errmsg("invalid elf data: 0x%02x", ehdr->e_ident[EI_DATA]);
        return PLTHOOK_INVALID_FILE_FORMAT;
    }
    if (ehdr->e_ident[EI_VERSION] != EV_CURRENT) {
        set_errmsg("invalid elf version: 0x%02x", ehdr->e_ident[EI_VERSION]);
        return PLTHOOK_INVALID_FILE_FORMAT;
    }
    if (ehdr->e_type != ET_EXEC && ehdr->e_type != ET_DYN) {
        set_errmsg("invalid file type: 0x%04x", ehdr->e_type);
        return PLTHOOK_INVALID_FILE_FORMAT;
    }
    if (ehdr->e_version != EV_CURRENT) {
        set_errmsg("invalid object file version: %" ELF_WORD_FMT, ehdr->e_version);
        return PLTHOOK_INVALID_FILE_FORMAT;
    }
    if (ehdr->e_ehsize != sizeof(Elf_Ehdr)) {
        set_errmsg("invalid elf header size: %u", ehdr->e_ehsize);
        return PLTHOOK_INVALID_FILE_FORMAT;
    }
    if (ehdr->e_phentsize != sizeof(Elf_Phdr)) {
        set_errmsg("invalid program header table entry size: %u", ehdr->e_phentsize);
        return PLTHOOK_INVALID_FILE_FORMAT;
    }
    return 0;
}
#endif

static int check_rel(const plthook_t *plthook, const Elf_Plt_Rel *plt, Elf_Xword r_type, const char **name_out, void ***addr_out)
{
    if (ELF_R_TYPE(plt->r_info) == r_type) {
        size_t idx = ELF_R_SYM(plt->r_info);
        idx = plthook->dynsym[idx].st_name;
        if (idx + 1 > plthook->dynstr_size) {
            set_errmsg("too big section header string table index: %" SIZE_T_FMT, idx);
            return PLTHOOK_INVALID_FILE_FORMAT;
        }
        *name_out = plthook->dynstr + idx;
        *addr_out = (void**)(plthook->plt_addr_base + plt->r_offset);
        return 0;
    }
    return -1;
}

int plthook_enum(plthook_t *plthook, unsigned int *pos, const char **name_out, void ***addr_out)
{
    return plthook_enum_with_prot(plthook, pos, name_out, addr_out, NULL);
}

int plthook_enum_with_prot(plthook_t *plthook, unsigned int *pos, const char **name_out, void ***addr_out, int *prot)
{
    while (*pos < plthook->rela_plt_cnt) {
        const Elf_Plt_Rel *plt = plthook->rela_plt + *pos;
        int rv = check_rel(plthook, plt, R_JUMP_SLOT, name_out, addr_out);
        (*pos)++;
        if (rv >= 0) {
            if (rv == 0 && prot != NULL) {
                *prot = plthook_get_mem_prot(plthook, *addr_out);
            }
            return rv;
        }
    }
#ifdef R_GLOBAL_DATA
    while (*pos < plthook->rela_plt_cnt + plthook->rela_dyn_cnt) {
        const Elf_Plt_Rel *plt = plthook->rela_dyn + (*pos - plthook->rela_plt_cnt);
        int rv = check_rel(plthook, plt, R_GLOBAL_DATA, name_out, addr_out);
        (*pos)++;
        if (rv >= 0) {
            if (rv == 0 && prot != NULL) {
                *prot = plthook_get_mem_prot(plthook, *addr_out);
            }
            return rv;
        }
    }
#endif
    *name_out = NULL;
    *addr_out = NULL;
    return EOF;
}

int plthook_replace(plthook_t *plthook, const char *funcname, void *funcaddr, void **oldfunc)
{
    size_t funcnamelen = strlen(funcname);
    unsigned int pos = 0;
    const char *name;
    void **addr;
    int rv;

    if (plthook == NULL) {
        set_errmsg("invalid argument: The first argument is null.");
        return PLTHOOK_INVALID_ARGUMENT;
    }
    while ((rv = plthook_enum(plthook, &pos, &name, &addr)) == 0) {
        if (strncmp(name, funcname, funcnamelen) == 0) {
            if (name[funcnamelen] == '\0' || name[funcnamelen] == '@') {
                int prot = plthook_get_mem_prot(plthook, addr);
                if (prot == 0) {
                    set_errmsg("Could not get the process memory permission at %p",
                             ALIGN_ADDR(addr));
                    return PLTHOOK_INTERNAL_ERROR;
                }
                if (!(prot & PROT_WRITE)) {
                    if (mprotect(ALIGN_ADDR(addr), page_size, PROT_READ | PROT_WRITE) != 0) {
                        set_errmsg("Could not change the process memory permission at %p: %s",
                                   ALIGN_ADDR(addr), strerror(errno));
                        return PLTHOOK_INTERNAL_ERROR;
                    }
                }
                if (oldfunc) {
                    *oldfunc = *addr;
                }
                *addr = funcaddr;
                if (!(prot & PROT_WRITE)) {
                    mprotect(ALIGN_ADDR(addr), page_size, prot);
                }
                return 0;
            }
        }
    }
    if (rv == EOF) {
        set_errmsg("no such function: %s", funcname);
        rv = PLTHOOK_FUNCTION_NOT_FOUND;
    }
    return rv;
}

void plthook_close(plthook_t *plthook)
{
    if (plthook != NULL) {
        free(plthook);
    }
}

const char *plthook_error(void)
{
    return errmsg;
}

static void set_errmsg(const char *fmt, ...)
{
    va_list ap;
    va_start(ap, fmt);
    vsnprintf(errmsg, sizeof(errmsg) - 1, fmt, ap);
    va_end(ap);
}

```

`plthook_osx.c`:

```c
/* -*- indent-tabs-mode: nil -*-
 *
 * plthook_osx.c -- implementation of plthook for OS X
 *
 * URL: https://github.com/kubo/plthook
 *
 * ------------------------------------------------------
 *
 * Copyright 2014-2024 Kubo Takehiro <kubo@jiubao.org>
 *
 * Redistribution and use in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 *
 *    1. Redistributions of source code must retain the above copyright notice, this list of
 *       conditions and the following disclaimer.
 *
 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
 *       of conditions and the following disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ''AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation are those of the
 * authors and should not be interpreted as representing official policies, either expressed
 * or implied, of the authors.
 *
 */
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <inttypes.h>
#include <dlfcn.h>
#include <errno.h>
#include <mach/mach.h>
#include <mach-o/dyld.h>
#include <sys/mman.h>
#include <mach-o/fixup-chains.h>
#include "plthook.h"

// #define PLTHOOK_DEBUG_CMD 1
// #define PLTHOOK_DEBUG_BIND 1
// #define PLTHOOK_DEBUG_FIXUPS 1
// #define PLTHOOK_DEBUG_ADDR 1

#ifdef PLTHOOK_DEBUG_CMD
#define DEBUG_CMD(...) fprintf(stderr, __VA_ARGS__)
#else
#define DEBUG_CMD(...)
#endif

#ifdef PLTHOOK_DEBUG_FIXUPS
#define DEBUG_FIXUPS(...) fprintf(stderr, __VA_ARGS__)
#else
#define DEBUG_FIXUPS(...)
#endif

#ifdef PLTHOOK_DEBUG_BIND
#define DEBUG_BIND(...) fprintf(stderr, __VA_ARGS__)
#define DEBUG_BIND_IF(cond, ...) if (cond) fprintf(stderr, __VA_ARGS__)
#else
#define DEBUG_BIND(...)
#define DEBUG_BIND_IF(cond, ...)
#endif

#ifdef PLTHOOK_DEBUG_ADDR
#include <mach/mach.h>

#define INHERIT_MAX_SIZE 11
static char *inherit_to_str(vm_inherit_t inherit, char *buf)
{
    switch (inherit) {
    case VM_INHERIT_SHARE: return "share";
    case VM_INHERIT_COPY: return "copy";
    case VM_INHERIT_NONE: return "none";
    case VM_INHERIT_DONATE_COPY: return "donate_copy";
    default:
        sprintf(buf, "%d", inherit);
        return buf;
    }
}

#define BEHAVIOR_MAX_SIZE 16
static char *behavior_to_str(vm_behavior_t behavior, char *buf)
{
    switch (behavior) {
    case VM_BEHAVIOR_DEFAULT: return "default";
    case VM_BEHAVIOR_RANDOM: return "random";
    case VM_BEHAVIOR_SEQUENTIAL: return "sequential";
    case VM_BEHAVIOR_RSEQNTL: return "rseqntl";
    case VM_BEHAVIOR_WILLNEED: return "willneed";
    case VM_BEHAVIOR_DONTNEED: return "dontneed";
    case VM_BEHAVIOR_FREE: return "free";
    case VM_BEHAVIOR_ZERO_WIRED_PAGES: return "zero";
    case VM_BEHAVIOR_REUSABLE: return "reusable";
    case VM_BEHAVIOR_REUSE: return "reuse";
    case VM_BEHAVIOR_CAN_REUSE: return "can";
    case VM_BEHAVIOR_PAGEOUT: return "pageout";
    default:
        sprintf(buf, "%d", behavior);
        return buf;
    }
}

static void dump_maps(const char *image_name)
{
    mach_port_t task = mach_task_self();
    vm_region_basic_info_data_64_t info;
    mach_msg_type_number_t info_count = VM_REGION_BASIC_INFO_COUNT_64;
    memory_object_name_t object = 0;
    vm_address_t addr = 0;
    vm_size_t size;
    char inherit_buf[INHERIT_MAX_SIZE + 1];
    char behavior_buf[BEHAVIOR_MAX_SIZE + 1];

    fprintf(stderr, "MEMORY MAP(%s)\n", image_name);
    fprintf(stderr, " start address    end address      protection    max_protection inherit     shared reserved offset   behavior         user_wired_count\n");
    while (vm_region_64(task, &addr, &size, VM_REGION_BASIC_INFO_64, (vm_region_info_t)&info, &info_count, &object) == KERN_SUCCESS) {
        fprintf(stderr, " %016lx-%016lx %c%c%c(%08x) %c%c%c(%08x)  %-*s %c      %c        %08llx %-*s %u\n",
                addr, addr + size,
                (info.protection & VM_PROT_READ) ? 'r' : '-',
                (info.protection & VM_PROT_WRITE) ? 'w' : '-',
                (info.protection & VM_PROT_EXECUTE) ? 'x' : '-',
                info.protection,
                (info.max_protection & VM_PROT_READ) ? 'r' : '-',
                (info.max_protection & VM_PROT_WRITE) ? 'w' : '-',
                (info.max_protection & VM_PROT_EXECUTE) ? 'x' : '-',
                info.max_protection,
                INHERIT_MAX_SIZE, inherit_to_str(info.inheritance, inherit_buf),
                info.shared ? 'Y' : 'N',
                info.reserved ? 'Y' : 'N',
                info.offset,
                BEHAVIOR_MAX_SIZE, behavior_to_str(info.behavior, behavior_buf),
                info.user_wired_count);
        addr += size;
    }
}
#endif

typedef struct {
    const char *name;
    int addend;
    char weak;
    void **addr;
} bind_address_t;

typedef struct mem_prot {
    size_t start;
    size_t end;
    int prot;
} mem_prot_t;

#define NUM_MEM_PROT 100

struct plthook {
    unsigned int num_entries;
    mem_prot_t mem_prot[NUM_MEM_PROT];
    bind_address_t entries[1]; /* This must be the last. */
};

#define MAX_SEGMENTS 8
#define MAX_SECTIONS 30

typedef struct {
    plthook_t *plthook;
    intptr_t slide;
    int num_segments;
    int linkedit_segment_idx;
    const struct segment_command_64 *segments[MAX_SEGMENTS];
#ifdef PLTHOOK_DEBUG_FIXUPS
    int num_sections;
    const struct section_64 *sections[MAX_SECTIONS];
#endif
    const struct linkedit_data_command *chained_fixups;
} data_t;

static int plthook_open_real(plthook_t **plthook_out, uint32_t image_idx, const struct mach_header *mh, const char *image_name);
static unsigned int set_bind_addrs(data_t *data, unsigned int idx, uint32_t bind_off, uint32_t bind_size, char weak);
static void set_bind_addr(data_t *d, unsigned int *idx, const char *sym_name, int seg_index, uint64_t seg_offset, int64_t addend, char weak);
static int read_chained_fixups(data_t *d, const struct mach_header *mh, const char *image_name);
#ifdef PLTHOOK_DEBUG_FIXUPS
static const char *segment_name_from_addr(data_t *d, size_t addr);
static const char *section_name_from_addr(data_t *d, size_t addr);
#endif

static int set_mem_prot(plthook_t *plthook);
static int get_mem_prot(plthook_t *plthook, void *addr);

static inline uint8_t *fileoff_to_vmaddr_in_segment(data_t *d, int segment_index, size_t offset)
{
    const struct segment_command_64 *seg = d->segments[segment_index];
    return (uint8_t *)(seg->vmaddr - seg->fileoff + d->slide + offset);
}
static uint8_t *fileoff_to_vmaddr(data_t *data, size_t offset);

static void set_errmsg(const char *fmt, ...) __attribute__((__format__ (__printf__, 1, 2)));

static uint64_t uleb128(const uint8_t **p)
{
    uint64_t r = 0;
    int s = 0;
    do {
        r |= (uint64_t)(**p & 0x7f) << s;
        s += 7;
    } while (*(*p)++ >= 0x80);
    return r;
}

static int64_t sleb128(const uint8_t** p)
{
    int64_t r = 0;
    int s = 0;
    for (;;) {
        uint8_t b = *(*p)++;
        if (b < 0x80) {
          if (b & 0x40) {
            r -= (0x80 - b) << s;
          } else {
            r |= (b & 0x3f) << s;
          }
          break;
        }
        r |= (b & 0x7f) << s;
        s += 7;
    }
    return r;
}

static char errmsg[512];

int plthook_open(plthook_t **plthook_out, const char *filename)
{
    size_t namelen;
    uint32_t cnt;
    uint32_t idx;

    if (filename == NULL) {
        return plthook_open_real(plthook_out, 0, NULL, NULL);
    }
    cnt = _dyld_image_count();
    namelen = strlen(filename);
    namelen = strlen(filename);
    cnt = _dyld_image_count();

    for (idx = 0; idx < cnt; idx++) {
        const char *image_name = _dyld_get_image_name(idx);
        size_t offset = 0;

        if (image_name == NULL) {
            *plthook_out = NULL;
            set_errmsg("Cannot find file at image index %u", idx);
            return PLTHOOK_INTERNAL_ERROR;
        }
        if (*filename != '/') {
            size_t image_name_len = strlen(image_name);
            if (image_name_len > namelen) {
              offset = image_name_len - namelen;
            }
        }
        if (strcmp(image_name + offset, filename) == 0) {
            return plthook_open_real(plthook_out, idx, NULL, image_name);
        }
    }
    *plthook_out = NULL;
    set_errmsg("Cannot find file: %s", filename);
    return PLTHOOK_FILE_NOT_FOUND;
}

int plthook_open_by_handle(plthook_t **plthook_out, void *hndl)
{
    int flags[] = {
        RTLD_LAZY | RTLD_NOLOAD,
        RTLD_LAZY | RTLD_NOLOAD | RTLD_FIRST,
    };
    int flag_idx;
    uint32_t cnt = _dyld_image_count();
#define NUM_FLAGS (sizeof(flags) / sizeof(flags[0]))

    if (hndl == NULL) {
        set_errmsg("NULL handle");
        return PLTHOOK_FILE_NOT_FOUND;
    }
    for (flag_idx = 0; flag_idx < (int)NUM_FLAGS; flag_idx++) {
        uint32_t idx;

        for (idx = 0; idx < cnt; idx++) {
            const char *image_name = idx ? _dyld_get_image_name(idx) : NULL;
            void *handle = dlopen(image_name, flags[flag_idx]);
            if (handle != NULL) {
                dlclose(handle);
                if (handle == hndl) {
                    return plthook_open_real(plthook_out, idx, NULL, image_name);
                }
            }
        }
    }
    set_errmsg("Cannot find the image correspond to handle %p", hndl);
    return PLTHOOK_FILE_NOT_FOUND;
}

int plthook_open_by_address(plthook_t **plthook_out, void *address)
{
    Dl_info dlinfo;
    uint32_t idx = 0;
    uint32_t cnt = _dyld_image_count();

    if (!dladdr(address, &dlinfo)) {
        *plthook_out = NULL;
        set_errmsg("Cannot find address: %p", address);
        return PLTHOOK_FILE_NOT_FOUND;
    }
    for (idx = 0; idx < cnt; idx++) {
        if (dlinfo.dli_fbase == _dyld_get_image_header(idx)) {
            return plthook_open_real(plthook_out, idx, dlinfo.dli_fbase, dlinfo.dli_fname);
        }
    }
    set_errmsg("Cannot find the image index for base address: %p", dlinfo.dli_fbase);
    return PLTHOOK_FILE_NOT_FOUND;
}

static int plthook_open_real(plthook_t **plthook_out, uint32_t image_idx, const struct mach_header *mh, const char *image_name)
{
    struct load_command *cmd;
    const struct dyld_info_command *dyld_info = NULL;
    unsigned int nbind;
    data_t data = {NULL,};
    size_t size;
    uint32_t i;

    data.linkedit_segment_idx = -1;
    data.slide = _dyld_get_image_vmaddr_slide(image_idx);
    if (mh == NULL) {
        mh = _dyld_get_image_header(image_idx);
    }
    if (image_name == NULL) {
        image_name = _dyld_get_image_name(image_idx);
    }
#if defined(PLTHOOK_DEBUG_CMD) || defined(PLTHOOK_DEBUG_ADDR)
    fprintf(stderr, "mh=%"PRIxPTR" slide=%"PRIxPTR"\n", (uintptr_t)mh, data.slide);
#endif
#ifdef PLTHOOK_DEBUG_ADDR
    dump_maps(image_name);
#endif

    cmd = (struct load_command *)((size_t)mh + sizeof(struct mach_header_64));
    DEBUG_CMD("CMD START\n");
    for (i = 0; i < mh->ncmds; i++) {
#ifdef PLTHOOK_DEBUG_CMD
        struct segment_command *segment;
#endif
        struct segment_command_64 *segment64;

        switch (cmd->cmd) {
        case LC_SEGMENT: /* 0x1 */
#ifdef PLTHOOK_DEBUG_CMD
            segment = (struct segment_command *)cmd;
#endif
            DEBUG_CMD("LC_SEGMENT\n"
                      "  segname   %s\n"
                      "  vmaddr    %8x  vmsize     %8x\n"
                      "  fileoff   %8x  filesize   %8x\n"
                      "  maxprot   %8x  initprot   %8x\n"
                      "  nsects    %8d  flags      %8x\n",
                      segment->segname,
                      segment->vmaddr, segment->vmsize,
                      segment->fileoff, segment->filesize,
                      segment->maxprot, segment->initprot,
                      segment->nsects, segment->flags);
            break;
        case LC_SEGMENT_64: /* 0x19 */
            segment64 = (struct segment_command_64 *)cmd;
            DEBUG_CMD("LC_SEGMENT_64\n"
                      "  segname   %s\n"
                      "  vmaddr    %8llx  vmsize     %8llx\n"
                      "  fileoff   %8llx  filesize   %8llx\n"
                      "  maxprot   %8x  initprot   %8x\n"
                      "  nsects    %8d  flags      %8x\n",
                      segment64->segname,
                      segment64->vmaddr, segment64->vmsize,
                      segment64->fileoff, segment64->filesize,
                      segment64->maxprot, segment64->initprot,
                      segment64->nsects, segment64->flags);
            if (strcmp(segment64->segname, "__LINKEDIT") == 0) {
                data.linkedit_segment_idx = data.num_segments;
            }
#ifdef PLTHOOK_DEBUG_FIXUPS
            struct section_64 *sec = (struct section_64 *)(segment64 + 1);
            uint32_t i;
            for (i = 0; i < segment64->nsects; i++) {
                DEBUG_CMD("  section_64 (%u)\n"
                          "      sectname  %s\n"
                          "      segname   %s\n"
                          "      addr      0x%llx\n"
                          "      size      0x%llx\n"
                          "      offset    0x%x\n"
                          "      align     0x%x\n"
                          "      reloff    0x%x\n"
                          "      nreloc    %d\n"
                          "      flags     0x%x\n"
                          "      reserved1 %d\n"
                          "      reserved2 %d\n"
                          "      reserved3 %d\n",
                          i,
                          sec->sectname,
                          sec->segname,
                          sec->addr,
                          sec->size,
                          sec->offset,
                          sec->align,
                          sec->reloff,
                          sec->nreloc,
                          sec->flags,
                          sec->reserved1,
                          sec->reserved2,
                          sec->reserved3);
                sec++;
            }
#endif
            if (data.num_segments == MAX_SEGMENTS) {
                set_errmsg("Too many segments: %s", image_name);
                return PLTHOOK_INTERNAL_ERROR;
            }
            data.segments[data.num_segments++] = segment64;
#ifdef PLTHOOK_DEBUG_FIXUPS
            {
                struct section_64 *sec = (struct section_64 *)(segment64 + 1);
                struct section_64 *sec_end = sec + segment64->nsects;
                while (sec < sec_end) {
                    if (data.num_sections == MAX_SECTIONS) {
                        set_errmsg("Too many sections: %s", image_name);
                        return PLTHOOK_INTERNAL_ERROR;
                    }
                    data.sections[data.num_sections++] = sec;
                    sec++;
                }
            }
#endif
            break;
        case LC_DYLD_INFO_ONLY: /* (0x22|LC_REQ_DYLD) */
            dyld_info= (struct dyld_info_command *)cmd;
            DEBUG_CMD("LC_DYLD_INFO_ONLY\n"
                      "                 offset     size\n"
                      "  rebase       %8x %8x\n"
                      "  bind         %8x %8x\n"
                      "  weak_bind    %8x %8x\n"
                      "  lazy_bind    %8x %8x\n"
                      "  export_bind  %8x %8x\n",
                      dyld_info->rebase_off, dyld_info->rebase_size,
                      dyld_info->bind_off, dyld_info->bind_size,
                      dyld_info->weak_bind_off, dyld_info->weak_bind_size,
                      dyld_info->lazy_bind_off, dyld_info->lazy_bind_size,
                      dyld_info->export_off, dyld_info->export_size);
            break;
        case LC_SYMTAB: /* 0x2 */
            DEBUG_CMD("LC_SYMTAB\n");
            break;
        case LC_DYSYMTAB: /* 0xb */
            DEBUG_CMD("LC_DYSYMTAB\n");
            break;
        case LC_LOAD_DYLIB: /* 0xc */
            DEBUG_CMD("LC_LOAD_DYLIB\n");
            break;
        case LC_ID_DYLIB: /* 0xd */
            DEBUG_CMD("LC_ID_DYLIB\n");
            break;
        case LC_LOAD_DYLINKER: /* 0xe */
            DEBUG_CMD("LC_LOAD_DYLINKER\n");
            break;
        case LC_ROUTINES_64: /* 0x1a */
            DEBUG_CMD("LC_ROUTINES_64\n");
            break;
        case LC_UUID: /* 0x1b */
            DEBUG_CMD("LC_UUID\n");
            break;
        case LC_RPATH: /* (0x1c|LC_REQ_DYLD) */
            DEBUG_CMD("LC_RPATH\n");
            break;
        case LC_CODE_SIGNATURE: /* 0x1d */
            DEBUG_CMD("LC_CODE_SIGNATURE\n");
            break;
        case LC_VERSION_MIN_MACOSX: /* 0x24 */
            DEBUG_CMD("LC_VERSION_MIN_MACOSX\n");
            break;
        case LC_FUNCTION_STARTS: /* 0x26 */
            DEBUG_CMD("LC_FUNCTION_STARTS\n");
            break;
        case LC_MAIN: /* 0x28|LC_REQ_DYLD */
            DEBUG_CMD("LC_MAIN\n");
            break;
        case LC_DATA_IN_CODE: /* 0x29 */
            DEBUG_CMD("LC_DATA_IN_CODE\n");
            break;
        case LC_SOURCE_VERSION: /* 0x2A */
            DEBUG_CMD("LC_SOURCE_VERSION\n");
            break;
        case LC_DYLIB_CODE_SIGN_DRS: /* 0x2B */
            DEBUG_CMD("LC_DYLIB_CODE_SIGN_DRS\n");
            break;
        case LC_BUILD_VERSION: /* 0x32 */
            DEBUG_CMD("LC_BUILD_VERSION\n");
            break;
        case LC_DYLD_EXPORTS_TRIE: /* (0x33|LC_REQ_DYLD) */
            DEBUG_CMD("LC_DYLD_EXPORTS_TRIE\n");
            break;
        case LC_DYLD_CHAINED_FIXUPS: /* (0x34|LC_REQ_DYLD) */
            data.chained_fixups = (struct linkedit_data_command *)cmd;
            DEBUG_CMD("LC_DYLD_CHAINED_FIXUPS\n"
                      "  cmdsize   %u\n"
                      "  dataoff   %u (0x%x)\n"
                      "  datasize  %u\n",
                      data.chained_fixups->cmdsize,
                      data.chained_fixups->dataoff,
                      data.chained_fixups->dataoff,
                      data.chained_fixups->datasize);
            break;
        default:
            DEBUG_CMD("LC_? (0x%x)\n", cmd->cmd);
        }
        cmd = (struct load_command *)((size_t)cmd + cmd->cmdsize);
    }
    DEBUG_CMD("CMD END\n");
    if (data.linkedit_segment_idx == -1) {
        set_errmsg("Cannot find the linkedit segment: %s", image_name);
        return PLTHOOK_INVALID_FILE_FORMAT;
    }
    if (data.chained_fixups != NULL) {
        int rv = read_chained_fixups(&data, mh, image_name);
        if (rv != 0) {
            return rv;
        }
    } else {
        nbind = 0;
        nbind = set_bind_addrs(&data, nbind, dyld_info->bind_off, dyld_info->bind_size, 0);
        nbind = set_bind_addrs(&data, nbind, dyld_info->weak_bind_off, dyld_info->weak_bind_size, 1);
        nbind = set_bind_addrs(&data, nbind, dyld_info->lazy_bind_off, dyld_info->lazy_bind_size, 0);
        size = offsetof(plthook_t, entries) + sizeof(bind_address_t) * nbind;
        data.plthook = (plthook_t*)calloc(1, size);
        if (data.plthook == NULL) {
            set_errmsg("failed to allocate memory: %" PRIuPTR " bytes", size);
            return PLTHOOK_OUT_OF_MEMORY;
        }
        data.plthook->num_entries = nbind;
        nbind = 0;
        nbind = set_bind_addrs(&data, nbind, dyld_info->bind_off, dyld_info->bind_size, 0);
        nbind = set_bind_addrs(&data, nbind, dyld_info->weak_bind_off, dyld_info->weak_bind_size, 1);
        nbind = set_bind_addrs(&data, nbind, dyld_info->lazy_bind_off, dyld_info->lazy_bind_size, 0);
    }
    set_mem_prot(data.plthook);

    *plthook_out = data.plthook;
    return 0;
}

static unsigned int set_bind_addrs(data_t *data, unsigned int idx, uint32_t bind_off, uint32_t bind_size, char weak)
{
    const uint8_t *ptr = fileoff_to_vmaddr_in_segment(data, data->linkedit_segment_idx, bind_off);
    const uint8_t *end = ptr + bind_size;
    const char *sym_name;
    int seg_index = 0;
    uint64_t seg_offset = 0;
    int64_t addend = 0;
    uint64_t count, skip;
#ifdef PLTHOOK_DEBUG_BIND
    int cond = data->plthook != NULL;
#endif

    while (ptr < end) {
        uint8_t op = *ptr & BIND_OPCODE_MASK;
        uint8_t imm = *ptr & BIND_IMMEDIATE_MASK;
        uint64_t i;

        DEBUG_BIND_IF(cond, "0x%02x: ", *ptr);
        ptr++;
        switch (op) {
        case BIND_OPCODE_DONE:
            DEBUG_BIND_IF(cond, "BIND_OPCODE_DONE\n");
            break;
        case BIND_OPCODE_SET_DYLIB_ORDINAL_IMM:
            DEBUG_BIND_IF(cond, "BIND_OPCODE_SET_DYLIB_ORDINAL_IMM: ordinal = %u\n", imm);
            break;
        case BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB:
#ifdef PLTHOOK_DEBUG_BIND
            DEBUG_BIND_IF(cond, "BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB: ordinal = %llu\n", uleb128(&ptr));
#else
            uleb128(&ptr);
#endif
            break;
        case BIND_OPCODE_SET_DYLIB_SPECIAL_IMM:
            if (imm == 0) {
                DEBUG_BIND_IF(cond, "BIND_OPCODE_SET_DYLIB_SPECIAL_IMM: ordinal = 0\n");
            } else {
                DEBUG_BIND_IF(cond, "BIND_OPCODE_SET_DYLIB_SPECIAL_IMM: ordinal = %u\n", BIND_OPCODE_MASK | imm);
            }
            break;
        case BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM:
            sym_name = (const char*)ptr;
            ptr += strlen(sym_name) + 1;
            DEBUG_BIND_IF(cond, "BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM: sym_name = %s\n", sym_name);
            break;
        case BIND_OPCODE_SET_TYPE_IMM:
            DEBUG_BIND_IF(cond, "BIND_OPCODE_SET_TYPE_IMM: type = %u\n", imm);
            break;
        case BIND_OPCODE_SET_ADDEND_SLEB:
            addend = sleb128(&ptr);
            DEBUG_BIND_IF(cond, "BIND_OPCODE_SET_ADDEND_SLEB: ordinal = %lld\n", addend);
            break;
        case BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB:
            seg_index = imm;
            seg_offset = uleb128(&ptr);
            DEBUG_BIND_IF(cond, "BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB: seg_index = %u, seg_offset = 0x%llx\n", seg_index, seg_offset);
            break;
        case BIND_OPCODE_ADD_ADDR_ULEB:
            seg_offset += uleb128(&ptr);
            DEBUG_BIND_IF(cond, "BIND_OPCODE_ADD_ADDR_ULEB: seg_offset = 0x%llx\n", seg_offset);
            break;
        case BIND_OPCODE_DO_BIND:
            set_bind_addr(data, &idx, sym_name, seg_index, seg_offset, addend, weak);
            seg_offset += sizeof(void*);
            DEBUG_BIND_IF(cond, "BIND_OPCODE_DO_BIND\n");
            break;
        case BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB:
            set_bind_addr(data, &idx, sym_name, seg_index, seg_offset, addend, weak);
            seg_offset += uleb128(&ptr) + sizeof(void*);
            DEBUG_BIND_IF(cond, "BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB: seg_offset = 0x%llx\n", seg_offset);
            break;
        case BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED:
            set_bind_addr(data, &idx, sym_name, seg_index, seg_offset, addend, weak);
            seg_offset += imm * sizeof(void *) + sizeof(void*);
            DEBUG_BIND_IF(cond, "BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED\n");
            break;
        case BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB:
            count = uleb128(&ptr);
            skip = uleb128(&ptr);
            for (i = 0; i < count; i++) {
                set_bind_addr(data, &idx, sym_name, seg_index, seg_offset, addend, weak);
                seg_offset += skip + sizeof(void*);
            }
            DEBUG_BIND_IF(cond, "BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB\n");
            break;
        default:
            DEBUG_BIND_IF(cond, "op: 0x%x, imm: 0x%x\n", op, imm);
        }
    }
    return idx;
}

static void set_bind_addr(data_t *data, unsigned int *idx, const char *sym_name, int seg_index, uint64_t seg_offset, int64_t addend, char weak)
{
    if (data->plthook != NULL) {
        size_t vmaddr = data->segments[seg_index]->vmaddr;
        bind_address_t *bind_addr = &data->plthook->entries[*idx];
        bind_addr->name = sym_name;
        bind_addr->addend = (int)addend;
        bind_addr->weak = weak;
        bind_addr->addr = (void**)(vmaddr + data->slide + seg_offset);
        DEBUG_BIND("bind_address[%u]: %s, %d, %lu, %p, %p, %p\n", *idx, sym_name, seg_index, seg_offset, (void*)vmaddr, (void*)data->slide, bind_addr->addr);
    }
    (*idx)++;
}

typedef struct {
    const char *image_name;
    FILE *fp;
    const struct dyld_chained_starts_in_image *starts;
    uint32_t seg_index; // i
    uint16_t page_index; // j
    off_t offset;
} chained_fixups_iter_t;

typedef struct {
    uint16_t    ptr_format;
    union {
        uint64_t raw;
        struct dyld_chained_ptr_64_rebase rebase;
        struct dyld_chained_ptr_64_bind bind;
        struct dyld_chained_ptr_arm64e_rebase arm64e_rebase;
        struct dyld_chained_ptr_arm64e_bind arm64e_bind;
        struct dyld_chained_ptr_arm64e_bind24 arm64e_bind24;
        struct dyld_chained_ptr_arm64e_auth_rebase arm64e_auth_rebase;
        struct dyld_chained_ptr_arm64e_auth_bind arm64e_auth_bind;
        struct dyld_chained_ptr_arm64e_auth_bind24 arm64e_auth_bind24;
    } ptr;
    off_t offset;
} chianed_fixups_entry_t;

static int chained_fixups_iter_init(chained_fixups_iter_t *iter, const char *image_name, const struct dyld_chained_starts_in_image *starts_offset);
static void chained_fixups_iter_deinit(chained_fixups_iter_t *iter);
static int chained_fixups_iter_rewind(chained_fixups_iter_t *iter);
static int chained_fixups_iter_next(chained_fixups_iter_t *iter, chianed_fixups_entry_t *entry);

static int chained_fixups_iter_init(chained_fixups_iter_t *iter, const char *image_name, const struct dyld_chained_starts_in_image *starts)
{
    memset(iter, 0, sizeof(*iter));
    iter->fp = fopen(image_name, "r");
    if (iter->fp == NULL) {
        set_errmsg("failed to open file %s (error: %s)", image_name, strerror(errno));
        return PLTHOOK_FILE_NOT_FOUND;
    }
    iter->image_name = image_name;
    iter->starts = starts;
    return 0;
}

static void chained_fixups_iter_deinit(chained_fixups_iter_t *iter)
{
    if (iter->fp != NULL) {
        fclose(iter->fp);
        iter->fp = NULL;
    }
}

static int chained_fixups_iter_rewind(chained_fixups_iter_t *iter)
{
    iter->seg_index = 0;
    iter->page_index = 0;
    iter->offset = 0;
    return 0;
}

static int chained_fixups_iter_next(chained_fixups_iter_t *iter, chianed_fixups_entry_t *entry)
{
    const struct dyld_chained_starts_in_image *starts = iter->starts;
    uint32_t i = iter->seg_index;
    uint16_t j = iter->page_index;
    off_t offset = iter->offset;

next_segment:
    if (i == starts->seg_count) {
        return -1;
    }
    if (j == 0 && offset == 0) {
        DEBUG_FIXUPS("  seg_info_offset[%u] %u\n",
                     i, starts->seg_info_offset[i]);
    }
    if (starts->seg_info_offset[i] == 0) {
        i++;
        j = 0;
        offset = 0;
        goto next_segment;
    }
    const struct dyld_chained_starts_in_segment* seg = (const struct dyld_chained_starts_in_segment*)((char*)starts + starts->seg_info_offset[i]);
    if (j == 0 && offset == 0) {
        DEBUG_FIXUPS("    dyld_chained_starts_in_segment\n"
                     "      size              %u\n"
                     "      page_size         0x%x\n"
                     "      pointer_format    %u\n"
                     "      segment_offset    %llu (0x%llx)\n"
                     "      max_valid_pointer %u\n"
                     "      page_count        %u\n",
                     seg->size, seg->page_size, seg->pointer_format, seg->segment_offset, seg->segment_offset, seg->max_valid_pointer, seg->page_count);
    }
next_page:
    if (j == seg->page_count) {
        i++;
        j = 0;
        offset = 0;
        goto next_segment;
    }

    if (seg->page_start[j] == DYLD_CHAINED_PTR_START_NONE) {
        DEBUG_FIXUPS("      page_start[%u]     DYLD_CHAINED_PTR_START_NONE\n", j);
        j++;
        offset = 0;
        goto next_page;
    }
    if (offset == 0) {
        DEBUG_FIXUPS("      page_start[%u]     %u\n", j, seg->page_start[j]);
    }
    if (offset == 0) {
        offset = seg->segment_offset + j * seg->page_size + seg->page_start[j];
    }
    if (fseeko(iter->fp, offset, SEEK_SET) != 0) {
        set_errmsg("failed to seek to %lld in %s", offset, iter->image_name);
        return PLTHOOK_INVALID_FILE_FORMAT;
    }
    entry->ptr_format = seg->pointer_format;
    if (fread(&entry->ptr, sizeof(entry->ptr), 1, iter->fp) != 1) {
        set_errmsg("failed to read fixup chain from %s", iter->image_name);
        return PLTHOOK_INVALID_FILE_FORMAT;
    }
    entry->offset = offset;
    switch (seg->pointer_format) {
    case DYLD_CHAINED_PTR_64_OFFSET:
        if (entry->ptr.bind.next) {
            offset += entry->ptr.bind.next * 4;
        } else {
            j++;
            offset = 0;
        }
        break;
    default:
        set_errmsg("unsupported pointer format %u in %s", seg->pointer_format, iter->image_name);
        return PLTHOOK_INTERNAL_ERROR;
    }
    iter->seg_index = i;
    iter->page_index = j;
    iter->offset = offset;
    return 0;
}

static int read_chained_fixups(data_t *d, const struct mach_header *mh, const char *image_name)
{
    const uint8_t *ptr = fileoff_to_vmaddr_in_segment(d, d->linkedit_segment_idx, d->chained_fixups->dataoff);
    const struct dyld_chained_fixups_header *header = (const struct dyld_chained_fixups_header *)ptr;
    const char *symbol_pool = (const char*)ptr + header->symbols_offset;
    int rv;
    unsigned int num_binds;
    size_t size;
    const struct dyld_chained_starts_in_image *starts = (const struct dyld_chained_starts_in_image *)(ptr + header->starts_offset);
    const struct dyld_chained_import *import = (const struct dyld_chained_import *)(ptr + header->imports_offset);
    chained_fixups_iter_t iter = {NULL, };
    chianed_fixups_entry_t entry;

    rv = chained_fixups_iter_init(&iter, image_name, starts);
    if (rv != 0) {
        return rv;
    }

    DEBUG_FIXUPS("dyld_chained_fixups_header\n"
                 "  fixups_version  %u\n"
                 "  starts_offset   %u\n"
                 "  imports_offset  %u\n"
                 "  symbols_offset  %u\n"
                 "  imports_count   %u\n"
                 "  imports_format  %u\n"
                 "  symbols_format  %u\n",
                 header->fixups_version,
                 header->starts_offset,
                 header->imports_offset,
                 header->symbols_offset,
                 header->imports_count,
                 header->imports_format,
                 header->symbols_format);
    if (header->fixups_version != 0) {
        set_errmsg("unknown chained fixups version %u", header->fixups_version);
        rv = PLTHOOK_INVALID_FILE_FORMAT;
        goto cleanup;
    }

    DEBUG_FIXUPS("dyld_chained_starts_in_image\n"
                 "  seg_count       %u\n",
                 starts->seg_count);
    num_binds = 0;
    while ((rv = chained_fixups_iter_next(&iter, &entry)) == 0) {
        if (entry.ptr_format == DYLD_CHAINED_PTR_64_OFFSET && entry.ptr.bind.bind) {
            num_binds++;
        }
#if 0
        if (entry.ptr.rebase.bind) {
            DEBUG_FIXUPS("  0x%08lX:  raw: 0x%016lX         bind: (next: %03u, ordinal: %06X, addend: %d)\n",
                         entry.offset, entry.ptr.raw, entry.ptr.bind.next, entry.ptr.bind.ordinal, entry.ptr.bind.addend);
        } else {
            DEBUG_FIXUPS("  0x%08lX:  raw: 0x%016lX       rebase: (next: %03u, target: 0x%011lX, high8: 0x%02X)\n",
                         entry.offset, entry.ptr.raw, entry.ptr.rebase.next, entry.ptr.rebase.target, entry.ptr.rebase.high8);
        }
#endif
    }
    if (rv > 0) {
        goto cleanup;
    }

    size = offsetof(plthook_t, entries) + sizeof(bind_address_t) * num_binds;
    d->plthook = (plthook_t*)calloc(1, size);
    if (d->plthook == NULL) {
        set_errmsg("failed to allocate memory: %" PRIuPTR " bytes", size);
        rv = PLTHOOK_OUT_OF_MEMORY;
        goto cleanup;
    }
    d->plthook->num_entries = num_binds;

    chained_fixups_iter_rewind(&iter);
    num_binds = 0;
    while ((rv = chained_fixups_iter_next(&iter, &entry)) == 0) {
        if (entry.ptr_format == DYLD_CHAINED_PTR_64_OFFSET && entry.ptr.bind.bind) {
            uint16_t ordinal = entry.ptr.bind.ordinal;
            uint32_t name_offset;
            char weak = 0;
            bind_address_t *bind_addr = &d->plthook->entries[num_binds];
#ifdef PLTHOOK_DEBUG_FIXUPS
            int32_t lib_ordinal;
            const char *libname;
#endif
            switch (header->imports_format) {
            case DYLD_CHAINED_IMPORT:
                name_offset = import[ordinal].name_offset;
                weak = import[ordinal].weak_import;
#ifdef PLTHOOK_DEBUG_FIXUPS
                if (import[ordinal].lib_ordinal >= (uint8_t)BIND_SPECIAL_DYLIB_WEAK_LOOKUP) {
                    lib_ordinal = (int8_t)import[ordinal].lib_ordinal;
                } else {
                    lib_ordinal = (uint8_t)import[ordinal].lib_ordinal;
                }
#endif
                break;
            default:
                DEBUG_FIXUPS("imports_format: %u\n", header->imports_format);
                set_errmsg("unsupported imports format %u", header->imports_format);
                rv = PLTHOOK_INTERNAL_ERROR;
                goto cleanup;
            }
            bind_addr->name = symbol_pool + name_offset;
            bind_addr->addr = (void**)fileoff_to_vmaddr(d,  entry.offset);
            bind_addr->addend = entry.ptr.bind.addend;
            bind_addr->weak = weak;
#ifdef PLTHOOK_DEBUG_FIXUPS
            switch (lib_ordinal) {
            case BIND_SPECIAL_DYLIB_SELF:
                libname = "this-image";
                break;
            case BIND_SPECIAL_DYLIB_MAIN_EXECUTABLE:
                libname = "main-executable";
                break;
            case BIND_SPECIAL_DYLIB_FLAT_LOOKUP:
                libname = "flat-namespace";
                break;
            case BIND_SPECIAL_DYLIB_WEAK_LOOKUP:
                libname = "weak";
                break;
            default:
                libname = "?";
            }
#endif
            DEBUG_FIXUPS("        %-12s %-16s 0x%08llX              bind  %s/%s",
                         segment_name_from_addr(d, entry.offset), section_name_from_addr(d, entry.offset), entry.offset, libname, symbol_pool + name_offset);
            if (entry.ptr.bind.addend != 0) {
                DEBUG_FIXUPS(" + 0x%X", entry.ptr.bind.addend);
            }
            if (weak) {
                DEBUG_FIXUPS(" [weak-import]");
            }
            DEBUG_FIXUPS("\n");
            num_binds++;
        } else if (entry.ptr_format == DYLD_CHAINED_PTR_64_OFFSET && !entry.ptr.bind.bind) {
            DEBUG_FIXUPS("        %-12s %-16s 0x%08llX            rebase  0x%08llX\n",
                         segment_name_from_addr(d, entry.offset), section_name_from_addr(d, entry.offset), entry.offset, entry.ptr.rebase.target);
        }
    }
    chained_fixups_iter_deinit(&iter);
    rv = 0;
cleanup:
    chained_fixups_iter_deinit(&iter);
    if (rv != 0 && d->plthook) {
        free(d->plthook);
        d->plthook = NULL;
    }
    return rv;
}

#ifdef PLTHOOK_DEBUG_FIXUPS
static const char *segment_name_from_addr(data_t *d, size_t addr)
{
    int i;
    for (i = 0; i < d->num_segments; i++) {
        const struct segment_command_64 *seg = d->segments[i];
        if (seg->fileoff <= addr && addr < seg->fileoff + seg->filesize) {
            return seg->segname;
        }
    }
    return "?";
}

static const char *section_name_from_addr(data_t *d, size_t addr)
{
    int i;
    for (i = 0; i < d->num_sections; i++) {
        const struct section_64 *sec = d->sections[i];
        if (sec->offset <= addr && addr < sec->offset + sec->size) {
            return sec->sectname;
        }
    }
    return "?";
}
#endif

static int set_mem_prot(plthook_t *plthook)
{
    unsigned int pos = 0;
    const char *name;
    void **addr;
    size_t start = (size_t)-1;
    size_t end = 0;
    mach_port_t task = mach_task_self();
    vm_address_t vm_addr = 0;
    vm_size_t vm_size;
    vm_region_basic_info_data_64_t info;
    mach_msg_type_number_t info_count = VM_REGION_BASIC_INFO_COUNT_64;
    memory_object_name_t object = 0;
    int idx = 0;

    while (plthook_enum(plthook, &pos, &name, &addr) == 0) {
        if (start > (size_t)addr) {
            start = (size_t)addr;
        }
        if (end < (size_t)addr) {
            end = (size_t)addr;
        }
    }
    end++;

    while (vm_region_64(task, &vm_addr, &vm_size, VM_REGION_BASIC_INFO_64, (vm_region_info_t)&info, &info_count, &object) == KERN_SUCCESS) {
        mem_prot_t mem_prot = {vm_addr, vm_addr + vm_size, info.protection & (PROT_READ | PROT_WRITE | PROT_EXEC)};
        if (mem_prot.prot != 0 && mem_prot.start < end && start < mem_prot.end) {
            plthook->mem_prot[idx++] = mem_prot;
            if (idx == NUM_MEM_PROT) {
                break;
            }
        }
        vm_addr += vm_size;
    }
    return 0;
}

static int get_mem_prot(plthook_t *plthook, void *addr)
{
    mem_prot_t *ptr = plthook->mem_prot;
    mem_prot_t *end = ptr + NUM_MEM_PROT;

    while (ptr < end && ptr->prot != 0) {
        if (ptr->start <= (size_t)addr && (size_t)addr < ptr->end) {
            return ptr->prot;
        }
        ++ptr;
    }
    return 0;
}

static uint8_t *fileoff_to_vmaddr(data_t *d, size_t offset)
{
    int i;
    for (i = 0; i < d->num_segments; i++) {
        const struct segment_command_64 *seg = d->segments[i];
        if (seg->fileoff <= offset && offset < seg->fileoff + seg->filesize) {
            return fileoff_to_vmaddr_in_segment(d, i, offset);
        }
    }
    return NULL;
}

int plthook_enum(plthook_t *plthook, unsigned int *pos, const char **name_out, void ***addr_out)
{
    plthook_entry_t entry;
    int rv = plthook_enum_entry(plthook, pos, &entry);
    if (rv == 0) {
        *name_out = entry.name;
        *addr_out = entry.addr;
    }
    return rv;
}

int plthook_enum_with_prot(plthook_t *plthook, unsigned int *pos, const char **name_out, void ***addr_out, int *prot)
{
    plthook_entry_t entry;
    int rv = plthook_enum_entry(plthook, pos, &entry);
    if (rv == 0) {
        *name_out = entry.name;
        *addr_out = entry.addr;
        if (prot) {
            *prot = entry.prot;
        }
    }
    return rv;
}

int plthook_enum_entry(plthook_t *plthook, unsigned int *pos, plthook_entry_t *entry)
{
    memset(entry, 0, sizeof(*entry));
    while (*pos < plthook->num_entries) {
        if (strcmp(plthook->entries[*pos].name, "__tlv_bootstrap") == 0) {
            (*pos)++;
            continue;
        }
        entry->name = plthook->entries[*pos].name;
        entry->addr = plthook->entries[*pos].addr;
        entry->addend = plthook->entries[*pos].addend;
        entry->prot = get_mem_prot(plthook, entry->addr);
        entry->weak = plthook->entries[*pos].weak;
        (*pos)++;
        return 0;
    }
    return EOF;
}

int plthook_replace(plthook_t *plthook, const char *funcname, void *funcaddr, void **oldfunc)
{
    size_t funcnamelen = strlen(funcname);
    unsigned int pos = 0;
    plthook_entry_t entry;
    int rv;

    if (plthook == NULL) {
        set_errmsg("invalid argument: The first argument is null.");
        return PLTHOOK_INVALID_ARGUMENT;
    }
    while ((rv = plthook_enum_entry(plthook, &pos, &entry)) == 0) {
        const char *name = entry.name;
        void **addr = entry.addr;
        if (strncmp(name, funcname, funcnamelen) == 0) {
            if (name[funcnamelen] == '\0' || name[funcnamelen] == '$') {
                goto matched;
            }
        }
        if (name[0] == '@') {
            /* I doubt this code... */
            name++;
            if (strncmp(name, funcname, funcnamelen) == 0) {
                if (name[funcnamelen] == '\0' || name[funcnamelen] == '$') {
                    goto matched;
                }
            }
        }
        if (name[0] == '_') {
            name++;
            if (strncmp(name, funcname, funcnamelen) == 0) {
                if (name[funcnamelen] == '\0' || name[funcnamelen] == '$') {
                    goto matched;
                }
            }
        }
        continue;
matched:
        if (oldfunc) {
            *oldfunc = *addr;
        }
        if (!(entry.prot & PROT_WRITE)) {
            size_t page_size = sysconf(_SC_PAGESIZE);
            void *base = (void*)((size_t)addr & ~(page_size - 1));
            if (mprotect(base, page_size, PROT_READ | PROT_WRITE) != 0) {
                set_errmsg("Cannot change memory protection at address %p", base);
                return PLTHOOK_INTERNAL_ERROR;
            }
            *addr = funcaddr;
            mprotect(base, page_size, entry.prot);
        } else {
            *addr = funcaddr;
        }
        return 0;
    }
    if (rv == EOF) {
        set_errmsg("no such function: %s", funcname);
        rv = PLTHOOK_FUNCTION_NOT_FOUND;
    }
    return rv;
}

void plthook_close(plthook_t *plthook)
{
    if (plthook != NULL) {
        free(plthook);
    }
    return;
}

const char *plthook_error(void)
{
    return errmsg;
}

static void set_errmsg(const char *fmt, ...)
{
    va_list ap;
    va_start(ap, fmt);
    vsnprintf(errmsg, sizeof(errmsg) - 1, fmt, ap);
    va_end(ap);
}

```

`plthook_win32.c`:

```c
/* -*- indent-tabs-mode: nil -*-
 *
 * plthook_win32.c -- implementation of plthook for PE format
 *
 * URL: https://github.com/kubo/plthook
 *
 * ------------------------------------------------------
 *
 * Copyright 2013-2014 Kubo Takehiro <kubo@jiubao.org>
 *
 * Redistribution and use in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 *
 *    1. Redistributions of source code must retain the above copyright notice, this list of
 *       conditions and the following disclaimer.
 *
 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
 *       of conditions and the following disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ''AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation are those of the
 * authors and should not be interpreted as representing official policies, either expressed
 * or implied, of the authors.
 *
 */
#include <stdio.h>
#include <stddef.h>
#include <stdarg.h>
#include <windows.h>
#include <dbghelp.h>
#include "plthook.h"

#ifdef _MSC_VER
#pragma comment(lib, "dbghelp.lib")
#endif

#ifndef _Printf_format_string_
#define _Printf_format_string_
#endif
#ifndef __GNUC__
#define __attribute__(arg)
#endif

#if defined _LP64 /* data model: I32/LP64 */
#define SIZE_T_FMT "lu"
#elif defined _WIN64  /* data model: IL32/P64 */
#define SIZE_T_FMT "I64u"
#else
#define SIZE_T_FMT "u"
#endif

#ifdef __CYGWIN__
#define stricmp strcasecmp
#endif

typedef struct {
    const char *mod_name;
    const char *name;
    void **addr;
} import_address_entry_t;

struct plthook {
    HMODULE hMod;
    unsigned int num_entries;
    import_address_entry_t entries[1];
};

static char errbuf[512];
static int plthook_open_real(plthook_t **plthook_out, HMODULE hMod);
static void set_errmsg(_Printf_format_string_ const char *fmt, ...) __attribute__((__format__ (__printf__, 1, 2)));
static void set_errmsg2(_Printf_format_string_ const char *fmt, ...) __attribute__((__format__ (__printf__, 1, 2)));
static const char *winsock2_ordinal2name(int ordinal);

int plthook_open(plthook_t **plthook_out, const char *filename)
{
    HMODULE hMod;

    *plthook_out = NULL;
    if (!GetModuleHandleExA(GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, filename, &hMod)) {
        set_errmsg2("Cannot get module %s: ", filename);
        return PLTHOOK_FILE_NOT_FOUND;
    }
    return plthook_open_real(plthook_out, hMod);
}

int plthook_open_by_handle(plthook_t **plthook_out, void *hndl)
{
    if (hndl == NULL) {
        set_errmsg("NULL handle");
        return PLTHOOK_FILE_NOT_FOUND;
    }
    return plthook_open_real(plthook_out, (HMODULE)hndl);
}

int plthook_open_by_address(plthook_t **plthook_out, void *address)
{
    HMODULE hMod;

    *plthook_out = NULL;
    if (!GetModuleHandleExA(GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT | GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS, address, &hMod)) {
        set_errmsg2("Cannot get module at address %p: ", address);
        return PLTHOOK_FILE_NOT_FOUND;
    }
    return plthook_open_real(plthook_out, hMod);
}

static int plthook_open_real(plthook_t **plthook_out, HMODULE hMod)
{
    plthook_t *plthook;
    ULONG ulSize;
    IMAGE_IMPORT_DESCRIPTOR *desc_head, *desc;
    size_t num_entries = 0;
    size_t ordinal_name_buflen = 0;
    size_t idx;
    char *ordinal_name_buf;

    desc_head = (IMAGE_IMPORT_DESCRIPTOR*)ImageDirectoryEntryToData(hMod, TRUE, IMAGE_DIRECTORY_ENTRY_IMPORT, &ulSize);
    if (desc_head == NULL) {
        set_errmsg2("ImageDirectoryEntryToData error: ");
        return PLTHOOK_INTERNAL_ERROR;
    }

    /* Calculate size to allocate memory.  */
    for (desc = desc_head; desc->Name != 0; desc++) {
        IMAGE_THUNK_DATA *name_thunk = (IMAGE_THUNK_DATA*)((char*)hMod + desc->OriginalFirstThunk);
        IMAGE_THUNK_DATA *addr_thunk = (IMAGE_THUNK_DATA*)((char*)hMod + desc->FirstThunk);
        const char *module_name = (char *)hMod + desc->Name;
        int is_winsock2_dll = (stricmp(module_name, "WS2_32.DLL") == 0);

        while (addr_thunk->u1.Function != 0) {
            if (IMAGE_SNAP_BY_ORDINAL(name_thunk->u1.Ordinal)) {
                int ordinal = IMAGE_ORDINAL(name_thunk->u1.Ordinal);
                const char *name = NULL;
                if (is_winsock2_dll) {
                    name = winsock2_ordinal2name(ordinal);
                }
                if (name == NULL) {
#ifdef __CYGWIN__
                    ordinal_name_buflen += snprintf(NULL, 0, "%s:@%d", module_name, ordinal) + 1;
#else
                    ordinal_name_buflen += _scprintf("%s:@%d", module_name, ordinal) + 1;
#endif
                }
            }
            num_entries++;
            name_thunk++;
            addr_thunk++;
        }
    }

    plthook = calloc(1, offsetof(plthook_t, entries) + sizeof(import_address_entry_t) * num_entries + ordinal_name_buflen);
    if (plthook == NULL) {
        set_errmsg("failed to allocate memory: %" SIZE_T_FMT " bytes", sizeof(plthook_t));
        return PLTHOOK_OUT_OF_MEMORY;
    }
    plthook->hMod = hMod;
    plthook->num_entries = num_entries;

    ordinal_name_buf = (char*)plthook + offsetof(plthook_t, entries) + sizeof(import_address_entry_t) * num_entries;
    idx = 0;
    for (desc = desc_head; desc->Name != 0; desc++) {
        IMAGE_THUNK_DATA *name_thunk = (IMAGE_THUNK_DATA*)((char*)hMod + desc->OriginalFirstThunk);
        IMAGE_THUNK_DATA *addr_thunk = (IMAGE_THUNK_DATA*)((char*)hMod + desc->FirstThunk);
        const char *module_name = (char *)hMod + desc->Name;
        int is_winsock2_dll = (stricmp(module_name, "WS2_32.DLL") == 0);

        while (addr_thunk->u1.Function != 0) {
            const char *name = NULL;

            if (IMAGE_SNAP_BY_ORDINAL(name_thunk->u1.Ordinal)) {
                int ordinal = IMAGE_ORDINAL(name_thunk->u1.Ordinal);
                if (is_winsock2_dll) {
                    name = winsock2_ordinal2name(ordinal);
                }
                if (name == NULL) {
                    name = ordinal_name_buf;
                    ordinal_name_buf += sprintf(ordinal_name_buf, "%s:@%d", module_name, ordinal) + 1;
                }
            } else {
                name = (char*)((PIMAGE_IMPORT_BY_NAME)((char*)hMod + name_thunk->u1.AddressOfData))->Name;
            }
            plthook->entries[idx].mod_name = module_name;
            plthook->entries[idx].name = name;
            plthook->entries[idx].addr = (void**)&addr_thunk->u1.Function;
            idx++;
            name_thunk++;
            addr_thunk++;
        }
    }

    *plthook_out = plthook;
    return 0;
}

int plthook_enum(plthook_t *plthook, unsigned int *pos, const char **name_out, void ***addr_out)
{
    if (*pos >= plthook->num_entries) {
        *name_out = NULL;
        *addr_out = NULL;
        return EOF;
    }
    *name_out = plthook->entries[*pos].name;
    *addr_out = plthook->entries[*pos].addr;
    (*pos)++;
    return 0;
}

static void replace_funcaddr(void **addr, void *newfunc, void **oldfunc)
{
    DWORD dwOld;
    DWORD dwDummy;

    if (oldfunc != NULL) {
        *oldfunc = *addr;
    }
    VirtualProtect(addr, sizeof(void *), PAGE_EXECUTE_READWRITE, &dwOld);
    *addr = newfunc;
    VirtualProtect(addr, sizeof(void *), dwOld, &dwDummy);
}

int plthook_replace(plthook_t *plthook, const char *funcname, void *funcaddr, void **oldfunc)
{
#ifndef _WIN64
    size_t funcnamelen = strlen(funcname);
#endif
    unsigned int pos = 0;
    const char *name;
    void **addr;
    int rv;
    BOOL import_by_ordinal = funcname[0] != '?' && strstr(funcname, ":@") != NULL;

    if (plthook == NULL) {
        set_errmsg("invalid argument: The first argument is null.");
        return PLTHOOK_INVALID_ARGUMENT;
    }
    while ((rv = plthook_enum(plthook, &pos, &name, &addr)) == 0) {
        if (import_by_ordinal) {
            if (stricmp(name, funcname) == 0) {
                goto found;
            }
        } else {
            /* import by name */
#ifdef _WIN64
            if (strcmp(name, funcname) == 0) {
                goto found;
            }
#else
            /* Function names may be decorated in Windows 32-bit applications. */
            if (strncmp(name, funcname, funcnamelen) == 0) {
                if (name[funcnamelen] == '\0' || name[funcnamelen] == '@') {
                    goto found;
                }
            }
            if (name[0] == '_' || name[0] == '@') {
                name++;
                if (strncmp(name, funcname, funcnamelen) == 0) {
                    if (name[funcnamelen] == '\0' || name[funcnamelen] == '@') {
                        goto found;
                    }
                }
            }
#endif
        }
    }
    if (rv == EOF) {
        set_errmsg("no such function: %s", funcname);
        rv = PLTHOOK_FUNCTION_NOT_FOUND;
    }
    return rv;
found:
    replace_funcaddr(addr, funcaddr, oldfunc);
    return 0;
}

void plthook_close(plthook_t *plthook)
{
    if (plthook != NULL) {
        free(plthook);
    }
}

const char *plthook_error(void)
{
    return errbuf;
}

static void set_errmsg(const char *fmt, ...)
{
    va_list ap;
    va_start(ap, fmt);
    vsnprintf(errbuf, sizeof(errbuf) - 1, fmt, ap);
    va_end(ap);
}

static void set_errmsg2(const char *fmt, ...)
{
    va_list ap;
    size_t len;

    va_start(ap, fmt);
    vsnprintf(errbuf, sizeof(errbuf) - 1, fmt, ap);
    va_end(ap);
    len = strlen(errbuf);
    FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM |FORMAT_MESSAGE_IGNORE_INSERTS,
                   NULL, GetLastError(), MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                   errbuf + len, sizeof(errbuf) - len - 1, NULL);
}

static const char *winsock2_ordinal2name(int ordinal)
{
    switch (ordinal) {
    case 1: return "accept";
    case 2: return "bind";
    case 3: return "closesocket";
    case 4: return "connect";
    case 5: return "getpeername";
    case 6: return "getsockname";
    case 7: return "getsockopt";
    case 8: return "htonl";
    case 9: return "htons";
    case 10: return "inet_addr";
    case 11: return "inet_ntoa";
    case 12: return "ioctlsocket";
    case 13: return "listen";
    case 14: return "ntohl";
    case 15: return "ntohs";
    case 16: return "recv";
    case 17: return "recvfrom";
    case 18: return "select";
    case 19: return "send";
    case 20: return "sendto";
    case 21: return "setsockopt";
    case 22: return "shutdown";
    case 23: return "socket";
    case 24: return "MigrateWinsockConfiguration";
    case 51: return "gethostbyaddr";
    case 52: return "gethostbyname";
    case 53: return "getprotobyname";
    case 54: return "getprotobynumber";
    case 55: return "getservbyname";
    case 56: return "getservbyport";
    case 57: return "gethostname";
    case 101: return "WSAAsyncSelect";
    case 102: return "WSAAsyncGetHostByAddr";
    case 103: return "WSAAsyncGetHostByName";
    case 104: return "WSAAsyncGetProtoByNumber";
    case 105: return "WSAAsyncGetProtoByName";
    case 106: return "WSAAsyncGetServByPort";
    case 107: return "WSAAsyncGetServByName";
    case 108: return "WSACancelAsyncRequest";
    case 109: return "WSASetBlockingHook";
    case 110: return "WSAUnhookBlockingHook";
    case 111: return "WSAGetLastError";
    case 112: return "WSASetLastError";
    case 113: return "WSACancelBlockingCall";
    case 114: return "WSAIsBlocking";
    case 115: return "WSAStartup";
    case 116: return "WSACleanup";
    case 151: return "__WSAFDIsSet";
    case 500: return "WEP";
    case 1000: return "WSApSetPostRoutine";
    case 1001: return "WsControl";
    case 1002: return "closesockinfo";
    case 1003: return "Arecv";
    case 1004: return "Asend";
    case 1005: return "WSHEnumProtocols";
    case 1100: return "inet_network";
    case 1101: return "getnetbyname";
    case 1102: return "rcmd";
    case 1103: return "rexec";
    case 1104: return "rresvport";
    case 1105: return "sethostname";
    case 1106: return "dn_expand";
    case 1107: return "WSARecvEx";
    case 1108: return "s_perror";
    case 1109: return "GetAddressByNameA";
    case 1110: return "GetAddressByNameW";
    case 1111: return "EnumProtocolsA";
    case 1112: return "EnumProtocolsW";
    case 1113: return "GetTypeByNameA";
    case 1114: return "GetTypeByNameW";
    case 1115: return "GetNameByTypeA";
    case 1116: return "GetNameByTypeW";
    case 1117: return "SetServiceA";
    case 1118: return "SetServiceW";
    case 1119: return "GetServiceA";
    case 1120: return "GetServiceW";
    case 1130: return "NPLoadNameSpaces";
    case 1131: return "NSPStartup";
    case 1140: return "TransmitFile";
    case 1141: return "AcceptEx";
    case 1142: return "GetAcceptExSockaddrs";
    }
    return NULL;
}

```

`test/Makefile`:

```
#
# This Makefile works only with GNU make.
#

UNAME_S := $(shell uname -s)

CFLAGS_SHARED = -shared -fPIC
CFLAGS = $(CFLAGS_WARNING) $(EXTRA_CFLAGS) $(OPT_CFLAGS)
CFLAGS_WARNING = -Wall
EXEEXT =
SOEXT = so
LIBS = -ldl -lm
PLTHOOK_C = plthook_elf.c
TESTS = run_tests
KICK_CMD =

ifeq ($(UNAME_S),Linux)
  # Linux
  TESTS = relro_pie_tests
  ifneq ($(TARGET_PLATFORM),)
    CC = $(TARGET_PLATFORM)-gcc
    KICK_CMD = qemu-$(or $(QEMU_ARCH),$(shell echo $(TARGET_PLATFORM) | sed -e 's/-.*//')) -L /usr/$(TARGET_PLATFORM)
  endif
endif

ifeq ($(UNAME_S),FreeBSD)
  # FreeBSD
  TESTS = relro_pie_tests
  LIBS = -lm -lutil
  SKIP_OPEN_BY_ADDRESS_TEST = 1
endif

ifeq ($(findstring MINGW32_NT,$(UNAME_S)),MINGW32_NT)
  # Mingw32
  CFLAGS_SHARED = -shared
  EXEEXT = .exe
  SOEXT = dll
  LIBS = -ldbghelp
  PLTHOOK_C = plthook_win32.c
endif

ifeq ($(findstring CYGWIN_NT,$(UNAME_S)),CYGWIN_NT)
  # Cygwin
  CFLAGS_SHARED = -shared
  EXEEXT = .exe
  SOEXT = dll
  LIBS = -ldbghelp
  PLTHOOK_C = plthook_win32.c
endif

ifeq ($(UNAME_S),Darwin)
  # OS X
  CFLAGS_SHARED = -shared -fPIC -Wno-deprecated-declarations
  LIBS = -ldl
  PLTHOOK_C = plthook_osx.c
endif

all: libtest.$(SOEXT) testprog$(EXEEXT)

libtest.$(SOEXT): libtest.c libtest.h
	$(CC) $(CFLAGS_SHARED) $(CFLAGS) -DLIBTEST_DLL -o libtest.$(SOEXT) libtest.c -lm

testprog$(EXEEXT): testprog.c ../$(PLTHOOK_C) libtest.h
	$(CC) $(CFLAGS_EXE) $(CFLAGS) -o testprog$(EXEEXT) -I.. testprog.c ../$(PLTHOOK_C) -L. -ltest $(LIBS)

run_tests: clean libtest.$(SOEXT) testprog$(EXEEXT)
	LD_LIBRARY_PATH=. $(KICK_CMD) ./testprog$(EXEEXT) open
	LD_LIBRARY_PATH=. $(KICK_CMD) ./testprog$(EXEEXT) open_by_handle
	test "$(SKIP_OPEN_BY_ADDRESS_TEST)" || env LD_LIBRARY_PATH=. $(KICK_CMD) ./testprog$(EXEEXT) open_by_address

check: $(TESTS)

relro_pie_tests:
	@echo ------------ check ------------
	$(MAKE) run_tests "EXTRA_CFLAGS="
	@echo ------------ check Partial RELRO ------------
	$(MAKE) run_tests "EXTRA_CFLAGS=-Wl,-z,relro"
	@echo ------------ check Full RELRO ------------
	$(MAKE) run_tests "EXTRA_CFLAGS=-Wl,-z,relro,-z,now"
	@echo ------------ check PIE ------------
	$(MAKE) run_tests "CFLAGS_EXE=-fPIE -pie"
	@echo ------------ check PIE Partial RELRO ------------
	$(MAKE) run_tests "CFLAGS_EXE=-fPIE -pie" "EXTRA_CFLAGS=-Wl,-z,relro"
	@echo ------------ check PIE Full RELRO ------------
	$(MAKE) run_tests "CFLAGS_EXE=-fPIE -pie" "EXTRA_CFLAGS=-Wl,-z,relro,-z,now"
	@echo ------------ check Partial RELRO + -fno-plt ------------
	@touch dummy.c
	@if test "$(TARGET_PLATFORM)" = "aarch64-linux-gnu"; then \
	  echo "skip -fno-plt tests on aarch64-linux-gnu"; \
	elif $(CC) -c dummy.c -fno-plt; then \
	  $(MAKE) run_tests "EXTRA_CFLAGS=-Wl,-z,relro -fno-plt"; \
	else \
	  echo "skip: -fno-plt isn't supported"; \
	fi

relro_pie_m32_tests:
	@echo ------------ check 32-bit ------------
	$(MAKE) run_tests "EXTRA_CFLAGS=-m32"
	@echo ------------ check 32-bit Partial RELRO ------------
	$(MAKE) run_tests "EXTRA_CFLAGS=-m32 -Wl,-z,relro"
	@echo ------------ check 32-bit Full RELRO ------------
	$(MAKE) run_tests "EXTRA_CFLAGS=-m32 -Wl,-z,relro,-z,now"
	@echo ------------ check 32-bit PIE ------------
	$(MAKE) run_tests "EXTRA_CFLAGS=-m32" "CFLAGS_EXE=-fPIE -pie"

relro_pie_tests_on_valgrind:
	@echo ------------ check on valgrind ------------
	$(MAKE) run_tests "EXTRA_CFLAGS=" KICK_CMD=valgrind
	@echo ------------ check Full RELRO on valgrind  ------------
	$(MAKE) run_tests "EXTRA_CFLAGS=-Wl,-z,relro,-z,now" KICK_CMD=valgrind
	@echo ------------ check 32-bit on valgrind ------------
	$(MAKE) run_tests "EXTRA_CFLAGS=-m32" KICK_CMD=valgrind
	@echo ------------ check 32-bit Full RELRO on valgrind ------------
	$(MAKE) run_tests "EXTRA_CFLAGS=-m32 -Wl,-z,relro,-z,now" KICK_CMD=valgrind

clean:
	$(RM) libtest.$(SOEXT) testprog$(EXEEXT)

```

`test/Makefile.win32`:

```win32
DLL_CFLAGS = /LD /MD
EXE_CFLAGS = /MD

all: libtest.dll testprog.exe

libtest.dll: libtest.c libtest.h
	cl /nologo $(DLL_CFLAGS) /DLIBTEST_DLL /Felibtest.dll libtest.c /link /def:libtest.def

testprog.exe: testprog.c ../plthook_win32.c libtest.h
	cl /nologo $(EXE_CFLAGS) /Fetestprog -I.. testprog.c ..\plthook_win32.c libtest.lib

check: libtest.dll testprog.exe
	.\testprog.exe open
	.\testprog.exe open_by_handle

clean:
	del libtest.dll libtest.exp libtest.lib libtest.obj plthook_win32.obj testprog.exe testprog.obj

```

`test/android/jni/Android.mk`:

```mk
LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)

LOCAL_MODULE    := libtest
LOCAL_SRC_FILES := ../../libtest.c
LOCAL_CFLAGS := -fno-builtin-ceil
TARGET_PLATFORM := android-22

include $(BUILD_SHARED_LIBRARY)

include $(CLEAR_VARS)

LOCAL_MODULE    := testprog
LOCAL_SRC_FILES := ../../testprog.c ../../../plthook_elf.c
LOCAL_C_INCLUDES := ../.. ../../..
LOCAL_SHARED_LIBRARIES := libtest

include $(BUILD_EXECUTABLE)

```

`test/android/jni/Application.mk`:

```mk
APP_PLATFORM := android-21

```

`test/android/run_tests`:

```
#!/bin/bash

cd "$(dirname "${BASH_SOURCE[0]}")"

if test -z "$ANDROID_HOME"; then
  echo "The environment variable ANDROID_HOME isn't set."
  exit 1
fi

if ! test -x "$ANDROID_HOME/tools/bin/sdkmanager"; then
  echo "Invalid environment variable ANDROID_HOME: $ANDROID_HOME"
  exit 1
fi

PATH=$ANDROID_HOME/tools/bin:$ANDROID_HOME/ndk-bundle:$ANDROID_HOME/emulator:$ANDROID_HOME/platform-tools:$PATH

set -e

echodo() {
  banner "$@"
  "$@"
  echo
}

banner() {
  echo ==========================================
  echo == $@
  echo ==========================================
}

if test "$TRAVIS" = true; then
  banner sdkmanager tools ndk-bundle emulator
  # Discard stdout to suppress log size. Test stops when log size > 4M on traivis-ci.
  echo yes | sdkmanager tools ndk-bundle emulator > /dev/null
  echo
fi

echodo ndk-build

API=25
TAG=google_apis
if test "$TRAVIS" = true; then
  ABIS="arm64-v8a armeabi-v7a"
else
  ABIS="arm64-v8a armeabi-v7a x86 x86_64"
fi

for ABI in $ABIS; do
  AVD_NAME=android-$API-$TAG-$ABI
  if ! avdmanager list avd -c | grep "^$AVD_NAME$" > /dev/null; then
    echo no | echodo avdmanager create avd -n $AVD_NAME -k "system-images;android-$API;$TAG;$ABI" -f
  fi

  banner emulator -avd $AVD_NAME -no-window -no-audio
  emulator -avd $AVD_NAME -no-window -no-audio &
  EMULATOR_PID=$!
  trap "kill $EMULATOR_PID" EXIT
  echo

  echodo adb wait-for-device
  echodo adb root
  sleep 1
  echodo adb push libs/$ABI/libtest.so /data/local
  echodo adb push libs/$ABI/testprog /data/local
  echodo adb shell "chmod 755 /data/local/libtest.so /data/local/testprog"
  echodo adb shell "env LD_LIBRARY_PATH=/data/local /data/local/testprog open"
  echodo adb shell "env LD_LIBRARY_PATH=/data/local /data/local/testprog open_by_address"
  echodo adb shell "env LD_LIBRARY_PATH=/data/local /data/local/testprog open_by_handle"
  kill $EMULATOR_PID
  trap - EXIT
  wait $EMULATOR_PID || true # ignore the exit code of the emulator process.
done

```

`test/libtest.c`:

```c
#include <stdlib.h>
#include "libtest.h"

double strtod_cdecl(const char *str, char **endptr)
{
    return strtod(str, endptr);
}

#if defined _WIN32 || defined __CYGWIN__
double __stdcall strtod_stdcall(const char *str, char **endptr)
{
    return strtod(str, endptr);
}

double __fastcall strtod_fastcall(const char *str, char **endptr)
{
    return strtod(str, endptr);
}

double strtod_export_by_ordinal(const char *str, char **endptr)
{
    return strtod(str, endptr);
}
#endif

#if defined __APPLE__
int atoi_dummy(const char *str)
{
    /* Just to avoid to put "strtod" at the beginning of GOT. */
    return atoi(str);
}
#endif

```

`test/libtest.def`:

```def
NAME libtest.dll
EXPORTS
    strtod_export_by_ordinal @10 NONAME

```

`test/libtest.h`:

```h
#ifndef LISTTEST_H
#define LISTTEST_H 1

#ifdef _WIN32
#ifdef LIBTEST_DLL
#define LIBTESTAPI __declspec(dllexport)
#else
#define LIBTESTAPI __declspec(dllimport)
#endif
#else
#define LIBTESTAPI
#endif

LIBTESTAPI
double strtod_cdecl(const char *str, char **endptr);

#if defined _WIN32 || defined __CYGWIN__
LIBTESTAPI
double __stdcall strtod_stdcall(const char *str, char **endptr);

LIBTESTAPI
double __fastcall strtod_fastcall(const char *str, char **endptr);

double strtod_export_by_ordinal(const char *str, char **endptr);
#endif

#endif

```

`test/run-test.bat`:

```bat
call "c:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Auxiliary\Build\vcvarsall.bat" %1
nmake /f Makefile.win32 check clean DLL_CFLAGS=%2 EXE_CFLAGS=%3

```

`test/testprog.c`:

```c
#include <plthook.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include "libtest.h"
#ifdef _WIN32
#include <windows.h>
#else
#include <dlfcn.h>
#endif

#if defined __UCLIBC__ && !defined RTLD_NOLOAD
#define RTLD_NOLOAD 0
#endif

#define CHK_PH(func) do { \
    if (func != 0) { \
        fprintf(stderr, "%s error: %s\n", #func, plthook_error()); \
        exit(1); \
    } \
} while (0)

typedef struct {
    const char *name;
    int enumerated;
} enum_test_data_t;

enum open_mode {
    OPEN_MODE_DEFAULT,
    OPEN_MODE_BY_HANDLE,
    OPEN_MODE_BY_ADDRESS,
};

static enum_test_data_t funcs_called_by_libtest[] = {
#if defined __APPLE__ && defined __LP64__
    {"_strtod", 0},
#elif defined __APPLE__ && !defined __LP64__
    {"_strtod$UNIX2003", 0},
#else
    {"strtod", 0},
#endif
    {NULL, },
};

static enum_test_data_t funcs_called_by_main[] = {
#if defined _WIN64 || (defined __CYGWIN__ && defined __x86_64__)
    {"strtod_cdecl", 0},
    {"strtod_stdcall", 0},
    {"strtod_fastcall", 0},
#ifndef __CYGWIN__
    {"libtest.dll:@10", 0},
#endif
#elif defined _WIN32 && defined __GNUC__
    {"strtod_cdecl", 0},
    {"strtod_stdcall@8", 0},
    {"@strtod_fastcall@8", 0},
#elif defined _WIN32 && !defined __GNUC__
    {"strtod_cdecl", 0},
    {"_strtod_stdcall@8", 0},
    {"@strtod_fastcall@8", 0},
    {"libtest.dll:@10", 0},
#elif defined __APPLE__
    {"_strtod_cdecl", 0},
#else
    {"strtod_cdecl", 0},
#endif
    {NULL, },
};

#define STRTOD_STR_SIZE 30

typedef struct {
    char str[STRTOD_STR_SIZE];
    double result;
} hooked_val_t;

/* value captured by hook from executable to libtest. */
static hooked_val_t val_exe2lib;
/* value captured by hook from libtest to libc. */
static hooked_val_t val_lib2libc;

static void reset_result(void)
{
    val_exe2lib.str[0] = '\0';
    val_exe2lib.result = 0.0;
    val_lib2libc.str[0] = '\0';
    val_lib2libc.result = 0.0;
}

static void set_result(hooked_val_t *hv, const char *str, double result)
{
    strncpy(hv->str, str, sizeof(hv->str) - 1);
    hv->str[sizeof(hv->str) - 1] = '\0';
    hv->result = result;
}

static void check_result(const char *str, double result, double expected_result, long line)
{
    if (result != expected_result) {
        goto error;
    }
    if (strcmp(val_exe2lib.str, str) != 0) {
        goto error;
    }
    if (val_exe2lib.result != result) {
        goto error;
    }
    if (strcmp(val_lib2libc.str, str) != 0) {
        goto error;
    }
    if (val_lib2libc.result != result) {
        goto error;
    }
    return;
error:
    fprintf(stderr,
            "Error: ['%s', %f, %f] ['%s', %f] ['%s', %f] at line %ld\n",
            str, result, expected_result,
            val_exe2lib.str, val_exe2lib.result,
            val_lib2libc.str, val_lib2libc.result,
            line);
    exit(1);
}

#define CHK_RESULT(func_name, str, expected_result) do { \
    double result__; \
    reset_result(); \
    result__ = func_name(str, NULL); \
    check_result(str, result__, expected_result, __LINE__); \
} while (0)

static double (*strtod_cdecl_old_func)(const char *, char**);
#if defined _WIN32 || defined __CYGWIN__
static double (__stdcall *strtod_stdcall_old_func)(const char *, char**);
static double (__fastcall *strtod_fastcall_old_func)(const char *, char**);
#endif
#if defined _WIN32
static double (*strtod_export_by_ordinal_old_func)(const char *, char**);
#endif

/* hook func from libtest to libc. */
static double strtod_hook_func(const char *str, char **endptr)
{
    double result = strtod(str, endptr);
    set_result(&val_lib2libc, str, result);
    return result;
}

/* hook func from testprog to libtest. */
static double strtod_cdecl_hook_func(const char *str, char **endptr)
{
    double result = strtod_cdecl_old_func(str, endptr);
    set_result(&val_exe2lib, str, result);
    return result;
}

#if defined _WIN32 || defined __CYGWIN__
/* hook func from testprog to libtest. */
static double __stdcall strtod_stdcall_hook_func(const char *str, char **endptr)
{
    double result = strtod_stdcall_old_func(str, endptr);
    set_result(&val_exe2lib, str, result);
    return result;
}

/* hook func from testprog to libtest. */
static double __fastcall strtod_fastcall_hook_func(const char *str, char **endptr)
{
    double result = strtod_fastcall_old_func(str, endptr);
    set_result(&val_exe2lib, str, result);
    return result;
}
#endif

#if defined _WIN32
/* hook func from testprog to libtest. */
static double strtod_export_by_ordinal_hook_func(const char *str, char **endptr)
{
    double result = strtod_export_by_ordinal_old_func(str, endptr);
    set_result(&val_exe2lib, str, result);
    return result;
}
#endif

static void test_plthook_enum(plthook_t *plthook, enum_test_data_t *test_data)
{
    unsigned int pos = 0;
    const char *name;
    void **addr;
    int i;

    while (plthook_enum(plthook, &pos, &name, &addr) == 0) {
        for (i = 0; test_data[i].name != NULL; i++) {
            if (strcmp(test_data[i].name, name) == 0) {
                test_data[i].enumerated = 1;
            }
        }
    }
    for (i = 0; test_data[i].name != NULL; i++) {
        if (!test_data[i].enumerated) {
            fprintf(stderr, "%s is not enumerated by plthook_enum.\n", test_data[i].name);
            pos = 0;
            while (plthook_enum(plthook, &pos, &name, &addr) == 0) {
                printf("   %s\n", name);
            }
            exit(1);
        }
    }
}

static void show_usage(const char *arg0)
{
    fprintf(stderr, "Usage: %s (open | open_by_handle | open_by_address)\n", arg0);
}

static void hook_function_calls_in_executable(enum open_mode open_mode)
{
    plthook_t *plthook;
    void *handle;

    switch (open_mode) {
    case OPEN_MODE_DEFAULT:
        CHK_PH(plthook_open(&plthook, NULL));
        break;
    case OPEN_MODE_BY_HANDLE:
#ifdef WIN32
        handle = GetModuleHandle(NULL);
#else
        handle = dlopen(NULL, RTLD_LAZY);
#endif
        assert(handle != NULL);
        CHK_PH(plthook_open_by_handle(&plthook, handle));
        break;
    case OPEN_MODE_BY_ADDRESS:
        CHK_PH(plthook_open_by_address(&plthook, &show_usage));
        break;
    }
    test_plthook_enum(plthook, funcs_called_by_main);
    CHK_PH(plthook_replace(plthook, "strtod_cdecl", (void*)strtod_cdecl_hook_func, (void**)&strtod_cdecl_old_func));
#if defined _WIN32 || defined __CYGWIN__
    CHK_PH(plthook_replace(plthook, "strtod_stdcall", (void*)strtod_stdcall_hook_func, (void**)&strtod_stdcall_old_func));
    CHK_PH(plthook_replace(plthook, "strtod_fastcall", (void*)strtod_fastcall_hook_func, (void**)&strtod_fastcall_old_func));
#endif
#if defined _WIN32
    CHK_PH(plthook_replace(plthook, "libtest.dll:@10", (void*)strtod_export_by_ordinal_hook_func, (void**)&strtod_export_by_ordinal_old_func));
#endif
    plthook_close(plthook);
}

static void hook_function_calls_in_library(enum open_mode open_mode)
{
    plthook_t *plthook;
    void *handle;
#if defined _WIN32 || defined __CYGWIN__
    const char *filename = "libtest.dll";
#else
    const char *filename = "libtest.so";
#endif
#ifndef WIN32
    void *address;
#endif

    switch (open_mode) {
    case OPEN_MODE_DEFAULT:
        CHK_PH(plthook_open(&plthook, filename));
        break;
    case OPEN_MODE_BY_HANDLE:
#ifdef WIN32
        handle = GetModuleHandle(filename);
#else
        handle = dlopen(filename, RTLD_LAZY | RTLD_NOLOAD);
#endif
        assert(handle != NULL);
        CHK_PH(plthook_open_by_handle(&plthook, handle));
        break;
    case OPEN_MODE_BY_ADDRESS:
#ifdef WIN32
        handle = GetModuleHandle(filename);
        assert(handle != NULL);
        CHK_PH(plthook_open_by_address(&plthook, handle));
#else
        handle = dlopen(filename, RTLD_LAZY | RTLD_NOLOAD);
        address = dlsym(handle, "strtod_cdecl");
        assert(address != NULL);
        CHK_PH(plthook_open_by_address(&plthook, (char*)address));
#endif
        break;
    }
    test_plthook_enum(plthook, funcs_called_by_libtest);
    CHK_PH(plthook_replace(plthook, "strtod", (void*)strtod_hook_func, NULL));
    plthook_close(plthook);
}

int main(int argc, char **argv)
{
    double expected_result = strtod("3.7", NULL);
    enum open_mode open_mode;

    if (argc != 2) {
        show_usage(argv[0]);
        exit(1);
    }
    if (strcmp(argv[1], "open") == 0) {
        open_mode = OPEN_MODE_DEFAULT;
    } else if (strcmp(argv[1], "open_by_handle") == 0) {
        open_mode = OPEN_MODE_BY_HANDLE;
    } else if (strcmp(argv[1], "open_by_address") == 0) {
        open_mode = OPEN_MODE_BY_ADDRESS;
    } else {
        show_usage(argv[0]);
        exit(1);
    }

    /* Resolve the function addresses by lazy binding. */
    strtod_cdecl("3.7", NULL);
#if defined _WIN32 || defined __CYGWIN__
    strtod_stdcall("3.7", NULL);
    strtod_fastcall("3.7", NULL);
#endif
#if defined _WIN32
    strtod_export_by_ordinal("3.7", NULL);
#endif

    hook_function_calls_in_executable(open_mode);
    hook_function_calls_in_library(open_mode);

    CHK_RESULT(strtod_cdecl, "3.7", expected_result);
#if defined _WIN32 || defined __CYGWIN__
    CHK_RESULT(strtod_stdcall, "3.7", expected_result);
    CHK_RESULT(strtod_fastcall, "3.7", expected_result);
#endif
#if defined _WIN32
    CHK_RESULT(strtod_export_by_ordinal, "3.7", expected_result);
#endif

    printf("success\n");
    return 0;
}

```

`test/uclibc-test.sh`:

```sh
#!/bin/bash

case "$1" in
  x86_64)
    ARCH=x86-64-core-i7
    LIBC=uclibc
    TOOLCHAIN_VER=stable-2018.11-1
    TARGET_PLATFORM=x86_64-buildroot-linux-uclibc
    ;;
  i686)
    ARCH=x86-core2
    LIBC=uclibc
    TOOLCHAIN_VER=stable-2018.11-1
    TARGET_PLATFORM=i686-buildroot-linux-uclibc
    ;;
esac

set -e

THIS_COMMAND=$0

run_make() {
  BASE_NAME=$ARCH--$LIBC--$TOOLCHAIN_VER
  export SYSROOT=$BASE_NAME/$TARGET_PLATFORM/sysroot
  if test -f $BASE_NAME.tar.bz2; then
    echo Found $BASE_NAME.tar.bz2
  else
    echo Download $BASE_NAME.tar.bz2
    wget https://toolchains.bootlin.com/downloads/releases/toolchains/$ARCH/tarballs/$BASE_NAME.tar.bz2
  fi
  if test -d $BASE_NAME; then
    echo Found $BASE_NAME
  else
    echo Extract $BASE_NAME.tar.bz2
    tar xfj $BASE_NAME.tar.bz2
  fi
  if test -h $SYSROOT/proc/self; then
    echo Found $SYSROOT/proc/self
  else
    echo Mount $SYSROOT/proc
    sudo mount -t proc none $SYSROOT/proc
  fi
  export RUN_AS_KICK_CMD=1
  export PATH="$BASE_NAME/bin:$PATH"
  make relro_pie_tests TARGET_PLATFORM=$TARGET_PLATFORM KICK_CMD=$THIS_COMMAND
}

kick_cmd() {
  cp testprog $SYSROOT/usr/bin
  cp libtest.so $SYSROOT/usr/lib
  cd $SYSROOT
  shift
  sudo chroot . ./usr/bin/testprog "$@"
}

if test "$RUN_AS_KICK_CMD"; then
  kick_cmd "$@"
else
  run_make "$@"
fi

```