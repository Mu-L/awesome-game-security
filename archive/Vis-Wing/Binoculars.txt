Project Path: arc_Vis-Wing_Binoculars_qgd9uhrk

Source Tree:

```txt
arc_Vis-Wing_Binoculars_qgd9uhrk
├── Binoculars
│   ├── __init__.py
│   ├── __pycache__
│   │   ├── __init__.cpython-310.pyc
│   │   └── __init__.cpython-311.pyc
│   ├── config
│   │   ├── __init__.py
│   │   ├── __pycache__
│   │   │   ├── __init__.cpython-310.pyc
│   │   │   ├── __init__.cpython-311.pyc
│   │   │   ├── config.cpython-310.pyc
│   │   │   └── config.cpython-311.pyc
│   │   ├── config.ini
│   │   ├── config.py
│   │   ├── model.ini
│   │   ├── prompt_base.txt
│   │   └── prompt_command.txt
│   ├── function
│   │   ├── ExplainFunc.py
│   │   ├── GoParse
│   │   │   ├── __pycache__
│   │   │   │   ├── extract_types.cpython-310.pyc
│   │   │   │   ├── extract_types.cpython-311.pyc
│   │   │   │   ├── function_discovery_and_renaming.cpython-310.pyc
│   │   │   │   ├── function_discovery_and_renaming.cpython-311.pyc
│   │   │   │   ├── recreate_pclntab.cpython-310.pyc
│   │   │   │   ├── recreate_pclntab.cpython-311.pyc
│   │   │   │   ├── string_cast.cpython-310.pyc
│   │   │   │   └── string_cast.cpython-311.pyc
│   │   │   ├── categorize_go_folders.py
│   │   │   ├── extract_types.py
│   │   │   ├── function_discovery_and_renaming.py
│   │   │   ├── recreate_pclntab.py
│   │   │   └── string_cast.py
│   │   ├── GoParseFunc.py
│   │   ├── Handle.py
│   │   ├── RenameFunc.py
│   │   ├── SwapModel.py
│   │   ├── __init__.py
│   │   └── __pycache__
│   │       ├── ExplainFunc.cpython-310.pyc
│   │       ├── ExplainFunc.cpython-311.pyc
│   │       ├── GoParseFunc.cpython-310.pyc
│   │       ├── GoParseFunc.cpython-311.pyc
│   │       ├── Handle.cpython-310.pyc
│   │       ├── Handle.cpython-311.pyc
│   │       ├── RenameFunc.cpython-310.pyc
│   │       ├── RenameFunc.cpython-311.pyc
│   │       ├── SwapModel.cpython-310.pyc
│   │       ├── SwapModel.cpython-311.pyc
│   │       ├── __init__.cpython-310.pyc
│   │       └── __init__.cpython-311.pyc
│   ├── images
│   │   ├── logo.ico
│   │   └── logo.png
│   ├── interface
│   │   ├── __init__.py
│   │   ├── __pycache__
│   │   │   ├── __init__.cpython-310.pyc
│   │   │   ├── __init__.cpython-311.pyc
│   │   │   ├── interface.cpython-310.pyc
│   │   │   └── interface.cpython-311.pyc
│   │   └── interface.py
│   └── models
│       ├── __init__.py
│       ├── __pycache__
│       │   ├── __init__.cpython-310.pyc
│       │   ├── __init__.cpython-311.pyc
│       │   ├── base.cpython-310.pyc
│       │   ├── base.cpython-311.pyc
│       │   ├── claude.cpython-310.pyc
│       │   ├── gpt360.cpython-310.pyc
│       │   ├── gpt360.cpython-311.pyc
│       │   └── openai.cpython-310.pyc
│       ├── base.py
│       ├── claude.py
│       ├── gpt360.py
│       └── openai.py
├── Binoculars.py
├── LICENSE
└── README.md

```

`Binoculars.py`:

```py
from Binoculars.config.config import loadconfig
from Binoculars.interface.interface import IDAAssistant

def PLUGIN_ENTRY():
    loadconfig()
    return IDAAssistant()
```

`Binoculars/config/config.ini`:

```ini
[MODEL]
default_model = {'GPT360': '360zhinao-pro-qwen-plus'}

[GPT360]
base_url = https://api.360.cn/v1/chat/completions
api_key = 
gpt360_proxy = 

[OPENAI]
base_url = 
api_key = 
openai_proxy = 

[CLAUDE]
base_url = 
api_key = 
claude_proxy = 


```

`Binoculars/config/config.py`:

```py
#!/usr/bin/env python  
# -*- coding:utf-8 _*-

import configparser
import os
import json

default_model = None
def loadconfig():
    from Binoculars.models.base import get_model
    global default_model
    default_model = get_model(readconfig('MODEL','Default_Model'))

def readconfig(section, key):
    config = os.path.join(os.path.split(os.path.realpath(__file__))[0], "config.ini")
    config_handle = configparser.ConfigParser()
    config_handle.read(config)
    return config_handle.get(section, key)

    
def writeconfig(section, key, content):
    config = os.path.join(os.path.split(os.path.realpath(__file__))[0], "config.ini")
    config_handle = configparser.ConfigParser()
    config_handle.read(config)
    config_handle.set(section,key,str(content))
    with open(config, 'w') as configfile:
        config_handle.write(configfile)
        
def readpromat(prompt):
    system_prompt = ""
    prompt = os.path.join(os.path.split(os.path.realpath(__file__))[0], prompt+".txt")
    with open(prompt) as prompt_handle:
        system_prompt = prompt_handle.read()
    return system_prompt

def get_model_list():
    config = os.path.join(os.path.split(os.path.realpath(__file__))[0], "model.ini")
    with open(config,"r") as file:
        return json.load(file)
        
def get_current_model():
    from Binoculars.models.base import get_model
    global default_model
    default_model = get_model(readconfig('MODEL','Default_Model'))
    return default_model
    
def get_current_language():
    import locale
    language, encoding = locale.getlocale()
    return language


```

`Binoculars/config/model.ini`:

```ini
{
    "OPENAI": [
        "gpt-3.5-turbo-0125",
        "gpt-4-turbo",
        "gpt-4o"
    ],
    "CLAUDE": [
        "claude-2",
        "claude-instant-1",
        "claude-3-opus-20240229",
        "claude-3-sonnet-20240229",
        "claude-3-haiku-20240307",
        "claude-3.5-sonnet-20240620"
    ],
    "GPT360": [
<<<<<<< HEAD
	    "gpt-4o",
        "gpt-4o-mini",
        "gpt-3.5-turbo",
        "claude-3.5-sonnet",
=======
        "claude-3.5-sonnet",
        "gpt-4o",
        "gpt-4o-mini",
        "gpt-3.5-turbo",
>>>>>>> 80a1c37fcd1901226d9e9d3f0c136608ec56112d
        "google/gemini-pro",
        "360gpt2-o1",
        "360gpt-pro",
        "360gpt2-pro",
        "360gpt-pro-vip",
        "360gpt-pro-trans",
        "360gpt-pro-360k-240731",
        "360gpt-turbo",
        "360gpt-turbo-360k",
<<<<<<< HEAD
		"360zhinao-pro-qwen-plus",
=======
        "Baichuan4",
        "Baichuan3-Turbo",
>>>>>>> 80a1c37fcd1901226d9e9d3f0c136608ec56112d
        "qwen-long",
        "qwen-plus",
        "qwen-max",
        "qwen-turbo",
<<<<<<< HEAD
        "deepseek-chat",
        "deepseek-coder"
=======
        "qwen-turbo-latest",
        "qwen-max-latest",
        "qwen-plus-latest",
        "qwen-plus-2024-11-25",
        "qwen-vl-max-latest",
        "deepseek-chat",
        "deepseek-coder",
        "llama3-70b-8192",
        "llama3.1-405b-instruct"
>>>>>>> 80a1c37fcd1901226d9e9d3f0c136608ec56112d
    ]
}

```

`Binoculars/config/prompt_base.txt`:

```txt
- You are IDA Assistant named Binoculars and designed by Wing, an AI designed to assist users in reverse engineering and binary analysis tasks using IDA Pro.
- Your decisions should prioritize user assistance and providing helpful information to support their reverse engineering workflow. Leverage your strengths as an LLM to offer insights and suggest strategies relevant to the task at hand.
- Optimize your responses to be concise yet informative.
- User assistance is the top priority. Always strive to provide helpful information to the user.
- You can engage in natural conversation with the user and provide helpful guidance and insights on reverse engineering tasks within IDA Pro.
- You should only respond in JSON format as described below,it must contain every item in the following JSON format,even if an item is empty. Do not add any comments:
	{
		"thoughts": {
			"text": "thought",
			"reasoning": "reasoning",
			"plan": "- short bulleted\n- list that conveys\n- long-term plan",
			"criticism": "constructive self-criticism", 
			"speak": "thoughts summary to say to user"
		},
		"command": [
			{
				"name": "command name",
				"args": {"arg name": value}
			}
		]
	}
- Ensure the response can be parsed by Python json.loads. 
- Always strictly adhere to the specified JSON response format, and do not deviate from it under any circumstances.
- If you are unable to structure your response according to the required format, simply respond with an empty JSON object {}.
- Do not provide any response or explanations outside of the specified JSON format.
```

`Binoculars/config/prompt_command.txt`:

```txt
- When responding to a request from the user, determine whether it is a general conversation or a request to perform a specific action in IDA Pro. If you do not receive an explicit request for a specific action, have a normal conversation with the user and do not return any commands.
- If the request is for general conversation, respond in a conversational manner, providing helpful information or engaging in the conversation.
- If the request indicates a desire for specific actions within IDA Pro (e.g., asking for disassembly, decompilation, etc.), Please strictly abide by the following restrictions.
	- DO NOT generate any commands that are not in the Commands list, even if the user requests it.
	- If the user's request does not match any command in the Commands list or the command does not have the necessary parameters, respond with the "do_nothing" command.
	- When a series of tasks is completed, end the session with the "do_nothing" command.
	- Do not attempt to use the previous command run results as parameters dynamically, as in the wrong usage example.
	- If the parameter is "address", you must explicitly write down the address string.
	- Try not to repeat the same mistake.
	- You can see user's current view/position in IDA Pro.
	- You have knowledge base on reverse engineering concepts and common techniques.
	- You can use multiple commands.
	- Reflect on how well your suggestions assisted the user in their reverse engineering task.
	- Assess whether the user found your insights helpful and relevant.
	- Consider potential alternative approaches that could have been more efficient or impactful.
	- Strive to provide the most value to the user with each interaction.
	- If the result of ANY command is empty or the address is invalid, do not try any further commands.
	- Example of wrong usage:
		"command": [
			{
				"name": "get_address_of_name",
				"args": {"name": "dispatch::handler"}
			},
			{
				"name": "decompile_address",
				"args": {"address": "<result of previous command>"} # Wrong usage
			},
			{
				"name": "get_xrefs_to",
				"args": {"address": "<result of 2 commands ago>"} # Wrong usage
			},
			{
				"name": "get_xrefs_from",
				"args": {"address": "<result of 2 commands ago>"} # Wrong usage
			}
		]
	- Limit your actions to the Commands list listed below.
		Commands list:
```

`Binoculars/function/ExplainFunc.py`:

```py
import idaapi
import functools
import textwrap
import ida_hexrays
import idc
import re
import ida_kernwin
from Binoculars.config.config import get_current_model
from Binoculars.config.config import get_current_language


class ExplainHandler(idaapi.action_handler_t):

    def __init__(self, default_model):
        idaapi.action_handler_t.__init__(self)

    def activate(self, ctx):
        default_model = get_current_model()
        current_language = get_current_language()
    
        widget = ida_kernwin.get_current_widget()
        if ida_kernwin.get_widget_type(widget) != idaapi.BWN_PSEUDOCODE:
            func_ea = idaapi.get_screen_ea()
            ida_hexrays.open_pseudocode(func_ea, 0)  # 打开或激活反编译窗口
            widget = ida_kernwin.get_current_widget()  # 重新获取 widget
        
        view = ida_hexrays.get_widget_vdui(widget)
        if view is None:
            idaapi.warning("Failed to get the pseudocode view.")
            return 1

        messages,systemprompt = {},""
        decompiler_output = ida_hexrays.decompile(idaapi.get_screen_ea())

        default_model.query_model_async(
            "Can you explain the purpose of the following C function and suggest a better name for it? No need for an improved version or other information! Please reply in {current_language}!\n{decompiler_output}".format(decompiler_output=str(decompiler_output),current_language=current_language),messages,systemprompt,functools.partial(comment_callback, address=idaapi.get_screen_ea(), view=view, default_model=default_model))
        return 1

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS
        
        
def comment_callback(address, view, response, default_model):
  
    response = "\n".join(textwrap.wrap(response, 80, replace_whitespace=False))
    comment = idc.get_func_cmt(address, 0)
    comment = re.sub(comment,comment,comment,flags=re.DOTALL)
    idc.set_func_cmt(address, f"{response.strip()}\n\n"f"{comment.strip()}", 0)
    
    if view:
        view.refresh_view(False)
    print("{model} 查询完成!".format(model=str(default_model)))
```

`Binoculars/function/GoParse/categorize_go_folders.py`:

```py
#IDAPython script to categorize golang functions into folders
#Turn on "Show Folders" to see effects
import ida_dirtree
import idautils
import idc

func_dir: ida_dirtree.dirtree_t
func_dir =   ida_dirtree.get_std_dirtree(ida_dirtree.DIRTREE_FUNCS)
ite = ida_dirtree.dirtree_iterator_t()
ok = func_dir.findfirst(ite, "*")

folders = {}


DEBUG = False
def info(formatted_string):
    print("[info] " + formatted_string)

def error(formatted_string):
    print('[ERROR] %s' % formatted_string)

def debug(formatted_string):
    if DEBUG:
        print('[DEBUG] %s' % formatted_string)

def create_folders():
    for function in idautils.Functions():
        folderName = ""
        name = idc.get_func_name(function)
        if name.startswith("_") or name.startswith("."):
            folders.setdefault("uncategorized",[]).append(name)
            continue
        for i,c in enumerate(name):
            if c == "." or c == "_": 
                folderName = name[:i]
                break
        if folderName == "":
            folderName = "uncategorized"
        if folderName == "sub":
            folderName = "unnamed"
        folders.setdefault(folderName,[]).append(name)
    existed = []
    created = []
    for folderName in folders:
        if func_dir.isdir(folderName):
            existed.append(folderName)
            continue
        else:
            try:
                func_dir.mkdir(folderName)
                created.append(folderName)
            except:
                print("[ERROR] Failed to create folder: ", folderName)
                continue
    for folderName in existed:
        if (folderName != "github"):
            folders.pop(folderName)
    for folder in created:
        if len(folders[folder]) <= 3:
            for func in folders[folder]:
                folders.setdefault("uncategorized",[]).append(func)
            folders.pop(folder)
            func_dir.rmdir(folder)


def populate_folders():
    for folderName in folders:
        if not func_dir.isdir(folderName):
            print("[ERROR] %s folder didn't exist, recreating...", folderName)
            try:
                func_dir.mkdir(folderName)
            except:
                print("[ERROR] Couldn't create folder: " + folderName)
        list_of_funcs = folders[folderName]
        for func in list_of_funcs:
            try:
                func_dir.rename(func, folderName+"/"+func)
            except:
                print("[ERROR] Failed to move function:", func)


def nest_standard_packages():
    common_packages = ["archive", "bufio", "builtin", "bytes", "compress", "container", "context", "crypto", "database", "debug", "embed", "encoding", "errors", "flag", "fmt", "go", "hash", "html", "image", "index", "io", "log", "math", "mime", "net", "os", "path", "plugin", "regexp", "sort", "strconv", "strings", "sync", "syscall", "testing", "text", "time", "unicode", "unsafe", "internal", "reflect", "vendor", "golang", "runtime", "type", "setg", "pthread", "walk", "gosave", "x", "cgo"]
    folderName = "StandardGoPackages"
    try:
        func_dir.mkdir(folderName)
        for package in common_packages:
            try:
                func_dir.rename(package, folderName+"/"+package)
            except:
                print("[ERROR] Failed to move standard package folder:", package)
    except:
        print("[ERROR] Failed to create folder: ", folderName)


def github_sort():
    if "github" in folders.keys():
        github_repos = {}
        for package in folders["github"]:
            repo = ""
            for i,c in enumerate(package[11:]):
                if c == "." or c == "_": 
                    i = i+11
                    repo = package[11:i]
                    github_repos.setdefault(repo,[]).append(package)
                    break

        for repo in github_repos:
            sub_folder = "github/" + repo
            try:
                func_dir.mkdir(sub_folder)
            except:
                print("[ERROR] Failed to create folder: ", sub_folder)
            for func in github_repos[repo]:
                try:
                    func_dir.rename("github/"+func, sub_folder+"/"+func)
                except:
                    print("[ERROR] Failed to move github repo:", func)



def main3():

    create_folders()
    populate_folders()
    nest_standard_packages()
    github_sort()

if __name__ == "__main__":
    main3()



#Still need to handle a few stragglers from the conflicting sorting mechanism introduced in IDA 7.7 but this is much better :)

```

`Binoculars/function/GoParse/extract_types.py`:

```py
"""
go_tmilk.py - Go Type Milking
Written by Ivan Kwiatkowski @ Kaspersky GReAT
Shared under the terms of the GPLv3 license
"""

C_HEADER = """
enum golang_kind : __int8
{
  INVALID = 0x0,
  BOOL = 0x1,
  INT = 0x2,
  INT8 = 0x3,
  INT16 = 0x4,
  INT32 = 0x5,
  INT64 = 0x6,
  UINT = 0x7,
  UINT8 = 0x8,
  UINT16 = 0x9,
  UINT32 = 0xA,
  UINT64 = 0xB,
  UINTPTR = 0xC,
  FLOAT32 = 0xD,
  FLOAT64 = 0xE,
  COMPLEX64 = 0xF,
  COMPLEX128 = 0x10,
  ARRAY = 0x11,
  CHAN = 0x12,
  FUNC = 0x13,
  INTERFACE = 0x14,
  MAP = 0x15,
  PTR = 0x16,
  SLICE = 0x17,
  STRING = 0x18,
  STRUCT = 0x19,
  UNSAFEPTR = 0x1A,
  CHAN_DIRECTIFACE = 0x32,
  FUNC_DIRECTIFACE = 0x33,
  MAP_DIRECTIFACE = 0x35,
  STRUCT_DIRECTIFACE = 0x39,
};

struct golang_type
{
  __int64 size;
  __int64 ptrdata;
  int hash;
  char tflag;
  char align;
  char fieldalign;
  golang_kind kind;
  __int64 equal_fn;
  __int64 gcData;
  int nameoff;
  int typeoff;
  __int64 name;
  __int64 mhdr;
};
"""
import ida_funcs
from idautils import *
from idc import *
import idaapi

DEBUG = False
def info(formatted_string):
    print("[info] " + formatted_string)

def error(formatted_string):
    print('[ERROR] %s' % formatted_string)

def debug(formatted_string):
    if DEBUG:
        print('[DEBUG] %s' % formatted_string)
        
def find_type_structures(func_name, search_len=15):
    """
    Looks for all types passed as argument to the given function. Probably only
    works for Go > 1.15 where the register calling convention was introduced.
    
    func_name: The name of the function to look for (i.e. "runtime.newobject")
    register: The register in which the required argument is passed (i.e. "eax")
    """
    type_addresses = set()
    # Find all xrefs to the given function
    for f in Functions():
        if ida_funcs.get_func_name(f) == func_name:
            for ref in XrefsTo(f):
                # Find the type argument of that function
                for h in Heads(ref.frm - search_len, ref.frm):
                    info(f"Instruction: {hex(h)} - {print_insn_mnem(h)}")
                    if "lea" == print_insn_mnem(h) and (get_operand_type(h, 1) == o_imm or get_operand_type(h, 1) == o_mem) and (print_operand(h, 0) == "rcx" or print_operand(h, 0) == "rax"):
                        info("FOUND")
                        type_addresses.add(get_operand_value(h, 1))
                        break
            break
    return type_addresses


def parse_type(addr):
	"""
	Applies the correct structure to the type at the given address and locates its name.
	"""
	SetType(addr, "golang_type")
	data_addr = -1
	for s in Segments():
		if (get_segm_name(s) == ".rdata") or (get_segm_name(s) == "__rodata"):
		   data_addr = get_segm_start(s)
	if data_addr == -1:
		error("Could not find .rdata segment!")
		return False
		   
	# nameOff is an offset into rdata. We end up on a structure where the first byte is a bitfield
	# followed by the size of the string followed by the name of the type.
	# https://github.com/golang/go/blob/release-branch.go1.16/src/reflect/type.go#L443
	nameOff = get_wide_dword(addr + 0x28) + data_addr
	if nameOff == data_addr:
		return True  # No type string, just move on
		
	# Starting from Go 1.17 (?), the size is provided as a varint-encoded length.
	size = get_wide_byte(nameOff + 1) << 8 | get_wide_byte(nameOff + 2)
	if size > 0xFF:  # Quick & dirty sanity check.
		size = get_wide_byte(nameOff + 1)  # This is almost certain to break eventually
		type_str = get_strlit_contents(nameOff + 2, size)
	else:
		type_str = get_strlit_contents(nameOff + 3, size)
	if not type_str:
		error(f"Could not obtain type name for {hex(addr)} at address {hex(nameOff)}")
		del_items(addr)  # Was probably a FP, delete the structure and move on
		return True
	set_cmt(addr, type_str.decode(errors="replace"), False)
	for ref in XrefsTo(addr):
		set_cmt(ref.frm, type_str.decode(errors="replace"), False)
	# Rename the structure too. 0x800 = SN_FORCE, not available for some reason
	# See https://hex-rays.com/products/ida/support/idadoc/203.shtml
	set_name(addr, "type_" + type_str.decode(errors="replace")[:20], SN_NOCHECK | 0x800)
	return True





def main5():
    
    # Import the required IDA structures if necessary
    if idc.get_struc_id("golang_type") == idaapi.BADADDR:
        idc.parse_decls(C_HEADER, idaapi.PT_TYP)

    # Find all places in the binary where there is type information
    addresses  = find_type_structures("runtime.newobject")
    addresses |= find_type_structures("runtime.makechan", search_len=30)
    addresses |= find_type_structures("runtime.makemap", search_len=30)
    addresses |= find_type_structures("runtime.mapiterinit", search_len=30)
    addresses |= find_type_structures("runtime.makeslice", search_len=30)

    # Parse type information
    for t in addresses:
        if not parse_type(t):
            break  # Stop on first fatal error

if __name__ == "__main__":
    main5()


```

`Binoculars/function/GoParse/function_discovery_and_renaming.py`:

```py
'''
    Refactoring Tim Strazzere's Golang Loader Assist
    Split full function discovery, function renaming, and function ptr renaming
'''

from idautils import *
from idc import *
import idaapi
import ida_segment
import sys
import string
import ida_funcs

#
# Constants
#


GO112_MAGIC = 0xfffffffb
GO116_MAGIC = 0xfffffffa
GO118_MAGIC = 0xfffffff0
GO120_MAGIC = 0xfffffff1

DEBUG = False
def info(formatted_string):
    print(formatted_string)

def error(formatted_string):
    print('ERROR - %s' % formatted_string)

def debug(formatted_string):
    if DEBUG:
        print('DEBUG - %s' % formatted_string)



def _get_seg(possible_seg_names):
    for seg_name in possible_seg_names:
        seg = ida_segment.get_segm_by_name(seg_name)
        if seg:
            return seg

    return None

def _get_seg_from_rdata(possible_seg_names):
    for seg_name in possible_seg_names:
        for ea, name in Names():
            if name == seg_name:
                return ea

    return None

def get_text_seg():
    #   .text found in PE & ELF binaries, __text found in macho binaries
    return _get_seg(['.text', '__text'])

def get_gopclntab_seg():
    # .gopclntab found in (older) PE & ELF binaries, __gopclntab found in macho binaries,
    # runtime.pclntab in .rdata for newer PE binaries
    # JAGS -- MODIFIED TO CREATE GOPCLNTAB segment if it's not already there
    seg = _get_seg_from_rdata(['runtime.pclntab'])

    if seg is None:
        seg =  _get_seg(['.gopclntab', '__gopclntab'])
    
    return seg



# ************************************************************************************************************************************************
# ************************************************************************************************************************************************
# mov     large dword ptr ds:1003h, 0 # most I've seen
# mov     qword ptr ds:1003h, 0 # some

def is_simple_wrapper(addr):
    if idc.print_insn_mnem(addr) == 'xor' and idc.print_operand(addr, 0) == 'edx' and  idc.print_operand(addr, 1) == 'edx':
        addr = ida_search.find_code(addr, SEARCH_DOWN)
        if idc.print_insn_mnem(addr) == 'jmp' and idc.print_operand(addr, 0) == 'runtime_morestack':
            return True

    return False

def create_runtime_ms():
    debug('Attempting to find runtime_morestack function for hooking on...')

    text_seg = get_text_seg()
    if text_seg is None:
        debug('Failed to get text segment')
        return None

    #   Opcodes for "mov     large dword ptr ds:1003h, 0", binary search is faster than text search
    opcodes = 'c7 05 03 10 00 00 00 00 00 00'
    if idaapi.get_inf_structure().is_64bit():
        #   Opcodes for "mov     qword ptr ds:dword_1000+3, 0"
        opcodes = '48 c7 04 25 03 10 00 00 00 00 00 00'

    runtime_ms_end = idaapi.find_binary(text_seg.start_ea, text_seg.end_ea, opcodes, 0, SEARCH_DOWN)
    if runtime_ms_end == BADADDR:
        debug('Failed to find opcodes associated with runtime_morestack: %s' % opcodes)
        return None

    runtime_ms = idaapi.get_func(runtime_ms_end)
    if runtime_ms is None:
        debug('Failed to get runtime_morestack function from address @ 0x%x' % runtime_ms_end)
        return None

    if idc.set_name(runtime_ms.start_ea, "runtime_morestack", SN_PUBLIC):
        debug('Successfully found runtime_morestack')
    else:
        debug('Failed to rename function @ 0x%x to runtime_morestack' % runtime_ms.start_ea)

    return runtime_ms

def traverse_xrefs(func):
    func_created = 0

    if func is None:
        return func_created

    # First
    func_xref = idaapi.get_first_cref_to(func.start_ea)
    # Attempt to go through crefs
    while func_xref != BADADDR:
        # See if there is a function already here
        if idaapi.get_func(func_xref) is None:
            # Ensure instruction bit looks like a jump
            func_end = ida_search.find_code(func_xref, SEARCH_DOWN)
            if idc.print_insn_mnem(func_end) == "jmp":
                # Ensure we're jumping back "up"
                func_start = idc.get_operand_value(func_end, 0)
                if func_start < func_xref:
                    if ida_funcs.add_func(func_start, func_end):
                        func_created += 1
                    else:
                        # If this fails, we should add it to a list of failed functions
                        # Then create small "wrapper" functions and backtrack through the xrefs of this
                        error('Error trying to create a function @ 0x%x - 0x%x' %(func_start, func_end))
        else:
            xref_func = idaapi.get_func(func_xref)
            # Simple wrapper is often runtime_morestack_noctxt, sometimes it isn't though...
            if is_simple_wrapper(xref_func.start_ea):
                debug('Stepping into a simple wrapper')
                func_created += traverse_xrefs(xref_func)
            if idaapi.get_func_name(xref_func.start_ea) is not None and 'sub_' not in idaapi.get_func_name(xref_func.start_ea):
                debug('Function @0x%x already has a name of %s; skipping...' % (func_xref, idaapi.get_func_name(xref_func.start_ea)))
            else:
                debug('Function @ 0x%x already has a name %s' % (xref_func.start_ea, idaapi.get_func_name(xref_func.start_ea)))

        func_xref = idaapi.get_next_cref_to(func.start_ea, func_xref)

    return func_created

def find_func_by_name(name):
    text_seg = get_text_seg()
    if text_seg is None:
        return None

    for addr in Functions(text_seg.start_ea, text_seg.end_ea):
        if name == idaapi.get_func_name(addr):
            return idaapi.get_func(addr)

    return None

def runtime_init():
    func_created = 0

    if find_func_by_name('runtime_morestack') is not None:
        func_created += traverse_xrefs(find_func_by_name('runtime_morestack'))
        func_created += traverse_xrefs(find_func_by_name('runtime_morestackc'))
        func_created += traverse_xrefs(find_func_by_name('runtime_morestack_noctxt'))
    else:
        runtime_ms = create_runtime_ms()
        func_created = traverse_xrefs(runtime_ms)


    return func_created



# ************************************************************************************************************************************************
# ************************************************************************************************************************************************
def create_pointer(addr, force_size=None):
    if force_size != 4 and (idaapi.get_inf_structure().is_64bit() or force_size == 8):
        ida_bytes.create_data(addr, FF_QWORD, 8, ida_idaapi.BADADDR)
        return idc.get_qword(addr), 8
    else:
        ida_bytes.create_data(addr, FF_DWORD, 4, ida_idaapi.BADADDR)
        return idc.get_wide_dword(addr), 4

STRIP_CHARS = [ '(', ')', '[', ']', '{', '}', ' ', '"' ]
REPLACE_CHARS = ['.', '*', '-', ',', ';', ':', '/', '\xb7' ]
def clean_function_name(name):
    name = name.decode("utf-8") 
    # Kill generic 'bad' characters
    clean_name = ""
    for c in name:
        if c not in string.printable or c in STRIP_CHARS:
            continue
        elif c in REPLACE_CHARS:
            clean_name += "_"
        else:
            clean_name += c    
    return clean_name

class _GoPclnTab():
    def __init__(self, start_ea, offset_funcdata, offset_nametab, functab_data_size=None):
        self.addr = start_ea
        self.magic = idaapi.get_dword(self.addr)
        # Partially Adapted from Akamai's script for the Panchan cryptojacker
        # https://github.com/akamai/akamai-security-research/blob/main/malware/panchan/function_discovery_and_renaming.py
        # Copyright 2022 Akamai Technologies Inc.
        self.ptr_size = idaapi.get_byte(self.addr + 7)
        
        self.functab_data_size =  functab_data_size if functab_data_size is not None else self.ptr_size
        tab_offsets_ea = self.addr + 8
        self.nfunctab = create_pointer(tab_offsets_ea, self.ptr_size)[0]

        self.text_start_ea, _ = create_pointer(tab_offsets_ea + 2 * self.ptr_size, self.ptr_size)

        if not idaapi.is_loaded(self.text_start_ea): # Sometimes, the value in the pcln tab isn't a valid adress
            self.text_start_ea = get_text_seg()

        self.funcnametab_ea = self.addr + create_pointer(tab_offsets_ea + offset_nametab * self.ptr_size, self.ptr_size)[0]
        self.funcdatatab_ea = self.addr + create_pointer(tab_offsets_ea + offset_funcdata * self.ptr_size, self.ptr_size)[0]
        self.cutab_ea = self.addr + create_pointer(tab_offsets_ea + 4 * self.ptr_size, self.ptr_size)[0]

    def _get_func_addr(self, idx):
        return create_pointer(self.funcdatatab_ea + 2 * idx * self.functab_data_size, self.ptr_size)[0]

    def _get_funcdata_ea(self, idx):
        return self.funcdatatab_ea + create_pointer(self.funcdatatab_ea + (2 * idx + 1) * self.functab_data_size, self.ptr_size)[0]

    def _get_func_name_ea(self, idx):
        funcdata_ea = self._get_funcdata_ea(idx)
        return self.funcnametab_ea + idaapi.get_dword(funcdata_ea + self.functab_data_size)

    def enumerate_functions(self):
        for idx in range(self.nfunctab):
            func_addr = self._get_func_addr(idx)
            func_name_ea = self._get_func_name_ea(idx)
            try:
                func_name = ida_bytes.get_strlit_contents(func_name_ea, -1, STRTYPE_C)
            except:
                info("No name found for function at 0x%x" % func_addr)
                continue
            yield func_addr, func_name

class GoPclnTab12(_GoPclnTab):
    def __init__(self, start_ea):
        super().__init__(start_ea, 0, 0)
        self.funcdatatab_ea = self.addr + 8 + self.ptr_size
        self.funcnametab_ea = self.addr
        self.cutab_ea = None

    def _get_funcdata_ea(self, idx):
        return self.addr + create_pointer(self.funcdatatab_ea + (2 * idx + 1) * self.functab_data_size, self.ptr_size)[0]

class GoPclnTab116(_GoPclnTab):
    def __init__(self, start_ea):
        super().__init__(start_ea, 6, 2)

class GoPclnTab118(_GoPclnTab):
    def __init__(self, start_ea):
        super().__init__(start_ea, 7, 3, 4)

    # Starting from Go 1.18, the function address in functab is stored as an
    # offset from the beginning of .text
    def _get_func_addr(self, idx):
        return self.text_start_ea + idaapi.get_dword(self.funcdatatab_ea + 2 * idx * self.functab_data_size)

    def _get_funcdata_ea(self, idx):
        return self.funcdatatab_ea + idaapi.get_dword(self.funcdatatab_ea + (2 * idx + 1) * self.functab_data_size)

# Properly parse the pclntb depending on Golang version
def parse_pcln_1(start_ea):
    magic = idaapi.get_dword(start_ea)
    
    if magic == GO120_MAGIC:    ## Go 120 has difference Magic, but executed same with GO118
        return GoPclnTab118(start_ea)
    elif magic == GO118_MAGIC:
        return GoPclnTab118(start_ea)
    elif magic == GO116_MAGIC:
        return GoPclnTab116(start_ea)
    else:
        return GoPclnTab12(start_ea)

def parse_pcln_2():

    def generator(start_ea):
        functions = [
            GoPclnTab118,
            GoPclnTab116,
            GoPclnTab12
        ]
        for func_class in functions:
            yield func_class(start_ea)
    
    gen = None
    
    def inner(start_ea):
        nonlocal gen
        if gen is None:
            gen = generator(start_ea)
        try:
            return next(gen)
        except StopIteration:
            return None

    return inner

def rename_func(pcln):
    renamed = 0
    for func_ea, func_name in pcln.enumerate_functions():
        if func_name and func_ea:
            clean_func_name = clean_function_name(func_name)
            debug('Going to remap function at 0x%x with %s - cleaned up as %s' % (func_ea, func_name, clean_func_name))
            if idaapi.get_func_name(func_ea) is not None:
                try:
                    idc.set_name(func_ea, clean_func_name)
                except Exception as e:
                    error('clean_func_name error %s, exception' % (clean_func_name, e))
                    continue
                renamed += 1
        else:
            break
    return renamed

def renamer_init():
    renamed = 0
    gopclntab = get_gopclntab_seg()

    if gopclntab is not None:
        start_ea = 0
        if isinstance(gopclntab, int):
            start_ea = gopclntab
        else:
            start_ea = gopclntab.start_ea
            
        pcln = parse_pcln_1(start_ea)
        
        renamed = rename_func(pcln)
        parse_pcln_2_func = parse_pcln_2()
        while not renamed:
            pcln = parse_pcln_2_func(start_ea)
            print("pcln: ",pcln)
            if pcln is None:
                break
            renamed = rename_func(pcln)     
    return renamed


# ************************************************************************************************************************************************
# ************************************************************************************************************************************************
# Function pointers are often used instead of passing a direct address to the
# function -- this function names them based off what they're currently named
# to ease reading
# lea     rax, main_GetExternIP_ptr <-- pointer to actual function
# mov     [rsp+1C0h+var_1B8], rax <-- loaded as arg for next function
# call    runtime_newproc <-- function is used inside a new process

def pointer_renamer():
    renamed = 0

    text_seg = get_text_seg()
    if text_seg is None:
        debug('Failed to get text segment')
        return renamed

    for addr in Functions(text_seg.start_ea, text_seg.end_ea):
        name = idc.get_func_name(addr)

        # Look at data xrefs to the function - find the pointer that is located in .rodata
        data_ref = idaapi.get_first_dref_to(addr)
        while data_ref != BADADDR:
            if 'rodata' in get_segm_name(data_ref):
                # Only rename things that are currently listed as an offset; eg. off_9120B0
                if 'off_' in ida_name.get_ea_name(data_ref):
                    if idc.set_name(data_ref, ('ptr_%s' % name)):
                        renamed += 1
                    else:
                        error('error attempting to name pointer @ 0x%02x for %s' % (data_ref, name))

            data_ref = idaapi.get_next_dref_to(addr, data_ref)

    return renamed



# ************************************************************************************************************************************************
# ************************************************************************************************************************************************
def main2():

    # This should be run before the renamer, as it will find and help define more functions
    func_added = runtime_init()
    print('[info] Found and successfully created %d functions!' % func_added)

    # Should be run after the function initializer,
    renamed = renamer_init()
    print('[info] Found and successfully renamed %d functions!' % renamed)

    # Attempt to rename all function pointers after we have all the functions and proper function names
    pointers_renamed = pointer_renamer()
    print('[info] Found and successfully renamed %d function pointers!' % pointers_renamed)

if __name__ == "__main__":
    main2()

```

`Binoculars/function/GoParse/recreate_pclntab.py`:

```py
import ida_bytes
import ida_idaapi
import ida_loader
import idaapi
import struct
import ida_search
import idc
import idautils
import ida_funcs


start_ea = idaapi.get_imagebase()
end_ea = idaapi.get_inf_structure().max_ea
is_64bit = idaapi.get_inf_structure().is_64bit()


# 验证大小端
info = idaapi.get_inf_structure()
try:
    is_be = info.is_be()
except:
    is_be = info.mf
v12magic = "FF FF FF FB 00 00" if is_be else "FB FF FF FF 00 00"
v116magic = "FF FF FF FA 00 00" if is_be else "FA FF FF FF 00 00"
v118magic = "FF FF FF F0 00 00" if is_be else "F0 FF FF FF 00 00"
v120magic = "FF FF FF F1 00 00" if is_be else "F1 FF FF FF 00 00"

# 输出
DEBUG = False
def info(formatted_string):
    print("[info] " + formatted_string)

def error(formatted_string):
    print('[ERROR] %s' % formatted_string)

def debug(formatted_string):
    if DEBUG:
        print('[DEBUG] %s' % formatted_string)


def find_pcHeader_without_magic(textStartflag):
    
    if textStartflag:    info("Scanning for pcHeader between 0x%X and 0x%X" % (start_ea, end_ea))
    else:  info("Fuzzy scanning for pcHeader between 0x%X and 0x%X" % (start_ea, end_ea))

    # 根据架构，确定指针大小

    if is_64bit:
        ptr_size = 8
        ptr_format = 'Q'  # unsigned long long (8 bytes)
        int_format = 'q'  # signed long long (8 bytes)
    else:
        ptr_size = 4
        ptr_format = 'I'  # unsigned int (4 bytes)
        int_format = 'i'  # signed int (4 bytes)

    # pcHeader 结构的格式
    # uint32 magic          (4 bytes)
    # uint8 pad1            (1 byte)
    # uint8 pad2            (1 byte)
    # uint8 minLC           (1 byte)
    # uint8 ptrSize         (1 byte)
    # int nfunc             (4 bytes in 32-bit, 8 bytes in 64-bit)
    # uint nfiles           (4 bytes in 32-bit, 8 bytes in 64-bit)
    # uintptr textStart     (4 bytes in 32-bit, 8 bytes in 64-bit)
    # uintptr funcnameOffset
    # uintptr cuOffset
    # uintptr filetabOffset
    # uintptr pctabOffset
    # uintptr pclnOffset

    # 计算需要的填充字节数，以确保 nfunc 对齐
    if is_64bit:
        padding = ''
        pc_header_format = '<I2B2B' + padding + int_format + 'Q' + ptr_format * 6
    else:
        pc_header_format = '<I2B2B' + int_format + 'I' + ptr_format * 6

    pc_header_size = struct.calcsize(pc_header_format)

    # 遍历整个二进制文件
    ea = start_ea
    while ea + pc_header_size < end_ea:
        data = ida_bytes.get_bytes(ea, pc_header_size)
        if not data or len(data) < pc_header_size:
            ea += 1
            continue

        fields = struct.unpack(pc_header_format, data)

        pcHeader = {
            'magic':          fields[0],
            'pad1':           fields[1],
            'pad2':           fields[2],
            'minLC':          fields[3],
            'ptrSize':        fields[4],
            'nfunc':          fields[5],
            'nfiles':         fields[6],
            'textStart':      fields[7],
            'funcnameOffset': fields[8],
            'cuOffset':       fields[9],
            'filetabOffset':  fields[10],
            'pctabOffset':    fields[11],
            'pclnOffset':     fields[12],
        }

        # 验证字段的合理性
        status = validate_pcHeader(pcHeader, ea, textStartflag=textStartflag)
        if status:
            info("Possible pcHeader found at 0x%X" % ea)
            for key, value in pcHeader.items():
                if isinstance(value, int):
                    print(f"  {key}: {value} (0x{value:X})")
                else:
                    print(f"  {key}: {value}")
                    
            # 如果需要，可以返回或记录找到的 pcHeader 位置
            return ea, pcHeader

        ea += 1  # 逐字节移动，继续搜索

    error("Failed to find pcHeader without relying on magic value.")
    return None, None

def validate_pcHeader(pcHeader, ea, textStartflag):

    # 验证 magic 字段，应为 0xFFFFFFF1
    # if pcHeader['magic'] != 0xFFFFFFF1:
    #     return False

    # 验证 pad1 和 pad2，一般为 0
    if pcHeader['pad1'] != 0 or pcHeader['pad2'] != 0:
        return False

    # 验证 minLC，一般为 1、2 或 4
    if pcHeader['minLC'] not in (1, 2, 4):
        return False

    # 验证 ptrSize，应为 4 或 8
    if pcHeader['ptrSize'] not in (4, 8):
        return False

    # 验证 nfunc，为正整数，且不过大
    if pcHeader['nfunc'] <= 0 or pcHeader['nfunc'] > 100000:
        return False

    # 验证 nfiles，为非负整数，且不过大
    if pcHeader['nfiles'] <= 0 or pcHeader['nfiles'] > 100000:
        return False

    # 验证偏移量字段，应为正整数，且不过大
    offset_fields = ['funcnameOffset', 'cuOffset', 'filetabOffset', 'pctabOffset', 'pclnOffset']
    
    for field in offset_fields:
        value = pcHeader[field]
        if value <= 0 or value > (0xFFFFFFFFFFFFFFFF if is_64bit else 0xFFFFFFFF):
            return False

    # 验证偏移量是否在合理范围内
    for field in offset_fields:
        value = pcHeader[field]
        offset_addr = ea + value
        if not ea <= offset_addr <= idaapi.get_inf_structure().max_ea:
            return False
            
    # 验证 textStart，应在合法的地址范围内（模糊匹配）
    textStart = pcHeader['textStart']
    if textStartflag:
        if not start_ea <= textStart <= end_ea:
            return False

    return True
    
def recreate_pclntab(ea):
    if is_64bit:
        get_content = idc.get_qword
        multiplier = 8
    else:
        get_content = ida_bytes.get_dword
        multiplier = 4
    
    exists = False
    for seg in idautils.Segments():
        name = idaapi.get_segm_name(idaapi.getseg(seg))
        if "gopclntab" in name:
            exists = True
            info("GoPCLNTab Found: %s" % name)
            break    
    halt = False
    empty_counter = 0
    seg_start = ea
    while (not halt):
        if empty_counter >= 3:
            seg_end = ea
            info("Effective .gopclntab seg_end: %s" % str(hex(seg_end)))
            halt = True
        offset_addr = get_content(ea)
        if offset_addr == 0:
            empty_counter += 1
            continue
        func_name = idc.get_func_name(offset_addr)
        if func_name == "":
            ida_bytes.del_items(offset_addr)
            idc.create_insn(offset_addr)
            ida_funcs.add_func(offset_addr)
        ea = ea + multiplier

    if not exists:
        if seg_end > seg_start:
            print("[info] Creating .gopclntab: ", hex(seg_start), hex(seg_end))
            idaapi.add_segm(0, seg_start, seg_end, ".gopclntab", "DATA")


def find_magic(magic):
    ea = ida_search.find_binary(start_ea, end_ea, magic, 16, ida_search.SEARCH_DOWN)
    if ea == idaapi.BADADDR:
        return idaapi.BADADDR
    pc, ptr = idc.get_bytes(ea + 6, 2)
    if pc not in [1,2,4]:
        return idaapi.BADADDR
    if ptr not in [4,8]:
        return idaapi.BADADDR
    return ea
    
    
def main1():

    info("Parsing using a generic method")

    ea = find_magic(v12magic)
    if ea == idaapi.BADADDR:
        ea = find_magic(v116magic)

    if ea == idaapi.BADADDR:
        ea = find_magic(v118magic)

    if ea == idaapi.BADADDR:
        ea = find_magic(v120magic)
        
    if ea == idaapi.BADADDR:
        error("Cannot use generic methods for parsing")
        info("Parsing using structure traversal")
        pcHeader_ea, pcHeader = find_pcHeader_without_magic(textStartflag=True)
        if pcHeader:
            recreate_pclntab(pcHeader_ea)
        else:
            error("Cannot use structure traversal to parse")
            info("Parsing using structure traversal")
            pcHeader_ea, pcHeader = find_pcHeader_without_magic(textStartflag=False)
            if pcHeader:
                recreate_pclntab(pcHeader_ea)
            else:
                error("pcHeader not found.")
    else:
        recreate_pclntab(ea)
        


if __name__ == "__main__":
    main1()    


```

`Binoculars/function/GoParse/string_cast.py`:

```py
'''
Fix string casts by reference to the loading functions
Refactored from Tim Strazzere's GolangLoaderAssist

Fixed:
>Added routine to undefine strings that are too long and thereby suspect before attempting to create new strings based on string loading routines
>Added logic to undefine items in the target offset when retrying string casting, drastically better results
>Added sanity checks for intended string address

Needs:
>Better string load heuristics
'''
from idautils import *
from idc import *
import idaapi
import ida_bytes
import idautils
import ida_segment
import sys
import string

DEBUG = False
def info(formatted_string):
    print("[info] " + formatted_string)

def error(formatted_string):
    print('[ERROR] %s' % formatted_string)

def debug(formatted_string):
    if DEBUG:
        print('[DEBUG] %s' % formatted_string)



#
# Function defining methods
#

def get_text_seg():
    #   .text found in PE & ELF binaries, __text found in macho binaries
    return _get_seg(['.text', '__text'])

def get_gopclntab_seg():
    seg = _get_seg_from_rdata(['runtime.pclntab'])

    if seg is None:
        seg =  _get_seg(['.gopclntab', '__gopclntab'])

    return seg

def _get_seg(possible_seg_names):
    for seg_name in possible_seg_names:
        seg = ida_segment.get_segm_by_name(seg_name)
        if seg:
            return seg

    return None

def _get_seg_from_rdata(possible_seg_names):
    for seg_name in possible_seg_names:
        for ea, name in Names():
            if name == seg_name:
                return ea

    return None

#Undefine obviously bad string definitions:
def undefine_string(ea):
    ida_bytes.del_items(ea)
    debug("Deleted string @ offset %s" % hex(ea))   

def undefine_long_strings(len_boundary):
    counter = 0
    for s in idautils.Strings():
        if s.length > len_boundary:
            undefine_string(s.ea)
            counter += 1
    return counter


#
# String defining fuctionality
#

# Indicators of string loads
# mov     ebx, offset aWire ; "wire" # Get string
# mov     [esp], ebx
# mov     dword ptr [esp+4], 4 # String length

# mov     ebx, offset unk_8608FD5 # Get string
# mov     [esp+8], ebx
# mov     dword ptr [esp+0Ch], 0Eh # String length

# mov     ebx, offset unk_86006E6 # Get string
# mov     [esp+10h], ebx
# mov     dword ptr [esp+14h], 5 # String length

# mov     ebx, 861143Ch
# mov     dword ptr [esp+0F0h+var_E8+4], ebx
# mov     [esp+0F0h+var_E0], 19h

# Found in newer versions of golang binaries

# lea     rax, unk_8FC736
# mov     [rsp+38h+var_18], rax
# mov     [rsp+38h+var_10], 1Dh

# lea     rdx, unk_8F6E82
# mov     [rsp+40h+var_38], rdx
# mov     [rsp+40h+var_30], 13h

# lea     eax, unk_82410F0
# mov     [esp+94h+var_8C], eax
# mov     [esp+94h+var_88], 2

# JAG-S (10.19.2021): need to add support for indirect string loads (go v1.17)
# lea     rax, unk_10B1E80 #offset str len
# mov     qword ptr [rsp+58h+var_18], rax
# lea     rax, off_10EAAC0 #offset to offset of str

# Currently it's normally ebx, but could in theory be anything - seen ebp
VALID_REGS = ['eax', 'ebx', 'ebp', 'rax', 'rcx', 'r10', 'rdx']

# Currently it's normally esp, but could in theory be anything - seen eax
VALID_DEST = ['esp', 'eax', 'ecx', 'edx', 'rsp']

# JAG-S (10.10.2021): This logic is from GolangLoaderAssist. Desperately needs to be broken up, refactored, and improved <--- HELP HERE
def is_string_load(addr):
    patterns = []
    # Check for first parts instruction and what it is loading -- also ignore function pointers we may have renamed
    if (idc.print_insn_mnem(addr) != 'mov' and idc.print_insn_mnem(addr) != 'lea') and (idc.get_operand_type(addr, 1) != 2 or idc.get_operand_type(addr, 1) != 5) or idc.print_operand(addr, 1)[-4:] == '_ptr':
        return False

    # Validate that the string offset actually exists inside the binary
    if get_segm_name(idc.get_operand_value(addr, 1)) is None:
        return False

    # Could be unk_, asc_, 'offset ', XXXXh, ignored ones are loc_ or inside []
    if idc.print_operand(addr, 0) in VALID_REGS and not ('[' in idc.print_operand(addr, 1) or 'loc_' in idc.print_operand(addr, 1)) and (('offset ' in idc.print_operand(addr, 1) or 'h' in idc.print_operand(addr, 1)) or ('unk' == idc.print_operand(addr, 1)[:3])):
        from_reg = idc.print_operand(addr, 0)
        # Check for second part
        addr_2 = ida_search.find_code(addr, SEARCH_DOWN)
        try:
            dest_reg = idc.print_operand(addr_2, 0)[idc.print_operand(addr_2, 0).index('[') + 1:idc.print_operand(addr_2, 0).index('[') + 4]
        except ValueError:
            return False
        if idc.print_insn_mnem(addr_2) == 'mov' and dest_reg in VALID_DEST and ('[%s' % dest_reg) in idc.print_operand(addr_2, 0) and idc.print_operand(addr_2, 1) == from_reg:
            # Check for last part, could be improved
            addr_3 = ida_search.find_code(addr_2, SEARCH_DOWN)
            # idc.get_operand_type 1 is a register, potentially we can just check that idc.get_operand_type returned 5?
            if idc.print_insn_mnem(addr_3) == 'mov' and (('[%s+' % dest_reg) in idc.print_operand(addr_3, 0) or idc.print_operand(addr_3, 0) in VALID_DEST) and 'offset ' not in idc.print_operand(addr_3, 1) and 'dword ptr ds' not in idc.print_operand(addr_3, 1) and idc.get_operand_type(addr_3, 1) != 1 and idc.get_operand_type(addr_3, 1) != 2 and idc.get_operand_type(addr_3, 1) != 4:
                try:
                    dumb_int_test = idc.get_operand_value(addr_3, 1)
                    if dumb_int_test > 0 and dumb_int_test < sys.maxsize:
                        return True
                except ValueError:
                    return False

    return False

def create_string(addr, string_len):
    if get_segm_name(addr) is None:
        debug('Cannot load a string which has no segment - not creating string @ 0x%02x' % addr)
        return False

    debug('Found string load @ 0x%x with length of %d' % (addr, string_len))
    # This may be overly aggressive if we found the wrong area...
    if idc.get_str_type(addr) is not None and ida_bytes.get_strlit_contents(addr, string_len, STRTYPE_C) is not None and len(ida_bytes.get_strlit_contents(addr, string_len, STRTYPE_C)) != string_len:
        debug('It appears that there is already a string present @ 0x%x' % addr)
        undefine_string(addr)

    if ida_bytes.get_strlit_contents(addr, string_len, STRTYPE_C) is None and ida_bytes.create_strlit(addr, string_len, STRTYPE_C):
        return True
    else:
        # If something is already partially analyzed (incorrectly) we need to ida_bytes.del_items it
        undefine_string(addr)
        if ida_bytes.create_strlit(addr, string_len, STRTYPE_C):
            return True
        debug('Unable to make a string @ 0x%x with length of %d' % (addr, string_len))

    return False

def create_offset(addr):
    if ida_offset.op_plain_offset(addr, 1, 0):
        return True
    else:
        debug('Unable to make an offset for string @ 0x%x ' % addr)

    return False

def strings_init():
    strings_added = 0
    retry = []
    text_seg = get_text_seg()
    if text_seg is None:
        debug('Failed to get text segment')
        return strings_added

    # This may be inherently flawed as it will only search for defined functions
    # and as of IDA Pro 6.95 it fails to autoanalyze many GO functions, currently
    # this works well since we redefine/find (almost) all the functions prior to
    # this being used. Could be worth a strategy rethink later one or on diff archs

    for addr in Functions(text_seg.start_ea, text_seg.end_ea):
        name = idc.get_func_name(addr)

        end_addr = next(Chunks(addr))[1]
        if end_addr < addr:
            error('Unable to find good end for the function %s' % name)
            pass

        debug('Found function %s starting/ending @ 0x%x 0x%x' %  (name, addr, end_addr))

        while addr <= end_addr:
            if is_string_load(addr):
                if 'rodata' not in get_segm_name(addr) and 'text' not in get_segm_name(addr):
                    debug('Should a string be in the %s section?' % get_segm_name(addr))
                string_addr = idc.get_operand_value(addr, 1)
                addr_3 = ida_search.find_code(ida_search.find_code(addr, SEARCH_DOWN), SEARCH_DOWN)
                string_len = idc.get_operand_value(addr_3, 1)
                if create_string(string_addr, string_len):
                    if create_offset(addr):
                        strings_added += 1
                else:
                    # There appears to be something odd that goes on with IDA making some strings, always works
                    # the second time, so lets just force a retry...
                    if string_len < 100:
                        retry.append((addr, string_addr, string_len))

                # Skip the extra mov lines since we know it won't be a load on any of them
                addr = ida_search.find_code(addr_3, SEARCH_DOWN)
            else:
                addr = ida_search.find_code(addr, SEARCH_DOWN)

    for instr_addr, string_addr, string_len in retry:
        try:
            if string_addr > ida_segment.get_last_seg().end_ea:
                continue
        except:
            debug("String retry addr check fallthrough")
        if create_string(string_addr, string_len):
            if create_offset(instr_addr):
                strings_added += 1
        else:
            error('FAILED-RETRY : Unable to make a string @ 0x%x with length of %d for usage in function @ 0x%x' % (string_addr, string_len, instr_addr))
    return strings_added

def main4():
# Attempt to find all string loading idioms

    #Prep
    undefinedCount = undefine_long_strings(50) #Feel free to fiddle with len
    info('Undefined %d suspected bad strings' % undefinedCount)
    strings_added = strings_init()
    info('Found and successfully created %d strings!' % strings_added)


if __name__ == "__main__":
    main4()


```

`Binoculars/function/GoParseFunc.py`:

```py
import idaapi
import ida_kernwin
import threading
from Binoculars.function.GoParse.recreate_pclntab import main1 
from Binoculars.function.GoParse.function_discovery_and_renaming import main2 
from Binoculars.function.GoParse.string_cast import main4
from Binoculars.function.GoParse.extract_types import main5
from PyQt5 import QtWidgets

class ParseGoHandler(idaapi.action_handler_t):
    
    def __init__(self, option):
        idaapi.action_handler_t.__init__(self)
        self.option = option
        
    def activate(self, ctx):
        result = QtWidgets.QMessageBox.question(
            None,
            "Confirm Execution",
            "The script is about to run. Do you want to continue?",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
        )
        if result == QtWidgets.QMessageBox.Yes:
            running_dialog = QtWidgets.QMessageBox(
                QtWidgets.QMessageBox.Information,
                "Running",
                "Operation is running, please wait...",
                QtWidgets.QMessageBox.Ok
            )
            running_dialog.setStandardButtons(QtWidgets.QMessageBox.Close)

            running_dialog.show()

            QtWidgets.QApplication.processEvents()

            try:
                if "1." in self.option:
                    main1()
                elif "2." in self.option:
                    main2()
                elif "3." in self.option:
                    main4()
                elif "4." in self.option:
                    main5()
            finally:
                running_dialog.close()
        else:
            print("[info] Operation was canceled by the user.")
        return 1  

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS
        
```

`Binoculars/function/Handle.py`:

```py
import ida_kernwin
import ida_hexrays
import ida_bytes
import ida_ida
import idc
import idautils
import ida_funcs
import ida_entry
import idaapi
import ida_gdl
import ida_lines
import ida_idaapi
import ida_nalt
import ida_typeinf
import ida_xref
import functools
import ida_name
import ida_lines
import re
import json
import struct
from typing import Any, Callable, get_type_hints, TypedDict, Optional, Annotated, TypeVar, Generic
from pydantic import Field
T = TypeVar("T")



ai_commands = {}
def ai_command(func):  
    params_schema = {
        "name": func.__name__,
        "description": func.__doc__.strip(),
        "parameters": {
            "type": "object",
            "properties": {},
            "required": []
        }
    }
    for name, param in func.__annotations__.items():
        if name == 'return':
            continue
        if hasattr(param, '__metadata__'):
            desc = param.__metadata__[0].description
            params_schema['parameters']['properties'][name] = {
                "type": param.__origin__.__name__,
                "description": desc
            }
            if param.__origin__ != Optional:
                params_schema['parameters']['required'].append(name)
    ai_commands[func.__name__] = params_schema
    return func

####################导入导出相关##############################
from typing import Optional, TypedDict, List
from pydantic import Field

class ImportItem(TypedDict):
    ea: str
    name: str
    module: str

class PagedImports(TypedDict):
    total: int
    next_offset: Optional[int]
    items: list[ImportItem]
    
class ExportItem(TypedDict):
    address: str
    name: Optional[str]
    ordinal: Optional[int]

class PagedExports(TypedDict):
    total: int
    items: List[ExportItem]

##################################################

class FuncHandle(object): 
    def __init__(self, assistant_widget):
        self.assistant_widget = assistant_widget
        
    def PrintOutput(self, output_str):
        self.assistant_widget.PrintOutput(output_str)
     
    @classmethod
    def get_ai_prompts(cls, format: str = "markdown"):
        if format == "markdown":
            return cls._generate_markdown()
        elif format == "json":
            return json.dumps(ai_commands, indent=2)
        elif format == "openai":
            return cls._generate_openai_schema()
        else:
            raise ValueError(f"Unsupported format: {format}")

    @classmethod
    def _generate_markdown(cls):
        output = ["## Available Commands"]
        for cmd,value in ai_commands.items():
          output.append(f"### `{value['name']}`")
          output.append(f"{value['description']}\n")
          output.append("**Parameters:**")
          for param, meta in value['parameters']['properties'].items():
            required = "(Required)" if param in value['parameters'].get('required', []) else "(Optional)"
            output.append(f"- `{param}`: {meta['description']} {required}")
          output.append("\n---")
        return "\n".join(output)
    
    @classmethod
    def _generate_openai_schema(cls):
        return [{
            "type": "function",
            "function": {
                "name": cmd["name"],
                "description": cmd["description"],
                "parameters": cmd["parameters"]
            }
        } for cmd in ai_commands.values()]
    
    @ai_command
    def do_nothing(self) -> str:
        """
        Do nothing. Use it when a series of tasks are completed.
        """
        return 
        
########################################################################
    class Metadata(TypedDict):
        path: str
        module: str
        base: str
        size: str
        md5: str
        sha256: str
        crc32: str
        filesize: str

    def get_image_size(self):
        try:
            info = idaapi.get_inf_structure()
            omin_ea = info.omin_ea
            omax_ea = info.omax_ea
        except AttributeError:
            import ida_ida
            omin_ea = ida_ida.inf_get_omin_ea()
            omax_ea = ida_ida.inf_get_omax_ea()
        # Bad heuristic for image size (bad if the relocations are the last section)
        image_size = omax_ea - omin_ea
        # Try to extract it from the PE header
        header = idautils.peutils_t().header()
        if header and header[:4] == b"PE\0\0":
            image_size = struct.unpack("<I", header[0x50:0x54])[0]
        return image_size
    
    # 获取当前 IDB 的元数据
    @ai_command
    def get_metadata(self) -> Metadata:
        """Get metadata about the current IDB"""
        # Fat Mach-O binaries can return a None hash:
        # https://github.com/mrexodia/ida-pro-mcp/issues/26
        def hash(f):
            try:
                return f().hex()
            except:
                return None
        return {
            "path": idaapi.get_input_file_path(),
            "module": idaapi.get_root_filename(),
            "base": hex(idaapi.get_imagebase()),
            "size": hex(self.get_image_size()),
            "md5": hash(ida_nalt.retrieve_input_file_md5),
            "sha256": hash(ida_nalt.retrieve_input_file_sha256),
            "crc32": hex(ida_nalt.retrieve_input_file_crc32()),
            "filesize": hex(ida_nalt.retrieve_input_file_size()),
        }
    
    class Function(TypedDict):
        start_address: int
        end_address: int
        name: str
        prototype: Optional[str]

    def get_prototype(self, fn: ida_funcs.func_t) -> Optional[str]:
        try:
            prototype: ida_typeinf.tinfo_t = fn.get_prototype()
            if prototype is not None:
                return str(prototype)
            else:
                return None
        except AttributeError:
            try:
                return idc.get_type(fn.start_ea)
            except:
                tif = ida_typeinf.tinfo_t()
                if ida_nalt.get_tinfo(tif, fn.start_ea):
                    return str(tif)
                return None
        except Exception as e:
            print(f"Error getting function prototype: {e}")
            return None


    def get_function(self, address: int, *, raise_error=True) -> Optional[Function]:
        fn = idaapi.get_func(address)
        if fn is None:
            if raise_error:
                raise IDAError(f"No function found at address {address}")
            return None

        try:
            name = fn.get_name()
        except AttributeError:
            name = ida_funcs.get_func_name(fn.start_ea)
        return {
            "address": fn.start_ea,
            "end_address": fn.end_ea,
            "name": name,
            "prototype": self.get_prototype(fn),
        }

        
    # 获取入口点
    @ai_command
    def get_entry_points(
        self
    ) -> list:
        """
        Get all entry points in the database
        """
        result = []
        for i in range(ida_entry.get_entry_qty()):
            ordinal = ida_entry.get_entry_ordinal(i)
            address = ida_entry.get_entry(ordinal)
            func = self.get_function(address, raise_error=False)
            if func is not None:
                result.append(func)
        return result
    
    # 获取当前地址
    def get_current_address(self) -> str:
        """Get the address currently selected by the user"""
        return hex(idaapi.get_screen_ea())
    
        
    def get_type_ea(self, ea):
        flag_types = []
        flags = ida_bytes.get_flags(ea)
        if idc.is_code(flags):
            flag_types.append("CODE")
        if idc.is_data(flags):
            flag_types.append("DATA")
        if idc.is_unknown(flags):
            flag_types.append("UNKNOWN")
        return f"Flags: {' | '.join(flag_types)}"
    
    # 确定给定地址处的数据类型和大小
    @ai_command
    def get_address_type(
        self,
        address: Annotated[str, Field(description="Hex address")]
    ) -> str:
        """
        Get the type of the address.
        """
        try:
            address = int(address, 16)
            flag_types = self.get_type_ea(address)
            size = idc.get_item_size(address)
            type_info = idc.get_type(address)
            if type_info:
                size_type = type_info
            else:
                size_type = {
                    1: "byte",
                    2: "word",
                    4: "dword",
                    8: "qword",
                    16: "oword"
                }.get(size, f"Unknown size ({size} bytes)")
            
            return f"Flags: {' | '.join(flag_types)}, Size: {size} bytes ({size_type})"
        except Exception as e:
            return f"Error: {str(e)}"
    
    # 列出二进制文件中所有段的权限和大小。
    @ai_command
    def get_segments(self) -> list:
        """List all segments in the binary with permissions and size."""
        segs = []
        for seg in idautils.Segments():
            s = idaapi.getseg(seg)
            segs.append({
                "name": idaapi.get_segm_name(s),
                "start": hex(s.start_ea),
                "end": hex(s.end_ea),
                "size": s.size(),
                "perms": f"{'R' if s.perm & idaapi.SEGPERM_READ else '-'}"
                         f"{'W' if s.perm & idaapi.SEGPERM_WRITE else '-'}"
                         f"{'X' if s.perm & idaapi.SEGPERM_EXEC else '-'}"
            })
        return segs
    
########################################################################函数

    
    # 列出所有函数
    @ai_command
    def list_functions(self) -> list[Function]:
        """List all functions in the database"""
        return [get_function(address) for address in idautils.Functions()]

    # 获取当前函数信息
    def get_current_function(self) -> dict[Function]:
        """Get the function currently selected by the user"""
        return self.get_function(idaapi.get_screen_ea())

    def refresh_decompiler_ctext(self, function_address: int):
        error = ida_hexrays.hexrays_failure_t()
        cfunc: ida_hexrays.cfunc_t = ida_hexrays.decompile_func(function_address, error, ida_hexrays.DECOMP_WARNINGS)
        if cfunc:
            cfunc.refresh_func_ctext()

    # 函数重命名
    @ai_command
    def rename_function(
        self,
        address: Annotated[str, Field(description="Hex address of the function to rename")],
        new_name: Annotated[str, Field(description="New name for the function")]
    ) -> str:
        """Rename a function"""
        try:
            function_address = int(address, 16)
            fn = idaapi.get_func(function_address)
            if not fn:
                return f"No function found at address {function_address}"
            if not idaapi.set_name(fn.start_ea, new_name):
               return f"Failed to rename function {fn.start_ea} to {new_name}"
            self.refresh_decompiler_ctext(fn.start_ea)
            return f"Successfully to rename function {fn.start_ea} to {new_name}"
        except Exception as e:
            return f"Error: {str(e)}"

    # 获取包含给定地址的函数的起始和结束地址
    @ai_command
    def get_function_start_end_address(
        self,
        address: Annotated[str, Field(description="Hex address")]
    ) -> dict:
        """
        Get the start and end address of the function at the specified address.
        """
        try:
            ea = int(address, 16)
            function = idaapi.get_func(ea)
            if function:
                return {
                    "start": hex(function.start_ea),
                    "end": hex(function.end_ea)
                }
            return {"error": f"No function at {hex(ea)}"}
        except Exception as e:
            return {"error": str(e)}
            
            
    def get_name_info(self):
        name_info = []
        for i in range(ida_name.get_nlist_size()):
            ea = ida_name.get_nlist_ea(i)
            name = ida_name.get_short_name(ea)
            name_info.append((name, hex(ea)))
        return name_info

    def search_name(self, keyword):        
        search_results = []
        
        functions = self.get_name_info()
        for name, ea in functions:
            if keyword.lower() in name.lower():
                search_results.append((name, ea))
        
        return search_results
    
    # 搜索名称中包含指定关键字的函数
    @ai_command
    def get_addresses_of_name(
        self,
        name: Annotated[str, Field(description="Search name")]
    ) -> list:
        """
        Search for a name as a parameter in ida name list and get all addresses with that name in the form of a list.
        """
        try:
            r = self.search_name(name)
            return r
        except Exception as e:
            return f"Error: {str(e)}"
    
    
    DEMANGLED_TO_EA = {}
    def create_demangled_to_ea_map(self):
        for ea in idautils.Functions():
            # Get the function name and demangle it
            # MNG_NODEFINIT inhibits everything except the main name
            # where default demangling adds the function signature
            # and decorators (if any)
            demangled = idaapi.demangle_name(
                idc.get_name(ea, 0), idaapi.MNG_NODEFINIT)
            if demangled:
                DEMANGLED_TO_EA[demangled] = ea
     
    def parse_address(self, address: str) -> int:
        try:
            return int(address, 0)
        except ValueError:
            for ch in address:
                if ch not in "0123456789abcdefABCDEF":
                    raise IDAError(f"Failed to parse address: {address}")
            raise IDAError(f"Failed to parse address (missing 0x prefix): {address}")
    
    # 通过函数名字获取函数
    @ai_command
    def get_function_by_name(
        self,
        name: Annotated[str, Field(description="Name of the function to get")]
    ) -> Function:
        """Get a function by its name"""
        function_address = idaapi.get_name_ea(idaapi.BADADDR, name)
        if function_address == idaapi.BADADDR:
            # If map has not been created yet, create it
            if len(DEMANGLED_TO_EA) == 0:
                self.create_demangled_to_ea_map()
            # Try to find the function in the map, else raise an error
            if name in DEMANGLED_TO_EA:
                function_address = DEMANGLED_TO_EA[name]
            else:
                raise IDAError(f"No function found with name {name}")
        return self.get_function(function_address)
    
    # 通过地址获取函数
    @ai_command
    def get_function_by_address(
        self,
        address: Annotated[str, Field(description="Address of the function to get")]
    ) -> Function:
        """Get a function by its address"""
        return self.get_function(self.parse_address(address))
    
########################################################################字符串


    class Page(TypedDict, Generic[T]):
        data: list[T]
        next_offset: Optional[int]
        
    def paginate(self, data: list[T], offset: int, count: int) -> Page[T]:
        if count == 0:
            count = len(data)
        next_offset = offset + count
        if next_offset >= len(data):
            next_offset = None
        return {
            "data": data[offset:offset+count],
            "next_offset": next_offset,
        }
        
    class String(TypedDict):
        address: str
        length: int
        type: str
        string: str

    def get_strings(self) -> list:
        strings = []
        for item in idautils.Strings():
            string_type = "C" if item.strtype == 0 else "Unicode"
            try:
                string = str(item)
                if string:
                    strings.append({
                        "address": hex(item.ea),
                        "length": item.length,
                        "type": string_type,
                        "string": string
                    })
            except:
                continue
        return strings
    
    # 获取所有字符串
    @ai_command
    def list_strings(
        self,
        offset: Annotated[int, Field(description="Offset to start listing from (start at 0)")],
        count: Annotated[int, Field(description="Number of strings to list (100 is a good default, 0 means remainder)")]
    ) -> Page[String]:
        """List all strings in the database (paginated)"""
        try:
            strings = self.get_strings()
            return self.paginate(strings, offset, count)
        except Exception as e:
            return f"Error: {str(e)}"
    
    # 搜索包含给定模式的字符串
    @ai_command
    def search_strings(
        self,
        pattern_str: Annotated[str, Field(description="The regular expression to match(The generated regular expression includes case by default)")],
        offset: Annotated[int, Field(description="Offset to start listing from (start at 0)")],
        count: Annotated[int, Field(description="Number of strings to list (100 is a good default, 0 means remainder)")]
)   -> Page[String]:
        """Search for strings that satisfy a regular expression"""
        strings = self.get_strings()
        try:
            pattern = re.compile(pattern_str)
            matched_strings = [s for s in strings if s["string"] and re.search(pattern, s["string"])]
            return paginate(matched_strings, offset, count)
        except Exception as e:
            return f"Error: {str(e)}"


########################################################################反汇编

    # 在指定的反汇编地址添加或修改可重复注释
    @ai_command
    def set_disassembly_comment(
        self,
        address: Annotated[str, Field(description="Hex address")],
        comment: Annotated[str, Field(description="Comment content")]
    ) -> str:
        """
        Set a comment at the specified address.
        """
        try:
            ea = int(address, 16)
            idc.set_cmt(ea, comment, 1)
            return f"Set comment at {hex(ea)}: {comment}"
        except Exception as e:
            return f"Error: {str(e)}"
        
    
    # 获取指定地址范围内的反汇编指令
    @ai_command
    def get_disassembly(
        self,
        start_address: Annotated[str, Field(description="Start address (supports hex or decimal string)")],
        end_address: Annotated[str, Field(description="End address (optional, uses current selection if not provided)")]
    ) -> str:
        """
        Gets the disassembly from start address to end address.
        """       
        try:
            start_address = int(start_address, 16)
            end_address = int(end_address, 16)
            if start_address and end_address and start_address != end_address:
                disassembly = ""
                while start_address < end_address:
                    disassembly += f"{hex(start_address)}: {idc.GetDisasm(start_address)}\n"
                    start_address = idc.next_head(start_address)
                return disassembly
            else:
                start_address = idc.read_selection_start()
                end_address = idc.read_selection_end()
                disassembly = ""
                for ea in idautils.Heads(start, end):
                    text = ida_lines.tag_remove(idc.generate_disasm_line(ea, 0))
                    disassembly += f"{hex(ea)}: {text}\n"
                return disassembly
        except Exception as e:
            return f"Error: {str(e)}"
            
            
    # 获取选定范围内的反汇编指令
    @ai_command
    def get_selected_disassembly(self) -> str:
        """
        Gets the selected disassembly.
        """
        try:
            start = idc.read_selection_start()
            end = idc.read_selection_end()
            
            if start == idc.BADADDR or end == idc.BADADDR:
                return "No selection or invalid selection."
            
            disassembly = ""
            for ea in idautils.Heads(start, end):
                text = ida_lines.tag_remove(idc.generate_disasm_line(ea, 0))
                disassembly += f"{hex(ea)}: {text}\n"
            return disassembly
        except Exception as e:
            return f"Error: {str(e)}"
            

    # 获取特定函数的反汇编指令
    @ai_command
    def get_disassembly_function(
        self,
        name: Annotated[str, Field(description="Function name")]
    ) -> str:
        """
        Get disassembly instructions of specified function
        """
        try:
            address = idc.get_name_ea_simple(name)
            if address != idc.BADADDR:
                function = idaapi.get_func(address)
                start_address = function.start_ea
                end_address = function.end_ea

                disassembly = ""
                while start_address < end_address:
                    disassembly += f"{hex(start_address)}: {idc.GetDisasm(start_address)}\n"
                    start_address = idc.next_head(start_address)
                return disassembly
            return f"No function found: {name}"
        except Exception as e:
            return f"Error: {str(e)}"
            
########################################################################反编译

    # 反编译给定地址处的函数的代码
    @ai_command
    def decompile_address(
        self,
        address: Annotated[str, Field(description="Hex address")]
    ) -> str:
        """
        Decompile the function at the specified address.
        """
        try:
            ea = int(address, 16)
            function = idaapi.get_func(ea)
            if function:
                decompiled_code = idaapi.decompile(function)
                return str(decompiled_code) if decompiled_code else "Decompile failed"
            return f"No function at {hex(ea)}"
        except Exception as e:
            return f"Error: {str(e)}"
            

    # 反编译由其名称指定的函数
    @ai_command
    def decompile_function(
        self,
        name: Annotated[str, Field(description="Function name")]
    ) -> str:
        """
        Decompile function by name
        """
        try:
            address = idc.get_name_ea_simple(name)
            if address != idc.BADADDR:
                function = idaapi.get_func(address)
                if function:
                    decompiled_code = idaapi.decompile(function)
                    return str(decompiled_code) if decompiled_code else "Decompile failed"
            return f"Function not found: {name}"
        except Exception as e:
            return f"Error: {str(e)}"
    
    # 重命名反编译代码中特定地址处的局部变量
    @ai_command
    def rename_local_variable(
        self,
        address: Annotated[str, Field(description="Address of the function containing the variable")],        
        old_name: Annotated[str, Field(description="Current name of the variable")],
        new_name: Annotated[str, Field(description="New name for the variable")]
    ) -> str:
        """
        Rename a local variable in a function
        """
        try:
            function_address = int(address, 16)
            func = idaapi.get_func(function_address)
            if not func:
                return f"No function found at address {address}"
            if not ida_hexrays.rename_lvar(func.start_ea, old_name, new_name):
                return f"Failed to rename local variable {old_name} in function {func.start_ea}"
            self.refresh_decompiler_ctext(func.start_ea)
            return f"Successfully to rename local variable {old_name} in function {func.start_ea}"
        except Exception as e:
            return f"Error: {str(e)}"
    
    '''
    # 反汇编由地址指定的函数
    @ai_command
    def disassemble_function(
        self,
        address: Annotated[str, Field(description="Hex address")]
    ) -> str:
        """
        Get assembly code (address: instruction; comment) for a function
        """
        try:
            address = int(address, 16)
            func = idaapi.get_func(address)
            if not func:
                raise IDAError(f"No function found at address {address}")

            # TODO: add labels
            disassembly = ""
            for address in ida_funcs.func_item_iterator_t(func):
                if len(disassembly) > 0:
                    disassembly += "\n"
                disassembly += f"{address}: "
                disassembly += idaapi.generate_disasm_line(address, idaapi.GENDSM_REMOVE_TAGS)
                comment = idaapi.get_cmt(address, False)
                if not comment:
                    comment = idaapi.get_cmt(address, True)
                if comment:
                    disassembly += f"; {comment}"
            return disassembly
        except Exception as e:
            return f"Error: {str(e)}"
    '''   
    
    def decompile_checked(self, address: int) -> ida_hexrays.cfunc_t:
        if not ida_hexrays.init_hexrays_plugin():
            raise IDAError("Hex-Rays decompiler is not available")
        error = ida_hexrays.hexrays_failure_t()
        cfunc: ida_hexrays.cfunc_t = ida_hexrays.decompile_func(address, error, ida_hexrays.DECOMP_WARNINGS)
        if not cfunc:
            message = f"Decompilation failed at {address}"
            if error.str:
                message += f": {error.str}"
            if error.errea != idaapi.BADADDR:
                message += f" (address: {error.errea})"
            raise IDAError(message)
        return cfunc
    
    # 设置反编译注释
    @ai_command
    def set_decompiler_comment(
        self,      
        address: Annotated[str, Field(description="Address in the function to set the comment for")],
        comment: Annotated[str, Field(description="Comment text (not shown in the pseudocode")]
    ) -> str:
        """
        Set a comment for a given address in the function pseudocode
        """
        try:
            address = int(address, 16)
            cfunc = self.decompile_checked(address)

            # 函数入口注释的特殊情况
            if address == cfunc.entry_ea:
                idc.set_func_cmt(address, comment, True)
                cfunc.refresh_func_ctext()
                return f"Set comment at {address}: {comment}"

            eamap = cfunc.get_eamap()
            if address not in eamap:
                raise IDAError(f"Failed to set comment at {address}")
            nearest_ea = eamap[address][0].ea

            # 删除现有的孤立评论
            if cfunc.has_orphan_cmts():
                cfunc.del_orphan_cmts()
                cfunc.save_user_cmts()

            # 通过尝试所有可能的项目类型来设置评论
            tl = idaapi.treeloc_t()
            tl.ea = nearest_ea
            for itp in range(idaapi.ITP_SEMI, idaapi.ITP_COLON):
                tl.itp = itp
                cfunc.set_user_cmt(tl, comment)
                cfunc.save_user_cmts()
                cfunc.refresh_func_ctext()
                if not cfunc.has_orphan_cmts():
                    return f"Set comment at {address}: {comment}"
                cfunc.del_orphan_cmts()
                cfunc.save_user_cmts()
            return f"Failed to set comment at {address}"
        except Exception as e:
            return f"Error: {str(e)}"
        
########################################################################交叉引用
    
    # 获取到指定地址的交叉引用  
    @ai_command
    def get_xrefs_to(
        self,
        address: Annotated[str, Field(description="Hex address")]
    ) -> list:
        """
        Get the cross-references to the specified address.
        """
        try:
            address = int(address, 16)
            xrefs = []
            for xref in idautils.XrefsTo(address, 0):
                xrefs.append((hex(xref.frm), self.get_type_ea(xref.frm), idautils.XrefTypeName(xref.type)))
            return xrefs
        except Exception as e:
            return f"Error: {str(e)}"

    # 获取从指定地址的交叉引用
    @ai_command
    def get_xrefs_from(
        self,
        address: Annotated[str, Field(description="Hex address")]
    ) -> list:
        """
        Get the cross-references from the specified address.
        """
        try:
            ea = int(address, 16)
            xrefs = []
            for xref in idautils.XrefsFrom(ea, 0):
                xrefs.append((
                    hex(xref.to), 
                    self.get_type_ea(xref.to), 
                    idautils.XrefTypeName(xref.type)
                ))
            return xrefs
        except Exception as e:
            return [f"Error: {str(e)}"]

    # 获取到指定地址处的函数内地址的交叉引用
    @ai_command
    def get_func_xrefs_to(
        self,
        address: Annotated[str, Field(description="Hex address")]
    ) -> list:
        """
        Get the details of all cross-references to the specified function.
        """
        try:
            ea = int(address, 16)
            if ea == idc.BADADDR:
                return [f"Invalid address: {hex(ea)}"]

            xrefs = []
            for xref in idautils.XrefsTo(ea, 0):
                xrefs.append((
                    hex(xref.frm), 
                    self.get_type_ea(xref.frm), 
                    idautils.XrefTypeName(xref.type)
                ))
            return xrefs
        except Exception as e:
            return [f"Error: {str(e)}"]

########################################################################

    # 获取选中范围的代码的栈字符串
    @ai_command
    def get_stack_string_of_the_selected_range_of_code(self) -> dict:
        """
        Extract stack strings from selected code range
        """
        try:
            disassembly_str = self.get_selected_disassembly()
            if not disassembly_str:
                return {"error": "No valid selection"}

            hex_list = re.findall(r',\s*([0-9A-Fa-f]+h)', disassembly_str)
            result_str = ''
            
            for hex_str in hex_list:
                little_endian_bytes = bytes.fromhex(hex_str.replace("h",""))
                big_endian_bytes = little_endian_bytes[::-1]
                filtered_hex_str = ''.join(
                    chr(int_data) 
                    for int_data in big_endian_bytes 
                    if int_data != 0
                )
                result_str += filtered_hex_str 
                
            return {"result": result_str}
        except Exception as e:
            return {"error": str(e)}
    

########################################################################结构体操作
    
    # 创建具有指定成员的新结构
    @ai_command
    def create_structure(
        self,
        name: Annotated[str, Field(description="Structure name")],
        members: Annotated[list, Field(description="List of tuples (offset, type, name)")]
    ) -> str:
        """Create a new structure with specified members"""
        try:
            sid = idaapi.add_struc(idaapi.BADADDR, name)
            if sid == idaapi.BADADDR:
                return f"Structure {name} already exists"
            
            for offset, mtype, mname in members:
                if not idaapi.add_struc_member(sid, mname, offset, mtype, None, 0):
                    return f"Failed to add member {mname} at offset {offset}"
            
            idaapi.refresh_idaview_anyway()
            return f"Created structure {name} with {len(members)} members"
        except Exception as e:
            return f"Error: {str(e)}"
    
    # 将结构类型应用于指定地址
    @ai_command
    def apply_structure(
        self,
        address: Annotated[str, Field(description="Hex address")],
        struct_name: Annotated[str, Field(description="Structure name")]
    ) -> str:
        """Apply structure type to specified address"""
        try:
            ea = int(address, 16)
            tid = idaapi.get_struc_id(struct_name)
            if tid == idaapi.BADADDR:
                return f"Structure {struct_name} not found"
            
            if not idaapi.create_struct(ea, -1, tid):
                return f"Failed to apply structure at {hex(ea)}"
            
            return f"Applied {struct_name} structure at {hex(ea)}"
        except Exception as e:
            return f"Error: {str(e)}"

######################################################################## 枚举操作
    
    # 创建具有指定成员的新枚举
    @ai_command
    def create_enum(
        self,
        name: Annotated[str, Field(description="Enumeration name")],
        members: Annotated[dict, Field(description="Dictionary {name: value}")]
    ) -> str:
        """Create a new enumeration with specified members"""
        try:
            eid = idaapi.add_enum(idaapi.BADADDR, name, 0)
            if eid == idaapi.BADADDR:
                return f"Enum {name} already exists"
            
            for ename, evalue in members.items():
                if not idaapi.add_enum_member(eid, ename, evalue, -1):
                    return f"Failed to add member {ename} with value {evalue}"
            
            return f"Created enum {name} with {len(members)} members"
        except Exception as e:
            return f"Error: {str(e)}"


######################################################################## 导入表/导出表


    @staticmethod
    @functools.lru_cache(maxsize=1)
    def _collect_imports() -> list[ImportItem]:
        """Snapshot all imported functions from the IDB (runs on UI thread, cached)."""
        idaapi.auto_wait()  # Ensure analysis is complete
        results: list[ImportItem] = []
        qty = ida_nalt.get_import_module_qty()

        for mod_idx in range(qty):
            module_name = ida_nalt.get_import_module_name(mod_idx) or f"module_{mod_idx}"

            def imp_cb(ea, name, ordinal):
                results.append({
                    "ea": hex(ea),
                    "name": name or f"ord_{ordinal}",
                    "module": module_name,
                })
                return 1  # Continue enumeration

            ida_nalt.enum_import_names(mod_idx, imp_cb)

        return results

    # 获取导入函数
    @ai_command
    def get_imports(
        self,
        limit: Annotated[int, Field(description="Maximum number of imports to return (positive integer, default 50)")] = 50,
        offset: Annotated[int, Field(description="Offset to start from (non-negative, default 0)")] = 0,
        module_filter: Annotated[Optional[str], Field(description="Filter by module name (case-insensitive substring, e.g., 'kernel32')")] = None
    ) -> PagedImports:
        """
        Get paginated imported functions with optional module filtering.
        Useful for identifying dependencies and API usage.
        """
        try:
            if limit <= 0:
                return {
                    "total": 0,
                    "next_offset": None,
                    "items": [],
                    "error": "limit must be a positive integer"
                }
            if offset < 0:
                return {
                    "total": 0,
                    "next_offset": None,
                    "items": [],
                    "error": "offset must be non-negative"
                }

            all_imports = self._collect_imports()

            # Apply module filter if provided
            if module_filter and module_filter.strip():
                filter_norm = module_filter.strip().lower()
                filtered_imports = [
                    item for item in all_imports
                    if filter_norm in item["module"].lower()
                ]
            else:
                filtered_imports = all_imports

            total = len(filtered_imports)
            start = min(offset, total)
            end = min(start + limit, total)
            items = filtered_imports[start:end]
            next_offset = end if end < total else None

            return {
                "total": total,
                "next_offset": next_offset,
                "items": items
            }

        except Exception as e:
            return {
                "total": 0,
                "next_offset": None,
                "items": [],
                "error": f"Failed to retrieve imports: {str(e)}"
            }
    
    # 获取导出表
    @ai_command
    def get_exports(self) -> PagedExports:
        """
        Get all exported functions with address, name, and ordinal.
        Useful for analyzing the public interface of a DLL.
        """
        try:
            exports: List[ExportItem] = []
            for entry in idautils.Entries():
                # entry 格式: (index, ordinal, ea) 或 (index, ordinal, ea, name)
                if len(entry) < 3:
                    continue
                _, ordinal, ea = entry[0], entry[1], entry[2]
                name = None
                if len(entry) >= 4:
                    name = entry[3]
                    if not name:
                        name = None  # 统一空值为 None

                exports.append({
                    "address": hex(ea),
                    "name": name,
                    "ordinal": ordinal if ordinal != 0xFFFF else None  # 无效 ordinal 处理
                })

            return {
                "total": len(exports),
                "items": exports
            }

        except Exception as e:
            return {
                "total": 0,
                "items": [],
                "error": f"Failed to retrieve exports: {str(e)}"
            }



########################################################################字符串处理
    
    # 查找字符串
    @ai_command
    def find_strings(
        self,
        min_length: Annotated[int, Field(description="Minimum string length")] = 5
    ) -> list:
        """Find all ASCII/Unicode strings"""
        results = []
        for s in idautils.Strings():
            try:
                if s.length >= min_length:
                    str_content = idc.get_strlit_contents(s.ea)
                    results.append({
                        "address": hex(s.ea),
                        "type": "ASCII" if s.strtype == 0 else "UNICODE",
                        "content": str_content.decode(errors='replace')
                    })
            except:
                continue
        return results
    
    # 重命名字符串
    @ai_command
    def rename_string(
        self,
        address: Annotated[str, Field(description="Hex address")],
        new_name: Annotated[str, Field(description="New string name")]
    ) -> str:
        """Rename a string at specified address"""
        try:
            ea = int(address, 16)
            if idc.create_strlit(ea, idc.BADADDR, idc.STRTYPE_C):
                return f"Renamed string at {hex(ea)} to {new_name}"
            return f"Failed to rename string at {hex(ea)}"
        except Exception as e:
            return f"Error: {str(e)}"


########################################################################重定位处理
    
    # 获取所有重定位条目
    @ai_command
    def get_relocations(self) -> list:
        """Get all relocation entries"""
        return [
            {
                "address": hex(r.ea),
                "type": r.type,
                "symbol": idc.get_name(r.sym)
            } 
            for r in idautils.Relocations()
        ]


########################################################################二进制修补
    
    # 修补指定地址的字节
    @ai_command
    def patch_bytes(
        self,
        address: Annotated[str, Field(description="Hex address")],
        new_bytes: Annotated[str, Field(description="Hex string (e.g. 90 90 CC)")]
    ) -> str:
        """Patch bytes at specified address"""
        try:
            ea = int(address, 16)
            byte_data = bytes.fromhex(new_bytes.replace(" ", ""))
            ida_bytes.patch_bytes(ea, byte_data)
            idaapi.refresh_idaview_anyway()
            return f"Patched {len(byte_data)} bytes at {hex(ea)}"
        except Exception as e:
            return f"Error: {str(e)}"

 
########################################################################堆栈变量处理
    
    # 重命名堆栈变量
    @ai_command
    def rename_stack_variable(
        self,
        address: Annotated[str, Field(description="Function address")],
        offset: Annotated[int, Field(description="Stack offset")],
        new_name: Annotated[str, Field(description="New variable name")]
    ) -> str:
        """Rename a stack variable"""
        try:
            func_ea = int(address, 16)
            cfunc = self.decompile_checked(func_ea)
            
            for var in cfunc.lvars:
                if var.is_stk_var() and var.get_stkoff() == offset:
                    var.name = new_name
                    cfunc.save_local_types()
                    cfunc.refresh_func_ctext()
                    return f"Renamed stack variable at offset {offset} to {new_name}"
            
            return f"No stack variable found at offset {offset}"
        except Exception as e:
            return f"Error: {str(e)}"
    
    # 设置堆栈变量类型
    @ai_command
    def set_stack_variable_type(
        self,
        address: Annotated[str, Field(description="Function address")],
        offset: Annotated[int, Field(description="Stack offset")],
        new_type: Annotated[str, Field(description="New type definition")]
    ) -> str:
        """Set stack variable type"""
        try:
            func_ea = int(address, 16)
            cfunc = self.decompile_checked(func_ea)
            
            tif = ida_typeinf.tinfo_t()
            if not tif.parse(new_type):
                return f"Invalid type definition: {new_type}"
            
            for var in cfunc.lvars:
                if var.is_stk_var() and var.get_stkoff() == offset:
                    var.tif = tif
                    cfunc.save_local_types()
                    cfunc.refresh_func_ctext()
                    return f"Set type for stack variable at offset {offset} to {new_type}"
            
            return f"No stack variable found at offset {offset}"
        except Exception as e:
            return f"Error: {str(e)}"

            
    
########################################################################功能性函数
    
    # 获取当前函数功能并生成注释(与RenameFunc.py功能相同)
    @ai_command
    def analyze_current_function_and_comment(
        self,
        default_model: Annotated[str, Field(description="Analysis model to use")] = "default"
    ) -> int:
        """
        Analyze current function and generate intelligent comments
        """
        from Binoculars.function.ExplainFunc import comment_callback 
        from Binoculars.config.config import get_current_language
        current_language = get_current_language()
        
        try:
            widget = ida_kernwin.get_current_widget()  # 获取当前活动的 widget
            if ida_kernwin.get_widget_type(widget) != idaapi.BWN_PSEUDOCODE:
                func_ea = idaapi.get_screen_ea()
                ida_hexrays.open_pseudocode(func_ea, 0)  # 打开或激活反编译窗口
                widget = ida_kernwin.get_current_widget()  # 重新获取 widget
            
            decompiler_output = ida_hexrays.decompile(idaapi.get_screen_ea())
            messages,systemprompt = {},""
            default_model.query_model_async(
            "Can you explain the purpose of the following C function and suggest a better name for it? No need for an improved version or other information! Please reply in {current_language}!\n{decompiler_output}".format(decompiler_output=str(decompiler_output),current_language = current_language),messages,systemprompt,
            functools.partial(comment_callback, address=idaapi.get_screen_ea(), view=widget))
            return 1
        except Exception as e:
            return f"Error: {str(e)}" 
    
    # 查找常见的 API 使用模式（网络、文件、加密等）
    @ai_command
    def find_api_patterns(self) -> dict:
        """
        Find common API usage patterns (network, file, crypto, etc.) by analyzing imported functions.
        """
        patterns = {
            "network": ["socket", "connect", "send", "recv", "WSA", "Http", "Internet", "URL"],
            "file": ["CreateFile", "ReadFile", "WriteFile", "DeleteFile", "fopen", "fwrite", "fread"],
            "registry": ["RegOpenKey", "RegSetValue", "RegQueryValue", "RegCreateKey"],
            "crypto": ["Crypt", "AES", "RSA", "SHA", "MD5", "EVP", "Digest", "Cipher", "BCRYPT"],
            "process": ["CreateProcess", "WinExec", "system", "ShellExecute", "CreateThread"],
            "debug": ["IsDebuggerPresent", "CheckRemoteDebuggerPresent", "OutputDebugString"],
            "injection": ["WriteProcessMemory", "VirtualAllocEx", "CreateRemoteThread", "NtMapViewOfSection"],
            "stealth": ["Hide", "Stealth", "Melt", "SelfDelete"]
        }

        try:
            imports_result = self.get_imports()
            items = imports_result.get("items", [])
            
            matches = {}
            for category, apis in patterns.items():
                hits = []
                for item in items:
                    # item: {"ea": "0x...", "name": "...", "module": "..."}
                    api_name = item["name"].lower()
                    module_name = item["module"].lower()
                    
                    for keyword in apis:
                        if keyword.lower() in api_name or keyword.lower() in module_name:
                            hits.append({
                                "api": item["name"],
                                "module": item["module"],
                                "address": item["ea"]
                            })
                            break  # 找到就跳出，避免重复添加
                
                if hits:
                    matches[category] = hits

            return {
                "total_matches": len(matches),
                "patterns": matches
            }

        except Exception as e:
            return {
                "error": f"Failed to analyze API patterns: {str(e)}"
            }


```

`Binoculars/function/RenameFunc.py`:

```py
import idaapi
import functools
import ida_hexrays
import idc
import re
import json
import ida_kernwin
from Binoculars.config.config import get_current_model

class RenameHandler(idaapi.action_handler_t):

    def __init__(self):
        idaapi.action_handler_t.__init__(self)

    def activate(self, ctx):
        default_model = get_current_model()
        
        widget = ida_kernwin.get_current_widget()
        if ida_kernwin.get_widget_type(widget) != idaapi.BWN_PSEUDOCODE:
            func_ea = idaapi.get_screen_ea()
            ida_hexrays.open_pseudocode(func_ea, 0)  # 打开或激活反编译窗口
            widget = ida_kernwin.get_current_widget()  # 重新获取 widget
        
        view = ida_hexrays.get_widget_vdui(widget)
        if view is None:
            idaapi.warning("Failed to get the pseudocode view.")
            return 1
    
        messages,systemprompt = {},""
        decompiler_output = ida_hexrays.decompile(idaapi.get_screen_ea())
        
        default_model.query_model_async("Analyze the following C function and suggest better variable names:\n{decompiler_output}\nRespond with a JSON object where the keys are the original names and the values are the suggested names. Do not interpret or add any additional information, just print the JSON object.".format(decompiler_output=str(decompiler_output)),messages,systemprompt,functools.partial(rename_callback, address=idaapi.get_screen_ea(), view=view,default_model=default_model),additional_model_options={"response_format": {"type": "json_object"}})
        return 1

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS
        
        

        
def rename_callback(address, view, response, default_model, retries=0):
    response = sanitize_json(response)
    names = json.loads(response)
    if type(names) == list:
        result = {}
        for name in names:
            result.update(name)
        names = result

    function_addr = idaapi.get_func(address).start_ea
    

    replaced = []
    for n in names:
        if idaapi.IDA_SDK_VERSION < 760:
            lvars = {lvar.name: lvar for lvar in view.cfunc.lvars}
            if n in lvars:
                if view.rename_lvar(lvars[n], names[n], True):
                    replaced.append(n)
        else:
            if ida_hexrays.rename_lvar(function_addr, n, names[n]):
                replaced.append(n)

    comment = idc.get_func_cmt(address, 0)
    if comment and len(replaced) > 0:
        for n in replaced:
            comment = re.sub(r'\b%s\b' % n, names[n], comment)
        idc.set_func_cmt(address, comment, 0)

    if view:
        view.refresh_view(True)
    print("{model} 查询完成! {replaced} 变量重命名.".format(model=str(default_model),
                                                                              replaced=len(replaced)))


def sanitize_json(mixed_content):
    json_string = extract_json(mixed_content)  
    json_string = re.sub(r'\\(?!["\\/bfnrt]|u[0-9a-fA-F]{4})', '', json_string)
    json_string = re.sub(r'[\x00-\x1f\x7f-\x9f]', '', json_string)
    json_string = re.sub(r'"\s*\n\s*"', '""', json_string)
    json_string = re.sub(r'\s*\n\s*', '', json_string)
    
    return json_string   

def extract_json(mixed_content):
    json_str = ''
    stack = []
    slash = False

    for i, char in enumerate(mixed_content):
        if slash:
            slash = False
            continue

        if char == '{':
            stack.append(i)
        elif char == '}':
            if not stack:
                continue
            start = stack.pop()
            json_str = mixed_content[start:i + 1]
        elif char == '\\':
            slash = True

    return json_str
```

`Binoculars/function/SwapModel.py`:

```py
import idaapi

class SwapModelHandler(idaapi.action_handler_t):

    def __init__(self, new_model_class, new_model, plugin):
        self.new_model_class = new_model_class
        self.new_model = new_model
        self.plugin = plugin

    def activate(self, ctx):
        from Binoculars.models.base import get_model
        from Binoculars.config.config import default_model
        from Binoculars.config.config import writeconfig
        
        try:
            default_model = get_model(str({self.new_model_class:self.new_model}))
        except ValueError as e:
            print(_("Couldn't change model to {model}: {error}").format(model=self.new_model, error=str(e)))
            return
        writeconfig("MODEL", "Default_Model", str({self.new_model_class:self.new_model}))
        self.plugin.generate_plugin_select_menu(default_model)

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS
```

`Binoculars/interface/interface.py`:

```py
import json
import ida_kernwin
import ida_name
import ida_ida
import idc
import idaapi
import re
import traceback
import ida_idaapi
from PyQt5 import QtWidgets, QtCore, QtGui
from Binoculars.config.config import readpromat
from collections import namedtuple
from Binoculars.function.Handle import FuncHandle
import inspect
import threading
import functools
import random
import string

chat_history = []
message_history = []
query = ""
global_default_model = None
system_prompt_flag = True
system_prompt = readpromat("prompt_base")
command_prompt = readpromat("prompt_command")
command_prompt += str(FuncHandle.get_ai_prompts("openai"))


def create_model_config():
    from Binoculars.config.config import get_model_list
    import ast
    MODEL_CONFIGS = []
    ModelConfig = namedtuple("ModelConfig", ["name", "model_class", "context_path"])
    model_map = get_model_list()
    for modelclass,modeltypes in model_map.items():
        for modeltype in modeltypes:
            MODEL_CONFIGS.append(ModelConfig(modeltype, modelclass ,f"{'SwapModel'}/{modelclass}/"))
    return MODEL_CONFIGS
    
class ContextMenuHooks(idaapi.UI_Hooks):
    def __init__(self, owner):
        super(ContextMenuHooks, self).__init__()
        self.owner = owner

    def finish_populating_widget_popup(self, form, popup):
        if idaapi.get_widget_type(form) == idaapi.BWN_PSEUDOCODE:
            MODEL_CONFIGS = create_model_config()
            for model_config in MODEL_CONFIGS:
                menu_path = "Binoculars/" + model_config.context_path
                model_name = model_config.name

                if model_name in self.owner.model_action_map:
                    action_name = self.owner.model_action_map[model_name]["action_name"]
                    idaapi.attach_action_to_popup(form, popup, action_name, menu_path)
 

class IDAAssistant(ida_idaapi.plugin_t):
    global message_history,chat_history
    global query
    flags = ida_idaapi.PLUGIN_FIX
    comment = "Binoculars"
    help = "Provides an AI assistant for reverse engineering tasks"
    wanted_name = "Binoculars"
    wanted_hotkey = "Alt-Q"
    model_action_map = {}

    def __init__(self):
        super(IDAAssistant, self).__init__()
        

    def init(self):
        from Binoculars.config.config import default_model
        
        self.generate_plugin_select_menu(default_model)
        self.menu = ContextMenuHooks(self)
        self.menu.hook()
        
        return idaapi.PLUGIN_KEEP
    
    
    def detach_actions(self):
        for model_name, action_info in self.model_action_map.items():
            action_name = action_info["action_name"]
            menu_path = action_info["menu_path"]
            
            ida_kernwin.execute_sync(functools.partial(idaapi.unregister_action, action_name), ida_kernwin.MFF_FAST)
            ida_kernwin.execute_sync(functools.partial(idaapi.detach_action_from_menu, menu_path, action_name), ida_kernwin.MFF_FAST)
        
        self.model_action_map.clear()
    
    def generate_plugin_select_menu(self, default_model):
        global global_default_model
        global_default_model = default_model

        def do_generate_model_select_menu():
            self.detach_actions()

            MODEL_CONFIGS = create_model_config()
            for model_config in MODEL_CONFIGS:
                menu_path = "Binoculars/" + model_config.context_path
                self.bind_model_switch_action(menu_path, model_config, default_model)

        threading.Thread(target=do_generate_model_select_menu).start()

        
    def bind_model_switch_action(self, menu_path, model_config, default_model):
        from Binoculars.function.SwapModel import SwapModelHandler


        unique_id = ''.join(random.choices(string.ascii_lowercase, k=7))
        action_name = f"Binoculars:select_{model_config.model_class}_{model_config.name}_{unique_id}"

        self.model_action_map[model_config.name] = {
            "action_name": action_name,
            "menu_path": menu_path
        }

        action = idaapi.action_desc_t(
            action_name,
            model_config.name,
            SwapModelHandler(model_config.model_class, model_config.name, self),
            "",
            "",
            208 if str(default_model) == model_config.name else 0
        )

        ida_kernwin.execute_sync(functools.partial(idaapi.register_action, action), ida_kernwin.MFF_FAST)
        ida_kernwin.execute_sync(
            functools.partial(idaapi.attach_action_to_menu, menu_path, action_name, idaapi.SETMENU_APP),
            ida_kernwin.MFF_FAST
        )


    def run(self, arg):
        self.assistant_window = AssistantWidget()
        self.assistant_window.Show("Binoculars")

    def term(self):
        if self.menu:
            self.menu.unhook()
        return

    def add_assistant_message(self, message):
        chat_history.append(f"<b>Assistant:</b> {message}") 

class AssistantWidget(ida_kernwin.PluginForm, QtCore.QObject):
    def __init__(self):
        from Binoculars.config.config import get_current_language
        ida_kernwin.PluginForm.__init__(self)
        QtCore.QObject.__init__(self)
        self.icon = ida_kernwin.load_custom_icon("Binoculars/images/logo.ico")
        self.stop_flag = False
        self.message_history_flag = True
        self.default_model = global_default_model      
        self.current_language = get_current_language()
        self.error_count = 0
        self.error_retry = 3
    
    def PrintOutput(self, output_str):
        self.chat_record.append(f"<b>System Message:</b> {output_str}")
    
    def change_default_model(self):
        global global_default_model
        self.default_model = global_default_model

    def OnCreate(self, form):
        # from Binoculars.function.Handle import FuncHandle
        self.parent = self.FormToPyQtWidget(form)
        self.PopulateForm()
        self.assistant = IDAAssistant()
        self.command_results = []
        self.func_handle = FuncHandle(self)
              

    def PopulateForm(self):
        from Binoculars.function.ExplainFunc import ExplainHandler 
        from Binoculars.function.RenameFunc import RenameHandler 
        # from Binoculars.function.GoParseFunc import ParseGoHandler 
        layout = QtWidgets.QVBoxLayout()
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setSpacing(10)

        self.view = ida_kernwin.get_current_viewer()
        self.output_window = ida_kernwin.find_widget("Output window")

        self.chat_record = QtWidgets.QTextEdit()
        self.chat_record.setReadOnly(True)
        self.chat_record.setStyleSheet("""
            QTextEdit {
                background-color: #F5F5F5;
                border: 1px solid #ddd;
                padding: 5px;
                font-family: monospace;
                border-radius: 5px;
            }
        """)
        layout.addWidget(self.chat_record)

        input_layout = QtWidgets.QHBoxLayout()
        self.user_input = QtWidgets.QTextEdit()
        self.user_input.setFixedHeight(50)
        self.user_input.setStyleSheet("""
            QTextEdit {
                background-color: #F5F5F5;
                border: 1px solid #ccc;
                padding: 5px;
                border-radius: 5px;
            }
        """)
        
        self.user_input.installEventFilter(self)
        input_layout.addWidget(self.user_input)
        
        button_style = """
            QPushButton {
                background-color: #e0e0e0;
                border: 1px solid #ccc;
                color: black;
                padding: 8px 16px;
                text-align: center;
                font-size: 14px;
                margin: 4px 2px;
                opacity: 0.8;
                transition: 0.3s;
                border-radius: 5px;
            }
            QPushButton:hover {opacity: 1}
            QPushButton:pressed { background-color: #c0c0c0; }
        """

        send_button = QtWidgets.QPushButton("Send")
        send_button.setStyleSheet(button_style)
        send_button.clicked.connect(self.OnSendClicked)
        input_layout.addWidget(send_button)
        
        stop_button = QtWidgets.QPushButton("Stop")
        stop_button.setStyleSheet("""
            QPushButton {
                background-color: #f44336;
                border: 1px solid #ccc;
                color: white;
                padding: 8px 16px;
                text-align: center;
                font-size: 14px;
                margin: 4px 2px;
                opacity: 0.8;
                transition: 0.3s;
                border-radius: 5px;
            }
            QPushButton:hover {opacity: 1}
            QPushButton:pressed { background-color: #d32f2f; }
        """)
        stop_button.clicked.connect(self.OnStopClicked)
        input_layout.addWidget(stop_button)

        layout.addLayout(input_layout)

        shortcut_layout = QtWidgets.QHBoxLayout()
        shortcut_layout.setAlignment(QtCore.Qt.AlignLeft)
        shortcut_label = QtWidgets.QLabel("Shortcut:")
        shortcut_layout.addWidget(shortcut_label)

        for text, action_name in [
            ("Analyze the current function", "explain_action"),
            ("Rename the current function variable", "rename_action"),
            ("Parsing Golang file symbols", "parsego_action")
        ]:
            button = QtWidgets.QPushButton(text)
            button.setStyleSheet(button_style + """
                QPushButton::menu-indicator {
                    image: none;
                }
            """)
                        
            font_metrics = button.fontMetrics()
            text_width = font_metrics.boundingRect(text).width()
            padding_horizontal = button.style().pixelMetric(QtWidgets.QStyle.PM_ButtonMargin) * 2
            button_min_width = text_width + padding_horizontal
            button.setMinimumWidth(button_min_width)
            shortcut_layout.addWidget(button)
            
            if text == "Analyze the current function":
                handler = ExplainHandler(self.default_model)
                self.update_handler(action_name=action_name, text=text, handler=handler, button=button)
            elif text == "Rename the current function variable":
                handler = RenameHandler()
                self.update_handler(action_name=action_name, text=text, handler=handler, button=button)
            elif text == "Parsing Golang file symbols":  
                menu = QtWidgets.QMenu(button)
                for option_text in ["1.recreate pclntab", "2.function discovery and renaming", "3.string cast", "4.extract types"]:
                    action = menu.addAction(option_text)
                    unique_action_name = f"{action_name}_{option_text.replace(' ', '_').replace('.', '').replace(':', '')}"
                    action.triggered.connect(lambda checked, opt=option_text, act_name=unique_action_name, txt=text: self.menu_option_triggered(opt, act_name, txt, button))
                button.setMenu(menu)
                

        layout.addLayout(shortcut_layout)
        self.parent.setLayout(layout)
    
    def menu_option_triggered(self, option_text, action_name, text, button):
        self.update_handler(action_name=action_name, text=text, option_text=option_text, button=button)
                
        output_window = ida_kernwin.find_widget("Output window")
        if output_window:
            ida_kernwin.activate_widget(output_window, True)
        ida_kernwin.process_ui_action(action_name)
    
    def update_handler(self, action_name, text, handler=None, option_text=None, button=None):
        
        from Binoculars.function.GoParseFunc import ParseGoHandler
        if text == "Parsing Golang file symbols":
            handler = ParseGoHandler(option_text)
            
        action_desc = idaapi.action_desc_t(
            action_name,
            text,
            handler,
            "",
            f"", 
            199
        )
        idaapi.unregister_action(action_name)
        idaapi.register_action(action_desc)

        if button:
            button.clicked.connect(lambda _, name=action_name: ida_kernwin.process_ui_action(name))
    
    def eventFilter(self, source, event):
        if event.type() == QtCore.QEvent.KeyPress and source is self.user_input:
            if event.key() == QtCore.Qt.Key_Return and event.modifiers() == QtCore.Qt.ShiftModifier:
                cursor = self.user_input.textCursor()
                cursor.insertText("\n")
                return True
            elif event.key() == QtCore.Qt.Key_Return:
                self.OnSendClicked()
                return True
        return super().eventFilter(source, event)
        
    def OnStopClicked(self):
        self.stop_flag = True
        self.chat_record.append(f"<b>System Message:</b> AI execution stopped.")
        
    def OnSendClicked(self):
        self.change_default_model()
        global message_history,query,system_prompt_flag
        self.stop_flag = False

        user_message = self.user_input.toPlainText().strip()
        if user_message:
            self.chat_record.append(f"<b>User:</b> {user_message}")
            self.user_input.clear()
            current_address = idc.here()
            
            systemprompt = (system_prompt if system_prompt_flag else "") + command_prompt
            # system_prompt_flag = False
            
            query = f"{user_message}\n" + f"Current address: {hex(current_address)}\n" + f"Reply in {self.current_language}"
            messages = message_history.copy() 
            self.default_model.query_model_async(query, messages, systemprompt, self.OnResponseReceived)
            
    # 接受回复
    def OnResponseReceived(self, response):
        global message_history, query
        
        assistant_reply = response.strip().replace("```json\n", "").replace("```\n", "").strip()
        
        if self.message_history_flag:
            message_history.append({"role": "user", "content": query})
            message_history.append({"role": "assistant", "content": assistant_reply})# 
            if len(message_history) > 20:
                message_history = message_history[2:]    
            
        chat_history.append(f"<b>User:</b> {query}")
    
        try:
            assistant_reply = self.ParseResponse(assistant_reply)

            if assistant_reply is None:
                self.chat_record.append(f"<b>System Message:</b> Failed to parse Binoculars response.")
                return

            if not assistant_reply:
                self.chat_record.append(f"<b>System Message:</b> No response from Binoculars.")
                return
                
            parsed_data = assistant_reply["parsed"]
            remaining_text = assistant_reply["remaining"]

            self.chat_record.append(f"<b>Binoculars:</b> {parsed_data['thoughts']['speak']}")
            if remaining_text:
                self.chat_record.append(f"<b>Binoculars:</b> {remaining_text}")
            
            
            commands = parsed_data['command']
            command_results = {}
            for command in commands:
                command_name = command['name']
                if command_name == "do_nothing":
                    continue
                command_args = command['args'].copy()
                command_args["default_model"] = self.default_model    
                
                command_handler = getattr(self.func_handle, f"{command_name}", None)
                
                if command_handler:
                    sig = inspect.signature(command_handler)
                    valid_params = list(sig.parameters.keys())
                    filtered_args = {k: v for k, v in command_args.items() if k in valid_params}
                    command_handler_result = command_handler(**filtered_args)
                    if isinstance(command_handler_result, dict) and "result" in command_handler_result:
                        self.PrintOutput(f"Module execution results: {command_handler_result['result']}")
        
                    command_results[command_name] = command_handler_result
                else:
                    self.PrintOutput(f"Unknown command: {command_name}")
                    command_results[command_name] = None

            query = ""
            for command_name, result in command_results.items():
                if result is not None:
                    query += f"{command_name} result:\n" + f"{json.dumps(result)}\n" + f"Reply in {self.current_language}\n"
                else:
                    # query += f"{command_name} result: None\n\n"
                    query += f"{command_name} result: An unknown command was used. This behavior is prohibited. Please use the command specified in the request.\n" + f"Reply in {self.current_language}\n"
                    
            if len(query) > 0:
                systemprompt = (system_prompt if system_prompt_flag else "") + command_prompt  
                messages = message_history.copy() 
                self.default_model.query_model_async(query, messages, systemprompt, self.OnResponseReceived) 

            self.error_count = 0

        except Exception as e:
            traceback_details = traceback.format_exc()
            print(traceback_details) # 打印了错误
            
            self.error_count += 1
            
            if self.error_count < self.error_retry and not self.stop_flag:
                self.PrintOutput(f"Error parsing Binoculars response: {str(e)}")
                systemprompt = (system_prompt if system_prompt_flag else "") + command_prompt            
                messages = message_history.copy() 
                query = f"Error parsing response:{str(e)}\n" + "Please refer to the error message to modify your reply\n" + f"Reply in {self.current_language}\n"
                self.default_model.query_model_async(query, messages, systemprompt, self.OnResponseReceived)
            else:
                self.PrintOutput(f"Error parsing Binoculars response: {str(e)}")
                

            
    def ParseResponse(self, response):
        try:
            json_str, remaining_text = self.sanitize_json(response)
            if json_str:
                parsed_response = json.loads(json_str)
                return {
                    "parsed": parsed_response,
                    "remaining": remaining_text.strip()
                }
            else:
                raise Exception("JSON format required.")
        except json.JSONDecodeError as e:
            raise Exception(f"{str(e)}. Return ONLY valid JSON.")
        except Exception as e:
            raise e

    def sanitize_json(self, mixed_content):
        json_str, remaining = self.extract_json(mixed_content)

        if not json_str:
            return "", mixed_content

        valid_escapes = ['\\n', '\\r', '\\t', '\\b', '\\f', '\\"', '\\\\', '\\/', '\\u']
        
        placeholder_map = {}
        def placeholder_replacer(match):
            s = match.group(0)
            placeholder = f"__ESCAPE_{len(placeholder_map)}__"
            placeholder_map[placeholder] = s
            return placeholder

        temp_json = json_str
        for valid in valid_escapes:
            import re
            temp_json = re.sub(re.escape(valid), placeholder_replacer, temp_json)

        temp_json = re.sub(r'\\(?![\\"nrtbfu/])', r'\\\\', temp_json)  # 修复非法 \x → \\x

        for placeholder, original in placeholder_map.items():
            temp_json = temp_json.replace(placeholder, original)

        temp_json = re.sub(r'[\x00-\x1f\x7f-\x9f]', '', temp_json)  # 清理控制字符

        temp_json = re.sub(r'"\s*\n\s*"', '""', temp_json)  # "内容"\n"更多" → "" 更安全
        temp_json = re.sub(r'\s*\n\s*', ' ', temp_json)      # 换行 → 空格

        return temp_json, remaining


    def extract_json(self, mixed_content):
        stack = []
        json_start = -1
        json_str = ""
        remaining = mixed_content
        
        for i, char in enumerate(mixed_content):
            if char == '{':
                if not stack:
                    json_start = i
                stack.append(i)
            elif char == '}':
                if stack:
                    start = stack.pop()
                    if not stack:
                        json_str = mixed_content[json_start:i+1]
                        remaining = mixed_content[i+1:].lstrip()
                        break
        return json_str, remaining
```

`Binoculars/models/base.py`:

```py
import abc
import threading
import json
import ida_kernwin
import functools
import logging
from Binoculars.config.config import readconfig

class LanguageModel(abc.ABC):
    @abc.abstractmethod
    def query_model_async(self, query, cb):
        pass
 
def get_model(model_dict_str):
    from Binoculars.config.config import get_model_list
    import ast
    import importlib
    
    model_map = get_model_list()
    model_dict = ast.literal_eval(model_dict_str)
    model_class = list(model_dict.keys())[0]
    model_type = list(model_dict.values())[0]

    try:
        if model_type in model_map.get(model_class, []):
            module = importlib.import_module(f"Binoculars.models.{model_class.lower()}")
            model_class = getattr(module, model_class)
            return model_class(model_type)
        else:
            raise ValueError(f"Model '{model_type}' not found for provider '{model_class}'")
    except (ImportError, AttributeError, ValueError) as e:
        print(f"Error loading model: {e}")
        return None 
        
        

class BaseModel(LanguageModel):
    def __init__(self, provider, model):
        logging.getLogger("httpx").setLevel(logging.WARNING)
        self.provider = provider
        self.model = model
        self.base_url = readconfig(provider, "BASE_URL")
        self.api_key = readconfig(provider, "API_KEY")
        if not self.api_key:
            print(f"Please edit the configuration file to insert your {provider} API key!")
            raise ValueError(f"No valid {provider} API key found")
        self.proxy = readconfig(provider, f"{provider}_PROXY")
        

    def __str__(self):
        return self.model

    def build_messages(self, query, message_history, system_prompt):
        messages = []
        if system_prompt:messages.append({"role": "system", "content": system_prompt})
        messages.extend(message_history)
        messages.append({"role": "user", "content": query})
       
        return messages
    
    def execute_callback(self, callback, response_content):
        ida_kernwin.execute_sync(functools.partial(callback, response=response_content), ida_kernwin.MFF_WRITE)


    def query_model(self, query, message_history, system_prompt, callback, additional_model_options=None):
        raise NotImplementedError("Subclasses should implement this method")

    def query_model_async(self, query, message_history, system_prompt, callback, additional_model_options=None):
        if additional_model_options is None:
            additional_model_options = {}
        print(f"Request to {self.model} sent...")
        t = threading.Thread(target=self.query_model, args=[query, message_history, system_prompt, callback, additional_model_options])
        t.start()
```

`Binoculars/models/claude.py`:

```py
import re
import httpx
import anthropic
from Binoculars.models.base import BaseModel


class CLAUDE(BaseModel):
    def __init__(self, model):
        super().__init__("CLAUDE", model)
        self.max_tokens= 1024
        self.client = anthropic.Anthropic(
            api_key= self.api_key,
            base_url=self.base_url,
            http_client=httpx.Client(
                proxies=self.proxy,
            ) if self.proxy else None
        )

    def query_model(self, query, message_history, system_prompt, callback, additional_model_options=None):
        if additional_model_options is None:additional_model_options = {}
        messages = self.build_messages(query, message_history, system_prompt)
        try:
            try:
                response = self.client.messages.create(
                    max_tokens = self.max_tokens,
                    model=self.model,
                    messages=messages,
                    **additional_model_options
                )
            except:
                response = self.client.completions.create(
                    max_tokens_to_sample = self.max_tokens,
                    model=self.model,
                    prompt=messages,
                    **additional_model_options
                )

            response_content = response.content[0].text.strip().replace("```json\n", "").replace("```\n", "").strip()
            
            self.execute_callback(callback, response_content)
        except anthropic.BadRequestError as e:
            m = re.search(r'maximum context length is \d+ tokens, however you requested \d+ tokens', str(e))
            if m:
                print("Unfortunately, this function is too big to be analyzed with the model's current API limits.")
            else:
                print(f"BadRequestError: General exception encountered while running the query: {str(e)}")
        except anthropic.AuthenticationError as e:
            print(f"AuthenticationError: {str(e)}")
        except anthropic.PermissionDeniedError as e:
            print(f"PermissionDeniedError: {str(e)}")
        except anthropic.NotFoundError as e:
            print(f"NotFoundError: {str(e)}")
        except anthropic.UnprocessableEntityError as e:
            print(f"UnprocessableEntityError: {str(e)}")
        except anthropic.RateLimitError as e:
            print(f"RateLimitError: {str(e)}")
        except anthropic.InternalServerError as e:
            print(f"InternalServerError: {str(e)}")
        except anthropic.APIConnectionError as e:
            print(f"APIConnectionError: {str(e)}")
        except Exception as e:
            print(f"General exception encountered while running the query: {str(e)}")



```

`Binoculars/models/gpt360.py`:

```py
import httpx
import json
from Binoculars.models.base import BaseModel

        
        
class GPT360(BaseModel):
    def __init__(self, model):
        super().__init__("GPT360", model)
        self.headers = {'Authorization': self.api_key, 'Content-Type': 'application/json'}

    def query_model(self, query, message_history, system_prompt, callback, additional_model_options=None):
        if additional_model_options is None:additional_model_options = {}
        messages = self.build_messages(query, message_history, system_prompt)
        payload = {
            "model": self.model,
            "messages": messages,
            **additional_model_options
        }
        try:
            response = httpx.post(self.base_url, headers=self.headers, data=json.dumps(payload), timeout=120.0, proxy=self.proxy if self.proxy else None)
            response.raise_for_status()
            response_content = response.json()['choices'][0]['message']['content']
            
            self.execute_callback(callback, response_content)
            
        except httpx.TimeoutException:
            print(f"{self.model} request timed out.")
        except httpx.ConnectError:
            print(f"{self.model} could not connect to the server.")
        except httpx.HTTPStatusError as e:
            print(f"{self.model} received a bad response: {e.response.status_code}")
        except httpx.RequestError as e:
            print(f"{self.model} request failed: {str(e)}")
        except Exception as e:
            print(f"General exception encountered while running the query: {str(e)}")



```

`Binoculars/models/openai.py`:

```py
import re
import httpx
import openai
from Binoculars.models.base import BaseModel


class OPENAI(BaseModel):
    def __init__(self, model):
        super().__init__("OPENAI", model)
        self.client = openai.OpenAI(
            api_key=self.api_key,
            base_url=self.base_url,
            http_client=httpx.Client(
                proxies=self.proxy,
            ) if self.proxy else None
        )

    def query_model(self, query, message_history, system_prompt, callback, additional_model_options=None):
        if additional_model_options is None:additional_model_options = {}
        messages = self.build_messages(query, message_history, system_prompt)
        try:
            response = self.client.chat.completions.create(
                model=self.model,
                messages=messages,
                **additional_model_options
            )
            response_content = response.choices[0].message.content
            
            self.execute_callback(callback, response_content)
        except openai.BadRequestError as e:
            m = re.search(r'maximum context length is \d+ tokens, however you requested \d+ tokens', str(e))
            if m:
                print("Unfortunately, this function is too big to be analyzed with the model's current API limits.")
            else:
                print(f"BadRequestError: General exception encountered while running the query: {str(e)}")
        except openai.AuthenticationError as e:
            print(f"AuthenticationError: {str(e)}")
        except openai.PermissionDeniedError as e:
            print(f"PermissionDeniedError: {str(e)}")
        except openai.NotFoundError as e:
            print(f"NotFoundError: {str(e)}")
        except openai.UnprocessableEntityError as e:
            print(f"UnprocessableEntityError: {str(e)}")
        except openai.RateLimitError as e:
            print(f"RateLimitError: {str(e)}")
        except openai.InternalServerError as e:
            print(f"InternalServerError: {str(e)}")
        except openai.APIConnectionError as e:
            print(f"APIConnectionError: {str(e)}")
        except Exception as e:
            print(f"General exception encountered while running the query: {str(e)}")



```

`LICENSE`:

```
MIT License

Copyright (c) 2024 唐哲的猫

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# Binoculars
![logo_500](https://github.com/user-attachments/assets/ff9fb4a1-82be-4b1d-b755-a3187bd6d610)  
Binoculars is an IDA PRO plugin with an integrated AI interface.  
 

## How to Get Started
1. Register the package in the requirements.txt file.
2. Move the Binoculars folder and Binoculars.py file to the IDA plugins folder.
3. Fill in the API KEY and the default model to be used in the config.ini file, for example {"GPT360":"360gpt2-pro"}.
4. Open IDA pro, use the ALT+Q shortcut key to open Binoculars or find Binoculars in the Edit/Plugins path of IDA pro.
5. Next you can use Binoculars.Type your query or request in the input field and click Send or press Enter.You can chat with it or perform specific functions.
![image](https://github.com/user-attachments/assets/144d3aed-617b-4910-aec6-8d4aa0242eed)

7. Of course, you can also use the right mouse button to find the Binoculars switch model.
![切换模型](https://github.com/user-attachments/assets/19af3747-52d3-4cb3-9d45-8933e9b37026)


## What Binoculars Can Do
You can chat with Binoculars to get information without having to frequently browse the browser.  
![聊天功能](https://github.com/user-attachments/assets/d7d8983f-ddc8-4f94-984b-acef37b393f6)  

You can use Binoculars shortcuts to analyze function functionality or rename variables.  
![快捷键_函数分析](https://github.com/user-attachments/assets/4ac33820-e082-49ca-9073-810eb5896f74)

You can use Binoculars built-in commands to perform some functions, and of course you can write more functions to Binoculars to make Binoculars more powerful.  
![内置命令_符号查找](https://github.com/user-attachments/assets/51dee0fb-8757-4dc3-ae19-b50a9ac21930)  
![内置命令_函数分析](https://github.com/user-attachments/assets/6778650c-dcf7-4f04-8dec-280f79d777ad)  





## Acknowledgments
Binoculars inherits the ideas of IDA Assistant, Gepetto and AutoGPT. It is a child standing on the shoulders of giants.  
Inheriting the ideas of AutoGPT, Binoculars will create unlimited possibilities.  
Thank you for your wisdom and hard work. 












```