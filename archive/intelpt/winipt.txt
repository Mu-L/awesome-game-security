Project Path: arc_intelpt_winipt_nf5anlmx

Source Tree:

```txt
arc_intelpt_winipt_nf5anlmx
├── LICENSE
├── README.md
├── _config.yml
├── inc
│   ├── ipt.h
│   ├── libipt.h
│   └── libiptnt.h
├── ipt-trace.png
├── ipttool
│   ├── ipttool.c
│   └── ipttool.vcxproj
├── libipt
│   ├── libipt.vcxproj
│   └── win32.c
├── libiptnt
│   ├── libiptnt.vcxproj
│   └── native.c
└── winipt.sln

```

`LICENSE`:

```
BSD 2-Clause License

Copyright (c) 2018, Alex Ionescu
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`README.md`:

```md
# WinIPT
The Windows Library for Intel Process Trace (WinIPT) is a project that leverages the new Intel Processor Trace functionality exposed by Windows 10 October Update (Version 1809 / Redstone 5). The new operating system now includes the old inbox Intel PT driver (ipt.sys) with additional code that allows configuring both per-process and per-core tracing through an IOCTL and registry mechanism, instead of relying on undocumented ETW internals. In this repository, you will find the following 3 projects:

* `libipt`
This is the Win32 API version of the library which grants access to the IPT Driver/Service IOCTLs that enable per-core and per-process tracing with the new facilities exposed by Windows. This library uses Win32 semantics & notation, and its functions are re-implementations of some of the functions that were found in `Dbghelp.dll`, `Dbgcore.dll`, `TTDRecordCPU.dll`, `Faultrep.dll` and `Ntdll.dll`.

* `libiptnt`
This is the native NT API version of the same library as above, which uses only Ntdll.dll functions, making it suitable for use in Native/non-Win32 applications. This library uses NT-style semantics & notication, and its functions are almost identical to the ones exposed by the libraries listed above.

* `ipttool`
This acts as a sample for the libipt static library referenced above, and provides a simple CLI utility around starting, stopping, and querying traces for a given process. It does not currently support core tracing, and it does not do decoding -- please use the Intel PT library for that.

## Screenshot

![Screenshot](ipt-trace.png)

## Motivation

Existing Windows-focused research on Intel Processor Trace has resulted in many hand-crafted custom drivers to toggle the correct flags in the appropriate MSRs, and to register for performance interrupts to correctly handle delivery of tracing data. Unfortunately, most of these custom drivers suffer from security vulnerabilities, academic/proof-of-concept quality code, and don't handle edge and corner cases safely (as would be expected of non-commercial, paid, software!). Additionally, the techniques they use for enabling such functionality closely mimic malicious code, making it hard for defenders to distinguish between the intent of an Intel PT tracing driver, and a rootkit.

Likely in response, in Windows 10 Spring Update (Version 1803 / Redstone 4), Microsoft added an `Ipt.sys` driver that enables Intel PT support for certain classes of ETW tracing operations. The support was incomplete, and mainly to handle this specific use case. In Windows 10 October Update (Version 1809 / Redstone 5), however, Microsoft has enhanced this driver to support non-ETW-based usage of Intel PT, and to configure both per-process (per-thread0 tracing as well as full per-core tracing, exposing many (but not all) of the Intel PT controls that normally get written into the appropriate MSR (such as allowing callers to enable MTC/TSC timing packets, or by configuring either Ring 0 or Ring 3 tracing).

Currently, this support seems to be specific to PSS/OCA scenarios (Microsoft's crash analytics framework part of Windows Error Reporting, or WER) and Time Travel Debugging (TTD/Nirvana) and undocumented, exposed only through a few external exports inside of `Ntdll.dll` and internal APIs inside of `Faultrep.dll`. As a result, I reverse engineered the internal IOCTL interface, the exported APIs, the tracing options and headers, and provide this library so that it may help those building PT-based tools to focus on the tracing data, and avoid having to become kernel programmers.

## Caveat

As per my previous note on existing drivers being of PoC-level quality, this repository is also a PoC and all of the libraries and tool presented here are provided with zero guarantees on their functionality, and no support (I will, however, strive to address PRs and other helpful comments!). Please do not ship commercial/enteprise/paid products using this library -- I am sure Microsoft and Intel will eventually ship an official set of APIs or SDK for such purposes.

## References

The official specification of Intel Processor Trace is available from [Intel](https://software.intel.com/en-us/blogs/2013/09/18/processor-tracing) and shoudl be perused if this is your first time learning about this technology.

For some highly recommended reading on potential applications to security, I suggest reading the following presentations from Richard Johnson & Andrea Alevi: [Go Speed Tracer](https://talos-intelligence-site.s3.amazonaws.com/production/document_files/files/000/000/048/original/Go_Speed_Tracer.pdf?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAIXACIED2SPMSC7GA%2F20180711%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20180711T075012Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7b8003bc3582e408522594913240c92a0608201f716f607111973d8c17eeafa2), [Harnessing Intel Processor Trace on Windows for Vulnerability Disclosure](https://conference.hitb.org/hitbsecconf2017ams/materials/D1T1%20-%20Richard%20Johnson%20-%20Harnessing%20Intel%20Processor%20Trace%20on%20Windows%20for%20Vulnerability%20Discovery.pdf) as well as this presentation: [COFI Break](https://gsec.hitb.org/materials/sg2016/D2%20-%20Shlomi%20Oberman%20and%20Ron%20Shina%20-%20Breaking%20Exploits%20with%20Practical%20Control%20Flow%20Integrity.pdf) by Shlomi Oberman and Ron Shina. 

You can also get the unofficial driver which Andrea and Richard collaborated on from [GitHub](https://github.com/intelpt/WindowsIntelPT).

Other relevant research on Intel PT security applications can be found from Microsoft Research [GRIFFIN](https://www.microsoft.com/en-us/research/wp-content/uploads/2017/01/griffin-asplos17.pdf) and from Shanghai University [FlowGuard](https://ipads.se.sjtu.edu.cn/lib/exe/fetch.php?media=publications:flowguard.pdf).

If you would like to know more about my research or work, I invite you to check out my blog at [http://www.alex-ionescu.com](http://www.alex-ionescu.com) as well as my training & consulting company, Winsider Seminars & Solutions Inc., at [http://www.windows-internals.com](http://www.windows-internals.com).

## License

```
Copyright 2018 Alex Ionescu. All rights reserved. 

Redistribution and use in source and binary forms, with or without modification, are permitted provided
that the following conditions are met: 
1. Redistributions of source code must retain the above copyright notice, this list of conditions and
   the following disclaimer. 
2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions
   and the following disclaimer in the documentation and/or other materials provided with the 
   distribution. 

THIS SOFTWARE IS PROVIDED BY ALEX IONESCU ``AS IS'' AND ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ALEX IONESCU
OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The views and conclusions contained in the software and documentation are those of the authors and
should not be interpreted as representing official policies, either expressed or implied, of Alex Ionescu.
```

```

`_config.yml`:

```yml
title: WinIPT
description: The Windows Library for Intel Process Trace (WinIPT) is a project that leverages the new Intel Processor Trace functionality exposed by Windows 10 Redstone 5 (1809), through a set of libraries and a command-line tool.
show_downloads: true
theme: jekyll-theme-midnight

```

`inc/ipt.h`:

```h
#pragma once
#pragma warning(disable:4214)
#pragma warning(disable:4201)

//
// Requests that can be sent with IOCTL_IPT_REQUEST or IOCTL_IPT_READ_TRACE
//
typedef enum _IPT_INPUT_TYPE
{
    IptGetTraceVersion,
    IptGetProcessTraceSize,
    IptGetProcessTrace,                 // Use IOCTL_IPT_READ_TRACE
    IptStartCoreTracing,
    IptRegisterExtendedImageForTracing,
    IptStartProcessTrace,
    IptStopProcessTrace,
    IptPauseThreadTrace,
    IptResumeThreadTrace,
    IptQueryProcessTrace,
    IptQueryCoreTrace
} IPT_INPUT_TYPE, *PIPT_INPUT_TYPE;

//
// Header on top of any IOCTL Input Request
//
typedef struct _IPT_BUFFER_VERSION
{
    ULONG BufferMajorVersion;
    ULONG BufferMinorVersion;
} IPT_BUFFER_VERSION, *PIPT_BUFFER_VERSION;

//
// IOCTL Input Request Buffer
//
typedef struct _IPT_INPUT_BUFFER
{
    IPT_BUFFER_VERSION;
    IPT_INPUT_TYPE InputType;
    union
    {
        struct
        {
            USHORT TraceVersion;
            HANDLE ProcessHandle;
        } GetProcessIptTraceSize;
        struct
        {
            USHORT TraceVersion;
            HANDLE ProcessHandle;
        } GetProcessIptTrace;
        struct
        {
            IPT_OPTIONS Options;
            ULONG NumberOfTries;
            ULONG TraceDurationInSeconds;
        } StartCoreIptTracing;
        struct
        {
            IPT_OPTIONS Options;
            ULONG NumberOfTries;
            ULONG TraceDurationInSeconds;
            USHORT ImagePathLength;
            USHORT FilteredPathLength;
            WCHAR ImageName[ANYSIZE_ARRAY];
        } RegisterExtendedImageForIptTracing;
        struct
        {
            HANDLE ProcessHandle;
            IPT_OPTIONS Options;
        } StartProcessIptTrace;
        struct
        {
            HANDLE ProcessHandle;
        } StopProcessIptTrace;
        struct
        {
            HANDLE ThreadHandle;
        } PauseThreadIptTrace;
        struct
        {
            HANDLE ThreadHandle;
        } ResumeThreadIptTrace;
        struct
        {
            HANDLE ProcessHandle;
        } QueryProcessIptTrace;
    };
} IPT_INPUT_BUFFER, *PIPT_INPUT_BUFFER;
C_ASSERT(sizeof(IPT_INPUT_BUFFER) == 0x28);

//
// IOCTL Output Request Buffer
//
typedef struct _IPT_OUTPUT_BUFFER
{
    union
    {
        struct
        {
            IPT_BUFFER_VERSION;
        } GetBufferMajorVersion;
        struct
        {
            USHORT TraceVersion;
        } GetTraceVersion;
        struct
        {
            USHORT TraceVersion;
            ULONGLONG TraceSize;
        } GetTraceSize;
        struct
        {
            IPT_TRACE_DATA;
        } GetTrace;
        struct
        {
            BOOLEAN OldState;
        } PauseTrace;
        struct
        {
            BOOLEAN OldState;
        } ResumeTrace;
        struct
        {
            IPT_OPTIONS Options;
        } QueryProcessTrace;
        struct
        {
            IPT_OPTIONS Options;
        } QueryCoreTrace;
    };
} IPT_OUTPUT_BUFFER, *PIPT_OUTPUT_BUFFER;
C_ASSERT(sizeof(IPT_OUTPUT_BUFFER) == 0x10);

//
// IOCTLs that the IPT Driver Handles
//
#define IOCTL_IPT_REQUEST \
    CTL_CODE(FILE_DEVICE_UNKNOWN, 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_IPT_READ_TRACE \
    CTL_CODE(FILE_DEVICE_UNKNOWN, 1, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)


```

`inc/libipt.h`:

```h
#pragma once
#pragma warning(disable:4214)
#pragma warning(disable:4201)

//
// Version number of IPT Service IOCTL buffers
//
#define IPT_BUFFER_MAJOR_VERSION_V1         1
#define IPT_BUFFER_MAJOR_VERSION_CURRENT    IPT_BUFFER_MAJOR_VERSION_V1
#define IPT_BUFFER_MINOR_VERSION_V0         0
#define IPT_BUFFER_MINOR_VERSION_CURRENT    IPT_BUFFER_MINOR_VERSION_V0

//
// Version numbers of trace formats
//
#define IPT_TRACE_VERSION_V1                1
#define IPT_TRACE_VERSION_CURRENT           IPT_TRACE_VERSION_V1

//
// See OnProcessCreate
//
typedef enum _IPT_MATCH_SETTINGS
{
    IptMatchByAnyApp,
    IptMatchByImageFileName,
    IptMatchByAnyPackage,
    IptMatchByPackageName,
} IPT_MATCH_SETTINGS;

//
// See GetIptOptionForTracingThreads vs GetIptOptionForTracingCores
//
typedef enum _IPT_MODE_SETTINGS
{
    //
    // Set through IOCTL (IptStartCoreIptTracing)
    //
    IptCtlUserModeOnly,                 // Sets BranchEn[2000], ToPA[100], User[8]
    IptCtlKernelModeOnly,               // Sets BranchEn[2000], ToPA[100], OS[4]
    IptCtlUserAndKernelMode,            // Sets BranchEn[2000], ToPA[100], User[8], OS[4]

    //
    // Set through registry (IptOptions)
    //
    IptRegUserModeOnly,                 // Sets BranchEn[2000], ToPA[100], User[8]
    IptRegKernelModeOnly,               // Sets BranchEn[2000], ToPA[100], OS[4]
    IptRegUserAndKernelMode,            // Sets BranchEn[2000], ToPA[100], User[8], OS[4]
} IPT_MODE_SETTINGS;

typedef enum IPT_TIMING_SETTINGS
{
    IptNoTimingPackets,                 // No additional IA32_RTIT_CTL bits enabled
    IptEnableMtcPackets,                // Sets MTCEn[400], TSCEn[200]. Requires CPUID.(EAX=014H,ECX=0H):EBX[3]= 1
    IptEnableCycPackets                 // Sets MTCEn[400], TSCEn[200], CYCEn[2]. Requires CPUID.(EAX=014H,ECX=0H):EBX[1]= 1
} IPT_TIMING_SETTINGS;

//
// See CheckIptOption
//
typedef union _IPT_OPTIONS
{
    struct
    {
        DWORDLONG OptionVersion : 4;    // Must be set to 1
        DWORDLONG TimingSettings : 4;   // IPT_TIMING_SETTINGS

        DWORDLONG MtcFrequency : 4;     // Bits 14:17 in IA32_RTIT_CTL
        DWORDLONG CycThreshold : 4;     // Bits 19:22 in IA32_RTIT_CTL

        DWORDLONG TopaPagesPow2 : 4;    // Size of buffer in ToPA, as 4KB powers of 2 (4KB->128MB). Multiple buffers will be used if CPUID.(EAX=014H,ECX=0H):ECX[1]= 1
        DWORDLONG MatchSettings: 3;     // IPT_MATCH_SETTINGS
        DWORDLONG Inherit : 1;          // Children will be automatically added to the trace

        DWORDLONG ModeSettings : 4;     // IPT_MODE_SETTINGS
        DWORDLONG Reserved : 36;
    };
    DWORDLONG AsULonglong;
} IPT_OPTIONS, *PIPT_OPTIONS;
C_ASSERT(sizeof(IPT_OPTIONS) == 8);

typedef struct _IPT_TRACE_DATA
{
    WORD TraceVersion;
    WORD ValidTrace;
    ULONG TraceSize;
    BYTE TraceData[ANYSIZE_ARRAY];
} IPT_TRACE_DATA, *PIPT_TRACE_DATA;

typedef struct _IPT_TRACE_HEADER
{
    HANDLE ThreadId;
    IPT_TIMING_SETTINGS TimingSettings;
    DWORD MtcFrequency;
    DWORD FrequencyToTscRatio;
    DWORD RingBufferOffset;
    DWORD TraceSize;
    BYTE Trace[ANYSIZE_ARRAY];
} IPT_TRACE_HEADER, *PIPT_TRACE_HEADER;

BOOL
GetIptBufferVersion (
    _Out_ PDWORD pdwBufferMajorVersion
);

BOOL
GetIptTraceVersion (
    _Out_ PWORD pwTraceVersion
);

BOOL
GetProcessIptTraceSize (
    _In_ HANDLE hProcess,
    _Out_ PDWORD pdwTraceSize
);

BOOL
GetProcessIptTrace (
    _In_ HANDLE hProcess,
    _In_ PVOID pTrace,
    _In_ DWORD dwTraceSize
);

BOOL
StartProcessIptTracing (
    _In_ HANDLE hProcess,
    _In_ IPT_OPTIONS ullOptions
);

BOOL
StopProcessIptTracing (
    _In_ HANDLE hProcess
);

BOOL
StartCoreIptTracing (
    _In_ IPT_OPTIONS ullOptions,
    _In_ DWORD dwNumberOfTries,
    _In_ DWORD dwTraceDurationInSeconds
);

BOOL
RegisterExtendedImageForIptTracing (
    _In_ PWCHAR pwszImagePath,
    _In_opt_ PWCHAR pwszFilteredPath,
    _In_ IPT_OPTIONS ullOptions,
    _In_ DWORD dwNumberOfTries,
    _In_ DWORD dwTraceDurationInSeconds
);

BOOL
PauseThreadIptTracing (
    _In_ HANDLE hThread,
    _In_ PBOOLEAN pbResult
);

BOOL
ResumeThreadIptTracing (
    _In_ HANDLE hThread,
    _In_ PBOOLEAN pbResult
);

BOOL
QueryProcessIptTracing (
    _In_ HANDLE hProcess,
    _Out_ PIPT_OPTIONS pullOptions
);

BOOL
QueryCoreIptTracing (
    _Out_ PIPT_OPTIONS pullOptions
);

```

`inc/libiptnt.h`:

```h
#pragma once
#pragma warning(disable:4214)
#pragma warning(disable:4201)

//
// Version number of IPT Service IOCTL buffers
//
#define IPT_BUFFER_MAJOR_VERSION_V1         1
#define IPT_BUFFER_MAJOR_VERSION_CURRENT    IPT_BUFFER_MAJOR_VERSION_V1
#define IPT_BUFFER_MINOR_VERSION_V0         0
#define IPT_BUFFER_MINOR_VERSION_CURRENT    IPT_BUFFER_MINOR_VERSION_V0

//
// Version numbers of trace formats
//
#define IPT_TRACE_VERSION_V1                1
#define IPT_TRACE_VERSION_CURRENT           IPT_TRACE_VERSION_V1

//
// See OnProcessCreate
//
typedef enum _IPT_MATCH_SETTINGS
{
    IptMatchByAnyApp,
    IptMatchByImageFileName,
    IptMatchByAnyPackage,
    IptMatchByPackageName,
} IPT_MATCH_SETTINGS;

//
// See GetIptOptionForTracingThreads vs GetIptOptionForTracingCores
//
typedef enum _IPT_MODE_SETTINGS
{
    //
    // Set through IOCTL (IptStartCoreIptTracing)
    //
    IptCtlUserModeOnly,                 // Sets BranchEn[2000], ToPA[100], User[8]
    IptCtlKernelModeOnly,               // Sets BranchEn[2000], ToPA[100], OS[4]
    IptCtlUserAndKernelMode,            // Sets BranchEn[2000], ToPA[100], User[8], OS[4]

    //
    // Set through registry (IptOptions)
    //
    IptRegUserModeOnly,                 // Sets BranchEn[2000], ToPA[100], User[8]
    IptRegKernelModeOnly,               // Sets BranchEn[2000], ToPA[100], OS[4]
    IptRegUserAndKernelMode,            // Sets BranchEn[2000], ToPA[100], User[8], OS[4]
} IPT_MODE_SETTINGS;

typedef enum IPT_TIMING_SETTINGS
{
    IptNoTimingPackets,                 // No additional IA32_RTIT_CTL bits enabled
    IptEnableMtcPackets,                // Sets MTCEn[400], TSCEn[200]. Requires CPUID.(EAX=014H,ECX=0H):EBX[3]= 1
    IptEnableCycPackets                 // Sets MTCEn[400], TSCEn[200], CYCEn[2]. Requires CPUID.(EAX=014H,ECX=0H):EBX[1]= 1
} IPT_TIMING_SETTINGS;

//
// See CheckIptOption
//
typedef union _IPT_OPTIONS
{
    struct
    {
        ULONGLONG OptionVersion : 4;    // Must be set to 1
        ULONGLONG TimingSettings : 4;   // IPT_TIMING_SETTINGS

        ULONGLONG MtcFrequency : 4;     // Bits 14:17 in IA32_RTIT_CTL
        ULONGLONG CycThreshold : 4;     // Bits 19:22 in IA32_RTIT_CTL

        ULONGLONG TopaPagesPow2 : 4;    // Size of buffer in ToPA, as 4KB powers of 2 (4KB->128MB). Multiple buffers will be used if CPUID.(EAX=014H,ECX=0H):ECX[1]= 1
        ULONGLONG MatchSettings: 3;     // IPT_MATCH_SETTINGS
        ULONGLONG Inherit : 1;          // Children will be automatically added to the trace

        ULONGLONG ModeSettings : 4;     // IPT_MODE_SETTINGS
        ULONGLONG Reserved : 36;
    };
    ULONGLONG AsULonglong;
} IPT_OPTIONS, *PIPT_OPTIONS;
C_ASSERT(sizeof(IPT_OPTIONS) == 8);

typedef struct _IPT_TRACE_DATA
{
    USHORT TraceVersion;
    USHORT ValidTrace;
    ULONG TraceSize;
    UCHAR TraceData[ANYSIZE_ARRAY];
} IPT_TRACE_DATA, *PIPT_TRACE_DATA;

typedef struct _IPT_TRACE_HEADER
{
    HANDLE ThreadId;
    IPT_TIMING_SETTINGS TimingSettings;
    ULONG MtcFrequency;
    ULONG FrequencyToTscRatio;
    ULONG RingBufferOffset;
    ULONG TraceSize;
    UCHAR Trace[ANYSIZE_ARRAY];
} IPT_TRACE_HEADER, *PIPT_TRACE_HEADER;

NTSTATUS
GetIptBufferVersion (
    _Out_ PULONG BufferMajorVersion
);

NTSTATUS
GetIptTraceVersion (
    _Out_ PUSHORT TraceVersion
);

NTSTATUS
GetProcessIptTraceSize (
    _In_ HANDLE ProcessHandle,
    _Out_ PULONG TraceSize
);

NTSTATUS
GetProcessIptTrace (
    _In_ HANDLE ProcessHandle,
    _In_ PVOID Trace,
    _In_ ULONG TraceSize
);

NTSTATUS
StartProcessIptTrace (
    _In_ HANDLE ProcessHandle,
    _In_ IPT_OPTIONS Options
);

NTSTATUS
StopProcessIptTrace (
    _In_ HANDLE ProcessHandle
);

NTSTATUS
StartCoreIptTracing (
    _In_ IPT_OPTIONS Options,
    _In_ ULONG NumberOfTries,
    _In_ ULONG TraceDurationInSeconds
);

NTSTATUS
RegisterExtendedImageForIptTracing (
    _In_ PWCHAR ImagePath,
    _In_opt_ PWCHAR FilteredPath,
    _In_ IPT_OPTIONS Options,
    _In_ ULONG NumberOfTries,
    _In_ ULONG TraceDurationInSeconds
);

```

`ipttool/ipttool.c`:

```c
#include <Windows.h>
#include <stdio.h>
#include <libipt.h>

#define IPT_TOOL_USE_MTC_TIMING_PACKETS     0x01
#define IPT_TOOL_USE_CYC_TIMING_PACKETS     0x02
#define IPT_TOOL_TRACE_KERNEL_MODE          0x04
#define IPT_TOOL_TRACE_ALL_MODE             0x08

#define IPT_TOOL_VALID_FLAGS                \
    (IPT_TOOL_USE_MTC_TIMING_PACKETS |      \
     IPT_TOOL_USE_CYC_TIMING_PACKETS |      \
     IPT_TOOL_TRACE_KERNEL_MODE |           \
     IPT_TOOL_TRACE_ALL_MODE)

typedef enum _IPT_TL_ACTION
{
    IptTlStartTrace,
    IptTlStopTrace,
    IptTlGetTrace,
    IptTlQueryTrace,
    IptTlPauseTrace,
    IptTlResumeTrace
} IPT_TL_ACTION;

FORCEINLINE
DWORD
ConvertToPASizeToSizeOption (
    _In_ DWORD dwSize
    )
{
    DWORD dwIndex;

    //
    // Cap the size to 128MB. Sizes below 4KB will result in 0 anyway.
    //
    if (dwSize > (128 * 1024 * 1024))
    {
        dwSize = 128 * 1024 * 1024;
    }

    //
    // Find the nearest power of two that's set (align down)
    //
    BitScanReverse(&dwIndex, dwSize);

    //
    // The value starts at 4KB
    //
    dwIndex -= 12;
    return dwIndex;
}

BOOL
EnableIpt (
    VOID
    )
{
    SC_HANDLE hScm, hSc;
    BOOL bRes;
    bRes = FALSE;

    //
    // Open a handle to the SCM
    //
    hScm = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (hScm != NULL)
    {
        //
        // Open a handle to the IPT Service
        //
        hSc = OpenService(hScm, L"Ipt", SERVICE_START);
        if (hSc != NULL)
        {
            //
            // Start it
            //
            bRes = StartService(hSc, 0, NULL);
            if ((bRes == FALSE) &&
                (GetLastError() == ERROR_SERVICE_ALREADY_RUNNING))
            {
                //
                // If it's already started, that's OK
                //
                bRes = TRUE;
            }
            else if (bRes == FALSE)
            {
                wprintf(L"[-] Unable to start IPT Service (err=%d)\n",
                        GetLastError());
                if (GetLastError() == ERROR_NOT_SUPPORTED)
                {
                    wprintf(L"[-] This is likely due to missing PT support\n");
                }
            }

            //
            // Done with the service
            //
            CloseServiceHandle(hSc);
        }
        else
        {
            wprintf(L"[-] Unable to open IPT Service (err=%d). "
                    L"Are you running Windows 10 1809?\n",
                    GetLastError());
        }

        //
        // Done with the SCM
        //
        CloseServiceHandle(hScm);
    }
    else
    {
        wprintf(L"[-] Unable to open a handle to the SCM (err=%d)\n",
                GetLastError());
    }

    //
    // Return the result
    //
    return bRes;
}

BOOL
EnableAndValidateIptServices (
    VOID
    )
{
    WORD wTraceVersion;
    DWORD dwBufferVersion;
    BOOL bRes;

    //
    // First enable IPT
    //
    bRes = EnableIpt();
    if (bRes == FALSE)
    {
        wprintf(L"[-] Intel PT Service could not be started!\n");
        goto Cleanup;
    }

    //
    // Next, check if the driver uses a dialect we understand
    //
    bRes = GetIptBufferVersion(&dwBufferVersion);
    if (bRes == FALSE)
    {
        wprintf(L"[-] Failed to communicate with IPT Service: (err=%d)\n",
                GetLastError());
        goto Cleanup;
    }
    if (dwBufferVersion != IPT_BUFFER_MAJOR_VERSION_CURRENT)
    {
        wprintf(L"[-] IPT Service buffer version is not supported: %d\n",
                dwBufferVersion);
        goto Cleanup;
    }

    //
    // Then, check if the driver uses trace versions we speak
    //
    bRes = GetIptTraceVersion(&wTraceVersion);
    if (bRes == FALSE)
    {
        wprintf(L"[-] Failed to get Trace Version from IPT Service (err=%d)\n",
                GetLastError());
        goto Cleanup;
    }
    if (wTraceVersion != IPT_TRACE_VERSION_CURRENT)
    {
        wprintf(L"[-] IPT Service trace version is not supported %d\n",
                wTraceVersion);
        goto Cleanup;
    }

Cleanup:
    //
    // Return result
    //
    return bRes;
}

BOOL
ConfigureTraceFlags (
    _In_ PWCHAR pwszFlags,
    _Inout_ PIPT_OPTIONS pOptions
    )
{
    DWORD dwFlags;
    BOOL bRes;
    bRes = FALSE;

    //
    // Read the flags now and make sure they're valid
    //
    dwFlags = wcstoul(pwszFlags, NULL, 16);
    if (dwFlags & ~IPT_TOOL_VALID_FLAGS)
    {
        wprintf(L"[-] Invalid flags: %s\n", pwszFlags);
        goto Cleanup;
    }

    //
    // If the user didn't specify MTC, but wants CYC, set MTC too as the IPT
    // driver wil enable those packets anyway.
    //
    if ((dwFlags & IPT_TOOL_USE_CYC_TIMING_PACKETS) &&
        !(dwFlags & IPT_TOOL_USE_MTC_TIMING_PACKETS))
    {
        wprintf(L"[*] CYC Packets require MTC packets, adjusting flags!\n");
        dwFlags |= IPT_TOOL_USE_MTC_TIMING_PACKETS;
    }

    //
    // If the user didn't specify MTC, but wants CYC, set MTC too as the IPT
    // driver wil enable those packets anyway.
    //
    if ((dwFlags & (IPT_TOOL_TRACE_KERNEL_MODE | IPT_TOOL_TRACE_ALL_MODE)) ==
        (IPT_TOOL_TRACE_KERNEL_MODE | IPT_TOOL_TRACE_ALL_MODE))
    {
        wprintf(L"[-] Cannot enable both `kernel` and `user + kernel` tracing."
                L" Please pick a single flag to use!\n");
        goto Cleanup;
    }

    //
    // There are no matching options for process tradces
    //
    pOptions->MatchSettings = IptMatchByAnyApp;

    //
    // Choose the right timing setting
    //
    if (dwFlags & IPT_TOOL_USE_MTC_TIMING_PACKETS)
    {
        pOptions->TimingSettings = IptEnableMtcPackets;
        pOptions->MtcFrequency = 3; // FIXME
    }
    else if (dwFlags & IPT_TOOL_USE_CYC_TIMING_PACKETS)
    {
        pOptions->TimingSettings = IptEnableCycPackets;
        pOptions->CycThreshold = 1; // FIXME
    }
    else
    {
        pOptions->TimingSettings = IptNoTimingPackets;
    }

    //
    // Choose the right mode setting
    //
    if (dwFlags & IPT_TOOL_TRACE_KERNEL_MODE)
    {
        pOptions->ModeSettings = IptCtlKernelModeOnly;
    }
    else if (dwFlags & IPT_TOOL_TRACE_ALL_MODE)
    {
        pOptions->ModeSettings = IptCtlUserAndKernelMode;
    }
    else
    {
        pOptions->ModeSettings = IptCtlUserModeOnly;
    }

    //
    // Print out chosen options
    //
    bRes = TRUE;
    wprintf(L"[+] Tracing Options:\n"
            L"           Match by: %s\n"
            L"         Trace mode: %s\n"
            L"     Timing packets: %s\n",
            L"Any process",
            (pOptions->ModeSettings == IptCtlUserAndKernelMode) ?
            L"Kernel and user-mode" :
            (pOptions->ModeSettings == IptCtlKernelModeOnly) ?
            L"Kernel-mode only" : L"User-mode only",
            (pOptions->TimingSettings == IptEnableMtcPackets) ?
            L"MTC Packets" :
            (pOptions->TimingSettings == IptEnableCycPackets) ?
            L"CYC Packets" : L"No  Packets");

Cleanup:
    //
    // Return result
    //
    return bRes;
}

BOOL
ConfigureBufferSize (
    _In_ PWCHAR pwszSize,
    _Inout_ PIPT_OPTIONS pOptions
    )
{
    DWORD dwSize;
    BOOL bRes;
    bRes = FALSE;

    //
    // Get the buffer size
    //
    dwSize = wcstoul(pwszSize, NULL, 10);
    if (dwSize == 0)
    {
        wprintf(L"[-] Invalid size: %s\n", pwszSize);
        goto Cleanup;
    }

    //
    // Warn the user about incorrect values
    //
    if (!((dwSize) && ((dwSize & (~dwSize + 1)) == dwSize)))
    {
        wprintf(L"[*] Size will be aligned to a power of 2\n");
    }
    else if (dwSize < 4096)
    {
        wprintf(L"[*] Size will be set to minimum of 4KB\n");
    }
    else if (dwSize > (128 * 1024 * 1024))
    {
        wprintf(L"[*] Size will be set to a maximum of 128MB\n");
    }

    //
    // Compute the size option
    //
    pOptions->TopaPagesPow2 = ConvertToPASizeToSizeOption(dwSize);
    bRes = TRUE;
    wprintf(L"[+] Using size: %d bytes\n",
            1 << (pOptions->TopaPagesPow2 + 12));

Cleanup:
    //
    // Return result
    //
    return bRes;
}

BOOL
ConfigureProcess (
    _In_ PWCHAR pwszPid,
    _Out_ PHANDLE phProcess
    )
{
    DWORD dwPid;
    BOOL bRes;
    bRes = FALSE;
    *phProcess = NULL;

    //
    // Get the PID first
    //
    dwPid = wcstoul(pwszPid, NULL, 0);
    if (dwPid == 0)
    {
        wprintf(L"[-] Invalid PID: %s\n", pwszPid);
        goto Cleanup;
    }

    //
    // Open a handle to it
    //
    *phProcess = OpenProcess(PROCESS_VM_READ, FALSE, dwPid);
    if (*phProcess == NULL)
    {
        wprintf(L"[-] Unable to open PID %d (err=%d)\n",
                dwPid, GetLastError());
        goto Cleanup;
    }
    bRes = TRUE;

Cleanup:
    //
    // Return result
    //
    return bRes;
}

BOOL
ConfigureThread (
    _In_ PWCHAR pwszTid,
    _Out_ PHANDLE phThread
    )
{
    DWORD dwPid;
    BOOL bRes;
    bRes = FALSE;
    *phThread = NULL;

    //
    // Get the PID first
    //
    dwPid = wcstoul(pwszTid, NULL, 0);
    if (dwPid == 0)
    {
        wprintf(L"[-] Invalid TID: %s\n", pwszTid);
        goto Cleanup;
    }

    //
    // Open a handle to it
    //
    *phThread = OpenThread(THREAD_GET_CONTEXT, FALSE, dwPid);
    if (*phThread == NULL)
    {
        wprintf(L"[-] Unable to open TID %d (err=%d)\n",
                dwPid, GetLastError());
        goto Cleanup;
    }
    bRes = TRUE;

Cleanup:
    //
    // Return result
    //
    return bRes;
}

INT
wmain (
    _In_ DWORD dwArgumentCount,
    _In_ PWCHAR pwszArguments[]
    )
{
    BOOL bRes;
    DWORD dwTraceSize;
    HANDLE hProcess;
    HANDLE hThread;
    HANDLE hTraceFile;
    DWORD dwResult;
    IPT_TL_ACTION dwAction;
    IPT_OPTIONS options;
    PIPT_TRACE_DATA pTraceData;
    PIPT_TRACE_HEADER traceHeader;
    DWORD dwEntries;
    UINT i;
    BOOLEAN result;

    //
    // Setup cleanup path
    //
    hTraceFile = INVALID_HANDLE_VALUE;
    hProcess = NULL;
    hThread = NULL;
    pTraceData = NULL;
    dwResult = 0xFFFFFFFF;
    options.AsULonglong = 0;
    result = 0;

    //
    // Shameless banner header
    //
    wprintf(L"/-----------------------------------------\\\n");
    wprintf(L"|=== Windows 10 RS5 1809 IPT Test Tool ===|\n");
    wprintf(L"|===  Copyright (c) 2018 Alex Ionescu  ===|\n");
    wprintf(L"|===    http://github.com/ionescu007   ===|\n");
    wprintf(L"|===  http://www.windows-internals.com ===|\n");
    wprintf(L"\\-----------------------------------------/\n");
    wprintf(L"\n");

    //
    // Print banner if invalid/no arguments
    //
    if (dwArgumentCount <= 1)
    {
Banner:
        wprintf(L"Usage: IptTool.exe [action] <PID> <Flags>\n");
        wprintf(L"       --start <PID> <Size> <Flags>     "
                L"Starts Intel PT tracing for the given PID\n");
        wprintf(L"                                        "
                L"Size should be a power of two between 4KB-128MB in bytes\n");
        wprintf(L"                                        "
                L"Flag 0x00 - No Timing Packets, Trace only User Mode Code\n"
                L"                                        "
                L"Flag 0x01 - Enable MTC Timing Packets\n"
                L"                                        "
                L"Flag 0x02 - Enable CYC Timing Packets\n"
                L"                                        "
                L"Flag 0x04 - Trace only Kernel Mode Code\n"
                L"                                        "
                L"Flag 0x08 - Trace both User and Kernel Mode Code\n");
        wprintf(L"       --trace <PID> <File>             "
                L"Writes into the given file the current trace data for the given PID\n");
        wprintf(L"       --stop <PID>                     "
                L"Stops Intel PT tracing for the specified PID\n");
        wprintf(L"       --query <PID>                    "
                L"Queries the status of Intel PT tracing for the specified PID\n");
        wprintf(L"       --pause <TID>                    "
                L"Pauses Intel PT tracing for the specified TID\n");
        wprintf(L"       --resume <TID>                   "
                L"Resumes Intel PT tracing for the specified TID\n");
        wprintf(L"\n");
        wprintf(L"All operations require PROCESS_VM_READ rights to the target PID\n"
                L"or THREAD_GET_CONTEXT rights to the target TID, respectively\n");
        goto Cleanup;
    }

    //
    // Start parsing arguments
    //
    if (wcscmp(pwszArguments[1], L"--start") == 0)
    {
        //
        // Five arguments are neded to start a trace
        //
        if (dwArgumentCount != 5)
        {
            goto Banner;
        }

        //
        // Open a handle to the PID
        //
        bRes = ConfigureProcess(pwszArguments[2], &hProcess);
        if (bRes == FALSE)
        {
            goto Cleanup;
        }

        //
        // Initialize options for Intel PT Trace
        //
        options.OptionVersion = 1;

        //
        // Configure the buffer size
        //
        bRes = ConfigureBufferSize(pwszArguments[3], &options);
        if (bRes == FALSE)
        {
            goto Cleanup;
        }

        //
        // Configure the trace flag
        //
        bRes = ConfigureTraceFlags(pwszArguments[4], &options);
        if (bRes == FALSE)
        {
            goto Cleanup;
        }

        //
        // We are starting a trace, once we know the driver works
        //
        dwAction = IptTlStartTrace;
    }
    else if (wcscmp(pwszArguments[1], L"--stop") == 0)
    {
        //
        // Stopping a trace needs 3 arguments
        //
        if (dwArgumentCount != 3)
        {
            goto Banner;
        }

        //
        // Open a handle to the PID
        //
        bRes = ConfigureProcess(pwszArguments[2], &hProcess);
        if (bRes == FALSE)
        {
            goto Cleanup;
        }

        //
        // We are stopping a trace, once we know the driver works
        //
        dwAction = IptTlStopTrace;
    }
    else if (wcscmp(pwszArguments[1], L"--trace") == 0)
    {
        //
        // Writing a trace needs 4 arguments
        //
        if (dwArgumentCount != 4)
        {
            goto Banner;
        }

        //
        // Open a handle to the PID
        //
        bRes = ConfigureProcess(pwszArguments[2], &hProcess);
        if (bRes == FALSE)
        {
            goto Cleanup;
        }

        //
        // Open a handle to the trace file
        //
        hTraceFile = CreateFile(pwszArguments[3],
                                FILE_GENERIC_WRITE,
                                FILE_SHARE_READ,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);
        if (hTraceFile == INVALID_HANDLE_VALUE)
        {
            wprintf(L"[-] Unable to create trace file %s (err=%d)\n",
                    pwszArguments[3],
                    GetLastError());
            goto Cleanup;
        }

        //
        // We are getting a trace, once we know the driver works
        //
        dwAction = IptTlGetTrace;
    }
    else if (wcscmp(pwszArguments[1], L"--query") == 0)
    {
        //
        // Querying process trace status needs 3 arguments
        //
        if (dwArgumentCount != 3)
        {
            goto Banner;
        }

        //
        // Open a handle to the PID
        //
        bRes = ConfigureProcess(pwszArguments[2], &hProcess);
        if (bRes == FALSE)
        {
            goto Cleanup;
        }

        //
        // We are querying process trace, once we know the driver works
        //
        dwAction = IptTlQueryTrace;
    }
    else if (wcscmp(pwszArguments[1], L"--pause") == 0)
    {
        //
        // Pausing thread trace needs 3 arguments
        //
        if (dwArgumentCount != 3)
        {
            goto Banner;
        }

        //
        // Open a handle to the TID
        //
        bRes = ConfigureThread(pwszArguments[2], &hThread);
        if (bRes == FALSE)
        {
            goto Cleanup;
        }

        //
        // We are pausing thread trace, once we know the driver works
        //
        dwAction = IptTlPauseTrace;
    }
    else if (wcscmp(pwszArguments[1], L"--resume") == 0)
    {
        //
        // Resuming thread trace needs 3 arguments
        //
        if (dwArgumentCount != 3)
        {
            goto Banner;
        }

        //
        // Open a handle to the TID
        //
        bRes = ConfigureThread(pwszArguments[2], &hThread);
        if (bRes == FALSE)
        {
            goto Cleanup;
        }

        //
        // We are resuming thread trace, once we know the driver works
        //
        dwAction = IptTlResumeTrace;
    }
    else
    {
        goto Banner;
    }

    //
    // Enable and validate IPT support works
    //
    bRes = EnableAndValidateIptServices();
    if (bRes == FALSE)
    {
        goto Cleanup;
    }

    //
    // Check what we're doing
    //
    switch (dwAction)
    {
        case IptTlStartTrace:
        {
            //
            // Start the trace
            //
            bRes = StartProcessIptTracing(hProcess, options);
            if (bRes == FALSE)
            {
                wprintf(L"[-] Failed to start a trace (err=%d)\n",
                        GetLastError());
                goto Cleanup;
            }

            //
            // Print out the status
            //
            wprintf(L"[+] Trace for PID %s started\n",
                    pwszArguments[2]);
            dwResult = 0;
            break;
        }

        case IptTlStopTrace:
        {
            //
            // Stop the trace
            //
            bRes = StopProcessIptTracing(hProcess);
            if (bRes == FALSE)
            {
                wprintf(L"[-] Failed to stop the trace (err=%d)\n",
                        GetLastError());
                goto Cleanup;
            }

            //
            // Print out the status
            //
            wprintf(L"[+] Trace for PID %s stopped\n",
                    pwszArguments[2]);
            dwResult = 0;
            break;
        }

        case IptTlQueryTrace:
        {
            //
            // Query the trace
            //
            bRes = QueryProcessIptTracing(hProcess, &options);
            if (bRes == FALSE)
            {
                wprintf(L"[-] Tracing is not enabled for this process\n");
                goto Cleanup;
            }

            //
            // Print out the status
            //
            wprintf(L"[+] Tracing Options:\n"
                    L"           Match by: %s\n"
                    L"         Trace mode: %s\n"
                    L"     Timing packets: %s\n",
                    L"Any process",
                    (options.ModeSettings == IptCtlUserAndKernelMode) ?
                    L"Kernel and user-mode" :
                    (options.ModeSettings == IptCtlKernelModeOnly) ?
                    L"Kernel-mode only" : L"User-mode only",
                    (options.TimingSettings == IptEnableMtcPackets) ?
                    L"MTC Packets" :
                    (options.TimingSettings == IptEnableCycPackets) ?
                    L"CYC Packets" : L"No  Packets");
            dwResult = 0;
            break;
        }

        case IptTlPauseTrace:
        {
            //
            // Pause tracing for this thread
            //
            bRes = PauseThreadIptTracing(hThread, &result);
            if (bRes == FALSE)
            {
                wprintf(L"[-] Failed to pause the trace (err=%d)\n",
                        GetLastError());
                goto Cleanup;
            }

            //
            // Print result
            //
            wprintf(L"Trace for TID %s paused, it was previously %s\n",
                    pwszArguments[2],
                    (result == 1) ? L"active" : L"paused");
            dwResult = 0;
            break;
        }

        case IptTlResumeTrace:
        {
            //
            // Resume tracing for this thread
            //
            bRes = ResumeThreadIptTracing(hThread, &result);
            if (bRes == FALSE)
            {
                wprintf(L"[-] Failed to resume the trace (err=%d)\n",
                        GetLastError());
                goto Cleanup;
            }

            //
            // Print result
            //
            wprintf(L"Trace for TID %s resumed, it was previously %s\n",
                    pwszArguments[2],
                    (result == 1) ? L"active" : L"paused");
            dwResult = 0;
            break;
        }

        case IptTlGetTrace:
        {
            //
            // Get the size of the trace
            //
            bRes = GetProcessIptTraceSize(hProcess, &dwTraceSize);
            if (bRes == FALSE)
            {
                wprintf(L"[-] Failed to query trace size (err=%d). "
                        L"Are you sure one is active?\n",
                        GetLastError());
                goto Cleanup;
            }

            //
            // Allocate a local buffer
            //
            pTraceData = HeapAlloc(GetProcessHeap(),
                                   HEAP_ZERO_MEMORY,
                                   dwTraceSize);
            if (pTraceData == NULL)
            {
                wprintf(L"[-] Out of memory while trying to allocate trace data\n");
                goto Cleanup;
            }

            //
            // Query the trace
            //
            wprintf(L"[+] Found active trace with %d bytes so far\n", dwTraceSize);
            bRes = GetProcessIptTrace(hProcess, pTraceData, dwTraceSize);
            if (bRes == FALSE)
            {
                wprintf(L"[-] Failed to query trace (err=%d)\n",
                        GetLastError());
                goto Cleanup;
            }

            //
            // Compute the number of thread entries in the trace data
            //
            dwEntries = (dwTraceSize - (dwTraceSize & ~0xFFF)) /
                         FIELD_OFFSET(IPT_TRACE_HEADER, Trace);
            wprintf(L"    [+] Trace contains %d thread headers\n", dwEntries);

            //
            // Parse each entry
            //
            traceHeader = (PIPT_TRACE_HEADER)pTraceData->TraceData;
            for (i = 0; i < dwEntries; i++)
            {
                //
                // Print out information from it
                //
                wprintf(L"        [+] Trace Entry %d for TID %p\n",
                        i,
                        traceHeader->ThreadId);
                wprintf(L"               Trace Size: %08d     "
                        L"        [Ring Buffer Offset: %d]\n",
                        traceHeader->TraceSize,
                        traceHeader->RingBufferOffset);
                wprintf(L"              Timing Mode: %s  "
                        L"        [MTC Frequency: %d, ClockTsc Ratio: %d]\n",
                        (traceHeader->TimingSettings == IptEnableMtcPackets) ?
                        L"MTC Packets" :
                        (traceHeader->TimingSettings == IptEnableCycPackets) ?
                        L"CYC Packets" : L"No  Packets",
                        traceHeader->MtcFrequency,
                        traceHeader->FrequencyToTscRatio);

                //
                // Move to the next trace header
                //
                traceHeader = (PIPT_TRACE_HEADER)(traceHeader->Trace +
                                                  traceHeader->TraceSize);
            }

            //
            // Write it to disk
            //
            bRes = WriteFile(hTraceFile,
                             pTraceData->TraceData,
                             dwTraceSize -
                             FIELD_OFFSET(IPT_TRACE_DATA, TraceData),
                             NULL,
                             NULL);
            if (bRes == FALSE)
            {
                wprintf(L"[-] Failed to write trace to disk (err=%d)\n",
                        GetLastError());
                goto Cleanup;
            }

            //
            // Print out the status
            //
            wprintf(L"[+] Trace for PID %s written to %s\n",
                    pwszArguments[2],
                    pwszArguments[3]);
            dwResult = 0;
            break;
        }

        DEFAULT_UNREACHABLE;
    }

Cleanup:
    //
    // Cleanup trace data if any was left over
    //
    if (pTraceData != NULL)
    {
        HeapFree(GetProcessHeap(), 0, pTraceData);
    }

    //
    // Close the trace file if we had one
    //
    if (hTraceFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hTraceFile);
    }

    //
    // Close the process handle if we had one
    //
    if (hProcess != NULL)
    {
        CloseHandle(hProcess);
    }

    //
    // Close the thread handle if we had one
    //
    if (hThread != NULL)
    {
        CloseHandle(hThread);
    }

    //
    // Return to caller
    //
    return dwResult;
}

```

`ipttool/ipttool.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="ipttool.c" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\libipt\libipt.vcxproj">
      <Project>{051de316-c76c-4cfc-82da-46c0b04cfad8}</Project>
    </ProjectReference>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{1B5BE021-FB5F-4792-AF04-39BF7705886E}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>winipt</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17704.0</WindowsTargetPlatformVersion>
    <ProjectName>ipttool</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <PropertyGroup>
    <IncludePath>..\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>Full</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <OmitFramePointers>true</OmitFramePointers>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`libipt/libipt.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="win32.c" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{051DE316-C76C-4CFC-82DA-46C0B04CFAD8}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>winipt</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17704.0</WindowsTargetPlatformVersion>
    <ProjectName>libipt</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <PropertyGroup>
    <IncludePath>..\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>Full</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <OmitFramePointers>true</OmitFramePointers>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`libipt/win32.c`:

```c
#include <Windows.h>
#include <libipt.h>
#include <ipt.h>

FORCEINLINE
VOID
InitializeIptBuffer (
    _Inout_ PIPT_INPUT_BUFFER pBuffer,
    _In_ IPT_INPUT_TYPE dwInputType
    )
{
    //
    // Zero it out and set the version
    //
    ZeroMemory(pBuffer, sizeof(*pBuffer));
    pBuffer->BufferMajorVersion = IPT_BUFFER_MAJOR_VERSION_CURRENT;
    pBuffer->BufferMinorVersion = IPT_BUFFER_MINOR_VERSION_CURRENT;

    //
    // Set the type
    //
    pBuffer->InputType = dwInputType;
}

FORCEINLINE
BOOL
OpenIptDevice (
    _Out_ PHANDLE phFile
    )
{
    //
    // Open the handle
    //
    *phFile = CreateFile(L"\\??\\IPT",
                         FILE_GENERIC_READ,
                         FILE_SHARE_READ,
                         NULL,
                         OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL |
                         FILE_FLAG_SEQUENTIAL_SCAN |
                         FILE_FLAG_NO_BUFFERING,
                         NULL);

    //
    // Return the result
    //
    return (*phFile == INVALID_HANDLE_VALUE) ? FALSE : TRUE;
}

BOOL
GetIptBufferVersion (
    _Out_ PDWORD pdwBufferMajorVersion
    )
{
    BOOL bRes;
    HANDLE hIpt;
    IPT_INPUT_BUFFER inputBuffer;
    IPT_BUFFER_VERSION outputBuffer;

    //
    // Initialize for failure
    //
    *pdwBufferMajorVersion = 0;

    //
    // Open the IPT Device
    //
    bRes = OpenIptDevice(&hIpt);
    if (bRes != FALSE)
    {
        //
        // Send only the version header of the input request.
        // The type is unused.
        //
        InitializeIptBuffer(&inputBuffer, -1);
        bRes = DeviceIoControl(hIpt,
                               IOCTL_IPT_REQUEST,
                               &inputBuffer,
                               sizeof(IPT_BUFFER_VERSION),
                               &outputBuffer,
                               sizeof(outputBuffer),
                               NULL,
                               NULL);
        CloseHandle(hIpt);

        //
        // On success, return the buffer version
        //
        if (bRes != FALSE)
        {
            *pdwBufferMajorVersion = outputBuffer.BufferMajorVersion;
        }
    }
    return bRes;
}

BOOL
GetIptTraceVersion (
    _Out_ PWORD pwTraceVersion
    )
{
    BOOL bRes;
    HANDLE hIpt;
    IPT_INPUT_BUFFER inputBuffer;
    IPT_OUTPUT_BUFFER outputBuffer;

    //
    // Initialize for failure
    //
    *pwTraceVersion = 0;

    //
    // Open the IPT Device
    //
    bRes = OpenIptDevice(&hIpt);
    if (bRes != FALSE)
    {
        //
        // Send a request to get the trace version
        //
        InitializeIptBuffer(&inputBuffer, IptGetTraceVersion);
        bRes = DeviceIoControl(hIpt,
                               IOCTL_IPT_REQUEST,
                               &inputBuffer,
                               sizeof(inputBuffer),
                               &outputBuffer,
                               sizeof(outputBuffer),
                               NULL,
                               NULL);
        CloseHandle(hIpt);

        //
        // On success, return the buffer version
        //
        if (bRes != FALSE)
        {
            *pwTraceVersion = outputBuffer.GetTraceVersion.TraceVersion;
        }
    }
    return bRes;
}

BOOL
GetProcessIptTraceSize (
    _In_ HANDLE hProcess,
    _Out_ PDWORD pdwTraceSize
    )
{
    BOOL bRes;
    HANDLE hIpt;
    IPT_INPUT_BUFFER inputBuffer;
    IPT_OUTPUT_BUFFER outputBuffer;

    //
    // Initialize for failure
    //
    *pdwTraceSize = 0;

    //
    // Open the IPT Device
    //
    bRes = OpenIptDevice(&hIpt);
    if (bRes != FALSE)
    {
        //
        // Send a request to get the trace size for the process
        //
        InitializeIptBuffer(&inputBuffer, IptGetProcessTraceSize);
        inputBuffer.GetProcessIptTraceSize.TraceVersion = IPT_TRACE_VERSION_CURRENT;
        inputBuffer.GetProcessIptTraceSize.ProcessHandle = hProcess;
        bRes = DeviceIoControl(hIpt,
                               IOCTL_IPT_REQUEST,
                               &inputBuffer,
                               sizeof(inputBuffer),
                               &outputBuffer,
                               sizeof(outputBuffer),
                               NULL,
                               NULL);
        CloseHandle(hIpt);

        //
        // Check if we got a size back
        //
        if (bRes != FALSE)
        {
            //
            // The IOCTL layer supports > 4GB traces but this doesn't exist yet
            // Otherwise, return the 32-bit trace size.
            //
            if (outputBuffer.GetTraceSize.TraceSize <= ULONG_MAX)
            {
                *pdwTraceSize = (DWORD)outputBuffer.GetTraceSize.TraceSize;
            }
            else
            {
                //
                // Mark this as a failure -- this is the Windows behavior too
                //
                SetLastError(ERROR_IMPLEMENTATION_LIMIT);
                bRes = FALSE;
            }
        }
    }
    return bRes;
}

BOOL
GetProcessIptTrace (
    _In_ HANDLE hProcess,
    _In_ PVOID pTrace,
    _In_ DWORD dwTraceSize
    )
{
    BOOL bRes;
    HANDLE hIpt;
    IPT_INPUT_BUFFER inputBuffer;

    //
    // The trace comes as part of an output buffer, so that part is required
    //
    bRes = FALSE;
    if (dwTraceSize < UFIELD_OFFSET(IPT_OUTPUT_BUFFER, GetTrace.TraceSize))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return bRes;
    }

    //
    // Open the IPT Device
    //
    bRes = OpenIptDevice(&hIpt);
    if (bRes != FALSE)
    {
        //
        // Send a request to get the trace for the process
        //
        InitializeIptBuffer(&inputBuffer, IptGetProcessTrace);
        inputBuffer.GetProcessIptTrace.TraceVersion = IPT_TRACE_VERSION_CURRENT;
        inputBuffer.GetProcessIptTrace.ProcessHandle = hProcess;
        bRes = DeviceIoControl(hIpt,
                               IOCTL_IPT_READ_TRACE,
                               &inputBuffer,
                               sizeof(inputBuffer),
                               pTrace,
                               dwTraceSize,
                               NULL,
                               NULL);
        CloseHandle(hIpt);
    }
    return bRes;
}

BOOL
StartProcessIptTracing (
    _In_ HANDLE hProcess,
    _In_ IPT_OPTIONS ullOptions
    )
{
    BOOL bRes;
    HANDLE hIpt;
    IPT_INPUT_BUFFER inputBuffer;
    IPT_OUTPUT_BUFFER outputBuffer;

    //
    // Open the IPT Device
    //
    bRes = OpenIptDevice(&hIpt);
    if (bRes != FALSE)
    {
        //
        // Send a request to start tracing for this process
        //
        InitializeIptBuffer(&inputBuffer, IptStartProcessTrace);
        inputBuffer.StartProcessIptTrace.Options = ullOptions;
        inputBuffer.StartProcessIptTrace.ProcessHandle = hProcess;
        bRes = DeviceIoControl(hIpt,
                               IOCTL_IPT_REQUEST,
                               &inputBuffer,
                               sizeof(inputBuffer),
                               &outputBuffer,
                               sizeof(outputBuffer),
                               NULL,
                               NULL);
        CloseHandle(hIpt);
    }
    return bRes;
}

BOOL
StopProcessIptTracing (
    _In_ HANDLE hProcess
    )
{
    BOOL bRes;
    HANDLE hIpt;
    IPT_INPUT_BUFFER inputBuffer;
    IPT_OUTPUT_BUFFER outputBuffer;

    //
    // Open the IPT Device
    //
    bRes = OpenIptDevice(&hIpt);
    if (bRes != FALSE)
    {
        //
        // Send a request to stop tracing for this process
        //
        InitializeIptBuffer(&inputBuffer, IptStopProcessTrace);
        inputBuffer.StopProcessIptTrace.ProcessHandle = hProcess;
        bRes = DeviceIoControl(hIpt,
                               IOCTL_IPT_REQUEST,
                               &inputBuffer,
                               sizeof(inputBuffer),
                               &outputBuffer,
                               sizeof(outputBuffer),
                               NULL,
                               NULL);
        CloseHandle(hIpt);
    }
    return bRes;
}

BOOL
StartCoreIptTracing (
    _In_ IPT_OPTIONS ullOptions,
    _In_ DWORD dwNumberOfTries,
    _In_ DWORD dwTraceDurationInSeconds
    )
{
    BOOL bRes;
    HANDLE hIpt;
    IPT_INPUT_BUFFER inputBuffer;
    IPT_OUTPUT_BUFFER outputBuffer;

    //
    // Open the IPT Device
    //
    bRes = OpenIptDevice(&hIpt);
    if (bRes != FALSE)
    {
        //
        // Send a request to start tracing for all the processor cores
        //
        InitializeIptBuffer(&inputBuffer, IptStartCoreTracing);
        inputBuffer.StartCoreIptTracing.Options = ullOptions;
        inputBuffer.StartCoreIptTracing.NumberOfTries = dwNumberOfTries;
        inputBuffer.StartCoreIptTracing.TraceDurationInSeconds = dwTraceDurationInSeconds;
        bRes = DeviceIoControl(hIpt,
                               IOCTL_IPT_REQUEST,
                               &inputBuffer,
                               sizeof(inputBuffer),
                               &outputBuffer,
                               sizeof(outputBuffer),
                               NULL,
                               NULL);
        CloseHandle(hIpt);
    }
    return bRes;
}

BOOL
RegisterExtendedImageForIptTracing (
    _In_ PWCHAR pwszImagePath,
    _In_opt_ PWCHAR pwszFilteredPath,
    _In_ IPT_OPTIONS ullOptions,
    _In_ DWORD dwNumberOfTries,
    _In_ DWORD dwTraceDurationInSeconds
    )
{
    BOOL bRes;
    WORD wPathLength, wFilterLength;
    DWORD dwInputLength;
    HANDLE hIpt;
    PIPT_INPUT_BUFFER inputBuffer;
    IPT_OUTPUT_BUFFER outputBuffer;

    //
    // Open the IPT Device
    //
    bRes = OpenIptDevice(&hIpt);
    if (bRes != FALSE)
    {
        //
        // Compute the size of the image path, and input buffer containing it
        //
        wPathLength = (WORD)(wcslen(pwszImagePath) + 1) * sizeof(WCHAR);
        dwInputLength = wPathLength + sizeof(*inputBuffer);

        //
        // Add the IFEO filter path size if it was passed in
        //
        if (pwszFilteredPath != NULL)
        {
            wFilterLength = (WORD)(wcslen(pwszFilteredPath) + 1) * sizeof(WCHAR);
            dwInputLength += wFilterLength;
        }

        //
        // Allocate the input buffer. Mimic Windows here by not using the heap.
        //
        inputBuffer = VirtualAlloc(NULL,
                                   dwInputLength,
                                   MEM_COMMIT,
                                   PAGE_READWRITE);
        if (inputBuffer != NULL)
        {
            //
            // Initialize a request for registering the given process
            //
            InitializeIptBuffer(inputBuffer, IptRegisterExtendedImageForTracing);
            inputBuffer->RegisterExtendedImageForIptTracing.Options = ullOptions;
            inputBuffer->RegisterExtendedImageForIptTracing.NumberOfTries = dwNumberOfTries;
            inputBuffer->RegisterExtendedImageForIptTracing.TraceDurationInSeconds = dwTraceDurationInSeconds;

            //
            // Copy the image path
            //
            inputBuffer->RegisterExtendedImageForIptTracing.ImagePathLength = wPathLength;
            CopyMemory(inputBuffer->RegisterExtendedImageForIptTracing.ImageName,
                       pwszImagePath,
                       wPathLength);

            //
            // Copy the filter path if it was present
            //
            if (pwszFilteredPath != NULL)
            {
                inputBuffer->RegisterExtendedImageForIptTracing.FilteredPathLength = wFilterLength;
                CopyMemory((PVOID)((DWORD_PTR)inputBuffer->RegisterExtendedImageForIptTracing.ImageName + wPathLength),
                           pwszFilteredPath,
                           wFilterLength);
            }
            else
            {
                inputBuffer->RegisterExtendedImageForIptTracing.FilteredPathLength = 0;
            }

            //
            // Send the request
            //
            bRes = DeviceIoControl(hIpt,
                                   IOCTL_IPT_REQUEST,
                                   &inputBuffer,
                                   sizeof(inputBuffer),
                                   &outputBuffer,
                                   sizeof(outputBuffer),
                                   NULL,
                                   NULL);

            //
            // Free the input buffer
            //
            VirtualFree(inputBuffer, 0, MEM_RELEASE);
        }
        else
        {
            //
            // Set failure since we're out of memory
            //
            bRes = FALSE;
        }
        CloseHandle(hIpt);
    }
    return bRes;
}

BOOL
PauseThreadIptTracing (
    _In_ HANDLE hThread,
    _In_ PBOOLEAN pbResult
    )
{
    BOOL bRes;
    HANDLE hIpt;
    IPT_INPUT_BUFFER inputBuffer;
    IPT_OUTPUT_BUFFER outputBuffer;

    //
    // Open the IPT Device
    //
    bRes = OpenIptDevice(&hIpt);
    if (bRes != FALSE)
    {
        //
        // Send a request to pause tracing for the given thread
        //
        InitializeIptBuffer(&inputBuffer, IptPauseThreadTrace);
        inputBuffer.PauseThreadIptTrace.ThreadHandle = hThread;
        bRes = DeviceIoControl(hIpt,
                               IOCTL_IPT_REQUEST,
                               &inputBuffer,
                               sizeof(inputBuffer),
                               &outputBuffer,
                               sizeof(outputBuffer),
                               NULL,
                               NULL);
        if (bRes != FALSE)
        {
            //
            // Result whether or not the thread was tracing or not
            //
            *pbResult = outputBuffer.PauseTrace.OldState;
        }
        CloseHandle(hIpt);
    }
    return bRes;
}

BOOL
ResumeThreadIptTracing (
    _In_ HANDLE hThread,
    _In_ PBOOLEAN pbResult
    )
{
    BOOL bRes;
    HANDLE hIpt;
    IPT_INPUT_BUFFER inputBuffer;
    IPT_OUTPUT_BUFFER outputBuffer;

    //
    // Open the IPT Device
    //
    bRes = OpenIptDevice(&hIpt);
    if (bRes != FALSE)
    {
        //
        // Send a request to resume tracing for the given thread
        //
        InitializeIptBuffer(&inputBuffer, IptResumeThreadTrace);
        inputBuffer.ResumeThreadIptTrace.ThreadHandle = hThread;
        bRes = DeviceIoControl(hIpt,
                               IOCTL_IPT_REQUEST,
                               &inputBuffer,
                               sizeof(inputBuffer),
                               &outputBuffer,
                               sizeof(outputBuffer),
                               NULL,
                               NULL);
        if (bRes != FALSE)
        {
            //
            // Return whether or not the thread was tracing or not
            //
            *pbResult = outputBuffer.ResumeTrace.OldState;
        }
        CloseHandle(hIpt);
    }
    return bRes;
}

BOOL
QueryProcessIptTracing (
    _In_ HANDLE hProcess,
    _Out_ PIPT_OPTIONS pullOptions
    )
{
    BOOL bRes;
    HANDLE hIpt;
    IPT_INPUT_BUFFER inputBuffer;
    IPT_OUTPUT_BUFFER outputBuffer;

    //
    // Open the IPT Device
    //
    bRes = OpenIptDevice(&hIpt);
    if (bRes != FALSE)
    {
        //
        // Send a request to check if the process has any tracing options set
        //
        InitializeIptBuffer(&inputBuffer, IptQueryProcessTrace);
        inputBuffer.QueryProcessIptTrace.ProcessHandle = hProcess;
        bRes = DeviceIoControl(hIpt,
                               IOCTL_IPT_REQUEST,
                               &inputBuffer,
                               sizeof(inputBuffer),
                               &outputBuffer,
                               sizeof(outputBuffer),
                               NULL,
                               NULL);
        if (bRes != FALSE)
        {
            //
            // Return the current set of options that are active
            //
            *pullOptions = outputBuffer.QueryProcessTrace.Options;
        }
        CloseHandle(hIpt);
    }
    return bRes;
}

BOOL
QueryCoreIptTracing (
    _Out_ PIPT_OPTIONS pullOptions
    )
{
    BOOL bRes;
    HANDLE hIpt;
    IPT_INPUT_BUFFER inputBuffer;
    IPT_OUTPUT_BUFFER outputBuffer;

    //
    // Open the IPT Device
    //
    bRes = OpenIptDevice(&hIpt);
    if (bRes != FALSE)
    {
        //
        // Send a request to check if the processor has any tracing options set
        //
        InitializeIptBuffer(&inputBuffer, IptQueryCoreTrace);
        bRes = DeviceIoControl(hIpt,
                               IOCTL_IPT_REQUEST,
                               &inputBuffer,
                               sizeof(inputBuffer),
                               &outputBuffer,
                               sizeof(outputBuffer),
                               NULL,
                               NULL);
        if (bRes != FALSE)
        {
            //
            // Return the current set of options that are active
            //
            *pullOptions = outputBuffer.QueryCoreTrace.Options;
        }
        CloseHandle(hIpt);
    }
    return bRes;
}


```

`libiptnt/libiptnt.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="native.c" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{393053BA-CA0E-4506-B415-87034C4A7093}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>winipt</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17704.0</WindowsTargetPlatformVersion>
    <ProjectName>libiptnt</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <PropertyGroup>
    <IncludePath>..\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>Full</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <OmitFramePointers>true</OmitFramePointers>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`libiptnt/native.c`:

```c
#include <ntstatus.h>
#define WIN32_NO_STATUS
#include <Windows.h>
#include <winternl.h>
#include <libiptnt.h>
#include <ipt.h>

_Must_inspect_result_
__drv_allocatesMem(Mem)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtAllocateVirtualMemory (
    _In_ HANDLE ProcessHandle,
    _Inout_ _At_ (*BaseAddress, _Readable_bytes_ (*RegionSize) _Writable_bytes_ (*RegionSize) _Post_readable_byte_size_ (*RegionSize)) PVOID *BaseAddress,
    _In_ ULONG_PTR ZeroBits,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG AllocationType,
    _In_ ULONG Protect
);

__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtFreeVirtualMemory (
    _In_ HANDLE ProcessHandle,
    _Inout_ __drv_freesMem(Mem) PVOID *BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG FreeType
);

#define NtCurrentProcess()  ((HANDLE)-1)

FORCEINLINE
VOID
InitializeIptBuffer (
    _Inout_ PIPT_INPUT_BUFFER Buffer,
    _In_ IPT_INPUT_TYPE InputType
    )
{
    //
    // Zero it out and set the version
    //
    ZeroMemory(Buffer, sizeof(*Buffer));
    Buffer->BufferMajorVersion = IPT_BUFFER_MAJOR_VERSION_CURRENT;
    Buffer->BufferMinorVersion = IPT_BUFFER_MINOR_VERSION_CURRENT;

    //
    // Set the type
    //
    Buffer->InputType = InputType;
}

FORCEINLINE
NTSTATUS
OpenIptDevice (
    _Out_ PHANDLE IptHandle
    )
{
    UNICODE_STRING iptDriverName;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;

    //
    // Setup the device name and attributes
    //
    RtlInitUnicodeString(&iptDriverName, L"\\Device\\IPT");
    InitializeObjectAttributes(&objectAttributes,
                               &iptDriverName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    //
    // Open the handle
    //
    return NtCreateFile(IptHandle,
                        FILE_GENERIC_READ,
                        &objectAttributes,
                        &ioStatusBlock,
                        NULL,
                        FILE_ATTRIBUTE_NORMAL,
                        FILE_SHARE_READ,
                        FILE_OPEN,
                        FILE_NO_INTERMEDIATE_BUFFERING |
                        FILE_SEQUENTIAL_ONLY |
                        FILE_NON_DIRECTORY_FILE,
                        NULL,
                        0);
}

NTSTATUS
GetIptBufferVersion (
    _Out_ PULONG BufferMajorVersion
    )
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    HANDLE iptHandle;
    IPT_INPUT_BUFFER inputBuffer;
    IPT_BUFFER_VERSION outputBuffer;

    //
    // Initialize for failure
    //
    *BufferMajorVersion = 0;

    //
    // Open the IPT Device
    //
    status = OpenIptDevice(&iptHandle);
    if (NT_SUCCESS(status))
    {
        //
        // Send only the version header of the input request.
        // The type is unused.
        //
        InitializeIptBuffer(&inputBuffer, -1);
        status = NtDeviceIoControlFile(iptHandle,
                                       NULL,
                                       NULL,
                                       NULL,
                                       &ioStatusBlock,
                                       IOCTL_IPT_REQUEST,
                                       &inputBuffer,
                                       sizeof(inputBuffer),
                                       &outputBuffer,
                                       sizeof(outputBuffer));
        NtClose(iptHandle);

        //
        // On success, return the buffer version
        //
        if (NT_SUCCESS(status))
        {
            *BufferMajorVersion = outputBuffer.BufferMajorVersion;
        }
    }
    return status;
}

NTSTATUS
GetIptTraceVersion (
    _Out_ PUSHORT TraceVersion
    )
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    HANDLE iptHandle;
    IPT_INPUT_BUFFER inputBuffer;
    IPT_OUTPUT_BUFFER outputBuffer;

    //
    // Initialize for failure
    //
    *TraceVersion = 0;

    //
    // Open the IPT Device
    //
    status = OpenIptDevice(&iptHandle);
    if (NT_SUCCESS(status))
    {
        //
        // Send a request to get the trace version
        //
        InitializeIptBuffer(&inputBuffer, IptGetTraceVersion);
        status = NtDeviceIoControlFile(iptHandle,
                                       NULL,
                                       NULL,
                                       NULL,
                                       &ioStatusBlock,
                                       IOCTL_IPT_REQUEST,
                                       &inputBuffer,
                                       sizeof(inputBuffer),
                                       &outputBuffer,
                                       sizeof(outputBuffer));
        NtClose(iptHandle);

        //
        // On success, return the buffer version
        //
        if (NT_SUCCESS(status))
        {
            *TraceVersion = outputBuffer.GetTraceVersion.TraceVersion;
        }
    }
    return status;
}

NTSTATUS
GetProcessIptTraceSize (
    _In_ HANDLE ProcessHandle,
    _Out_ PULONG TraceSize
    )
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    HANDLE iptHandle;
    IPT_INPUT_BUFFER inputBuffer;
    IPT_OUTPUT_BUFFER outputBuffer;

    //
    // Initialize for failure
    //
    *TraceSize = 0;

    //
    // Open the IPT Device
    //
    status = OpenIptDevice(&iptHandle);
    if (NT_SUCCESS(status))
    {
        //
        // Send a request to get the trace size for the process
        //
        InitializeIptBuffer(&inputBuffer, IptGetProcessTraceSize);
        inputBuffer.GetProcessIptTraceSize.TraceVersion = IPT_TRACE_VERSION_CURRENT;
        inputBuffer.GetProcessIptTraceSize.ProcessHandle = ProcessHandle;
        status = NtDeviceIoControlFile(iptHandle,
                                       NULL,
                                       NULL,
                                       NULL,
                                       &ioStatusBlock,
                                       IOCTL_IPT_REQUEST,
                                       &inputBuffer,
                                       sizeof(inputBuffer),
                                       &outputBuffer,
                                       sizeof(outputBuffer));
        NtClose(iptHandle);

        //
        // Check if we got a size back
        //
        if (NT_SUCCESS(status))
        {
            //
            // The IOCTL layer supports > 4GB traces but this doesn't exist yet
            // Otherwise, return the 32-bit trace size.
            //
            if (outputBuffer.GetTraceSize.TraceSize <= ULONG_MAX)
            {
                *TraceSize = (ULONG)outputBuffer.GetTraceSize.TraceSize;
            }
            else
            {
                //
                // Mark this as a failure -- this is the Windows behavior too
                //
                status = STATUS_IMPLEMENTATION_LIMIT;
            }
        }
    }
    return status;
}

NTSTATUS
GetProcessIptTrace (
    _In_ HANDLE ProcessHandle,
    _In_ PVOID Trace,
    _In_ ULONG TraceSize
    )
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    HANDLE iptHandle;
    IPT_INPUT_BUFFER inputBuffer;

    //
    // The trace comes as part of an output buffer, so that part is required
    //
    if (TraceSize < UFIELD_OFFSET(IPT_OUTPUT_BUFFER, GetTrace.TraceSize))
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Open the IPT Device
    //
    status = OpenIptDevice(&iptHandle);
    if (NT_SUCCESS(status))
    {
        //
        // Send a request to get the trace for the process
        //
        InitializeIptBuffer(&inputBuffer, IptGetProcessTrace);
        inputBuffer.GetProcessIptTrace.TraceVersion = IPT_TRACE_VERSION_CURRENT;
        inputBuffer.GetProcessIptTrace.ProcessHandle = ProcessHandle;
        status = NtDeviceIoControlFile(iptHandle,
                                       NULL,
                                       NULL,
                                       NULL,
                                       &ioStatusBlock,
                                       IOCTL_IPT_READ_TRACE,
                                       &inputBuffer,
                                       sizeof(inputBuffer),
                                       Trace,
                                       TraceSize);
        NtClose(iptHandle);
    }
    return status;
}

NTSTATUS
StartProcessIptTrace (
    _In_ HANDLE ProcessHandle,
    _In_ IPT_OPTIONS Options
    )
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    HANDLE iptHandle;
    IPT_INPUT_BUFFER inputBuffer;
    IPT_OUTPUT_BUFFER outputBuffer;

    //
    // Open the IPT Device
    //
    status = OpenIptDevice(&iptHandle);
    if (NT_SUCCESS(status))
    {
        //
        // Send a request to start tracing for this process
        //
        InitializeIptBuffer(&inputBuffer, IptStartProcessTrace);
        inputBuffer.StartProcessIptTrace.Options = Options;
        inputBuffer.StartProcessIptTrace.ProcessHandle = ProcessHandle;
        status = NtDeviceIoControlFile(iptHandle,
                                       NULL,
                                       NULL,
                                       NULL,
                                       &ioStatusBlock,
                                       IOCTL_IPT_REQUEST,
                                       &inputBuffer,
                                       sizeof(inputBuffer),
                                       &outputBuffer,
                                       sizeof(outputBuffer));
        NtClose(iptHandle);
    }
    return status;
}

NTSTATUS
StopProcessIptTrace (
    _In_ HANDLE ProcessHandle
    )
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    HANDLE iptHandle;
    IPT_INPUT_BUFFER inputBuffer;
    IPT_OUTPUT_BUFFER outputBuffer;

    //
    // Open the IPT Device
    //
    status = OpenIptDevice(&iptHandle);
    if (NT_SUCCESS(status))
    {
        //
        // Send a request to stop tracing for this process
        //
        InitializeIptBuffer(&inputBuffer, IptStopProcessTrace);
        inputBuffer.StopProcessIptTrace.ProcessHandle = ProcessHandle;
        status = NtDeviceIoControlFile(iptHandle,
                                       NULL,
                                       NULL,
                                       NULL,
                                       &ioStatusBlock,
                                       IOCTL_IPT_REQUEST,
                                       &inputBuffer,
                                       sizeof(inputBuffer),
                                       &outputBuffer,
                                       sizeof(outputBuffer));
        NtClose(iptHandle);
    }
    return status;
}

NTSTATUS
StartCoreIptTracing (
    _In_ IPT_OPTIONS Options,
    _In_ ULONG NumberOfTries,
    _In_ ULONG TraceDurationInSeconds
    )
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    HANDLE iptHandle;
    IPT_INPUT_BUFFER inputBuffer;
    IPT_OUTPUT_BUFFER outputBuffer;

    //
    // Open the IPT Device
    //
    status = OpenIptDevice(&iptHandle);
    if (NT_SUCCESS(status))
    {
        //
        // Send a request to start tracing for all the processor cores
        //
        InitializeIptBuffer(&inputBuffer, IptStartCoreTracing);
        inputBuffer.StartCoreIptTracing.Options = Options;
        inputBuffer.StartCoreIptTracing.NumberOfTries = NumberOfTries;
        inputBuffer.StartCoreIptTracing.TraceDurationInSeconds = TraceDurationInSeconds;
        status = NtDeviceIoControlFile(iptHandle,
                                       NULL,
                                       NULL,
                                       NULL,
                                       &ioStatusBlock,
                                       IOCTL_IPT_REQUEST,
                                       &inputBuffer,
                                       sizeof(inputBuffer),
                                       &outputBuffer,
                                       sizeof(outputBuffer));
        NtClose(iptHandle);
    }
    return status;
}

NTSTATUS
RegisterExtendedImageForIptTracing (
    _In_ PWCHAR ImagePath,
    _In_opt_ PWCHAR FilteredPath,
    _In_ IPT_OPTIONS Options,
    _In_ ULONG NumberOfTries,
    _In_ ULONG TraceDurationInSeconds
    )
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    USHORT pathLength, filterLength;
    ULONG inputLength;
    HANDLE iptHandle;
    PIPT_INPUT_BUFFER inputBuffer;
    IPT_OUTPUT_BUFFER outputBuffer;
    SIZE_T regionSize;

    //
    // Open the IPT Device
    //
    status = OpenIptDevice(&iptHandle);
    if (NT_SUCCESS(status))
    {
        //
        // Compute the size of the image path, and input buffer containing it
        //
        pathLength = (USHORT)(wcslen(ImagePath) + 1) * sizeof(WCHAR);
        inputLength = pathLength + sizeof(*inputBuffer);

        //
        // Add the IFEO filter path size if it was passed in
        //
        if (FilteredPath != NULL)
        {
            filterLength = (USHORT)(wcslen(FilteredPath) + 1) * sizeof(WCHAR);
            inputLength += filterLength;
        }

        //
        // Allocate the input buffer. Mimic Windows here by not using the heap.
        //
        inputBuffer = NULL;
        regionSize = inputLength;
        status = NtAllocateVirtualMemory(NtCurrentProcess(),
                                         &inputBuffer,
                                         0,
                                         &regionSize,
                                         MEM_COMMIT,
                                         PAGE_READWRITE);
        if (NT_SUCCESS(status))
        {
            //
            // Initialize a request for registering the given process
            //
            InitializeIptBuffer(inputBuffer, IptRegisterExtendedImageForTracing);
            inputBuffer->RegisterExtendedImageForIptTracing.Options = Options;
            inputBuffer->RegisterExtendedImageForIptTracing.NumberOfTries = NumberOfTries;
            inputBuffer->RegisterExtendedImageForIptTracing.TraceDurationInSeconds = TraceDurationInSeconds;

            //
            // Copy the image path
            //
            inputBuffer->RegisterExtendedImageForIptTracing.ImagePathLength = pathLength;
            CopyMemory(inputBuffer->RegisterExtendedImageForIptTracing.ImageName,
                       ImagePath,
                       pathLength);

            //
            // Copy the filter path if it was present
            //
            if (FilteredPath != NULL)
            {
                inputBuffer->RegisterExtendedImageForIptTracing.FilteredPathLength = filterLength;
                CopyMemory((PVOID)((ULONG_PTR)inputBuffer->RegisterExtendedImageForIptTracing.ImageName + pathLength),
                           FilteredPath,
                           filterLength);
            }
            else
            {
                inputBuffer->RegisterExtendedImageForIptTracing.FilteredPathLength = 0;
            }

            //
            // Send the request
            //
            status = NtDeviceIoControlFile(iptHandle,
                                           NULL,
                                           NULL,
                                           NULL,
                                           &ioStatusBlock,
                                           IOCTL_IPT_REQUEST,
                                           &inputBuffer,
                                           sizeof(inputBuffer),
                                           &outputBuffer,
                                           sizeof(outputBuffer));

            //
            // Free the input buffer
            //
            regionSize = 0;
            NtFreeVirtualMemory(NtCurrentProcess(),
                                &inputBuffer,
                                &regionSize,
                                MEM_RELEASE);
        }
        NtClose(iptHandle);
    }
    return status;
}

NTSTATUS
PauseThreadIptTracing (
    _In_ HANDLE ThreadHandle,
    _In_ PBOOLEAN Result
    )
{
    NTSTATUS status;
    HANDLE iptHandle;
    IO_STATUS_BLOCK ioStatusBlock;
    IPT_INPUT_BUFFER inputBuffer;
    IPT_OUTPUT_BUFFER outputBuffer;

    //
    // Open the IPT Device
    //
    status = OpenIptDevice(&iptHandle);
    if (NT_SUCCESS(status))
    {
        //
        // Send a request to pause tracing for the given thread
        //
        InitializeIptBuffer(&inputBuffer, IptPauseThreadTrace);
        inputBuffer.PauseThreadIptTrace.ThreadHandle = ThreadHandle;
        status = NtDeviceIoControlFile(iptHandle,
                                       NULL,
                                       NULL,
                                       NULL,
                                       &ioStatusBlock,
                                       IOCTL_IPT_REQUEST,
                                       &inputBuffer,
                                       sizeof(inputBuffer),
                                       &outputBuffer,
                                       sizeof(outputBuffer));
        if (NT_SUCCESS(status))
        {
            //
            // Result whether or not the thread was tracing or not
            //
            *Result = outputBuffer.PauseTrace.OldState;
        }
        NtClose(iptHandle);
    }
    return status;
}

NTSTATUS
ResumeThreadIptTracing (
    _In_ HANDLE ThreadHandle,
    _In_ PBOOLEAN Result
    )
{
    NTSTATUS status;
    HANDLE iptHandle;
    IO_STATUS_BLOCK ioStatusBlock;
    IPT_INPUT_BUFFER inputBuffer;
    IPT_OUTPUT_BUFFER outputBuffer;

    //
    // Open the IPT Device
    //
    status = OpenIptDevice(&iptHandle);
    if (NT_SUCCESS(status))
    {
        //
        // Send a request to resume tracing for the given thread
        //
        InitializeIptBuffer(&inputBuffer, IptResumeThreadTrace);
        inputBuffer.ResumeThreadIptTrace.ThreadHandle = ThreadHandle;
        status = NtDeviceIoControlFile(iptHandle,
                                       NULL,
                                       NULL,
                                       NULL,
                                       &ioStatusBlock,
                                       IOCTL_IPT_REQUEST,
                                       &inputBuffer,
                                       sizeof(inputBuffer),
                                       &outputBuffer,
                                       sizeof(outputBuffer));
        if (NT_SUCCESS(status))
        {
            //
            // Return whether or not the thread was tracing or not
            //
            *Result = outputBuffer.ResumeTrace.OldState;
        }
        NtClose(iptHandle);
    }
    return status;
}

NTSTATUS
QueryProcessIptTracing (
    _In_ HANDLE ProcessHandle,
    _Out_ PIPT_OPTIONS Options
    )
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    HANDLE iptHandle;
    IPT_INPUT_BUFFER inputBuffer;
    IPT_OUTPUT_BUFFER outputBuffer;

    //
    // Open the IPT Device
    //
    status = OpenIptDevice(&iptHandle);
    if (NT_SUCCESS(status))
    {
        //
        // Send a request to check if the process has any tracing options set
        //
        InitializeIptBuffer(&inputBuffer, IptQueryProcessTrace);
        inputBuffer.QueryProcessIptTrace.ProcessHandle =  ProcessHandle;
        status = NtDeviceIoControlFile(iptHandle,
                                       NULL,
                                       NULL,
                                       NULL,
                                       &ioStatusBlock,
                                       IOCTL_IPT_REQUEST,
                                       &inputBuffer,
                                       sizeof(inputBuffer),
                                       &outputBuffer,
                                       sizeof(outputBuffer));
        if (NT_SUCCESS(status))
        {
            //
            // Return the current set of options that are active
            //
            *Options = outputBuffer.QueryProcessTrace.Options;
        }
        NtClose(iptHandle);
    }
    return status;
}

NTSTATUS
QueryCoreIptTracing (
    _Out_ PIPT_OPTIONS Options
    )
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    HANDLE iptHandle;
    IPT_INPUT_BUFFER inputBuffer;
    IPT_OUTPUT_BUFFER outputBuffer;

    //
    // Open the IPT Device
    //
    status = OpenIptDevice(&iptHandle);
    if (NT_SUCCESS(status))
    {
        //
        // Send a request to check if the processor has any tracing options set
        //
        InitializeIptBuffer(&inputBuffer, IptQueryCoreTrace);
        status = NtDeviceIoControlFile(iptHandle,
                                       NULL,
                                       NULL,
                                       NULL,
                                       &ioStatusBlock,
                                       IOCTL_IPT_REQUEST,
                                       &inputBuffer,
                                       sizeof(inputBuffer),
                                       &outputBuffer,
                                       sizeof(outputBuffer));
        if (NT_SUCCESS(status))
        {
            //
            // Return the current set of options that are active
            //
            *Options = outputBuffer.QueryCoreTrace.Options;
        }
        NtClose(iptHandle);
    }
    return status;
}
```

`winipt.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.27825.0
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libipt", "libipt\libipt.vcxproj", "{051DE316-C76C-4CFC-82DA-46C0B04CFAD8}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ipttool", "ipttool\ipttool.vcxproj", "{1B5BE021-FB5F-4792-AF04-39BF7705886E}"
	ProjectSection(ProjectDependencies) = postProject
		{051DE316-C76C-4CFC-82DA-46C0B04CFAD8} = {051DE316-C76C-4CFC-82DA-46C0B04CFAD8}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libipt", "libiptnt\libiptnt.vcxproj", "{393053BA-CA0E-4506-B415-87034C4A7093}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{051DE316-C76C-4CFC-82DA-46C0B04CFAD8}.Release|x64.ActiveCfg = Release|x64
		{051DE316-C76C-4CFC-82DA-46C0B04CFAD8}.Release|x64.Build.0 = Release|x64
		{1B5BE021-FB5F-4792-AF04-39BF7705886E}.Release|x64.ActiveCfg = Release|x64
		{1B5BE021-FB5F-4792-AF04-39BF7705886E}.Release|x64.Build.0 = Release|x64
		{393053BA-CA0E-4506-B415-87034C4A7093}.Release|x64.ActiveCfg = Release|x64
		{393053BA-CA0E-4506-B415-87034C4A7093}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {19EF0305-DC28-4577-B041-40382D6A1D54}
	EndGlobalSection
EndGlobal

```