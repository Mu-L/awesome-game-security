Project Path: arc_intelpt_WindowsIntelPT_c3blbmsc

Source Tree:

```txt
arc_intelpt_WindowsIntelPT_c3blbmsc
├── Compiled_IntelPt
│   ├── Dbgview.exe
│   ├── INSTDRV.EXE
│   ├── IdaPt.py
│   ├── PtControlApp.exe
│   ├── WindowsPtDriver.sys
│   ├── libipt.dll
│   └── readme.md
├── LICENSE
├── PtControlApp
│   ├── EntryPoint.cpp
│   ├── IntelPt.h
│   ├── IntelPtControlApp.cpp
│   ├── IntelPtControlApp.h
│   ├── Log.cpp
│   ├── Log.h
│   ├── PtControlApp.rc
│   ├── PtControlApp.sln
│   ├── PtControlApp.vcxproj
│   ├── PtControlApp.vcxproj.filters
│   ├── UndocNt.h
│   ├── asm
│   │   └── Amd64Control.asm
│   ├── decoder
│   │   ├── basic_include
│   │   │   ├── inttypes.h
│   │   │   └── threads.h
│   │   ├── intel-pt.h
│   │   ├── libipt.lib
│   │   ├── libipt.txt
│   │   ├── pt_cpu.cpp
│   │   ├── pt_cpu.h
│   │   ├── pt_cpuid.cpp
│   │   ├── pt_cpuid.h
│   │   ├── pt_last_ip.cpp
│   │   ├── pt_last_ip.h
│   │   ├── pt_time.cpp
│   │   ├── pt_time.h
│   │   └── ptdump.cpp
│   ├── pt_dump.h
│   ├── res
│   │   ├── cpu.ico
│   │   └── libipt.dll
│   ├── resource.h
│   ├── stdafx.cpp
│   ├── stdafx.h
│   └── targetver.h
├── README.md
├── WindowsIntelPt.sln
└── WindowsPtDriver
    ├── Debug.cpp
    ├── Debug.h
    ├── DriverEntry.cpp
    ├── DriverEntry.h
    ├── DriverIo.cpp
    ├── DriverIo.h
    ├── Export.def
    ├── HyperV.cpp
    ├── IntelPt.cpp
    ├── IntelPt.h
    ├── IntelPtXSave.cpp
    ├── IntelPtXSave.h
    ├── Intel_Defs.h
    ├── KernelTracing.cpp
    ├── KernelTracing.h
    ├── PtTests.cpp
    ├── UndocNt.h
    ├── WindowsIntelPtDriver.rc
    ├── WindowsIntelPtDriver.vcxproj
    ├── WindowsIntelPtDriver.vcxproj.filters
    ├── WindowsIntelPtDriver2015.sln
    ├── asm
    │   └── Amd64XSave.asm
    ├── hv.h
    ├── hv_intercepts.h
    ├── lib
    │   ├── How_To_Generate_Libs.txt
    │   └── amd64
    │       ├── winhv.lib
    │       └── winhvr.lib
    ├── resource.h
    ├── rules
    │   └── masm64.rules
    └── stdafx.h

```

`Compiled_IntelPt/IdaPt.py`:

```py
# Intel PT IDA Plugin
# Last revision: 06/17/2017
# Copyright 2017 Andrea Allievi, richard Johnson - Microsoft Ltd and Cisco Talos
#
import sys
import collections
try:
    import idaapi
    from idaapi import *
    from idc import *
    from idautils import *
    import ida_funcs
    IDA_READY = 1
except:
    IDA_READY = 0

class Ida_pt:
    def __init__(self):
        # Init global data here:
        self.BaseAddr = 0                    # The module base address
        self.ModSize = 0                     # The module size
        self.lineNumber = 0                  # Current number of line 
        self.qwLastTraceIp = 0				 # Last IP Trace address
        self.curDelta = 0                    # Current Module Delta
        self.lastPtPck = None                # The last PT packet
        self.hTraceFile = None               # Current trace file handle
        self.retAddrs = []                   # The list of Return Addresses
        self.curTntMaskAndOffset = ["", 0]            # Last TNT packet mask
        self.cpuId = 0                       # Current module CPU ID
        #self.Graphs = []                     # The list that contains all the analysed graphs
        self.curColor = self.get_new_color(0xFFFFFF)
        #self.curGraph = collections.OrderedDict() 

    # Get the IDA normalized address
    def GetIdaAddress(self, addr):
        IdaAddr = addr - self.curDelta
        #IdaAddr &= 0xFFFFFFFF
        return (IdaAddr)

    # Get the Trace packet full address
    def GetPtPckFullIP(self, pck): 
        retAddr = self.qwLastTraceIp
        if (pck[2] == 0):
            # Invalid packet here
            return 0
        elif (pck[2][0] == '1'):
            retAddr &= 0xFFFFFFFFFFFF0000
            retAddr += int(pck[3][-4:], 16)
        elif (pck[2][0] == '2'):
            retAddr &= 0xFFFFFFFF00000000
            retAddr += int(pck[3][-8:], 16)
        else:
            retAddr = int(pck[3], 16)
        self.qwLastTraceIp = retAddr
        return retAddr

    # Get a new color from the color list
    def get_new_color(self, current_color):
        colors = [0xffe699, 0xe1cc85, 0xffcc33, 0xe6ac00, 0xc39200, 0xb38600]
        if (current_color & 0xFFFFFF) == 0xFFFFFF:
            return colors[0]
        
        if current_color in colors:
            pos = colors.index(current_color)
            if pos == len(colors)-1:
                return colors[pos]
            else:
                return colors[pos+1]
        return 0xFFFFFF

    def GetPacket(self, line):
         # Packet format: "OFFSET - PACKET TYPE - PARAMS
        (offset, pckType, param1, param2, param3) = (0, "", 0, 0, 0)
        pckList = line.split()
        if len(pckList) < 2: return None
        offset = int(pckList[0], 16)
        pckType = pckList[1].strip().lower()
        if (len(pckList) > 2): param1 = pckList[2].strip().lower()
        if (len(pckList) > 3): param2 = pckList[3].strip().lower()
        if (len(pckList) > 4): param3 = pckList[4].strip().lower()
        return  (offset, pckType, param1, param2, param3)

    def SetIdaNodeColor(self, node, color = None):
        if (color == None): color = self.curColor
        #node_info = idaapi.node_info_t()
        #node_info.bg_color = color
        #idaapi.set_node_info2(node.startEA, 0, node_info,  idaapi.NIF_BG_COLOR)
        for insr in Heads(node.startEA, node.endEA):
            idc.SetColor(insr, CIC_ITEM, color) 

    def ColorInstruction(self, ea):
        oldColor = idc.GetColor(ea, idc.CIC_ITEM)
        # Grab the new color
        newColor = self.get_new_color(oldColor)
        idc.SetColor(ea, idc.CIC_ITEM, newColor)

    def ParseFileAndGetStartAddr(self, fileFullPath):
        line = ""               # The read file line
        curLineNumber = 3       # Current line number
        qwStartAddr = 0         # Start address found in the Dump

        hDump = open(fileFullPath, "r")
        hdrLine = hDump.readline().strip()
        if hdrLine[:14].lower() != "Intel PT Trace".lower():
            hDump.close()
            return False

        # Optional CPU ID
        cpuIdStr = hDump.readline().strip()
        if (cpuIdStr[:6].upper() == 'CPU ID'):
            self.cpuId = int(cpuIdStr[-2:], 10)
        else:
            targetName = cpuIdStr
            cpuIdStr = ''

        # Grab the executable name
        if (cpuIdStr != ''):
           targetName = hDump.readline().strip()

        if targetName[:16].lower() == "executable name:":
            # This text file describe an executable
            targetName = targetName[17:].strip()
            print("Found \"%s\" executable name." % targetName)
        elif targetName[:19].lower() == "kernel driver name:" :
            # This text file describe a kernel driver 
            targetName = targetName[20:].strip()
            print("Found \"%s\" kernel mode driver name." % targetName)
        elif targetName[:22].lower() == "binary dump file name:":
            # This text file describe a generic PT dump
            targetName = targetName[23:].strip()
            print("Found \"%s\" binary dump file name." % targetName)
        else:
            hDump.close()
            return False

        # Grab the base address and the size:
        baseAddrLine = hDump.readline().strip()
        if baseAddrLine[:13].lower() == "base address:":
            delimPos = -1
            baseAddrLine = baseAddrLine[14:].strip()
            delimPos = baseAddrLine.find("-")
            if (delimPos < 0): baseAddrStr = baseAddrLine.strip()
            else: baseAddrStr = baseAddrLine[:delimPos].strip()
            try:
                if (baseAddrStr.startswith("0x")): self.BaseAddr = int(baseAddrStr, 16)
                else: self.BaseAddr = int(baseAddrStr, 10)
            except Exception as e:
                hDump.close()
                return False         
       
            # Now grab the module size
            if delimPos > 0:
                sizeStr = baseAddrLine[delimPos + 1:].strip()
                if sizeStr.lower().startswith("size:"): sizeStr = sizeStr[5:].strip()
                elif sizeStr.lower().startswith("size"): sizeStr = sizeStr[4:].strip()
                try:
                    if (sizeStr.startswith("0x")): self.ModSize = int(sizeStr, 16)
                    else: self.ModSize = int(sizeStr, 10)
                except Exception as e:
                    hDump.close()
                    return False         
            else:
                self.modSize = 0
        else:
            hDump.close()
            return False
        
        # Get current DELTA value
        self.curDelta = self.GetModuleDelta()
        print("Found module base address %s - size: %s - Delta: %s." % (hex(self.BaseAddr)[:-1], hex(self.ModSize), hex(self.curDelta)))

        # Now search the "Begin Trace Dump" string:
        while True:
            line = hDump.readline()
            if (line == ""):
                self.ModSize = 0
                self.BaseAddr = 0
                hDump.close()
                return False
            if line.lower().startswith("begin trace dump"): break
            curLineNumber += 1
        
        # Found, start by analysing one packet and get the start
        while True:
            line = hDump.readline()
            pck = self.GetPacket(line)
            pckType = pck[1]
            curLineNumber += 1
            if pckType == "fup":
                # Arg1 - Address type (IpBytes) - in powers of "2"
                # Arg2 - Final address
                if (int(pck[2][0]) != 3): return False
                qwStartAddr = int(pck[3], 16)
                break
            elif pckType == "tip"or pckType == "tip.pgd" or pckType == "tip.pge":
                # Arg1 - Address type (IpBytes) - in powers of "2"
                # Arg2 - Final address
                if (int(pck[2][0]) != 3): return False
                qwStartAddr = int(pck[3], 16)
                break
        
        print("Found the starting address from the DUMP: %s" % hex(qwStartAddr - self.curDelta)[:-1])
        self.hTraceFile = hDump
        self.qwLastTraceIp = qwStartAddr
        self.lastPtPck = pck
        return self.GetIdaAddress(qwStartAddr)			# IDA Speaking

    def GetModuleDelta(self):
        if (IDA_READY == 0): return 
        loaded_mod_base_addr = idaapi.get_imagebase()
        return (self.BaseAddr - loaded_mod_base_addr)

    def GetIdaFuncBlock(self, ea):
        if (IDA_READY == 0 or ea == 0): return None
        f = idaapi.get_func(ea)			# Grab the function associated to the current EA
        if (f is None):
            # Try to create a function 
            import idc
            idc.MakeCode(ea)
            idc.MakeFunction(ea)

        if (f is None):
            return None

        graph = idaapi.FlowChart(f, flags=FC_PREDS) 	# Create the FlowChart associated to it
        for block in graph:
            if block.startEA <= ea and block.endEA > ea:
                # found my block
                return block
        return None

    # Get a function node from a graph
    def GetGraphNode(self, graph, ea):
        nodes = graph.keys()
        for node in nodes:
            if (ea >= node.startEA and ea < node.endEA ):
                return node
        return None

    def CreateFuncGraph(self, ea):
        # Get and analyse the entire flow chart and produce the Binary Graph
        f = idaapi.get_func(ea)			# Grab the function associated to the current EA
        flowchart = idaapi.FlowChart(f, flags=idaapi.FC_PREDS) 	# Create the FlowChart associated to it
        graph = collections.OrderedDict() 

        # Build the entire graph
        for curBlock in flowchart:
            # Get left and right edge
            lastInsr = idc.PrevHead(curBlock.endEA)
            leftAddr = idc.NextHead(lastInsr)
            rightAddr = GetOperandValue(lastInsr, 0)

            # Create the node
            if (curBlock not in graph):
                graph[curBlock] = (self.GetIdaFuncBlock(leftAddr), self.GetIdaFuncBlock(rightAddr))
        return graph

    def StartPtAnalysis(self, startEa):
        curEa = startEa
        nextEa = 0                   # Next IDA Address
        
        while True:
            #Read next packet
            line = self.hTraceFile.readline()
            if (line == '' or line.strip() == 'END'): break
            line = line.strip()
            if (line == ''): continue
            nextPck = self.GetPacket(line)
            self.lineNumber += 1

            nextEa = self.AnalyseNextChunk(curEa, nextPck)
            if (nextEa == 0): 
                # Here it means that we are in 2 totally different points in the code (kernel drivers are a good example)
                if (nextPck[1][:3] != "fup" and nextPck[1][:3] != "tip"):
                    print("I found an internal error. Packet ID: %s, type: %s, current IP: %s" % (hex(nextPck[0]), nextPck[1], hex(curEa)[:-1]))
                    break
                completePtAddr = self.GetPtPckFullIP(nextPck)
                nextEa = self.GetIdaAddress(completePtAddr)
                print("Found another unrelated block of code in the DUMP. Start at %s. Line #%d in the dump file." % (hex(nextEa)[:-1], self.lineNumber))
            elif (nextEa == -1):
                # Some errors or we are done
                break

            self.lastPtPck = nextPck
            curEa = nextEa

        # Complete this dump if the last packet is a pgd
        lastEa = ida_funcs.get_fchunk(curEa).endEA
        if (nextPck[1][-3:] == "pgd" and curEa != lastEa): 
            while (curEa < lastEa):
                mnem = idc.GetMnem(curEa)
                self.ColorInstruction(curEa)
                if (mnem[0] == "j" or mnem[:4] == "loop" or mnem == "call" or mnem == "ret" or mnem == "retn"): 
                    break
                curEa = idc.NextHead(curEa)
        return True
        
    def Is64BitPe(self):
        info = idaapi.get_inf_structure()
        return info.is_64bit()

    def AnalyseNextChunk(self, startEa, nextPck):
        prevPck = self.lastPtPck;
        curEa = startEa             
        endEa = 0                   # The ending Address
        curRetAddr = 0              # Current REturn Address

        #Analyse here the next packet
        pckType = nextPck[1]
        if pckType == "fup" or pckType == "tip" or pckType == "tip.pge":
            # Arg1 - Address type (IpBytes) - in powers of "2"
            # Arg2 - Final address
            completePtAddr = self.GetPtPckFullIP(nextPck)
            endEa = self.GetIdaAddress(completePtAddr)
            if (endEa == startEa): return startEa
        elif pckType == "tip.pgd":
            # Asynchronous event here
            return startEa
        elif pckType[:3] == "tnt":
            # Taken - not taken packet here, allow them to decide what to do
            if (nextPck != prevPck):
                self.curTntMaskAndOffset = [nextPck[2], 0]
        else:
            # Not interesting packets
            return startEa
        
        # Grab current REturn address if any
        if (len(self.retAddrs) > 0):
            curRetAddr = self.retAddrs[-1];

        if (int(nextPck[0]) >= 0x1550):
            pass

        # Cycle between each instruction
        while (True):
            mnem = idc.GetMnem(curEa)
            if (mnem == ''):
                # Internal Error here
                print ("Unable to disassemble the instruction at address %s. Current packet: %s." % (hex(curEa)[:-1], hex(nextPck[0])))   
                return -1

            targetEa = 0
            #Color this instruction
            self.ColorInstruction(curEa)

            if (mnem == "call" or mnem == "jmp"):
                targetEa = idc.GetOperandValue(curEa, 0)        # Only if the Operand is idc.o_near
                nextEa = idc.NextHead(curEa)
                opType = idc.GetOpType(curEa, 0)
                if (opType == idc.o_mem):
                    # Read the memory
                    if (self.Is64BitPe()): targetEa = idc.Qword(targetEa)
                    else: targetEa = idc.Dword(targetEa)

                elif (opType == idc.o_reg or opType == idc.o_displ or opType == idc.o_phrase):
                    # How to detect the value of the register?
                    # Simple, wait for the next packet
                    if (mnem == "call"): self.retAddrs.append(nextEa)
                    cmt = idc.CommentEx(curEa, 0)
                    if (cmt is None): cmt = "Target: "
                    cmt += (hex(endEa)[:-1]) + " "
                    idc.MakeComm(curEa, cmt)
                    return endEa        # This is a clever hack

                # Are we sure that the memory is valid?
                if (idc.GetOpType(targetEa, 0) > -1):           # if idc.isHead(targetEa):
                    # Target memory is valid
                    if (mnem == "call"): self.retAddrs.append(nextEa)
                    self.lastPtPck = nextPck
                    return self.AnalyseNextChunk(targetEa, nextPck)
                
                else:
                    # The target memory is not valid or not in IDA file, wait the next packet
                    if endEa > 0:
                        return endEa
                    
                    if (mnem == "call"):
                        #Imported function, skip this (CALL DWORD PTR [IAT entry])
                        targetEa = nextEa
                    else:
                        # Imported API, return the ret Address (JMP DWORD PTR [IAT Entry]) 
                        if (len(self.retAddrs) > 0):
                            targetEa = self.retAddrs.pop()
                            return targetEa            
                        else:
                            return -1
 
            elif (mnem == "ja" or mnem == "jae" or mnem == "jb" or mnem == "jbe" or             
                mnem == "je" or mnem == "jg" or mnem == "jge" or mnem == "jl" or mnem == "jle" or 
                mnem == "jna" or mnem == "jnae" or mnem == "jnb" or mnem == "jnbe" or mnem == "jnc" or 
                mnem == "jne" or mnem == "jng" or mnem == "jnge" or mnem == "jnl" or mnem == "jnle" or
                mnem == "jno" or mnem == "jns" or mnem == "jnz" or mnem == "jo" or mnem == "jp" or
                mnem == "jpe" or mnem == "jpo" or mnem == "js" or mnem == "jz" or mnem == "jp" or
                mnem == "jc" or mnem == "jecxz" or mnem == "jcxz" or mnem == "jrcxz" or 
                mnem == "loop" or mnem == "loope" or mnem == "loopne" or mnem == "loopnz" or mnem == "loopz"):
                # A COFI packet, analyse it and decide what will be the next instruction
                (mask, offset) = (self.curTntMaskAndOffset[0], self.curTntMaskAndOffset[1])
                if (offset >= len(mask)):
                    # Still not reached the right point
                    return curEa

                if (mask[offset] == '!'):
                    # Taken, go to the right
                    targetEa = idc.GetOperandValue(curEa, 0)
                else:
                    targetEa = idc.NextHead(curEa)

                # Increase the currently analysed offset and determine if I have to stop or not
                if (offset + 1 >= len(mask)):
                    # I need to exit here
                    self.curTntMaskAndOffset = ["", 0]
                    return targetEa
                else:
                    self.curTntMaskAndOffset = [mask, offset + 1]

            elif (mnem == "ret" or mnem == "retn"):
                (mask, offset) = (self.curTntMaskAndOffset[0], self.curTntMaskAndOffset[1])

                # Check this 2 lines:
                if (endEa != 0):
                    cmt = idc.CommentEx(curEa, 0)
                    if (cmt is None): cmt = "Target: "
                    cmt += (hex(endEa)[:-1]) + " "
                    idc.MakeComm(curEa, cmt)
                    if (len(self.retAddrs) > 0 and self.retAddrs[-1] == endEa):
                        # Delete this address from the return address array
                        self.retAddrs.pop()         
                    return endEa

                #Pop the RET address and continue from there
                if (len(self.retAddrs) > 0):
                    targetEa = self.retAddrs.pop()
                else:
                    # We are done, go to another block (if any)
                    return 0

                if (offset < len(mask)):
                    # Intel Manual, section 36.4.2.1 - Taken/Not-taken (TNT) Packet
                    # It seems that the TNT packets tracks even the RET opcodes
                    if (mask[offset] != '!'):
                        # Signal here the error??
                        print ("TNT Packet inconsistency error detected at address %s. Current packet: %s." % (hex(curEa)[:-1], hex(nextPck[0])))   
                        raise StandardError("The TNT bit should not be 0 for a RET opcode")

                    # Increase the currently analysed offset and determine if I have to stop or not
                    if (offset + 1 >= len(mask)):
                        # I need to exit here
                        self.curTntMaskAndOffset = ["", 0]
                        return targetEa
                    else:
                        self.curTntMaskAndOffset = [mask, offset + 1]
                #End of Ret branch
            # For each other instructions continue until we reach endEa
            else:
                targetEa = idc.NextHead(curEa)

            if (targetEa == endEa):
                return targetEa
            curEa = targetEa

            # The following code worked:
            #if (endEa == 0 or targetEa < endEa): 
            #    curEa = targetEa
            #elif (targetEa == endEa):
            #    return targetEa
            #elif (curRetAddr != 0 and curRetAddr <= endEa):
            #    # There should be a RET somewhere
            #    curEa = targetEa
            #else:
            #    return targetEa

    def Run(self, fileName = ''):
        # Ask the user for a file if needed
        if fileName == '' or fileName == None:
            fileName = idc.AskFile(0, "*.*", "Select a PT dump file...") 
        if fileName == '' or fileName == None:
            return False
        
        # Run the engine and get the base start address:
        qwStartEa = self.ParseFileAndGetStartAddr(fileName)
        if (qwStartEa == 0): 
            print "Error! The specified dump file is not valid!"
            return False 
        #print "Obtained %s has start virtual address." % hex(qwStartEa)
        bRetVal = self.StartPtAnalysis(qwStartEa)
        if (self.hTraceFile != None): self.hTraceFile.close()


if (IDA_READY == 0):
    print "This Script requires IDA Python to properly work."
    print "Open me in IDA please!"
    raw_input("Press any key to exit...")
else:
    plugin = Ida_pt()
    plugin.Run()




```

`Compiled_IntelPt/readme.md`:

```md
<h2>Compiled Windows Intel PT Driver</h2>

<p>This folder contains the compiled version of the Windows Intel PT Driver and Control Application</p>
<p>Version: 0.6</p>
<p>News:
<ul>
   <li>Re-designed the entire driver code. Now it is much more modular and scalable</li>
   <li>Added and tested the support for Kernel-mode tracing</li>
   <li>Added the support for Kernel tracing from the user-mode application (requires Administratives privilege)</li>
   <li>Added the support for Microsoft HyperV (Root Partition only)</li>
   <li>Written some example code for doing Kernel-tracing of the loading/unloading code of a target driver</li>
</ul></p>
<p>Unfortunately the driver code is still too young to be compiled as signed. 
You need to enable the Test Signing mode in your Windows OS to be able to use the driver.
By the way our tests highlighted that the code was really very stable.
Write us a mail (<a href="mailto:info@andrea-allievi.com">info@andrea-allievi.com</a>) if you find some bugs or for any other queries.
If I find the time I will be happy to answer.
</p>
<p>Last Revision: 17th June 2017 - Recon Conference<br>
</p>

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    {one line to give the program's name and a brief idea of what it does.}
    Copyright (C) {year}  {name of author}

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    {project}  Copyright (C) {year}  {fullname}
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<http://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<http://www.gnu.org/philosophy/why-not-lgpl.html>.

```

`PtControlApp/EntryPoint.cpp`:

```cpp
/**********************************************************************
 *  Windows Intel Processor Trace (PT) Driver
 *  Filename: EntryPoint.h
 *  The Control application entry point and startup functions
 *  Last revision: 12/01/2016
 *
 *  Copyright© 2016 Andrea Allievi, Richard Johnson
 *  Microsoft Ltd & TALOS Research and Intelligence Group
 *  All right reserved
 **********************************************************************/
#include "stdafx.h"
#include "IntelPtControlApp.h"
#include "pt_dump.h"

// Global app data
GLOBAL_DATA g_appData;

int wmain(int argc, LPTSTR argv[])
{
	int iRetVal = 0;
	wprintf(L"Intel PT Test Application\r\n");
	wprintf(L"Version 0.6\r\n\r\n");

	if (!ParseCommandLine(argc, argv)) {
		iRetVal = NoCmdlineStartup();
	}
	//StartEtwTrace();

	rewind(stdin);
	wprintf(L"Press any key to exit...");
	getwchar();
	return iRetVal;
}

// Parse command line
bool ParseCommandLine(int argc, LPTSTR argv[]) {
	BOOL bRetVal = FALSE;				// Win32 Returned value
	bool bError = false;				// TRUE if I found some parsing errors
	LPTSTR lpPtBinFile = NULL,			// Input binary file
		lpOutFile = NULL,				// Output file
		lpFileOnlyName = NULL;			// A file name without the path
	QWORD qwBaseAddr = 0;				// The dump base address
	DWORD dwSize = 0;					// Maximum size to read from the dump
	LPTSTR endPtr = NULL;				// END string pointer


	for (int i = 1; i < argc; i++) {
		LPTSTR arg = argv[i];
		LPTSTR param = NULL;

		param = wcschr(arg, L':');
		if (param) { param[0] = 0; param++; }

		// Check the arg starting chr
		if (arg[0] == L'/' || arg[0] == L'-')
			arg++;
		else {
			bError = true;
			break;
		}

		if (_wcsicmp(arg, L"help") == 0) {
			ShowCommandLineUsage();
			return true;
		}

		// Live PT trace switches
		else if (_wcsicmp(arg, L"buffsize") == 0) {
			DWORD dwBuffSize = 0;
			if (param[0] == L'0' && (param[1] | 0x20) == 'x')
				dwBuffSize = wcstoul(param + 2, &endPtr, 16);
			else
				// Consider this as an integer value
				dwBuffSize = wcstoul(param, &endPtr, 10);
			if (dwBuffSize == 0) bError = true;
			if (dwBuffSize % PAGE_SIZE) dwBuffSize += (PAGE_SIZE - (dwBuffSize % PAGE_SIZE));
			g_appData.dwTraceBuffSize = dwBuffSize;
		}

		// Binary Files switches
		else if (_wcsicmp(arg, L"decode") == 0)
			lpPtBinFile = param;
		else if (_wcsicmp(arg, L"out") == 0)
			lpOutFile = param;
		else if (_wcsicmp(arg, L"base") == 0) {
			if (param == NULL || wcslen(param) < 2) {
				bError = true;
				break;
			}
			if (param[0] == L'0' && (param[1] | 0x20) == 'x')
				qwBaseAddr = wcstoull(param + 2, &endPtr, 16);
			else
				qwBaseAddr = wcstoull(param, &endPtr, 16);
		}
		else if (_wcsicmp(arg, L"filesize") == 0) {
			if (param == NULL || wcslen(param) < 2) {
				bError = true;
				break;
			}
			if (param[0] == L'0' && (param[1] | 0x20) == 'x')
				dwSize = wcstoul(param + 2, &endPtr, 16);
			else
				// Consider this as an integer value
				dwSize = wcstoul(param, &endPtr, 10);
			if (dwSize == 0) bError = true;
			if (dwSize % 4096) dwSize += (4096 - (dwSize % 4096));
		}
		else
			bError = true;
		if (bError) break;
	}

	if (lpPtBinFile) {
		bool bNoOutFile = false;
		if (!FileExists(lpPtBinFile)) {
			wprintf(L"Error! The specified file name doesn't exists!\r\n");
			return true;
		}

		// Do the decoding here and exit
		lpFileOnlyName = wcsrchr(lpPtBinFile, L'\\');
		if (lpFileOnlyName) lpFileOnlyName++; else lpFileOnlyName = lpPtBinFile;
		wprintf(L"Decoding \"%s\" file... ", lpFileOnlyName);

		if (!lpOutFile) {
			lpOutFile = new TCHAR[MAX_PATH];
			LPTSTR lpSlashPtr = NULL;
			GetModuleFileName(GetModuleHandle(NULL), lpOutFile, MAX_PATH);
			lpSlashPtr = wcsrchr(lpOutFile, L'\\');
			if (lpSlashPtr) lpSlashPtr[1] = 0;
			wcscat_s(lpOutFile, MAX_PATH, L"pt_dump.txt");
			bNoOutFile = true;
		}
		HANDLE hTxtDump = CreateFile(lpOutFile, FILE_WRITE_ACCESS, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
		if (hTxtDump == INVALID_HANDLE_VALUE) {
			if (bNoOutFile) { delete[] lpOutFile; lpOutFile = NULL; }
			cl_wprintf(RED, L"Error %i!\r\n", (LPVOID)GetLastError());
			return true;
		}
		CHAR fullLine[0x200] = { 0 }; DWORD dwBytesIo = 0;
		sprintf_s(fullLine, COUNTOF(fullLine), "AaLl86 Intel PT Trace file. Version 0.4\r\n");
		WriteFile(hTxtDump, fullLine, (DWORD)strlen(fullLine), &dwBytesIo, NULL);
		sprintf_s(fullLine, COUNTOF(fullLine), "Binary dump file name: %S\r\n", wcsrchr(lpPtBinFile, L'\\') + 1);
		WriteFile(hTxtDump, fullLine, (DWORD)strlen(fullLine), &dwBytesIo, NULL);
		sprintf_s(fullLine, COUNTOF(fullLine), "Base address: 0x%016llX\r\n", qwBaseAddr);
		WriteFile(hTxtDump, fullLine, (DWORD)strlen(fullLine), &dwBytesIo, NULL);
		sprintf_s(fullLine, COUNTOF(fullLine), "\r\n");
		WriteFile(hTxtDump, fullLine, (DWORD)strlen(fullLine), &dwBytesIo, NULL);
		WriteFile(hTxtDump, "Begin Trace Dump:\r\n", (DWORD)strlen("Begin Trace Dump:\r\n"), &dwBytesIo, NULL);
		CloseHandle(hTxtDump);

		bRetVal = pt_dump_file(lpPtBinFile, lpOutFile, dwSize);
		if (bNoOutFile) { delete[] lpOutFile; lpOutFile = NULL; }
		if (bRetVal)
			cl_wprintf(GREEN, L"OK\r\n");
		else {
			cl_wprintf(RED, L"Some Errors!\r\n");
			DeleteFile(lpOutFile);
		}
		return true;
	}
	return false;
}

// Show command line usage
void ShowCommandLineUsage() {
	wprintf(L"Command line usage.\r\n");
	wprintf(L"\r\nSwitches used for the live-tracing:\r\n"
		L"  /buffSize:<size> - Specify a PT trace buffer size (the default is 64 KBytes).\r\n"
		L"\r\n"
		L"Switches used for the decoding of a binary file:\r\n"
		L"  /decode:<dumpFile> - Decode a binary PT Dump file\r\n"
		L"  /fileSize:<sizeToRead> - Specify the maximum amount of data to read from the PT dump file\r\n"
		L"  /base:<baseAddressInHex> - Specify the base address for the PT dump (in HEX digits).\r\n"
		L"  /out:<outFile> - Output human-readable file path\r\n"
		L"  /help - Show this help.\r\n");
	wprintf(L"\r\n");
}




```

`PtControlApp/IntelPt.h`:

```h
/**********************************************************************
 *  Windows Intel Processor Trace (PT) Driver
 *  Filename: IntelPt.h
 *	Defines the Intel Processor Trace driver function prototypes 
 *  for the User-mode control application 
 *  Last revision: 12/01/2016
 *
 *  Copyright© 2016 Andrea Allievi, Richard Johnson
 *  Microsoft Ltd & TALOS Research and Intelligence Group
 *  All right reserved
 **********************************************************************/
#pragma once

typedef long NTSTATUS;

#pragma pack(1)
struct INTEL_PT_CAPABILITIES {
	UINT16 bCr3Filtering : 1;						// [0] - CR3 Filtering Support (Indicates that IA32_RTIT_CTL.CR3Filter can be set to 1)
	UINT16 bConfPsbAndCycSupported : 1;				// [1] - Configurable PSB and Cycle-Accurate Mode Supported (IA32_RTIT_CTL.PSBFreq can be set to a non-zero value, IA32_RTIT_STATUS.PacketByteCnt can be set to a non-zero value)
	UINT16 bIpFiltering : 1;						// [2] - IP Filtering and TraceStop	supported, and Preserve Intel PT MSRs across warm reset
	UINT16 bMtcSupport : 1;							// [3] - IA32_RTIT_CTL.MTCEn can be set to 1, and MTC packets will be generated (section 36.2.5)
	UINT16 bPtWriteSupport : 1;						// [4] - indicates support of PTWRITE
	UINT16 bPETSupport : 1;							// [5] - indicates support of Power Event Trace
	UINT16 bVmxSupport : 1;							// [6] - Indicates whether Intel PT can be used in VMX operations
	UINT16 bTopaOutput : 1;							// [7] - Tracing can be enabled with IA32_RTIT_CTL.ToPA = 1, hence utilizing the ToPA output scheme (section 36.2.4.2)
	UINT16 bTopaMultipleEntries : 1;				// [8] - ToPA tables can hold any number of output entries, up to the maximum allowed by the MaskOrTableOffset field of IA32_RTIT_OUTPUT_MASK_PTRS
	UINT16 bSingleRangeSupport : 1;					// [9] - Single-Range Output Supported
	UINT16 bTransportOutputSupport : 1;				// [10] - Output to Trace Transport Subsystem Supported (Setting IA32_RTIT_CTL.FabricEn to 1 is supported)
	UINT16 bIpPcksAreLip : 1;						// [11] - IP Payloads are LIP (Specifies if the generated packets that contain IP payloads have LIP values or RIP values)	<-- Very important
	SHORT numOfAddrRanges;							// + 0x02 - Number of Address Ranges - specifies the number ADDRn_CFG field supported in IA32_RTIT_CTL for IP filtering	and IP TraceStop
	SHORT mtcPeriodBmp;								// + 0x04 - Bitmap of supported MTC Period Encodings
	SHORT cycThresholdBmp;							// + 0x06 - Bitmap of supported Cycle Threshold values
	SHORT psbFreqBmp;								// + 0x08 - Bitmap of supported	Configurable PSB Frequency encoding
};

// The IA32_PERF_GLOBAL_STATUS descriptor of Intel Broadwell microarchitecture 
union MSR_IA32_PERF_GLOBAL_STATUS_DESC {
	struct {
		DWORD PMC0_OVF : 1;						// [0] - Read only
		DWORD PMC1_OVF : 1;						// [1] - Read only 
		DWORD PMC2_OVF : 1;						// [2] - Read only
		DWORD PMC3_OVF : 1;						// [3] - Read only
		DWORD PMC4_OVF : 1;						// [4] - Read only (if PMC4 present)
		DWORD PMC5_OVF : 1;						// [5] - Read only (if PMC5 present) 
		DWORD PMC6_OVF : 1;						// [6] - Read only (if PMC6 present)
		DWORD PMC7_OVF : 1;						// [7] - Read only (if PMC7 present)
		DWORD Reserved : 24;					// [8:31] - Reserved
		DWORD FIXED_CTR0 : 1;					// [32] - FIXED_CTR0 Overflow (RO)
		DWORD FIXED_CTR1 : 1;					// [33] - FIXED_CTR1 Overflow (RO)
		DWORD FIXED_CTR2 : 1;					// [34] - FIXED_CTR2 Overflow (RO)
		DWORD Reserved2 : 20;					// [35:54] - Reserved
		DWORD TraceToPAPMI : 1;				// [55] - The ToPA PMI Interrupt status
		DWORD Reserved3 : 5;					// [56:60] - Reserved
		DWORD Ovf_UncorePMU : 1;				// [61]
		DWORD Ovf_Buffer : 1;					// [62]
		DWORD CondChgd : 1;						// [63]
	} Fields;
	ULONGLONG All;
};


// The Table of Physical Address Entry format (Section 36.2.4.2)
union TOPA_TABLE_ENTRY {
	struct {
		QWORD End : 1;						// [0] - If set, indicates that this is an END entry, and thus the address field points to a table base rather than an output region base.
		QWORD Reserved1 : 1;				// [1] - Must be 0
		QWORD Int : 1;						// [2] - When the output region indicated by this entry is filled, signal Perfmon LVT interrupt.
		QWORD Reserved2 : 1;				// [3] - Must be 0
		QWORD Stop : 1;						// [4] - When the output region indicated by this entry is filled, software should disable packet generation
		QWORD Reserved3 : 1;				// [5] - Must be 0
		QWORD Size : 4;						// [6:9] - Indicates the size of the associated output region. Encodings are: 0: 4K, 1 : 8K, 2 : 16K, 3 : 32K, 4 : 64K, 5 : 128K, 6 : 256K, 7 : 512K, 8 : 1M, 9 : 2M, 10 : 4M, 11 : 8M, 12 : 16M, 13 : 32M, 14 : 64M, 15 : 128M
		QWORD Reserved4 : 2;				// [10] - Must be 0
		QWORD BaseAddr : 48;				// [12:MAXPHYADDR-1] - If END=0, this is the base physical address of the output region specified by this entry; If END=1, this is the 4K-aligned base physical address of the next ToPA table
	} Fields;
	ULONGLONG All;
};
#pragma pack()

// Undocumented Win32 APIs
extern "C" NTSTATUS ZwResumeProcess(HANDLE hProcess);


```

`PtControlApp/IntelPtControlApp.cpp`:

```cpp
/**********************************************************************
 *  Windows Intel Processor Trace (PT) Driver
 *  Filename: IntelPtControlApp.cpp
 *	Implement the entire PT driver's Control Application 
 *  Last revision: 12/01/2016
 *
 *  Copyright© 2016 Andrea Allievi, Richard Johnson
 *  Microsoft Ltd & TALOS Research and Intelligence Group
 *  All right reserved
 **********************************************************************/

#include "stdafx.h"
#include "IntelPtControlApp.h"
#include "Psapi.h"
#include <crtdbg.h>
#include "pt_dump.h"
#include "UndocNt.h"
#include "log.h"
const LPTSTR g_ptDevName = L"\\\\.\\WindowsIntelPtDev";
#pragma comment (lib, "ntdll.lib")

// Entry point without command line arguments
int NoCmdlineStartup()
{
	BOOL bRetVal = FALSE;
	INTEL_PT_CAPABILITIES ptCap = { 0 };
	HANDLE hPtDev = NULL;							// Handle to the PT device
	TCHAR procPath[MAX_PATH] = { 0 };				// The target process full path
	PT_USER_REQ ptStartStruct = { 0 };				// The Intel PT starting structure
	DWORD dwBytesIo = 0;							// Number of I/O bytes
	DWORD dwCpusCount = 1;							// Number of CPUs in which to run the code
	DWORD dwLastErr = 0;							// Last Win32 Error
	KAFFINITY cpuAffinity = 0;						// The processor Affinity mask
	BOOLEAN bDoKernelTrace = FALSE;					// TRUE if I would like to do kernel tracing
	PT_CPU_BUFFER_DESC * pCpuDescArray;				// The CPU PT buffer descriptor array
	LPTSTR lpOutBasePath = NULL;					// The dump files base directory
	BOOLEAN bManuallyAllocBuff = FALSE;				// TRUE if I would like to manually allocate the buffer (used for test purposes)
	BOOLEAN bDeleteFiles = FALSE;					// TRUE if some errors that require the file deletion
	PROCESS_INFORMATION pi = { 0 };
	SYSTEM_INFO sysInfo = { 0 };

	// Allocate memory for the file names
	lpOutBasePath = new TCHAR[MAX_PATH]; 
	RtlZeroMemory(lpOutBasePath, MAX_PATH * sizeof(TCHAR));

	GetNativeSystemInfo(&sysInfo);
	hPtDev = CreateFile(g_ptDevName, FILE_ALL_ACCESS, 0, NULL, OPEN_EXISTING, 0, NULL);
	dwLastErr = GetLastError();

	if (hPtDev == INVALID_HANDLE_VALUE) {
		// Do not use the driver to check the processor Support
		bRetVal = CheckIntelPtSupport(&ptCap);
		wprintf(L"Intel Processor Tracing support for this CPU: ");
		if (bRetVal) cl_wprintf(GREEN, L"YES\r\n"); else cl_wprintf(RED, L"NO\r\n");
		wprintf(L"Unable to open the Intel PT device object!\r\n");
		return 0;
	}
	else
		g_appData.hPtDev = hPtDev;

	// First check if the processor is Intel PT compatible (bypass HyperV if needed)
	bRetVal = DeviceIoControl(hPtDev, IOCTL_PTDRV_CHECKSUPPORT, NULL, 0, (LPVOID)&ptCap, sizeof(ptCap), &dwBytesIo, NULL);
	if (!bRetVal)
		// We have failed, rely on the classical method as last resort
		bRetVal = CheckIntelPtSupport(&ptCap);
	wprintf(L"Intel Processor Tracing support for this CPU: ");
	if (bRetVal) cl_wprintf(GREEN, L"YES\r\n"); else cl_wprintf(RED, L"NO\r\n");


	// Create the Exit Event
	g_appData.hExitEvt = CreateEvent(NULL, TRUE, FALSE, NULL);

	#pragma region 1. Generate Output dunp files base path string 
	SYSTEMTIME curTime = { 0 };
	GetModuleFileName(GetModuleHandle(NULL), lpOutBasePath, MAX_PATH);
	GetLocalTime(&curTime);
	LPTSTR slashPtr = wcsrchr(lpOutBasePath, L'\\');
	if (slashPtr) slashPtr[1] = 0; 
	swprintf_s(lpOutBasePath, MAX_PATH, L"%s%.2i%.2i-%.2i%.2i%.4i_Dumps",
		lpOutBasePath, curTime.wHour, curTime.wMinute, curTime.wMonth, curTime.wDay, curTime.wYear);
	CreateDirectory(lpOutBasePath, NULL);
	#pragma endregion

	#pragma region 2. Ask the user and check the CPU affinity
	TCHAR answer[10] = { 0 };
	wprintf(L"Would you like to do the Kernel Tests? [Y/N] ");
	wscanf_s(L"%2s", answer, 10);
	if ((answer[0] | 0x20) == L'y') {
		g_appData.dwMainThrId = GetCurrentThreadId();
		bDoKernelTrace = TRUE;
	}

	wprintf(L"Insert here the target %s to trace: ", (bDoKernelTrace ? L"kernel driver" : L"process"));
	wscanf_s(L"%s", procPath, MAX_PATH);
	if (sysInfo.dwNumberOfProcessors > 1) {
		// Ask how many processor to use
		wprintf(L"On how many processors would you like to run the process? [1/%i] ", sysInfo.dwNumberOfProcessors);
		wscanf_s(L"%i", &dwCpusCount);

		if (dwCpusCount > sysInfo.dwNumberOfProcessors) {
			wprintf(L"Invalid value, assuming all the processors as valid.\r\n");
			cpuAffinity = sysInfo.dwActiveProcessorMask;
			dwCpusCount = sysInfo.dwNumberOfProcessors;
		} else
			cpuAffinity = ((DWORD_PTR)(-1i64) >> ((sizeof(DWORD_PTR) * 8) - dwCpusCount));
		if (FALSE) 
			// If you would like to test the different affinities:
			cpuAffinity = 0xd;
		_ASSERT((sysInfo.dwActiveProcessorMask | cpuAffinity) == sysInfo.dwActiveProcessorMask);
	} else {
		cpuAffinity = 0x1;
		dwCpusCount = 1;
	}
	#pragma endregion
	
	#pragma region 3. Create the CPU buffer data structures and trace files
	wprintf(L"Creating trace files (binary and readable)... ");
	bRetVal = (BOOL)InitPerCpuData(cpuAffinity, lpOutBasePath);
	if (bRetVal) 
		cl_wprintf(GREEN, L"Success!\r\n");
	else {
		RemoveDirectory(lpOutBasePath);
		// We are great, we would like to try to write to the TEMP directory
		dwBytesIo = GetTempPath(MAX_PATH, lpOutBasePath);
		LPTSTR slashPtr = wcsrchr(lpOutBasePath, L'\\');
		if (lpOutBasePath[dwBytesIo - 1] == '\\')  lpOutBasePath[--dwBytesIo] = 0;
		swprintf_s(lpOutBasePath, MAX_PATH, L"%s\\IntelPt_Dumps_%.2i%.2i-%.2i%.2i%.4i",
			lpOutBasePath, curTime.wHour, curTime.wMinute, curTime.wMonth, curTime.wDay, curTime.wYear);
		CreateDirectory(lpOutBasePath, NULL);
		bRetVal = (BOOL)InitPerCpuData(cpuAffinity, lpOutBasePath);
		if (bRetVal) {
			cl_wprintf(GREEN, L"Success! ");
			wprintf(L"(in TEMP directory)\r\n");
		}
	}
	
	if (!bRetVal) {
		RemoveDirectory(lpOutBasePath);
		cl_wprintf(RED, L"Error!\r\n");
		wprintf(L"Unable to create the output dump file.\r\n");
		CloseHandle(hPtDev);
		return -1;
	}
	pCpuDescArray = g_appData.pCpuDescArray;
	#pragma endregion

	#pragma region 4. Spawn of the new process and PMI threads
	if (!bDoKernelTrace) {
		wprintf(L"Creating target process... ");
		bRetVal = SpawnSuspendedProcess(procPath, NULL, &pi);
		if (bRetVal) cl_wprintf(GREEN, L"OK\r\n");
		else {
			wprintf(L"Error!\r\n");
			FreePerCpuData(TRUE);
			CloseHandle(hPtDev);
			wprintf(L"Press any key to exit...");
			getwchar();
			return -1;
		}
		g_appData.hTargetProc = pi.hProcess;
	} else {
		// Set this process as the remote one
		pi.hProcess = GetCurrentProcess();
		pi.hThread = GetCurrentThread();
		pi.dwProcessId = GetCurrentProcessId();
	}

	if (!bDoKernelTrace) {
		bRetVal = SetProcessAffinityMask(pi.hProcess, cpuAffinity);
		_ASSERT(bRetVal);
		bRetVal = SetThreadAffinityMask(pi.hThread, cpuAffinity);
		_ASSERT(bRetVal);
		wprintf(L"   Affinity mask set to 0x%08X.\r\n", (UINT32)cpuAffinity);
	}
	else bRetVal = (BOOL)SetThreadAffinityMask(pi.hThread, cpuAffinity);
	_ASSERT(bRetVal);
	if (!bRetVal) {
		cl_wprintf(YELLOW, L"Warning!\r\n");
		wprintf(L"   Unable Set the processor affinity for the spawned process.\r\n");
	}

	// Create the PMI threads (1 per target CPU)
	for (int i = 0; i < (int)dwCpusCount; i++) {
		PT_PMI_USER_CALLBACK pmiDesc = { 0 };
		HANDLE hNewThr = NULL;
		DWORD newThrId = 0;

		hNewThr = CreateThread(NULL, 0, PmiThreadProc, (LPVOID)i, CREATE_SUSPENDED, &newThrId);
		// Register this thread and its callback
		pmiDesc.dwThrId = newThrId;
		pmiDesc.kCpuAffinity = (1i64 << i);
		pmiDesc.lpAddress = PmiCallback;
		bRetVal = DeviceIoControl(hPtDev, IOCTL_PTDRV_REGISTER_PMI_ROUTINE, (LPVOID)&pmiDesc, sizeof(PT_PMI_USER_CALLBACK), NULL, 0, &dwBytesIo, NULL);
		if (bRetVal) {
			pCpuDescArray[i].dwPmiThrId = newThrId;
			pCpuDescArray[i].hPmiThread = hNewThr;
			ResumeThread(hNewThr);
		}
	}
	#pragma endregion

	#pragma region 5. Set IP filtering (if any) and TRACE options
	HMODULE hRemoteMod = NULL;						// The remote module base address
	MODULEINFO remoteModInfo = { 0 };				// The remote module information
	if (g_appData.bTraceByIp) {
		// Now grab the remote image base address and size
		if (!bDoKernelTrace) {
			bRetVal = EnumProcessModules(pi.hProcess, &hRemoteMod, sizeof(HMODULE), &dwBytesIo);
			bRetVal = GetModuleInformation(pi.hProcess, hRemoteMod, &remoteModInfo, sizeof(MODULEINFO));
			dwLastErr = GetLastError();
		}
		else {
			// Grab the target module base address
			SYSTEM_ALL_MODULES * pSysAllModules = NULL;
			NTSTATUS ntStatus = 0;
			CHAR modNameAnsi[0x80] = { 0 };
			sprintf_s(modNameAnsi, COUNTOF(modNameAnsi), "%S", procPath);
			ntStatus = ZwQuerySystemInformation(11, pSysAllModules, 0, &dwBytesIo);
			if (ntStatus == STATUS_INFO_LENGTH_MISMATCH) {
				pSysAllModules = (SYSTEM_ALL_MODULES*)VirtualAlloc(NULL, dwBytesIo + 64, MEM_COMMIT, PAGE_READWRITE);
				RtlZeroMemory(pSysAllModules, dwBytesIo);

				ntStatus = ZwQuerySystemInformation(11, pSysAllModules, dwBytesIo, &dwBytesIo);
				if (ntStatus == 0) {
					// Search for the SimplePt
					for (unsigned i = 0; i < pSysAllModules->dwNumOfModules; i++) {
						SYSTEM_MODULE_INFORMATION curMod = pSysAllModules->modules[i];
						LPSTR lpTargetModName = curMod.ImageName + curMod.ModuleNameOffset;
						if (_stricmp(modNameAnsi, lpTargetModName) == 0) {
							// Target module found
							wprintf(L"Found \"%S\" kernel driver in memory.\r\n", lpTargetModName);
							remoteModInfo.lpBaseOfDll = curMod.Base;
							remoteModInfo.SizeOfImage = curMod.Size;
							break;
						}
					}
				}
			}
			if (pSysAllModules) VirtualFree((LPVOID)pSysAllModules, 0, MEM_RELEASE);
			ptStartStruct.bTraceKernel = TRUE;
			ptStartStruct.bTraceUser = FALSE;
		}
		g_appData.bTraceOnlyKernel = bDoKernelTrace;

		#ifdef _DEBUG
		if (!remoteModInfo.lpBaseOfDll && _wcsicmp(procPath, L"AaLl86TestDriver.sys") == 0) {
			wprintf(L"Would you like to perform the Tracing test from Kernel-mode? [Y/N] ");
			wscanf_s(L"%2s", answer, 10);
			// Do the special Kernel-mode test of AaLl86
			if ((answer[0] | 0x20) == L'y') {
				DoKernelTrace(hPtDev, PT_USER_REQ(), procPath);
				goto CloseTrace;
			}
		}
		#endif

		if (!remoteModInfo.lpBaseOfDll) {
			cl_wprintf(RED, L"Error! ");
			wprintf(L"I was not able to find the target %s base address and size.\r\n", (bDoKernelTrace ? L"kernel module" : L"process' main module"));
			FreePerCpuData();
			CloseHandle(hPtDev);
			return -1;
		}

		cl_wprintf(PINK, L"\r\n       Using IP filtering mode!\r\n");
		wprintf(L"%s base address: 0x%llX, size 0x%08X.\r\n\r\n", (bDoKernelTrace ? L"Target kernel driver" : L"New Process main module"),
			(QWORD)remoteModInfo.lpBaseOfDll, remoteModInfo.SizeOfImage);

		// Set the PT_USER_REQUEST structure
		ptStartStruct.IpFiltering.dwNumOfRanges = 1;
		ptStartStruct.IpFiltering.Ranges[0].lpStartVa = (LPVOID)((ULONG_PTR)remoteModInfo.lpBaseOfDll);
		ptStartStruct.IpFiltering.Ranges[0].lpEndVa = (LPVOID)((ULONG_PTR)remoteModInfo.lpBaseOfDll + remoteModInfo.SizeOfImage);
		ptStartStruct.IpFiltering.Ranges[0].bStopTrace = FALSE;
	}		// END Tracing by IP block

	// Write some information in the output text file:
	WriteCpuTextDumpsHeader(procPath, (ULONG_PTR)remoteModInfo.lpBaseOfDll, remoteModInfo.SizeOfImage, bDoKernelTrace);
	ptStartStruct.bTraceUser = !bDoKernelTrace;
	ptStartStruct.bTraceKernel = bDoKernelTrace;
	// For now do not set the frequencies....
	ptStartStruct.dwOptsMask = PT_TRACE_BRANCH_PCKS_MASK | PT_ENABLE_RET_COMPRESSION_MASK | PT_ENABLE_TOPA_MASK;
	ptStartStruct.kCpuAffinity = cpuAffinity;
	ptStartStruct.dwTraceSize = g_appData.dwTraceBuffSize;
	#pragma endregion

	#pragma region 6. Optional - Allocate each PT CPU buffer (we can even skip this process, the START_TRACE IOCTL can do it for us) 
	LPVOID * lpBuffArray = new LPVOID[dwCpusCount];
	RtlZeroMemory(lpBuffArray, sizeof(LPVOID)* dwCpusCount);
	if (bManuallyAllocBuff) {
		// 2 Things to keep in mind here:
		//    1. The IOCTL_PTDRV_ALLOC_BUFFERS checks PT_ENABLE_TOPA bit for the buffer allocations
		//    2. We do not need to send the entire PT_USER_REQ structure but only CPU mask, Size and a BOOL value (that contains the bit for the TOPA)
		DeviceIoControl(hPtDev, IOCTL_PTDRV_FREE_BUFFERS, (LPVOID)&ptStartStruct, FIELD_OFFSET(PT_USER_REQ, dwProcessId), NULL, 0, &dwBytesIo, NULL);
		bRetVal = DeviceIoControl(hPtDev, IOCTL_PTDRV_ALLOC_BUFFERS, (LPVOID)&ptStartStruct, FIELD_OFFSET(PT_USER_REQ, dwProcessId), lpBuffArray, sizeof(LPVOID) * dwCpusCount, &dwBytesIo, NULL);
		dwLastErr = GetLastError();
		if (bRetVal) {
			// Save our buffers
			for (int i = 0; i < (int)dwCpusCount; i++)
				g_appData.pCpuDescArray[i].lpPtBuff = (LPBYTE)lpBuffArray[i];
		}
		else {
			cl_wprintf(RED, L"Error! ");
			wprintf(L"Unable to allocate the PT buffers!\r\n");
			FreePerCpuData();
			CloseHandle(hPtDev);
			return 0;
		}
	}
	#pragma endregion

	#pragma region 8. Start the tracing and wait the process to exit
	// Start the device Tracing
	if (!bDoKernelTrace) {
		wprintf(L"Starting the Tracing and resuming the process... ");
		ptStartStruct.dwProcessId = pi.dwProcessId;
		ptStartStruct.kCpuAffinity = cpuAffinity;
		bRetVal = DeviceIoControl(hPtDev, IOCTL_PTDRV_START_TRACE, (LPVOID)&ptStartStruct, sizeof(PT_USER_REQ), lpBuffArray, sizeof(LPVOID) * dwCpusCount, &dwBytesIo, NULL);
		dwLastErr = GetLastError();

		if (bRetVal) {
			cl_wprintf(GREEN, L"OK\r\n");
			g_appData.currentTrace = ptStartStruct;

			// Copy the returned Buffer array
			for (int i = 0; i < (int)g_appData.dwNumOfActiveCpus; i++) {
				g_appData.pCpuDescArray[i].lpPtBuff = (LPBYTE)lpBuffArray[i];
				g_appData.pCpuDescArray[i].dwBuffSize = ptStartStruct.dwTraceSize;
			}

			// Resume the target process
			wprintf(L"\r\n");
			Sleep(100);
			ResumeThread(pi.hThread);
			wprintf(L"Waiting for the traced process to exit...\r\n");
			WaitForSingleObject(pi.hProcess, INFINITE);
			wprintf(L"\r\n");
		}
		else  {
			TerminateProcess(pi.hProcess, -1);
			cl_wprintf(RED, L"Error!\r\n");
			bDeleteFiles = TRUE;
		}
	}
	else {
		DoKernelTrace(hPtDev, ptStartStruct, procPath);
	}

	// Set the event and wait for all PMI thread to exit
CloseTrace:
	SetEvent(g_appData.hExitEvt);
	for (int i = 0; i < (int)dwCpusCount; i++) {
		WaitForSingleObject(pCpuDescArray[i].hPmiThread, INFINITE);
		CloseHandle(pCpuDescArray[i].hPmiThread);
		pCpuDescArray[i].hPmiThread = NULL;
		pCpuDescArray[i].dwPmiThrId = 0;
	}
	#pragma endregion

	#pragma region 9. Optional - Get the results of our tracing (like the number of written packets)
	PT_TRACE_DETAILS ptDetails = { 0 };
	QWORD qwTotalNumOfPtPcks = 0;					// The TOTAL number of acquired packets
	wprintf(L"\r\n\r\n");
	cl_wprintf(DARKYELLOW, L"*** PT Trace results ***\r\n");
	wprintf(L"Number of traced CPUs: %i   -   Affinity mask: 0x%08X.\r\n", dwCpusCount, (DWORD)cpuAffinity);
	for (int i = 0; i < sizeof(cpuAffinity) * 8; i++) {
		if (!(cpuAffinity & (1i64 << i))) continue;

		wprintf(L"CPU %i\r\n", i);
		RtlZeroMemory(&ptDetails, sizeof(ptDetails));
		bRetVal = DeviceIoControl(hPtDev, IOCTL_PTDR_GET_TRACE_DETAILS, (LPVOID)&i, sizeof(int), (LPVOID)&ptDetails, sizeof(ptDetails), &dwBytesIo, NULL);
		if (bRetVal) {
			wprintf(L"   Number of traced IP ranges: %i\r\n", ptDetails.IpFiltering.dwNumOfRanges);
			wprintf(L"   Number of acquired packets: %I64i\r\n", ptDetails.qwTotalNumberOfPackets);
			qwTotalNumOfPtPcks += ptDetails.qwTotalNumberOfPackets;
		} else
			cl_wprintf(RED, L"   Error!\r\n");
	}
	wprintf(L"\r\nGlobal number of PT packets acquired: %I64i.\r\n", qwTotalNumOfPtPcks);
	wprintf(L"All the dumps have been saved in \"%s\".\r\n", lpOutBasePath);
	#pragma endregion

	#pragma region 10. Free the resources and close each files
	// Stop the Tracing (and clear the buffer if not manually allocated)
	bRetVal = DeviceIoControl(hPtDev, IOCTL_PTDRV_CLEAR_TRACE, (LPVOID)&cpuAffinity, sizeof(cpuAffinity), NULL, 0, &dwBytesIo, NULL);

	CloseHandle(pi.hProcess); 
	CloseHandle(pi.hThread);
	FreePerCpuData(bDeleteFiles);
	if (bManuallyAllocBuff)
		bRetVal = DeviceIoControl(g_appData.hPtDev, IOCTL_PTDRV_FREE_BUFFERS, (LPVOID)&cpuAffinity,
			sizeof(cpuAffinity), NULL, 0, &dwBytesIo, NULL);


	CloseHandle(hPtDev);
	#pragma endregion
    return 0;
}

extern "C" void MovToRdi(QWORD value);
// Check if the current CPU has support for Intel PT
BOOL CheckIntelPtSupport(INTEL_PT_CAPABILITIES * lpPtCap)
{
	INTEL_PT_CAPABILITIES ptCap = { 0 };
	int cpuid_ctx[4] = { 0 };			// EAX, EBX, ECX, EDX

	// Instrumentation for the Hypervisor
	QWORD rdiVal = 0;
	RtlCopyMemory(&rdiVal, " AaLl86 ", sizeof(__int64));
	MovToRdi(rdiVal);

	// Processor support for Intel Processor Trace is indicated by CPUID.(EAX=07H,ECX=0H):EBX[bit 25] = 1.
	__cpuidex(cpuid_ctx, 0x07, 0);
	if (!(cpuid_ctx[1] & (1 << 25))) return FALSE;

	// Now enumerate the Intel Processor Trace capabilities
	RtlZeroMemory(cpuid_ctx, sizeof(cpuid_ctx));
	MovToRdi(rdiVal);
	__cpuidex(cpuid_ctx, 0x14, 0);
	// If the maximum valid sub-leaf index is 0 exit immediately
	if (cpuid_ctx[0] == 0) return FALSE;

	ptCap.bCr3Filtering = (cpuid_ctx[1] & (1 << 0)) != 0;					// EBX
	ptCap.bConfPsbAndCycSupported = (cpuid_ctx[1] & (1 << 1)) != 0;
	ptCap.bIpFiltering = (cpuid_ctx[1] & (1 << 2)) != 0;
	ptCap.bMtcSupport = (cpuid_ctx[1] & (1 << 3)) != 0;
	ptCap.bTopaOutput = (cpuid_ctx[2] & (1 << 0)) != 0;						// ECX
	ptCap.bTopaMultipleEntries = (cpuid_ctx[2] & (1 << 1)) != 0;
	ptCap.bSingleRangeSupport = (cpuid_ctx[2] & (1 << 2)) != 0;
	ptCap.bTransportOutputSupport = (cpuid_ctx[2] & (1 << 3)) != 0;
	ptCap.bIpPcksAreLip = (cpuid_ctx[2] & (1 << 31)) != 0;

	// Enmeration part 2:
	RtlZeroMemory(cpuid_ctx, sizeof(cpuid_ctx));
	MovToRdi(rdiVal);
	__cpuidex(cpuid_ctx, 0x14, 1);
	ptCap.numOfAddrRanges = (BYTE)(cpuid_ctx[0] & 0x7);
	ptCap.mtcPeriodBmp = (SHORT)((cpuid_ctx[0] >> 16) & 0xFFFF);
	ptCap.cycThresholdBmp = (SHORT)(cpuid_ctx[1] & 0xFFFF);
	ptCap.psbFreqBmp = (SHORT)((cpuid_ctx[1] >> 16) & 0xFFFF);

	if (lpPtCap) *lpPtCap = ptCap;
	return TRUE;
}

// Close and flush the per-CPU files and data structures
bool FreePerCpuData(BOOL bDeleteFiles) {
	PT_CPU_BUFFER_DESC * pCpuDesc = NULL;				// Current CPU Descriptor
	BOOLEAN bBuffValid = FALSE;
	DWORD dwBytesIo = 0;
	if (g_appData.pCpuDescArray == NULL) return false;

	for (int i = 0; i < (int)g_appData.dwNumOfActiveCpus; i++) {
		pCpuDesc = &g_appData.pCpuDescArray[i];
		if (pCpuDesc->hBinFile) { 
			if (bDeleteFiles)
				SetFileInformationByHandle(pCpuDesc->hBinFile, FileDispositionInfo, (LPVOID)&bDeleteFiles, sizeof(BOOL));
			CloseHandle(pCpuDesc->hBinFile); pCpuDesc->hBinFile = NULL; 
		}
		if (pCpuDesc->hTextFile) { 
			if (bDeleteFiles)
				SetFileInformationByHandle(pCpuDesc->hTextFile, FileDispositionInfo, (LPVOID)&bDeleteFiles, sizeof(BOOL));
			CloseHandle(pCpuDesc->hTextFile); pCpuDesc->hTextFile = NULL;
		}
		if (pCpuDesc->lpPtBuff) bBuffValid = TRUE;
	}

	// The actual PT buffer deallocation is done in the main routine (by the PT driver)
	delete[] g_appData.pCpuDescArray;
	g_appData.pCpuDescArray = NULL;
	g_appData.dwNumOfActiveCpus = 0;
	g_appData.kActiveCpuAffinity = 0;
	return true;
}

// Initialize and open the per-CPU files and data structures
bool InitPerCpuData(ULONG_PTR kCpuAffinity, LPTSTR lpBasePath) {
	PT_CPU_BUFFER_DESC * pCpuArray = NULL;				// The new PER-CPU array
	HANDLE hNewFile = NULL;								// The handle of the new file
	TCHAR newFileName[MAX_PATH] = { 0 };
	DWORD dwPathLen = 0;
	DWORD dwNumOfCpus = 0,								// Total number of CPUs
		dwCurCpuCount = 0;								// Current CPU counter (different from ID)

	FreePerCpuData();
	for (int i = 0; i < sizeof(kCpuAffinity) * 8; i++)
		if (kCpuAffinity & (1i64 << i)) dwNumOfCpus++;

	pCpuArray = new PT_CPU_BUFFER_DESC[dwNumOfCpus];
	RtlZeroMemory(pCpuArray, sizeof(PT_CPU_BUFFER_DESC) * dwNumOfCpus);
	g_appData.dwNumOfActiveCpus = dwNumOfCpus;
	g_appData.kActiveCpuAffinity = kCpuAffinity;
	g_appData.pCpuDescArray = pCpuArray;

	dwPathLen = (DWORD)wcslen(lpBasePath);

	for (int i = 0; sizeof(kCpuAffinity) * 8; i++) {
		PT_CPU_BUFFER_DESC * pCurCpuDesc = &pCpuArray[dwCurCpuCount];
		if (!(kCpuAffinity & (1i64 << i))) continue;
		if (dwCurCpuCount >= dwNumOfCpus) break;

		newFileName[0] = 0;
		swprintf_s(newFileName, MAX_PATH, L"%s\\cpu%.2i_bin.bin", lpBasePath, i);
		// Create the binary file 
		hNewFile = CreateFile(newFileName, FILE_GENERIC_WRITE | DELETE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, 0, NULL);

		// Create the text file 
		if (hNewFile != INVALID_HANDLE_VALUE) {
			pCurCpuDesc->hBinFile = hNewFile;
			newFileName[0] = 0;
			swprintf_s(newFileName, MAX_PATH, L"%s\\cpu%.2i_text.log", lpBasePath, i);
			hNewFile = CreateFile(newFileName, FILE_GENERIC_WRITE | DELETE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, 0, NULL);
		}
		if (hNewFile != INVALID_HANDLE_VALUE)
			pCurCpuDesc->hTextFile = hNewFile;
		else {
			FreePerCpuData(TRUE);
			return false;
		}
		dwCurCpuCount++;
	}
	return true;
}

// Write the human readable dump file header
bool WriteCpuTextDumpsHeader(LPTSTR lpImgName, ULONG_PTR qwBase, DWORD dwSize, BOOLEAN bKernelTrace) {
	DWORD dwCurCpuCount = 0;			// Current CPU counter (different from ID)
	DWORD dwNumOfCpus = 0;				// Total number of CPUs
	KAFFINITY kCpuAffinity = 0;			// Current CPU affinity mask
	CHAR fullLine[0x200] = { 0 };		// A full line of log dump
	DWORD dwBytesIo = 0;
	CVersionInfo verInfo;				// Version information about myself
	LPTSTR verString = NULL;			// My version info string
	if (!g_appData.pCpuDescArray) return false;

	// Grab some basic data
	dwNumOfCpus = g_appData.dwNumOfActiveCpus;
	kCpuAffinity = g_appData.kActiveCpuAffinity;

	if (lpImgName && wcsrchr(lpImgName, L'\\'))
		lpImgName = wcsrchr(lpImgName, L'\\') + 1;

	for (int i = 0; i < sizeof(g_appData.kActiveCpuAffinity) * 8; i++) {
		PT_CPU_BUFFER_DESC * pCurCpuBuff = &g_appData.pCpuDescArray[dwCurCpuCount];
		HANDLE hTextFile = NULL;
		if (!(kCpuAffinity & (1i64 << i))) continue;
		if (dwCurCpuCount > dwNumOfCpus) break;
		hTextFile = pCurCpuBuff->hTextFile;
		if (!hTextFile) { dwCurCpuCount++; continue; }

		verString = verInfo.GetFileVersionString();
		sprintf_s(fullLine, COUNTOF(fullLine), "Intel PT Trace file. Version %S.\r\nCPU ID : %i\r\n", verString, i);
		WriteFile(hTextFile, fullLine, (DWORD)strlen(fullLine), &dwBytesIo, NULL);
		if (qwBase && dwSize) {
			if (!bKernelTrace)
				sprintf_s(fullLine, COUNTOF(fullLine), "Executable name: %S\r\n", lpImgName);
			else
				sprintf_s(fullLine, COUNTOF(fullLine), "Kernel driver name: %S\r\n", lpImgName);
			WriteFile(hTextFile, fullLine, (DWORD)strlen(fullLine), &dwBytesIo, NULL);
			sprintf_s(fullLine, COUNTOF(fullLine), "Base address: 0x%016llX - Size 0x%08X\r\n", (QWORD)qwBase, dwSize);
			WriteFile(hTextFile, fullLine, (DWORD)strlen(fullLine), &dwBytesIo, NULL);
		}
		sprintf_s(fullLine, COUNTOF(fullLine), "\r\n");
		WriteFile(hTextFile, fullLine, (DWORD)strlen(fullLine), &dwBytesIo, NULL);
		WriteFile(hTextFile, "Begin Trace Dump:\r\n", (DWORD)strlen("Begin Trace Dump:\r\n"), &dwBytesIo, NULL);

		dwCurCpuCount++;
	}
	return true;
}

// Spawn a suspended process and oblige the loader to load the remote image in memory
BOOL SpawnSuspendedProcess(LPTSTR lpAppName, LPTSTR lpCmdLine, PROCESS_INFORMATION * pOutProcInfo) {
	BYTE remote_opcodes[] = { 0x90, 0x90, 0xc3, 0x90, 0x90 };			// NOP - RET opcodes
	PROCESS_INFORMATION pi = { 0 };					// Process information
	STARTUPINFO si = { 0 };							// The process Startup options
	ULONG_PTR ulBytesIo = 0;						// Number of I/O bytes
	LPVOID lpRemBuff = NULL;						// Remote memory buffer
	HANDLE hRemoteThr = NULL;						// The remote thread stub 
	BOOL bRetVal = FALSE;							// Win32 return value
	DWORD dwThrId = 0;								// Remote thread ID

	si.cb = sizeof(STARTUPINFO);
	bRetVal = CreateProcess(lpAppName, lpCmdLine, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi);

	// To get the remote image base address I need to instruct the Windows loader to load the 
	// Target image file in memory, and to compile the PEB
	lpRemBuff = VirtualAllocEx(pi.hProcess, NULL, 4096, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (lpRemBuff) 
		bRetVal = WriteProcessMemory(pi.hProcess, lpRemBuff, (LPCVOID)remote_opcodes, sizeof(remote_opcodes), (SIZE_T*)&ulBytesIo);
	else
		bRetVal = FALSE;

	if (bRetVal) 
		hRemoteThr = CreateRemoteThread(pi.hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)lpRemBuff, NULL, 0, &dwThrId);

	if (hRemoteThr) {
		WaitForSingleObject(hRemoteThr, INFINITE);
		if (lpRemBuff) VirtualFreeEx(pi.hProcess, lpRemBuff, 0, MEM_RELEASE);

		// Get rid of it:
		CloseHandle(hRemoteThr);
		if (pOutProcInfo) *pOutProcInfo = pi;
		return TRUE;
	} else {
		TerminateProcess(pi.hProcess, -1);
		CloseHandle(pi.hThread);
		CloseHandle(pi.hProcess);
		return FALSE;
	}
}

// The PMI interrupt Thread 
DWORD WINAPI PmiThreadProc(LPVOID lpParameter) {
	LPTSTR lpEventName = L"Global\\" INTEL_PT_PMI_EVENT_NAME;
	HANDLE hKernelEvt = NULL;
	DWORD dwLastErr = 0;										// Last Win32 error
	DWORD dwBytesIo = 0,										// Number of I/O bytes
		dwEvtNum = 0;											// The event number that has satisfied the wait
	BOOLEAN bRetVal = FALSE;
	DWORD dwCpuNumber = (DWORD)lpParameter;
	HANDLE hWaitEvts[2] = { 0 };
	PT_PMI_USER_CALLBACK pmiDesc = { 0 };
	PT_CPU_BUFFER_DESC * pCurCpuBuff = &g_appData.pCpuDescArray[dwCpuNumber];

	hKernelEvt = OpenEvent(SYNCHRONIZE, FALSE, lpEventName);
	dwLastErr = GetLastError();

	if (!hKernelEvt) return -1;
	hWaitEvts[0] = hKernelEvt;
	hWaitEvts[1] = g_appData.hExitEvt;

	while (TRUE) {
		// Perform an ALERTABLE wait
		dwEvtNum = WaitForMultipleObjectsEx(2, hWaitEvts, FALSE, INFINITE, TRUE);

		// WAIT_IO_COMPLETION means APC has been queued
		if (dwEvtNum - WAIT_OBJECT_0 == 1) {
			// We are exiting, pause the Tracing
			DeviceIoControl(g_appData.hPtDev, IOCTL_PTDRV_PAUSE_TRACE, (LPVOID)&g_appData.kActiveCpuAffinity, sizeof(KAFFINITY), NULL, 0, &dwBytesIo, NULL);
			break;
		}
		// Continue to wait on the PMI Event, and raise the appropriate Callbacks
	}
	// Deregister my callback
	pmiDesc.dwThrId = GetCurrentThreadId();
	pmiDesc.lpAddress = PmiCallback;
	DeviceIoControl(g_appData.hPtDev, IOCTL_PTDRV_FREE_PMI_ROUTINE, (LPVOID)&pmiDesc, sizeof(PT_PMI_USER_CALLBACK), NULL, 0, &dwBytesIo, NULL);

	// Sleep a bit
	Sleep(500);

	// and write the rest of the log
	if (pCurCpuBuff->lpPtBuff && pCurCpuBuff->hBinFile) {
		BYTE zeroArray[16] = { 0 };
		DWORD dwEndOffset = 0;

		for (DWORD i = 0; i < pCurCpuBuff->dwBuffSize - sizeof(zeroArray); i += sizeof(zeroArray)) 
			if (RtlCompareMemory(pCurCpuBuff->lpPtBuff + i, zeroArray, sizeof(zeroArray)) == sizeof(zeroArray)) {
				dwEndOffset = i; break;
			}
		
		if (!dwEndOffset) dwEndOffset = g_appData.pCpuDescArray[dwCpuNumber].dwBuffSize;
		bRetVal = WriteFile(pCurCpuBuff->hBinFile, pCurCpuBuff->lpPtBuff, dwEndOffset, &dwBytesIo, NULL);
		if (pCurCpuBuff->hTextFile) {
			// Dump the text trace file immediately
			bRetVal = pt_dumpW((LPBYTE)pCurCpuBuff->lpPtBuff, (DWORD)dwEndOffset, pCurCpuBuff->hTextFile, pCurCpuBuff->qwDelta, g_appData.bTraceOnlyKernel);
			pCurCpuBuff->qwDelta += (QWORD)dwEndOffset;
		}
	}

	return 0;
}

// The PMI callback
VOID PmiCallback(DWORD dwCpuId, PVOID lpBuffer, QWORD qwBufferSize) {
	HANDLE hTraceBinFile = NULL;					// The trace BINARY file
	HANDLE hTraceTextFile = NULL;					// The trace Text file
	DWORD dwDescNum = 0;							// The descriptor number
	DWORD dwBytesIo = 0;							// Number of I/O bytes
	BOOL bRetVal = FALSE;							// Returned Win32 value
	DWORD dwLastErr = 0;							// Last Win32 error
	KAFFINITY thisCpuAffinity = (1i64 << dwCpuId);

	// Check if there is the main thread, open if so
	if (g_appData.dwMainThrId && !g_appData.hMainThr)
		g_appData.hMainThr = OpenThread(SYNCHRONIZE | THREAD_SUSPEND_RESUME, FALSE, g_appData.dwMainThrId);

	// Convert the CPU ID in descriptor number
	for (int i = 0; i < sizeof(KAFFINITY) * 8; i++) {
		if ((1i64 << i) & g_appData.kActiveCpuAffinity) {
			if (i == dwCpuId) break;
			dwDescNum++;
		}
	}
	// Grab the parameters
	hTraceBinFile = g_appData.pCpuDescArray[dwDescNum].hBinFile;
	hTraceTextFile = g_appData.pCpuDescArray[dwDescNum].hTextFile;
	QWORD & qwDelta = g_appData.pCpuDescArray[dwDescNum].qwDelta;

	// Suspend the main thread if any
	if (g_appData.hMainThr) SuspendThread(g_appData.hMainThr);

	if (hTraceBinFile) {
		bRetVal = WriteFile(hTraceBinFile, lpBuffer, (DWORD)qwBufferSize, &dwBytesIo, NULL);
		
		if (!bRetVal) {
			cl_wprintf(RED, L"Warning! ");
			wprintf(L"Unable to write in the log file. Results could be erroneous.\r\n");
		}
	}

	if (hTraceTextFile) {
		// Dump the text trace file immediately
		bRetVal = pt_dumpW((LPBYTE)lpBuffer, (DWORD)qwBufferSize, hTraceTextFile, qwDelta, g_appData.bTraceOnlyKernel);
		qwDelta += (QWORD)qwBufferSize;
	}
	RtlZeroMemory((LPBYTE)lpBuffer, (DWORD)qwBufferSize);

	// Resume the tracing and the execution of the target process
	bRetVal = DeviceIoControl(g_appData.hPtDev, IOCTL_PTDRV_RESUME_TRACE, (LPVOID)&thisCpuAffinity, sizeof(KAFFINITY), NULL, 0, &dwBytesIo, NULL);
	
	if (!g_appData.currentTrace.bTraceKernel)
		ZwResumeProcess(g_appData.hTargetProc);
	if (g_appData.hMainThr) ResumeThread(g_appData.hMainThr);
}

// Try some Kernel tracing activity :-)
bool DoKernelTrace(HANDLE hPtDev, PT_USER_REQ ptUserReq, LPTSTR lpDrvName) {
	BOOL bRetVal = FALSE;
	HANDLE hTestDev = NULL;
	DWORD dwLastErr = 0, dwBytesIo = 0;
	KERNEL_MODULE kernelMod = { 0 };
	LPVOID lpPtBuff = NULL;
	TCHAR answer[0x20] = { 0 };
	LPVOID * lpBuffArray = NULL;
	DWORD dwNumOfCpus = g_appData.dwNumOfActiveCpus;
	
	// Specific AaLl86 Driver data:
	const LPTSTR DosDevName = L"\\\\.\\IntelPtTest";
	LPTSTR lpKernelModName = L"ci.dll";
	bool bAaLl86Test = (_wcsicmp(lpDrvName, L"AaLl86TestDriver.sys") == 0);

	#ifdef _DEBUG
	if (bAaLl86Test && ptUserReq.dwTraceSize == 0) {
		// Here theoretically I have to open the target driver module and insert the special BAD_OPCODE 
		// BUT I am too lazy.
		wprintf(L"Testing Kernel-mode Tracing from a Kernel module... ");
		// Send the special IOCTLs
		dwBytesIo = (DWORD)((wcslen(lpDrvName) + 1) * sizeof(WCHAR));
		bRetVal = DeviceIoControl(hPtDev, IOCTL_PTDR_DO_KERNELDRV_TEST, (LPVOID)lpDrvName, dwBytesIo, NULL, 0, &dwBytesIo, NULL);
		dwLastErr = GetLastError();
		if (bRetVal) {
			cl_wprintf(GREEN, L"OK\r\n");
			wprintf(L"The dump file has been saved in the \"C:\" volume.\r\n");
			return true;
		}
		else {
			cl_wprintf(RED, L"Error!\r\n");
			return false;
		}
	}
	#endif

	if (bAaLl86Test) {
		// Open the target kernel device object
		wprintf(L"Simple Kernel Driver Test - Opening the device... ");
		hTestDev = CreateFile(DosDevName, FILE_ALL_ACCESS, 0, NULL, OPEN_EXISTING, 0, NULL);
		dwLastErr = GetLastError();
		if (hTestDev != INVALID_HANDLE_VALUE)
			cl_wprintf(GREEN, L"OK\r\n");
		else {
			cl_wprintf(RED, L"Error!\r\n");
			return false;
		}
	}

	// Allocate the buffer array
	lpBuffArray = new LPVOID[dwNumOfCpus];
	RtlZeroMemory(lpBuffArray, dwNumOfCpus * sizeof(LPVOID));

	// Start the device Tracing
	wprintf(L"Starting the Kernel-mode Tracing... ");
	bRetVal = DeviceIoControl(hPtDev, IOCTL_PTDRV_START_TRACE, (LPVOID)&ptUserReq, sizeof(PT_USER_REQ), 
		lpBuffArray, sizeof(LPVOID) * dwNumOfCpus, &dwBytesIo, NULL);
	dwLastErr = GetLastError();

	if (bRetVal) {
		cl_wprintf(GREEN, L"OK\r\n");
		g_appData.currentTrace = ptUserReq;

		// Copy the returned Buffer array
		for (int i = 0; i < (int)dwNumOfCpus; i++) {
			g_appData.pCpuDescArray[i].lpPtBuff = (LPBYTE)lpBuffArray[i];
			g_appData.pCpuDescArray[i].dwBuffSize = ptUserReq.dwTraceSize;
		}
	}
	else {
		cl_wprintf(RED, L"Error!\r\n");
		return false;
	}
	Sleep(100);

	if (bAaLl86Test) {
		wprintf(L"Doing some test malicious activity (this could crash your system)... ");
		// Test the Search Module IOCTL
		bRetVal = DeviceIoControl(hTestDev, IOCTL_PTBUG_SEARCHKERNELMODULE, (LPVOID)lpKernelModName, (DWORD)(wcslen(lpKernelModName) + 1) * sizeof(WCHAR), 
			(LPVOID)&kernelMod,	sizeof(KERNEL_MODULE), &dwBytesIo, NULL);
		dwLastErr = GetLastError();

		if (bRetVal) {
			// READ some memory from the CI.DLL module
			LPBYTE lpBuff = new BYTE[0x1000];
			bRetVal = ReadFile(hTestDev, (LPVOID)lpBuff, 0x1000, &dwBytesIo, NULL);

			if (bRetVal && lpBuff[0] == 'M' && lpBuff[1] == 'Z') {
				DWORD dwValue = 0x4000C;
				DWORD dwOffset = 0x00194b4;				// CI!g_CiDeveloperMode symbol

				bRetVal = SetFilePointer(hTestDev, dwOffset, NULL, FILE_BEGIN);
				bRetVal = WriteFile(hTestDev, (LPCVOID)&dwValue, sizeof(DWORD), &dwBytesIo, NULL);
			}
		}
		if (bRetVal)
			cl_wprintf(GREEN, L"OK\r\n");
		else
			cl_wprintf(RED, L"Error!\r\n");
	}
	else {
		wprintf(L"\r\n\r\nPress any key when you would like to stop the tracing...\r\n");
		rewind(stdin);
		getwchar();
	}

	CloseHandle(hTestDev);	
	return (bRetVal != FALSE);
}

```

`PtControlApp/IntelPtControlApp.h`:

```h
/**********************************************************************
 *  Windows Intel Processor Trace (PT) Driver
 *  Filename: IntelPtControlApp.h
 *	A simple Intel PT driver control application header file
 *  Last revision: 12/01/2016
 *
 *  Copyright© 2016 Andrea Allievi, Richard Johnson
 *  Microsoft Ltd & TALOS Research and Intelligence Group
 *  All right reserved
 **********************************************************************/
#pragma once
#include "IntelPt.h"
#include "..\WindowsPtDriver\DriverIo.h"

#define DEFAULT_TRACE_BUFF_SIZE 64 * 1024			// Default TRACE buffer size
#define ROUND_TO_PAGES(Size)  (((ULONG_PTR)(Size) + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1))
#define PAGE_SIZE 0x1000

// The PT buffer data structure
struct PT_CPU_BUFFER_DESC {
	HANDLE hBinFile;						// The binary file handle
	HANDLE hTextFile;						// The human readable file handle
	LPBYTE lpPtBuff;						// The PT buffer pointer
	DWORD dwBuffSize;						// The PT buffer size in BYTEs
	QWORD qwDelta;							// The delta value used in translating each packet
	HANDLE hPmiThread;						// The handle of the current PMI thread
	DWORD dwPmiThrId;						// The PMI Thread ID
};

// The Application global data
struct GLOBAL_DATA {
	DWORD dwTraceBuffSize;						// The size of the trace buffer
	BOOLEAN bTraceByIp;							// TRUE if I have to trace by IP
	BOOLEAN bTraceOnlyKernel;					// TRUE if I would like to trace only kernel
	HANDLE hPtDev;								// The handle to the Intel PT device
	HANDLE hTargetProc;							// The traced process handle
	HANDLE hExitEvt;							// The handle to the exit event
	DWORD dwMainThrId;							// The main application thread ID
	HANDLE hMainThr;							// The handle of the main application thread
	PT_USER_REQ currentTrace;
	PT_CPU_BUFFER_DESC * pCpuDescArray;			// The PT CPU buffer descriptor array ptr
	DWORD dwNumOfActiveCpus;					// The number of active CPUs
	KAFFINITY kActiveCpuAffinity;				// The current active CPUs affinity mask

	// Struct constructor
	GLOBAL_DATA() { dwTraceBuffSize = DEFAULT_TRACE_BUFF_SIZE; bTraceByIp = TRUE; }
};
// The only unique GLOBAL_DATA structure
extern GLOBAL_DATA g_appData;		// (defined in EntryPoint.cpp)

// Application Entry Point
int wmain(int argc, LPTSTR argv[]);

// Entry point without command line arguments
int NoCmdlineStartup();

// Show command line usage
void ShowCommandLineUsage();

// Parse command line
bool ParseCommandLine(int argc, LPTSTR argv[]);

// Check the support of Intel Processor Tarce on this CPU
BOOL CheckIntelPtSupport(INTEL_PT_CAPABILITIES * lpPtCap);

// The PMI interrupt Thread 
DWORD WINAPI PmiThreadProc(LPVOID lpParameter);
// The PMI callback
VOID PmiCallback(DWORD dwCpuId, PVOID lpBuffer, QWORD qwBufferSize);

// Spawn a suspended process and oblige the loader to load the remote image in memory
BOOL SpawnSuspendedProcess(LPTSTR lpAppName, LPTSTR lpCmdLine, PROCESS_INFORMATION * outProcInfo);

// Parse the command line arguments
bool ParseCommandLine();

// Try some Kernel tracing activity :-)
bool DoKernelTrace(HANDLE hPtDev, PT_USER_REQ ptUserReq, LPTSTR lpDrvName);

// Initialize and open the per-CPU files and data structures
bool InitPerCpuData(ULONG_PTR kCpuAffinity, LPTSTR lpBasePath);

// Close and flush the per-CPU files and data structures
bool FreePerCpuData(BOOL bDeleteFiles = FALSE);

// Write the human readable dump file header
bool WriteCpuTextDumpsHeader(LPTSTR lpImgName, ULONG_PTR qwBase, DWORD dwSize, BOOLEAN bKernelTrace = FALSE);



// AaLl86 Test driver stuff
typedef struct _KERNEL_MODULE {
	LPVOID lpStartAddr;
	DWORD dwSize;
	TCHAR modName[100];
}KERNEL_MODULE, *PKERNEL_MODULE;

// Search a particular kernel module in memory and return the associated structure
#define IOCTL_PTBUG_SEARCHKERNELMODULE CTL_CODE(FILE_DEVICE_UNKNOWN, 0xB01, METHOD_BUFFERED, FILE_READ_DATA)
// Kernel Tracing Test IOCTL
#define IOCTL_PTDR_DO_KERNELDRV_TEST CTL_CODE(FILE_DEVICE_UNKNOWN, 0xA0C, METHOD_BUFFERED, FILE_EXECUTE)

```

`PtControlApp/Log.cpp`:

```cpp
/********************************************************************
*
*  Author            : Andrea Allievi (andreaa)
*  Date              : 06/23/2017
*  Filename			 : Log.cpp
*  Description       : My generic Log class used to write data into a .LOG
*					   file very easily from C++
*					   The LOGTITLE symbol is defined in "stdafx.h" precompiled header
*********************************************************************/
#include "stdafx.h"
#include "log.h"
//#include <crtdbg.h>
#pragma comment (lib, "version.lib")
CLog staticLog;

// Static function to write data to an uninitialized log
// Default behaviour: if Application Communication instance is not NULL, use that, else use Dbg Output
void WriteToLog(LPTSTR dbgStr, LPVOID arg1, LPVOID arg2, LPVOID arg3, LPVOID arg4) {
	//CLog log;
	staticLog.WriteLine(dbgStr, arg1, arg2, arg3, arg4);
}

// Default Class Constructor
CLog::CLog():
	g_hLogFile(NULL),
	g_strLogTitle(NULL),
	g_bIsAutoDeleteLog(true),
	g_bAtLeastOneWrite(false),
	g_bImCopy(false),
	g_strLogFile(NULL)
{
	g_strLogFile = new TCHAR[MAX_PATH];
	RtlZeroMemory(g_strLogFile, MAX_PATH * sizeof(TCHAR));
}

// Specialized Class Constructor
CLog::CLog(LPTSTR logFile, LPTSTR logTitle) {
	g_bIsAutoDeleteLog = true;
	g_bAtLeastOneWrite = false;
	g_bImCopy = false;
	g_hLogFile = NULL;
	g_strLogFile = new TCHAR[MAX_PATH];
	g_strLogTitle = NULL;
	RtlZeroMemory(g_strLogFile, MAX_PATH * sizeof(TCHAR));
	if (logTitle) this->SetLogTitle(logTitle);
	if (!this->Open(logFile))
		DbgBreak();
}

// Copy constructor
CLog::CLog(CLog &log) {
	g_bAtLeastOneWrite = log.g_bAtLeastOneWrite;
	g_bIsAutoDeleteLog = log.g_bIsAutoDeleteLog;
	g_hLogFile = log.g_hLogFile;
	if (log.g_hLogFile) {
		HANDLE hProc = GetCurrentProcess();
		DuplicateHandle(hProc, log.g_hLogFile, hProc, &g_hLogFile, 0, FALSE, DUPLICATE_SAME_ACCESS);
	}
	if (log.g_strLogFile) {
		g_strLogFile = new TCHAR[MAX_PATH];
		RtlCopyMemory(g_strLogFile, log.g_strLogFile, MAX_PATH * sizeof(TCHAR));
	}
	if (log.g_strLogTitle) {
		int titleLen = (int)wcslen(log.g_strLogTitle);
		g_strLogTitle = new TCHAR[titleLen+1];
		RtlZeroMemory(g_strLogTitle, (titleLen+1) * sizeof(TCHAR));
		RtlCopyMemory(g_strLogTitle, log.g_strLogTitle, (titleLen+1) * sizeof(TCHAR));
	}
	g_bImCopy = true;
	log.g_bAtLeastOneWrite = true;
}

// Destructor
CLog::~CLog() {
	this->Close();
	if (g_strLogTitle) delete[] g_strLogTitle;
	if (g_strLogFile) delete[] g_strLogFile;
}

// Set log Title
void CLog::SetLogTitle(LPTSTR strTitle) {
	if (!strTitle) return;
	int titleLen = (int)wcslen(strTitle);

	if (this->g_strLogTitle) {
		delete g_strLogTitle;
		g_strLogTitle = NULL;
	}
	g_strLogTitle = new TCHAR[titleLen+1];
	wcscpy_s(g_strLogTitle, titleLen+1, strTitle);
}

// Create or open a log file
bool CLog::Open(LPTSTR fileName, bool overwrite) {
	BOOL retVal = FALSE;
	HANDLE hFile = NULL;
	SYSTEMTIME time = {0};
	CHAR logStr[255] = {0};
	DWORD bytesToWrite = 0;
	DWORD bytesWritten = 0;
	DWORD lastErr = 0;

	if (this->g_hLogFile != NULL) {
		// Log File already opened, close it
		if (wcscmp(fileName, this->g_strLogFile) != 0) this->Close();
		else
			// File already opened
			return true;
	}

	hFile = CreateFile(fileName, GENERIC_WRITE, FILE_SHARE_READ, NULL, (overwrite ? CREATE_ALWAYS : OPEN_ALWAYS),
		FILE_ATTRIBUTE_NORMAL, NULL);
	lastErr = GetLastError();
	if (hFile == INVALID_HANDLE_VALUE)
		return false;

	if (lastErr == ERROR_ALREADY_EXISTS && overwrite == false) {
		retVal = SetFilePointer(hFile, 0, 0, FILE_END);
		if (retVal > 0) 
			// Don't autodelete log that already contains data
			g_bIsAutoDeleteLog = false;
	}
	
	// Mi memorizzo il nome del file
	if (!g_strLogFile)
		g_strLogFile = new TCHAR[MAX_PATH];
	wcscpy_s(g_strLogFile, MAX_PATH, fileName);

	GetLocalTime(&time);
	LPTSTR logTitle = this->g_strLogTitle;
	if (!logTitle) {
		// 20/02/2012 If there isn't a log title use CVersionInfo
		#ifdef LOGTITLE
			logTitle = LOGTITLE;
		#else
			LPTSTR prodName = NULL, companyName = NULL, verStr = NULL;
			logTitle = new TCHAR[0x100];
			CVersionInfo fileInfo;
			prodName = fileInfo.GetProductName();
			companyName = fileInfo.GetCompanyName();
			verStr = fileInfo.GetFileVersionString();
			wsprintf(logTitle, L"%s %s %s Log File", companyName, prodName, verStr);
			this->g_strLogTitle = logTitle;
		#endif
	}
	bytesToWrite = sprintf_s(logStr, 255, "%S\r\nExecution time: %02i/%02i/%02i - %02i:%02i\r\n", logTitle, 
		time.wDay, time.wMonth, time.wYear, time.wHour, time.wMinute) + 1;
	retVal = WriteFile(hFile, logStr, bytesToWrite - 1, &bytesWritten, NULL);
	this->g_bAtLeastOneWrite = false;

	if (retVal) {
		this->g_hLogFile = hFile;
		return true;
	} else {
		RtlZeroMemory(g_strLogFile, MAX_PATH * sizeof(TCHAR));
		return false;
	}
}

// Close this log file
void CLog::Close(bool WriteEnd) {
	if (!this->g_hLogFile || g_hLogFile == INVALID_HANDLE_VALUE) 
		return;

	bool deleteMe = false;
	if (!g_bAtLeastOneWrite && g_bIsAutoDeleteLog && !g_bImCopy)
		// Auto delete this log if there aren't any write
		deleteMe = true;

	if (WriteEnd && !g_bImCopy) WriteLine(L"Execution Ended!\r\n\r\n");
	CloseHandle(g_hLogFile); g_hLogFile = NULL;
	if (deleteMe) DeleteFile(g_strLogFile);

	if (g_strLogFile) 
		RtlZeroMemory(g_strLogFile, MAX_PATH * sizeof(TCHAR));
	
}


// Write a log line (NO parameters)
void CLog::WriteLine(LPTSTR dbgStr) {
	if (g_hLogFile) WriteCurTime();
	Write(dbgStr);
	Write(L"\r\n");
}

// Write a log line (4 parameters max)
void CLog::WriteLine(LPTSTR dbgStr, LPVOID arg1, LPVOID arg2, LPVOID arg3, LPVOID arg4) {
	if (g_hLogFile) WriteCurTime();
	Write(dbgStr, arg1, arg2, arg3, arg4);
	Write(L"\r\n");
}

// Write current time to log
void CLog::WriteCurTime() {
	TCHAR timeStr[20] = {0};
	SYSTEMTIME curTime = {0};
	GetLocalTime(&curTime);
	swprintf_s(timeStr, 20, L"%02i:%02i:%02i - ", curTime.wHour, curTime.wMinute, curTime.wSecond);
	Write(timeStr);
}

// Write a Unicode log string (NO parameters)
void CLog::Write(LPWSTR dbgStr) {
	DWORD bytesToWrite = 0;
	DWORD bytesWritten = 0;
	CHAR * logStr = NULL;			// String to write in file

	if (!g_hLogFile || g_hLogFile == INVALID_HANDLE_VALUE) {		// If I don't have opened a log file
		OutputDebugString(dbgStr);									// write to debug output
	} else {
		bytesToWrite = (DWORD)wcslen(dbgStr) + 1;
		logStr = new CHAR[bytesToWrite];
		sprintf_s(logStr, bytesToWrite, "%S", dbgStr);
		WriteFile(g_hLogFile, logStr, bytesToWrite - 1, &bytesWritten, NULL);			//BOOL retVal = 
		delete[] logStr;
	}
	g_bAtLeastOneWrite = true;
}

// Write a log string (4 parameters max)
void CLog::Write(LPTSTR dbgStr, LPVOID arg1, LPVOID arg2, LPVOID arg3, LPVOID arg4) {
	LPTSTR resStr = NULL;			// Formatted string

	// Format unicode original string
	resStr = new TCHAR[2048];
	swprintf_s(resStr, 2048, dbgStr, arg1, arg2, arg3, arg4);
	Write(resStr);
	if (resStr != dbgStr) delete[] resStr;
}

// Write an ANSI log string (NO parameters)
void CLog::Write(LPSTR dbgStr) {
	DWORD bytesToWrite = 0;
	DWORD bytesWritten = 0;

	if (!this->g_hLogFile || g_hLogFile == INVALID_HANDLE_VALUE) {		// If I don't have opened a log file
		OutputDebugStringA(dbgStr);										// write to debug output
	} else {
		bytesToWrite = (DWORD)strlen(dbgStr);
		WriteFile(g_hLogFile, dbgStr, bytesToWrite, &bytesWritten, NULL);
	}
	g_bAtLeastOneWrite = true;
}

// Write an ANSI log string (4 parameters max)
void CLog::Write(LPSTR dbgStr, LPVOID arg1, LPVOID arg2, LPVOID arg3, LPVOID arg4) {
	LPSTR resStr = NULL;			// Formatted string

	// Format ansi original string
	resStr = new CHAR[2048];
	sprintf_s(resStr, 2048, dbgStr, arg1, arg2, arg3, arg4);
	Write(resStr);
	delete[] resStr;
}


// Flush file to perform actual disk write
void CLog::Flush() {
	if (!this->g_hLogFile) return;
	FlushFileBuffers(g_hLogFile);
}

#pragma region Version Information Class functions
// Default constructor
CVersionInfo::CVersionInfo(): 
	g_bVerInfoBuff(NULL),
	iLangTableLen(0),
	pLangTable(NULL),
	g_LangStr(NULL),
	g_fVerStr(NULL)
	{
		GetModuleVersionInfo();
	}

// Constructor that accept a module name 
CVersionInfo::CVersionInfo(LPTSTR modName) {
	g_LangStr = NULL;
	g_fVerStr = NULL;
	GetModuleVersionInfo(modName);
}

// Constructor that accept a module handle
CVersionInfo::CVersionInfo(HMODULE hModule) {
	g_LangStr = NULL;
	g_fVerStr = NULL;
	GetModuleVersionInfo(hModule);
}

// Destructor
CVersionInfo::~CVersionInfo() {
	if (g_bVerInfoBuff) delete[] g_bVerInfoBuff;
	g_bVerInfoBuff = NULL;
	if (g_LangStr) delete[] g_LangStr;
	if (g_fVerStr) delete[] g_fVerStr;
}

// Get fixed Version Information
VS_FIXEDFILEINFO CVersionInfo::GetFixedVersion() {
	VS_FIXEDFILEINFO * pVerInfo = NULL;
	UINT verSize = 0;
	BOOL retVal = FALSE;
	if (!g_bVerInfoBuff) return VS_FIXEDFILEINFO();

	retVal = VerQueryValue((LPCVOID)g_bVerInfoBuff, L"\\", (LPVOID*)&pVerInfo, (PUINT)&verSize);
	if (retVal) return *pVerInfo;
	else return VS_FIXEDFILEINFO();
}

LPTSTR CVersionInfo::GetFileVersionString() {
	VS_FIXEDFILEINFO fixedVer = {0};
	if (!g_bVerInfoBuff) return NULL;

	fixedVer = GetFixedVersion();
	if (!g_fVerStr) g_fVerStr = new TCHAR[0x30];
	wsprintf(g_fVerStr, L"%i.%i", 
		(WORD)(fixedVer.dwFileVersionMS >> 16),
		(WORD)(fixedVer.dwFileVersionMS));
	return g_fVerStr;
}

// Helper function that Get a Language Code Page Version Value
LPTSTR CVersionInfo::VerQueryLangCpValue(LPTSTR value) {
	if (!g_bVerInfoBuff || !g_LangStr) return NULL;
	LPTSTR verValue = NULL;
	LPTSTR verLangStr = new TCHAR[0x40];
	UINT dwChars = 0;			
	BOOL retVal = FALSE;

	wcscpy_s(verLangStr, 0x40, g_LangStr);
	wcscat_s(verLangStr, 0x40, value);
	
	// Retrieve file description for language and code page "i". 
	retVal = VerQueryValue((LPCVOID)g_bVerInfoBuff, verLangStr, (LPVOID*)&verValue, &dwChars); 
	delete[] verLangStr;

	if (retVal) 
		return verValue;
	else
		return NULL;
}

LPTSTR CVersionInfo::GetProductName() {
	return VerQueryLangCpValue(L"ProductName");
}

LPTSTR CVersionInfo::GetCompanyName() {
	return VerQueryLangCpValue(L"CompanyName");
}

// Helper function that receive versione information of a specific module (NULL = this executable)
bool CVersionInfo::GetModuleVersionInfo(HMODULE hMod) {
	LPTSTR modFileName = NULL;				// Filename of module used to retrieve version information
	BOOL retVal = FALSE;

	modFileName = new TCHAR[MAX_PATH];
	retVal = GetModuleFileName(hMod, modFileName, MAX_PATH);
	if (!retVal) {
		delete modFileName;
		::WriteToLog(L"CLog::GetModuleVersion - Error while getting module filename...");
		return false;
	}
	retVal = GetModuleVersionInfo(modFileName);
	delete modFileName;
	return (retVal == TRUE);
}

bool CVersionInfo::GetModuleVersionInfo(LPTSTR modName) {
	DWORD dummy = 0;						// Dummy DWORD variable for GetFileVersionInfoSize
	DWORD verSize = 0;						// Version info size
	LPBYTE buff = NULL;						// Buffer
	BOOL retVal = FALSE;
	LPTSTR langStr = NULL;					// Lang and code page Version string
	if (!modName) return false;

	verSize = GetFileVersionInfoSize(modName, &dummy);
	if (!verSize) 
		return false;

	buff = new BYTE[verSize];
	retVal = GetFileVersionInfo(modName, dummy, verSize, (LPVOID)buff);

	if (retVal) {
		iLangTableLen = 0;
		pLangTable = NULL;
		if (g_LangStr) {delete g_LangStr; g_LangStr = NULL; }

		// Read the list of languages and code pages.
		retVal = VerQueryValue(buff, TEXT("\\VarFileInfo\\Translation"), (LPVOID*)&pLangTable, &iLangTableLen);

		langStr = new TCHAR[0x40];
		// Read the file description for each language and code page.
		for(int i = 0; i < (int)(iLangTableLen / sizeof(struct LANGANDCODEPAGE)); i++) 
			wsprintf(langStr, TEXT("\\StringFileInfo\\%04x%04x\\"), pLangTable[i].wLanguage, pLangTable[i].wCodePage);
		g_LangStr = langStr;
	}

	if (retVal) 
		this->g_bVerInfoBuff = buff;
	else 
		if (buff) delete buff;

	return (retVal == TRUE);
}
#pragma endregion

// ....
// One Log to rule them all!
// ....

```

`PtControlApp/Log.h`:

```h
/********************************************************************
*
*  Author            : Andrea Allievi (andreaa)
*  Date              : 06/23/2017
*  Filename			 : Log.h
*  Description       : My generic Log class used to write data into a .LOG
*					   file very easily from C++
*					   The LOGTITLE symbol is defined in "stdafx.h" precompiled header
*********************************************************************/

#pragma once
#include <windows.h>

class CLog {
public:
	// Default Constructor
	CLog();

	// Specialized Constructor
	CLog(LPTSTR logFile, LPTSTR logTitle = NULL);

	// Destructor
	~CLog();

	// Copy constructor
	CLog(CLog &log);

	// Set log Title
	void SetLogTitle(LPTSTR strTitle);

	// Create or open a log file
	bool Open(LPTSTR logFile, bool overwrite = false);

	// Get log file name
	const LPTSTR GetLogFileName() { 
		return this->g_strLogFile; }

	const bool IsOpened() {
		return (g_hLogFile && g_hLogFile != INVALID_HANDLE_VALUE);
	}

	// Close this log
	void Close(bool WriteEnd = true);

	// Write a log string (4 parameters max)
	void Write(LPTSTR dbgStr, LPVOID arg1, LPVOID arg2 = NULL, LPVOID arg3 = NULL, LPVOID arg4 = NULL);

	// Write an ANSI log string (4 parameters max)
	void Write(LPSTR dbgStr, LPVOID arg1, LPVOID arg2 = NULL, LPVOID arg3 = NULL, LPVOID arg4 = NULL);

	// Write an ANSI log string (NO parameters)
	void Write(LPSTR dbgStr);

	// Write a Unicode log string (NO parameters)
	void Write(LPWSTR dbgStr);

	// Write a log line (4 parameters max)
	void WriteLine(LPTSTR dbgStr, LPVOID arg1, LPVOID arg2 = NULL, LPVOID arg3 = NULL, LPVOID arg4 = NULL);

	// Write a log line (NO parameters)
	void WriteLine(LPTSTR dbgStr);

	// Flush file to perform actual disk write
	void Flush();

	// Get the current log file handle
	HANDLE GetCurrentLogHandle()			// Modification made on 08/10/2016 to correctly deal with the AntiRansom driver
	{ return g_hLogFile; }

private:
	// Write current time to log
	void WriteCurTime();

private:
	LPTSTR g_strLogFile;			// This instance log file string
	HANDLE g_hLogFile;				// Log file handle of this CLog
	LPTSTR g_strLogTitle;			// Log title (see LOGTITLE definition)
	bool g_bIsAutoDeleteLog;		// Set if this log has to delete itself if there are no writing
	bool g_bAtLeastOneWrite;		// Set if user called at least one Write function
	bool g_bImCopy;					// True if this instance is a copy of another ones
};

#pragma region Version Information Class
class CVersionInfo {
public:
	CVersionInfo();
	CVersionInfo(LPTSTR modName);
	CVersionInfo(HMODULE hModule);
	~CVersionInfo();

	VS_FIXEDFILEINFO GetFixedVersion();
	LPTSTR GetFileVersionString();
	LPTSTR GetProductName();
	LPTSTR GetCompanyName();

private:
	// Helper functions that receive versione information of a specific module (NULL = this executable)
	bool GetModuleVersionInfo(HMODULE hMod = NULL);
	bool GetModuleVersionInfo(LPTSTR modName);

	// Helper function that Get a Language Code Page Version Value
	LPTSTR VerQueryLangCpValue(LPTSTR value); 

	// For lang and code page data
	struct LANGANDCODEPAGE {
		WORD wLanguage;
		WORD wCodePage;
	} * pLangTable;
	UINT iLangTableLen;

	// Lang string 
	LPTSTR g_LangStr;

	// FileVersion String
	LPTSTR g_fVerStr;

	// This module buffer
	LPBYTE g_bVerInfoBuff;

};
#pragma endregion

// Static function to write data to an uninitialized log
void WriteToLog(LPTSTR dbgStr, LPVOID arg1 = NULL, LPVOID arg2 = NULL, LPVOID arg3 = NULL, LPVOID arg4 = NULL);

```

`PtControlApp/PtControlApp.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 0,5,0,1
 PRODUCTVERSION 0,5,0,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x1L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "MSTIC, Cisco Talos"
            VALUE "FileDescription", "Intel PT Driver control Application"
            VALUE "FileVersion", "0.5.0.1"
            VALUE "InternalName", "PtControlApp.exe"
            VALUE "LegalCopyright", "Copyright (C) 2016 Andrea Allievi, Richard Johnson"
            VALUE "OriginalFilename", "PtControlApp.exe"
            VALUE "ProductName", "Windows Intel PT Driver"
            VALUE "ProductVersion", "0.5.0.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_MAINICO             ICON                    "res\\cpu.ico"

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`PtControlApp/PtControlApp.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 14
VisualStudioVersion = 14.0.24720.0
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "PtControlApp", "PtControlApp.vcxproj", "{AEEB84F9-A268-4642-8CCC-CE05D80ACD74}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{AEEB84F9-A268-4642-8CCC-CE05D80ACD74}.Debug|x64.ActiveCfg = Debug|x64
		{AEEB84F9-A268-4642-8CCC-CE05D80ACD74}.Debug|x64.Build.0 = Debug|x64
		{AEEB84F9-A268-4642-8CCC-CE05D80ACD74}.Debug|x86.ActiveCfg = Debug|x64
		{AEEB84F9-A268-4642-8CCC-CE05D80ACD74}.Release|x64.ActiveCfg = Release|x64
		{AEEB84F9-A268-4642-8CCC-CE05D80ACD74}.Release|x64.Build.0 = Release|x64
		{AEEB84F9-A268-4642-8CCC-CE05D80ACD74}.Release|x86.ActiveCfg = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`PtControlApp/PtControlApp.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{AEEB84F9-A268-4642-8CCC-CE05D80ACD74}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>TestIntelPt</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.14393.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <PostBuildEventUseInBuild>false</PostBuildEventUseInBuild>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <PostBuildEventUseInBuild>false</PostBuildEventUseInBuild>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
    <PostBuildEvent>
      <Command>
      </Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
    <PostBuildEvent>
      <Command>@echo off
set REMOTE_IP=TALOS-SGX
set REMOTE_PATH=\dati\build\

xcopy /y "$(OutDir)*.exe" "\\%REMOTE_IP%%REMOTE_PATH%"
xcopy /y "$(OutDir)*.pdb" "\\%REMOTE_IP%%REMOTE_PATH%"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>Disabled</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="decoder\intel-pt.h" />
    <ClInclude Include="decoder\pt_cpu.h" />
    <ClInclude Include="decoder\pt_cpuid.h" />
    <ClInclude Include="decoder\pt_last_ip.h" />
    <ClInclude Include="decoder\pt_time.h" />
    <ClInclude Include="IntelPt.h" />
    <ClInclude Include="Log.h" />
    <ClInclude Include="pt_dump.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
    <ClInclude Include="IntelPtControlApp.h" />
    <ClInclude Include="UndocNt.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="decoder\ptdump.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="decoder\pt_cpu.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="decoder\pt_cpuid.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="decoder\pt_last_ip.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="decoder\pt_time.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="EntryPoint.cpp" />
    <ClCompile Include="Log.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="IntelPtControlApp.cpp" />
  </ItemGroup>
  <ItemGroup>
    <Library Include="decoder\libipt.lib" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="PtControlApp.rc" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="res\cpu.ico" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="asm\Amd64Control.asm">
      <FileType>Document</FileType>
    </MASM>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`PtControlApp/PtControlApp.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Source Files\PT Decoder">
      <UniqueIdentifier>{92261b6d-6fa7-40ac-91cb-e5e18e70fa1e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\PT_Decoder">
      <UniqueIdentifier>{1385788d-7326-4369-8d72-40a0007b08c1}</UniqueIdentifier>
    </Filter>
    <Filter Include="libs">
      <UniqueIdentifier>{25fb05fc-58ba-4ffb-98f7-4d80df0b04dd}</UniqueIdentifier>
    </Filter>
    <Filter Include="ASM">
      <UniqueIdentifier>{9dd12787-39f3-41e1-927a-280a77131790}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IntelPt.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IntelPtControlApp.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="decoder\intel-pt.h">
      <Filter>Header Files\PT_Decoder</Filter>
    </ClInclude>
    <ClInclude Include="decoder\pt_cpu.h">
      <Filter>Header Files\PT_Decoder</Filter>
    </ClInclude>
    <ClInclude Include="decoder\pt_last_ip.h">
      <Filter>Header Files\PT_Decoder</Filter>
    </ClInclude>
    <ClInclude Include="decoder\pt_time.h">
      <Filter>Header Files\PT_Decoder</Filter>
    </ClInclude>
    <ClInclude Include="decoder\pt_cpuid.h">
      <Filter>Header Files\PT_Decoder</Filter>
    </ClInclude>
    <ClInclude Include="pt_dump.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="UndocNt.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Log.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IntelPtControlApp.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="decoder\ptdump.cpp">
      <Filter>Source Files\PT Decoder</Filter>
    </ClCompile>
    <ClCompile Include="decoder\pt_time.cpp">
      <Filter>Source Files\PT Decoder</Filter>
    </ClCompile>
    <ClCompile Include="decoder\pt_last_ip.cpp">
      <Filter>Source Files\PT Decoder</Filter>
    </ClCompile>
    <ClCompile Include="decoder\pt_cpuid.cpp">
      <Filter>Source Files\PT Decoder</Filter>
    </ClCompile>
    <ClCompile Include="decoder\pt_cpu.cpp">
      <Filter>Source Files\PT Decoder</Filter>
    </ClCompile>
    <ClCompile Include="EntryPoint.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Log.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <Library Include="decoder\libipt.lib">
      <Filter>libs</Filter>
    </Library>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="PtControlApp.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <Image Include="res\cpu.ico">
      <Filter>Resource Files</Filter>
    </Image>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="asm\Amd64Control.asm">
      <Filter>ASM</Filter>
    </MASM>
  </ItemGroup>
</Project>
```

`PtControlApp/UndocNt.h`:

```h
/**********************************************************************
 *  Windows Intel Processor Trace (PT) Driver
 *  Filename: UndocNt.h
 *  Defines the undocumented Windows Nt data structures
 *  Last revision: 12/01/2016
 *
 *  Copyright© 2016 Andrea Allievi, Richard Johnson
 *  Microsoft Ltd & TALOS Research and Intelligence Group
 *  All right reserved
 **********************************************************************/
#pragma once
#define ANYSIZE_ARRAY 1
// The specified information record length does not match the length required for the specified information class.
#define STATUS_INFO_LENGTH_MISMATCH      ((NTSTATUS)0xC0000004L)

//typedef int NTSTATUS;

extern "C" NTSTATUS ZwQuerySystemInformation(DWORD SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);

// NTSTATUS to Win32 error and viceversa
extern "C" ULONG RtlNtStatusToDosError(NTSTATUS Status);
extern "C" DWORD LsaNtStatusToWinError(NTSTATUS Status);

typedef struct _SYSTEM_MODULE_INFORMATION { // Information Class 11
	PVOID Reserved[2];						// + 0x00
	PVOID Base;								// + 0x10
	ULONG Size;								// + 0x18
	ULONG Flags;							// + 0x1C
	USHORT Index;							// + 0x20
	USHORT Unknown;							// + 0x22
	USHORT LoadCount;						// + 0x24
	USHORT ModuleNameOffset;				// + 0x26
	CHAR ImageName[256];					// + 0x28
} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;

struct SYSTEM_ALL_MODULES {
	DWORD dwNumOfModules;
	SYSTEM_MODULE_INFORMATION modules[ANYSIZE_ARRAY];
};
```

`PtControlApp/asm/Amd64Control.asm`:

```asm
;   Windows Intel PT Driver
;   Filename: Amd64Control.asm
;	Description: Implement some control routine for the Hypervisor tests
;	Last revision: 04/06/2017
TITLE Intel Pt Control App AMD64 Assembler File


;Declare an external function
;EXTERN ExternalCFunc: PROC

.data

.code
;void _xsaves(void *mem, unsigned __int64 save_mask);
_xsaves PROC
	mov r8, rcx
	mov ecx, edx
	shr rdx, 020h
	xsaves qword ptr [r8]
	ret
_xsaves ENDP

;void MovToRdi(QWORD value)
MovToRdi PROC
   mov rdi, rcx
   xor rcx, rcx
   ret
MovToRdi ENDP

END
```

`PtControlApp/decoder/basic_include/inttypes.h`:

```h
/*
 * Copyright (c) 2013-2016, Intel Corporation
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *  * Neither the name of Intel Corporation nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <stddef.h>
#include <stdint.h>

#ifndef PRId64
#  define PRId64 "lld"
#endif
#ifndef PRIu64
#  define PRIu64 "llu"
#endif
#ifndef PRIx64
#  define PRIx64 "llx"
#endif

#ifndef PRId32
#  define PRId32 "d"
#endif
#ifndef PRIu32
#  define PRIu32 "u"
#endif
#ifndef PRIx32
#  define PRIx32 "x"
#endif

#ifndef PRIu16
#  define PRIu16 "u"
#endif

#ifndef PRIu8
#  define PRIu8 "u"
#endif
#ifndef PRIx8
#  define PRIx8 "x"
#endif

#ifndef SCNx64
#  define SCNx64 "llx"
#endif

```

`PtControlApp/decoder/basic_include/threads.h`:

```h
/*
 * Copyright (c) 2014-2016, Intel Corporation
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *  * Neither the name of Intel Corporation nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * It looks like there is still no support for C11's threads.h.
 *
 * We implement the few features we actually need hoping that this file will
 * soon go away.
 */

#ifndef THREADS_H
#define THREADS_H

#include "windows.h"


enum {
	thrd_success	= 1,
	thrd_error
};


struct pt_thread {
	HANDLE handle;
};
typedef struct pt_thread thrd_t;

typedef int (*thrd_start_t)(void *);


struct thrd_args {
	thrd_start_t fun;
	void *arg;
};

static DWORD WINAPI thrd_routine(void *arg)
{
	struct thrd_args *args;
	int result;

	args = (struct thrd_args *) arg;
	if (!args)
		return (DWORD) -1;

	result = -1;
	if (args->fun)
		result = args->fun(args->arg);

	free(args);

	return (DWORD) result;
}

static inline int thrd_create(thrd_t *thrd, thrd_start_t fun, void *arg)
{
	struct thrd_args *args;
	HANDLE handle;

	if (!thrd || !fun)
		return thrd_error;

	args = malloc(sizeof(*args));
	if (!args)
		return thrd_error;

	args->fun = fun;
	args->arg = arg;

	handle = CreateThread(NULL, 0, thrd_routine, args, 0, NULL);
	if (!handle) {
		free(args);
		return thrd_error;
	}

	thrd->handle = handle;
	return thrd_success;
}

static inline int thrd_join(thrd_t *thrd, int *res)
{
	DWORD status;
	BOOL success;

	if (!thrd)
		return thrd_error;

	status = WaitForSingleObject(thrd->handle, INFINITE);
	if (status)
		return thrd_error;

	if (res) {
		DWORD result;

		success = GetExitCodeThread(thrd->handle, &result);
		if (!success) {
			(void) CloseHandle(thrd->handle);
			return thrd_error;
		}

		*res = (int) result;
	}

	success = CloseHandle(thrd->handle);
	if (!success)
		return thrd_error;

	return thrd_success;
}

struct pt_mutex {
	CRITICAL_SECTION cs;
};
typedef struct pt_mutex mtx_t;

enum {
	mtx_plain
};

static inline int mtx_init(mtx_t *mtx, int type)
{
	if (!mtx || type != mtx_plain)
		return thrd_error;

	InitializeCriticalSection(&mtx->cs);

	return thrd_success;
}

static inline void mtx_destroy(mtx_t *mtx)
{
	if (mtx)
		DeleteCriticalSection(&mtx->cs);
}

static inline int mtx_lock(mtx_t *mtx)
{
	if (!mtx)
		return thrd_error;

	EnterCriticalSection(&mtx->cs);

	return thrd_success;
}

static inline int mtx_unlock(mtx_t *mtx)
{
	if (!mtx)
		return thrd_error;

	LeaveCriticalSection(&mtx->cs);

	return thrd_success;
}


struct pt_cond {
	CONDITION_VARIABLE cond;
};
typedef struct pt_cond cnd_t;

static inline int cnd_init(cnd_t *cnd)
{
	if (!cnd)
		return thrd_error;

	InitializeConditionVariable(&cnd->cond);

	return thrd_success;
}

static inline int cnd_destroy(cnd_t *cnd)
{
	if (!cnd)
		return thrd_error;

	/* Nothing to do. */

	return thrd_success;
}

static inline int cnd_signal(cnd_t *cnd)
{
	if (!cnd)
		return thrd_error;

	WakeConditionVariable(&cnd->cond);

	return thrd_success;
}

static inline int cnd_broadcast(cnd_t *cnd)
{
	if (!cnd)
		return thrd_error;

	WakeAllConditionVariable(&cnd->cond);

	return thrd_success;
}

static inline int cnd_wait(cnd_t *cnd, mtx_t *mtx)
{
	BOOL success;

	if (!cnd || !mtx)
		return thrd_error;

	success = SleepConditionVariableCS(&cnd->cond, &mtx->cs, INFINITE);
	if (!success)
		return thrd_error;

	return thrd_success;
}

#endif /* THREADS_H */

```

`PtControlApp/decoder/intel-pt.h`:

```h
/*
 * Copyright (c) 2013-2016, Intel Corporation
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *  * Neither the name of Intel Corporation nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef INTEL_PT_H
#define INTEL_PT_H

#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif


/* Intel(R) Processor Trace (Intel PT) decoder library.
 *
 * This file is logically structured into the following sections:
 *
 * - Version
 * - Opcodes
 * - Errors
 * - Configuration
 * - Packet encoder / decoder
 * - Query decoder
 * - Traced image
 * - Instruction flow decoder
 */



struct pt_encoder;
struct pt_packet_decoder;
struct pt_query_decoder;
struct pt_insn_decoder;



/* A macro to mark functions as exported. */
#ifndef pt_export
#  if defined(__GNUC__)
#    define pt_export __attribute__((visibility("default")))
#  elif defined(_MSC_VER)
#    define pt_export __declspec(dllimport)
#  else
#    error "unknown compiler"
#  endif
#endif



/* Version. */



/** The library version. */
struct pt_version {
	/** Major version number. */
	uint8_t major;

	/** Minor version number. */
	uint8_t minor;

	/** Reserved bits. */
	uint16_t reserved;

	/** Build number. */
	uint32_t build;

	/** Version extension. */
	const char *ext;
};


/** Return the library version. */
extern pt_export struct pt_version pt_library_version();



/* Opcodes. */



/** A one byte opcode. */
enum pt_opcode {
	pt_opc_pad		= 0x00,
	pt_opc_ext		= 0x02,
	pt_opc_psb		= pt_opc_ext,
	pt_opc_tip		= 0x0d,
	pt_opc_tnt_8		= 0x00,
	pt_opc_tip_pge		= 0x11,
	pt_opc_tip_pgd		= 0x01,
	pt_opc_fup		= 0x1d,
	pt_opc_mode		= 0x99,
	pt_opc_tsc		= 0x19,
	pt_opc_mtc		= 0x59,
	pt_opc_cyc		= 0x03,

	/* A free opcode to trigger a decode fault. */
	pt_opc_bad		= 0xd9
};

/** A one byte extension code for ext opcodes. */
enum pt_ext_code {
	pt_ext_psb		= 0x82,
	pt_ext_tnt_64		= 0xa3,
	pt_ext_pip		= 0x43,
	pt_ext_ovf		= 0xf3,
	pt_ext_psbend		= 0x23,
	pt_ext_cbr		= 0x03,
	pt_ext_tma		= 0x73,
	pt_ext_stop		= 0x83,
	pt_ext_vmcs		= 0xc8,
	pt_ext_ext2		= 0xc3,

	pt_ext_bad		= 0x04
};

/** A one byte extension 2 code for ext2 extension opcodes. */
enum pt_ext2_code {
	pt_ext2_mnt		= 0x88,

	pt_ext2_bad		= 0x00
};

/** A one byte opcode mask. */
enum pt_opcode_mask {
	pt_opm_tip		= 0x1f,
	pt_opm_tnt_8		= 0x01,
	pt_opm_tnt_8_shr	= 1,
	pt_opm_fup		= pt_opm_tip,

	/* The bit mask for the compression bits in the opcode. */
	pt_opm_ipc		= 0xe0,

	/* The shift right value for ipc bits. */
	pt_opm_ipc_shr		= 5,

	/* The bit mask for the compression bits after shifting. */
	pt_opm_ipc_shr_mask	= 0x7,

	/* Shift counts and masks for decoding the cyc packet. */
	pt_opm_cyc              = 0x03,
	pt_opm_cyc_ext          = 0x04,
	pt_opm_cyc_bits         = 0xf8,
	pt_opm_cyc_shr          = 3,
	pt_opm_cycx_ext         = 0x01,
	pt_opm_cycx_shr         = 1
};

/** The size of the various opcodes in bytes. */
enum pt_opcode_size {
	pt_opcs_pad		= 1,
	pt_opcs_tip		= 1,
	pt_opcs_tip_pge		= 1,
	pt_opcs_tip_pgd		= 1,
	pt_opcs_fup		= 1,
	pt_opcs_tnt_8		= 1,
	pt_opcs_mode		= 1,
	pt_opcs_tsc		= 1,
	pt_opcs_mtc		= 1,
	pt_opcs_cyc		= 1,
	pt_opcs_psb		= 2,
	pt_opcs_psbend		= 2,
	pt_opcs_ovf		= 2,
	pt_opcs_pip		= 2,
	pt_opcs_tnt_64		= 2,
	pt_opcs_cbr		= 2,
	pt_opcs_tma		= 2,
	pt_opcs_stop		= 2,
	pt_opcs_vmcs		= 2,
	pt_opcs_mnt		= 3
};

/** The psb magic payload.
 *
 * The payload is a repeating 2-byte pattern.
 */
enum pt_psb_pattern {
	/* The high and low bytes in the pattern. */
	pt_psb_hi		= pt_opc_psb,
	pt_psb_lo		= pt_ext_psb,

	/* Various combinations of the above parts. */
	pt_psb_lohi		= pt_psb_lo | pt_psb_hi << 8,
	pt_psb_hilo		= pt_psb_hi | pt_psb_lo << 8,

	/* The repeat count of the payload, not including opc and ext. */
	pt_psb_repeat_count	= 7,

	/* The size of the repeated pattern in bytes. */
	pt_psb_repeat_size	= 2
};

/** An execution mode. */
enum pt_exec_mode {
	ptem_unknown,
	ptem_16bit,
	ptem_32bit,
	ptem_64bit
};

/** The payload details. */
enum pt_payload {
	/* The shift counts for post-processing the PIP payload. */
	pt_pl_pip_shr		= 1,
	pt_pl_pip_shl		= 5,

	/* The size of a PIP payload in bytes. */
	pt_pl_pip_size		= 6,

	/* The non-root bit in the first byte of the PIP payload. */
	pt_pl_pip_nr            = 0x01,

	/* The size of a 8bit TNT packet's payload in bits. */
	pt_pl_tnt_8_bits	= 8 - pt_opm_tnt_8_shr,

	/* The size of a 64bit TNT packet's payload in bytes. */
	pt_pl_tnt_64_size	= 6,

	/* The size of a 64bit TNT packet's payload in bits. */
	pt_pl_tnt_64_bits	= 48,

	/* The size of a TSC packet's payload in bytes and in bits. */
	pt_pl_tsc_size		= 7,
	pt_pl_tsc_bit_size	= pt_pl_tsc_size * 8,

	/* The size of a CBR packet's payload in bytes. */
	pt_pl_cbr_size		= 2,

	/* The size of a PSB packet's payload in bytes. */
	pt_pl_psb_size		= pt_psb_repeat_count * pt_psb_repeat_size,

	/* The size of a MODE packet's payload in bytes. */
	pt_pl_mode_size		= 1,

	/* The size of an IP packet's payload with update-16 compression. */
	pt_pl_ip_upd16_size	= 2,

	/* The size of an IP packet's payload with update-32 compression. */
	pt_pl_ip_upd32_size	= 4,

	/* The size of an IP packet's payload with update-48 compression. */
	pt_pl_ip_upd48_size	= 6,

	/* The size of an IP packet's payload with sext-48 compression. */
	pt_pl_ip_sext48_size	= 6,

	/* The size of an IP packet's payload with full-ip compression. */
	pt_pl_ip_full_size	= 8,

	/* Byte locations, sizes, and masks for processing TMA packets. */
	pt_pl_tma_size		= 5,
	pt_pl_tma_ctc_size	= 2,
	pt_pl_tma_ctc_bit_size	= pt_pl_tma_ctc_size * 8,
	pt_pl_tma_ctc_0		= 2,
	pt_pl_tma_ctc_1		= 3,
	pt_pl_tma_ctc_mask	= (1 << pt_pl_tma_ctc_bit_size) - 1,
	pt_pl_tma_fc_size	= 2,
	pt_pl_tma_fc_bit_size	= 9,
	pt_pl_tma_fc_0		= 5,
	pt_pl_tma_fc_1		= 6,
	pt_pl_tma_fc_mask	= (1 << pt_pl_tma_fc_bit_size) - 1,

	/* The size of a MTC packet's payload in bytes and in bits. */
	pt_pl_mtc_size		= 1,
	pt_pl_mtc_bit_size	= pt_pl_mtc_size * 8,

	/* A mask for the MTC payload bits. */
	pt_pl_mtc_mask		= (1 << pt_pl_mtc_bit_size) - 1,

	/* The maximal payload size in bytes of a CYC packet. */
	pt_pl_cyc_max_size	= 15,

	/* The size of a VMCS packet's payload in bytes. */
	pt_pl_vmcs_size		= 5,

	/* The shift counts for post-processing the VMCS payload. */
	pt_pl_vmcs_shl		= 12,

	/* The size of a MNT packet's payload in bytes. */
	pt_pl_mnt_size		= 8
};

/** Mode packet masks. */
enum pt_mode_mask {
	pt_mom_leaf		= 0xe0,
	pt_mom_leaf_shr		= 5,
	pt_mom_bits		= 0x1f
};

/** Mode packet leaves. */
enum pt_mode_leaf {
	pt_mol_exec		= 0x00,
	pt_mol_tsx		= 0x20
};

/** Mode packet bits. */
enum pt_mode_bit {
	/* mode.exec */
	pt_mob_exec_csl		= 0x01,
	pt_mob_exec_csd		= 0x02,

	/* mode.tsx */
	pt_mob_tsx_intx		= 0x01,
	pt_mob_tsx_abrt		= 0x02
};

/** The IP compression. */
enum pt_ip_compression {
	/* The bits encode the payload size and the encoding scheme.
	 *
	 * No payload.  The IP has been suppressed.
	 */
	pt_ipc_suppressed	= 0x0,

	/* Payload: 16 bits.  Update last IP. */
	pt_ipc_update_16	= 0x01,

	/* Payload: 32 bits.  Update last IP. */
	pt_ipc_update_32	= 0x02,

	/* Payload: 48 bits.  Sign extend to full address. */
	pt_ipc_sext_48		= 0x03,

	/* Payload: 48 bits.  Update last IP. */
	pt_ipc_update_48	= 0x04,

	/* Payload: 64 bits.  Full address. */
	pt_ipc_full		= 0x06
};

/** The size of the various packets in bytes. */
enum pt_packet_size {
	ptps_pad		= pt_opcs_pad,
	ptps_tnt_8		= pt_opcs_tnt_8,
	ptps_mode		= pt_opcs_mode + pt_pl_mode_size,
	ptps_tsc		= pt_opcs_tsc + pt_pl_tsc_size,
	ptps_mtc		= pt_opcs_mtc + pt_pl_mtc_size,
	ptps_psb		= pt_opcs_psb + pt_pl_psb_size,
	ptps_psbend		= pt_opcs_psbend,
	ptps_ovf		= pt_opcs_ovf,
	ptps_pip		= pt_opcs_pip + pt_pl_pip_size,
	ptps_tnt_64		= pt_opcs_tnt_64 + pt_pl_tnt_64_size,
	ptps_cbr		= pt_opcs_cbr + pt_pl_cbr_size,
	ptps_tip_supp		= pt_opcs_tip,
	ptps_tip_upd16		= pt_opcs_tip + pt_pl_ip_upd16_size,
	ptps_tip_upd32		= pt_opcs_tip + pt_pl_ip_upd32_size,
	ptps_tip_upd48		= pt_opcs_tip + pt_pl_ip_upd48_size,
	ptps_tip_sext48		= pt_opcs_tip + pt_pl_ip_sext48_size,
	ptps_tip_full		= pt_opcs_tip + pt_pl_ip_full_size,
	ptps_tip_pge_supp	= pt_opcs_tip_pge,
	ptps_tip_pge_upd16	= pt_opcs_tip_pge + pt_pl_ip_upd16_size,
	ptps_tip_pge_upd32	= pt_opcs_tip_pge + pt_pl_ip_upd32_size,
	ptps_tip_pge_upd48	= pt_opcs_tip_pge + pt_pl_ip_upd48_size,
	ptps_tip_pge_sext48	= pt_opcs_tip_pge + pt_pl_ip_sext48_size,
	ptps_tip_pge_full	= pt_opcs_tip_pge + pt_pl_ip_full_size,
	ptps_tip_pgd_supp	= pt_opcs_tip_pgd,
	ptps_tip_pgd_upd16	= pt_opcs_tip_pgd + pt_pl_ip_upd16_size,
	ptps_tip_pgd_upd32	= pt_opcs_tip_pgd + pt_pl_ip_upd32_size,
	ptps_tip_pgd_upd48	= pt_opcs_tip_pgd + pt_pl_ip_upd48_size,
	ptps_tip_pgd_sext48	= pt_opcs_tip_pgd + pt_pl_ip_sext48_size,
	ptps_tip_pgd_full	= pt_opcs_tip_pgd + pt_pl_ip_full_size,
	ptps_fup_supp		= pt_opcs_fup,
	ptps_fup_upd16		= pt_opcs_fup + pt_pl_ip_upd16_size,
	ptps_fup_upd32		= pt_opcs_fup + pt_pl_ip_upd32_size,
	ptps_fup_upd48		= pt_opcs_fup + pt_pl_ip_upd48_size,
	ptps_fup_sext48		= pt_opcs_fup + pt_pl_ip_sext48_size,
	ptps_fup_full		= pt_opcs_fup + pt_pl_ip_full_size,
	ptps_tma		= pt_opcs_tma + pt_pl_tma_size,
	ptps_stop		= pt_opcs_stop,
	ptps_vmcs		= pt_opcs_vmcs + pt_pl_vmcs_size,
	ptps_mnt		= pt_opcs_mnt + pt_pl_mnt_size
};



/* Errors. */



/** Error codes. */
enum pt_error_code {
	/* No error. Everything is OK. */
	pte_ok,

	/* Internal decoder error. */
	pte_internal,

	/* Invalid argument. */
	pte_invalid,

	/* Decoder out of sync. */
	pte_nosync,

	/* Unknown opcode. */
	pte_bad_opc,

	/* Unknown payload. */
	pte_bad_packet,

	/* Unexpected packet context. */
	pte_bad_context,

	/* Decoder reached end of trace stream. */
	pte_eos,

	/* No packet matching the query to be found. */
	pte_bad_query,

	/* Decoder out of memory. */
	pte_nomem,

	/* Bad configuration. */
	pte_bad_config,

	/* There is no IP. */
	pte_noip,

	/* The IP has been suppressed. */
	pte_ip_suppressed,

	/* There is no memory mapped at the requested address. */
	pte_nomap,

	/* An instruction could not be decoded. */
	pte_bad_insn,

	/* No wall-clock time is available. */
	pte_no_time,

	/* No core:bus ratio available. */
	pte_no_cbr,

	/* Bad traced image. */
	pte_bad_image,

	/* A locking error. */
	pte_bad_lock,

	/* The requested feature is not supported. */
	pte_not_supported,

	/* The return address stack is empty. */
	pte_retstack_empty,

	/* A compressed return is not indicated correctly by a taken branch. */
	pte_bad_retcomp,

	/* The current decoder state does not match the state in the trace. */
	pte_bad_status_update,

	/* The trace did not contain an expected enabled event. */
	pte_no_enable,

	/* An event was ignored. */
	pte_event_ignored
};


/** Decode a function return value into an pt_error_code. */
static inline enum pt_error_code pt_errcode(int status)
{
	return (status >= 0) ? pte_ok : (enum pt_error_code) -status;
}

/** Return a human readable error string. */
extern pt_export const char *pt_errstr(enum pt_error_code);



/* Configuration. */



/** A cpu vendor. */
enum pt_cpu_vendor {
	pcv_unknown,
	pcv_intel
};

/** A cpu identifier. */
struct pt_cpu {
	/** The cpu vendor. */
	enum pt_cpu_vendor vendor;

	/** The cpu family. */
	uint16_t family;

	/** The cpu model. */
	uint8_t model;

	/** The stepping. */
	uint8_t stepping;
};

/** A collection of Intel PT errata. */
struct pt_errata {
	/** BDM70: Intel(R) Processor Trace PSB+ Packets May Contain
	 *         Unexpected Packets.
	 *
	 * Same as: SKD024.
	 *
	 * Some Intel Processor Trace packets should be issued only between
	 * TIP.PGE and TIP.PGD packets.  Due to this erratum, when a TIP.PGE
	 * packet is generated it may be preceded by a PSB+ that incorrectly
	 * includes FUP and MODE.Exec packets.
	 */
	uint32_t bdm70:1;

	/** BDM64: An Incorrect LBR or Intel(R) Processor Trace Packet May Be
	 *         Recorded Following a Transactional Abort.
	 *
	 * Use of Intel(R) Transactional Synchronization Extensions (Intel(R)
	 * TSX) may result in a transactional abort.  If an abort occurs
	 * immediately following a branch instruction, an incorrect branch
	 * target may be logged in an LBR (Last Branch Record) or in an Intel(R)
	 * Processor Trace (Intel(R) PT) packet before the LBR or Intel PT
	 * packet produced by the abort.
	 */
	uint32_t bdm64:1;

	/** SKD007: Intel(R) PT Buffer Overflow May Result in Incorrect Packets.
	 *
	 * Under complex micro-architectural conditions, an Intel PT (Processor
	 * Trace) OVF (Overflow) packet may be issued after the first byte of a
	 * multi-byte CYC (Cycle Count) packet, instead of any remaining bytes
	 * of the CYC.
	 */
	uint32_t skd007:1;

	/** SKD022: VM Entry That Clears TraceEn May Generate a FUP.
	 *
	 * If VM entry clears Intel(R) PT (Intel Processor Trace)
	 * IA32_RTIT_CTL.TraceEn (MSR 570H, bit 0) while PacketEn is 1 then a
	 * FUP (Flow Update Packet) will precede the TIP.PGD (Target IP Packet,
	 * Packet Generation Disable).  VM entry can clear TraceEn if the
	 * VM-entry MSR-load area includes an entry for the IA32_RTIT_CTL MSR.
	 */
	uint32_t skd022:1;

	/** SKD010: Intel(R) PT FUP May be Dropped After OVF.
	 *
	 * Same as: SKD014.
	 *
	 * Some Intel PT (Intel Processor Trace) OVF (Overflow) packets may not
	 * be followed by a FUP (Flow Update Packet) or TIP.PGE (Target IP
	 * Packet, Packet Generation Enable).
	 */
	uint32_t skd010:1;

	/* Reserve a few bytes for the future. */
	uint32_t reserved[15];
};

/** An unknown packet. */
struct pt_packet_unknown;

/** An Intel PT decoder configuration.
 */
struct pt_config {
	/** The size of the config structure in bytes. */
	size_t size;

	/** The trace buffer begin address. */
	uint8_t *begin;

	/** The trace buffer end address. */
	uint8_t *end;

	/** An optional callback for handling unknown packets.
	 *
	 * If \@callback is not NULL, it is called for any unknown opcode.
	 */
	struct {
		/** The callback function.
		 *
		 * It shall decode the packet at \@pos into \@unknown.
		 * It shall return the number of bytes read upon success.
		 * It shall return a negative pt_error_code otherwise.
		 * The below context is passed as \@context.
		 */
		int (*callback)(struct pt_packet_unknown *unknown,
				const struct pt_config *config,
				const uint8_t *pos, void *context);

		/** The user-defined context for this configuration. */
		void *context;
	} decode;

	/** The cpu on which Intel PT has been recorded. */
	struct pt_cpu cpu;

	/** The errata to apply when encoding or decoding Intel PT. */
	struct pt_errata errata;

	/* The CTC frequency.
	 *
	 * This is only required if MTC packets have been enabled in
	 * IA32_RTIT_CTRL.MTCEn.
	 */
	uint32_t cpuid_0x15_eax, cpuid_0x15_ebx;

	/* The MTC frequency as defined in IA32_RTIT_CTL.MTCFreq.
	 *
	 * This is only required if MTC packets have been enabled in
	 * IA32_RTIT_CTRL.MTCEn.
	 */
	uint8_t mtc_freq;

	/* The nominal frequency as defined in MSR_PLATFORM_INFO[15:8].
	 *
	 * This is only required if CYC packets have been enabled in
	 * IA32_RTIT_CTRL.CYCEn.
	 *
	 * If zero, timing calibration will only be able to use MTC and CYC
	 * packets.
	 *
	 * If not zero, timing calibration will also be able to use CBR
	 * packets.
	 */
	uint8_t nom_freq;
};


/** Zero-initialize an Intel PT configuration. */
static inline void pt_config_init(struct pt_config *config)
{
	memset(config, 0, sizeof(*config));

	config->size = sizeof(*config);
}

/** Determine errata for a given cpu.
 *
 * Updates \@errata based on \@cpu.
 *
 * Returns 0 on success, a negative error code otherwise.
 * Returns -pte_invalid if \@errata or \@cpu is NULL.
 */
extern pt_export int pt_cpu_errata(struct pt_errata *errata,
				   const struct pt_cpu *cpu);



/* Packet encoder / decoder. */



/* We define a few abbreviations outside of the below enum as we don't
 * want to handle those in switches.
 */
enum {
	ppt_ext			= pt_opc_ext << 8,
	ppt_ext2		= ppt_ext << 8 | pt_ext_ext2 << 8
};

/** Intel PT packet types. */
enum pt_packet_type {
	/* 1-byte header packets. */
	ppt_pad			= pt_opc_pad,
	ppt_tip			= pt_opc_tip,
	ppt_tnt_8		= pt_opc_tnt_8 | 0xFE,
	ppt_tip_pge		= pt_opc_tip_pge,
	ppt_tip_pgd		= pt_opc_tip_pgd,
	ppt_fup			= pt_opc_fup,
	ppt_mode		= pt_opc_mode,
	ppt_tsc			= pt_opc_tsc,
	ppt_mtc			= pt_opc_mtc,
	ppt_cyc			= pt_opc_cyc,

	/* 2-byte header packets. */
	ppt_psb			= ppt_ext | pt_ext_psb,
	ppt_tnt_64		= ppt_ext | pt_ext_tnt_64,
	ppt_pip			= ppt_ext | pt_ext_pip,
	ppt_stop		= ppt_ext | pt_ext_stop,
	ppt_ovf			= ppt_ext | pt_ext_ovf,
	ppt_psbend		= ppt_ext | pt_ext_psbend,
	ppt_cbr			= ppt_ext | pt_ext_cbr,
	ppt_tma			= ppt_ext | pt_ext_tma,
	ppt_vmcs		= ppt_ext | pt_ext_vmcs,

	/* 3-byte header packets. */
	ppt_mnt			= ppt_ext2 | pt_ext2_mnt,

	/* A packet decodable by the optional decoder callback. */
	ppt_unknown		= 0x7ffffffe,

	/* An invalid packet. */
	ppt_invalid		= 0x7fffffff
};

/** A TNT-8 or TNT-64 packet. */
struct pt_packet_tnt {
	/** TNT payload bit size. */
	uint8_t bit_size;

	/** TNT payload excluding stop bit. */
	uint64_t payload;
};

/** A packet with IP payload. */
struct pt_packet_ip {
	/** IP compression. */
	enum pt_ip_compression ipc;

	/** Zero-extended payload ip. */
	uint64_t ip;
};

/** A mode.exec packet. */
struct pt_packet_mode_exec {
	/** The mode.exec csl bit. */
	uint32_t csl:1;

	/** The mode.exec csd bit. */
	uint32_t csd:1;
};

static inline enum pt_exec_mode
pt_get_exec_mode(const struct pt_packet_mode_exec *packet)
{
	if (packet->csl)
		return packet->csd ? ptem_unknown : ptem_64bit;
	else
		return packet->csd ? ptem_32bit : ptem_16bit;
}

static inline struct pt_packet_mode_exec
pt_set_exec_mode(enum pt_exec_mode mode)
{
	struct pt_packet_mode_exec packet;

	switch (mode) {
	default:
		packet.csl = 1;
		packet.csd = 1;
		break;

	case ptem_64bit:
		packet.csl = 1;
		packet.csd = 0;
		break;

	case ptem_32bit:
		packet.csl = 0;
		packet.csd = 1;
		break;

	case ptem_16bit:
		packet.csl = 0;
		packet.csd = 0;
		break;
	}

	return packet;
}

/** A mode.tsx packet. */
struct pt_packet_mode_tsx {
	/** The mode.tsx intx bit. */
	uint32_t intx:1;

	/** The mode.tsx abrt bit. */
	uint32_t abrt:1;
};

/** A mode packet. */
struct pt_packet_mode {
	/** Mode leaf. */
	enum pt_mode_leaf leaf;

	/** Mode bits. */
	union {
		/** Packet: mode.exec. */
		struct pt_packet_mode_exec exec;

		/** Packet: mode.tsx. */
		struct pt_packet_mode_tsx tsx;
	} bits;
};

/** A PIP packet. */
struct pt_packet_pip {
	/** The CR3 value. */
	uint64_t cr3;

	/** The non-root bit. */
	uint32_t nr:1;
};

/** A TSC packet. */
struct pt_packet_tsc {
	/** The TSC value. */
	uint64_t tsc;
};

/** A CBR packet. */
struct pt_packet_cbr {
	/** The core/bus cycle ratio. */
	uint8_t ratio;
};

/** A TMA packet. */
struct pt_packet_tma {
	/** The crystal clock tick counter value. */
	uint16_t ctc;

	/** The fast counter value. */
	uint16_t fc;
};

/** A MTC packet. */
struct pt_packet_mtc {
	/** The crystal clock tick counter value. */
	uint8_t ctc;
};

/** A CYC packet. */
struct pt_packet_cyc {
	/** The cycle counter value. */
	uint64_t value;
};

/** A VMCS packet. */
struct pt_packet_vmcs {
       /* The VMCS Base Address (i.e. the shifted payload). */
	uint64_t base;
};

/** A MNT packet. */
struct pt_packet_mnt {
	/** The raw payload. */
	uint64_t payload;
};

/** An unknown packet decodable by the optional decoder callback. */
struct pt_packet_unknown {
	/** Pointer to the raw packet bytes. */
	const uint8_t *packet;

	/** Optional pointer to a user-defined structure. */
	void *priv;
};

/** An Intel PT packet. */
struct pt_packet {
	/** The type of the packet.
	 *
	 * This also determines the \@payload field.
	 */
	enum pt_packet_type type;

	/** The size of the packet including opcode and payload. */
	uint8_t size;

	/** Packet specific data. */
	union {
		/** Packets: pad, ovf, psb, psbend, stop - no payload. */

		/** Packet: tnt-8, tnt-64. */
		struct pt_packet_tnt tnt;

		/** Packet: tip, fup, tip.pge, tip.pgd. */
		struct pt_packet_ip ip;

		/** Packet: mode. */
		struct pt_packet_mode mode;

		/** Packet: pip. */
		struct pt_packet_pip pip;

		/** Packet: tsc. */
		struct pt_packet_tsc tsc;

		/** Packet: cbr. */
		struct pt_packet_cbr cbr;

		/** Packet: tma. */
		struct pt_packet_tma tma;

		/** Packet: mtc. */
		struct pt_packet_mtc mtc;

		/** Packet: cyc. */
		struct pt_packet_cyc cyc;

		/** Packet: vmcs. */
		struct pt_packet_vmcs vmcs;

		/** Packet: mnt. */
		struct pt_packet_mnt mnt;

		/** Packet: unknown. */
		struct pt_packet_unknown unknown;
	} payload;
};



/* Packet encoder. */



/** Allocate an Intel PT packet encoder.
 *
 * The encoder will work on the buffer defined in \@config, it shall contain
 * raw trace data and remain valid for the lifetime of the encoder.
 *
 * The encoder starts at the beginning of the trace buffer.
 */
extern pt_export struct pt_encoder *
pt_alloc_encoder(const struct pt_config *config);

/** Free an Intel PT packet encoder.
 *
 * The \@encoder must not be used after a successful return.
 */
extern pt_export void pt_free_encoder(struct pt_encoder *encoder);

/** Hard set synchronization point of an Intel PT packet encoder.
 *
 * Synchronize \@encoder to \@offset within the trace buffer.
 *
 * Returns zero on success, a negative error code otherwise.
 *
 * Returns -pte_eos if the given offset is behind the end of the trace buffer.
 * Returns -pte_invalid if \@encoder is NULL.
 */
extern pt_export int pt_enc_sync_set(struct pt_encoder *encoder,
				     uint64_t offset);

/** Get the current packet encoder position.
 *
 * Fills the current \@encoder position into \@offset.
 *
 * This is useful for reporting errors.
 *
 * Returns zero on success, a negative error code otherwise.
 *
 * Returns -pte_invalid if \@encoder or \@offset is NULL.
 */
extern pt_export int pt_enc_get_offset(struct pt_encoder *encoder,
				       uint64_t *offset);

/* Return a pointer to \@encoder's configuration.
 *
 * Returns a non-null pointer on success, NULL if \@encoder is NULL.
 */
extern pt_export const struct pt_config *
pt_enc_get_config(const struct pt_encoder *encoder);

/** Encode an Intel PT packet.
 *
 * Writes \@packet at \@encoder's current position in the Intel PT buffer and
 * advances the \@encoder beyond the written packet.
 *
 * The \@packet.size field is ignored.
 *
 * In case of errors, the \@encoder is not advanced and nothing is written
 * into the Intel PT buffer.
 *
 * Returns the number of bytes written on success, a negative error code
 * otherwise.
 *
 * Returns -pte_bad_opc if \@packet.type is not known.
 * Returns -pte_bad_packet if \@packet's payload is invalid.
 * Returns -pte_eos if \@encoder reached the end of the Intel PT buffer.
 * Returns -pte_invalid if \@encoder or \@packet is NULL.
 */
extern pt_export int pt_enc_next(struct pt_encoder *encoder,
				 const struct pt_packet *packet);



/* Packet decoder. */



/** Allocate an Intel PT packet decoder.
 *
 * The decoder will work on the buffer defined in \@config, it shall contain
 * raw trace data and remain valid for the lifetime of the decoder.
 *
 * The decoder needs to be synchronized before it can be used.
 */
extern pt_export struct pt_packet_decoder *
pt_pkt_alloc_decoder(const struct pt_config *config);

/** Free an Intel PT packet decoder.
 *
 * The \@decoder must not be used after a successful return.
 */
extern pt_export void pt_pkt_free_decoder(struct pt_packet_decoder *decoder);

/** Synchronize an Intel PT packet decoder.
 *
 * Search for the next synchronization point in forward or backward direction.
 *
 * If \@decoder has not been synchronized, yet, the search is started at the
 * beginning of the trace buffer in case of forward synchronization and at the
 * end of the trace buffer in case of backward synchronization.
 *
 * Returns zero or a positive value on success, a negative error code otherwise.
 *
 * Returns -pte_eos if no further synchronization point is found.
 * Returns -pte_invalid if \@decoder is NULL.
 */
extern pt_export int pt_pkt_sync_forward(struct pt_packet_decoder *decoder);
extern pt_export int pt_pkt_sync_backward(struct pt_packet_decoder *decoder);

/** Hard set synchronization point of an Intel PT decoder.
 *
 * Synchronize \@decoder to \@offset within the trace buffer.
 *
 * Returns zero on success, a negative error code otherwise.
 *
 * Returns -pte_eos if the given offset is behind the end of the trace buffer.
 * Returns -pte_invalid if \@decoder is NULL.
 */
extern pt_export int pt_pkt_sync_set(struct pt_packet_decoder *decoder,
				     uint64_t offset);

/** Get the current decoder position.
 *
 * Fills the current \@decoder position into \@offset.
 *
 * This is useful for reporting errors.
 *
 * Returns zero on success, a negative error code otherwise.
 *
 * Returns -pte_invalid if \@decoder or \@offset is NULL.
 * Returns -pte_nosync if \@decoder is out of sync.
 */
extern pt_export int pt_pkt_get_offset(struct pt_packet_decoder *decoder,
				       uint64_t *offset);

/** Get the position of the last synchronization point.
 *
 * Fills the last synchronization position into \@offset.
 *
 * This is useful when splitting a trace stream for parallel decoding.
 *
 * Returns zero on success, a negative error code otherwise.
 *
 * Returns -pte_invalid if \@decoder or \@offset is NULL.
 * Returns -pte_nosync if \@decoder is out of sync.
 */
extern pt_export int pt_pkt_get_sync_offset(struct pt_packet_decoder *decoder,
					    uint64_t *offset);

/* Return a pointer to \@decoder's configuration.
 *
 * Returns a non-null pointer on success, NULL if \@decoder is NULL.
 */
extern pt_export const struct pt_config *
pt_pkt_get_config(const struct pt_packet_decoder *decoder);

/** Decode the next packet and advance the decoder.
 *
 * Decodes the packet at \@decoder's current position into \@packet and
 * adjusts the \@decoder's position by the number of bytes the packet had
 * consumed.
 *
 * The \@size argument must be set to sizeof(struct pt_packet).
 *
 * Returns the number of bytes consumed on success, a negative error code
 * otherwise.
 *
 * Returns -pte_bad_opc if the packet is unknown.
 * Returns -pte_bad_packet if an unknown packet payload is encountered.
 * Returns -pte_eos if \@decoder reached the end of the Intel PT buffer.
 * Returns -pte_invalid if \@decoder or \@packet is NULL.
 * Returns -pte_nosync if \@decoder is out of sync.
 */
extern pt_export int pt_pkt_next(struct pt_packet_decoder *decoder,
				 struct pt_packet *packet, size_t size);



/* Query decoder. */



/** Decoder status flags. */
enum pt_status_flag {
	/** There is an event pending. */
	pts_event_pending	= 1 << 0,

	/** The address has been suppressed. */
	pts_ip_suppressed	= 1 << 1,

	/** There is no more trace data available. */
	pts_eos			= 1 << 2
};

/** Event types. */
enum pt_event_type {
	/* Tracing has been enabled/disabled. */
	ptev_enabled,
	ptev_disabled,

	/* Tracing has been disabled asynchronously. */
	ptev_async_disabled,

	/* An asynchronous branch, e.g. interrupt. */
	ptev_async_branch,

	/* A synchronous paging event. */
	ptev_paging,

	/* An asynchronous paging event. */
	ptev_async_paging,

	/* Trace overflow. */
	ptev_overflow,

	/* An execution mode change. */
	ptev_exec_mode,

	/* A transactional execution state change. */
	ptev_tsx,

	/* Trace Stop. */
	ptev_stop,

	/* A synchronous vmcs event. */
	ptev_vmcs,

	/* An asynchronous vmcs event. */
	ptev_async_vmcs
};

/** An event. */
struct pt_event {
	/** The type of the event. */
	enum pt_event_type type;

	/** A flag indicating that the event IP has been suppressed. */
	uint32_t ip_suppressed:1;

	/** A flag indicating that the event is for status update. */
	uint32_t status_update:1;

	/** A flag indicating that the event has timing information. */
	uint32_t has_tsc:1;

	/** The time stamp count of the event.
	 *
	 * This field is only valid if \@has_tsc is set.
	 */
	uint64_t tsc;

	/** The number of lost mtc and cyc packets.
	 *
	 * This gives an idea about the quality of the \@tsc.  The more packets
	 * were dropped, the less precise timing is.
	 */
	uint32_t lost_mtc;
	uint32_t lost_cyc;

	/* Reserved space for future extensions. */
	uint64_t reserved[2];

	/** Event specific data. */
	union {
		/** Event: enabled. */
		struct {
			/* The address at which tracing resumes. */
			uint64_t ip;
		} enabled;

		/** Event: disabled. */
		struct {
			/** The destination of the first branch inside a
			 * filtered area.
			 *
			 * This field is not valid if \@ip_suppressed is set.
			 */
			uint64_t ip;

			/* The exact source ip needs to be determined using
			 * disassembly and the filter configuration.
			 */
		} disabled;

		/** Event: async disabled. */
		struct {
			/** The source address of the asynchronous branch that
			 * disabled tracing.
			 */
			uint64_t at;

			/** The destination of the first branch inside a
			 * filtered area.
			 *
			 * This field is not valid if \@ip_suppressed is set.
			 */
			uint64_t ip;
		} async_disabled;

		/** Event: async branch. */
		struct {
			/** The branch source address. */
			uint64_t from;

			/** The branch destination address.
			 *
			 * This field is not valid if \@ip_suppressed is set.
			 */
			uint64_t to;
		} async_branch;

		/** Event: paging. */
		struct {
			/** The updated CR3 value.
			 *
			 * The lower 5 bit have been zeroed out.
			 * The upper bits have been zeroed out depending on the
			 * maximum possible address.
			 */
			uint64_t cr3;

			/** A flag indicating whether the cpu is operating in
			 * vmx non-root (guest) mode.
			 */
			uint32_t non_root:1;

			/* The address at which the event is effective is
			 * obvious from the disassembly.
			 */
		} paging;

		/** Event: async paging. */
		struct {
			/** The updated CR3 value.
			 *
			 * The lower 5 bit have been zeroed out.
			 * The upper bits have been zeroed out depending on the
			 * maximum possible address.
			 */
			uint64_t cr3;

			/** A flag indicating whether the cpu is operating in
			 * vmx non-root (guest) mode.
			 */
			uint32_t non_root:1;

			/** The address at which the event is effective. */
			uint64_t ip;
		} async_paging;

		/** Event: overflow. */
		struct {
			/** The address at which tracing resumes after overflow.
			 *
			 * This field is not valid, if ip_suppressed is set.
			 * In this case, the overflow resolved while tracing
			 * was disabled.
			 */
			uint64_t ip;
		} overflow;

		/** Event: exec mode. */
		struct {
			/** The execution mode. */
			enum pt_exec_mode mode;

			/** The address at which the event is effective. */
			uint64_t ip;
		} exec_mode;

		/** Event: tsx. */
		struct {
			/** The address at which the event is effective.
			 *
			 * This field is not valid if \@ip_suppressed is set.
			 */
			uint64_t ip;

			/** A flag indicating speculative execution mode. */
			uint32_t speculative:1;

			/** A flag indicating speculative execution aborts. */
			uint32_t aborted:1;
		} tsx;

		/** Event: vmcs. */
		struct {
			/** The VMCS base address.
			 *
			 * The address is zero-extended with the lower 12 bits
			 * all zero.
			 */
			uint64_t base;

			/* The new VMCS base address should be stored and
			 * applied on subsequent VM entries.
			 */
		} vmcs;

		/** Event: async vmcs. */
		struct {
			/** The VMCS base address.
			 *
			 * The address is zero-extended with the lower 12 bits
			 * all zero.
			 */
			uint64_t base;

			/** The address at which the event is effective. */
			uint64_t ip;

			/* An async paging event that binds to the same IP
			 * will always succeed this async vmcs event.
			 */
		} async_vmcs;
	} variant;
};


/** Allocate an Intel PT query decoder.
 *
 * The decoder will work on the buffer defined in \@config, it shall contain
 * raw trace data and remain valid for the lifetime of the decoder.
 *
 * The decoder needs to be synchronized before it can be used.
 */
extern pt_export struct pt_query_decoder *
pt_qry_alloc_decoder(const struct pt_config *config);

/** Free an Intel PT query decoder.
 *
 * The \@decoder must not be used after a successful return.
 */
extern pt_export void pt_qry_free_decoder(struct pt_query_decoder *decoder);

/** Synchronize an Intel PT query decoder.
 *
 * Search for the next synchronization point in forward or backward direction.
 *
 * If \@decoder has not been synchronized, yet, the search is started at the
 * beginning of the trace buffer in case of forward synchronization and at the
 * end of the trace buffer in case of backward synchronization.
 *
 * If \@ip is not NULL, set it to last ip.
 *
 * Returns a non-negative pt_status_flag bit-vector on success, a negative error
 * code otherwise.
 *
 * Returns -pte_bad_opc if an unknown packet is encountered.
 * Returns -pte_bad_packet if an unknown packet payload is encountered.
 * Returns -pte_eos if no further synchronization point is found.
 * Returns -pte_invalid if \@decoder is NULL.
 */
extern pt_export int pt_qry_sync_forward(struct pt_query_decoder *decoder,
					 uint64_t *ip);
extern pt_export int pt_qry_sync_backward(struct pt_query_decoder *decoder,
					 uint64_t *ip);

/** Manually synchronize an Intel PT query decoder.
 *
 * Synchronize \@decoder on the syncpoint at \@offset.  There must be a PSB
 * packet at \@offset.
 *
 * If \@ip is not NULL, set it to last ip.
 *
 * Returns a non-negative pt_status_flag bit-vector on success, a negative error
 * code otherwise.
 *
 * Returns -pte_bad_opc if an unknown packet is encountered.
 * Returns -pte_bad_packet if an unknown packet payload is encountered.
 * Returns -pte_eos if \@offset lies outside of \@decoder's trace buffer.
 * Returns -pte_eos if \@decoder reaches the end of its trace buffer.
 * Returns -pte_invalid if \@decoder is NULL.
 * Returns -pte_nosync if there is no syncpoint at \@offset.
 */
extern pt_export int pt_qry_sync_set(struct pt_query_decoder *decoder,
				     uint64_t *ip, uint64_t offset);

/** Get the current decoder position.
 *
 * Fills the current \@decoder position into \@offset.
 *
 * This is useful for reporting errors.
 *
 * Returns zero on success, a negative error code otherwise.
 *
 * Returns -pte_invalid if \@decoder or \@offset is NULL.
 * Returns -pte_nosync if \@decoder is out of sync.
 */
extern pt_export int pt_qry_get_offset(struct pt_query_decoder *decoder,
				       uint64_t *offset);

/** Get the position of the last synchronization point.
 *
 * Fills the last synchronization position into \@offset.
 *
 * This is useful for splitting a trace stream for parallel decoding.
 *
 * Returns zero on success, a negative error code otherwise.
 *
 * Returns -pte_invalid if \@decoder or \@offset is NULL.
 * Returns -pte_nosync if \@decoder is out of sync.
 */
extern pt_export int pt_qry_get_sync_offset(struct pt_query_decoder *decoder,
					    uint64_t *offset);

/* Return a pointer to \@decoder's configuration.
 *
 * Returns a non-null pointer on success, NULL if \@decoder is NULL.
 */
extern pt_export const struct pt_config *
pt_qry_get_config(const struct pt_query_decoder *decoder);

/** Query whether the next unconditional branch has been taken.
 *
 * On success, provides 1 (taken) or 0 (not taken) in \@taken for the next
 * conditional branch and updates \@decoder.
 *
 * Returns a non-negative pt_status_flag bit-vector on success, a negative error
 * code otherwise.
 *
 * Returns -pte_bad_opc if an unknown packet is encountered.
 * Returns -pte_bad_packet if an unknown packet payload is encountered.
 * Returns -pte_bad_query if no conditional branch is found.
 * Returns -pte_eos if decoding reached the end of the Intel PT buffer.
 * Returns -pte_invalid if \@decoder or \@taken is NULL.
 * Returns -pte_nosync if \@decoder is out of sync.
 */
extern pt_export int pt_qry_cond_branch(struct pt_query_decoder *decoder,
					int *taken);

/** Get the next indirect branch destination.
 *
 * On success, provides the linear destination address of the next indirect
 * branch in \@ip and updates \@decoder.
 *
 * Returns a non-negative pt_status_flag bit-vector on success, a negative error
 * code otherwise.
 *
 * Returns -pte_bad_opc if an unknown packet is encountered.
 * Returns -pte_bad_packet if an unknown packet payload is encountered.
 * Returns -pte_bad_query if no indirect branch is found.
 * Returns -pte_eos if decoding reached the end of the Intel PT buffer.
 * Returns -pte_invalid if \@decoder or \@ip is NULL.
 * Returns -pte_nosync if \@decoder is out of sync.
 */
extern pt_export int pt_qry_indirect_branch(struct pt_query_decoder *decoder,
					    uint64_t *ip);

/** Query the next pending event.
 *
 * On success, provides the next event \@event and updates \@decoder.
 *
 * The \@size argument must be set to sizeof(struct pt_event).
 *
 * Returns a non-negative pt_status_flag bit-vector on success, a negative error
 * code otherwise.
 *
 * Returns -pte_bad_opc if an unknown packet is encountered.
 * Returns -pte_bad_packet if an unknown packet payload is encountered.
 * Returns -pte_bad_query if no event is found.
 * Returns -pte_eos if decoding reached the end of the Intel PT buffer.
 * Returns -pte_invalid if \@decoder or \@event is NULL.
 * Returns -pte_invalid if \@size is too small.
 * Returns -pte_nosync if \@decoder is out of sync.
 */
extern pt_export int pt_qry_event(struct pt_query_decoder *decoder,
				  struct pt_event *event, size_t size);

/** Query the current time.
 *
 * On success, provides the time at \@decoder's current position in \@time.
 * Since \@decoder is reading ahead until the next indirect branch or event,
 * the value matches the time for that branch or event.
 *
 * The time is similar to what a rdtsc instruction would return.  Depending
 * on the configuration, the time may not be fully accurate.  If TSC is not
 * enabled, the time is relative to the last synchronization and can't be used
 * to correlate with other TSC-based time sources.  In this case, -pte_no_time
 * is returned and the relative time is provided in \@time.
 *
 * Some timing-related packets may need to be dropped (mostly due to missing
 * calibration or incomplete configuration).  To get an idea about the quality
 * of the estimated time, we record the number of dropped MTC and CYC packets.
 *
 * If \@lost_mtc is not NULL, set it to the number of lost MTC packets.
 * If \@lost_cyc is not NULL, set it to the number of lost CYC packets.
 *
 * Returns zero on success, a negative error code otherwise.
 *
 * Returns -pte_invalid if \@decoder or \@time is NULL.
 * Returns -pte_no_time if there has not been a TSC packet.
 */
extern pt_export int pt_qry_time(struct pt_query_decoder *decoder,
				 uint64_t *time, uint32_t *lost_mtc,
				 uint32_t *lost_cyc);

/** Return the current core bus ratio.
 *
 * On success, provides the core:bus ratio at \@decoder's current position
 * in \@cbr.
 * Since \@decoder is reading ahead until the next indirect branch or event,
 * the value matches the core:bus ratio for that branch or event.
 *
 * The ratio is defined as core cycles per bus clock cycle.
 *
 * Returns zero on success, a negative error code otherwise.
 *
 * Returns -pte_invalid if \@decoder or \@cbr is NULL.
 * Returns -pte_no_cbr if there has not been a CBR packet.
 */
extern pt_export int pt_qry_core_bus_ratio(struct pt_query_decoder *decoder,
					   uint32_t *cbr);



/* Traced image. */



/** An Intel PT address space identifier.
 *
 * This identifies a particular address space when adding file sections or
 * when reading memory.
 */
struct pt_asid {
	/** The size of this object - set to sizeof(struct pt_asid). */
	size_t size;

	/** The CR3 value. */
	uint64_t cr3;

	/** The VMCS Base address. */
	uint64_t vmcs;
};

/** An unknown CR3 value to be used for pt_asid objects. */
static const uint64_t pt_asid_no_cr3 = 0xffffffffffffffffull;

/** An unknown VMCS Base value to be used for pt_asid objects. */
static const uint64_t pt_asid_no_vmcs = 0xffffffffffffffffull;

/** Initialize an address space identifier. */
static inline void pt_asid_init(struct pt_asid *asid)
{
	asid->size = sizeof(*asid);
	asid->cr3 = pt_asid_no_cr3;
	asid->vmcs = pt_asid_no_vmcs;
}


/** The traced memory image. */
struct pt_image;


/** Allocate a traced memory image.
 *
 * An optional \@name may be given to the image.  The name string is copied.
 *
 * Returns a new traced memory image on success, NULL otherwise.
 */
extern pt_export struct pt_image *pt_image_alloc(const char *name);

/** Free a traced memory image.
 *
 * The \@image must have been allocated with pt_image_alloc().
 * The \@image must not be used after a successful return.
 */
extern pt_export void pt_image_free(struct pt_image *image);

/** Get the image name.
 *
 * Returns a pointer to \@image's name or NULL if there is no name.
 */
extern pt_export const char *pt_image_name(const struct pt_image *image);

/** Add a new file section to the traced memory image.
 *
 * Adds \@size bytes starting at \@offset in \@filename. The section is
 * loaded at the virtual address \@vaddr in the address space \@asid.
 *
 * The \@asid may be NULL or (partially) invalid.  In that case only the valid
 * fields are considered when comparing with other address-spaces.  Use this
 * when tracing a single process or when adding sections to all processes.
 *
 * The section is silently truncated to match the size of \@filename.
 *
 * Returns zero on success, a negative error code otherwise.
 *
 * Returns -pte_bad_image if sections would overlap.
 * Returns -pte_invalid if \@image or \@filename is NULL.
 * Returns -pte_invalid if \@offset is too big.
 */
extern pt_export int pt_image_add_file(struct pt_image *image,
				       const char *filename, uint64_t offset,
				       uint64_t size,
				       const struct pt_asid *asid,
				       uint64_t vaddr);

/** Copy an image.
 *
 * Adds all sections from \@src to \@image.  Sections that would overlap with
 * existing sections will be ignored.
 *
 * Returns the number of ignored images on success, a negative error code
 * otherwise.
 *
 * Returns -pte_invalid if \@image or \@src is NULL.
 */
extern pt_export int pt_image_copy(struct pt_image *image,
				   const struct pt_image *src);

/** Remove all sections loaded from a file.
 *
 * Removes all sections loaded from \@filename from the address space \@asid.
 * Specify the same \@asid that was used for adding sections from \@filename.
 *
 * Returns the number of removed sections on success, a negative error code
 * otherwise.
 *
 * Returns -pte_invalid if \@image or \@filename is NULL.
 */
extern pt_export int pt_image_remove_by_filename(struct pt_image *image,
						 const char *filename,
						 const struct pt_asid *asid);

/** Remove all sections loaded into an address space.
 *
 * Removes all sections loaded into \@asid.  Specify the same \@asid that was
 * used for adding sections.
 *
 * Returns the number of removed sections on success, a negative error code
 * otherwise.
 *
 * Returns -pte_invalid if \@image is NULL.
 */
extern pt_export int pt_image_remove_by_asid(struct pt_image *image,
					     const struct pt_asid *asid);

/** A read memory callback function.
 *
 * It shall read \@size bytes of memory from address space \@asid starting
 * at \@ip into \@buffer.
 *
 * It shall return the number of bytes read on success.
 * It shall return a negative pt_error_code otherwise.
 */
typedef int (read_memory_callback_t)(uint8_t *buffer, size_t size,
				     const struct pt_asid *asid,
				     uint64_t ip, void *context);

/** Set the memory callback for the traced memory image.
 *
 * Sets \@callback for reading memory.  The callback is used for addresses
 * that are not found in file sections.  The \@context argument is passed
 * to \@callback on each use.
 *
 * There can only be one callback at any time.  A subsequent call will replace
 * the previous callback.  If \@callback is NULL, the callback is removed.
 *
 * Returns -pte_invalid if \@image is NULL.
 */
extern pt_export int pt_image_set_callback(struct pt_image *image,
					   read_memory_callback_t *callback,
					   void *context);



/* Instruction flow decoder. */



/** The instruction class.
 *
 * We provide only a very coarse classification suitable for reconstructing
 * the execution flow.
 */
enum pt_insn_class {
	/* The instruction could not be classified. */
	ptic_error,

	/* The instruction is something not listed below. */
	ptic_other,

	/* The instruction is a near (function) call. */
	ptic_call,

	/* The instruction is a near (function) return. */
	ptic_return,

	/* The instruction is a near unconditional jump. */
	ptic_jump,

	/* The instruction is a near conditional jump. */
	ptic_cond_jump,

	/* The instruction is a call-like far transfer.
	 * E.g. SYSCALL, SYSENTER, or FAR CALL.
	 */
	ptic_far_call,

	/* The instruction is a return-like far transfer.
	 * E.g. SYSRET, SYSEXIT, IRET, or FAR RET.
	 */
	ptic_far_return,

	/* The instruction is a jump-like far transfer.
	 * E.g. FAR JMP.
	 */
	ptic_far_jump
};

/** The maximal size of an instruction. */
enum {
	pt_max_insn_size	= 15
};

/** A single traced instruction. */
struct pt_insn {
	/** The virtual address in its process. */
	uint64_t ip;

	/** A coarse classification. */
	enum pt_insn_class iclass;

	/** The execution mode. */
	enum pt_exec_mode mode;

	/** The raw bytes. */
	uint8_t raw[pt_max_insn_size];

	/** The size in bytes. */
	uint8_t size;

	/** A collection of flags giving additional information:
	 *
	 * - the instruction was executed speculatively.
	 */
	uint32_t speculative:1;

	/** - speculative execution was aborted after this instruction. */
	uint32_t aborted:1;

	/** - speculative execution was committed after this instruction. */
	uint32_t committed:1;

	/** - tracing was disabled after this instruction. */
	uint32_t disabled:1;

	/** - tracing was enabled at this instruction. */
	uint32_t enabled:1;

	/** - tracing was resumed at this instruction.
	 *
	 *    In addition to tracing being enabled, it continues from the IP
	 *    at which tracing had been disabled before.
	 */
	uint32_t resumed:1;

	/** - normal execution flow was interrupted after this instruction. */
	uint32_t interrupted:1;

	/** - tracing resumed at this instruction after an overflow. */
	uint32_t resynced:1;

	/** - tracing was stopped after this instruction. */
	uint32_t stopped:1;
};


/** Allocate an Intel PT instruction flow decoder.
 *
 * The decoder will work on the buffer defined in \@config, it shall contain
 * raw trace data and remain valid for the lifetime of the decoder.
 *
 * The decoder needs to be synchronized before it can be used.
 */
extern pt_export struct pt_insn_decoder *
pt_insn_alloc_decoder(const struct pt_config *config);

/** Free an Intel PT instruction flow decoder.
 *
 * This will destroy the decoder's default image.
 *
 * The \@decoder must not be used after a successful return.
 */
extern pt_export void pt_insn_free_decoder(struct pt_insn_decoder *decoder);

/** Synchronize an Intel PT instruction flow decoder.
 *
 * Search for the next synchronization point in forward or backward direction.
 *
 * If \@decoder has not been synchronized, yet, the search is started at the
 * beginning of the trace buffer in case of forward synchronization and at the
 * end of the trace buffer in case of backward synchronization.
 *
 * Returns zero or a positive value on success, a negative error code otherwise.
 *
 * Returns -pte_bad_opc if an unknown packet is encountered.
 * Returns -pte_bad_packet if an unknown packet payload is encountered.
 * Returns -pte_eos if no further synchronization point is found.
 * Returns -pte_invalid if \@decoder is NULL.
 */
extern pt_export int pt_insn_sync_forward(struct pt_insn_decoder *decoder);
extern pt_export int pt_insn_sync_backward(struct pt_insn_decoder *decoder);

/** Manually synchronize an Intel PT instruction flow decoder.
 *
 * Synchronize \@decoder on the syncpoint at \@offset.  There must be a PSB
 * packet at \@offset.
 *
 * Returns zero or a positive value on success, a negative error code otherwise.
 *
 * Returns -pte_bad_opc if an unknown packet is encountered.
 * Returns -pte_bad_packet if an unknown packet payload is encountered.
 * Returns -pte_eos if \@offset lies outside of \@decoder's trace buffer.
 * Returns -pte_eos if \@decoder reaches the end of its trace buffer.
 * Returns -pte_invalid if \@decoder is NULL.
 * Returns -pte_nosync if there is no syncpoint at \@offset.
 */
extern pt_export int pt_insn_sync_set(struct pt_insn_decoder *decoder,
				      uint64_t offset);

/** Get the current decoder position.
 *
 * Fills the current \@decoder position into \@offset.
 *
 * This is useful for reporting errors.
 *
 * Returns zero on success, a negative error code otherwise.
 *
 * Returns -pte_invalid if \@decoder or \@offset is NULL.
 * Returns -pte_nosync if \@decoder is out of sync.
 */
extern pt_export int pt_insn_get_offset(struct pt_insn_decoder *decoder,
					uint64_t *offset);

/** Get the position of the last synchronization point.
 *
 * Fills the last synchronization position into \@offset.
 *
 * Returns zero on success, a negative error code otherwise.
 *
 * Returns -pte_invalid if \@decoder or \@offset is NULL.
 * Returns -pte_nosync if \@decoder is out of sync.
 */
extern pt_export int pt_insn_get_sync_offset(struct pt_insn_decoder *decoder,
					     uint64_t *offset);

/** Get the traced image.
 *
 * The returned image may be modified as long as no decoder that uses this
 * image is running.
 *
 * Returns a pointer to the traced image the decoder uses for reading memory.
 * Returns NULL if \@decoder is NULL.
 */
extern pt_export struct pt_image *
pt_insn_get_image(struct pt_insn_decoder *decoder);

/** Set the traced image.
 *
 * Sets the image that \@decoder uses for reading memory to \@image.  If \@image
 * is NULL, sets the image to \@decoder's default image.
 *
 * Only one image can be active at any time.
 *
 * Returns zero on success, a negative error code otherwise.
 * Return -pte_invalid if \@decoder is NULL.
 */
extern pt_export int pt_insn_set_image(struct pt_insn_decoder *decoder,
				       struct pt_image *image);

/* Return a pointer to \@decoder's configuration.
 *
 * Returns a non-null pointer on success, NULL if \@decoder is NULL.
 */
extern pt_export const struct pt_config *
pt_insn_get_config(const struct pt_insn_decoder *decoder);

/** Return the current time.
 *
 * On success, provides the time at \@decoder's current position in \@time.
 * Since \@decoder is reading ahead until the next indirect branch or event,
 * the value matches the time for that branch or event.
 *
 * The time is similar to what a rdtsc instruction would return.  Depending
 * on the configuration, the time may not be fully accurate.  If TSC is not
 * enabled, the time is relative to the last synchronization and can't be used
 * to correlate with other TSC-based time sources.  In this case, -pte_no_time
 * is returned and the relative time is provided in \@time.
 *
 * Some timing-related packets may need to be dropped (mostly due to missing
 * calibration or incomplete configuration).  To get an idea about the quality
 * of the estimated time, we record the number of dropped MTC and CYC packets.
 *
 * If \@lost_mtc is not NULL, set it to the number of lost MTC packets.
 * If \@lost_cyc is not NULL, set it to the number of lost CYC packets.
 *
 * Returns zero on success, a negative error code otherwise.
 *
 * Returns -pte_invalid if \@decoder or \@time is NULL.
 * Returns -pte_no_time if there has not been a TSC packet.
 */
extern pt_export int pt_insn_time(struct pt_insn_decoder *decoder,
				  uint64_t *time, uint32_t *lost_mtc,
				  uint32_t *lost_cyc);

/** Return the current core bus ratio.
 *
 * On success, provides the core:bus ratio at \@decoder's current position
 * in \@cbr.
 * Since \@decoder is reading ahead until the next indirect branch or event,
 * the value matches the core:bus ratio for that branch or event.
 *
 * The ratio is defined as core cycles per bus clock cycle.
 *
 * Returns zero on success, a negative error code otherwise.
 *
 * Returns -pte_invalid if \@decoder or \@cbr is NULL.
 * Returns -pte_no_cbr if there has not been a CBR packet.
 */
extern pt_export int pt_insn_core_bus_ratio(struct pt_insn_decoder *decoder,
					    uint32_t *cbr);

/** Determine the next instruction.
 *
 * On success, provides the next instruction in execution order in \@insn.
 *
 * The \@size argument must be set to sizeof(struct pt_insn).
 *
 * Returns a non-negative pt_status_flag bit-vector on success, a negative error
 * code otherwise.
 *
 * Returns pts_eos to indicate the end of the trace stream.  Subsequent calls
 * to pt_insn_next() will continue to return pts_eos until trace is required
 * to determine the next instruction.
 *
 * Returns -pte_bad_context if the decoder encountered an unexpected packet.
 * Returns -pte_bad_opc if the decoder encountered unknown packets.
 * Returns -pte_bad_packet if the decoder encountered unknown packet payloads.
 * Returns -pte_bad_query if the decoder got out of sync.
 * Returns -pte_eos if decoding reached the end of the Intel PT buffer.
 * Returns -pte_invalid if \@decoder or \@insn is NULL.
 * Returns -pte_nomap if the memory at the instruction address can't be read.
 * Returns -pte_nosync if \@decoder is out of sync.
 */
extern pt_export int pt_insn_next(struct pt_insn_decoder *decoder,
				  struct pt_insn *insn, size_t size);

#ifdef __cplusplus
}
#endif

#endif /* INTEL_PT_H */

```

`PtControlApp/decoder/libipt.txt`:

```txt
Microsoft (R) COFF/PE Dumper Version 14.00.24213.1
Copyright (C) Microsoft Corporation.  All rights reserved.


Dump of file libipt.lib

File Type: LIBRARY

Archive member name at 8: /               
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
     B10 size
correct header end

    107 public symbols

     16AA __IMPORT_DESCRIPTOR_libipt
     18D0 __NULL_IMPORT_DESCRIPTOR
     1A06 libipt_NULL_THUNK_DATA
     1DDE __imp__pt_errstr
     1DDE _pt_errstr
     2844 __imp__pt_pkt_alloc_decoder
     2844 _pt_pkt_alloc_decoder
     28B6 __imp__pt_pkt_free_decoder
     28B6 _pt_pkt_free_decoder
     2B50 __imp__pt_pkt_sync_forward
     2B50 _pt_pkt_sync_forward
     2ADE __imp__pt_pkt_sync_backward
     2ADE _pt_pkt_sync_backward
     2BC0 __imp__pt_pkt_sync_set
     2BC0 _pt_pkt_sync_set
     2994 __imp__pt_pkt_get_offset
     2994 _pt_pkt_get_offset
     2A02 __imp__pt_pkt_get_sync_offset
     2A02 _pt_pkt_get_sync_offset
     2926 __imp__pt_pkt_get_config
     2926 _pt_pkt_get_config
     2A76 __imp__pt_pkt_next
     2A76 _pt_pkt_next
     2C2C __imp__pt_qry_alloc_decoder
     2C2C _pt_qry_alloc_decoder
     2DEA __imp__pt_qry_free_decoder
     2DEA _pt_qry_free_decoder
     3090 __imp__pt_qry_sync_forward
     3090 _pt_qry_sync_forward
     301E __imp__pt_qry_sync_backward
     301E _pt_qry_sync_backward
     3100 __imp__pt_qry_sync_set
     3100 _pt_qry_sync_set
     2EC8 __imp__pt_qry_get_offset
     2EC8 _pt_qry_get_offset
     2F36 __imp__pt_qry_get_sync_offset
     2F36 _pt_qry_get_sync_offset
     2E5A __imp__pt_qry_get_config
     2E5A _pt_qry_get_config
     2C9E __imp__pt_qry_cond_branch
     2C9E _pt_qry_cond_branch
     2FAA __imp__pt_qry_indirect_branch
     2FAA _pt_qry_indirect_branch
     2D80 __imp__pt_qry_event
     2D80 _pt_qry_event
     316C __imp__pt_qry_time
     316C _pt_qry_time
     2D0E __imp__pt_qry_core_bus_ratio
     2D0E _pt_qry_core_bus_ratio
     1B56 __imp__pt_alloc_encoder
     1B56 _pt_alloc_encoder
     1E44 __imp__pt_free_encoder
     1E44 _pt_free_encoder
     1D72 __imp__pt_enc_sync_set
     1D72 _pt_enc_sync_set
     1C9C __imp__pt_enc_get_offset
     1C9C _pt_enc_get_offset
     1C2E __imp__pt_enc_get_config
     1C2E _pt_enc_get_config
     1D0A __imp__pt_enc_next
     1D0A _pt_enc_next
     27D4 __imp__pt_library_version
     27D4 _pt_library_version
     1F1E __imp__pt_image_alloc
     1F1E _pt_image_alloc
     1FF4 __imp__pt_image_free
     1FF4 _pt_image_free
     205E __imp__pt_image_name
     205E _pt_image_name
     1EB0 __imp__pt_image_add_file
     1EB0 _pt_image_add_file
     1F8A __imp__pt_image_copy
     1F8A _pt_image_copy
     213C __imp__pt_image_remove_by_filename
     213C _pt_image_remove_by_filename
     20C8 __imp__pt_image_remove_by_asid
     20C8 _pt_image_remove_by_asid
     21B4 __imp__pt_image_set_callback
     21B4 _pt_image_set_callback
     2226 __imp__pt_insn_alloc_decoder
     2226 _pt_insn_alloc_decoder
     230C __imp__pt_insn_free_decoder
     230C _pt_insn_free_decoder
     268A __imp__pt_insn_sync_forward
     268A _pt_insn_sync_forward
     2618 __imp__pt_insn_sync_backward
     2618 _pt_insn_sync_backward
     26FC __imp__pt_insn_sync_set
     26FC _pt_insn_sync_set
     245C __imp__pt_insn_get_offset
     245C _pt_insn_get_offset
     24CC __imp__pt_insn_get_sync_offset
     24CC _pt_insn_get_sync_offset
     23EE __imp__pt_insn_get_image
     23EE _pt_insn_get_image
     25AA __imp__pt_insn_set_image
     25AA _pt_insn_set_image
     237E __imp__pt_insn_get_config
     237E _pt_insn_get_config
     276A __imp__pt_insn_time
     276A _pt_insn_time
     2298 __imp__pt_insn_core_bus_ratio
     2298 _pt_insn_core_bus_ratio
     2540 __imp__pt_insn_next
     2540 _pt_insn_next
     1BC4 __imp__pt_cpu_errata
     1BC4 _pt_cpu_errata

Archive member name at B54: /               
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
     B1A size
correct header end

    55 offsets

        1     16AA
        2     18D0
        3     1A06
        4     1DDE
        5     2844
        6     28B6
        7     2B50
        8     2ADE
        9     2BC0
        A     2994
        B     2A02
        C     2926
        D     2A76
        E     2C2C
        F     2DEA
       10     3090
       11     301E
       12     3100
       13     2EC8
       14     2F36
       15     2E5A
       16     2C9E
       17     2FAA
       18     2D80
       19     316C
       1A     2D0E
       1B     1B56
       1C     1E44
       1D     1D72
       1E     1C9C
       1F     1C2E
       20     1D0A
       21     27D4
       22     1F1E
       23     1FF4
       24     205E
       25     1EB0
       26     1F8A
       27     213C
       28     20C8
       29     21B4
       2A     2226
       2B     230C
       2C     268A
       2D     2618
       2E     26FC
       2F     245C
       30     24CC
       31     23EE
       32     25AA
       33     237E
       34     276A
       35     2298
       36     2540
       37     1BC4

    107 public symbols

        1 __IMPORT_DESCRIPTOR_libipt
        2 __NULL_IMPORT_DESCRIPTOR
       1B __imp__pt_alloc_encoder
       37 __imp__pt_cpu_errata
       1F __imp__pt_enc_get_config
       1E __imp__pt_enc_get_offset
       20 __imp__pt_enc_next
       1D __imp__pt_enc_sync_set
        4 __imp__pt_errstr
       1C __imp__pt_free_encoder
       25 __imp__pt_image_add_file
       22 __imp__pt_image_alloc
       26 __imp__pt_image_copy
       23 __imp__pt_image_free
       24 __imp__pt_image_name
       28 __imp__pt_image_remove_by_asid
       27 __imp__pt_image_remove_by_filename
       29 __imp__pt_image_set_callback
       2A __imp__pt_insn_alloc_decoder
       35 __imp__pt_insn_core_bus_ratio
       2B __imp__pt_insn_free_decoder
       33 __imp__pt_insn_get_config
       31 __imp__pt_insn_get_image
       2F __imp__pt_insn_get_offset
       30 __imp__pt_insn_get_sync_offset
       36 __imp__pt_insn_next
       32 __imp__pt_insn_set_image
       2D __imp__pt_insn_sync_backward
       2C __imp__pt_insn_sync_forward
       2E __imp__pt_insn_sync_set
       34 __imp__pt_insn_time
       21 __imp__pt_library_version
        5 __imp__pt_pkt_alloc_decoder
        6 __imp__pt_pkt_free_decoder
        C __imp__pt_pkt_get_config
        A __imp__pt_pkt_get_offset
        B __imp__pt_pkt_get_sync_offset
        D __imp__pt_pkt_next
        8 __imp__pt_pkt_sync_backward
        7 __imp__pt_pkt_sync_forward
        9 __imp__pt_pkt_sync_set
        E __imp__pt_qry_alloc_decoder
       16 __imp__pt_qry_cond_branch
       1A __imp__pt_qry_core_bus_ratio
       18 __imp__pt_qry_event
        F __imp__pt_qry_free_decoder
       15 __imp__pt_qry_get_config
       13 __imp__pt_qry_get_offset
       14 __imp__pt_qry_get_sync_offset
       17 __imp__pt_qry_indirect_branch
       11 __imp__pt_qry_sync_backward
       10 __imp__pt_qry_sync_forward
       12 __imp__pt_qry_sync_set
       19 __imp__pt_qry_time
       1B _pt_alloc_encoder
       37 _pt_cpu_errata
       1F _pt_enc_get_config
       1E _pt_enc_get_offset
       20 _pt_enc_next
       1D _pt_enc_sync_set
        4 _pt_errstr
       1C _pt_free_encoder
       25 _pt_image_add_file
       22 _pt_image_alloc
       26 _pt_image_copy
       23 _pt_image_free
       24 _pt_image_name
       28 _pt_image_remove_by_asid
       27 _pt_image_remove_by_filename
       29 _pt_image_set_callback
       2A _pt_insn_alloc_decoder
       35 _pt_insn_core_bus_ratio
       2B _pt_insn_free_decoder
       33 _pt_insn_get_config
       31 _pt_insn_get_image
       2F _pt_insn_get_offset
       30 _pt_insn_get_sync_offset
       36 _pt_insn_next
       32 _pt_insn_set_image
       2D _pt_insn_sync_backward
       2C _pt_insn_sync_forward
       2E _pt_insn_sync_set
       34 _pt_insn_time
       21 _pt_library_version
        5 _pt_pkt_alloc_decoder
        6 _pt_pkt_free_decoder
        C _pt_pkt_get_config
        A _pt_pkt_get_offset
        B _pt_pkt_get_sync_offset
        D _pt_pkt_next
        8 _pt_pkt_sync_backward
        7 _pt_pkt_sync_forward
        9 _pt_pkt_sync_set
        E _pt_qry_alloc_decoder
       16 _pt_qry_cond_branch
       1A _pt_qry_core_bus_ratio
       18 _pt_qry_event
        F _pt_qry_free_decoder
       15 _pt_qry_get_config
       13 _pt_qry_get_offset
       14 _pt_qry_get_sync_offset
       17 _pt_qry_indirect_branch
       11 _pt_qry_sync_backward
       10 _pt_qry_sync_forward
       12 _pt_qry_sync_set
       19 _pt_qry_time
        3 libipt_NULL_THUNK_DATA

Archive member name at 16AA: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
     1EA size
correct header end

FILE HEADER VALUES
             14C machine (x86)
               3 number of sections
        576C57B6 time date stamp Thu Jun 23 22:42:14 2016
             10A file pointer to symbol table
               8 number of symbols
               0 size of optional header
             100 characteristics
                   32 bit word machine

SECTION HEADER #1
.debug$S name
       0 physical address
       0 virtual address
      40 size of raw data
      8C file pointer to raw data (0000008C to 000000CB)
       0 file pointer to relocation table
       0 file pointer to line numbers
       0 number of relocations
       0 number of line numbers
42100040 flags
         Initialized Data
         Discardable
         1 byte align
         Read Only

RAW DATA #1
  00000000: 02 00 00 00 11 00 09 00 00 00 00 00 0A 6C 69 62  .............lib
  00000010: 69 70 74 2E 64 6C 6C 27 00 13 10 07 00 00 00 03  ipt.dll'........
  00000020: 00 00 00 00 00 00 00 0C 00 00 00 0D 52 12 4D 69  ............R.Mi
  00000030: 63 72 6F 73 6F 66 74 20 28 52 29 20 4C 49 4E 4B  crosoft (R) LINK

SECTION HEADER #2
.idata$2 name
       0 physical address
       0 virtual address
      14 size of raw data
      CC file pointer to raw data (000000CC to 000000DF)
      E0 file pointer to relocation table
       0 file pointer to line numbers
       3 number of relocations
       0 number of line numbers
C0300040 flags
         Initialized Data
         4 byte align
         Read Write

RAW DATA #2
  00000000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  00000010: 00 00 00 00                                      ....

RELOCATIONS #2
                                                Symbol    Symbol
 Offset    Type              Applied To         Index     Name
 --------  ----------------  -----------------  --------  ------
 0000000C  DIR32NB                    00000000         3  .idata$6
 00000000  DIR32NB                    00000000         4  .idata$4
 00000010  DIR32NB                    00000000         5  .idata$5

SECTION HEADER #3
.idata$6 name
       0 physical address
       0 virtual address
       C size of raw data
      FE file pointer to raw data (000000FE to 00000109)
      E0 file pointer to relocation table
       0 file pointer to line numbers
       0 number of relocations
       0 number of line numbers
C0200040 flags
         Initialized Data
         2 byte align
         Read Write

RAW DATA #3
  00000000: 6C 69 62 69 70 74 2E 64 6C 6C 00 00              libipt.dll..

COFF SYMBOL TABLE
000 00DD520D ABS    notype       Static       | @comp.id
001 00000000 SECT2  notype       External     | __IMPORT_DESCRIPTOR_libipt
002 C0000040 SECT2  notype       Section      | .idata$2
003 00000000 SECT3  notype       Static       | .idata$6
004 C0000040 UNDEF  notype       Section      | .idata$4
005 C0000040 UNDEF  notype       Section      | .idata$5
006 00000000 UNDEF  notype       External     | __NULL_IMPORT_DESCRIPTOR
007 00000000 UNDEF  notype       External     | libipt_NULL_THUNK_DATA

String Table Size = 0x50 bytes

Archive member name at 18D0: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      F9 size
correct header end

FILE HEADER VALUES
             14C machine (x86)
               2 number of sections
        576C57B6 time date stamp Thu Jun 23 22:42:14 2016
              B8 file pointer to symbol table
               2 number of symbols
               0 size of optional header
             100 characteristics
                   32 bit word machine

SECTION HEADER #1
.debug$S name
       0 physical address
       0 virtual address
      40 size of raw data
      64 file pointer to raw data (00000064 to 000000A3)
       0 file pointer to relocation table
       0 file pointer to line numbers
       0 number of relocations
       0 number of line numbers
42100040 flags
         Initialized Data
         Discardable
         1 byte align
         Read Only

RAW DATA #1
  00000000: 02 00 00 00 11 00 09 00 00 00 00 00 0A 6C 69 62  .............lib
  00000010: 69 70 74 2E 64 6C 6C 27 00 13 10 07 00 00 00 03  ipt.dll'........
  00000020: 00 00 00 00 00 00 00 0C 00 00 00 0D 52 12 4D 69  ............R.Mi
  00000030: 63 72 6F 73 6F 66 74 20 28 52 29 20 4C 49 4E 4B  crosoft (R) LINK

SECTION HEADER #2
.idata$3 name
       0 physical address
       0 virtual address
      14 size of raw data
      A4 file pointer to raw data (000000A4 to 000000B7)
       0 file pointer to relocation table
       0 file pointer to line numbers
       0 number of relocations
       0 number of line numbers
C0300040 flags
         Initialized Data
         4 byte align
         Read Write

RAW DATA #2
  00000000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  00000010: 00 00 00 00                                      ....

COFF SYMBOL TABLE
000 00DD520D ABS    notype       Static       | @comp.id
001 00000000 SECT2  notype       External     | __NULL_IMPORT_DESCRIPTOR

String Table Size = 0x1D bytes

Archive member name at 1A06: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
     114 size
correct header end

FILE HEADER VALUES
             14C machine (x86)
               3 number of sections
        576C57B6 time date stamp Thu Jun 23 22:42:14 2016
              D4 file pointer to symbol table
               2 number of symbols
               0 size of optional header
             100 characteristics
                   32 bit word machine

SECTION HEADER #1
.debug$S name
       0 physical address
       0 virtual address
      40 size of raw data
      8C file pointer to raw data (0000008C to 000000CB)
       0 file pointer to relocation table
       0 file pointer to line numbers
       0 number of relocations
       0 number of line numbers
42100040 flags
         Initialized Data
         Discardable
         1 byte align
         Read Only

RAW DATA #1
  00000000: 02 00 00 00 11 00 09 00 00 00 00 00 0A 6C 69 62  .............lib
  00000010: 69 70 74 2E 64 6C 6C 27 00 13 10 07 00 00 00 03  ipt.dll'........
  00000020: 00 00 00 00 00 00 00 0C 00 00 00 0D 52 12 4D 69  ............R.Mi
  00000030: 63 72 6F 73 6F 66 74 20 28 52 29 20 4C 49 4E 4B  crosoft (R) LINK

SECTION HEADER #2
.idata$5 name
       0 physical address
       0 virtual address
       4 size of raw data
      CC file pointer to raw data (000000CC to 000000CF)
       0 file pointer to relocation table
       0 file pointer to line numbers
       0 number of relocations
       0 number of line numbers
C0300040 flags
         Initialized Data
         4 byte align
         Read Write

RAW DATA #2
  00000000: 00 00 00 00                                      ....

SECTION HEADER #3
.idata$4 name
       0 physical address
       0 virtual address
       4 size of raw data
      D0 file pointer to raw data (000000D0 to 000000D3)
       0 file pointer to relocation table
       0 file pointer to line numbers
       0 number of relocations
       0 number of line numbers
C0300040 flags
         Initialized Data
         4 byte align
         Read Write

RAW DATA #3
  00000000: 00 00 00 00                                      ....

COFF SYMBOL TABLE
000 00DD520D ABS    notype       Static       | @comp.id
001 00000000 SECT2  notype       External     | libipt_NULL_THUNK_DATA

String Table Size = 0x1C bytes

Archive member name at 1B56: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      31 size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 0000001D
  DLL name     : libipt.dll
  Symbol name  : _pt_alloc_encoder
  Type         : code
  Name type    : no prefix
  Hint         : 0
  Name         : pt_alloc_encoder

Archive member name at 1BC4: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      2E size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 0000001A
  DLL name     : libipt.dll
  Symbol name  : _pt_cpu_errata
  Type         : code
  Name type    : no prefix
  Hint         : 1
  Name         : pt_cpu_errata

Archive member name at 1C2E: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      32 size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 0000001E
  DLL name     : libipt.dll
  Symbol name  : _pt_enc_get_config
  Type         : code
  Name type    : no prefix
  Hint         : 2
  Name         : pt_enc_get_config

Archive member name at 1C9C: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      32 size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 0000001E
  DLL name     : libipt.dll
  Symbol name  : _pt_enc_get_offset
  Type         : code
  Name type    : no prefix
  Hint         : 3
  Name         : pt_enc_get_offset

Archive member name at 1D0A: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      2C size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 00000018
  DLL name     : libipt.dll
  Symbol name  : _pt_enc_next
  Type         : code
  Name type    : no prefix
  Hint         : 4
  Name         : pt_enc_next

Archive member name at 1D72: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      30 size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 0000001C
  DLL name     : libipt.dll
  Symbol name  : _pt_enc_sync_set
  Type         : code
  Name type    : no prefix
  Hint         : 5
  Name         : pt_enc_sync_set

Archive member name at 1DDE: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      2A size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 00000016
  DLL name     : libipt.dll
  Symbol name  : _pt_errstr
  Type         : code
  Name type    : no prefix
  Hint         : 6
  Name         : pt_errstr

Archive member name at 1E44: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      30 size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 0000001C
  DLL name     : libipt.dll
  Symbol name  : _pt_free_encoder
  Type         : code
  Name type    : no prefix
  Hint         : 7
  Name         : pt_free_encoder

Archive member name at 1EB0: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      32 size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 0000001E
  DLL name     : libipt.dll
  Symbol name  : _pt_image_add_file
  Type         : code
  Name type    : no prefix
  Hint         : 8
  Name         : pt_image_add_file

Archive member name at 1F1E: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      2F size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 0000001B
  DLL name     : libipt.dll
  Symbol name  : _pt_image_alloc
  Type         : code
  Name type    : no prefix
  Hint         : 9
  Name         : pt_image_alloc

Archive member name at 1F8A: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      2E size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 0000001A
  DLL name     : libipt.dll
  Symbol name  : _pt_image_copy
  Type         : code
  Name type    : no prefix
  Hint         : 10
  Name         : pt_image_copy

Archive member name at 1FF4: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      2E size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 0000001A
  DLL name     : libipt.dll
  Symbol name  : _pt_image_free
  Type         : code
  Name type    : no prefix
  Hint         : 11
  Name         : pt_image_free

Archive member name at 205E: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      2E size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 0000001A
  DLL name     : libipt.dll
  Symbol name  : _pt_image_name
  Type         : code
  Name type    : no prefix
  Hint         : 12
  Name         : pt_image_name

Archive member name at 20C8: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      38 size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 00000024
  DLL name     : libipt.dll
  Symbol name  : _pt_image_remove_by_asid
  Type         : code
  Name type    : no prefix
  Hint         : 13
  Name         : pt_image_remove_by_asid

Archive member name at 213C: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      3C size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 00000028
  DLL name     : libipt.dll
  Symbol name  : _pt_image_remove_by_filename
  Type         : code
  Name type    : no prefix
  Hint         : 14
  Name         : pt_image_remove_by_filename

Archive member name at 21B4: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      36 size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 00000022
  DLL name     : libipt.dll
  Symbol name  : _pt_image_set_callback
  Type         : code
  Name type    : no prefix
  Hint         : 15
  Name         : pt_image_set_callback

Archive member name at 2226: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      36 size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 00000022
  DLL name     : libipt.dll
  Symbol name  : _pt_insn_alloc_decoder
  Type         : code
  Name type    : no prefix
  Hint         : 16
  Name         : pt_insn_alloc_decoder

Archive member name at 2298: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      37 size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 00000023
  DLL name     : libipt.dll
  Symbol name  : _pt_insn_core_bus_ratio
  Type         : code
  Name type    : no prefix
  Hint         : 17
  Name         : pt_insn_core_bus_ratio

Archive member name at 230C: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      35 size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 00000021
  DLL name     : libipt.dll
  Symbol name  : _pt_insn_free_decoder
  Type         : code
  Name type    : no prefix
  Hint         : 18
  Name         : pt_insn_free_decoder

Archive member name at 237E: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      33 size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 0000001F
  DLL name     : libipt.dll
  Symbol name  : _pt_insn_get_config
  Type         : code
  Name type    : no prefix
  Hint         : 19
  Name         : pt_insn_get_config

Archive member name at 23EE: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      32 size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 0000001E
  DLL name     : libipt.dll
  Symbol name  : _pt_insn_get_image
  Type         : code
  Name type    : no prefix
  Hint         : 20
  Name         : pt_insn_get_image

Archive member name at 245C: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      33 size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 0000001F
  DLL name     : libipt.dll
  Symbol name  : _pt_insn_get_offset
  Type         : code
  Name type    : no prefix
  Hint         : 21
  Name         : pt_insn_get_offset

Archive member name at 24CC: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      38 size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 00000024
  DLL name     : libipt.dll
  Symbol name  : _pt_insn_get_sync_offset
  Type         : code
  Name type    : no prefix
  Hint         : 22
  Name         : pt_insn_get_sync_offset

Archive member name at 2540: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      2D size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 00000019
  DLL name     : libipt.dll
  Symbol name  : _pt_insn_next
  Type         : code
  Name type    : no prefix
  Hint         : 23
  Name         : pt_insn_next

Archive member name at 25AA: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      32 size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 0000001E
  DLL name     : libipt.dll
  Symbol name  : _pt_insn_set_image
  Type         : code
  Name type    : no prefix
  Hint         : 24
  Name         : pt_insn_set_image

Archive member name at 2618: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      36 size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 00000022
  DLL name     : libipt.dll
  Symbol name  : _pt_insn_sync_backward
  Type         : code
  Name type    : no prefix
  Hint         : 25
  Name         : pt_insn_sync_backward

Archive member name at 268A: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      35 size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 00000021
  DLL name     : libipt.dll
  Symbol name  : _pt_insn_sync_forward
  Type         : code
  Name type    : no prefix
  Hint         : 26
  Name         : pt_insn_sync_forward

Archive member name at 26FC: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      31 size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 0000001D
  DLL name     : libipt.dll
  Symbol name  : _pt_insn_sync_set
  Type         : code
  Name type    : no prefix
  Hint         : 27
  Name         : pt_insn_sync_set

Archive member name at 276A: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      2D size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 00000019
  DLL name     : libipt.dll
  Symbol name  : _pt_insn_time
  Type         : code
  Name type    : no prefix
  Hint         : 28
  Name         : pt_insn_time

Archive member name at 27D4: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      33 size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 0000001F
  DLL name     : libipt.dll
  Symbol name  : _pt_library_version
  Type         : code
  Name type    : no prefix
  Hint         : 29
  Name         : pt_library_version

Archive member name at 2844: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      35 size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 00000021
  DLL name     : libipt.dll
  Symbol name  : _pt_pkt_alloc_decoder
  Type         : code
  Name type    : no prefix
  Hint         : 30
  Name         : pt_pkt_alloc_decoder

Archive member name at 28B6: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      34 size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 00000020
  DLL name     : libipt.dll
  Symbol name  : _pt_pkt_free_decoder
  Type         : code
  Name type    : no prefix
  Hint         : 31
  Name         : pt_pkt_free_decoder

Archive member name at 2926: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      32 size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 0000001E
  DLL name     : libipt.dll
  Symbol name  : _pt_pkt_get_config
  Type         : code
  Name type    : no prefix
  Hint         : 32
  Name         : pt_pkt_get_config

Archive member name at 2994: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      32 size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 0000001E
  DLL name     : libipt.dll
  Symbol name  : _pt_pkt_get_offset
  Type         : code
  Name type    : no prefix
  Hint         : 33
  Name         : pt_pkt_get_offset

Archive member name at 2A02: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      37 size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 00000023
  DLL name     : libipt.dll
  Symbol name  : _pt_pkt_get_sync_offset
  Type         : code
  Name type    : no prefix
  Hint         : 34
  Name         : pt_pkt_get_sync_offset

Archive member name at 2A76: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      2C size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 00000018
  DLL name     : libipt.dll
  Symbol name  : _pt_pkt_next
  Type         : code
  Name type    : no prefix
  Hint         : 35
  Name         : pt_pkt_next

Archive member name at 2ADE: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      35 size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 00000021
  DLL name     : libipt.dll
  Symbol name  : _pt_pkt_sync_backward
  Type         : code
  Name type    : no prefix
  Hint         : 36
  Name         : pt_pkt_sync_backward

Archive member name at 2B50: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      34 size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 00000020
  DLL name     : libipt.dll
  Symbol name  : _pt_pkt_sync_forward
  Type         : code
  Name type    : no prefix
  Hint         : 37
  Name         : pt_pkt_sync_forward

Archive member name at 2BC0: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      30 size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 0000001C
  DLL name     : libipt.dll
  Symbol name  : _pt_pkt_sync_set
  Type         : code
  Name type    : no prefix
  Hint         : 38
  Name         : pt_pkt_sync_set

Archive member name at 2C2C: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      35 size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 00000021
  DLL name     : libipt.dll
  Symbol name  : _pt_qry_alloc_decoder
  Type         : code
  Name type    : no prefix
  Hint         : 39
  Name         : pt_qry_alloc_decoder

Archive member name at 2C9E: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      33 size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 0000001F
  DLL name     : libipt.dll
  Symbol name  : _pt_qry_cond_branch
  Type         : code
  Name type    : no prefix
  Hint         : 40
  Name         : pt_qry_cond_branch

Archive member name at 2D0E: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      36 size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 00000022
  DLL name     : libipt.dll
  Symbol name  : _pt_qry_core_bus_ratio
  Type         : code
  Name type    : no prefix
  Hint         : 41
  Name         : pt_qry_core_bus_ratio

Archive member name at 2D80: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      2D size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 00000019
  DLL name     : libipt.dll
  Symbol name  : _pt_qry_event
  Type         : code
  Name type    : no prefix
  Hint         : 42
  Name         : pt_qry_event

Archive member name at 2DEA: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      34 size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 00000020
  DLL name     : libipt.dll
  Symbol name  : _pt_qry_free_decoder
  Type         : code
  Name type    : no prefix
  Hint         : 43
  Name         : pt_qry_free_decoder

Archive member name at 2E5A: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      32 size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 0000001E
  DLL name     : libipt.dll
  Symbol name  : _pt_qry_get_config
  Type         : code
  Name type    : no prefix
  Hint         : 44
  Name         : pt_qry_get_config

Archive member name at 2EC8: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      32 size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 0000001E
  DLL name     : libipt.dll
  Symbol name  : _pt_qry_get_offset
  Type         : code
  Name type    : no prefix
  Hint         : 45
  Name         : pt_qry_get_offset

Archive member name at 2F36: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      37 size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 00000023
  DLL name     : libipt.dll
  Symbol name  : _pt_qry_get_sync_offset
  Type         : code
  Name type    : no prefix
  Hint         : 46
  Name         : pt_qry_get_sync_offset

Archive member name at 2FAA: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      37 size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 00000023
  DLL name     : libipt.dll
  Symbol name  : _pt_qry_indirect_branch
  Type         : code
  Name type    : no prefix
  Hint         : 47
  Name         : pt_qry_indirect_branch

Archive member name at 301E: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      35 size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 00000021
  DLL name     : libipt.dll
  Symbol name  : _pt_qry_sync_backward
  Type         : code
  Name type    : no prefix
  Hint         : 48
  Name         : pt_qry_sync_backward

Archive member name at 3090: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      34 size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 00000020
  DLL name     : libipt.dll
  Symbol name  : _pt_qry_sync_forward
  Type         : code
  Name type    : no prefix
  Hint         : 49
  Name         : pt_qry_sync_forward

Archive member name at 3100: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      30 size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 0000001C
  DLL name     : libipt.dll
  Symbol name  : _pt_qry_sync_set
  Type         : code
  Name type    : no prefix
  Hint         : 50
  Name         : pt_qry_sync_set

Archive member name at 316C: libipt.dll/     
576C57B6 time/date Thu Jun 23 22:42:14 2016
         uid
         gid
       0 mode
      2C size
correct header end

  Version      : 0
  Machine      : 14C (x86)
  TimeDateStamp: 576C57B6 Thu Jun 23 22:42:14 2016
  SizeOfData   : 00000018
  DLL name     : libipt.dll
  Symbol name  : _pt_qry_time
  Type         : code
  Name type    : no prefix
  Hint         : 51
  Name         : pt_qry_time

     Exports

       ordinal    name

                  _pt_alloc_encoder
                  _pt_cpu_errata
                  _pt_enc_get_config
                  _pt_enc_get_offset
                  _pt_enc_next
                  _pt_enc_sync_set
                  _pt_errstr
                  _pt_free_encoder
                  _pt_image_add_file
                  _pt_image_alloc
                  _pt_image_copy
                  _pt_image_free
                  _pt_image_name
                  _pt_image_remove_by_asid
                  _pt_image_remove_by_filename
                  _pt_image_set_callback
                  _pt_insn_alloc_decoder
                  _pt_insn_core_bus_ratio
                  _pt_insn_free_decoder
                  _pt_insn_get_config
                  _pt_insn_get_image
                  _pt_insn_get_offset
                  _pt_insn_get_sync_offset
                  _pt_insn_next
                  _pt_insn_set_image
                  _pt_insn_sync_backward
                  _pt_insn_sync_forward
                  _pt_insn_sync_set
                  _pt_insn_time
                  _pt_library_version
                  _pt_pkt_alloc_decoder
                  _pt_pkt_free_decoder
                  _pt_pkt_get_config
                  _pt_pkt_get_offset
                  _pt_pkt_get_sync_offset
                  _pt_pkt_next
                  _pt_pkt_sync_backward
                  _pt_pkt_sync_forward
                  _pt_pkt_sync_set
                  _pt_qry_alloc_decoder
                  _pt_qry_cond_branch
                  _pt_qry_core_bus_ratio
                  _pt_qry_event
                  _pt_qry_free_decoder
                  _pt_qry_get_config
                  _pt_qry_get_offset
                  _pt_qry_get_sync_offset
                  _pt_qry_indirect_branch
                  _pt_qry_sync_backward
                  _pt_qry_sync_forward
                  _pt_qry_sync_set
                  _pt_qry_time

  Summary

          C0 .debug$S
          14 .idata$2
          14 .idata$3
           4 .idata$4
           4 .idata$5
           C .idata$6

```

`PtControlApp/decoder/pt_cpu.cpp`:

```cpp
/*
 * Copyright (c) 2013-2016, Intel Corporation
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *  * Neither the name of Intel Corporation nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include "pt_cpuid.h"

#include "intel-pt.h"

#include <limits.h>
#include <stdlib.h>


const char *cpu_vendors[] = {
	"",
	"GenuineIntel"
};

enum {
	pt_cpuid_vendor_size = 12
};

union cpu_vendor {
	/* The raw data returned from cpuid. */
	struct {
		uint32_t ebx;
		uint32_t edx;
		uint32_t ecx;
	} cpuid;

	/* The resulting vendor string. */
	char vendor_string[pt_cpuid_vendor_size];
};

static enum pt_cpu_vendor cpu_vendor(void)
{
	union cpu_vendor vendor;
	uint32_t eax;
	size_t i;

	memset(&vendor, 0, sizeof(vendor));
	eax = 0;

	pt_cpuid(0u, &eax, &vendor.cpuid.ebx, &vendor.cpuid.ecx,
		 &vendor.cpuid.edx);

	for (i = 0; i < sizeof(cpu_vendors)/sizeof(*cpu_vendors); i++)
		if (strncmp(vendor.vendor_string,
			    cpu_vendors[i], pt_cpuid_vendor_size) == 0)
			return (enum pt_cpu_vendor) i;

	return pcv_unknown;
}

static uint32_t cpu_info(void)
{
	uint32_t eax, ebx, ecx, edx;

	eax = 0;
	ebx = 0;
	ecx = 0;
	edx = 0;
	pt_cpuid(1u, &eax, &ebx, &ecx, &edx);

	return eax;
}

int pt_cpu_parse(struct pt_cpu *cpu, const char *s)
{
	const char sep = '/';
	char *endptr;
	long family, model, stepping;

	if (!cpu || !s)
		return -pte_invalid;

	family = strtol(s, &endptr, 0);
	if (s == endptr || *endptr == '\0' || *endptr != sep)
		return -pte_invalid;

	if (family < 0 || family > USHRT_MAX)
		return -pte_invalid;

	/* skip separator */
	s = endptr + 1;

	model = strtol(s, &endptr, 0);
	if (s == endptr || (*endptr != '\0' && *endptr != sep))
		return -pte_invalid;

	if (model < 0 || model > UCHAR_MAX)
		return -pte_invalid;

	if (*endptr == '\0')
		/* stepping was omitted, it defaults to 0 */
		stepping = 0;
	else {
		/* skip separator */
		s = endptr + 1;

		stepping = strtol(s, &endptr, 0);
		if (*endptr != '\0')
			return -pte_invalid;

		if (stepping < 0 || stepping > UCHAR_MAX)
			return -pte_invalid;
	}

	cpu->vendor = pcv_intel;
	cpu->family = (uint16_t) family;
	cpu->model = (uint8_t) model;
	cpu->stepping = (uint8_t) stepping;

	return 0;
}

int pt_cpu_read(struct pt_cpu *cpu)
{
	uint32_t info;
	uint16_t family;

	if (!cpu)
		return -pte_invalid;

	cpu->vendor = cpu_vendor();

	info = cpu_info();

	cpu->family = family = (info>>8) & 0xf;
	if (family == 0xf)
		cpu->family += (info>>20) & 0xf;

	cpu->model = (info>>4) & 0xf;
	if (family == 0x6 || family == 0xf)
		cpu->model += (info>>12) & 0xf0;

	cpu->stepping = (info>>0) & 0xf;

	return 0;
}

```

`PtControlApp/decoder/pt_cpu.h`:

```h
/*
 * Copyright (c) 2013-2016, Intel Corporation
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *  * Neither the name of Intel Corporation nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef PT_CPU_H
#define PT_CPU_H

struct pt_cpu;

/* Parses @s which should be of format family/model[/stepping] and
 * stores the value in @cpu on success.
 * The optional stepping defaults to 0 if omitted.
 *
 * Returns 0 on success.
 * Returns -pte_invalid if @cpu or @s is NULL.
 * Returns -pte_invalid if @s could not be parsed.
 */
extern int pt_cpu_parse(struct pt_cpu *cpu, const char *s);

/* Get the cpu we're running on.
 *
 * Reads the family/model/stepping of the processor on which this function
 * is executed and stores the value in @cpu.
 *
 * Returns zero on success, a negative error code otherwise.
 * Returns -pte_invalid if @cpu is NULL.
 */
extern int pt_cpu_read(struct pt_cpu *cpu);

#endif /* PT_CPU_H */

```

`PtControlApp/decoder/pt_cpuid.cpp`:

```cpp
/*
 * Copyright (c) 2013-2016, Intel Corporation
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *  * Neither the name of Intel Corporation nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include "pt_cpuid.h"

#include <intrin.h>

extern void pt_cpuid(uint32_t leaf, uint32_t *eax, uint32_t *ebx,
		     uint32_t *ecx, uint32_t *edx)
{
	int cpu_info[4];

	__cpuid(cpu_info, leaf);
	*eax = cpu_info[0];
	*ebx = cpu_info[1];
	*ecx = cpu_info[2];
	*edx = cpu_info[3];
}

```

`PtControlApp/decoder/pt_cpuid.h`:

```h
/*
 * Copyright (c) 2013-2016, Intel Corporation
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *  * Neither the name of Intel Corporation nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef PT_CPUID_H
#define PT_CPUID_H

#include <inttypes.h>

/* Execute cpuid with @leaf set in the eax register.
 * The result is stored in @eax, @ebx, @ecx and @edx.
 */
extern void pt_cpuid(uint32_t leaf, uint32_t *eax, uint32_t *ebx,
		     uint32_t *ecx, uint32_t *edx);

#endif /* PT_CPUID_H */

```

`PtControlApp/decoder/pt_last_ip.cpp`:

```cpp
/*
 * Copyright (c) 2013-2016, Intel Corporation
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *  * Neither the name of Intel Corporation nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include "pt_last_ip.h"

#include "intel-pt.h"


void pt_last_ip_init(struct pt_last_ip *last_ip)
{
	if (!last_ip)
		return;

	last_ip->ip = 0ull;
	last_ip->have_ip = 0;
	last_ip->suppressed = 0;
}

int pt_last_ip_query(uint64_t *ip, const struct pt_last_ip *last_ip)
{
	if (!last_ip)
		return -pte_invalid;

	if (!last_ip->have_ip) {
		if (ip)
			*ip = 0ull;
		return -pte_noip;
	}

	if (last_ip->suppressed) {
		if (ip)
			*ip = 0ull;
		return -pte_ip_suppressed;
	}

	if (ip)
		*ip = last_ip->ip;

	return 0;
}

/* Sign-extend a uint64_t value. */
static uint64_t sext(uint64_t val, uint8_t sign)
{
	uint64_t signbit, mask;

	signbit = 1ull << (sign - 1);
	mask = ~0ull << sign;

	return val & signbit ? val | mask : val & ~mask;
}

int pt_last_ip_update_ip(struct pt_last_ip *last_ip,
			 const struct pt_packet_ip *packet,
			 const struct pt_config *config)
{
	(void) config;

	if (!last_ip || !packet)
		return -pte_invalid;

	switch (packet->ipc) {
	case pt_ipc_suppressed:
		last_ip->suppressed = 1;
		return 0;

	case pt_ipc_sext_48:
		last_ip->ip = sext(packet->ip, 48);
		last_ip->have_ip = 1;
		last_ip->suppressed = 0;
		return 0;

	case pt_ipc_update_16:
		last_ip->ip = (last_ip->ip & ~0xffffull)
			| (packet->ip & 0xffffull);
		last_ip->have_ip = 1;
		last_ip->suppressed = 0;
		return 0;

	case pt_ipc_update_32:
		last_ip->ip = (last_ip->ip & ~0xffffffffull)
			| (packet->ip & 0xffffffffull);
		last_ip->have_ip = 1;
		last_ip->suppressed = 0;
		return 0;

	case pt_ipc_update_48:
		last_ip->ip = (last_ip->ip & ~0xffffffffffffull)
			| (packet->ip & 0xffffffffffffull);
		last_ip->have_ip = 1;
		last_ip->suppressed = 0;
		return 0;

	case pt_ipc_full:
		last_ip->ip = packet->ip;
		last_ip->have_ip = 1;
		last_ip->suppressed = 0;
		return 0;
	}

	return -pte_bad_packet;
}

```

`PtControlApp/decoder/pt_last_ip.h`:

```h
/*
 * Copyright (c) 2013-2016, Intel Corporation
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *  * Neither the name of Intel Corporation nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef PT_LAST_IP_H
#define PT_LAST_IP_H

#include <stdint.h>

struct pt_packet_ip;
struct pt_config;


/* Keeping track of the last-ip in Intel PT packets. */
struct pt_last_ip {
	/* The last IP. */
	uint64_t ip;

	/* Flags governing the handling of IP updates and queries:
	 *
	 * - we have seen an IP update.
	 */
	uint32_t have_ip:1;
	/* - the IP has been suppressed in the last update. */
	uint32_t suppressed:1;
};


/* Initialize (or reset) the last-ip. */
extern void pt_last_ip_init(struct pt_last_ip *last_ip);

/* Query the last-ip.
 *
 * If @ip is not NULL, provides the last-ip in @ip on success.
 *
 * Returns zero on success.
 * Returns -pte_invalid if @last_ip is NULL.
 * Returns -pte_noip if there is no last-ip.
 * Returns -pte_ip_suppressed if the last-ip has been suppressed.
 */
extern int pt_last_ip_query(uint64_t *ip, const struct pt_last_ip *last_ip);

/* Update last-ip.
 *
 * Updates @last_ip based on @packet and, if non-null, @config.
 *
 * Returns zero on success.
 * Returns -pte_invalid if @last_ip or @packet is NULL.
 * Returns -pte_bad_packet if @packet appears to be corrupted.
 */
extern int pt_last_ip_update_ip(struct pt_last_ip *last_ip,
				const struct pt_packet_ip *packet,
				const struct pt_config *config);

#endif /* PT_LAST_IP_H */

```

`PtControlApp/decoder/pt_time.cpp`:

```cpp
/*
 * Copyright (c) 2014-2016, Intel Corporation
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *  * Neither the name of Intel Corporation nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include "pt_time.h"

#include "intel-pt.h"

#include <string.h>
#include <limits.h>


void pt_time_init(struct pt_time *time)
{
	if (!time)
		return;

	memset(time, 0, sizeof(*time));
}

int pt_time_query_tsc(uint64_t *tsc, uint32_t *lost_mtc,
		      uint32_t *lost_cyc, const struct pt_time *time)
{
	if (!tsc || !time)
		return -pte_internal;

	*tsc = time->tsc;

	if (lost_mtc)
		*lost_mtc = time->lost_mtc;
	if (lost_cyc)
		*lost_cyc = time->lost_cyc;

	if (!time->have_tsc)
		return -pte_no_time;

	return 0;
}

int pt_time_query_cbr(uint32_t *cbr, const struct pt_time *time)
{
	if (!cbr || !time)
		return -pte_internal;

	if (!time->have_cbr)
		return -pte_no_cbr;

	*cbr = time->cbr;

	return 0;
}

/* Compute the distance between two CTC sources.
 *
 * We adjust a single wrap-around but fail if the distance is bigger than that.
 *
 * Returns zero on success, a negative error code otherwise.
 */
static int pt_time_ctc_delta(uint32_t *ctc_delta, uint32_t ctc,
			     uint32_t last_ctc, const struct pt_config *config)
{
	if (!config || !ctc_delta)
		return -pte_internal;

	/* Correct a single wrap-around.  If we lost enough MTCs to wrap
	 * around twice, timing will be wrong until the next TSC.
	 */
	if (ctc < last_ctc) {
		ctc += 1u << (config->mtc_freq + pt_pl_mtc_bit_size);

		/* Since we only store the CTC between TMA/MTC or MTC/TMC a
		 * single correction should suffice.
		 */
		if (ctc < last_ctc)
			return -pte_bad_packet;
	}

	*ctc_delta = ctc - last_ctc;
	return 0;
}

/* Translate CTC into the same unit as the FastCounter by multiplying with P.
 *
 * Returns zero on success, a negative error code otherwise.
 */
static int pt_time_ctc_fc(uint64_t *fc, uint64_t ctc,
			  const struct pt_config *config)
{
	uint32_t eax, ebx;

	if (!fc || !config)
		return -pte_internal;

	eax = config->cpuid_0x15_eax;
	ebx = config->cpuid_0x15_ebx;

	/* Neither multiply nor divide by zero. */
	if (!eax || !ebx)
		return -pte_bad_config;

	*fc = (ctc * ebx) / eax;
	return 0;
}

int pt_time_update_tsc(struct pt_time *time,
		       const struct pt_packet_tsc *packet,
		       const struct pt_config *config)
{
	(void) config;

	if (!time || !packet)
		return -pte_internal;

	time->have_tsc = 1;
	time->have_tma = 0;
	time->tsc = time->base = packet->tsc;
	time->fc = 0ull;

	/* We got the full time; we recover from previous losses. */
	time->lost_mtc = 0;
	time->lost_cyc = 0;

	return 0;
}

int pt_time_update_cbr(struct pt_time *time,
		       const struct pt_packet_cbr *packet,
		       const struct pt_config *config)
{
	(void) config;

	if (!time || !packet)
		return -pte_internal;

	time->have_cbr = 1;
	time->cbr = packet->ratio;

	return 0;
}

int pt_time_update_tma(struct pt_time *time,
		       const struct pt_packet_tma *packet,
		       const struct pt_config *config)
{
	uint32_t ctc, mtc_mask, mtc_offset, mtc_freq;
	uint64_t fc;

	if (!time || !packet || !config)
		return -pte_internal;

	/* Without a TSC something is seriously wrong. */
	if (!time->have_tsc)
		return -pte_bad_context;

	ctc = packet->ctc;
	fc = packet->fc;

	mtc_freq = config->mtc_freq;
	mtc_mask = (1u << mtc_freq) - 1u;
	mtc_offset = ctc & mtc_mask;

	/* Mask out the MTC offset and the high order bits. */
	ctc &= pt_pl_mtc_mask << mtc_freq;

	time->have_tma = 1;
	time->base -= fc;
	time->fc += fc;
	time->mtc_offset = mtc_offset;

	/* If the MTC frequency is low enough that TMA provides the full CTC
	 * value, we're fine.
	 */
	if ((mtc_freq + 8) <= pt_pl_tma_ctc_bit_size) {
		time->ctc = ctc;
		time->ctc_cyc = ctc;

		/* We can use the TMA instead of an MTC. */
		time->have_mtc = 1;
	}
	/* Otherwise, we must rely on either having seen an MTC before or
	 * on heuristically approximating it later at the next MTC.
	 */

	return 0;
}

int pt_time_update_mtc(struct pt_time *time,
		       const struct pt_packet_mtc *packet,
		       const struct pt_config *config)
{
	uint32_t last_ctc, mtc_offset, ctc, ctc_delta;
	uint64_t tsc, base;
	uint8_t mtc_freq;
	int errcode, have_tsc, have_tma, have_mtc;

	if (!time || !packet || !config)
		return -pte_internal;

	have_tsc = time->have_tsc;
	have_tma = time->have_tma;
	have_mtc = time->have_mtc;

	/* We ignore MTCs between TSC and TMA to avoid apparent CTC overflows.
	 * Later MTCs will ensure that no time is lost.
	 */
	if (have_tsc && !have_tma)
		return 0;

	base = time->base;
	last_ctc = time->ctc;
	mtc_offset = time->mtc_offset;
	mtc_freq = config->mtc_freq;

	ctc = packet->ctc << mtc_freq;

	/* Store our CTC value if we have or would have reset FC. */
	if (time->fc || time->lost_cyc || !have_mtc)
		time->ctc_cyc = ctc;

	/* Prepare for the next packet in case we error out below. */
	time->have_mtc = 1;
	time->fc = 0ull;
	time->mtc_offset = 0;
	time->ctc = ctc;

	/* We recover from previous CYC losses. */
	time->lost_cyc = 0;

	/* Avoid a big jump when we see the first MTC with an arbitrary CTC
	 * payload.
	 */
	if (!have_mtc) {
		uint8_t shift;

		/* If we have not seen a TMA, we ignore this first MTC.
		 *
		 * We have no idea where in this MTC period tracing started.
		 * We could lose an entire MTC period or just a tiny fraction.
		 *
		 * On the other hand, if we assumed a previous MTC value, we
		 * might make just the same error.
		 */
		if (!have_tma)
			return 0;

		/* The TMA we've seen provided an offset into the current
		 * MTC period.  Let's assume the last CTC was just small
		 * enough to contain that offset.
		 */
		shift = pt_pl_tma_ctc_bit_size;
		if (shift < mtc_freq)
			shift = mtc_freq;

		ctc_delta = 1u << shift;
	} else {
		/* This is the normal case.  We have seen an MTC before so we
		 * know the previous CTC value.
		 */

		errcode = pt_time_ctc_delta(&ctc_delta, ctc, last_ctc, config);
		if (errcode < 0) {
			time->lost_mtc += 1;
			return errcode;
		}
	}

	/* We don't want a wrap-around here.  Something must be wrong. */
	if (ctc_delta < mtc_offset) {
		time->lost_mtc += 1;
		return -pte_bad_packet;
	}

	ctc_delta -= mtc_offset;

	errcode = pt_time_ctc_fc(&tsc, ctc_delta, config);
	if (errcode < 0)
		return errcode;

	base += tsc;
	time->tsc = time->base = base;

	return 0;
}

/* Adjust a CYC packet's payload spanning multiple MTC periods.
 *
 * CYC packets measure the Fast Counter since the last CYC(-eligible) packet.
 * Depending on the CYC threshold, we may not get a CYC for each MTC, so a CYC
 * period may overlap with or even span multiple MTC periods.
 *
 * We can't do much about the overlap case without examining all packets in
 * the respective periods.  We leave this as expected imprecision.
 *
 * If we find a CYC packet to span multiple MTC packets, though, we try to
 * approximate the portion for the current MTC period by subtracting the
 * estimated portion for previous MTC periods using calibration information.
 *
 * We only consider MTC.  For the first CYC after TSC, the corresponding TMA
 * will contain the Fast Counter at TSC.
 *
 * Returns zero on success, a negative error code otherwise.
 */
static int pt_time_adjust_cyc(uint64_t *cyc, const struct pt_time *time,
			      const struct pt_config *config, uint64_t fcr)
{
	uint32_t last_ctc, ctc, ctc_delta;
	uint64_t fc, total_cyc, old_cyc;
	int errcode;

	if (!time || !config || !fcr)
		return -pte_internal;

	last_ctc = time->ctc_cyc;
	ctc = time->ctc;

	/* There is nothing to do if this is the current MTC period. */
	if (ctc == last_ctc)
		return 0;

	/* Calibration computes
	 *
	 *   fc  = (ctc_delta * cpuid[0x15].ebx) / cpuid[0x15].eax.
	 *   fcr = (fc << pt_tcal_fcr_shr) / cyc
	 *
	 * So cyc = (fc << pt_tcal_fcr_shr) / fcr.
	 */

	errcode = pt_time_ctc_delta(&ctc_delta, ctc, last_ctc, config);
	if (errcode < 0)
		return errcode;

	errcode = pt_time_ctc_fc(&fc, ctc_delta, config);
	if (errcode < 0)
		return errcode;

	old_cyc = (fc << pt_tcal_fcr_shr) / fcr;
	total_cyc = *cyc;

	/* Make sure we don't wrap around.  If we would, attribute the entire
	 * CYC payload to any previous MTC period.
	 *
	 * We lost an unknown portion of the CYC payload for the current MTC
	 * period, but it's usually better to run too slow than too fast.
	 */
	if (total_cyc < old_cyc)
		total_cyc = old_cyc;

	*cyc = total_cyc - old_cyc;
	return 0;
}

int pt_time_update_cyc(struct pt_time *time,
		       const struct pt_packet_cyc *packet,
		       const struct pt_config *config, uint64_t fcr)
{
	uint64_t cyc, fc;

	if (!time || !packet || !config)
		return -pte_internal;

	if (!fcr) {
		time->lost_cyc += 1;
		return 0;
	}

	cyc = packet->value;
	fc = time->fc;
	if (!fc) {
		int errcode;

		errcode = pt_time_adjust_cyc(&cyc, time, config, fcr);
		if (errcode < 0)
			return errcode;
	}

	fc += (cyc * fcr) >> pt_tcal_fcr_shr;

	time->fc = fc;
	time->tsc = time->base + fc;

	return 0;
}

void pt_tcal_init(struct pt_time_cal *tcal)
{
	if (!tcal)
		return;

	memset(tcal, 0, sizeof(*tcal));

	tcal->min_fcr = UINT64_MAX;
}

static int pt_tcal_have_fcr(const struct pt_time_cal *tcal)
{
	if (!tcal)
		return 0;

	return (tcal->min_fcr <= tcal->max_fcr);
}

int pt_tcal_fcr(uint64_t *fcr, const struct pt_time_cal *tcal)
{
	if (!fcr || !tcal)
		return -pte_internal;

	if (!pt_tcal_have_fcr(tcal))
		return -pte_no_time;

	*fcr = tcal->fcr;

	return 0;
}

int pt_tcal_set_fcr(struct pt_time_cal *tcal, uint64_t fcr)
{
	if (!tcal)
		return -pte_internal;

	tcal->fcr = fcr;

	if (fcr < tcal->min_fcr)
		tcal->min_fcr = fcr;

	if (fcr > tcal->max_fcr)
		tcal->max_fcr = fcr;

	return 0;
}

int pt_tcal_update_tsc(struct pt_time_cal *tcal,
		      const struct pt_packet_tsc *packet,
		      const struct pt_config *config)
{
	(void) config;

	if (!tcal || !packet)
		return -pte_internal;

	/* A TSC outside of PSB+ may indicate loss of time.  We do not use it
	 * for calibration.  We store the TSC value for calibration at the next
	 * TSC in PSB+, though.
	 */
	tcal->tsc = packet->tsc;
	tcal->cyc_tsc = 0ull;

	return 0;
}

int pt_tcal_header_tsc(struct pt_time_cal *tcal,
		      const struct pt_packet_tsc *packet,
		      const struct pt_config *config)
{
	uint64_t tsc, last_tsc, tsc_delta, cyc, fcr;

	(void) config;

	if (!tcal || !packet)
		return -pte_internal;

	last_tsc = tcal->tsc;
	cyc = tcal->cyc_tsc;

	tsc = packet->tsc;

	tcal->tsc = tsc;
	tcal->cyc_tsc = 0ull;

	if (!last_tsc || !cyc)
		return 0;

	/* Correct a single wrap-around. */
	if (tsc < last_tsc) {
		tsc += 1ull << pt_pl_tsc_bit_size;

		if (tsc < last_tsc)
			return -pte_bad_packet;
	}

	tsc_delta = tsc - last_tsc;

	/* We shift the nominator to improve rounding precision.
	 *
	 * Since we're only collecting the CYCs between two TSC, we shouldn't
	 * overflow.  Let's rather fail than overflow.
	 */
	if (tsc_delta & ~(~0ull >> pt_tcal_fcr_shr))
		return -pte_internal;

	fcr = (tsc_delta << pt_tcal_fcr_shr) / cyc;

	return pt_tcal_set_fcr(tcal, fcr);
}

int pt_tcal_update_cbr(struct pt_time_cal *tcal,
		      const struct pt_packet_cbr *packet,
		      const struct pt_config *config)
{
	/* A CBR outside of PSB+ indicates a frequency change.  Reset our
	 * calibration state.
	 */
	pt_tcal_init(tcal);

	return pt_tcal_header_cbr(tcal, packet, config);
}

int pt_tcal_header_cbr(struct pt_time_cal *tcal,
		      const struct pt_packet_cbr *packet,
		      const struct pt_config *config)
{
	uint64_t cbr, p1, fcr;

	if (!tcal || !packet || !config)
		return -pte_internal;

	p1 = config->nom_freq;
	if (!p1)
		return 0;

	/* If we know the nominal frequency, we can use it for calibration. */
	cbr = packet->ratio;

	fcr = (p1 << pt_tcal_fcr_shr) / cbr;

	return pt_tcal_set_fcr(tcal, fcr);
}

int pt_tcal_update_tma(struct pt_time_cal *tcal,
		      const struct pt_packet_tma *packet,
		      const struct pt_config *config)
{
	(void) tcal;
	(void) packet;
	(void) config;

	/* Nothing to do. */
	return 0;
}

int pt_tcal_update_mtc(struct pt_time_cal *tcal,
		      const struct pt_packet_mtc *packet,
		      const struct pt_config *config)
{
	uint32_t last_ctc, ctc, ctc_delta, have_mtc;
	uint64_t cyc, fc, fcr;
	int errcode;

	if (!tcal || !packet || !config)
		return -pte_internal;

	last_ctc = tcal->ctc;
	have_mtc = tcal->have_mtc;
	cyc = tcal->cyc_mtc;

	ctc = packet->ctc << config->mtc_freq;

	/* We need at least two MTC (including this). */
	if (!have_mtc) {
		tcal->cyc_mtc = 0ull;
		tcal->ctc = ctc;
		tcal->have_mtc = 1;

		return 0;
	}

	/* Without any cycles, we can't calibrate.  Try again at the next
	 * MTC and distribute the cycles over the combined MTC period.
	 */
	if (!cyc)
		return 0;

	/* Prepare for the next packet in case we error out below. */
	tcal->have_mtc = 1;
	tcal->cyc_mtc = 0ull;
	tcal->ctc = ctc;

	/* Let's pretend we will fail.  We'll correct it at the end. */
	tcal->lost_mtc += 1;

	errcode = pt_time_ctc_delta(&ctc_delta, ctc, last_ctc, config);
	if (errcode < 0)
		return errcode;

	errcode = pt_time_ctc_fc(&fc, ctc_delta, config);
	if (errcode < 0)
		return errcode;

	/* We shift the nominator to improve rounding precision.
	 *
	 * Since we're only collecting the CYCs between two MTC, we shouldn't
	 * overflow.  Let's rather fail than overflow.
	 */
	if (fc & ~(~0ull >> pt_tcal_fcr_shr))
		return -pte_internal;

	fcr = (fc << pt_tcal_fcr_shr) / cyc;

	errcode = pt_tcal_set_fcr(tcal, fcr);
	if (errcode < 0)
		return errcode;

	/* We updated the FCR.  This recovers from previous MTC losses. */
	tcal->lost_mtc = 0;

	return 0;
}

int pt_tcal_update_cyc(struct pt_time_cal *tcal,
		      const struct pt_packet_cyc *packet,
		      const struct pt_config *config)
{
	uint64_t cyc;

	(void) config;

	if (!tcal || !packet)
		return -pte_internal;

	cyc = packet->value;
	tcal->cyc_mtc += cyc;
	tcal->cyc_tsc += cyc;

	return 0;
}

```

`PtControlApp/decoder/pt_time.h`:

```h
/*
 * Copyright (c) 2014-2016, Intel Corporation
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *  * Neither the name of Intel Corporation nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef PT_TIME_H
#define PT_TIME_H

#include <stdint.h>

struct pt_config;
struct pt_packet_tsc;
struct pt_packet_cbr;
struct pt_packet_tma;
struct pt_packet_mtc;
struct pt_packet_cyc;


/* Intel(R) Processor Trace timing. */
struct pt_time {
	/* The estimated Time Stamp Count. */
	uint64_t tsc;

	/* The base Time Stamp Count (from TSC and MTC). */
	uint64_t base;

	/* The estimated Fast Counter. */
	uint64_t fc;

	/* The number of CTC ticks into the current MTC period (from TMA). */
	uint32_t mtc_offset;

	/* The adjusted last CTC value (from MTC and TMA). */
	uint32_t ctc;

	/* The adjusted CTC value when @fc was cleared (from MTC and TMA). */
	uint32_t ctc_cyc;

	/* The number of lost MTC updates. */
	uint32_t lost_mtc;

	/* The number of lost CYC updates. */
	uint32_t lost_cyc;

	/* The core:bus ratio. */
	uint8_t cbr;

	/* A flag saying whether we have seen a TSC packet. */
	uint32_t have_tsc:1;

	/* A flag saying whether we have seen a CBR packet. */
	uint32_t have_cbr:1;

	/* A flag saying whether we have seen a TMA packet. */
	uint32_t have_tma:1;

	/* A flag saying whether we have seen a MTC packet. */
	uint32_t have_mtc:1;
};

/* Initialize (or reset) the time. */
extern void pt_time_init(struct pt_time *time);

/* Query the current time.
 *
 * Provides the estimated Time Stamp Count value in @tsc.
 *
 * If @lost_mtc is not NULL, provides the number of lost MTC packets.
 * If @lost_cyc is not NULL, provides the number of lost CYC packets.
 *
 * Returns zero on success; a negative error code, otherwise.
 * Returns -pte_internal if @tsc or @time is NULL.
 * Returns -pte_no_time if there has not been a TSC packet.
 */
extern int pt_time_query_tsc(uint64_t *tsc, uint32_t *lost_mtc,
			     uint32_t *lost_cyc, const struct pt_time *time);

/* Query the current core:bus ratio.
 *
 * Provides the core:bus ratio in @cbr.
 *
 * Returns zero on success; a negative error code, otherwise.
 * Returns -pte_internal if @cbr or @time is NULL.
 * Returns -pte_no_cbr if there has not been a CBR packet.
 */
extern int pt_time_query_cbr(uint32_t *cbr, const struct pt_time *time);

/* Update the time based on an Intel PT packet.
 *
 * Returns zero on success.
 * Returns a negative error code, otherwise.
 */
extern int pt_time_update_tsc(struct pt_time *, const struct pt_packet_tsc *,
			      const struct pt_config *);
extern int pt_time_update_cbr(struct pt_time *, const struct pt_packet_cbr *,
			      const struct pt_config *);
extern int pt_time_update_tma(struct pt_time *, const struct pt_packet_tma *,
			      const struct pt_config *);
extern int pt_time_update_mtc(struct pt_time *, const struct pt_packet_mtc *,
			      const struct pt_config *);
/* @fcr is the fast-counter:cycles ratio obtained by calibration. */
extern int pt_time_update_cyc(struct pt_time *, const struct pt_packet_cyc *,
			      const struct pt_config *, uint64_t fcr);


/* Timing calibration.
 *
 * Used for estimating the Fast-Counter:Cycles ratio.
 *
 * Ideally, we calibrate by counting CYCs between MTCs.  Lacking MTCs, we
 * use TSC, instead.
 */
struct pt_time_cal {
	/* The estimated fast-counter:cycles ratio. */
	uint64_t fcr;

	/* The minimal and maximal @fcr values. */
	uint64_t min_fcr, max_fcr;

	/* The last TSC value.
	 *
	 * Used for calibrating at TSC.
	 */
	uint64_t tsc;

	/* The number of cycles since the last TSC (from CYC).
	 *
	 * Used for calibrating at TSC.
	 */
	uint64_t cyc_tsc;

	/* The number of cycles since the last MTC (from CYC).
	 *
	 * Used for calibrating at MTC.
	 */
	uint64_t cyc_mtc;

	/* The adjusted last CTC value (from MTC).
	 *
	 * Used for calibrating at MTC.
	 */
	uint32_t ctc;

	/* The number of lost MTC updates since the last successful update. */
	uint32_t lost_mtc;

	/* A flag saying whether we have seen a MTC packet. */
	uint32_t have_mtc:1;
};

enum {
	/* The amount by which the fcr value is right-shifted.
	 *
	 * Do not shift the value obtained by pt_tcal_fcr() when passing it to
	 * pt_time_update_cyc().
	 * Do shift the value passed to pt_tcal_set_fcr().
	 */
	pt_tcal_fcr_shr	= 8
};

/* Initialize of reset timing calibration. */
extern void pt_tcal_init(struct pt_time_cal *tcal);

/* Query the estimated fast-counter:cycles ratio.
 *
 * Provides the estimated ratio in @fcr unless -pte_internal or
 * -pte_no_time is returned.
 *
 * Returns zero on success, a negative error code otherwise.
 * Returns -pte_internal if @fcr or @tcal is NULL.
 * Returns -pte_no_time if no information is available.
 */
extern int pt_tcal_fcr(uint64_t *fcr, const struct pt_time_cal *tcal);

/* Set the fast-counter:cycles ratio.
 *
 * Timing calibration takes one CBR or two MTC packets before it can provide
 * first estimations.  Use this to supply an initial value to be used in the
 * meantime.
 *
 * Returns zero on success, a negative error code otherwise.
 * Returns -pte_internal if @cal is NULL.
 */
extern int pt_tcal_set_fcr(struct pt_time_cal *tcal, uint64_t fcr);

/* Update calibration based on an Intel PT packet.
 *
 * Returns zero on success, a negative error code otherwise.
 */
extern int pt_tcal_update_tsc(struct pt_time_cal *,
			      const struct pt_packet_tsc *,
			      const struct pt_config *);
extern int pt_tcal_header_tsc(struct pt_time_cal *,
			      const struct pt_packet_tsc *,
			      const struct pt_config *);
extern int pt_tcal_update_cbr(struct pt_time_cal *,
			      const struct pt_packet_cbr *,
			      const struct pt_config *);
extern int pt_tcal_header_cbr(struct pt_time_cal *,
			      const struct pt_packet_cbr *,
			      const struct pt_config *);
extern int pt_tcal_update_tma(struct pt_time_cal *,
			      const struct pt_packet_tma *,
			      const struct pt_config *);
extern int pt_tcal_update_mtc(struct pt_time_cal *,
			      const struct pt_packet_mtc *,
			      const struct pt_config *);
extern int pt_tcal_update_cyc(struct pt_time_cal *,
			      const struct pt_packet_cyc *,
			      const struct pt_config *);

#endif /* PT_TIME_H */

```

`PtControlApp/decoder/ptdump.cpp`:

```cpp
/*
 * Copyright (c) 2013-2016, Intel Corporation
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *  * Neither the name of Intel Corporation nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include "..\stdafx.h"
#include "pt_cpu.h"
#include "..\pt_dump.h"

#include <stdlib.h>
#include <stdarg.h>
#include <inttypes.h>
#include <string.h>
#include <stdio.h>
#include <errno.h>

#define PT_VERSION_MAJOR 1
#define PT_VERSION_MINOR 5
#define PT_VERSION_BUILD 0
#define PT_VERSION_EXT ""
#define CRT_SECURE_NO_WARNINGS 1
#pragma comment(lib, "libipt.lib")

ptdump_global g_pt_data;

static int usage(const char *name)
{
	fprintf(stderr,
		"%s: [<options>] <ptfile>.  Use --help or -h for help.\n",
		name);
	return -1;
}

static int no_file_error(const char *name)
{
	fprintf(stderr, "%s: No processor trace file specified.\n", name);
	return -1;
}

static int unknown_option_error(const char *arg, const char *name)
{
	fprintf(stderr, "%s: unknown option: %s.\n", name, arg);
	return -1;
}

static int help(const char *name)
{
	fprintf(stderr,
		"usage: %s [<options>] <ptfile>[:<from>[-<to>]\n\n"
		"options:\n"
		"  --help|-h                 this text.\n"
		"  --version                 display version information and exit.\n"
		"  --no-sync                 don't try to sync to the first PSB, assume a valid\n"
		"                            sync point at the beginning of the trace.\n"
		"  --quiet                   don't print anything but errors.\n"
		"  --no-pad                  don't show PAD packets.\n"
		"  --no-timing               don't show timing packets.\n"
		"  --no-cyc                  don't show CYC packets and ignore them when tracking time.\n"
		"  --no-offset               don't show the offset as the first column.\n"
		"  --raw                     show raw packet bytes.\n"
		"  --lastip                  show last IP updates on packets with IP payloads.\n"
		"  --exec-mode               show the current execution mode on mode.exec packets.\n"
		"  --time                    show the estimated TSC on timing packets.\n"
		"  --tcal                    show time calibration information.\n"
		"  --time-delta              show timing information as delta.\n"
		"  --no-tcal                 skip timing calibration.\n"
		"                            this will result in errors when CYC packets are encountered.\n"
		"  --no-wall-clock           suppress the no-time error and print relative time.\n"
		"  --cpu none|auto|f/m[/s]   set cpu to the given value and decode according to:\n"
		"                              none     spec (default)\n"
		"                              auto     current cpu\n"
		"                              f/m[/s]  family/model[/stepping]\n"
		"  --mtc-freq <n>            set the MTC frequency (IA32_RTIT_CTL[17:14]) to <n>.\n"
		"  --nom-freq <n>            set the nominal frequency (MSR_PLATFORM_INFO[15:8]) to <n>.\n"
		"  --cpuid-0x15.eax          set the value of cpuid[0x15].eax.\n"
		"  --cpuid-0x15.ebx          set the value of cpuid[0x15].ebx.\n"
		"  <ptfile>[:<from>[-<to>]]  load the processor trace data from <ptfile>;\n"
		"                            an optional offset or range can be given.\n",
		name);

	return 0;
}

static int version(const char *name)
{
	struct pt_version v = pt_library_version();

	printf("%s-%d.%d.%d%s / libipt-%" PRIu8 ".%" PRIu8 ".%" PRIu32 "%s\n",
	       name, PT_VERSION_MAJOR, PT_VERSION_MINOR, PT_VERSION_BUILD,
	       PT_VERSION_EXT, v.major, v.minor, v.build, v.ext);
	return 0;
}

static int parse_range(const char *arg, uint64_t *begin, uint64_t *end)
{
	char *rest;

	if (!arg || !*arg)
		return 0;

	errno = 0;
	*begin = strtoull(arg, &rest, 0);
	if (errno)
		return -1;

	if (!*rest)
		return 1;

	if (*rest != '-')
		return -1;

	*end = strtoull(rest+1, &rest, 0);
	if (errno || *rest)
		return -1;

	return 2;
}

// Load the PT binary file:
static int load_file(uint8_t **buffer, size_t *size, char *arg,
		     const char *prog)
{
	uint64_t begin_arg, end_arg;
	uint8_t *content;
	HANDLE hFile = NULL;
	HANDLE hSection = NULL;
	long fsize, begin, end;
	int range_parts;
	char *range;

	if (!buffer || !size || !arg || !prog) {
		fprintf(stderr, "%s: internal error.\n", prog ? prog : "");
		return -1;
	}

	range_parts = 0;
	begin_arg = 0ull;
	end_arg = UINT64_MAX;

	range = strrchr(arg, ':');
	if (range) {
		/* Let's try to parse an optional range suffix.
		 *
		 * If we can, remove it from the filename argument.
		 * If we can not, assume that the ':' is part of the filename,
		 * e.g. a drive letter on Windows.
		 */
		range_parts = parse_range(range + 1, &begin_arg, &end_arg);
		if (range_parts <= 0) {
			begin_arg = 0ull;
			end_arg = UINT64_MAX;

			range_parts = 0;
		} else
			*range = 0;
	}

	errno = 0;
	hFile = CreateFileA(arg, FILE_GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
	//fopen_s(&file, arg, "rb");
	if (hFile == INVALID_HANDLE_VALUE) {
		fprintf(stderr, "%s: failed to open %s: %d.\n",
			prog, arg, errno);
		return -1;
	}

	fsize = SetFilePointer(hFile, 0, 0, FILE_END);
	if (fsize < 0) {
		fprintf(stderr, "%s: failed to determine size of %s: %d.\n",
			prog, arg, errno);
		goto err_file;
	}

	/* Truncate the range to fit into the file unless an explicit range end
	 * was provided.
	 */
	if (range_parts < 2)
		end_arg = (uint64_t) fsize;

	begin = (long) begin_arg;
	end = (long) end_arg;
	if ((uint64_t) begin != begin_arg || (uint64_t) end != end_arg) {
		fprintf(stderr, "%s: invalid offset/range argument.\n", prog);
		goto err_file;
	}

	if (fsize <= begin) {
		fprintf(stderr, "%s: offset 0x%lx outside of %s.\n",
			prog, begin, arg);
		goto err_file;
	}

	if (fsize < end) {
		fprintf(stderr, "%s: range 0x%lx outside of %s.\n",
			prog, end, arg);
		goto err_file;
	}

	if (end <= begin) {
		fprintf(stderr, "%s: bad range.\n", prog);
		goto err_file;
	}

	fsize = end - begin;
	SetFilePointer(hFile, begin, 0, FILE_BEGIN);

	// Use memory mapped file
	hSection = CreateFileMapping((HANDLE)hFile, NULL, PAGE_READONLY, NULL, NULL, NULL);
	content = (uint8_t*)MapViewOfFile(hSection, FILE_MAP_READ, 0, 0, fsize);
	if (!content) {
		fprintf(stderr, "%s: failed to map the input file %s.\n",
			prog, arg);
		goto err_file;
	}

	__try {
		BYTE test = content[0];
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {
		UnmapViewOfFile((LPCVOID)content);
		goto err_file;
	}

	*buffer = content;
	*size = fsize;

	// Update global data on success
	g_pt_data.hInFile = hFile;
	g_pt_data.hInSection = hSection;
	g_pt_data.lpFileContent = (LPCVOID)content;

	return 0;

err_file:
	if (hSection) CloseHandle(hSection);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);
	return -1;
}

// Unload and free the resource of the current loaded input file
static int unload_file() {
	if (g_pt_data.lpFileContent)
		UnmapViewOfFile(g_pt_data.lpFileContent);
	if (g_pt_data.hInSection)
		CloseHandle(g_pt_data.hInSection);
	if (g_pt_data.hInFile)
		CloseHandle(g_pt_data.hInFile);
	return 0;
}


// Load the binary PT file 
static int load_pt(struct pt_config *config, char *arg, const char *prog)
{
	uint8_t *buffer;
	size_t size;
	int errcode;

	errcode = load_file(&buffer, &size, arg, prog);
	if (errcode < 0)
		return errcode;

	config->begin = buffer;
	config->end = buffer + size;

	return 0;
}

static int diag(const char *errstr, uint64_t offset, int errcode)
{
	if (errcode)
		printf("[%" PRIx64 ": %s: %s]\n", offset, errstr,
		       pt_errstr(pt_errcode(errcode)));
	else
		printf("[%" PRIx64 ": %s]\n", offset, errstr);

	return errcode;
}

static void ptdump_tracking_init(struct ptdump_tracking *tracking)
{
	if (!tracking)
		return;

	pt_last_ip_init(&tracking->last_ip);
	pt_tcal_init(&tracking->tcal);
	pt_time_init(&tracking->time);

	tracking->tsc = 0ull;
	tracking->fcr = 0ull;
	tracking->in_header = 0;
}

static void ptdump_tracking_reset(struct ptdump_tracking *tracking)
{
	if (!tracking)
		return;

	pt_last_ip_init(&tracking->last_ip);
	pt_tcal_init(&tracking->tcal);
	pt_time_init(&tracking->time);

	tracking->tsc = 0ull;
	tracking->fcr = 0ull;
	tracking->in_header = 0;
}

static void ptdump_tracking_fini(struct ptdump_tracking *tracking)
{
	(void) tracking;

	/* Nothing to do. */
}

#define print_field(field, ...)					\
	do {							\
		/* Avoid partial overwrites. */			\
		memset(field, 0, sizeof(field));		\
		snprintf(field, sizeof(field), __VA_ARGS__);	\
	} while (0)


//TODO: Modify this to print to a file
static int print_buffer(struct ptdump_buffer *buffer, uint64_t offset,
			const struct ptdump_options *options)
{
	int retCode = 0;
	const char *sep;
	CHAR lpOutStr[0x200] = { 0 };
	DWORD dwBytesIo = 0;

	if (!buffer)
		return diag("error printing buffer", offset, -pte_internal);

	if (buffer->skip || options->quiet)
		return 0;

	/* Make sure the first column starts at the beginning of the line - no
	 * matter what column is first.
	 */
	sep = "";

	if (options->show_offset) {
		sprintf_s(lpOutStr, COUNTOF(lpOutStr), "%s%-*s", lpOutStr, (int) sizeof(buffer->offset), buffer->offset);
		sep = " ";
	}

	if (buffer->raw[0]) {
		sprintf_s(lpOutStr, COUNTOF(lpOutStr), "%s%s%-*s", lpOutStr, sep, (int) sizeof(buffer->raw), buffer->raw);
		sep = " ";
	}

	if (buffer->payload.standard[0])
		sprintf_s(lpOutStr, COUNTOF(lpOutStr), "%s%s%-*s", lpOutStr, sep, (int) sizeof(buffer->opcode),
		       buffer->opcode);
	else
		sprintf_s(lpOutStr, COUNTOF(lpOutStr), "%s%s%s", lpOutStr, sep, buffer->opcode);

	/* We printed at least one column.  From this point on, we don't need
	 * the separator any longer.
	 */

	if (buffer->use_ext_payload)
		sprintf_s(lpOutStr, COUNTOF(lpOutStr), " %s%s", lpOutStr, buffer->payload.extended);
	else if (buffer->tracking.id[0]) {
		sprintf_s(lpOutStr, COUNTOF(lpOutStr), "%s %-*s", lpOutStr, (int) sizeof(buffer->payload.standard),
		       buffer->payload.standard);

		sprintf_s(lpOutStr, COUNTOF(lpOutStr), "%s %-*s", lpOutStr, (int) sizeof(buffer->tracking.id),
		       buffer->tracking.id);
		sprintf_s(lpOutStr, COUNTOF(lpOutStr), "%s%s", lpOutStr, buffer->tracking.payload);
	} else if (buffer->payload.standard[0])
		sprintf_s(lpOutStr, COUNTOF(lpOutStr), "%s%s", lpOutStr, buffer->payload.standard);

	strcat_s(lpOutStr, COUNTOF(lpOutStr), "\r\n");

	if (options->hTargetFile) {
		retCode = WriteFile(options->hTargetFile, lpOutStr, (DWORD)strlen(lpOutStr), &dwBytesIo, NULL);
		// Translate the Win32 returned code in PT return code
		if (retCode == 0) retCode = -1;
	}
	else
		printf(lpOutStr);

	return retCode;
}

static int print_raw(struct ptdump_buffer *buffer, uint64_t offset,
		     const struct pt_packet *packet,
		     const struct pt_config *config)
{
	const uint8_t *begin, *end;
	char *bbegin, *bend;

	if (!buffer || !packet)
		return diag("error printing packet", offset, -pte_internal);

	begin = config->begin + offset;
	end = begin + packet->size;

	if (config->end < end)
		return diag("bad packet size", offset, -pte_bad_packet);

	bbegin = buffer->raw;
	bend = bbegin + sizeof(buffer->raw);

	for (; begin < end; ++begin) {
		char *pos;

		pos = bbegin;
		bbegin += 2;

		if (bend <= bbegin)
			return diag("truncating raw packet", offset, 0);

		sprintf_s(pos, sizeof(buffer->raw), "%02x", *begin);
	}

	return 0;
}

static int track_last_ip(struct ptdump_buffer *buffer,
			 struct pt_last_ip *last_ip, uint64_t offset,
			 const struct pt_packet_ip *packet,
			 const struct ptdump_options *options,
			 const struct pt_config *config)
{
	uint64_t ip;
	int errcode;

	if (!buffer || !options)
		return diag("error tracking last-ip", offset, -pte_internal);

	print_field(buffer->tracking.id, "ip");

	errcode = pt_last_ip_update_ip(last_ip, packet, config);
	if (errcode < 0) {
		print_field(buffer->tracking.payload, "<unavailable>");

		return diag("error tracking last-ip", offset, errcode);
	}

	errcode = pt_last_ip_query(&ip, last_ip);
	if (errcode < 0) {
		if (errcode == -pte_ip_suppressed)
			print_field(buffer->tracking.payload, "<suppressed>");
		else {
			print_field(buffer->tracking.payload, "<unavailable>");

			return diag("error tracking last-ip", offset, errcode);
		}
	} else
		print_field(buffer->tracking.payload, "%016" PRIx64, ip);

	return 0;
}


static int print_time(struct ptdump_buffer *buffer,
		      struct ptdump_tracking *tracking, uint64_t offset,
		      const struct ptdump_options *options)
{
	uint64_t tsc;
	int errcode;

	if (!tracking || !options)
		return diag("error printing time", offset, -pte_internal);

	print_field(buffer->tracking.id, "tsc");

	errcode = pt_time_query_tsc(&tsc, NULL, NULL, &tracking->time);
	if (errcode < 0) {
		switch (-errcode) {
		case pte_no_time:
			if (options->no_wall_clock)
				break;

			/* Fall through. */
		default:
			diag("error printing time", offset, errcode);
			print_field(buffer->tracking.payload, "<unavailable>");
			return errcode;
		}
	}

	if (options->show_time_as_delta) {
		uint64_t old_tsc;

		old_tsc = tracking->tsc;
		if (old_tsc <= tsc)
			print_field(buffer->tracking.payload, "+%" PRIx64,
				    tsc - old_tsc);
		else
			print_field(buffer->tracking.payload, "-%" PRIx64,
				    old_tsc - tsc);

		tracking->tsc = tsc;
	} else
		print_field(buffer->tracking.payload, "%016" PRIx64, tsc);

	return 0;
}

static int print_tcal(struct ptdump_buffer *buffer,
		      struct ptdump_tracking *tracking, uint64_t offset,
		      const struct ptdump_options *options)
{
	uint64_t fcr;
	double dfcr;
	int errcode;

	if (!tracking || !options)
		return diag("error printing time", offset, -pte_internal);

	print_field(buffer->tracking.id, "fcr");

	errcode = pt_tcal_fcr(&fcr, &tracking->tcal);
	if (errcode < 0) {
		print_field(buffer->tracking.payload, "<unavailable>");
		return diag("error printing time", offset, errcode);
	}

	/* We print fcr as double to account for the shift. */
	dfcr = (double) fcr;
	dfcr /= (double) (1ull << pt_tcal_fcr_shr);

	if (options->show_time_as_delta) {
		uint64_t old_fcr;
		double dold_fcr;

		old_fcr = tracking->fcr;

		/* We print fcr as double to account for the shift. */
		dold_fcr = (double) old_fcr;
		dold_fcr /= (double) (1ull << pt_tcal_fcr_shr);

		if (old_fcr <= fcr)
			print_field(buffer->tracking.payload, "+%.3f",
				    dfcr - dold_fcr);
		else
			print_field(buffer->tracking.payload, "-%.3f",
				    dold_fcr - dfcr);

		tracking->fcr = fcr;
	} else
		print_field(buffer->tracking.payload, "%.3f", dfcr);

	return 0;
}

static int track_time(struct ptdump_buffer *buffer,
		      struct ptdump_tracking *tracking,  uint64_t offset,
		      const struct ptdump_options *options)
{
	if (!tracking || !options)
		return diag("error tracking time", offset, -pte_internal);

	if (options->show_tcal && !buffer->skip_tcal)
		print_tcal(buffer, tracking, offset, options);

	if (options->show_time && !buffer->skip_time)
		print_time(buffer, tracking, offset, options);

	return 0;
}

static int track_tsc(struct ptdump_buffer *buffer,
		     struct ptdump_tracking *tracking,  uint64_t offset,
		     const struct pt_packet_tsc *packet,
		     const struct ptdump_options *options,
		     const struct pt_config *config)
{
	int errcode;

	if (!buffer || !tracking || !options)
		return diag("error tracking time", offset, -pte_internal);

	if (!options->no_tcal) {
		errcode = tracking->in_header ?
			pt_tcal_header_tsc(&tracking->tcal, packet, config) :
			pt_tcal_update_tsc(&tracking->tcal, packet, config);
		if (errcode < 0)
			diag("error calibrating time", offset, errcode);
	}

	errcode = pt_time_update_tsc(&tracking->time, packet, config);
	if (errcode < 0)
		diag("error updating time", offset, errcode);

	return track_time(buffer, tracking, offset, options);
}

static int track_cbr(struct ptdump_buffer *buffer,
		     struct ptdump_tracking *tracking,  uint64_t offset,
		     const struct pt_packet_cbr *packet,
		     const struct ptdump_options *options,
		     const struct pt_config *config)
{
	int errcode;

	if (!buffer || !tracking || !options)
		return diag("error tracking time", offset, -pte_internal);

	if (!options->no_tcal) {
		errcode = tracking->in_header ?
			pt_tcal_header_cbr(&tracking->tcal, packet, config) :
			pt_tcal_update_cbr(&tracking->tcal, packet, config);
		if (errcode < 0)
			diag("error calibrating time", offset, errcode);
	}

	errcode = pt_time_update_cbr(&tracking->time, packet, config);
	if (errcode < 0)
		diag("error updating time", offset, errcode);

	/* There is no timing update at this packet. */
	buffer->skip_time = 1;

	return track_time(buffer, tracking, offset, options);
}

static int track_tma(struct ptdump_buffer *buffer,
		     struct ptdump_tracking *tracking,  uint64_t offset,
		     const struct pt_packet_tma *packet,
		     const struct ptdump_options *options,
		     const struct pt_config *config)
{
	int errcode;

	if (!buffer || !tracking || !options)
		return diag("error tracking time", offset, -pte_internal);

	if (!options->no_tcal) {
		errcode = pt_tcal_update_tma(&tracking->tcal, packet, config);
		if (errcode < 0)
			diag("error calibrating time", offset, errcode);
	}

	errcode = pt_time_update_tma(&tracking->time, packet, config);
	if (errcode < 0)
		diag("error updating time", offset, errcode);

	/* There is no calibration update at this packet. */
	buffer->skip_tcal = 1;

	return track_time(buffer, tracking, offset, options);
}

static int track_mtc(struct ptdump_buffer *buffer,
		     struct ptdump_tracking *tracking,  uint64_t offset,
		     const struct pt_packet_mtc *packet,
		     const struct ptdump_options *options,
		     const struct pt_config *config)
{
	int errcode;

	if (!buffer || !tracking || !options)
		return diag("error tracking time", offset, -pte_internal);

	if (!options->no_tcal) {
		errcode = pt_tcal_update_mtc(&tracking->tcal, packet, config);
		if (errcode < 0)
			diag("error calibrating time", offset, errcode);
	}

	errcode = pt_time_update_mtc(&tracking->time, packet, config);
	if (errcode < 0)
		diag("error updating time", offset, errcode);

	return track_time(buffer, tracking, offset, options);
}

static int track_cyc(struct ptdump_buffer *buffer,
		     struct ptdump_tracking *tracking,  uint64_t offset,
		     const struct pt_packet_cyc *packet,
		     const struct ptdump_options *options,
		     const struct pt_config *config)
{
	uint64_t fcr;
	int errcode;

	if (!buffer || !tracking || !options)
		return diag("error tracking time", offset, -pte_internal);

	/* Initialize to zero in case of calibration errors. */
	fcr = 0ull;

	if (!options->no_tcal) {
		errcode = pt_tcal_fcr(&fcr, &tracking->tcal);
		if (errcode < 0)
			diag("calibration error", offset, errcode);

		errcode = pt_tcal_update_cyc(&tracking->tcal, packet, config);
		if (errcode < 0)
			diag("error calibrating time", offset, errcode);
	}

	errcode = pt_time_update_cyc(&tracking->time, packet, config, fcr);
	if (errcode < 0)
		diag("error updating time", offset, errcode);
	else if (!fcr)
		diag("error updating time: no calibration", offset, 0);

	/* There is no calibration update at this packet. */
	buffer->skip_tcal = 1;

	return track_time(buffer, tracking, offset, options);
}

static uint64_t sext(uint64_t val, uint8_t sign)
{
	uint64_t signbit, mask;

	signbit = 1ull << (sign - 1);
	mask = ~0ull << sign;

	return val & signbit ? val | mask : val & ~mask;
}

static int print_ip_payload(struct ptdump_buffer *buffer, uint64_t offset,
			    const struct pt_packet_ip *packet)
{
	if (!buffer || !packet)
		return diag("error printing payload", offset, -pte_internal);

	switch (packet->ipc) {
	case pt_ipc_suppressed:
		print_field(buffer->payload.standard, "%x: ????????????????",
			    pt_ipc_suppressed);
		return 0;

	case pt_ipc_update_16:
		print_field(buffer->payload.standard, "%x: ????????????%04"
			    PRIx64, pt_ipc_update_16, packet->ip);
		return 0;

	case pt_ipc_update_32:
		print_field(buffer->payload.standard, "%x: ????????%08"
			    PRIx64, pt_ipc_update_32, packet->ip);
		return 0;

	case pt_ipc_update_48:
		print_field(buffer->payload.standard, "%x: ????%012"
			    PRIx64, pt_ipc_update_48, packet->ip);
		return 0;

	case pt_ipc_sext_48:
		print_field(buffer->payload.standard, "%x: %016" PRIx64,
			    pt_ipc_sext_48, sext(packet->ip, 48));
		return 0;

	case pt_ipc_full:
		print_field(buffer->payload.standard, "%x: %016" PRIx64,
			    pt_ipc_full, packet->ip);
		return 0;
	}

	print_field(buffer->payload.standard, "%x: %016" PRIx64,
		    packet->ipc, packet->ip);
	return diag("bad ipc", offset, -pte_bad_packet);
}

static int print_tnt_payload(struct ptdump_buffer *buffer, uint64_t offset,
			     const struct pt_packet_tnt *packet)
{
	uint64_t tnt;
	uint8_t bits;
	char *begin, *end;

	if (!buffer || !packet)
		return diag("error printing payload", offset, -pte_internal);

	bits = packet->bit_size;
	tnt = packet->payload;

	begin = buffer->payload.extended;
	end = begin + bits;

	if (sizeof(buffer->payload.extended) < bits) {
		diag("truncating tnt payload", offset, 0);

		end = begin + sizeof(buffer->payload.extended);
	}

	for (; begin < end; ++begin, --bits)
		*begin = tnt & (1ull << (bits - 1)) ? '!' : '.';

	return 0;
}

static const char *print_exec_mode(const struct pt_packet_mode_exec *packet,
				   uint64_t offset)
{
	enum pt_exec_mode mode;

	mode = pt_get_exec_mode(packet);
	switch (mode) {
	case ptem_64bit:
		return "64-bit";

	case ptem_32bit:
		return "32-bit";

	case ptem_16bit:
		return "16-bit";

	case ptem_unknown:
		return "unknown";
	}

	diag("bad exec mode", offset, -pte_bad_packet);
	return "invalid";
}

static int print_packet(struct ptdump_buffer *buffer, uint64_t offset,
			const struct pt_packet *packet,
			struct ptdump_tracking *tracking,
			const struct ptdump_options *options,
			const struct pt_config *config)
{
	if (!buffer || !packet || !tracking || !options)
		return diag("error printing packet", offset, -pte_internal);

	switch (packet->type) {
	case ppt_unknown:
		print_field(buffer->opcode, "<unknown>");
		return 0;

	case ppt_invalid:
		print_field(buffer->opcode, "<invalid>");
		return 0;

	case ppt_psb:
		print_field(buffer->opcode, "psb");

		tracking->in_header = 1;
		return 0;

	case ppt_psbend:
		print_field(buffer->opcode, "psbend");

		tracking->in_header = 0;
		return 0;

	case ppt_pad:
		print_field(buffer->opcode, "pad");

		if (options->no_pad)
			buffer->skip = 1;
		return 0;

	case ppt_ovf:
		print_field(buffer->opcode, "ovf");
		return 0;

	case ppt_stop:
		print_field(buffer->opcode, "stop");
		return 0;

	case ppt_fup:
		print_field(buffer->opcode, "fup");
		print_ip_payload(buffer, offset, &packet->payload.ip);

		if (options->show_last_ip)
			track_last_ip(buffer, &tracking->last_ip, offset,
				      &packet->payload.ip, options, config);
		return 0;

	case ppt_tip:
		print_field(buffer->opcode, "tip");
		print_ip_payload(buffer, offset, &packet->payload.ip);

		if (options->show_last_ip)
			track_last_ip(buffer, &tracking->last_ip, offset,
				      &packet->payload.ip, options, config);
		return 0;

	case ppt_tip_pge:
		print_field(buffer->opcode, "tip.pge");
		print_ip_payload(buffer, offset, &packet->payload.ip);

		if (options->show_last_ip)
			track_last_ip(buffer, &tracking->last_ip, offset,
				      &packet->payload.ip, options, config);
		if (options->no_pge_pgd)
			buffer->skip = 1;
		return 0;

	case ppt_tip_pgd:
		print_field(buffer->opcode, "tip.pgd");
		print_ip_payload(buffer, offset, &packet->payload.ip);

		if (options->show_last_ip)
			track_last_ip(buffer, &tracking->last_ip, offset,
				      &packet->payload.ip, options, config);
		if (options->no_pge_pgd)
			buffer->skip = 1;
		return 0;

	case ppt_pip:
		print_field(buffer->opcode, "pip");
		print_field(buffer->payload.standard, "%" PRIx64 "%s",
			    packet->payload.pip.cr3,
			    packet->payload.pip.nr ? ", nr" : "");

		print_field(buffer->tracking.id, "cr3");
		print_field(buffer->tracking.payload, "%016" PRIx64,
			    packet->payload.pip.cr3);
		if (options->no_pip)
			buffer->skip = 1;
		return 0;

	case ppt_vmcs:
		print_field(buffer->opcode, "vmcs");
		print_field(buffer->payload.standard, "%" PRIx64,
			    packet->payload.vmcs.base);

		print_field(buffer->tracking.id, "vmcs");
		print_field(buffer->tracking.payload, "%016" PRIx64,
			    packet->payload.vmcs.base);
		return 0;

	case ppt_tnt_8:
		print_field(buffer->opcode, "tnt.8");
		return print_tnt_payload(buffer, offset, &packet->payload.tnt);

	case ppt_tnt_64:
		print_field(buffer->opcode, "tnt.64");
		return print_tnt_payload(buffer, offset, &packet->payload.tnt);

	case ppt_mode: {
		const struct pt_packet_mode *mode;

		mode = &packet->payload.mode;
		switch (mode->leaf) {
		case pt_mol_exec: {
			const char *csd, *csl, *sep;

			csd = mode->bits.exec.csd ? "cs.d" : "";
			csl = mode->bits.exec.csl ? "cs.l" : "";

			sep = csd[0] && csl[0] ? ", " : "";

			print_field(buffer->opcode, "mode.exec");
			print_field(buffer->payload.standard, "%s%s%s",
				    csd, sep, csl);

			if (options->show_exec_mode) {
				const char *em;

				em = print_exec_mode(&mode->bits.exec, offset);
				print_field(buffer->tracking.id, "em");
				print_field(buffer->tracking.payload, "%s", em);
			}
		}
			return 0;

		case pt_mol_tsx: {
			const char *intx, *abrt, *sep;

			intx = mode->bits.tsx.intx ? "intx" : "";
			abrt = mode->bits.tsx.abrt ? "abrt" : "";

			sep = intx[0] && abrt[0] ? ", " : "";

			print_field(buffer->opcode, "mode.tsx");
			print_field(buffer->payload.standard, "%s%s%s",
				    intx, sep, abrt);
		}
			return 0;
		}

		print_field(buffer->opcode, "mode");
		print_field(buffer->payload.standard, "leaf: %x", mode->leaf);

		return diag("unknown mode leaf", offset, 0);
	}

	case ppt_tsc:
		print_field(buffer->opcode, "tsc");
		print_field(buffer->payload.standard, "%" PRIx64,
			    packet->payload.tsc.tsc);

		if (options->track_time)
			track_tsc(buffer, tracking, offset,
				  &packet->payload.tsc, options, config);

		if (options->no_timing)
			buffer->skip = 1;

		return 0;

	case ppt_cbr:
		print_field(buffer->opcode, "cbr");
		print_field(buffer->payload.standard, "%x",
			    packet->payload.cbr.ratio);

		if (options->track_time)
			track_cbr(buffer, tracking, offset,
				  &packet->payload.cbr, options, config);

		if (options->no_timing)
			buffer->skip = 1;

		return 0;

	case ppt_tma:
		print_field(buffer->opcode, "tma");
		print_field(buffer->payload.standard, "%x, %x",
			    packet->payload.tma.ctc, packet->payload.tma.fc);

		if (options->track_time)
			track_tma(buffer, tracking, offset,
				  &packet->payload.tma, options, config);

		if (options->no_timing)
			buffer->skip = 1;

		return 0;

	case ppt_mtc:
		print_field(buffer->opcode, "mtc");
		print_field(buffer->payload.standard, "%x",
			    packet->payload.mtc.ctc);

		if (options->track_time)
			track_mtc(buffer, tracking, offset,
				  &packet->payload.mtc, options, config);

		if (options->no_timing)
			buffer->skip = 1;

		return 0;

	case ppt_cyc:
		print_field(buffer->opcode, "cyc");
		print_field(buffer->payload.standard, "%" PRIx64,
			    packet->payload.cyc.value);

		if (options->track_time && !options->no_cyc)
			track_cyc(buffer, tracking, offset,
				  &packet->payload.cyc, options, config);

		if (options->no_timing || options->no_cyc)
			buffer->skip = 1;

		return 0;

	case ppt_mnt:
		print_field(buffer->opcode, "mnt");
		print_field(buffer->payload.standard, "%" PRIx64,
			    packet->payload.mnt.payload);
		return 0;
	}

	return diag("unknown packet", offset, -pte_bad_opc);
}

static int dump_one_packet(uint64_t offset, const struct pt_packet *packet,
			   struct ptdump_tracking *tracking,
			   const struct ptdump_options *options,
			   const struct pt_config *config)
{
	struct ptdump_buffer buffer;
	int errcode;

	memset(&buffer, 0, sizeof(buffer));

	print_field(buffer.offset, "0x%08" PRIx32, (DWORD)(offset + options->offset_delta));

	if (options->show_raw_bytes) {
		errcode = print_raw(&buffer, offset, packet, config);
		if (errcode < 0)
			return errcode;
	}

	errcode = print_packet(&buffer, offset, packet, tracking, options,
			       config);
	if (errcode < 0)
		return errcode;

	return print_buffer(&buffer, offset, options);
}

static int dump_packets(struct pt_packet_decoder *decoder,
			struct ptdump_tracking *tracking,
			const struct ptdump_options *options,
			const struct pt_config *config)
{
	uint64_t offset;
	int errcode;

	offset = 0ull;
	for (;;) {
		struct pt_packet packet;

		errcode = pt_pkt_get_offset(decoder, &offset);
		if (errcode < 0)
			return diag("error getting offset", offset, errcode);

		errcode = pt_pkt_next(decoder, &packet, sizeof(packet));
		if (errcode < 0) {
			if (errcode == -pte_eos)
				return 0;

			// Return the error code and restart the scan
			if (pt_errcode(errcode) != pte_bad_packet)
				return diag("error decoding packet", offset, errcode);
			else
				return errcode;
		}

		errcode = dump_one_packet(offset, &packet, tracking, options,
					  config);
		if (errcode < 0)
			return diag("error printing the packet", offset, errcode);
	}
	return 0;
}

static int dump_sync(struct pt_packet_decoder *decoder,
		     struct ptdump_tracking *tracking,
		     const struct ptdump_options *options,
		     const struct pt_config *config)
{
	int errcode;

	if (!options)
		return diag("setup error", 0ull, -pte_internal);

	if (options->no_sync) {
		errcode = pt_pkt_sync_set(decoder, 0ull);
		if (errcode < 0)
			return diag("sync error", 0ull, errcode);
	} else {
		errcode = pt_pkt_sync_forward(decoder);
		if (errcode < 0)
			return diag("sync error", 0ull, errcode);
	}

	for (;;) {
		errcode = dump_packets(decoder, tracking, options, config);
		if (!errcode)
			break;

		errcode = pt_pkt_sync_forward(decoder);
		if (errcode < 0)
			return diag("sync error", 0ull, errcode);

		ptdump_tracking_reset(tracking);
	}

	return errcode;
}

// Dump all the PT packets
static int pt_dump(const struct pt_config *config,
		const struct ptdump_options *options)
{
	struct pt_packet_decoder *decoder;
	struct ptdump_tracking tracking;
	int errcode;

	decoder = pt_pkt_alloc_decoder(config);
	if (!decoder)
		return diag("failed to allocate decoder", 0ull, 0);

	ptdump_tracking_init(&tracking);

	errcode = dump_sync(decoder, &tracking, options, config);

	ptdump_tracking_fini(&tracking);
	pt_pkt_free_decoder(decoder);
	return errcode;
}

BOOL pt_dump_file(LPTSTR lpInputFile, LPTSTR lpOutFile, DWORD dwMaxSize) {
	// ... Dump all the useful packets:
	HANDLE hTarget = NULL;
	CHAR binaryFileAStr[MAX_PATH] = { 0 };
	CHAR myPath[MAX_PATH] = { 0 };
	pt_config config = { 0 };
	BOOL bRetVal = FALSE;
	if (!lpInputFile) return FALSE;

	sprintf_s((char* const)binaryFileAStr, MAX_PATH, "%S", lpInputFile);
	GetModuleFileNameA(GetModuleHandle(NULL), myPath, MAX_PATH);

	int errcode = load_pt(&config, binaryFileAStr, myPath);
	if (errcode < 0) return FALSE;

	if (lpOutFile) {
		// Open target file
		hTarget = CreateFile(lpOutFile, FILE_GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
		if (hTarget == INVALID_HANDLE_VALUE)
			return FALSE;
		else
			// Move to the end of file
			SetFilePointer(hTarget, 0, 0, FILE_END);
	}

	if (dwMaxSize == 0) dwMaxSize = (DWORD)(config.end - config.begin);
	bRetVal = pt_dumpW(config.begin, dwMaxSize, hTarget);

	unload_file();
	return bRetVal;
}

BOOL pt_dumpW(LPBYTE lpBuff, DWORD dwBuffSize, HANDLE hOutFile, QWORD delta, BOOLEAN bTraceOnlyKernel) {
	ptdump_options options = { 0 };
	pt_config config = { 0 };

	config.size = sizeof(pt_config);
	config.begin = lpBuff;
	config.end = lpBuff + dwBuffSize;

	options.no_sync = 1;
	options.no_pad = 1;
	options.no_timing = 1;
	options.show_offset = 1;
	options.show_time_as_delta = 1;
	options.no_pge_pgd = 0;
	options.no_pip = (bTraceOnlyKernel != FALSE) ? 1 : 0;
	options.offset_delta = delta;
	if (hOutFile)
		options.hTargetFile = hOutFile;

	int errcode = pt_cpu_errata(&config.errata, &config.cpu);
	if (errcode < 0)
		wprintf(L"failed to determine errata (error %i)", errcode);
	errcode = pt_dump(&config, &options);
	return (errcode == 0);
}

static int get_arg_uint64(uint64_t *value, const char *option, const char *arg,
			  const char *prog)
{
	char *rest;

	if (!value || !option || !prog) {
		fprintf(stderr, "%s: internal error.\n", prog ? prog : "?");
		return 0;
	}

	if (!arg || (arg[0] == '-' && arg[1] == '-')) {
		fprintf(stderr, "%s: %s: missing argument.\n", prog, option);
		return 0;
	}

	errno = 0;
	*value = strtoull(arg, &rest, 0);
	if (errno || *rest) {
		fprintf(stderr, "%s: %s: bad argument: %s.\n", prog, option,
			arg);
		return 0;
	}

	return 1;
}

static int get_arg_uint32(uint32_t *value, const char *option, const char *arg,
			  const char *prog)
{
	uint64_t val;

	if (!get_arg_uint64(&val, option, arg, prog))
		return 0;

	if (val > UINT32_MAX) {
		fprintf(stderr, "%s: %s: value too big: %s.\n", prog, option,
			arg);
		return 0;
	}

	*value = (uint32_t) val;

	return 1;
}

static int get_arg_uint8(uint8_t *value, const char *option, const char *arg,
			 const char *prog)
{
	uint64_t val;

	if (!get_arg_uint64(&val, option, arg, prog))
		return 0;

	if (val > UINT8_MAX) {
		fprintf(stderr, "%s: %s: value too big: %s.\n", prog, option,
			arg);
		return 0;
	}

	*value = (uint8_t) val;

	return 1;
}

int ptdump_main(int argc, char *argv[])
{
	struct ptdump_options options;
	struct pt_config config;
	int errcode, idx;
	char *ptfile;

	ptfile = NULL;

	memset(&options, 0, sizeof(options));
	options.show_offset = 1;

	memset(&config, 0, sizeof(config));
	pt_config_init(&config);

	for (idx = 1; idx < argc; ++idx) {
		if (strncmp(argv[idx], "-", 1) != 0) {
			ptfile = argv[idx];
			if (idx < (argc-1))
				return usage(argv[0]);
			break;
		}

		if (strcmp(argv[idx], "-h") == 0)
			return help(argv[0]);
		if (strcmp(argv[idx], "--help") == 0)
			return help(argv[0]);
		if (strcmp(argv[idx], "--version") == 0)
			return version(argv[0]);
		if (strcmp(argv[idx], "--no-sync") == 0)
			options.no_sync = 1;
		else if (strcmp(argv[idx], "--quiet") == 0)
			options.quiet = 1;
		else if (strcmp(argv[idx], "--no-pad") == 0)
			options.no_pad = 1;
		else if (strcmp(argv[idx], "--no-timing") == 0)
			options.no_timing = 1;
		else if (strcmp(argv[idx], "--no-cyc") == 0)
			options.no_cyc = 1;
		else if (strcmp(argv[idx], "--no-offset") == 0)
			options.show_offset = 0;
		else if (strcmp(argv[idx], "--raw") == 0)
			options.show_raw_bytes = 1;
		else if (strcmp(argv[idx], "--lastip") == 0)
			options.show_last_ip = 1;
		else if (strcmp(argv[idx], "--exec-mode") == 0)
			options.show_exec_mode = 1;
		else if (strcmp(argv[idx], "--time") == 0) {
			if (options.show_tcal) {
				fprintf(stderr, "%s: specify either --time "
					"or --tcal.\n", argv[0]);
				return 1;
			}

			options.track_time = 1;
			options.show_time = 1;
		} else if (strcmp(argv[idx], "--time-delta") == 0) {
			options.show_time_as_delta = 1;
		} else if (strcmp(argv[idx], "--tcal") == 0) {
			if (options.show_time) {
				fprintf(stderr, "%s: specify either --time "
					"or --tcal.\n", argv[0]);
				return 1;
			}

			options.track_time = 1;
			options.show_tcal = 1;
		} else if (strcmp(argv[idx], "--no-tcal") == 0)
			options.no_tcal = 1;
		else if (strcmp(argv[idx], "--no-wall-clock") == 0)
			options.no_wall_clock = 1;
		else if (strcmp(argv[idx], "--cpu") == 0) {
			const char *arg;

			arg = argv[++idx];
			if (!arg) {
				fprintf(stderr,
					"%s: --cpu: missing argument.\n",
					argv[0]);
				return 1;
			}

			if (strcmp(arg, "auto") == 0) {
				errcode = pt_cpu_read(&config.cpu);
				if (errcode < 0) {
					fprintf(stderr,
						"%s: error reading cpu: %s.\n",
						argv[0],
						pt_errstr(pt_errcode(errcode)));
					return 1;
				}
				continue;
			}

			if (strcmp(arg, "none") == 0) {
				memset(&config.cpu, 0, sizeof(config.cpu));
				continue;
			}

			errcode = pt_cpu_parse(&config.cpu, arg);
			if (errcode < 0) {
				fprintf(stderr,
					"%s: cpu must be specified as f/m[/s]\n",
					argv[0]);
				return 1;
			}
		} else if (strcmp(argv[idx], "--mtc-freq") == 0) {
			if (!get_arg_uint8(&config.mtc_freq, "--mtc-freq",
					   argv[++idx], argv[0]))
				return 1;
		} else if (strcmp(argv[idx], "--nom-freq") == 0) {
			if (!get_arg_uint8(&config.nom_freq, "--nom-freq",
					   argv[++idx], argv[0]))
				return 1;
		} else if (strcmp(argv[idx], "--cpuid-0x15.eax") == 0) {
			if (!get_arg_uint32(&config.cpuid_0x15_eax,
					    "--cpuid-0x15.eax", argv[++idx],
					    argv[0]))
				return 1;
		} else if (strcmp(argv[idx], "--cpuid-0x15.ebx") == 0) {
			if (!get_arg_uint32(&config.cpuid_0x15_ebx,
					    "--cpuid-0x15.ebx", argv[++idx],
					    argv[0]))
				return 1;
		} else
			return unknown_option_error(argv[idx], argv[0]);
	}

	if (!ptfile)
		return no_file_error(argv[0]);

	errcode = pt_cpu_errata(&config.errata, &config.cpu);
	if (errcode < 0)
		diag("failed to determine errata", 0ull, errcode);

	errcode = load_pt(&config, ptfile, argv[0]);
	if (errcode < 0)
		return errcode;

	errcode = pt_dump(&config, &options);

	free(config.begin);

	return -errcode;
}

```

`PtControlApp/pt_dump.h`:

```h
/**********************************************************************
 *  Windows Intel Processor Trace (PT) Driver
 *  Filename: pt_dump.h 
 *	Defines the data structures used to decode the binary PT dump
 *  Last revision: 12/01/2016
 *
 *  Copyright© 2016 Andrea Allievi, Richard Johnson
 *  Microsoft Ltd & TALOS Research and Intelligence Group
 *  All right reserved
 **********************************************************************/
#pragma once
#include <stdint.h>
#include "decoder\pt_last_ip.h"
#include "decoder\pt_time.h"
#include "decoder\intel-pt.h"

struct ptdump_options {
	/* Show the current offset in the trace stream. */
	uint32_t show_offset : 1;
	/* Show raw packet bytes. */
	uint32_t show_raw_bytes : 1;
	/* Show last IP for packets with IP payloads. */
	uint32_t show_last_ip : 1;
	/* Show the execution mode on mode.exec. */
	uint32_t show_exec_mode : 1;
	/* Keep track of time. */
	uint32_t track_time : 1;
	/* Show the estimated TSC for timing related packets. */
	uint32_t show_time : 1;
	/* Show time calibration. */
	uint32_t show_tcal : 1;
	/* Show timing information as delta to the previous value. */
	uint32_t show_time_as_delta : 1;
	/* Quiet mode: Don't print anything but errors. */
	uint32_t quiet : 1;
	/* Don't show PAD packets. */
	uint32_t no_pad : 1;
	/* Do not try to sync the decoder. */
	uint32_t no_sync : 1;
	/* Do not calibrate timing. */
	uint32_t no_tcal : 1;
	/* Do not expect wall-clock time. */
	uint32_t no_wall_clock : 1;
	/* Don't show timing packets. */
	uint32_t no_timing : 1;
	/* Don't show CYC packets and ignore them when tracking time. */
	uint32_t no_cyc : 1;
	/* Don't PGE PGD packets. */
	uint32_t no_pge_pgd : 1;
	/* Don't show Paging Information Packets */
	uint32_t no_pip : 1;
	/* The offset DELTA value */
	uint64_t offset_delta;
	/* HANDLE to the target text file (if one)*/
	HANDLE hTargetFile;
};

struct ptdump_buffer {
	/* The trace offset. */
	char offset[17];
	/* The raw packet bytes. */
	char raw[33];
	/* The packet opcode. */
	char opcode[10];
	union {
		/* The standard packet payload. */
		char standard[25];

		/* An extended packet payload. */
		char extended[48];
	} payload;

	/* The tracking information. */
	struct {
		/* The tracking identifier. */
		char id[5];

		/* The tracking information. */
		char payload[17];
	} tracking;
	/* A flag telling whether an extended payload is used. */
	uint32_t use_ext_payload : 1;
	/* A flag telling whether to skip printing this buffer. */
	uint32_t skip : 1;
	/* A flag telling whether to skip printing the time. */
	uint32_t skip_time : 1;
	/* A flag telling whether to skip printing the calibration. */
	uint32_t skip_tcal : 1;
};

struct ptdump_tracking {
	/* Track last-ip. */
	struct pt_last_ip last_ip;
	/* Track time calibration. */
	struct pt_time_cal tcal;
	/* Track time. */
	struct pt_time time;
	/* The last estimated TSC. */
	uint64_t tsc;
	/* The last calibration value. */
	uint64_t fcr;
	/* Header vs. normal decode.  Set if decoding PSB+. */
	uint32_t in_header : 1;
};

struct ptdump_global {
	HANDLE hInFile = 0;					// The input file handle
	HANDLE hInSection = 0;				// The input file SECTION object
	LPCVOID lpFileContent = 0;			// The mapped file content
};

// Load a PT binary file
int load_pt(struct pt_config *config, char *arg, const char *prog);

// Dump all the PT packets
int pt_dump(const struct pt_config *config, const struct ptdump_options *options);


// AaLl86 DEFAULT binary dump 
BOOL pt_dump_file(LPTSTR lpInputFile, LPTSTR lpOutFile, DWORD dwMaxSize = 0);
BOOL pt_dumpW(LPBYTE lpBuff, DWORD dwBuffSize, HANDLE hOutFile, QWORD delta = 0ull, BOOLEAN bTraceOnlyKernel = FALSE);

```

`PtControlApp/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by PtControlApp.rc
//
#define IDI_ICON1                       101
#define IDI_MAINICO                     101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`PtControlApp/stdafx.cpp`:

```cpp
/**********************************************************************
 *  Windows Intel Processor Trace (PT) Driver
 *  Filename: stdafx.cpp
 *	Implement Control Application's standard routines 
 *  Last revision: 12/01/2016
 *
 *  Copyright© 2016 Andrea Allievi, Richard Johnson
 *  Microsoft Ltd & TALOS Research and Intelligence Group
 *  All right reserved
 **********************************************************************/
#include "stdafx.h"

// Get if a file Exist
bool FileExists(LPTSTR fileName) {
	HANDLE h = NULL;
	DWORD lastErr = 0;
	DWORD fileAttr = 0;

	// Get if file is an ADS
	LPTSTR slash = wcsrchr(fileName, L'\\');
	if (slash) slash++;
	else slash = fileName;
	LPTSTR colon = wcsrchr(slash, L':');
	if (colon) colon[0] = 0;
	fileAttr = GetFileAttributes(fileName);
	if (fileAttr == INVALID_FILE_ATTRIBUTES) fileAttr = 0;

	if ((fileAttr & FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY)
		// File is a directory
		return true;
	else
		// File is a file
		h = CreateFile(fileName, FILE_READ_ATTRIBUTES, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
		NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS, NULL);
	lastErr = GetLastError();

	if (colon) colon[0] = L':';

	if (h == INVALID_HANDLE_VALUE)
		return false;
	else {
		CloseHandle(h);
		return true;
	}
}

#pragma region Generic Environment Console functions
// Get Last Win32 Error description
LPTSTR GetWin32ErrorMessage(DWORD errNum) {
	// Retrieve the system error message for the last-error code
	LPVOID lpMsgBuf = NULL;

	FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL, errNum, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpMsgBuf, 0, NULL);
	return (LPTSTR)lpMsgBuf;
}

// Read a line of input from a console
DWORD ReadLine(LPTSTR buff, int buffCch) {
	HANDLE hConsole = GetStdHandle(STD_INPUT_HANDLE);
	CONSOLE_READCONSOLE_CONTROL cControl = { 0 };
	DWORD dwCharRead = 0;
	cControl.nLength = sizeof(CONSOLE_READCONSOLE_CONTROL);
	cControl.dwCtrlWakeupMask = (ULONG)L'\n';
	ReadConsole(hConsole, buff, buffCch, &dwCharRead, &cControl);
	return dwCharRead;
}

void SetConsoleColor(ConsoleColor c){
	HANDLE hCon = GetStdHandle(STD_OUTPUT_HANDLE);
	CONSOLE_SCREEN_BUFFER_INFO con_info;
	GetConsoleScreenBufferInfo(hCon, &con_info);
	SetConsoleTextAttribute(hCon, ((BYTE)c & 0xF) | (con_info.wAttributes & 0xF0));
}

int GetCurrentConsoleColor() {
	HANDLE hCon = GetStdHandle(STD_OUTPUT_HANDLE);
	CONSOLE_SCREEN_BUFFER_INFO con_info;
	GetConsoleScreenBufferInfo(hCon, &con_info);
	return con_info.wAttributes;
}

// Color WPrintf 
void cl_wprintf(ConsoleColor c, LPTSTR string, LPVOID arg1, LPVOID arg2, LPVOID arg3, LPVOID arg4) {
	ConsoleColor oldColor = (ConsoleColor)GetCurrentConsoleColor();
	SetConsoleColor(c);
	wprintf(string, arg1, arg2, arg3, arg4);
	SetConsoleColor(oldColor);
}
#pragma endregion
```

`PtControlApp/stdafx.h`:

```h
/**********************************************************************
 *  Windows Intel Processor Trace (PT) Driver
 *  Filename: stdafx.h 
 *	Control Application standard definitions
 *  Last revision: 12/01/2016
 *
 *  Copyright© 2016 Andrea Allievi, Richard Johnson
 *  Microsoft Ltd & TALOS Research and Intelligence Group
 *  All right reserved
 **********************************************************************/
#pragma once

#include "targetver.h"

#include <stdio.h>
#include <tchar.h>

#define WIN32_LEAN_AND_MEAN
#include <Windows.h>

typedef unsigned long long QWORD;

// Get if a file Exist
bool FileExists(LPTSTR fileName);

// Get Last Win32 Error description
LPTSTR GetWin32ErrorMessage(DWORD errNum);

// Read a line of input from a console
DWORD ReadLine(LPTSTR buff, int buffCch);

enum ConsoleColor {
	DARKBLUE = 1, DARKGREEN, DARKTEAL, DARKRED, DARKPINK, DARKYELLOW,
	GRAY, DARKGRAY, BLUE, GREEN, TEAL, RED, PINK, YELLOW, WHITE
};

// Set console text Color
void SetConsoleColor(ConsoleColor c);
// Get console text Color
int GetCurrentConsoleColor();
// Color WPrintf 
void cl_wprintf(ConsoleColor c, LPTSTR string, LPVOID arg1 = NULL, LPVOID arg2 = NULL, LPVOID arg3 = NULL, LPVOID arg4 = NULL);

#ifdef _DEBUG
#define DbgBreak() __debugbreak()
#else
#define DbgBreak() __noop()
#endif

#define COUNTOF(x) sizeof(x) / sizeof(x[0])
```

`PtControlApp/targetver.h`:

```h
#pragma once

// Including SDKDDKVer.h defines the highest available Windows platform.

// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.

#include <SDKDDKVer.h>

```

`README.md`:

```md
Windows Intel PT Support 
========================
  
This driver implements the Intel Processor Trace functionality in Intel Skylake architecture for Microsoft Windows. 
  
Overview 
--------
  
Intel Processor Trace is a high performance hardware supported branch tracing mechanism in Intel Skylake architecure. 

Primary benefits include: 

* Avoids cache and TLB polution by writing directly to physical memory 
* Uses a compressed logging format that is suitable for long running traces 
* Able to trace all branches on a CPU core including userspace and kernel 

**Driver Features**

* Trace user processes using CR3 filtering
* Trace kernel mode drivers using linear range filtering
* Trace up to four arbitrary ranges of physical memory
* Log to single physical address range 
* Log to table of physical pages and map to virtual address range
* Multi-core tracing support 
* Full support for HyperV Root Partitions

**Build Instructions**

* Open the included Visual Studio Project file in Visual Studio 2013 or 2015.
* Ensure build options are set to x64 Release and build

**Driver Loading Instructions**

* Ensure your CPU is Skylake architecture and you are running on native hardware (not a hypervisor)
* Boot your Windows 8.1 or Windows 10 OS using boot options that allow loading test signed drivers 
* Install the WindowsPtDriver using `sc create intelpt BinPath=%cd%\WindowsPtDriver\x64\Release\WindowsPtDriver.sys`

**Current Limitations**
 
All threads in a usermode process will log to a single buffer, making it difficult to determine accurate 
execution per-thread. This something we are working to fix.
 
The IOCTLs for this driver must not be called from within the traced process. The driver maps the 
physical memory ranges holding the trace data into the process that initialized the trace, this is
unstable if mapped into the trace target. Use the included command line tool for executing traces 
against target processes. 

   
**Development Notes**

The driver currently executes a DbgBreak() on load if a kernel debugger is attached. 


**TODO List**

* Output sideband memory map information for post processing
* Per-thread logging
* Implement the support for Kernel KVA Shadowing


  
Last revision: 04/15/2018

```

`WindowsIntelPt.sln`:

```sln
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 14
VisualStudioVersion = 14.0.25420.1
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "WindowsPtDriver", "WindowsPtDriver\WindowsIntelPtDriver.vcxproj", "{44253DD8-98B2-4229-8305-5DD1E272CDE3}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "PtControlApp", "PtControlApp\PtControlApp.vcxproj", "{AEEB84F9-A268-4642-8CCC-CE05D80ACD74}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{44253DD8-98B2-4229-8305-5DD1E272CDE3}.Debug|x64.ActiveCfg = Debug|x64
		{44253DD8-98B2-4229-8305-5DD1E272CDE3}.Debug|x64.Build.0 = Debug|x64
		{44253DD8-98B2-4229-8305-5DD1E272CDE3}.Debug|x64.Deploy.0 = Debug|x64
		{44253DD8-98B2-4229-8305-5DD1E272CDE3}.Release|x64.ActiveCfg = Release|x64
		{44253DD8-98B2-4229-8305-5DD1E272CDE3}.Release|x64.Build.0 = Release|x64
		{AEEB84F9-A268-4642-8CCC-CE05D80ACD74}.Debug|x64.ActiveCfg = Debug|x64
		{AEEB84F9-A268-4642-8CCC-CE05D80ACD74}.Debug|x64.Build.0 = Debug|x64
		{AEEB84F9-A268-4642-8CCC-CE05D80ACD74}.Release|x64.ActiveCfg = Release|x64
		{AEEB84F9-A268-4642-8CCC-CE05D80ACD74}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`WindowsPtDriver/Debug.cpp`:

```cpp
/**********************************************************************
 *  Windows Intel Processor Trace (PT) Driver
 *  Filename: Debug.cpp
 *	Implement Driver Debug functions
 *  Last revision: 01/06/2017
 *
 *  Copyright© 2016 Andrea Allievi, Richard Johnson
 *  TALOS Research and Intelligence Group and Microsoft Ltd
 *  All right reserved
 **********************************************************************/
#include "stdafx.h"
#include "Debug.h"
#include <stdarg.h>

#pragma region Debug Functions
BOOLEAN g_bOldDbgState = FALSE;
/*  When DbgPrintEx is called in kernel-mode code, Windows compares the message importance bitfield that is 
 *  specified by Level with the filter mask of the component that is specified by ComponentId.
 *
 *  Note 
 *  Recall that when the Level parameter is between 0 and 31, the importance bitfield is equal to 1 << Level. 
 *  But when the Level parameter is 32 or higher, the importance bitfield is simply equal to Level.
 *  Windows performs an AND operation on the importance bitfield and the component filter mask. 
 *  If the result is nonzero, the message is sent to the debugger.
 *
*/
//DPFLTR_SYSTEM_ID = 0x0 - DPFLTR_DEFAULT_ID = 0x65h	
//DPFLTR_IHVDRIVER_ID = 77
NTSTATUS EnableDebugOutput() 
{
	NTSTATUS ntStatus = STATUS_SUCCESS;
	ntStatus = DbgQueryDebugFilterState(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL);
	if (ntStatus == FACILITY_DEBUGGER) 
		g_bOldDbgState = TRUE;
	else 
		g_bOldDbgState = FALSE;
	// Now set new Mask
	ntStatus = DbgSetDebugFilterState(DPFLTR_IHVDRIVER_ID, DPFLTR_MASK | 0x0E, TRUE);
	return ntStatus;
}

VOID RevertToDefaultDbgSettings() 
{
	DbgSetDebugFilterState(DPFLTR_IHVDRIVER_ID, DPFLTR_MASK | 0x0E, g_bOldDbgState);
}

ULONG DrvDbgPrint(PCHAR Format, ...) 
{
	va_list arglist;
	va_start(arglist, Format);
	return vDbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, Format, arglist);
}

PVOID DbgAllocateMemory(IN POOL_TYPE  PoolType, IN SIZE_T  NumberOfBytes, IN ULONG  Tag) 
{
	PVOID retBuff = ExAllocatePoolWithTag(PoolType, NumberOfBytes, Tag);
	DbgPrint("[" DRV_NAME "] Allocated 0x%08X bytes at base address 0x%08X, Tag '%.04s', %s.\r\n", 
		NumberOfBytes, (LPBYTE)retBuff, (LPSTR)&Tag, (PoolType == NonPagedPool ? "NonPaged Pool" : "Paged Pool"));
	return retBuff;
}

VOID DbgFreeMemory(PVOID pMem) 
{
	ExFreePool(pMem);
	DbgPrint("[" DRV_NAME "] Deallocated memory at base address 0x%08X\r\n", (LPBYTE)pMem);
}
#pragma endregion
```

`WindowsPtDriver/Debug.h`:

```h
/**********************************************************************
 *  Windows Intel Processor Trace (PT) Driver
 *	Filename: Debug.h
 *	Implement Driver Debug function prototypes
 *	Last revision: 01/06/2016
 *
 *  Copyright© 2016 Andrea Allievi, Richard Johnson
 *  TALOS Research and Intelligence Group and Microsoft Ltd
 *	All right reserved
 **********************************************************************/

#pragma once

// Macro to substitute the old original DbgPrint routine with the new one
#define DbgPrint DrvDbgPrint		

// Enable debug output for DPFLTR_DEFAULT_ID  component filter mask 
NTSTATUS EnableDebugOutput();

// Revert to default Debug Settings
VOID RevertToDefaultDbgSettings();

// Allocate Debug Memory  with auditing
PVOID DbgAllocateMemory(IN POOL_TYPE  PoolType, IN SIZE_T  NumberOfBytes, IN ULONG  Tag);

// Free Allocated Debug Memory
VOID DbgFreeMemory(PVOID pMem);

// Write a driver message to the Kernel Debugger
ULONG DrvDbgPrint(PCHAR Format, ...); 

```

`WindowsPtDriver/DriverEntry.cpp`:

```cpp
/**********************************************************************
 *  Windows Intel Processor Trace (PT) Driver
 *  Filename: DriverEntry.cpp
 *	Implement Driver Entry point and startup functions
 *  Last revision: 01/06/2016
 *
 *  Copyright© 2016 Andrea Allievi, Richard Johnson
 *  TALOS Research and Intelligence Group and Microsoft Ltd
 *  All right reserved
 **********************************************************************/
#include "stdafx.h"
#include "DriverEntry.h"
#include "DriverIo.h"
#include "Debug.h"
#include "UndocNt.h"
#include "IntelPtXSave.h"
#include <hv.h>

const LPTSTR g_lpDevName = L"\\Device\\WindowsIntelPtDev";
const LPTSTR g_lpDosDevName = L"\\DosDevices\\WindowsIntelPtDev";

// The global driver data
DRIVER_GLOBAL_DATA * g_pDrvData = NULL;

NTSTATUS DriverEntry(PDRIVER_OBJECT pDriverObject, PUNICODE_STRING pRegPath) 
{
	UNREFERENCED_PARAMETER(pRegPath);
	NTSTATUS ntStatus = STATUS_SUCCESS;
	KAFFINITY activeProcessorsMask = 0;					// The active processors mask
	DWORD dwNumOfProcs = 0;								// Number of system processors
	DWORD dwBuffSize = 0;								// The global driver data size in bytes
	UNICODE_STRING devNameString = { 0 };				// The I/O device name
	UNICODE_STRING dosDevNameString = { 0 };			// The DOS device name (Usermode access)
	PDEVICE_OBJECT pDevObj = NULL;						// The device object
	INTEL_PT_CAPABILITIES ptCap = { 0 };				// The Intel PT Capabilities for this processor

	// Debug helper
	DBG_BREAK();
	EnableDebugOutput();

	// Get the total number of system processors
	dwNumOfProcs = KeQueryActiveProcessorCount(&activeProcessorsMask);

	// Allocate memory for my own global data
	dwBuffSize = sizeof(DRIVER_GLOBAL_DATA) + (dwNumOfProcs * sizeof(PER_PROCESSOR_PT_DATA));
	g_pDrvData = (PDRIVER_GLOBAL_DATA)ExAllocatePoolWithTag(NonPagedPool, dwBuffSize, MEMTAG);
	if (!g_pDrvData) return STATUS_INSUFFICIENT_RESOURCES;
	RtlZeroMemory(g_pDrvData, dwBuffSize);
	g_pDrvData->dwNumProcs = dwNumOfProcs;

	// Check Microsoft HyperV presence:
	if (NT_SUCCESS(DetectMicrosoftHyperV(NULL))) {
		// HyperV detected, allocate and initialize all the needed data
		ntStatus = InitGlobalHv();
		ASSERT(NT_SUCCESS(ntStatus));
		g_pDrvData->IsUnderHyperV = TRUE;
		if (g_pDrvData->HyperV_Data.Info.Features.PartitionPrivilegeMask.CreatePartitions == 0)
			DbgPrint("[" DRV_NAME "] Info: Intel Processor Trace driver is running into an HyperV child VM. \r\n");
	}
	else
		g_pDrvData->IsUnderHyperV = FALSE;

	// Check PT support
	ntStatus = CheckIntelPtSupport(&ptCap);
	if (!NT_SUCCESS(ntStatus)) 
	{
		DbgPrint("[" DRV_NAME "] Intel Processor Trace is not supported on this system. Exiting...\r\n");
		RevertToDefaultDbgSettings();
		ExFreePool(g_pDrvData);
		return ntStatus;
	}
	if (ptCap.numOfAddrRanges < 4) {
		DbgPrint("[" DRV_NAME "] Info: The processor %i supports maximum of %i IP ranges.\r\n", KeGetCurrentProcessorNumber(), ptCap.numOfAddrRanges);
	}

	#if ENABLE_EXPERIMENTAL_XSAVE
	ntStatus = InitializeCpusXSaveArea();
	#endif

	// Create a Pmi Event name and register the PMI interrupt
	CreateSharedPmiEvent(INTEL_PT_PMI_EVENT_NAME);
	RegisterPmiInterrupt();
	// Initialize the user-mode callbacks list 
	InitializeListHead(&g_pDrvData->userCallbackList);
	KeInitializeSpinLock(&g_pDrvData->userCallbackListLock);

	// Build the controller device
	RtlInitUnicodeString(&devNameString, g_lpDevName);
	RtlInitUnicodeString(&dosDevNameString, g_lpDosDevName);

	// XXX: require admin to prevent side channel attacks on 3rd party programs (IoCreateDeviceSecure)
	ntStatus = IoCreateDevice(pDriverObject, 0, &devNameString, FILE_DEVICE_UNKNOWN,
		FILE_DEVICE_SECURE_OPEN, FALSE, &pDevObj);
	
	if (NT_SUCCESS(ntStatus)) {
		ntStatus = IoCreateSymbolicLink(&dosDevNameString, &devNameString);
		g_pDrvData->pMainDev = pDevObj;
	}

	if (!NT_SUCCESS(ntStatus)) {
		if (g_pDrvData->pMainDev) IoDeleteDevice(g_pDrvData->pMainDev);
		ExFreePool(g_pDrvData);
		return ntStatus;
	}

	// Put the needed routines in the NonPaged pool
	MmLockPagableCodeSection(CheckIntelPtSupport);

	// Initialize Driver dispatch routine
	for (DWORD i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++)
		pDriverObject->MajorFunction[i] = DeviceUnsupported;

	pDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DeviceIoControl;
	pDriverObject->MajorFunction[IRP_MJ_CREATE] = DevicePassThrough;
	pDriverObject->MajorFunction[IRP_MJ_CLOSE] = DevicePassThrough;
	pDriverObject->MajorFunction[IRP_MJ_CLEANUP] = DevicePassThrough;
	pDriverObject->MajorFunction[IRP_MJ_READ] = DeviceUnsupported;		
	pDriverObject->MajorFunction[IRP_MJ_WRITE] = DeviceUnsupported;	
	
	pDriverObject->DriverUnload = DriverUnload;

	return STATUS_SUCCESS;
}

// Create the shared PMI event
NTSTATUS CreateSharedPmiEvent(LPTSTR lpEvtName) 
{
	NTSTATUS ntStatus = STATUS_SUCCESS;					// Returned NT_STATUS value
	DWORD dwNameLen = 0;								// Size in CHARs
	HANDLE hEvent = NULL;								// Handle to the named event
	PKEVENT pEvent = NULL;								// The EVENT object body
	OBJECT_ATTRIBUTES oa = { 0 };						// The EVENT object attributes
	UNICODE_STRING eventNameString = { 0 };				// The EVENT name string
	TCHAR newName[COUNTOF(g_pDrvData->pmiEventName)] = { 0 };

	dwNameLen = (DWORD)wcslen(lpEvtName);
	if (!lpEvtName || dwNameLen < 2)
		return STATUS_INVALID_PARAMETER;

	// Preliminary buffer checks
	if (lpEvtName[0] != L'\\') 	{
		// Add the trailing "\BasedNamedObject\" (18 chars)
		if ((dwNameLen + 1 + 18) > COUNTOF(g_pDrvData->pmiEventName))
			return STATUS_INVALID_BUFFER_SIZE;

		wcscpy_s(newName, COUNTOF(newName), L"\\BaseNamedObjects\\");
		wcscat_s(newName, COUNTOF(newName), lpEvtName);

	} else {
		if ((dwNameLen + 1) > COUNTOF(g_pDrvData->pmiEventName))
			return STATUS_INVALID_BUFFER_SIZE;

		wcscpy_s(newName, COUNTOF(newName), lpEvtName);
	}

	if (g_pDrvData->pPmiEvent) {
		KeResetEvent(g_pDrvData->pPmiEvent);
		// Delete the object (DO NOT use ExFreePool, the Object Manager has allocated this)
		ObDereferenceObject(g_pDrvData->pPmiEvent);
		if (g_pDrvData->hPmiEvent) ZwClose(g_pDrvData->hPmiEvent);
		g_pDrvData->pPmiEvent = NULL;
		RtlZeroMemory(g_pDrvData->pmiEventName, COUNTOF(g_pDrvData->pmiEventName));
	}

	RtlInitUnicodeString(&eventNameString, newName);
	InitializeObjectAttributes(&oa, &eventNameString, OBJ_KERNEL_HANDLE, NULL, NULL);

	// Create the named event
	ntStatus = ZwCreateEvent(&hEvent, EVENT_ALL_ACCESS, &oa, SynchronizationEvent, FALSE);

	if (NT_SUCCESS(ntStatus)) {
		ntStatus = ObReferenceObjectByHandle(hEvent, EVENT_ALL_ACCESS, *ExEventObjectType, KernelMode, (PVOID*)&pEvent, NULL);
		if (NT_SUCCESS(ntStatus)) {
			RtlCopyMemory(g_pDrvData->pmiEventName, newName, COUNTOF(g_pDrvData->pmiEventName));
			g_pDrvData->pPmiEvent = pEvent;
			g_pDrvData->hPmiEvent = hEvent;
		}
		else
			ZwClose(hEvent);
	}
	
	return ntStatus;
}

// Initialize each CPU XSave area (Experimental XSAVE support)
NTSTATUS InitializeCpusXSaveArea() {
	NTSTATUS ntStatus = STATUS_SUCCESS;					// Returned NTSTATUS value
	KAFFINITY activeProcessorsMask = 0;					// The active processors mask
	DWORD dwNumOfProcs = 0;								// Total number of processor in the system
	DWORD dwAreaSize = 0;								// The maximum XSAVE area size
	
	// Get the total number of system processors
	dwNumOfProcs = KeQueryActiveProcessorCount(&activeProcessorsMask);

	// Check the XSAVE support for this processor (is enough)
	ntStatus = CheckPtXSaveSupport(&dwAreaSize, NULL, NULL);
	if (!NT_SUCCESS(ntStatus)) return ntStatus;

	for (int i = 0; i < (int)dwNumOfProcs; i++) {
		PER_PROCESSOR_PT_DATA & pCurCpuData = g_pDrvData->procData[i];
		LPVOID lpBuff = NULL; 
		DWORD dwBuffSize = 0;

		if (dwAreaSize > PAGE_SIZE)
			dwBuffSize = dwAreaSize;
		else
			// I should allocate a PAGE_SIZE buffer to obey at the 64-BYTE aligment requirement
			dwBuffSize = 0x1000;

		lpBuff = ExAllocatePoolWithTag(NonPagedPool, dwBuffSize, MEMTAG);
		if (((ULONG_PTR)lpBuff & 0x00FF) != 0) {
			// I am too lazy to use the MDL (see MmAllocatePagesForMdl)
			return STATUS_INTERNAL_ERROR;
		}
		pCurCpuData.lpXSaveArea = lpBuff;
		pCurCpuData.dwXSaveAreaSize = dwAreaSize;
	}

	return STATUS_SUCCESS;
}

VOID UnloadPtDpc(struct _KDPC *Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2) 
{
	UNREFERENCED_PARAMETER(Dpc);
	UNREFERENCED_PARAMETER(SystemArgument1);
	UNREFERENCED_PARAMETER(SystemArgument2);
	
	NTSTATUS ntStatus = STATUS_SUCCESS;
	ULONG dwCurProc = 0;

	dwCurProc = KeGetCurrentProcessorNumber();

	DbgPrint("[" DRV_NAME "] Stopping and unloading the Trace for CPU #%i...\r\n", dwCurProc);
	ntStatus = StopAndDisablePt();
	ntStatus = FreeCpuResources(dwCurProc);

	if (DeferredContext) 
	{
		// This is a pointer to the KEVENT, signal it without wait anything (It could be done at DISPATCH IRQL)
		KeSetEvent((PRKEVENT)DeferredContext, IO_NO_INCREMENT, FALSE);
	}
	// END
}

// XXX: This will currently bugcheck if the IOCTL is called from within the traced process
VOID DriverUnload(PDRIVER_OBJECT pDrvObj) 
{
	UNREFERENCED_PARAMETER(pDrvObj);
	NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
	UNICODE_STRING dosDevNameString = { 0 };
	ULONG dwCurProc = 0;
	KDPC unloadDpc = { 0 };

	PAGED_CODE();

	dwCurProc = KeGetCurrentProcessorNumber();
	for (DWORD i = 0; i < g_pDrvData->dwNumProcs; i++) 
	{
		KEVENT kUnloadEvent = { 0 };
		PER_PROCESSOR_PT_DATA * procData = &g_pDrvData->procData[i];;
		KeInitializeEvent(&kUnloadEvent, NotificationEvent, FALSE);

		// This will fail if called from within the traced process
		ntStatus = UnmapTraceBuffToUserVa(i);
		if (!NT_SUCCESS(ntStatus)) 
		{
			// Memory mappings are inconsistent so we bugcheck
			KeBugCheckEx(PROCESS_HAS_LOCKED_PAGES, 0x00, (ULONG_PTR)procData->lpMappedProc, procData->pPtBuffDesc->qwBuffSize / PAGE_SIZE, 0);
		}

		// Queue the unload DPC
		KeInitializeDpc(&unloadDpc, UnloadPtDpc, (LPVOID)&kUnloadEvent);
		KeSetTargetProcessorDpc(&unloadDpc, (CCHAR)i);
		KeInsertQueueDpc(&unloadDpc, NULL, NULL);

		KeWaitForSingleObject(&kUnloadEvent, Executive, KernelMode, FALSE, NULL);

		// Free the XSAVE area (if any)
		if (procData->lpXSaveArea) {
			ExFreePool(procData->lpXSaveArea);
			procData->dwXSaveAreaSize = 0;
			procData->lpXSaveArea = NULL;
		}
	}

	// Unload each registered User-mode PMI Callback
	ClearAndFreePmiCallbackList();

	// Unload the device object and the Symbolic Link
	if (g_pDrvData->pMainDev) 
	{
		// Delete the symbolic Link
		RtlInitUnicodeString(&dosDevNameString, g_lpDosDevName);
		IoDeleteSymbolicLink(&dosDevNameString);
		IoDeleteDevice(g_pDrvData->pMainDev);
	}

	// Unload HyperV data
	if (g_pDrvData->IsUnderHyperV)
		DestroyGlobalHv();

	// uninstall PMI
	if (g_pDrvData->bPmiInstalled)
		UnregisterPmiInterrupt();
	
	// delete the PMI event
	if (g_pDrvData->hPmiEvent)
		ZwClose(g_pDrvData->hPmiEvent);
	g_pDrvData->hPmiEvent = NULL;

	if (g_pDrvData->pPmiEvent)
		ObDereferenceObject(g_pDrvData->pPmiEvent);
	g_pDrvData->pPmiEvent = NULL;

	if (g_pDrvData) 
		ExFreePool(g_pDrvData);

	DbgPrint("[" DRV_NAME "] driver successfully unloaded.");
	RevertToDefaultDbgSettings();
}
```

`WindowsPtDriver/DriverEntry.h`:

```h
/**********************************************************************
*  Windows Intel Processor Trace (PT) Driver
*  Filename: DriverEntry.h
*  Implement Driver Entry point and startup functions prototypes
*  Last revision: 10/07/2016
*
*  Copyright© 2016 Andrea Allievi, Richard Johnson
*  TALOS Research and Intelligence Group and Microsoft Ltd
*  All right reserved
**********************************************************************/
#pragma once
#include "IntelPt.h"
#include "hv.h"

// The PMI Handler function prototype
typedef VOID (*PMIHANDLER)(PKTRAP_FRAME TrapFrame);

typedef struct _DRIVER_GLOBAL_DATA {
	BOOLEAN bPtSupported;								// TRUE if Intel PT is supported
	BOOLEAN bPmiInstalled;								// TRUE if I have correctly installed the PMI Handler routine
	BOOLEAN bCpuX2ApicMode;								// TRUE if the system processors are in x2Apic Mode
	BOOLEAN bManualAllocBuff;							// TRUE if the PT buffer has been MANUALLY allocated from User Mode
	DWORD dwNumProcs;									// The number of the system processors
	PDEVICE_OBJECT pMainDev;							// The main device object 
	PMIHANDLER pOldPmiHandler;							// The OLD PMI handler routine (if any)
	TCHAR pmiEventName[0x80];							// The PMI event name shared between user and kernel mode
	PRKEVENT pPmiEvent;									// The PMI event 
	HANDLE hPmiEvent;									// The PMI event kernel handle
	DWORD * lpApicBase;									// The APIC I/O memory VA
	LVT_Entry pmiVectDesc;								// The starting PMI LVT Vector descriptor
	INTELPT_PMI_HANDLER pCustomPmiIsr;					// The registered custom Kernel-Mode PMI Isr routine (if any)
	KAFFINITY kLastCpuAffinity;							// The last trace CPU affinity (used only in user-mode tracing)
	LIST_ENTRY userCallbackList;						// The user callback descriptor list
	KSPIN_LOCK userCallbackListLock;					// The user callback descriptor list spinlock
	// INTEL_PT_CAPABILITIES ptCapabilities;			// The Intel Processor Trace capabilities (moved to intelpt.h)
	// PKINTERRUPT pkPmiInterrupt = NULL;				// The PMI Interrupt Object (moved to intelpt.h)
	BOOLEAN IsUnderHyperV;
	// TODO: In the future move this to the PER_PROCESSOR_PT_DATA structure
	HYPERV_DATA HyperV_Data;
	PER_PROCESSOR_PT_DATA procData[ANYSIZE_ARRAY];		// An array of PER_PROCESSOR_PT_DATA structure (1 per processor)
}DRIVER_GLOBAL_DATA, *PDRIVER_GLOBAL_DATA;
extern DRIVER_GLOBAL_DATA * g_pDrvData;

// Driver entry point
DDKBUILD NTSTATUS DriverEntry(PDRIVER_OBJECT pDriverObject, PUNICODE_STRING pRegPath);

// Driver unload routine
VOID DriverUnload(PDRIVER_OBJECT pDrvObj);

// Create the shared PMI event
NTSTATUS CreateSharedPmiEvent(LPTSTR lpEvtName);

// The Inter-processor DPC type
enum DPC_TYPE {
	DPC_TYPE_ALLOC_BUFF,
	DPC_TYPE_FREE_BUFF,
	DPC_TYPE_START_PT,
	DPC_TYPE_PAUSE_PT,
	DPC_TYPE_CLEAR_PT
};
// The Inter-processor DPC structure
struct IPI_DPC_STRUCT {
	DPC_TYPE Type;
	DWORD dwCpu;
	IO_STATUS_BLOCK ioSb;
	KEVENT kEvt;
};

// DPC routine (needed to start/stop/pause the PT on a target CPU)
VOID IoCpuIpiDpc(struct _KDPC *Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2);

// Initialize each CPU XSave area (Experimental XSAVE support)
NTSTATUS InitializeCpusXSaveArea();

```

`WindowsPtDriver/DriverIo.cpp`:

```cpp
/**********************************************************************
 *  Windows Intel Processor Trace (PT) Driver
 * 	Filename: DriverIo.cpp
 *	Implements the I/O communication between the Driver and the User App
 *	Last revision: 01/06/2016
 *
 *  Copyright© 2016 Andrea Allievi, Richard Johnson 
 * 	Microsoft Ltd & TALOS Research and Intelligence Group
 *	All right reserved
 **********************************************************************/
#include "stdafx.h"
#include "DriverEntry.h"
#include "DriverIo.h"
#include "UndocNt.h"
#include "Debug.h"

// Driver generic pass-through routine
NTSTATUS DevicePassThrough(PDEVICE_OBJECT pDevObj, PIRP pIrp) 
{
	UNREFERENCED_PARAMETER(pDevObj);
	NTSTATUS ntStatus = STATUS_SUCCESS;
	pIrp->IoStatus.Status = ntStatus;
	pIrp->IoStatus.Information = 0;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return ntStatus;
}

// Driver unsupported routine
NTSTATUS DeviceUnsupported(PDEVICE_OBJECT pDevObj, PIRP pIrp) 
{
	UNREFERENCED_PARAMETER(pDevObj);
	NTSTATUS ntStatus = STATUS_NOT_SUPPORTED;
	pIrp->IoStatus.Status = ntStatus;
	pIrp->IoStatus.Information = 0;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return ntStatus;
}

// Driver create and close routine (pass through)
NTSTATUS DeviceCreate(PDEVICE_OBJECT pDevObj, PIRP pIrp) 
{ 
	return DevicePassThrough(pDevObj, pIrp); 
}	

NTSTATUS DeviceClose(PDEVICE_OBJECT pDevObj, PIRP pIrp) 
{ 
	return DevicePassThrough(pDevObj, pIrp); 
}

// Allocate the PT buffer for one or more CPUs
NTSTATUS AllocateCpuUserBuffers(KAFFINITY cpuAffinity, DWORD dwSize, LPVOID * lppBuffArray, DWORD * lpdwArraySize, BOOLEAN bUseToPA) {
	NTSTATUS ntStatus = 0;						// Returned NT_STATUS
	PER_PROCESSOR_PT_DATA * pCurCpuData = NULL;	// Per processor CPU data
	KAFFINITY kSysCpusAffinity = 0;				// The system CPU affinity mask
	DWORD dwCurProcId = 0;						// Current process ID
	DWORD dwNumOfBuffers = 0,					// Number of buffer to allocate
		dwCurIdx = 0;							// Current buffer index
	ULONG_PTR * lpBuffArray = NULL;				// The buffer array

	dwCurProcId = (DWORD)PsGetCurrentProcessId();
	KeQueryActiveProcessorCount(&kSysCpusAffinity);

	// Verify the CPU affinity
	if ((cpuAffinity | kSysCpusAffinity) != kSysCpusAffinity) return STATUS_INVALID_PARAMETER;
	if (dwSize < PAGE_SIZE) return STATUS_INVALID_PARAMETER;

	// Count the number of the CPU -> the number of buffer to allocate
	for (int i = 0; i < sizeof(KAFFINITY); i++) {
		if (!(cpuAffinity & (1i64 << i))) continue;
		pCurCpuData = &g_pDrvData->procData[i];
		if (pCurCpuData->lpUserVa != NULL ||
			(pCurCpuData->pPtBuffDesc && pCurCpuData->pPtBuffDesc->u.Simple.lpTraceBuffPhysAddr))
			// A buffer has been already allocated, the user need to get rid of this before proceed
			return STATUS_ADDRESS_ALREADY_EXISTS;			// STATUS_ALREADY_COMMITTED = 0xC0000021L - No Win32 translation
		dwNumOfBuffers++;
	}

	if (!dwNumOfBuffers) return STATUS_INVALID_PARAMETER;
	DrvDbgPrint("[" DRV_NAME "] Requested the allocation of 0x%08X bytes buffer for %i CPUs (affinity 0x%08X)",
		dwSize, dwNumOfBuffers, cpuAffinity);

	lpBuffArray = (ULONG_PTR*)ExAllocatePoolWithTag(PagedPool, dwNumOfBuffers * sizeof(ULONG_PTR), MEMTAG);
	RtlZeroMemory(lpBuffArray, dwNumOfBuffers * sizeof(ULONG_PTR));
	dwCurIdx = 0;

	for (int i = 0; i < sizeof(KAFFINITY); i++) {
		if (!(cpuAffinity & (1i64 << i))) continue;
		pCurCpuData = &g_pDrvData->procData[i];

		ntStatus = AllocCpuPtBuffer(i, (QWORD)dwSize, bUseToPA);
		if (NT_SUCCESS(ntStatus)) ntStatus = MapTracePhysBuffToUserVa(i);
		if (!NT_SUCCESS(ntStatus)) return ntStatus;
		lpBuffArray[dwCurIdx++] = (ULONG_PTR)pCurCpuData->lpUserVa;
		if (dwCurIdx >= dwNumOfBuffers) break;
	}

	if (lppBuffArray) *lppBuffArray = (LPVOID*)lpBuffArray;
	else ExFreePool(lpBuffArray);
	if (lpdwArraySize) *lpdwArraySize = (dwNumOfBuffers * sizeof(ULONG_PTR));

	return ntStatus;
}

// Free the PT buffer of the specified CPUs
NTSTATUS FreeCpuUserBuffers(KAFFINITY cpuAffinity) {
	NTSTATUS ntStatus = 0;						// Returned NT_STATUS
	KAFFINITY kSysCpusAffinity = 0;				// The system CPU affinity mask
	DWORD dwCurProcId = 0;						// Current process ID

	dwCurProcId = (DWORD)PsGetCurrentProcessId();
	KeQueryActiveProcessorCount(&kSysCpusAffinity);

	// Verify the CPU affinity
	if ((cpuAffinity | kSysCpusAffinity) != kSysCpusAffinity) return STATUS_INVALID_PARAMETER;

	// Count the number of the CPU -> the number of buffer to allocate
	for (int i = 0; i < sizeof(KAFFINITY); i++) {
		if (!(cpuAffinity & (1i64 << i))) continue;
		ntStatus = FreeCpuResources(i);
		if (!NT_SUCCESS(ntStatus)) return ntStatus;
	}
	return STATUS_SUCCESS;
}

// Search a PMI User-mode Callback entry and optionally remove it
#pragma code_seg(".nonpaged")
PMI_USER_CALLBACK_DESC * SearchCallbackEntry(LPVOID lpAddress, DWORD dwThrId, BOOLEAN bRemove) {
	KIRQL kOldIrql = KeGetCurrentIrql();
	PLIST_ENTRY pNextEntry = NULL;
	PPMI_USER_CALLBACK_DESC pFoundPmiDesc = NULL;

	KeAcquireSpinLock(&g_pDrvData->userCallbackListLock, &kOldIrql);
	// Be fast here
	pNextEntry = g_pDrvData->userCallbackList.Flink;
	while (pNextEntry != &g_pDrvData->userCallbackList) {
		PPMI_USER_CALLBACK_DESC pCurPmiDesc = NULL;
		pCurPmiDesc = CONTAINING_RECORD(pNextEntry, PMI_USER_CALLBACK_DESC, entry);
		if (pCurPmiDesc->lpUserAddress == lpAddress && PsGetThreadId(pCurPmiDesc->pTargetThread) == (HANDLE)dwThrId) {
			pFoundPmiDesc = pCurPmiDesc;
			if (bRemove) RemoveEntryList(pNextEntry);
			break;
		}
		pNextEntry = pNextEntry->Flink;
	}
	KeReleaseSpinLock(&g_pDrvData->userCallbackListLock, kOldIrql);
	return pFoundPmiDesc;
}
#pragma code_seg()


// The IOCTL dispatch routine
NTSTATUS DeviceIoControl(PDEVICE_OBJECT pDevObj, PIRP pIrp) 
{
	UNREFERENCED_PARAMETER(pDevObj);
	NTSTATUS ntStatus = STATUS_SUCCESS;					// Returned NTSTATUS
	PIO_STACK_LOCATION pIoStack = NULL;					// The I/O stack location
	DWORD dwInBuffSize = 0, dwOutBuffSize = 0;			// Input and output buffer size
	LPVOID lpOutBuff = NULL, lpInBuff = NULL;			// Input and output buffer
	KDPC * pkDpc = NULL;								// The target DPC (must be in NonPaged pool)
	ULONG dwNumOfCpus = 0;								// Total number of System CPUs
	KAFFINITY kSysCpusAffinity = 0;						// The system CPU affinity mask
	KAFFINITY kTargetCpusAffinity = 0;					// The target CPU affinity
	BOOLEAN bPause = FALSE;								// TRUE if we need to pause the trace
	IPI_DPC_STRUCT * pIpiDpcStruct = NULL;				// The IPC DPC struct
	PEPROCESS epTarget = NULL;							// Target EPROCESS (if any)
	PMI_USER_CALLBACK_DESC * pmiUserCallbackDesc = NULL;		// The PMI user callback descriptor (if any)

	pIoStack = IoGetCurrentIrpStackLocation(pIrp);
	dwInBuffSize = pIoStack->Parameters.DeviceIoControl.InputBufferLength;
	dwOutBuffSize = pIoStack->Parameters.DeviceIoControl.OutputBufferLength;

	dwNumOfCpus = KeQueryActiveProcessorCount(&kSysCpusAffinity);

	// Allocate the needed DPC structure (in Non Paged pool)
	pkDpc = (PKDPC)ExAllocatePoolWithTag(NonPagedPool, sizeof(KDPC), MEMTAG);
	pIpiDpcStruct = (IPI_DPC_STRUCT*)ExAllocatePoolWithTag(NonPagedPool, sizeof(IPI_DPC_STRUCT), MEMTAG);
	if (!pkDpc || !pIpiDpcStruct) 
		return STATUS_INSUFFICIENT_RESOURCES;
	RtlZeroMemory(pkDpc, sizeof(KDPC)); RtlZeroMemory(pIpiDpcStruct, sizeof(IPI_DPC_STRUCT));

	switch (pIoStack->Parameters.DeviceIoControl.IoControlCode) 
	{
		#pragma region Utility IOCTLs
		// Check the support for current processor and get the capabilities list
		case IOCTL_PTDRV_CHECKSUPPORT: 
		{
			// Input buffer: none
			// Output buffer: an optional QWORD value that contains the PT capabilities
			INTEL_PT_CAPABILITIES ptCap = { 0 };
			ntStatus = CheckIntelPtSupport(&ptCap);

			if (dwOutBuffSize >= sizeof(INTEL_PT_CAPABILITIES)) {
				RtlCopyMemory(pIrp->AssociatedIrp.SystemBuffer, &ptCap, sizeof(INTEL_PT_CAPABILITIES));
				pIrp->IoStatus.Information = sizeof(INTEL_PT_CAPABILITIES);
			} else {
				ntStatus = STATUS_NOT_IMPLEMENTED;
			}
			break;
		}

		// Get the trace details (total number of packets, etc)
		case IOCTL_PTDR_GET_TRACE_DETAILS:
		{
			lpInBuff = pIrp->AssociatedIrp.SystemBuffer;	// Input buffer: CPU number
			lpOutBuff = pIrp->AssociatedIrp.SystemBuffer;	// Output buffer: PT_TRACE_DETAILS structure

			// Parameters check
			if (dwInBuffSize < sizeof(DWORD) || dwOutBuffSize < sizeof(PT_TRACE_DETAILS)) {
				ntStatus = STATUS_INVALID_BUFFER_SIZE;
				break;
			}

			DWORD dwTargetCpu = *((DWORD*)lpInBuff);
			if (dwTargetCpu >= dwNumOfCpus || !(g_pDrvData->kLastCpuAffinity & (1i64 << dwTargetCpu))) {
				ntStatus = STATUS_INVALID_PARAMETER;
				break;
			}

			PER_PROCESSOR_PT_DATA & cpuData = g_pDrvData->procData[dwTargetCpu];
			PT_TRACE_DETAILS details = { 0 };

			if (cpuData.curState == PT_PROCESSOR_STATE_STOPPED)
				details.dwCurrentTraceState = PT_TRACE_STATE_STOPPED;
			else if (cpuData.curState == PT_PROCESSOR_STATE_PAUSED)
				details.dwCurrentTraceState = PT_TRACE_STATE_PAUSED;
			else if (cpuData.curState == PT_PROCESSOR_STATE_TRACING)
				details.dwCurrentTraceState = PT_TRACE_STATE_RUNNING;
			else
				details.dwCurrentTraceState = PT_TRACE_STATE_ERROR;

			if (cpuData.lpTargetProc)
				details.dwTargetProcId = (DWORD)PsGetProcessId(cpuData.lpTargetProc);

			details.dwCpuId = dwTargetCpu;
			if (cpuData.pPtBuffDesc)
				details.dwTraceBuffSize = (DWORD)cpuData.pPtBuffDesc->qwBuffSize;
			details.qwTotalNumberOfPackets = cpuData.PacketByteCount;
			details.IpFiltering.dwNumOfRanges = cpuData.dwNumOfActiveRanges;
			RtlCopyMemory(details.IpFiltering.Ranges, cpuData.IpRanges, cpuData.dwNumOfActiveRanges * sizeof(details.IpFiltering.Ranges[0]));

			RtlCopyMemory(lpOutBuff, &details, sizeof(PT_TRACE_DETAILS));
			pIrp->IoStatus.Information = sizeof(PT_TRACE_DETAILS);
			ntStatus = STATUS_SUCCESS;
			break;
		}
		#pragma endregion

		#pragma region Start/Stop - Pause/Resume trace IOCTLs
		// Start PT on one or more CPUs
		case IOCTL_PTDRV_START_TRACE: 
		{
			// Input buffer: a PT_USER_REQ that describes the tracing information
			// Output buffer: an optional array of LPVOID that contains the Virtual addresses of the USER mode buffers
			PT_USER_REQ * ptTraceStruct = NULL;
			DWORD dwTotalNumOfBuffs = 0,			// TOTAL number of buffers
				dwCurNumOfBuff = 0;					// The number of copied buffers
			lpInBuff = pIrp->AssociatedIrp.SystemBuffer;
			lpOutBuff = pIrp->AssociatedIrp.SystemBuffer;

			if (dwInBuffSize < sizeof(PT_USER_REQ)) {
				ntStatus = STATUS_INVALID_BUFFER_SIZE;
				break;
			}
			ptTraceStruct = (PT_USER_REQ*)lpInBuff;

			// Step 1. Parameters checking:
			// Verify the CPU mask affinity
			kTargetCpusAffinity = (KAFFINITY)ptTraceStruct->kCpuAffinity;
			if ((kSysCpusAffinity | kTargetCpusAffinity) != kSysCpusAffinity) {
				ntStatus = STATUS_INVALID_PARAMETER;
				break;
			}	

			// Grab the EPROCESS structure (if any)
			if (ptTraceStruct->dwProcessId > 0) {
				ntStatus = PsLookupProcessByProcessId((HANDLE)ptTraceStruct->dwProcessId, &epTarget);
				if (!NT_SUCCESS(ntStatus)) {
					ntStatus = STATUS_INVALID_PARAMETER;
					break;
				}
			}
			// Verify here that the ranges are correct
			int iNumOfRanges = (int)ptTraceStruct->IpFiltering.dwNumOfRanges;
			if (iNumOfRanges >= 4) { ntStatus = STATUS_INVALID_PARAMETER; break; }
	
			#ifndef _KERNEL_TRACE_FROM_USER_MODE_ENABLED
			BOOLEAN bIpWindowError = FALSE;
			for (int i = 0; i < iNumOfRanges; i++) {
				PT_TRACE_IP_FILTERING & filterDesc = ptTraceStruct->IpFiltering;
				if ((ULONG_PTR)filterDesc.Ranges[i].lpStartVa > (ULONG_PTR)MmHighestUserAddress ||
					(ULONG_PTR)filterDesc.Ranges[i].lpEndVa > (ULONG_PTR)MmHighestUserAddress) {
					bIpWindowError = TRUE;
					break;
				}
			}
			if (bIpWindowError) { ntStatus = STATUS_INVALID_PARAMETER; break; }
			#endif		

			ntStatus = STATUS_UNSUCCESSFUL;
			for (int i = 0; i < sizeof(kTargetCpusAffinity) * 8; i++) {
				if (!(kTargetCpusAffinity & (1i64 << i))) continue;
				PER_PROCESSOR_PT_DATA * pPerCpuData = &g_pDrvData->procData[i];
				QWORD qwBuffSize = IsPtBufferAllocatedAndValid(i, TRUE);
				BOOLEAN bNewVa = FALSE;

				if (qwBuffSize  && pPerCpuData->lpMappedProc != PsGetCurrentProcess()) 
					if (!NT_SUCCESS(UnmapTraceBuffToUserVa(i))) {
						ntStatus = STATUS_CONTEXT_MISMATCH;
						break;
					} else
						bNewVa = TRUE;

				if (qwBuffSize != (QWORD)ptTraceStruct->dwTraceSize || bNewVa) {
					// We need to re-allocate or re-map the buffer
					if (dwOutBuffSize < ((dwTotalNumOfBuffs + 1) * sizeof(LPVOID))) {
						// We do not have space to communicate back the buffer
						ntStatus = STATUS_INVALID_BUFFER_SIZE;
						break;
					}
					DrvDbgPrint("[" DRV_NAME "] (Re)allocating 0x%08X bytes of PT buffer for CPU %i...\r\n",
						ptTraceStruct->dwTraceSize, i);
					BOOLEAN bUseTopa = ((ptTraceStruct->dwOptsMask & PT_ENABLE_TOPA_MASK) != 0);
					if (qwBuffSize != (QWORD)ptTraceStruct->dwTraceSize)
						ntStatus = AllocateCpuUserBuffers((KAFFINITY)(1i64 << i), ptTraceStruct->dwTraceSize, NULL, NULL, bUseTopa);
					else if (bNewVa) 
						// Needs to be remapped here
						ntStatus = MapTracePhysBuffToUserVa(i);
					if (!NT_SUCCESS(ntStatus)) break;
				} else {
					ClearCpuPtBuffer(i);				// It is safe to call this here
					ntStatus = STATUS_SUCCESS;
				}
				dwTotalNumOfBuffs++;
			}
			if (!NT_SUCCESS(ntStatus)) break;

			// Reset the PMI event before start
			if (g_pDrvData->pPmiEvent)
				KeClearEvent(g_pDrvData->pPmiEvent);
			
			for (int iCpuNum = 0; iCpuNum < sizeof(kTargetCpusAffinity) * 8; iCpuNum++) {
				if (!(kTargetCpusAffinity & (1i64 << iCpuNum))) continue;

				// Allocate and run the DPC
				RtlZeroMemory(pIpiDpcStruct, sizeof(IPI_DPC_STRUCT));
				pIpiDpcStruct->dwCpu = iCpuNum;
				pIpiDpcStruct->Type = DPC_TYPE_START_PT;
				KeInitializeEvent(&pIpiDpcStruct->kEvt, SynchronizationEvent, FALSE);
				KeInitializeDpc(pkDpc, IoCpuIpiDpc, (PVOID)pIpiDpcStruct);
				KeSetTargetProcessorDpc(pkDpc, (CCHAR)iCpuNum);
				KeInsertQueueDpc(pkDpc, (LPVOID)ptTraceStruct, (LPVOID)epTarget); // Method-Buffered: passing ptTraceStruct is safe

				// Wait for the DPC to do its job
				KeWaitForSingleObject((PVOID)&pIpiDpcStruct->kEvt, Executive, KernelMode, FALSE, NULL);
				ntStatus = pIpiDpcStruct->ioSb.Status;
				if (!NT_SUCCESS(ntStatus)) break;
			}
			if (!NT_SUCCESS(ntStatus)) break;

			// Now copy the buffers (if needed)
			for (dwCurNumOfBuff = 0; dwCurNumOfBuff < dwTotalNumOfBuffs; dwCurNumOfBuff++) {
				LPVOID * lpBuffArray = (LPVOID*)lpOutBuff;
				if (dwOutBuffSize >= (dwCurNumOfBuff + 1) * sizeof(LPVOID))
					lpBuffArray[dwCurNumOfBuff] = g_pDrvData->procData[dwCurNumOfBuff].lpUserVa;
				else
					break;
			}
			
			// Set the last CPU affinity
			g_pDrvData->kLastCpuAffinity = kTargetCpusAffinity;
			pIrp->IoStatus.Information = dwCurNumOfBuff * sizeof(LPVOID);
			ntStatus = STATUS_SUCCESS;
			break;
		}

		// Stop a process trace
		case IOCTL_PTDRV_PAUSE_TRACE:
			bPause = TRUE;
		case IOCTL_PTDRV_RESUME_TRACE:
			// Method buffered
			lpInBuff = pIrp->AssociatedIrp.SystemBuffer;

			if (dwInBuffSize == sizeof(DWORD)) 
				kTargetCpusAffinity = (KAFFINITY)(*(DWORD*)lpInBuff);
			else if (dwInBuffSize >= sizeof(KAFFINITY))
				kTargetCpusAffinity = (*(KAFFINITY*)lpInBuff);
			else {
				ntStatus = STATUS_INVALID_BUFFER_SIZE;
				break;
			}

			for (int iCpuNum = 0; iCpuNum < sizeof(kTargetCpusAffinity); iCpuNum++) {
				if (!(kTargetCpusAffinity & (1i64 << iCpuNum))) continue;

				// Allocate and run the DPC
				RtlZeroMemory(pIpiDpcStruct, sizeof(IPI_DPC_STRUCT));
				pIpiDpcStruct->dwCpu = iCpuNum;
				pIpiDpcStruct->Type = DPC_TYPE_PAUSE_PT;
				KeInitializeEvent(&pIpiDpcStruct->kEvt, SynchronizationEvent, FALSE);
				KeInitializeDpc(pkDpc, IoCpuIpiDpc, (PVOID)pIpiDpcStruct);
				KeSetTargetProcessorDpc(pkDpc, (CCHAR)iCpuNum);
				KeInsertQueueDpc(pkDpc, (LPVOID)bPause, NULL);

				// Wait for the DPC to do its job
				KeWaitForSingleObject((PVOID)&pIpiDpcStruct->kEvt, Executive, KernelMode, FALSE, NULL);
				if (!NT_SUCCESS(pIpiDpcStruct->ioSb.Status)) break;
			}
			pIrp->IoStatus.Information = 0;
			ntStatus = pIpiDpcStruct->ioSb.Status;
			break;

		// Stop and clear Intel PT on one or more processors
		case IOCTL_PTDRV_CLEAR_TRACE:
			// Input buffer:  a DWORD or QWORD that contains the CPU affinity mask
			// Output buffer: None
			lpInBuff = pIrp->AssociatedIrp.SystemBuffer;

			if (dwInBuffSize == sizeof(DWORD))
				kTargetCpusAffinity = (KAFFINITY)(*(DWORD*)lpInBuff);
			else if (dwInBuffSize >= sizeof(KAFFINITY))
				kTargetCpusAffinity = (*(KAFFINITY*)lpInBuff);
			else {
				ntStatus = STATUS_INVALID_BUFFER_SIZE;
				break;
			}

			// Verify the CPU mask affinity
			if ((kSysCpusAffinity | kTargetCpusAffinity) != kSysCpusAffinity) {
				ntStatus = STATUS_INVALID_PARAMETER;
				break;
			}

			for (int iCpuNum = 0; iCpuNum < sizeof(kTargetCpusAffinity); iCpuNum++) {
				if (!(kTargetCpusAffinity & (1i64 << iCpuNum))) continue;

				if (!g_pDrvData->bManualAllocBuff)
					UnmapTraceBuffToUserVa((DWORD)iCpuNum);

				// Allocate and run the DPC
				RtlZeroMemory(pIpiDpcStruct, sizeof(IPI_DPC_STRUCT));
				pIpiDpcStruct->dwCpu = iCpuNum;
				pIpiDpcStruct->Type = DPC_TYPE_CLEAR_PT;
				KeInitializeEvent(&pIpiDpcStruct->kEvt, SynchronizationEvent, FALSE);
				KeInitializeDpc(pkDpc, IoCpuIpiDpc, (PVOID)pIpiDpcStruct);
				KeSetTargetProcessorDpc(pkDpc, (CCHAR)iCpuNum);
				KeInsertQueueDpc(pkDpc, NULL, NULL);

				// Wait for the DPC to do its job
				KeWaitForSingleObject((PVOID)&pIpiDpcStruct->kEvt, Executive, KernelMode, FALSE, NULL);
				ntStatus = pIpiDpcStruct->ioSb.Status;
				if (!NT_SUCCESS(ntStatus)) break;
			}
			pIrp->IoStatus.Information = 0;
			break;
			
		#pragma endregion

		#pragma region Buffer management IOCTLs
		// Free the previous allocated PT buffer for one or more CPUs (this should be the first Buffer IoCtl due to IOCTL_PTDRV_CLEAR_TRACE Ioctl code)
		case IOCTL_PTDRV_FREE_BUFFERS: {
			// Input buffer:  a DWORD or QWORD that contains the CPU affinity mask
			// Output buffer: None
			lpInBuff = pIrp->AssociatedIrp.SystemBuffer;
			if (dwInBuffSize == sizeof(DWORD))
				kTargetCpusAffinity = (KAFFINITY)(*(DWORD*)lpInBuff);
			else if (dwInBuffSize >= sizeof(KAFFINITY))
				kTargetCpusAffinity = (*(KAFFINITY*)lpInBuff);
			else {
				ntStatus = STATUS_INVALID_BUFFER_SIZE;
				break;
			}
			ntStatus = FreeCpuUserBuffers(kTargetCpusAffinity);
			if (NT_SUCCESS(ntStatus)) g_pDrvData->bManualAllocBuff = FALSE;
			break;
		}

		// Allocate the PT buffer for one or more CPUs
		case IOCTL_PTDRV_ALLOC_BUFFERS: {
			// Input buffer:  a partial PT_USER_REQ that describes the allocation information
			// Output buffer: an array of LPVOID that contains the Virtual addresses of the USER mode buffers
			PT_USER_REQ * ptTraceStruct = NULL;
			BOOLEAN bUseToPA = FALSE;
			DWORD dwNumOfBuffs = 0;
			LPVOID lpBuffArray = NULL;
			lpInBuff = pIrp->AssociatedIrp.SystemBuffer;
			lpOutBuff = pIrp->AssociatedIrp.SystemBuffer;

			if (dwInBuffSize < FIELD_OFFSET(PT_USER_REQ, dwProcessId)) {
				ntStatus = STATUS_INVALID_BUFFER_SIZE;
				break;
			} else
				ptTraceStruct = (PT_USER_REQ*)lpInBuff;

			// Verify the CPU mask affinity
			kTargetCpusAffinity = (KAFFINITY)ptTraceStruct->kCpuAffinity;
			if ((kSysCpusAffinity | kTargetCpusAffinity) != kSysCpusAffinity) {
				ntStatus = STATUS_INVALID_PARAMETER;
				break;
			}

			// Count the number of CPU specified here:
			for (int i = 0; i < sizeof(kTargetCpusAffinity) * 8; i++)
				if (ptTraceStruct->kCpuAffinity & (1i64 << i)) dwNumOfBuffs++;

			if (dwOutBuffSize < dwNumOfBuffs * sizeof(LPVOID)) {
				ntStatus = STATUS_INVALID_BUFFER_SIZE;
				break;
			}
			// Round up buffer size to be page aligned
			ptTraceStruct->dwTraceSize = ROUND_TO_PAGES(ptTraceStruct->dwTraceSize);

			// Consider the dwOptsMask as a bitmask and even as a simple BOOLEAN value
			bUseToPA = (ptTraceStruct->dwOptsMask == 1) || (ptTraceStruct->dwOptsMask & PT_ENABLE_TOPA_MASK);
			ntStatus = AllocateCpuUserBuffers(ptTraceStruct->kCpuAffinity, ptTraceStruct->dwTraceSize, &lpBuffArray, NULL, bUseToPA);
			if (NT_SUCCESS(ntStatus) && lpBuffArray) {
				RtlCopyMemory(lpOutBuff, lpBuffArray, dwNumOfBuffs * sizeof(LPVOID));
				pIrp->IoStatus.Information = dwNumOfBuffs * sizeof(LPVOID);
				g_pDrvData->bManualAllocBuff = TRUE;
			} 
			if (lpBuffArray) ExFreePool(lpBuffArray);
			break;
		}
		#pragma endregion

		#pragma region PMI Callbacks IOCTLs
		case IOCTL_PTDRV_REGISTER_PMI_ROUTINE: {
			// Input buffer: a PT_PMI_USER_CALLBACK data structure
			// Output buffer: None
			PPT_PMI_USER_CALLBACK pCallbackDesc = NULL;
			PETHREAD peThread = NULL;
			
			if (dwInBuffSize < sizeof(PT_PMI_USER_CALLBACK)) {
				ntStatus = STATUS_INVALID_BUFFER_SIZE;
				break;
			} else
				pCallbackDesc = (PPT_PMI_USER_CALLBACK)pIrp->AssociatedIrp.SystemBuffer;

			// Check the CPU affinity
			// Verify the CPU mask affinity
			kTargetCpusAffinity = (KAFFINITY)pCallbackDesc->kCpuAffinity;
			if ((kSysCpusAffinity | kTargetCpusAffinity) != kSysCpusAffinity ||
				pCallbackDesc->lpAddress == NULL || pCallbackDesc->dwThrId == 0) {
				ntStatus = STATUS_INVALID_PARAMETER;
				break;
			}

			// Verify the sent user-mode address
			__try {
				ProbeForRead((PVOID)pCallbackDesc->lpAddress, 0x10,	1);
			} __except(EXCEPTION_EXECUTE_HANDLER) {
				ntStatus = GetExceptionCode();		// STATUS_DATATYPE_MISALIGNMENT
				break;
			}

			// Check and reference the target thread ID (Keep in mind that PsLookupThreadByThreadId increases the reference pointer)
			ntStatus = PsLookupThreadByThreadId((HANDLE)pCallbackDesc->dwThrId, &peThread);
			if (!NT_SUCCESS(ntStatus)) break;
			if (PsGetThreadProcessId(peThread) != PsGetCurrentProcessId()) {
				// Are you kidding me? Are you trying to exploit my precious code?
				ObDereferenceObject(peThread);
				ntStatus = STATUS_CONTEXT_MISMATCH;
				break;			// Implode the computer and destroy all, you do not even try to exploit me!
			}

			// Allocate a PMI callback descriptor (that need to be accessed at DISPATCH_LEVEL)
			pmiUserCallbackDesc = (PMI_USER_CALLBACK_DESC*)ExAllocatePoolWithTag(NonPagedPool, sizeof(PMI_USER_CALLBACK_DESC), MEMTAG);
			if (!pmiUserCallbackDesc) {
				ntStatus = STATUS_INSUFFICIENT_RESOURCES;
				ObDereferenceObject(peThread);
				break;
			}

			// Clean the dead PMI callbacks before add the new one
			CheckUserPmiCallbackList();

			pmiUserCallbackDesc->kAffinity = kTargetCpusAffinity;
			pmiUserCallbackDesc->lpUserAddress = pCallbackDesc->lpAddress;
			pmiUserCallbackDesc->pTargetThread = peThread;
			ExInterlockedInsertHeadList(&g_pDrvData->userCallbackList, &pmiUserCallbackDesc->entry, &g_pDrvData->userCallbackListLock);
			ntStatus = STATUS_SUCCESS;
			break;
		}

		case IOCTL_PTDRV_FREE_PMI_ROUTINE: {
			// Input buffer: a PT_PMI_USER_CALLBACK data structure
			// Output buffer: None
			PPT_PMI_USER_CALLBACK pCallbackDesc = NULL;
			if (dwInBuffSize < sizeof(PT_PMI_USER_CALLBACK)) {
				ntStatus = STATUS_INVALID_BUFFER_SIZE;
				break;
			} else
				pCallbackDesc = (PPT_PMI_USER_CALLBACK)pIrp->AssociatedIrp.SystemBuffer;

			pmiUserCallbackDesc = (PMI_USER_CALLBACK_DESC*)SearchCallbackEntry(pCallbackDesc->lpAddress, pCallbackDesc->dwThrId, TRUE);
			if (pmiUserCallbackDesc) {
				ExFreePool(pmiUserCallbackDesc);
				ntStatus = STATUS_SUCCESS;
			} else
				ntStatus = STATUS_NOT_FOUND;
			break;
		}
		#pragma endregion

		#ifdef _DEBUG
		case IOCTL_PTDR_DO_KERNELDRV_TEST: {
			// USE this only in test environments:
			lpInBuff = pIrp->AssociatedIrp.SystemBuffer;
			if (dwInBuffSize < 2) return STATUS_INVALID_BUFFER_SIZE;

			DrvDbgPrint("[" DRV_NAME "] Received special Debug IOCTL. Do not use this in production environments!\r\n");
			ntStatus = DoDriverTraceTest((LPTSTR)lpInBuff);
			if (!NT_SUCCESS(ntStatus)) 
				DrvDbgPrint("[" DRV_NAME "] The Kernel mode tracing test has failed with 0x%08X status.", ntStatus);
			pIrp->IoStatus.Information = 0;
			break;
		}
		#endif	
		default:
			ntStatus = STATUS_NOT_SUPPORTED;
			break;
	}

	// Cleanup and complete the request
	if (pIpiDpcStruct) ExFreePool(pIpiDpcStruct);
	if (pkDpc) ExFreePool((LPVOID)pkDpc);
	pIrp->IoStatus.Status = ntStatus;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);

	// Do not forget to release the REFERENCE to the target EPROCESS (if any)
	if (epTarget) {
		ObDereferenceObject(epTarget);
	}
	return ntStatus;
}

#pragma code_seg(".nonpaged")
// DPC routine (needed to start/stop/pause the PT on a target CPU)
/* Arguments explanation:
 *   DeferredContext - Pointer to a structure that describe the DPC itself
 *   SysArg1 - the structure that describe the operation 
 *   SysArg2 - Any data that is not related to the DPC but can not acquired at DISPATCH_LEVEL. Ususally is the pointer to the target process. */
VOID IoCpuIpiDpc(struct _KDPC *Dpc, PVOID DeferredContext, PVOID SysArg1, PVOID SysArg2)
{
	UNREFERENCED_PARAMETER(Dpc);
	IPI_DPC_STRUCT * pIpiDpcStruct = (IPI_DPC_STRUCT*)DeferredContext;
	PT_USER_REQ * ptTraceUserStruct = NULL;
	DWORD dwCpuId = KeGetCurrentProcessorNumber();
	NTSTATUS ntStatus = STATUS_SUCCESS;

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

	switch (pIpiDpcStruct->Type) 
	{
		case DPC_TYPE_START_PT: {
			TRACE_OPTIONS opts = { 0 };
			ptTraceUserStruct = (PT_USER_REQ*)SysArg1;
			PEPROCESS pTargetProc = (PEPROCESS)SysArg2;
			if (ptTraceUserStruct->dwOptsMask)	{
				// Analyse here the trace options if any
				opts.All = ptTraceUserStruct->dwOptsMask;
				ntStatus = SetTraceOptions(dwCpuId, opts);
				if (!NT_SUCCESS(ntStatus)) break;
			}

			// Build the PT_TRACE_DESC structure and translate the PT_USER_REQ structure
			PT_TRACE_DESC ptDesc = { 0 };
			#ifndef _KERNEL_TRACE_FROM_USER_MODE_ENABLED
			ptDesc.bTraceKernel = FALSE;
			ptDesc.bTraceUser = TRUE;
			#else		
			ptDesc.bTraceUser = ptTraceUserStruct->bTraceUser;
			ptDesc.bTraceKernel = ptTraceUserStruct->bTraceKernel;
			if (!ptDesc.bTraceKernel && !ptDesc.bTraceUser) ptDesc.bTraceUser = 1;
			#endif		

			ptDesc.peProc = pTargetProc;
			ptDesc.dwNumOfRanges = ptTraceUserStruct->IpFiltering.dwNumOfRanges;
			if (ptDesc.dwNumOfRanges)
				RtlCopyMemory(ptDesc.Ranges, ptTraceUserStruct->IpFiltering.Ranges, sizeof(PT_TRACE_RANGE) * 4);

			// user input validated in DriverIo dispatch function
			ntStatus = StartCpuTrace(ptDesc, (QWORD)ptTraceUserStruct->dwTraceSize);
			break;
		}
		case DPC_TYPE_PAUSE_PT: {
			BOOLEAN bPause = (BOOLEAN)SysArg1;
			ntStatus = PauseResumeTrace(bPause);
			break;
		}
		case DPC_TYPE_CLEAR_PT: 
			ntStatus = StopAndDisablePt();
			if (!g_pDrvData->bManualAllocBuff && NT_SUCCESS(ntStatus))
				ntStatus = FreeCpuResources(dwCpuId);
			break;
	}

	// Raise the event
	pIpiDpcStruct->ioSb.Status = ntStatus;
	KeSetEvent(&pIpiDpcStruct->kEvt, IO_NO_INCREMENT, FALSE);
}

#pragma code_seg()

```

`WindowsPtDriver/DriverIo.h`:

```h
/**********************************************************************
 *  Windows Intel Processor Trace (PT) Driver
 *  Filename: DriverIo.h
 *  Define the I/O communication between the Driver and the User App
 *  Last revision: 01/06/2016
 *
 *  Copyright© 2016 Andrea Allievi, Richard Johnson
 *  TALOS Research and Intelligence Group and Microsoft Ltd
 *  All right reserved
 **********************************************************************/
#pragma once
#define INTEL_PT_PMI_EVENT_NAME L"IntelPtPmiEvt"			// The name of the synchronization event
#define _KERNEL_TRACE_FROM_USER_MODE_ENABLED 1				// Enable kernel mode tracing from user mode

#define PT_TRACE_CYC_PCKS_MASK				(1 << 0)		// CYC Packets
#define PT_TRACE_MTC_PCKS_MASK				(1 << 1)		// MTC Packets
#define PT_TRACE_TSC_PCKS_MASK				(1 << 2)		// TSC Packets
#define PT_TRACE_BRANCH_PCKS_MASK			(1 << 3)		// COFI-based packets: FUP, TIP, TIP.PGE, TIP.PGD, TNT, MODE.Exec, MODE.TSX.
#define PT_ENABLE_TOPA_MASK					(1 << 4)		// Table of Physical Addresses
#define PT_ENABLE_RET_COMPRESSION_MASK		(1 << 5)		// RET compression

struct PT_TRACE_IP_FILTERING {
	DWORD dwNumOfRanges;
	struct {
		LPVOID lpStartVa;
		LPVOID lpEndVa;
		BOOLEAN bStopTrace;
	} Ranges[4];
};

typedef struct _PT_USER_REQ {
	KAFFINITY kCpuAffinity;					// The target CPUs affinity mask
	DWORD dwTraceSize;						// Trace buffer size 
	DWORD dwOptsMask;						// The trace options bitmask
	DWORD dwProcessId;						// The target process ID (0 means ALL)
	PT_TRACE_IP_FILTERING IpFiltering;		// The IP ranges that we would like to trace (if any)
	BOOLEAN bTraceUser;						// TRUE if tracing User mode 
	BOOLEAN bTraceKernel;					// TRUE if tracing Kernel mode 
} PT_USER_REQ, * PPT_USER_REQ;

enum PT_TRACE_STATE {
	PT_TRACE_STATE_ERROR = -1,
	PT_TRACE_STATE_STOPPED,
	PT_TRACE_STATE_PAUSED,
	PT_TRACE_STATE_RUNNING
};

// The structure used to retrieve the details of a TRACE
typedef struct _PT_TRACE_DETAILS {
	DWORD dwTargetProcId;					// The target process to trace
	DWORD dwCpuId;							// Target processor ID
	DWORD dwTraceBuffSize;					// The Trace buffer size
	QWORD qwTotalNumberOfPackets;			// The total number of packets acquired until now
	PT_TRACE_IP_FILTERING IpFiltering;		// The IP ranges that we would like to trace (if any)
	PT_TRACE_STATE dwCurrentTraceState;		// The current tracing state
} PT_TRACE_DETAILS, *PPT_TRACE_DETAILS;

// The PMI User-mode callback routine
typedef VOID(*PMI_USER_CALLBACK_ROUTINE) (DWORD dwCpuId, PVOID lpBuffer, QWORD qwBufferSize);

// The PMI user-mode callback data structure
typedef struct _PT_PMI_USER_CALLBACK {
	KAFFINITY kCpuAffinity;					// The CPU affinity mask in which to execute this Callback
	PMI_USER_CALLBACK_ROUTINE lpAddress;	// User-mode address
	DWORD dwThrId;							// Thread ID in which to execute this callback
}PT_PMI_USER_CALLBACK, *PPT_PMI_USER_CALLBACK;

#ifndef WIN32
// Driver generic pass-through routine
NTSTATUS DevicePassThrough(PDEVICE_OBJECT pDevObj, PIRP pIrp);

// Driver Device IO Control dispatch routine
NTSTATUS DeviceIoControl(PDEVICE_OBJECT pDevObj, PIRP pIrp);

// Driver create and close routine
NTSTATUS DeviceCreate(PDEVICE_OBJECT pDevObj, PIRP pIrp);
NTSTATUS DeviceClose(PDEVICE_OBJECT pDevObj, PIRP pIrp);

// Driver unsupported routine
NTSTATUS DeviceUnsupported(PDEVICE_OBJECT pDevObj, PIRP pIrp);

// Allocate the PT buffer for one or more CPUs and map to the current process
NTSTATUS AllocateCpuUserBuffers(KAFFINITY cpuAffinity, DWORD dwSize, LPVOID * lppBuffArray, DWORD * lpdwArraySize, BOOLEAN bUseToPA);

// Free the PT buffer of the specified CPUs
NTSTATUS FreeCpuUserBuffers(KAFFINITY cpuAffinity);

// Search a PMI User-mode Callback entry and optionally remove it
PMI_USER_CALLBACK_DESC * SearchCallbackEntry(LPVOID lpAddress, DWORD dwThrId, BOOLEAN bRemove = FALSE);

#else
#include <WinIoCtl.h>
/*
*   IOCTL's are defined by the following bit layout.
* [Common |Device Type|Required Access|Custom|Function Code|Transfer Type]
*   31     30       16 15          14  13   12           2  1            0
*
*   Common          - 1 bit.  This is set for user-defined device types.
*   Device Type     - This is the type of device the IOCTL belongs to.
*					   This can be user defined (Common bit set).
*					   This must match the device type of the device object.
*   Required Access - FILE_READ_DATA, FILE_WRITE_DATA, etc.
*                     This is the required access for the  device.
*   Custom          - 1 bit.  This is set for user-defined IOCTL's.
*					   This is used in the same manner as "WM_USER".
*   Function Code   - This is the function code that the system or the
*					   user defined (custom bit set)
*   Transfer Type   - METHOD_IN_DIRECT, METHOD_OUT_DIRECT, METHOD_NEITHER,
*					   METHOD_BUFFERED, This the data transfer method to be used.
*/

#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
	((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
	)
#endif

// Check the support for current processor and get the capabilities list
#define IOCTL_PTDRV_CHECKSUPPORT CTL_CODE(FILE_DEVICE_UNKNOWN, 0xA01, METHOD_BUFFERED, FILE_READ_DATA)

// Allocate and return the buffer for one or more processors
#define IOCTL_PTDRV_ALLOC_BUFFERS CTL_CODE(FILE_DEVICE_UNKNOWN, 0xA0D, METHOD_BUFFERED, FILE_EXECUTE)
// Free and cleanup the PT buffer for one or more processors
#define IOCTL_PTDRV_FREE_BUFFERS CTL_CODE(FILE_DEVICE_UNKNOWN, 0xA0F, METHOD_BUFFERED, FILE_EXECUTE)

// Start a particular process trace
#define IOCTL_PTDRV_START_TRACE CTL_CODE(FILE_DEVICE_UNKNOWN, 0xA03, METHOD_BUFFERED, FILE_EXECUTE)
// Pause a process trace (needed to reliably read a TRACE)
#define IOCTL_PTDRV_PAUSE_TRACE CTL_CODE(FILE_DEVICE_UNKNOWN, 0xA05, METHOD_BUFFERED, FILE_EXECUTE)
// Resume a process trace (needed to reliably read a TRACE)
#define IOCTL_PTDRV_RESUME_TRACE CTL_CODE(FILE_DEVICE_UNKNOWN, 0xA07, METHOD_BUFFERED, FILE_EXECUTE)
// Stop, cleanup a process trace and free the resource
#define IOCTL_PTDRV_CLEAR_TRACE CTL_CODE(FILE_DEVICE_UNKNOWN, 0xA09, METHOD_BUFFERED, FILE_EXECUTE)
// Get the TRACE details (like total number of packets and so on)
#define IOCTL_PTDR_GET_TRACE_DETAILS CTL_CODE(FILE_DEVICE_UNKNOWN, 0xA0B, METHOD_BUFFERED, FILE_READ_DATA | FILE_EXECUTE)

// Register a user-mode Callback routine for the PMI interrupt
#define IOCTL_PTDRV_REGISTER_PMI_ROUTINE CTL_CODE(FILE_DEVICE_UNKNOWN, 0xA12, METHOD_BUFFERED, FILE_WRITE_DATA)
// Remove a user-mode callback routine for the PMI interrupt
#define IOCTL_PTDRV_FREE_PMI_ROUTINE CTL_CODE(FILE_DEVICE_UNKNOWN, 0xA14, METHOD_BUFFERED, FILE_WRITE_DATA)


```

`WindowsPtDriver/Export.def`:

```def
;  Windows Intel Processor Trace (PT) Driver
;  Filename: Exports.def
;  Defines all the exported functions of the kernel driver, used for tracing Kernel code
;  Last revision: 01/06/2016
LIBRARY WindowsPtDriver

EXPORTS
	IntelPtCheckCpuSupport = CheckIntelPtSupport
	IntelPtAllocBuffer
	IntelPtAddBufferPmi
	IntelPtRemoveBufferPmi
	IntelPtPauseResumeTrace = PauseResumeTrace
	IntelPtStopTrace
	IntelPtFreeBuffer = FreePtBuffer
	IntelPtRegisterPmiHandler
	IntelPtRemovePmiHandler
	IntelPtSetOptions
	IntelPtGetOptions



```

`WindowsPtDriver/HyperV.cpp`:

```cpp
/**********************************************************************
*  Windows Intel Processor Trace (PT) Driver
*  Filename: HyperV.cpp
*  Implements the HyperV support for IntelPt
*  Last revision: xx/xx/2017
*
*  Copyright© 2017 Andrea Allievi, Richard Johnson
*  Microsoft Ltd and TALOS Research and Intelligence Group
*  All right reserved
**********************************************************************/
#include "stdafx.h"
#include "DriverEntry.h"
#include <hv.h>
#include "Debug.h"
#include <intrin.h>

// This routine detects if the system is under a not-obfuscated hypervisor, and,
// if so, it detect if the Hypervisor is Microsoft HyperV
NTSTATUS DetectMicrosoftHyperV(HYPERV_INFO * HyperVInfo) {
	int CpuInfo[4] = { 0 };
	HYPERV_INFO HvInfo = { 0 };
	BOOLEAN IsMicrosoftHv = FALSE;

	// Follow the SPECS
	__cpuidex(CpuInfo, 0x40000000, 0);
	IsMicrosoftHv = memcmp(&CpuInfo[1], "Microsoft Hv", sizeof(DWORD) * 3) == 0;
	if (!IsMicrosoftHv ||
		CpuInfo[0] < 0x40000005)
		return STATUS_NOT_FOUND;

	__cpuidex(CpuInfo, 0x40000001, 0);
	if (CpuInfo[0] != (DWORD)'1#vH')
		return STATUS_NOT_FOUND;

	if (!HyperVInfo)
		return STATUS_SUCCESS;

	// ... Grab the HyperV Information
	__cpuidex(CpuInfo, 0x40000002, 0);
	HvInfo.Build = (DWORD)CpuInfo[0];
	HvInfo.MajorVersion = (WORD)(CpuInfo[1] >> 16);
	HvInfo.MinorVersion = (WORD)CpuInfo[1];
	HvInfo.ServicePack = (DWORD)CpuInfo[2];
	HvInfo.ServiceBranch = (UCHAR)(CpuInfo[3] >> 24) & 0xFF;
	HvInfo.ServiceNumber = (DWORD)(CpuInfo[3] & 0xFFFFFF);

	// Grab the HyperV partition features 
	__cpuidex(CpuInfo, 0x40000003, 0);
	RtlCopyMemory(&HvInfo.Features, CpuInfo, sizeof(HYPERV_FEATURES));

	*HyperVInfo = HvInfo;
	return STATUS_SUCCESS;
}

// Emit an HyperV real CPUINFO
NTSTATUS HvCpuId(int CpuInfo[4], int Function, int SubLeaf) {
	HV_HYPERCALL_INFO HvCallInfo = { 0 };				// Hypercall Input structure
	HV_HYPERCALL_OUTPUT HvOutput = { 0 };				// Hypercall output
	PHV_LOGICAL_PROC_REGISTERS_INPUT HvInput = NULL;	// HvCallGetLogicalProcessorRegisters input buffer
	DWORD * CpuIdDataPtr = NULL;						// HvCallGetLogicalProcessorRegisters output buffer
	ULONG CpuNumber = 0;								// The current CPU Number
	KIRQL OldIrql = 0;									// Previous processor IRQL
	HV_STATUS HvStatus = 0;								// Returned status from the Hypervisor
	PHYPERV_DATA pHvData = NULL;
	
	// Grab the global data
	if (!g_pDrvData) return STATUS_INVALID_DEVICE_STATE;
	pHvData = (PHYPERV_DATA)&g_pDrvData->HyperV_Data;

	// HvCallGetLogicalProcessorRegisters is a REP hypercall.
	HvCallInfo.AsUINT64 = HvCallGetLogicalProcessorRegisters;
	HvCallInfo.Fields.CountOfElements = 1;

	if (!pHvData->IsValid)
		return STATUS_UNSUCCESSFUL;

	// Protect this code from pre-emption
	KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
	CpuNumber = KeGetCurrentProcessorNumber();

	// From the TLFS: Callers must specify the 64-bit guest physical address (GPA) of the input and/or output parameters. GPA pointers must by 8-byte aligned (page 17)
	HvInput = (PHV_LOGICAL_PROC_REGISTERS_INPUT)pHvData->InputPage.VirtualAddr;
	CpuIdDataPtr = (DWORD*)pHvData->OutputPage.VirtualAddr;

	HvInput->VCpuIndex = CpuNumber;
	HvInput->Type = HvX64LpRegisterTypeCpuid;
	HvInput->Address.CpuId.Eax = (DWORD)Function;
	HvInput->Address.CpuId.Ecx = (DWORD)SubLeaf;

	// Perform the actual Hypercall
	HvOutput = pHvData->CallHv(HvCallInfo, pHvData->InputPage.PhysicalAddr, pHvData->OutputPage.PhysicalAddr);
	KeLowerIrql(OldIrql);

	HvStatus = HvOutput.Fields.Result;
	if (HvStatus == HV_STATUS_SUCCESS)
	{
		RtlCopyMemory(CpuInfo, pHvData->OutputPage.VirtualAddr, sizeof(int) * 4);
	}
	// ALWAYS zero out the used buffers
	RtlZeroMemory(pHvData->OutputPage.VirtualAddr, PAGE_SIZE);
	RtlZeroMemory(pHvData->InputPage.VirtualAddr, PAGE_SIZE);

	return (HvStatusToNtStatus(HvStatus));
}

// Initialize HyperV data structures and memory
NTSTATUS InitGlobalHv() {
	NTSTATUS NtStatus = STATUS_SUCCESS;
	HYPERV_INFO HvInfo = { 0 };
	HV_MEMDESC MemDesc = { 0 };									// Current Memory Descriptor
	PHYSICAL_ADDRESS physMaxAddr = { 0 };						// The maximum acceptable physical address
	HV_X64_MSR_HYPERCALL_DESC HypercallMsr = { 0 };				// The Hypercall MSR
	PHYPERV_DATA pHvData = NULL;

	// Grab the global data
	if (!g_pDrvData) return STATUS_INVALID_DEVICE_STATE;
	pHvData = (PHYPERV_DATA)&g_pDrvData->HyperV_Data;

	NtStatus = DetectMicrosoftHyperV(&HvInfo);
	if (!NT_SUCCESS(NtStatus))
	{
		DrvDbgPrint("InitGlobalHv - No Hypervisor detected, or Hypervisor is not HyperV\r\n");
		return STATUS_NOT_FOUND;
	}
	pHvData->Info = HvInfo;

	// Allocate memory for the Hypercalls
	physMaxAddr.QuadPart = (LONGLONG)-1;
	MemDesc.Size = PAGE_SIZE;
	MemDesc.VirtualAddr = MmAllocateContiguousMemory(PAGE_SIZE, physMaxAddr);
	if (MemDesc.VirtualAddr) {
		MemDesc.PhysicalAddr = MmGetPhysicalAddress(MemDesc.VirtualAddr);
		RtlZeroMemory(MemDesc.VirtualAddr, PAGE_SIZE);
	}
	pHvData->InputPage = MemDesc;

	// Output page
	RtlZeroMemory(&MemDesc, sizeof(HV_MEMDESC));
	MemDesc.VirtualAddr = MmAllocateContiguousMemory(PAGE_SIZE, physMaxAddr);
	MemDesc.Size = PAGE_SIZE;
	if (MemDesc.VirtualAddr) {
		MemDesc.PhysicalAddr = MmGetPhysicalAddress(MemDesc.VirtualAddr);
		RtlZeroMemory(MemDesc.VirtualAddr, PAGE_SIZE);
	}
	pHvData->OutputPage = MemDesc;

	if (!pHvData->InputPage.VirtualAddr ||
		!pHvData->OutputPage.VirtualAddr)
	{
		if (pHvData->InputPage.VirtualAddr)
			MmFreeContiguousMemory(pHvData->InputPage.VirtualAddr);
		if (pHvData->OutputPage.VirtualAddr)
			MmFreeContiguousMemory(pHvData->OutputPage.VirtualAddr);
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	// Discover the Hypercall page (page 26 of the TLFS Specs)
	HypercallMsr.AsUINT64 = __readmsr(HV_X64_MSR_HYPERCALL);
	if (!HypercallMsr.Fields.EnableHypercallPage || !HypercallMsr.Fields.HypercallGPA)
	{
		// Internal error, this should be not the case
		MmFreeContiguousMemory(pHvData->InputPage.VirtualAddr);
		MmFreeContiguousMemory(pHvData->OutputPage.VirtualAddr);
		return STATUS_INTERNAL_ERROR;
	}

	// Map this Physical page
	RtlZeroMemory(&MemDesc, sizeof(HV_MEMDESC));
	MemDesc.PhysicalAddr.QuadPart = ((UINT64)HypercallMsr.Fields.HypercallGPA << 12);
	MemDesc.VirtualAddr = MmMapIoSpace(MemDesc.PhysicalAddr, PAGE_SIZE, MmNonCached);
	MemDesc.Size = PAGE_SIZE;
	pHvData->HypercallPage = MemDesc;
	pHvData->CallHv = (PHV_PERFORM_HYPERCALL)MemDesc.VirtualAddr;

	// Finalize the configuration
	pHvData->IsValid = TRUE;
	return STATUS_SUCCESS;
}

// Destroy the HyperV data structures and memory
VOID DestroyGlobalHv() {
	PHYPERV_DATA pHvData = NULL;

	// Grab the global data
	if (!g_pDrvData) return;
	pHvData = (PHYPERV_DATA)&g_pDrvData->HyperV_Data;

	if (pHvData->InputPage.VirtualAddr)
		MmFreeContiguousMemory(pHvData->InputPage.VirtualAddr);
	if (pHvData->OutputPage.VirtualAddr)
		MmFreeContiguousMemory(pHvData->OutputPage.VirtualAddr);
	if (pHvData->HypercallPage.VirtualAddr)
		MmUnmapIoSpace(pHvData->HypercallPage.VirtualAddr, PAGE_SIZE);
}

// Utility function that converts a HV_STATUS value in its correspondent NTSTATUS (if any)
NTSTATUS HvStatusToNtStatus(HV_STATUS HvStatus) {
	NTSTATUS ntStatus = (NTSTATUS)0;

	if (HvStatus == HV_STATUS_SUCCESS)
		ntStatus = STATUS_SUCCESS;
	else if (HvStatus == HV_STATUS_UNSUCCESSFUL)
		ntStatus = STATUS_UNSUCCESSFUL;
	else if (HvStatus >= 0x1000)
		// No corrispondent NTSTATUS value here
		ntStatus = STATUS_INVALID_PARAMETER;
	else
		// For all others, return the equivalent STATUS_HV* codes.
		ntStatus = (NTSTATUS)(0xC0350000 | HvStatus);

	return ntStatus;
}
```

`WindowsPtDriver/IntelPt.cpp`:

```cpp
/**********************************************************************
 *  Windows Intel Processor Trace (PT) Driver
 * 	Filename: IntelPt.cpp
 *	Implement the Intel Processor Trace driver
 *	Last revision: 01/06/2016
 *
 *  Copyright© 2016 Andrea Allievi, Richard Johnson 
 * 	Microsoft Ltd & TALOS Research and Intelligence Group
 *	All right reserved
 **********************************************************************/
#include "stdafx.h"
#include "DriverEntry.h"
#include "IntelPt.h"
#include "Debug.h"
#include "UndocNt.h"
#include "IntelPtXSave.h"
#include <hv.h>
#include <intrin.h>

#define DirectoryTableBaseOffset 0x28

#pragma region Intel PT management functions
#pragma code_seg(".nonpaged")
// Emit a REAL CpuId opcode (bypassing the Hypervisor if needed)
void CPUIDEX(int CpuInfo[4], int Function, int Leaf) {
	NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
	if (g_pDrvData && g_pDrvData->IsUnderHyperV) 
	{
		// If this is not the root partition, we normally do not have the 
		// "CpuManagement" Partition privilege
		if (g_pDrvData->HyperV_Data.Info.Features.PartitionPrivilegeMask.CpuManagement != 0)
			ntStatus = HvCpuId(CpuInfo, Function, Leaf);
		else
			// Rely on the standard CPUID instruction
			ntStatus = STATUS_ACCESS_DENIED;
	}
	
	if (!NT_SUCCESS(ntStatus))
		return __cpuidex(CpuInfo, Function, Leaf);
}

NTSTATUS CheckIntelPtSupport(INTEL_PT_CAPABILITIES * lpPtCap)
{
	INTEL_PT_CAPABILITIES ptCap = { 0 };			// The processor PT capabilities
	MSR_IA32_VMX_MISC_CTLS_DESC VmxMisc = { 0 };	// The VMX miscellaneous data
	int cpuid_ctx[4] = { 0 };						// EAX, EBX, ECX, EDX
	KIRQL kIrql = KeGetCurrentIrql();

	// Processor support for Intel Processor Trace is indicated by CPUID.(EAX=07H,ECX=0H):EBX[bit 25] = 1.
	CPUIDEX(cpuid_ctx, 0x07, 0);
	if ((cpuid_ctx[1] & (1 << 25)) == 0) 
		return STATUS_NOT_SUPPORTED;

	// We can return now if capability struct was not requested
	if (!lpPtCap)
		return STATUS_SUCCESS;

	// Enumerate the Intel Processor Trace capabilities
	RtlZeroMemory(cpuid_ctx, sizeof(cpuid_ctx));
	CPUIDEX(cpuid_ctx, 0x14, 0);
	ptCap.bCr3Filtering = (cpuid_ctx[1] & (1 << 0)) != 0;					// EBX
	ptCap.bConfPsbAndCycSupported = (cpuid_ctx[1] & (1 << 1)) != 0;
	ptCap.bIpFiltering = (cpuid_ctx[1] & (1 << 2)) != 0;
	ptCap.bMtcSupport = (cpuid_ctx[1] & (1 << 3)) != 0;
	ptCap.bTopaOutput = (cpuid_ctx[2] & (1 << 0)) != 0;						// ECX
	ptCap.bTopaMultipleEntries = (cpuid_ctx[2] & (1 << 1)) != 0;
	ptCap.bSingleRangeSupport = (cpuid_ctx[2] & (1 << 2)) != 0;
	ptCap.bTransportOutputSupport = (cpuid_ctx[2] & (1 << 3)) != 0;
	ptCap.bIpPcksAreLip = (cpuid_ctx[2] & (1 << 31)) != 0;

	// Enumerate secondary capabilities (sub-leaf 1)
	if (cpuid_ctx[0] != 0)
	{
		RtlZeroMemory(cpuid_ctx, sizeof(cpuid_ctx));
		CPUIDEX(cpuid_ctx, 0x14, 1);
		ptCap.numOfAddrRanges = (BYTE)(cpuid_ctx[0] & 0x7);
		ptCap.mtcPeriodBmp = (SHORT)((cpuid_ctx[0] >> 16) & 0xFFFF);
		ptCap.cycThresholdBmp = (SHORT)(cpuid_ctx[1] & 0xFFFF);
		ptCap.psbFreqBmp = (SHORT)((cpuid_ctx[1] >> 16) & 0xFFFF);
	}
 
	// Get if the PT is compatible with the Hypervisors here:
	if (kIrql < DISPATCH_LEVEL)
	{
		__try
		{
			VmxMisc.All = __readmsr(MSR_IA32_VMX_MISC_CTLS);
		} 
		__except (EXCEPTION_EXECUTE_HANDLER)
		{
			// Some Hypervisors (like HyperV) detect the read to VMX_MISC_CTLS and raise an exception
			VmxMisc.All = 0;
		}
	}
	ptCap.bVmxSupport = VmxMisc.Fields.IntelPtVmxSupport;
	if (VmxMisc.Fields.IntelPtVmxSupport == 1)
		DrvDbgPrint("CheckIntelPtSupport - The processor supports Intel PT in VMX operations.\r\n");

	*lpPtCap = ptCap;
	return STATUS_SUCCESS;
}

// Enable the Intel PT trace for current processor 
NTSTATUS StartCpuTrace(PT_TRACE_DESC desc, PT_BUFFER_DESCRIPTOR * pPtBuffDesc) {
	NTSTATUS ntStatus = STATUS_NOT_SUPPORTED;				// Returned NTSTATUS value
	INTEL_PT_CAPABILITIES ptCap = { 0 };					// The per-processor PT capabilities
	PER_PROCESSOR_PT_DATA * lpProcPtData = NULL;			// The per processor data structure
	ULONG_PTR targetCr3 = 0;								// The target CR3 value
	KIRQL kOldIrql = KeGetCurrentIrql();					// The current IRQL
	ULONG curProcId = KeGetCurrentProcessorNumber();		// Current processor number
	if (!pPtBuffDesc) return STATUS_INVALID_PARAMETER;
	if (!g_pDrvData) return STATUS_INTERNAL_ERROR;
	
	// PT data structures
	MSR_RTIT_CTL_DESC rtitCtlDesc = { 0 };
	MSR_RTIT_STATUS_DESC rtitStatusDesc = { 0 };
	MSR_RTIT_OUTPUTBASE_DESC rtitOutBaseDesc = { 0 };
	MSR_RTIT_OUTPUT_MASK_PTRS_DESC rtitOutMasksDesc = { 0 };
	if (!pPtBuffDesc || !pPtBuffDesc->qwBuffSize) return STATUS_INVALID_PARAMETER_2;

	ntStatus = CheckIntelPtSupport(&ptCap);
	if (!NT_SUCCESS(ntStatus)) return ntStatus;

	// Check here the support based on the Trace structure
	if (desc.peProc != NULL)
		// Check the support for CR3 filtering
		if (!ptCap.bCr3Filtering) return STATUS_NOT_SUPPORTED;
	if (desc.dwNumOfRanges > 0) {
		if (!ptCap.bIpFiltering) return STATUS_NOT_SUPPORTED;
		if (desc.dwNumOfRanges > 4) return STATUS_INVALID_PARAMETER_1;
		if ((DWORD)ptCap.numOfAddrRanges < desc.dwNumOfRanges) return STATUS_NOT_SUPPORTED;
	}
	// Now check the output mode
	if (!ptCap.bSingleRangeSupport && !ptCap.bTopaOutput) return STATUS_NOT_SUPPORTED;

	// To proper read the value of the CR3 register of a target process, the KiSwapProcess routines does this:
	// From KTHREAD go to ETHREAD, then use the ApcState field to return back to a EPROCESS
	// Finally grab it from peProc->DirectoryTableBase (offset + 0x28) 
	if (desc.peProc) {
		targetCr3 = ((ULONG_PTR *)desc.peProc)[5];
		// Check the found target CR3 (it should have the last 12 bits set to 0, due to the PFN standard)
		if ((targetCr3 & 0xFFF) != 0) return STATUS_INVALID_ADDRESS;
		DrvDbgPrint("[" DRV_NAME "] Starting Intel Processor Trace for processor %i. Target CR3: 0x%llX\r\n", curProcId, targetCr3);
	}
	else if (desc.bTraceKernel)
		DrvDbgPrint("[" DRV_NAME "] Starting Intel Processor Trace for processor %i. Tracing Kernel address space...\r\n", curProcId);
	else 
		DrvDbgPrint("[" DRV_NAME "] Starting Intel Processor Trace for processor %i. Tracing all user mode processes.\r\n", curProcId);

	if (desc.dwNumOfRanges > 0)
		DrvDbgPrint("[" DRV_NAME "] Enabled %i filtering windows. IP range 1. Start VA: 0x%llX, Size 0x%08X\r\n ",
			desc.dwNumOfRanges, (LPVOID)desc.Ranges[0].lpStartVa, (LPVOID)((DWORD)((QWORD)desc.Ranges[0].lpEndVa - (QWORD)desc.Ranges[0].lpStartVa)));

	// Check if the passed data structure that describe the buffer is valid
	if ((pPtBuffDesc->bUseTopa && !ptCap.bTopaOutput) ||
		pPtBuffDesc->qwBuffSize < PAGE_SIZE ||
		(!pPtBuffDesc->bUseTopa && !ptCap.bSingleRangeSupport) ||
		!pPtBuffDesc->u.Simple.lpTraceBuffPhysAddr)
		return STATUS_INVALID_PARAMETER_2;

	// Initially set up all the descriptor data in the Per-processor control structure
	lpProcPtData = &g_pDrvData->procData[curProcId];
	lpProcPtData->lpTargetProcCr3 = targetCr3;
	lpProcPtData->lpTargetProc = desc.peProc;
	if (desc.dwNumOfRanges) {
		RtlZeroMemory(lpProcPtData->IpRanges, sizeof(lpProcPtData->IpRanges));
		RtlCopyMemory(lpProcPtData->IpRanges, desc.Ranges, desc.dwNumOfRanges * sizeof(PT_TRACE_RANGE));
		lpProcPtData->dwNumOfActiveRanges = desc.dwNumOfRanges;
	}

	// Check if the options have been initialized
	if (!lpProcPtData->TraceOptions.Fields.bInitialized)
		SetDefaultTraceOptions(curProcId);

	// Raise the IRQL (we don't want to be swapped out)
	if (kOldIrql < DISPATCH_LEVEL)
		KeRaiseIrql(DISPATCH_LEVEL, &kOldIrql);

	// Step 1. Disable all the previous PT flags
	DBG_BREAK();
	rtitCtlDesc.All = __readmsr(MSR_IA32_RTIT_CTL);
	rtitCtlDesc.Fields.TraceEn = 0;
	__writemsr(MSR_IA32_RTIT_CTL, rtitCtlDesc.All);
	ASSERT(__readmsr(MSR_IA32_RTIT_CTL) == rtitCtlDesc.All);

	// Clear IA32_RTIT_STATUS MSR
	rtitStatusDesc.All = __readmsr(MSR_IA32_RTIT_STATUS);
	rtitStatusDesc.Fields.Error = 0;						// See Intel's manuals, section 36.3.2.1
	rtitStatusDesc.Fields.Stopped = 0;
	rtitStatusDesc.Fields.ContextEn = 0;
	rtitStatusDesc.Fields.PacketByteCnt = 0;				// Restore the Byte counter to 0
	lpProcPtData->PacketByteCount = 0;						// In both values
	__writemsr(MSR_IA32_RTIT_STATUS, rtitStatusDesc.All);

	// Set the IA32_RTIT_OUTPUT and IA32_RTIT_OUTPUT_MASK_PTRS MSRs
	if (pPtBuffDesc->bUseTopa)
	{
		// Use Table of Physical Addresses 
		rtitCtlDesc.Fields.ToPA = 1;

		// Set the proc_trace_table_base
		rtitOutBaseDesc.All = (ULONGLONG)pPtBuffDesc->u.ToPA.lpTopaPhysAddr;
		__writemsr(MSR_IA32_RTIT_OUTPUT_BASE, rtitOutBaseDesc.All);
		ASSERT(__readmsr(MSR_IA32_RTIT_OUTPUT_BASE) == rtitOutBaseDesc.All);

		// Set the proc_trace_table_offset: indicates the entry of the current table that is currently in use
		rtitOutMasksDesc.Fields.LowerMask = 0x7F;
		rtitOutMasksDesc.Fields.MaskOrTableOffset = 0;		// Start from the first entry in the table
		rtitOutMasksDesc.Fields.OutputOffset = 0;			// Start at offset 0
		__writemsr(MSR_IA32_RTIT_OUTPUT_MASK_PTRS, rtitOutMasksDesc.All);
		ASSERT(__readmsr(MSR_IA32_RTIT_OUTPUT_MASK_PTRS) == rtitOutMasksDesc.All);
	}
	else
	{
		// Use the single range output implementation
		rtitCtlDesc.Fields.ToPA = 0;						// We use the single-range output scheme
		rtitOutBaseDesc.All = (ULONGLONG)pPtBuffDesc->u.Simple.lpTraceBuffPhysAddr;
		__writemsr(MSR_IA32_RTIT_OUTPUT_BASE, rtitOutBaseDesc.All);
		ASSERT(__readmsr(MSR_IA32_RTIT_OUTPUT_BASE) == rtitOutBaseDesc.All);

		rtitOutMasksDesc.All = (1 << PAGE_SHIFT) - 1;		// The physical page always has low 12 bits NULL
		__writemsr(MSR_IA32_RTIT_OUTPUT_MASK_PTRS, rtitOutMasksDesc.All);
		ASSERT(__readmsr(MSR_IA32_RTIT_OUTPUT_MASK_PTRS) == rtitOutMasksDesc.All);
	}

	// Set the TRACE options:
	TRACE_OPTIONS & options = lpProcPtData->TraceOptions;
	rtitCtlDesc.Fields.FabricEn = 0;
	rtitCtlDesc.Fields.Os = (desc.bTraceKernel ? 1 : 0);	// Trace Kernel address space	
	rtitCtlDesc.Fields.User = (desc.bTraceUser ? 1 : 0);	// Trace the user mode process
	rtitCtlDesc.Fields.BranchEn = options.Fields.bTraceBranchPcks;

	if (lpProcPtData->lpTargetProcCr3) {
		// Set the page table filter for the target process 
		__writemsr(MSR_IA32_RTIT_CR3_MATCH, (ULONGLONG)targetCr3);
		ASSERT(__readmsr(MSR_IA32_RTIT_CR3_MATCH) == (ULONGLONG)targetCr3);
		rtitCtlDesc.Fields.CR3Filter = 1;
	}
	else {
		// Set the register to 0
		__writemsr(MSR_IA32_RTIT_CR3_MATCH, 0);
		ASSERT(__readmsr(MSR_IA32_RTIT_CR3_MATCH) == 0);
		rtitCtlDesc.Fields.CR3Filter = 0;
	}

	// Set the IP range flags and registers to 0 
	rtitCtlDesc.Fields.Addr0Cfg = 0;
	rtitCtlDesc.Fields.Addr1Cfg = 0;
	rtitCtlDesc.Fields.Addr2Cfg = 0;
	rtitCtlDesc.Fields.Addr3Cfg = 0;

	// Now set them to the proper values (see Intel Manuals, chapter 36.2.5.2 - IA32_RTIT_CTL MSR)
	if (lpProcPtData->dwNumOfActiveRanges > 0) {
		if (lpProcPtData->IpRanges[0].bStopTrace) rtitCtlDesc.Fields.Addr0Cfg = 2;
		else rtitCtlDesc.Fields.Addr0Cfg = 1;
		__writemsr(MSR_IA32_RTIT_ADDR0_START, (QWORD)lpProcPtData->IpRanges[0].lpStartVa);
		ASSERT(__readmsr(MSR_IA32_RTIT_ADDR0_START) == (QWORD)lpProcPtData->IpRanges[0].lpStartVa);
		__writemsr(MSR_IA32_RTIT_ADDR0_END, (QWORD)lpProcPtData->IpRanges[0].lpEndVa);
		ASSERT(__readmsr(MSR_IA32_RTIT_ADDR0_END) == (QWORD)lpProcPtData->IpRanges[0].lpEndVa);
	}
	if (lpProcPtData->dwNumOfActiveRanges > 1) {
		if (lpProcPtData->IpRanges[1].bStopTrace) rtitCtlDesc.Fields.Addr1Cfg = 2;
		else rtitCtlDesc.Fields.Addr1Cfg = 1;
		__writemsr(MSR_IA32_RTIT_ADDR1_START, (QWORD)lpProcPtData->IpRanges[1].lpStartVa);
		__writemsr(MSR_IA32_RTIT_ADDR1_END, (QWORD)lpProcPtData->IpRanges[1].lpEndVa);
	}
	if (lpProcPtData->dwNumOfActiveRanges > 2) {
		if (lpProcPtData->IpRanges[2].bStopTrace) rtitCtlDesc.Fields.Addr2Cfg = 2;
		else rtitCtlDesc.Fields.Addr2Cfg = 1;
		__writemsr(MSR_IA32_RTIT_ADDR2_START, (QWORD)lpProcPtData->IpRanges[2].lpStartVa);
		__writemsr(MSR_IA32_RTIT_ADDR2_END, (QWORD)lpProcPtData->IpRanges[2].lpEndVa);
	}
	if (lpProcPtData->dwNumOfActiveRanges > 3) {
		if (lpProcPtData->IpRanges[3].bStopTrace) rtitCtlDesc.Fields.Addr3Cfg = 2;
		else rtitCtlDesc.Fields.Addr3Cfg = 1;
		__writemsr(MSR_IA32_RTIT_ADDR3_START, (QWORD)lpProcPtData->IpRanges[3].lpStartVa);
		__writemsr(MSR_IA32_RTIT_ADDR3_END, (QWORD)lpProcPtData->IpRanges[3].lpEndVa);
	}

	if (ptCap.bMtcSupport)
	{
		rtitCtlDesc.Fields.MTCEn = options.Fields.bTraceMtcPcks;
		if ((1 << options.Fields.MTCFreq) & ptCap.mtcPeriodBmp)
			rtitCtlDesc.Fields.MTCFreq = options.Fields.MTCFreq;
	}
	if (ptCap.bConfPsbAndCycSupported)
	{
		rtitCtlDesc.Fields.CycEn = options.Fields.bTraceCycPcks;
		if ((1 << options.Fields.CycThresh) & ptCap.cycThresholdBmp)
			rtitCtlDesc.Fields.CycThresh = options.Fields.CycThresh;
		if ((1 << options.Fields.PSBFreq) & ptCap.psbFreqBmp)
			rtitCtlDesc.Fields.PSBFreq = options.Fields.PSBFreq;
	}
	rtitCtlDesc.Fields.DisRETC = (options.Fields.bEnableRetCompression == 0);
	rtitCtlDesc.Fields.TSCEn = options.Fields.bTraceTscPcks;

	// Switch the tracing to ON dude :-)
	rtitCtlDesc.Fields.TraceEn = 1;
	__writemsr(MSR_IA32_RTIT_CTL, rtitCtlDesc.All);
	ASSERT(__readmsr(MSR_IA32_RTIT_CTL) == rtitCtlDesc.All);

	// Read the status register
	rtitStatusDesc.All = __readmsr(MSR_IA32_RTIT_STATUS);

	// Finally lower the IRQL
	if (kOldIrql < DISPATCH_LEVEL)
		KeLowerIrql(kOldIrql);

	if (rtitStatusDesc.Fields.TriggerEn) {
		DbgPrint("[" DRV_NAME "] Successfully enabled Intel PT tracing for processor %i. Log Virtual Address: 0x%llX. :-)\r\n",
			curProcId, pPtBuffDesc->bUseTopa ? pPtBuffDesc->u.ToPA.lpTopaVa : pPtBuffDesc->u.Simple.lpTraceBuffVa);
		lpProcPtData->curState = PT_PROCESSOR_STATE_TRACING;
		// Set the PT buffer as current
		lpProcPtData->pPtBuffDesc = pPtBuffDesc;
		return STATUS_SUCCESS;
	}
	else
	{
		DbgPrint("[" DRV_NAME "] Error: unable to successfully enable Intel PT tracing for processor %i.", curProcId);
		//__writemsr(MSR_IA32_RTIT_STATUS, 0);
		lpProcPtData->curState = PT_PROCESSOR_STATE_ERROR;
		lpProcPtData->lpTargetProc = NULL;
		lpProcPtData->lpTargetProcCr3 = NULL;
		lpProcPtData->dwNumOfActiveRanges = 0;
		RtlZeroMemory(lpProcPtData->IpRanges, sizeof(lpProcPtData->IpRanges));
		return STATUS_UNSUCCESSFUL;
	}
}

// Enable the Intel PT trace for current processor (allocate the needed buffer)
NTSTATUS StartCpuTrace(PT_TRACE_DESC desc, QWORD qwBuffSize)
{
	NTSTATUS ntStatus = STATUS_SUCCESS;
	BOOLEAN bBuffAllocated = FALSE;				// TRUE if buffer for current CPU has been allocated
	DWORD dwCurCpu = KeGetCurrentProcessorNumber();
	if (!g_pDrvData) return STATUS_INTERNAL_ERROR;
	ntStatus = CheckIntelPtSupport(NULL);
	if (!NT_SUCCESS(ntStatus)) return ntStatus;

	// Grab the memory descriptor
	PER_PROCESSOR_PT_DATA & cpuPtData = g_pDrvData->procData[dwCurCpu];

	// Check if the options have been initialized
	if (!cpuPtData.TraceOptions.Fields.bInitialized)
		SetDefaultTraceOptions(dwCurCpu);

	// Allocate the physical memory
	if (!cpuPtData.pPtBuffDesc || !cpuPtData.pPtBuffDesc->qwBuffSize || cpuPtData.pPtBuffDesc->qwBuffSize != qwBuffSize)
	{
		BOOLEAN bUseTopa = (cpuPtData.TraceOptions.Fields.bUseTopa == 1);
		ntStatus = AllocCpuPtBuffer(dwCurCpu, qwBuffSize, bUseTopa);
		if (!NT_SUCCESS(ntStatus)) {
			DbgPrint("[" DRV_NAME "] Error: unable to allocate the trace buffer.\r\n");
			cpuPtData.lpTargetProcCr3 = NULL;
			cpuPtData.lpTargetProc = NULL;
			return STATUS_INVALID_PARAMETER_2;
		}
		bBuffAllocated = TRUE;
	}

	ntStatus = StartCpuTrace(desc, cpuPtData.pPtBuffDesc);

	if (!NT_SUCCESS(ntStatus) && bBuffAllocated)
		FreeCpuResources(dwCurCpu);
	return ntStatus;
}

// Start the Tracing of a particular usermode process 
NTSTATUS StartProcessTrace(DWORD dwProcId, QWORD qwBuffSize) 
{
	NTSTATUS ntStatus = 0;
	PEPROCESS peProc = NULL;
	PT_TRACE_DESC ptDesc = { 0 };			// The kernel tracing data structure
	if (!g_pDrvData) return STATUS_INTERNAL_ERROR;

	// PsLookupProcessByProcessId should be executed at IRQL < DISPATCH_LEVEL
	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);				
	ntStatus = PsLookupProcessByProcessId((HANDLE)dwProcId, &peProc);

	if (!NT_SUCCESS(ntStatus)) 
		return ntStatus;
	else {
		// Compose the right data structure and pass the control to the main function
		ptDesc.bTraceKernel = FALSE;
		ptDesc.bTraceUser = TRUE;
		ptDesc.dwNumOfRanges = 0;
		ptDesc.peProc = peProc;
		return StartCpuTrace(ptDesc, qwBuffSize);
	}
}

// Put the tracing in PAUSE mode
NTSTATUS PauseResumeTrace(BOOLEAN bPause) 
{
	MSR_RTIT_CTL_DESC rtitCtlDesc = { 0 };					// The RTIT MSR descriptor
	MSR_RTIT_STATUS_DESC rtitStatusDesc = { 0 };			// The Status MSR descriptor
	MSR_RTIT_OUTPUTBASE_DESC rtitOutBaseDesc = { 0 };		// IA32_RTIT_OUTPUT_BASE Model specific Register
	MSR_RTIT_OUTPUT_MASK_PTRS_DESC rtitOutMasksDesc = { 0 };// IA32_RTIT_OUTPUT_MASK_PTRS Model specific Register
	DWORD dwCurCpu = 0;										// Current running CPU
	NTSTATUS ntStatus = STATUS_NOT_SUPPORTED;			 	// Returned NTSTATUS value
	if (!g_pDrvData) return STATUS_INTERNAL_ERROR;

	ntStatus = CheckIntelPtSupport(NULL);
	if (!NT_SUCCESS(ntStatus)) return ntStatus;

	dwCurCpu = KeGetCurrentProcessorNumber();
	PER_PROCESSOR_PT_DATA & curCpuData = g_pDrvData->procData[dwCurCpu];
	if (curCpuData.curState != PT_PROCESSOR_STATE_TRACING && bPause) return STATUS_SUCCESS;
	if (curCpuData.curState != PT_PROCESSOR_STATE_PAUSED && bPause == FALSE) return STATUS_INVALID_DEVICE_REQUEST;

	// Read the current state
	rtitCtlDesc.All = __readmsr(MSR_IA32_RTIT_CTL);
	rtitStatusDesc.All = __readmsr(MSR_IA32_RTIT_STATUS);

	// XXX: This seems unnecessary 
	// Update the STATUS register 
	if (rtitCtlDesc.Fields.TraceEn == 0) {
		rtitStatusDesc.Fields.Stopped = 0;
		rtitStatusDesc.Fields.Error = 0;
		__writemsr(MSR_IA32_RTIT_STATUS, rtitStatusDesc.All);
	}

	if (bPause)	{
		// Pause Intel PT tracing 
		rtitCtlDesc.Fields.TraceEn = 0;
	}
	else 
	{
		PT_BUFFER_DESCRIPTOR * ptBuffDesc =	curCpuData.pPtBuffDesc;
		// If we paused to dump buffer lets reset it 
		if (ptBuffDesc && ptBuffDesc->bUseTopa && ptBuffDesc->bBuffIsFull) {
			// Restore the Topa Buffer, Set the proc_trace_table_base
			rtitOutBaseDesc.All = (ULONGLONG)ptBuffDesc->u.ToPA.lpTopaPhysAddr;
			__writemsr(MSR_IA32_RTIT_OUTPUT_BASE, rtitOutBaseDesc.All);

			// Set the proc_trace_table_offset: indicates the entry of the table that is currently in use
			rtitOutMasksDesc.Fields.LowerMask = 0x7F;
			rtitOutMasksDesc.Fields.MaskOrTableOffset = 0;	// Start from the first entry in the table
			rtitOutMasksDesc.Fields.OutputOffset = 0;		// Start at offset 0
			__writemsr(MSR_IA32_RTIT_OUTPUT_MASK_PTRS, rtitOutMasksDesc.All);
			ptBuffDesc->bBuffIsFull = FALSE;
		}

		// Resume Intel PT tracing
		rtitCtlDesc.Fields.TraceEn = 1;
	}

	// Update the Control register
	__writemsr(MSR_IA32_RTIT_CTL, rtitCtlDesc.All);

	/* XXX: should not be needed 
	if (kIrql <= DISPATCH_LEVEL) {
		// STALL the execution for a little time
		KeStallExecutionProcessor(42);
	} // else ... Interrupt routine should be VERY FAST
	*/

	// Read the final status
	rtitStatusDesc.All = __readmsr(MSR_IA32_RTIT_STATUS);
	
	if (rtitStatusDesc.Fields.Error) {
		curCpuData.curState = PT_PROCESSOR_STATE_ERROR;
		return STATUS_UNSUCCESSFUL;
	}

	if (bPause) {
		// Copy and reset the current number of packets
		curCpuData.PacketByteCount += (QWORD)rtitStatusDesc.Fields.PacketByteCnt;
		rtitStatusDesc.Fields.PacketByteCnt = 0;
		__writemsr(MSR_IA32_RTIT_STATUS, rtitStatusDesc.All);
		curCpuData.curState = PT_PROCESSOR_STATE_PAUSED;
	}
	else
		curCpuData.curState = PT_PROCESSOR_STATE_TRACING;

	return STATUS_SUCCESS;
}

// Disable Intel PT for the current processor
NTSTATUS StopAndDisablePt() 
{
	NTSTATUS ntStatus = STATUS_NOT_SUPPORTED;				// Returned NTSTATUS value
	INTEL_PT_CAPABILITIES ptCap = { 0 };					// Intel Processor Tracing capabilities
	PER_PROCESSOR_PT_DATA * lpProcPtData = NULL;			// The per processor data structure
	MSR_RTIT_CTL_DESC rtitCtlDesc = { 0 };
	MSR_RTIT_STATUS_DESC rtitStatusDesc = { 0 };			// The Status MSR descriptor
	ULONG dwCurProc = 0;
	if (!g_pDrvData) return STATUS_INTERNAL_ERROR;

	ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

	dwCurProc = KeGetCurrentProcessorNumber();
	lpProcPtData = &g_pDrvData->procData[dwCurProc];

	ntStatus = CheckIntelPtSupport(&ptCap);
	if (!NT_SUCCESS(ntStatus)) return ntStatus;

	#if ENABLE_EXPERIMENTAL_XSAVE
	ntStatus = SavePtData((PXSAVE_AREA_EX)lpProcPtData->lpXSaveArea, lpProcPtData->dwXSaveAreaSize);
	#endif

	// Stop and disable the Intel PT
	rtitCtlDesc.All = __readmsr(MSR_IA32_RTIT_CTL);
	rtitCtlDesc.Fields.TraceEn = 0;
	__writemsr(MSR_IA32_RTIT_CTL, rtitCtlDesc.All);

	// Copy the final number of Acquired packets
	rtitStatusDesc.All = __readmsr(MSR_IA32_RTIT_STATUS);
	lpProcPtData->PacketByteCount += (QWORD)rtitStatusDesc.Fields.PacketByteCnt;

	// Reset all the configuration registers
	__writemsr(MSR_IA32_RTIT_OUTPUT_BASE, 0);
	__writemsr(MSR_IA32_RTIT_OUTPUT_MASK_PTRS, 0);
	if (ptCap.numOfAddrRanges > 0) {
		__writemsr(MSR_IA32_RTIT_ADDR0_START, 0);
		__writemsr(MSR_IA32_RTIT_ADDR0_END, 0);
	}
	if (ptCap.numOfAddrRanges > 1) {
		__writemsr(MSR_IA32_RTIT_ADDR1_START, 0);
		__writemsr(MSR_IA32_RTIT_ADDR1_END, 0);
	}
	if (ptCap.numOfAddrRanges > 2) {
		__writemsr(MSR_IA32_RTIT_ADDR2_START, 0);
		__writemsr(MSR_IA32_RTIT_ADDR2_END, 0);
	}
	if (ptCap.numOfAddrRanges > 3) {
		__writemsr(MSR_IA32_RTIT_ADDR3_START, 0);
		__writemsr(MSR_IA32_RTIT_ADDR3_END, 0);
	}
	if (ptCap.bCr3Filtering)
		__writemsr(MSR_IA32_RTIT_CR3_MATCH, 0);

	// Set the new processor State
	lpProcPtData->curState = PT_PROCESSOR_STATE_STOPPED;

	lpProcPtData->lpTargetProcCr3 = NULL;
	lpProcPtData->lpTargetProc = NULL;
	lpProcPtData->dwNumOfActiveRanges = 0;
	RtlZeroMemory(lpProcPtData->IpRanges, sizeof(lpProcPtData->IpRanges));

	return STATUS_SUCCESS;
}

// Get the active Trace options for a particular CPU
NTSTATUS GetTraceOptions(DWORD dwCpuId, TRACE_OPTIONS * pOptions) 
{
	DWORD dwNumCpus = KeQueryActiveProcessorCount(NULL);
	if (!g_pDrvData) return STATUS_INTERNAL_ERROR;
	if (dwCpuId >= dwNumCpus) 
		return STATUS_INVALID_PARAMETER;

	// Initialize the default trace options if not any is set
	if (g_pDrvData->procData[dwCpuId].TraceOptions.Fields.bInitialized == FALSE)
		SetDefaultTraceOptions(dwCpuId);

	if (pOptions)
		*pOptions = g_pDrvData->procData[dwCpuId].TraceOptions;

	return STATUS_SUCCESS;
}

// Set the trace options for a particular CPU
NTSTATUS SetTraceOptions(DWORD dwCpuId, TRACE_OPTIONS opts) 
{
	KAFFINITY curCpuAffinity = 0;
	DWORD dwNumCpus = 0;
	INTEL_PT_CAPABILITIES ptCap = { 0 };
	NTSTATUS ntStatus = 0;

	dwNumCpus = KeQueryActiveProcessorCount(&curCpuAffinity);
	if (!g_pDrvData) return STATUS_INTERNAL_ERROR;
	if (dwCpuId >= dwNumCpus) return STATUS_INVALID_PARAMETER;
	PER_PROCESSOR_PT_DATA & cpuData = g_pDrvData->procData[dwCpuId];
	ntStatus = CheckIntelPtSupport(&ptCap);
	if (!NT_SUCCESS(ntStatus)) return ntStatus;

	// Check the options now
	if (opts.Fields.bTraceMtcPcks && (ptCap.bMtcSupport == 0)) return STATUS_NOT_SUPPORTED;
	if (opts.Fields.bTraceCycPcks && (ptCap.bConfPsbAndCycSupported == 0)) return STATUS_NOT_SUPPORTED;
	if (opts.Fields.bUseTopa && !(ptCap.bTopaOutput && ptCap.bTopaMultipleEntries)) return STATUS_NOT_SUPPORTED;

	// Check now the frequency bitmaps:
	if (opts.Fields.MTCFreq && ((1 << opts.Fields.MTCFreq) & (ptCap.mtcPeriodBmp == 0))) return STATUS_NOT_SUPPORTED;
	if (opts.Fields.PSBFreq && (ptCap.bConfPsbAndCycSupported == 0)) return STATUS_NOT_SUPPORTED;
	if (opts.Fields.PSBFreq && ((1 << opts.Fields.PSBFreq) & (ptCap.psbFreqBmp == 0))) return STATUS_NOT_SUPPORTED;
	if (opts.Fields.CycThresh && (ptCap.bConfPsbAndCycSupported == 0)) return STATUS_NOT_SUPPORTED;
	if (opts.Fields.CycThresh && ((1 << opts.Fields.CycThresh) & (ptCap.cycThresholdBmp == 0))) return STATUS_NOT_SUPPORTED;

	// Copy the options
	opts.Fields.bInitialized = 1;
	cpuData.TraceOptions = opts;
	return STATUS_SUCCESS;
}

// Set the default trace options for a particular CPU
NTSTATUS SetDefaultTraceOptions(DWORD dwCpuId) {
	KAFFINITY curCpuAffinity = 0;
	DWORD dwNumCpus = 0;
	INTEL_PT_CAPABILITIES ptCap = { 0 };
	NTSTATUS ntStatus = 0;

	dwNumCpus = KeQueryActiveProcessorCount(&curCpuAffinity);
	if (!g_pDrvData) return STATUS_INTERNAL_ERROR;
	if (dwCpuId >= dwNumCpus) return STATUS_INVALID_PARAMETER;
	PER_PROCESSOR_PT_DATA * lpProcPtData = &g_pDrvData->procData[dwCpuId];

	ntStatus = CheckIntelPtSupport(&ptCap);
	if (!NT_SUCCESS(ntStatus)) return ntStatus;

	// Set the default trace options if needed
	if (lpProcPtData->TraceOptions.All == 0) {
		lpProcPtData->TraceOptions.Fields.bTraceBranchPcks = TRUE;
		if (ptCap.bTopaOutput)
			lpProcPtData->TraceOptions.Fields.bUseTopa = TRUE;
		lpProcPtData->TraceOptions.Fields.bEnableRetCompression = TRUE;
	}
	lpProcPtData->TraceOptions.Fields.bInitialized = 1;
	return STATUS_SUCCESS;
}
#pragma endregion

#pragma region Trace Buffer memory management Code
/* BRIEF EXPLANATION HERE
 * What is the difference between AllocCpuPtBuffer/FreeCpuResources and AllocPtBuffer/FreePtBuffer???
 * The 2 functions perform more or less the same work BUT in different ways:
 * AllocCpuPtBuffer/FreeCpuResources verify if the ONLY buffer associated with the CPU is legal and mapped 
 * to some User-mode address space. THERE IS ONLY ONE BUFFER PER CPU for the driver
 *
 * AllocPtBuffer/FreePtBuffer doesn't suffer for this limitations and are used even from external kernel modules.
 * It's duty of the External module to decide what to do with the buffer descriptor.
 */

// Allocate a Trace buffer for a specific CPU
NTSTATUS AllocCpuPtBuffer(DWORD dwCpuId, QWORD qwSize, BOOLEAN bUseToPA)
{
	NTSTATUS ntStatus = STATUS_SUCCESS;						// Returned NTSTATUS value
	INTEL_PT_CAPABILITIES ptCap = { 0 };					// Current processor capabilities
	PT_BUFFER_DESCRIPTOR * pPtNewBuffDesc = NULL;			// The NEW Buffer descriptor
	if (dwCpuId > KeQueryActiveProcessorCount(NULL)) return STATUS_INVALID_PARAMETER_3;

	PER_PROCESSOR_PT_DATA & perCpuData = g_pDrvData->procData[dwCpuId];
	ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

	// Get this processor capabilities
	ntStatus = CheckIntelPtSupport(&ptCap);
	if (!NT_SUCCESS(ntStatus)) return ntStatus;

	if (bUseToPA && !(ptCap.bTopaOutput && ptCap.bTopaMultipleEntries))
		return STATUS_NOT_SUPPORTED;
	if (!bUseToPA && !ptCap.bSingleRangeSupport)
		return STATUS_NOT_SUPPORTED;
	if (perCpuData.curState >= PT_PROCESSOR_STATE_TRACING) return STATUS_INVALID_DEVICE_REQUEST;

	if (bUseToPA) {
		if (perCpuData.pPtBuffDesc && perCpuData.pPtBuffDesc->u.ToPA.lpTopaPhysAddr)
			ntStatus = FreeCpuResources(dwCpuId);
		if (!NT_SUCCESS(ntStatus)) return ntStatus;
		// Table of Physical Address usage
		ntStatus = AllocAndSetTopa(&pPtNewBuffDesc, qwSize);
		if (NT_SUCCESS(ntStatus))
			// Enable the default PMI handler
			pPtNewBuffDesc->bDefaultPmiSet = TRUE;
	} else 	{
		if (perCpuData.pPtBuffDesc && perCpuData.pPtBuffDesc->u.Simple.lpTraceBuffVa)
			ntStatus = FreeCpuResources(dwCpuId);
		if (!NT_SUCCESS(ntStatus)) return ntStatus;
		ntStatus = AllocPtBuffer(&pPtNewBuffDesc, qwSize, FALSE);
	}

	if (NT_SUCCESS(ntStatus))
		// Set the current descriptor as default one for current CPU
		perCpuData.pPtBuffDesc = pPtNewBuffDesc;
	else
		ExFreePool(pPtNewBuffDesc);

	return ntStatus;
}

// Free the resources used by a CPU
NTSTATUS FreeCpuResources(DWORD dwCpuId) {
	NTSTATUS ntStatus = STATUS_SUCCESS;
	DWORD dwCurProcId = 0, dwTargetPid = 0;					// Current and target Process ID
	BOOLEAN bExited = FALSE;								// True if the target process has already exited
	KIRQL kIrql = KeGetCurrentIrql();
	KAFFINITY curCpuAffinity = 0;
	DWORD dwNumCpus = 0;

	dwNumCpus = KeQueryActiveProcessorCount(&curCpuAffinity);
	if (dwCpuId >= dwNumCpus) return STATUS_INVALID_PARAMETER;
	PER_PROCESSOR_PT_DATA & perCpuData = g_pDrvData->procData[dwCpuId];
	if (perCpuData.curState >= PT_PROCESSOR_STATE_TRACING) return STATUS_INVALID_DEVICE_REQUEST;

	// Very important: Check the user-mode process here:
	if (perCpuData.lpUserVa) {
		dwCurProcId = (DWORD)PsGetCurrentProcessId();
		if (perCpuData.lpMappedProc)
			dwTargetPid = (DWORD)PsGetProcessId(perCpuData.lpMappedProc);

		bExited = PsGetProcessExitProcessCalled(perCpuData.lpMappedProc);

		if ((!dwTargetPid || (dwTargetPid == dwCurProcId) || bExited)  && kIrql <= APC_LEVEL) {
			// We can safely unmap the PT buffer here
			ntStatus = UnmapTraceBuffToUserVa(dwCpuId);
			if (!NT_SUCCESS(ntStatus)) {
				DbgPrint("[" DRV_NAME "] Error: Unable to unmap the trace buffer for process %i.\r\n", dwTargetPid);
				return ntStatus;
			}
		}
		else {
			DbgPrint("[" DRV_NAME "] Warning: Unable to free the the allocated physical memory for processor %i. The process with PID %i has still not unmapped the buffer. "
				"Base VA: 0x%llX, physical address: 0x%llX.\r\n", dwCpuId, dwTargetPid, perCpuData.lpUserVa, perCpuData.pPtBuffDesc ? perCpuData.pPtBuffDesc->u.Simple.lpTraceBuffPhysAddr : 0);
			return STATUS_CONTEXT_MISMATCH;
		}
		if (bExited) g_pDrvData->bManualAllocBuff = FALSE;
	}

	// Now finally release the buffer
	PT_BUFFER_DESCRIPTOR * ptBuffDesc = perCpuData.pPtBuffDesc;
	if (ptBuffDesc) {
		perCpuData.pPtBuffDesc = NULL;
		ntStatus = FreePtBuffer(ptBuffDesc);
	}
	return ntStatus;
}

// Allocate and set a buffer for Intel Processor Trace
NTSTATUS AllocPtBuffer(PT_BUFFER_DESCRIPTOR ** lppBuffDesc, QWORD qwSize, BOOLEAN bUseTopa) {
	PHYSICAL_ADDRESS MaxAddr; MaxAddr.QuadPart = -1ll;		// Maximum physical address
	PT_BUFFER_DESCRIPTOR * pBuffDesc = NULL;

	if (bUseTopa)
		return AllocAndSetTopa(lppBuffDesc, qwSize, TRUE);

	// Simple output range implementation
	LPVOID lpBuffVa = MmAllocateContiguousMemory(qwSize, MaxAddr);
	if (!lpBuffVa) return STATUS_INSUFFICIENT_RESOURCES;
	RtlZeroMemory(lpBuffVa, qwSize);

	// Grab the physical address:
	PHYSICAL_ADDRESS physAddr = MmGetPhysicalAddress(lpBuffVa);

	// Allocate the relative MDL
	PMDL pPtMdl = IoAllocateMdl(lpBuffVa, (ULONG)qwSize, FALSE, FALSE, NULL);
	if (pPtMdl && lppBuffDesc) {
		pBuffDesc = (PT_BUFFER_DESCRIPTOR*)ExAllocatePoolWithTag(NonPagedPool, sizeof(PT_BUFFER_DESCRIPTOR), MEMTAG);
		RtlZeroMemory(pBuffDesc, sizeof(PT_BUFFER_DESCRIPTOR));
		pBuffDesc->pTraceMdl = pPtMdl;
		pBuffDesc->u.Simple.lpTraceBuffVa = lpBuffVa;
		pBuffDesc->qwBuffSize = qwSize;
		pBuffDesc->u.Simple.lpTraceBuffPhysAddr = (ULONG_PTR)physAddr.QuadPart;
		*lppBuffDesc = pBuffDesc;
	}
	return STATUS_SUCCESS;
}

// Free a PT trace buffer (use with caution, avoid BSOD please)
NTSTATUS FreePtBuffer(PT_BUFFER_DESCRIPTOR * ptBuffDesc) {
	//ULONG dwCurCpu = 0;										// Current CPU number
	KIRQL kIrql = KeGetCurrentIrql();
	ASSERT(kIrql <= DISPATCH_LEVEL);

	if (!ptBuffDesc) return STATUS_INVALID_PARAMETER;
	if (ptBuffDesc->qwBuffSize < PAGE_SIZE) return STATUS_INVALID_BUFFER_SIZE;

	if (ptBuffDesc->bUseTopa) {
		// Free the ToPA table
		if (ptBuffDesc->u.ToPA.lpTopaVa) {
			MmFreeContiguousMemory(ptBuffDesc->u.ToPA.lpTopaVa);
			ptBuffDesc->u.ToPA.lpTopaVa = NULL;
			ptBuffDesc->u.ToPA.lpTopaPhysAddr = NULL;
		}

		// Free the actual physical memory
		if (ptBuffDesc->pTraceMdl) {
			// Free the used pages 
			MmFreePagesFromMdl(ptBuffDesc->pTraceMdl);
			ExFreePool(ptBuffDesc->pTraceMdl);
			ptBuffDesc->pTraceMdl = NULL;
		}
	}
	else {
		// Free the simple output region
		if (ptBuffDesc->u.Simple.lpTraceBuffVa)
			MmFreeContiguousMemory(ptBuffDesc->u.Simple.lpTraceBuffVa);

		if (ptBuffDesc->pTraceMdl) {
			IoFreeMdl(ptBuffDesc->pTraceMdl);
			ptBuffDesc->pTraceMdl = NULL;
		}

		ptBuffDesc->u.Simple.lpTraceBuffVa = NULL;
		ptBuffDesc->u.Simple.lpTraceBuffPhysAddr = NULL;
	}

	// Free the data structure itself
	ExFreePool(ptBuffDesc);
	return STATUS_SUCCESS;
}

// Allocate and set a ToPA (with the Windows API)
NTSTATUS AllocAndSetTopa(PT_BUFFER_DESCRIPTOR ** lppBuffDesc, QWORD qwReqBuffSize, BOOLEAN bSetPmiAndStop)
{
	NTSTATUS ntStatus = STATUS_SUCCESS;						// Returned NTSTATUS
	DWORD dwNumEntriesInMdl = 0;							// Number of entries in the MDL
	DWORD dwTopaSize = 0;									// Size of the ToPa
	TOPA_TABLE_ENTRY * pTopa = NULL;						// Pointer to the ToPa
	PHYSICAL_ADDRESS highPhysAddr = { (ULONG)-1, -1 };		// Highest physical memory address
	PHYSICAL_ADDRESS lowPhysAddr = { 0i64 };				// Lowest physical memory address
	PHYSICAL_ADDRESS topaPhysAddr = { 0i64 };				// The ToPA physical address
	PMDL pTraceBuffMdl = NULL;
	PT_BUFFER_DESCRIPTOR * pBuffDesc = NULL;

	ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

	if (qwReqBuffSize % PAGE_SIZE) return STATUS_INVALID_PARAMETER_2;

	// Allocate the needed physical memory
	pTraceBuffMdl = MmAllocatePagesForMdlEx(lowPhysAddr, highPhysAddr, lowPhysAddr, (SIZE_T)qwReqBuffSize + PAGE_SIZE, MmCached, MM_ALLOCATE_FULLY_REQUIRED);
	if (!pTraceBuffMdl) return STATUS_INSUFFICIENT_RESOURCES;

	// Get the PFN array
	dwNumEntriesInMdl = ADDRESS_AND_SIZE_TO_SPAN_PAGES(MmGetMdlVirtualAddress(pTraceBuffMdl), MmGetMdlByteCount(pTraceBuffMdl));
	PPFN_NUMBER pfnArray = MmGetMdlPfnArray(pTraceBuffMdl);

	// Allocate the ToPA
	dwTopaSize = (dwNumEntriesInMdl + 1) * 8;
	dwTopaSize = ROUND_TO_PAGES(dwTopaSize);
	pTopa = (TOPA_TABLE_ENTRY *)MmAllocateContiguousMemory(dwTopaSize, highPhysAddr);
	topaPhysAddr = MmGetPhysicalAddress(pTopa);
	if (!pTopa) {
		MmFreePagesFromMdl(pTraceBuffMdl);
		ExFreePool(pTraceBuffMdl);
		return STATUS_INSUFFICIENT_RESOURCES;
	}
	RtlZeroMemory(pTopa, dwTopaSize);

	// Create the ToPA 
	for (DWORD i = 0; i < dwNumEntriesInMdl; i++)  {
		pTopa[i].Fields.BaseAddr = pfnArray[i];				// Pfn array contains the PFN offset, not the actual Physical address
		pTopa[i].Fields.Size = 0;		// Encoding: 0 - 4K pages
	} 

	// LVT interrupt entry (if any)
	if (bSetPmiAndStop) {
		pTopa[dwNumEntriesInMdl - 1].Fields.Int = 1;
		pTopa[dwNumEntriesInMdl - 1].Fields.Stop = 1;
	}

	// END entries 
	RtlZeroMemory(&pTopa[dwNumEntriesInMdl], sizeof(TOPA_TABLE_ENTRY));
	pTopa[dwNumEntriesInMdl].Fields.BaseAddr = (ULONG_PTR)(topaPhysAddr.QuadPart >> 0xC);
	pTopa[dwNumEntriesInMdl].Fields.End = 1;

	// Now create the descriptor and set the ToPA data
	if (lppBuffDesc) {
		pBuffDesc = (PT_BUFFER_DESCRIPTOR*)ExAllocatePoolWithTag(NonPagedPool, sizeof(PT_BUFFER_DESCRIPTOR), MEMTAG);
		RtlZeroMemory(pBuffDesc, sizeof(PT_BUFFER_DESCRIPTOR));
		pBuffDesc->bUseTopa = TRUE;
		pBuffDesc->u.ToPA.lpTopaPhysAddr = (ULONG_PTR)topaPhysAddr.QuadPart;
		pBuffDesc->u.ToPA.lpTopaVa = pTopa;
		pBuffDesc->qwBuffSize = qwReqBuffSize;
		pBuffDesc->pTraceMdl = pTraceBuffMdl;
		pBuffDesc->bDefaultPmiSet = bSetPmiAndStop;
		*lppBuffDesc = pBuffDesc;
	}
	return ntStatus;
}

// Get if the PT buffer is allocated and valid for a particular processor
QWORD IsPtBufferAllocatedAndValid(DWORD dwCpuId, BOOLEAN bTestUserVa) {
	PER_PROCESSOR_PT_DATA * pPerCpuData = NULL;
	if (dwCpuId > KeQueryActiveProcessorCount(NULL)) return FALSE;
	
	pPerCpuData = &g_pDrvData->procData[dwCpuId];
	if (bTestUserVa)
		if (!pPerCpuData->lpUserVa) return 0;

	if (!(pPerCpuData->pPtBuffDesc && pPerCpuData->pPtBuffDesc->u.Simple.lpTraceBuffPhysAddr))
		return 0;

	// Return the size of the buffer
	return pPerCpuData->pPtBuffDesc->qwBuffSize;
}

// Clear the PT buffer
NTSTATUS ClearCpuPtBuffer(DWORD dwCpuId) {
	PER_PROCESSOR_PT_DATA * pPerCpuData = NULL;
	LPVOID lpKernelVa = NULL;							// The kernel VA
	if (dwCpuId > KeQueryActiveProcessorCount(NULL)) return FALSE;
	pPerCpuData = &g_pDrvData->procData[dwCpuId];

	if (!pPerCpuData->pPtBuffDesc || !pPerCpuData->pPtBuffDesc->u.Simple.lpTraceBuffPhysAddr)
		return STATUS_NOT_FOUND;

	if (!pPerCpuData->pPtBuffDesc->pTraceMdl)
		return STATUS_INTERNAL_ERROR;

	if (!pPerCpuData->pPtBuffDesc->lpKernelVa) {
		// We do not want to map the MDL in Kernel Address space, try to use the User-mode VA
		if (pPerCpuData->lpUserVa && PsGetCurrentProcess() == pPerCpuData->lpMappedProc) {
			RtlZeroMemory(pPerCpuData->lpUserVa, (DWORD)pPerCpuData->pPtBuffDesc->qwBuffSize);
			return STATUS_SUCCESS;
		} else {
			DrvDbgPrint("[" DRV_NAME "] Warning, the ClearCpuPtBuffer routine is re-mapping the PT buffer (size 0x%08X) for CPU %i in Kernel mode. "
				"This could be very time consuming. Are you sure that is needed?\r\n", (DWORD)pPerCpuData->pPtBuffDesc->qwBuffSize, dwCpuId);
			lpKernelVa = MmGetSystemAddressForMdlSafe(pPerCpuData->pPtBuffDesc->pTraceMdl, NormalPagePriority);
			if (!lpKernelVa) return STATUS_INTERNAL_ERROR;
			RtlZeroMemory(lpKernelVa, (DWORD)pPerCpuData->pPtBuffDesc->qwBuffSize);
			MmUnmapLockedPages(lpKernelVa, pPerCpuData->pPtBuffDesc->pTraceMdl);
		}
	}
	return STATUS_SUCCESS;

}

#pragma code_seg()

// Map a physical page buffer to a User-mode process
// Only one PT buffer per CPU supported in Usermode
NTSTATUS MapTracePhysBuffToUserVa(DWORD dwCpuId) 
{
	PMDL pMdl = NULL;									// The new MDL describing the physical memory
	LPVOID lpUserBuff = NULL;							// The user-mode accessible buffer
	PEPROCESS pCurProc = NULL;							// The current EPROCESS target
	if (!g_pDrvData->procData[dwCpuId].pPtBuffDesc) return STATUS_NO_MEMORY;
	PT_BUFFER_DESCRIPTOR * pPtBuffDesc = g_pDrvData->procData[dwCpuId].pPtBuffDesc;

	// This should be executed at IRQL level <= APC for MmMapLockedPagesSpecifyCache
	ASSERT(KeGetCurrentIrql() <= APC_LEVEL);

	if (!pPtBuffDesc->u.Simple.lpTraceBuffVa || !pPtBuffDesc->qwBuffSize)
		return STATUS_INVALID_PARAMETER;

	if (pPtBuffDesc->bUseTopa)
	{
		// Table of Physical Address Implementation
		pMdl = pPtBuffDesc->pTraceMdl;
		if (!pMdl) return STATUS_INTERNAL_ERROR;
	}
	else 
	{
		// Simple-output scheme implementation
		if (!pPtBuffDesc->u.Simple.lpTraceBuffPhysAddr)
		{
			PHYSICAL_ADDRESS physAddr = MmGetPhysicalAddress(pPtBuffDesc->u.Simple.lpTraceBuffVa);
			pPtBuffDesc->u.Simple.lpTraceBuffPhysAddr = (ULONG_PTR)physAddr.QuadPart;
		}

		if (pPtBuffDesc->pTraceMdl)
			pMdl = pPtBuffDesc->pTraceMdl;
		else
			pMdl = IoAllocateMdl(pPtBuffDesc->u.Simple.lpTraceBuffVa, (ULONG)pPtBuffDesc->qwBuffSize, FALSE, FALSE, NULL);

		// Update this MDL to describe the underlying already-locked physical pages
		MmBuildMdlForNonPagedPool(pMdl);	// do this only here and nowhere else

		pPtBuffDesc->pTraceMdl = pMdl;
		if (!pMdl) return STATUS_INSUFFICIENT_RESOURCES;
	}

	pCurProc = PsGetCurrentProcess();

	// Now map the MDL to the current user-mode process 
	// If AccessMode is Usermode, the caller must be running at IRQL <= APC_LEVEL
	lpUserBuff = MmMapLockedPagesSpecifyCache(pMdl, UserMode, MmCached, NULL, FALSE, NormalPagePriority);				

	if (lpUserBuff) 
	{
		g_pDrvData->procData[dwCpuId].lpUserVa = lpUserBuff;
		g_pDrvData->procData[dwCpuId].lpMappedProc = pCurProc;
		ObReferenceObject(pCurProc);			// prevent process termination without freeing the resource
		return STATUS_SUCCESS;
	}
	else
		return STATUS_UNSUCCESSFUL;
}

// Unmap the memory-mapped physical memory from usermode
// Only one PT buffer per CPU supported in USER-mode
NTSTATUS UnmapTraceBuffToUserVa(DWORD dwCpuId) 
{
	PEPROCESS pCurProc = NULL;						// The current EPROCESS target
	PER_PROCESSOR_PT_DATA * pPerCpuData = &g_pDrvData->procData[dwCpuId];
	pCurProc = PsGetCurrentProcess();

	if (pPerCpuData->lpUserVa) 
	{
		BOOLEAN bExited = FALSE;
		PEPROCESS pMappedProc = pPerCpuData->lpMappedProc;

		if (!pPerCpuData->pPtBuffDesc || !pPerCpuData->pPtBuffDesc->pTraceMdl)
			return STATUS_INTERNAL_ERROR;	// THIS SHOULD NEVER HAPPEN

		// Get if the mapped process is already terminated
		if (pMappedProc) 
			bExited = PsGetProcessExitProcessCalled(pMappedProc);

		if (pMappedProc && (bExited == FALSE) && (pCurProc != pMappedProc))
			return STATUS_CONTEXT_MISMATCH;

		if (!bExited)
			MmUnmapLockedPages(pPerCpuData->lpUserVa, pPerCpuData->pPtBuffDesc->pTraceMdl);
			
		pPerCpuData->lpUserVa = NULL;
		pPerCpuData->lpMappedProc = NULL;
		ObDereferenceObject(pMappedProc);
	}
	return STATUS_SUCCESS;
}
#pragma endregion

#pragma region PMI Interrupt management code
#pragma code_seg(".nonpaged")
// Register the LVT (Local Vector Table) PMI interrupt
NTSTATUS RegisterPmiInterrupt() 
{
	NTSTATUS ntStatus = STATUS_SUCCESS;						// Returned NTSTATUS
	PMIHANDLER pNewPmiHandler = NULL;						// The new PMI handler routine
	INT CpuIdData[4] = { 0 };								// The CPUID data
	//PMIHANDLER pOldPmiHandler = NULL; 					// The old PMI handler (currently not implemented)
	BOOLEAN bX2ApicCompat = FALSE;

	BYTE lpBuff[0x20] = { 0 };
	//XXX ULONG dwBytesIo = 0;								// Number of I/O bytes

	// First of all we need to check if this system supports APIC or x2Apic
	__cpuidex(CpuIdData, 1, 0);
	bX2ApicCompat = (CpuIdData[2] & (1 < 21)) == 1;

	MSR_IA32_APIC_BASE_DESC ApicBase = { 0 };				// In Multi-processors systems this address could change
	ApicBase.All = __readmsr(MSR_IA32_APIC_BASE);			// In Windows systems all the processors LVT are mapped at the same physical address

	if (!ApicBase.Fields.EXTD) 	{
		LPDWORD lpdwApicBase = NULL;
		PHYSICAL_ADDRESS apicPhys = { 0 };

		// Map the APIC I/O space (each DWORD is a LVT_Entry structure)
		apicPhys.QuadPart = ApicBase.All & (~0xFFFi64);
		lpdwApicBase = (LPDWORD)MmMapIoSpace(apicPhys, 0x1000, MmNonCached);

		if (lpdwApicBase) 
		{ 
			DrvDbgPrint("[" DRV_NAME "] Successfully mapped the local APIC to 0x%llX.\r\n", lpdwApicBase);
			g_pDrvData->lpApicBase = lpdwApicBase;
		} else
			return STATUS_NOT_SUPPORTED;

		// Now read the entry 0x340 (not really needed)
		g_pDrvData->pmiVectDesc.All = lpdwApicBase[0x340 / 4];
	}
	else {
		// Current system uses x2APIC mode, no need to map anything
		g_pDrvData->bCpuX2ApicMode = TRUE;
		// From Intel Manual: In x2APIC mode, system software uses RDMSR and WRMSR to access the APIC registers.
	}

	// The following functions must be stored in HalDispatchTable 
	// TODO: Find a way to proper get the old PMI interrupt handler routine. Search inside the HAL code?
	// ntStatus = HalQuerySystemInformation(HalProfileSourceInformation, COUNTOF(lpBuff), (LPVOID)lpBuff, &dwBytesIo);		

	// Now set the new PMI handler, WARNING: we do not save and restore old handler
	pNewPmiHandler = IntelPtPmiHandler;
	ntStatus = HalSetSystemInformation(HalProfileSourceInterruptHandler, sizeof(PMIHANDLER), (LPVOID)&pNewPmiHandler);
	if (NT_SUCCESS(ntStatus))  {
		DrvDbgPrint("[" DRV_NAME "] Successfully registered system PMI handler to function 0x%llX.\r\n", (LPVOID)pNewPmiHandler);
		g_pDrvData->bPmiInstalled = TRUE;
	}

	return ntStatus;
}

// Unregister and remove the LVT PMI interrupt 
NTSTATUS UnregisterPmiInterrupt()
{
	NTSTATUS ntStatus = STATUS_SUCCESS;						// Returned NTSTATUS
	PMIHANDLER pOldPmiHandler = g_pDrvData->pOldPmiHandler;	// The old PMI handler
		
	// This is currently not restoring old PMI handler since we don't know how to retrieve it, just nulling it out
	ntStatus = HalSetSystemInformation(HalProfileSourceInterruptHandler, sizeof(PMIHANDLER), (LPVOID)&pOldPmiHandler);

	if (NT_SUCCESS(ntStatus)) 
	{
		g_pDrvData->bPmiInstalled = FALSE;
		if (g_pDrvData->lpApicBase)
			MmUnmapIoSpace(g_pDrvData->lpApicBase, 0x1000);
	}

	return ntStatus;
}

// The PMI LVT handler routine (Warning! This should run at very high IRQL)
VOID IntelPtPmiHandler(PKTRAP_FRAME pTrapFrame) 
{
	PKDPC pProcDpc = NULL;									// This processor DPC
	MSR_IA32_PERF_GLOBAL_STATUS_DESC pmiDesc = { 0 };		// The PMI Interrupt descriptor
	LVT_Entry perfMonDesc = { 0 };							// The LVT Performance Monitoring register
	LPDWORD lpdwApicBase = g_pDrvData->lpApicBase;			// The LVT Apic I/O space base address (if not in x2Apic mode)
	DWORD dwCurCpu = 0;
	PER_PROCESSOR_PT_DATA * pCurCpuData = NULL;				// The Per-Processor data structure
	PT_BUFFER_DESCRIPTOR * ptBuffDesc = NULL;				// The PT Buffer descriptor
	UNREFERENCED_PARAMETER(pTrapFrame);

	ASSERT(KeGetCurrentIrql() > DISPATCH_LEVEL);

	dwCurCpu = KeGetCurrentProcessorNumber();
	pCurCpuData = &g_pDrvData->procData[dwCurCpu];
	ptBuffDesc = g_pDrvData->procData[dwCurCpu].pPtBuffDesc;

	// Check if the interrupt is mine
	pmiDesc.All = __readmsr(MSR_IA32_PERF_GLOBAL_STATUS);
	if (pmiDesc.Fields.TraceToPAPMI == 0)
		return;

	// Pause the Tracing. From Intel's Manual: "Software can minimize the likelihood of the second case by clearing
	//	TraceEn at the beginning of the PMI handler"
	PauseResumeTrace(TRUE);

	// Check the Intel PT status
	MSR_RTIT_STATUS_DESC traceStatusDesc = { 0 };
	traceStatusDesc.All = __readmsr(MSR_IA32_RTIT_STATUS);
	if (traceStatusDesc.Fields.Error)
		DrvDbgPrint("[" DRV_NAME "] Warning: Intel PT Pmi has raised, but the PT Status register indicates an error!\r\n");

	if (ptBuffDesc && ptBuffDesc->bDefaultPmiSet) {
		// Queue a DPC only if the Default PMI handler is set
		ptBuffDesc->bBuffIsFull = TRUE;

		// The IRQL is too high so we use DPC 
		pProcDpc = (PKDPC)ExAllocatePoolWithTag(NonPagedPool, sizeof(KDPC), MEMTAG);
		KeInitializeDpc(pProcDpc, IntelPmiDpc, NULL);
		KeSetTargetProcessorDpc(pProcDpc, (CCHAR)dwCurCpu);
		KeInsertQueueDpc(pProcDpc, (LPVOID)dwCurCpu, NULL);
	}

	MSR_IA32_PERF_GLOBAL_OVF_CTRL_DESC globalResetMsrDesc = { 0 };
	// Set the PMI Reset: Once the ToPA PMI handler has serviced the relevant buffer, writing 1 to bit 55 of the MSR at 390H
	// (IA32_GLOBAL_STATUS_RESET)clears IA32_PERF_GLOBAL_STATUS.TraceToPAPMI.
	globalResetMsrDesc.Fields.ClrTraceToPA_PMI = 1;
	__writemsr(MSR_IA32_PERF_GLOBAL_OVF_CTRL, globalResetMsrDesc.All);

	// Call the External PMI handler (if any)
	if (g_pDrvData->pCustomPmiIsr) {
		g_pDrvData->pCustomPmiIsr(dwCurCpu, ptBuffDesc);
	}

	// Re-enable the PMI
	if (g_pDrvData->bCpuX2ApicMode) 
	{
		// Check Intel Manuals, Vol. 3A section 10-12
		// The local APIC registers can be accessed via the MSR interface only when the local APIC has
		// been switched to the x2APIC mode as described
		ULONGLONG perfMonEntry = __readmsr(MSR_IA32_X2APIC_LVT_PMI);
		perfMonDesc.All = (ULONG)perfMonEntry;
		perfMonDesc.Fields.Masked = 0;
		perfMonEntry = (ULONGLONG)perfMonDesc.All;
		__writemsr(MSR_IA32_X2APIC_LVT_PMI, perfMonEntry);
	} else {
		if (!lpdwApicBase)
			// XXX: Not sure how to continue, No MmMapIoSpace at this IRQL (should not happen)
			KeBugCheckEx(INTERRUPT_EXCEPTION_NOT_HANDLED, NULL, NULL, NULL, NULL);
		// Access the APIC register through the I/O port
		perfMonDesc.All = lpdwApicBase[0x340 / 4];
		perfMonDesc.Fields.Masked = 0;
		lpdwApicBase[0x340 / 4] = perfMonDesc.All;
	}
};

// The Kernel mode PMI callback APC
VOID ApcKernelRoutine(PKAPC pApc, PKNORMAL_ROUTINE *NormalRoutine, PVOID *NormalContext, PVOID *SystemArgument1, PVOID *SystemArgument2) {
	UNREFERENCED_PARAMETER(NormalRoutine);
	UNREFERENCED_PARAMETER(NormalContext);
	UNREFERENCED_PARAMETER(SystemArgument1);
	UNREFERENCED_PARAMETER(SystemArgument2);
	// ??? What to do here?? 
	// Simple only free the APC structure
	if (pApc) ExFreePool(pApc);
}

// Check and clean the dead PMI callbacks
NTSTATUS CheckUserPmiCallbackList() {
	KIRQL kOldIrql = KeGetCurrentIrql();
	PLIST_ENTRY pNextEntry = NULL, pCurEntry = NULL;
	if (IsListEmpty(&g_pDrvData->userCallbackList)) return STATUS_NOT_FOUND;

	KeAcquireSpinLock(&g_pDrvData->userCallbackListLock, &kOldIrql);
	pNextEntry = g_pDrvData->userCallbackList.Flink;
	while (pNextEntry != &g_pDrvData->userCallbackList) {
		PPMI_USER_CALLBACK_DESC pCurPmiDesc = NULL;
		pCurEntry = pNextEntry;
		pCurPmiDesc = CONTAINING_RECORD(pCurEntry, PMI_USER_CALLBACK_DESC, entry);
		if (PsIsThreadTerminating(pCurPmiDesc->pTargetThread)) {
			// Auto delete this damn entry
			pNextEntry = pCurEntry->Flink;
			RemoveEntryList(pCurEntry);
			DrvDbgPrint("[" DRV_NAME "] Successfully removed dead user-mode PMI Callback (Thread ID: %i, Address: 0x%llX).\r\n",
				PsGetThreadId(pCurPmiDesc->pTargetThread), pCurPmiDesc->lpUserAddress);
			ObDereferenceObject(pCurPmiDesc->pTargetThread);
			ExFreePool(pCurPmiDesc);
			continue;
		}
		pNextEntry = pCurEntry->Flink;
	}
	KeReleaseSpinLock(&g_pDrvData->userCallbackListLock, kOldIrql);
	return STATUS_SUCCESS;
}

// Clear the user PMI Callback list and free the memory
NTSTATUS ClearAndFreePmiCallbackList() {
	KIRQL kOldIrql = KeGetCurrentIrql();
	PLIST_ENTRY pCurEntry = NULL;
	PPMI_USER_CALLBACK_DESC pCurCallback = NULL;
	if (IsListEmpty(&g_pDrvData->userCallbackList)) return  STATUS_NOT_FOUND;

	KeAcquireSpinLock(&g_pDrvData->userCallbackListLock, &kOldIrql);
	while (TRUE) {
		pCurEntry = RemoveHeadList(&g_pDrvData->userCallbackList);
		if (pCurEntry == &g_pDrvData->userCallbackList) break;
		pCurCallback = CONTAINING_RECORD(pCurEntry, PMI_USER_CALLBACK_DESC, entry);
		ObDereferenceObject(pCurCallback->pTargetThread);
		ExFreePool(pCurCallback);
	}
	KeReleaseSpinLock(&g_pDrvData->userCallbackListLock, kOldIrql);
	return STATUS_SUCCESS;
}

// The PMI DPC routine
VOID IntelPmiDpc(struct _KDPC *pDpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2) 
{
	UNREFERENCED_PARAMETER(DeferredContext);
	UNREFERENCED_PARAMETER(SystemArgument1);
	UNREFERENCED_PARAMETER(SystemArgument2);
	DWORD dwCpuNum = KeGetCurrentProcessorNumber();			// This CPU number
	ULONGLONG targetCr3 = 0ui64;							// The target CR3 register value
	KIRQL kOldIrql = KeGetCurrentIrql();
	
	// A quick integrity check
	ASSERT(dwCpuNum == (DWORD)SystemArgument1);

	PER_PROCESSOR_PT_DATA & curCpuData = g_pDrvData->procData[dwCpuNum];	// This processor DPC data
		
	if (curCpuData.lpTargetProc) 
	{
		// Verify that the Target CR3 still matches
		targetCr3 = ((ULONGLONG*)curCpuData.lpTargetProc)[5];
		ASSERT(targetCr3 == curCpuData.lpTargetProcCr3);

		// queue work item to suspend the target process 
		PWORK_QUEUE_ITEM pWorkItem = (PWORK_QUEUE_ITEM)ExAllocatePoolWithTag(NonPagedPool, sizeof(WORK_QUEUE_ITEM) + sizeof(LPVOID), MEMTAG);
		if (pWorkItem) 
		{
			ExInitializeWorkItem(pWorkItem, IntelPmiWorkItem, (PVOID)pWorkItem);
			*((LPVOID*)(LPBYTE(pWorkItem) + sizeof(WORK_QUEUE_ITEM))) = (LPVOID)curCpuData.lpTargetProc;
			ExQueueWorkItem(pWorkItem, CriticalWorkQueue);
		}
	}

	// Set the Buffer full Event (if any)
	if (g_pDrvData->pPmiEvent)
		KeSetEvent(g_pDrvData->pPmiEvent, IO_NO_INCREMENT, FALSE);

	// Queue the User-mode APC and call the User-mode Callbacks
	if (!IsListEmpty(&g_pDrvData->userCallbackList)) {
		PLIST_ENTRY pNextEntry = NULL,				// Next entry
			pCurEntry = NULL;						// Current entry
		PRKAPC pkApc = NULL;
		
		KeAcquireSpinLock(&g_pDrvData->userCallbackListLock, &kOldIrql);
		pNextEntry = g_pDrvData->userCallbackList.Flink;
		while (pNextEntry != &g_pDrvData->userCallbackList) {
			PPMI_USER_CALLBACK_DESC pCurPmiDesc = NULL;
			BOOLEAN bApcInserted = FALSE;
			pCurEntry = pNextEntry;
			pCurPmiDesc = CONTAINING_RECORD(pCurEntry, PMI_USER_CALLBACK_DESC, entry);
			if ((1i64 << dwCpuNum) & pCurPmiDesc->kAffinity) {
				// Found a valid User-mode callback, verify it and call it
				if (PsIsThreadTerminating(pCurPmiDesc->pTargetThread)) {
					// Auto delete this damn entry
					pNextEntry = pCurEntry->Flink;
					RemoveEntryList(pCurEntry);
					ObDereferenceObject(pCurPmiDesc->pTargetThread);
					ExFreePool(pCurPmiDesc);
					continue;
				}
				pkApc = (PRKAPC)ExAllocatePoolWithTag(NonPagedPool, sizeof(KAPC), MEMTAG);
				if (pkApc) {
					KeInitializeApc(pkApc, (PRKTHREAD)pCurPmiDesc->pTargetThread, CurrentApcEnvironment, &ApcKernelRoutine, NULL,
						(PKNORMAL_ROUTINE)pCurPmiDesc->lpUserAddress, UserMode, (PVOID)dwCpuNum);
					bApcInserted = KeInsertQueueApc(pkApc, (LPVOID)curCpuData.lpUserVa, (LPVOID)curCpuData.pPtBuffDesc->qwBuffSize, IO_NO_INCREMENT);
				}
				ASSERT(pkApc != NULL && bApcInserted == TRUE);
			}
			pNextEntry = pCurEntry->Flink;
		}
		KeReleaseSpinLock(&g_pDrvData->userCallbackListLock, kOldIrql);
	}

	ExFreePool(pDpc);
}

// The PMI Work Item
VOID IntelPmiWorkItem(PVOID Parameter) 
{
	PWORK_QUEUE_ITEM pWorkItem = NULL;					// This work item 
	PEPROCESS pTargetProc = NULL;						// The Target Process
	NTSTATUS ntStatus = STATUS_ABANDONED;				// The returned NTSTATUS 
	DWORD dwProcId = 0;									// The target process ID

	if (!Parameter) return;
	pWorkItem = (PWORK_QUEUE_ITEM)Parameter;
	pTargetProc = *(PEPROCESS*)((LPBYTE)Parameter + sizeof(WORK_QUEUE_ITEM));
	dwProcId = (DWORD)PsGetProcessId(pTargetProc);

	ntStatus = PsSuspendProcess(pTargetProc);
	if (NT_SUCCESS(ntStatus))
		DrvDbgPrint("[" DRV_NAME "] Successfully suspended process ID: %i.\r\n", dwProcId);

	ExFreePool(pWorkItem);
}
#pragma code_seg()
#pragma endregion
```

`WindowsPtDriver/IntelPt.h`:

```h
/**********************************************************************
 *  Windows Intel Processor Trace (PT) Driver 0.4
 *  Filename: IntelPt.h
 *  Defines the Intel Processor Trace driver function prototypes
 *  Last revision: 01/06/2016
 *
 *  Copyright© 2016 Andrea Allievi, Richard Johnson
 *  TALOS Research and Intelligence Group and Microsoft Ltd
 *  All right reserved
 **********************************************************************/
#pragma once
#include "Intel_Defs.h"

// For "kernelTracing.h"
#define INTEL_PT_HDRS 1

struct INTEL_PT_CAPABILITIES {
	UINT16 bCr3Filtering : 1;						// [0] - CR3 Filtering Support (Indicates that IA32_RTIT_CTL.CR3Filter can be set to 1)
	UINT16 bConfPsbAndCycSupported : 1;				// [1] - Configurable PSB and Cycle-Accurate Mode Supported (IA32_RTIT_CTL.PSBFreq can be set to a non-zero value, IA32_RTIT_STATUS.PacketByteCnt can be set to a non-zero value)
	UINT16 bIpFiltering : 1;						// [2] - IP Filtering and TraceStop	supported, and Preserve Intel PT MSRs across warm reset
	UINT16 bMtcSupport : 1;							// [3] - IA32_RTIT_CTL.MTCEn can be set to 1, and MTC packets will be generated (section 36.2.5)
	UINT16 bPtWriteSupport : 1;						// [4] - indicates support of PTWRITE
	UINT16 bPETSupport : 1;							// [5] - indicates support of Power Event Trace
	UINT16 bVmxSupport : 1;							// [6] - Indicates whether Intel PT can be used in VMX operations
	UINT16 bTopaOutput : 1;							// [7] - Tracing can be enabled with IA32_RTIT_CTL.ToPA = 1, hence utilizing the ToPA output scheme (section 36.2.4.2)
	UINT16 bTopaMultipleEntries : 1;				// [8] - ToPA tables can hold any number of output entries, up to the maximum allowed by the MaskOrTableOffset field of IA32_RTIT_OUTPUT_MASK_PTRS
	UINT16 bSingleRangeSupport : 1;					// [9] - Single-Range Output Supported
	UINT16 bTransportOutputSupport : 1;				// [10] - Output to Trace Transport Subsystem Supported (Setting IA32_RTIT_CTL.FabricEn to 1 is supported)
	UINT16 bIpPcksAreLip : 1;						// [11] - IP Payloads are LIP (Specifies if the generated packets that contain IP payloads have LIP values or RIP values)	<-- Very important
	SHORT numOfAddrRanges;							// + 0x02 - Number of Address Ranges - specifies the number ADDRn_CFG field supported in IA32_RTIT_CTL for IP filtering	and IP TraceStop
	SHORT mtcPeriodBmp;								// + 0x04 - Bitmap of supported MTC Period Encodings
	SHORT cycThresholdBmp;							// + 0x06 - Bitmap of supported Cycle Threshold values
	SHORT psbFreqBmp;								// + 0x08 - Bitmap of supported	Configurable PSB Frequency encoding
};

enum PT_PROCESSOR_STATE {
	PT_PROCESSOR_STATE_ERROR = -1,
	PT_PROCESSOR_STATE_DISABLED = 0,
	PT_PROCESSOR_STATE_STOPPED,
	PT_PROCESSOR_STATE_TRACING,
	PT_PROCESSOR_STATE_PAUSED
};

// Describe a processor trace range
struct PT_TRACE_RANGE {
	LPVOID lpStartVa;
	LPVOID lpEndVa;
	BOOLEAN bStopTrace;
};

// Data structure that describe the trace type request
struct PT_TRACE_DESC {
	PEPROCESS peProc;						// Trace by CR3: The Process address space to trace (if any)
	BOOLEAN bTraceKernel;					// Trace by CPL: TRUE to trace Kernel mode components
	BOOLEAN bTraceUser;						// Trace by CPL: TRUE to trace User mode components
	DWORD dwNumOfRanges;					// Trace by IP: Number of range to trace
	struct PT_TRACE_RANGE Ranges[4];		// Trace by IP: the VA ranges to trace
};

// The trace options Bitmask
union TRACE_OPTIONS {
	struct {
		BOOLEAN bTraceCycPcks : 1;					// [0] - Enables/disables CYC Packet (Cycle Count Packet - default is 0)
		BOOLEAN bTraceMtcPcks : 1;					// [1] - Enables/disables MTC Packet (Wall-clock time packets - default is 0)
		BOOLEAN bTraceTscPcks : 1;					// [2] - Enables/disables TSC Packet (Time Stamp packets - default is 0)
		BOOLEAN bTraceBranchPcks : 1;				// [3] - Enables/disables COFI-based packets: FUP, TIP, TIP.PGE, TIP.PGD, TNT, MODE.Exec, MODE.TSX.		(default is 1)
		BOOLEAN bUseTopa : 1;						// [4] - Enable/disable the usage of Table of Physical Address (if available, default is 1)
		BOOLEAN bEnableRetCompression : 1;			// [5] - Enables/disables RET compression (default is 1)
		BOOLEAN bInitialized : 1;					// [6] - Set to 1 if this structure is initialized
		BOOLEAN Reserved : 1;						// [7] - Reserved
		BYTE MTCFreq : 4;							// [8:11] - MTC packet Frequency, which is based on the core crystal clock, or Always Running Timer (ART)
		BYTE CycThresh : 4;							// [12:15] - CYC packet threshold. CYC packets will be sent with the first eligible packet after N cycles have passed since the last CYC packet
		BYTE PSBFreq : 4;							// [16:19] - The frequency of PSB packets. PSB packet frequency is based on the number of Intel PT packet bytes output
	} Fields;
	DWORD All;
};

// The descriptor of the Tracing buffer
typedef struct _PT_BUFFER_DESCRIPTOR {
	union {
		struct {
			LPVOID lpTraceBuffVa;					// + 0x00 - Kernel VA Pointer to a contiguous memory buffer
			ULONG_PTR lpTraceBuffPhysAddr;			// + 0x08 - The physical address of the contiguous memory buffer
		} Simple;
		struct {
			LPVOID lpTopaVa;						// + 0x00 - Kernel VA pointer to the ToPA
			ULONG_PTR lpTopaPhysAddr;				// + 0x08 - The Physical adress of the ToPA
		} ToPA;
	} u;
	BOOLEAN bUseTopa;								// + 0x10 - TRUE if this processor uses ToPa
	BOOLEAN bDefaultPmiSet;							// + 0x11 - TRUE if the default PMI is on
	BOOLEAN bBuffIsFull;							// + 0x12 - TRUE if the ToPa or Simple buffer is full
	QWORD qwBuffSize;								// + 0x18 - The physical buffer size
	PMDL pTraceMdl;									// + 0x20 - The MDL used for mapping pages
	LPVOID lpKernelVa;								// + 0x28 - The kernel-mode virtual address (never used, except for the tests)
}PT_BUFFER_DESCRIPTOR, *PPT_BUFFER_DESCRIPTOR;

// The custom PMI ISR routines
typedef VOID(*INTELPT_PMI_HANDLER)(DWORD dwCpuId, PT_BUFFER_DESCRIPTOR * ptBuffDesc);

struct PER_PROCESSOR_PT_DATA {
	PT_BUFFER_DESCRIPTOR * pPtBuffDesc;				// + 0x00 - The PT buffer descriptor associated to this CPU 
	TRACE_OPTIONS TraceOptions;						// + 0x08 - The trace packets options bitmask
	LPVOID lpUserVa;								// + 0x28 - The User Mode VA
	PEPROCESS lpMappedProc;							// + 0x30 - The process the User VA belongs to (usually the user-mode controlling app)	
	PT_PROCESSOR_STATE curState;					// + 0x38 - Current processor state
	ULONGLONG PacketByteCount;						// + 0x40 - The total number of TRACE packets acquired by this processor

	LPVOID lpXSaveArea;								// + 0x48 - [Experimantal] - XSave Area ptr
	DWORD dwXSaveAreaSize;							// + 0x50 - [Experimantal] - XSave area size for current processor

	// Tracing state data:
	PEPROCESS lpTargetProc;							// + 0x58 - The target process to monitor (NULL if All process are going to be traced)
	ULONG_PTR lpTargetProcCr3;						// + 0x60 - The process to monitor CR3 (NULL if All process are going to be traced)
	DWORD dwNumOfActiveRanges;						// + 0x68 - Number of active ranges
	PT_TRACE_RANGE IpRanges[4];						// + 0x70
};

// The user-mode PMI Callback descriptor
typedef struct _PMI_USER_CALLBACK_DESC {
	LIST_ENTRY entry;							// + 0x00 - The double linked list entry
	PETHREAD pTargetThread;						// + 0x10 - The target thread
	KAFFINITY kAffinity;						// + 0x18 - The target routine affinity mask
	LPVOID lpUserAddress;						// + 0x20 - The user-mode callback address
} PMI_USER_CALLBACK_DESC, *PPMI_USER_CALLBACK_DESC;

// Define the number of trailing zeroes in a page aligned virtual address.
// This is used as the shift count when shifting virtual addresses to
// virtual page numbers.
#define PAGE_SHIFT 12L
#define PAGE_SIZE 0x1000

// Check the Intel Processor Trace support on this processor
NTSTATUS CheckIntelPtSupport(INTEL_PT_CAPABILITIES * lpPtCap);

// Enable the Intel PT for current processor
NTSTATUS StartCpuTrace(PT_TRACE_DESC desc, PT_BUFFER_DESCRIPTOR * pPtBuffDesc);
// Allocate the buffer and start Intel PT for current processor
NTSTATUS StartCpuTrace(PT_TRACE_DESC trace_desc, QWORD qwBuffSize = 0ui64);
// Start the tracing for a Process
NTSTATUS StartProcessTrace(DWORD dwProcId, QWORD qwBuffSize = 0ui64);
// Disable Intel PT for the current processor
NTSTATUS StopAndDisablePt();
// Put the tracing in PAUSE mode
NTSTATUS PauseResumeTrace(BOOLEAN bPause);
// Map a physical page buffer to the current User-mode process 
NTSTATUS MapTracePhysBuffToUserVa(DWORD dwCpuId);
// Unmap the memory-mapped physical memory from User mode
NTSTATUS UnmapTraceBuffToUserVa(DWORD dwCpuId);
// Allocate a Trace buffer for the current CPU
NTSTATUS AllocPtBuffer(PT_BUFFER_DESCRIPTOR ** lppBuffDesc, QWORD qwSize, BOOLEAN bUseTopa = TRUE);
// Free a PT trace buffer (use with caution, avoid BSOD please)
NTSTATUS FreePtBuffer(PT_BUFFER_DESCRIPTOR * ptBuffDesc);
// Allocate a Trace buffer for a specific CPU
NTSTATUS AllocCpuPtBuffer(DWORD dwCpuId, QWORD qwSize, BOOLEAN bUseToPA);
// Free the resources used by a CPU
NTSTATUS FreeCpuResources(DWORD dwCpuId);
// Get if the PT buffer is allocated and valid for a particular processor
QWORD IsPtBufferAllocatedAndValid(DWORD dwCpuId, BOOLEAN bTestUserVa = FALSE);
// Clear the PT buffer
NTSTATUS ClearCpuPtBuffer(DWORD dwCpuId);
// Get the active Trace options for a particular CPU
NTSTATUS GetTraceOptions(DWORD dwCpuId, TRACE_OPTIONS * pOptions);
// Set the trace options for a particular CPU
NTSTATUS SetTraceOptions(DWORD dwCpuId, TRACE_OPTIONS options);
// Set the default trace options for a particular CPU
NTSTATUS SetDefaultTraceOptions(DWORD dwCpuId);
// Allocate and set a ToPA (with the Windows API)
NTSTATUS AllocAndSetTopa(PT_BUFFER_DESCRIPTOR ** lppBuffDesc, QWORD qwReqBuffSize, BOOLEAN bSetPmiAndStop = TRUE);
// Register the LVT (Local Vector Table) PMI interrupt
NTSTATUS RegisterPmiInterrupt();
// Deregister and remove the LVT PMI interrupt 
NTSTATUS UnregisterPmiInterrupt();
// Check and clean the dead PMI callbacks
NTSTATUS CheckUserPmiCallbackList();
// Clear the user PMI Callback list and free the memory
NTSTATUS ClearAndFreePmiCallbackList();
// The PMI LVT handler routine (Warning! This should run at very high IRQL)
VOID IntelPtPmiHandler(PKTRAP_FRAME pTrapFrame);
BOOLEAN PmiInterruptHandler(struct _KINTERRUPT *Interrupt, PVOID ServiceContext);
// The PMI DPC routine
VOID IntelPmiDpc(struct _KDPC *Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2);
// The PMI Work Item
VOID IntelPmiWorkItem(PVOID Parameter);

#pragma region Kernel Tracing Test Routines and IOCTLs
#ifdef _DEBUG
// Kernel Tracing Test IOCTL
#define IOCTL_PTDR_DO_KERNELDRV_TEST CTL_CODE(FILE_DEVICE_UNKNOWN, 0xA0C, METHOD_BUFFERED, FILE_EXECUTE)

// Do a Kernel trace of a driver test:
NTSTATUS DoDriverTraceTest(LPTSTR lpDrvFileName, LPTSTR lpDumpFile = NULL, DWORD dwBuffSize = 0);
#endif
#pragma endregion
```

`WindowsPtDriver/IntelPtXSave.cpp`:

```cpp
/**********************************************************************
*  Windows Intel Processor Trace (PT) Driver 0.5
*  Filename: IntelPtXSave.cpp
*  Implements the support routines for the PT XSAVE feature
*  Last revision: 01/25/2017
*
*  Copyright© 2017 Andrea Allievi, Richard Johnson
*  TALOS Research and Intelligence Group and Microsoft Ltd
*  All right reserved
**********************************************************************/

#include "stdafx.h"
#include "IntelPtXSave.h"
#include "DriverEntry.h"
#include <intrin.h>

// Check if the current processor support the XSAVE feature for Intel PT
NTSTATUS CheckPtXSaveSupport(DWORD * pdwSAreaSize, DWORD * pdwUAreaSize, DWORD * pdwPtSize) {
	int cpuInfo[4] = { 0 };
	// Check the presence of XSAVE Feature (chapter 13.2 of Intel Basic Architecure manual)
	__cpuidex(cpuInfo, 1, 0);
	if ((cpuInfo[2] & CPUID_XSAVE_MASK) != CPUID_XSAVE_MASK) return STATUS_NOT_SUPPORTED;
	// Now use the Processor Extended State Enumeration Main Leaf
	__cpuidex(cpuInfo, 0xD, 0);
	// Check the x87 and SSE state
	if ((cpuInfo[0] & (1 << 0)) == 0) return STATUS_NOT_SUPPORTED;
	if ((cpuInfo[0] & (1 << 1)) == 0) return STATUS_NOT_SUPPORTED;
	if (pdwUAreaSize) (*pdwUAreaSize) = cpuInfo[2];
	// Now check the support of XSAVES/XRSTORS and IA32_XSS MSR
	__cpuidex(cpuInfo, 0xD, 1);
	if ((cpuInfo[0] & (1 << 3)) == 0) return STATUS_NOT_SUPPORTED;
	// Check the opfficial PT support
	if ((cpuInfo[2] & PT_XSAVE_MASK) == 0) return STATUS_NOT_SUPPORTED;
	if (pdwSAreaSize) (*pdwSAreaSize) = cpuInfo[1];

	// Try to get the size and position of the PT data in the EXTENDED REGION of the XSAVE area 
	__cpuidex(cpuInfo, 0xD, 8);
	if (pdwPtSize) (*pdwPtSize) = cpuInfo[0];
	ASSERT((cpuInfo[2] & (1 << 0)) == 1);				// ECX Bit 00 is set if the bit n(corresponding to the sub - leaf index) is supported in the IA32_XSS MSR; it is clear if bit n is instead supported in XCR0.

	// ps. Take a look at KeSaveExtendedProcessorState - RtlXSave and RtlGetEnabledExtendedFeatures
	return STATUS_SUCCESS;
}

// Get the current XSAVE Area size for the enabled features in XCR0 and IA32_XSS MSR of current CPU
DWORD GetCurXSaveAreaSize() {
	int cpuInfo[4] = { 0 };
	// Processor Extended State Enumeration Sub - leaf(EAX = 0DH, ECX = 1)
	__cpuidex(cpuInfo, 0xD, 1);
	// EBX Bits 31 - 00: The size in bytes of the XSAVE area containing all states enabled by XCRO | IA32_XSS.
	return (DWORD)cpuInfo[1];
}

// Save all the PT data to an XSAVE area
NTSTATUS SavePtData(PXSAVE_AREA_EX lpXSaveArea, DWORD dwSize) {
	MSR_IA32_XSS_DESC xssDesc = { 0 };					// The IA32_XSS MSR descriptor
	XCR0_DESC xcr0Desc = { 0 };							// The XCR0 extended register descriptor
	XCR0_DESC xcr0OrgDesc = { 0 };						// The XCR0 original extended register descriptor
	NTSTATUS ntStatus = STATUS_SUCCESS;					// Returned NTSTATUS
	ULONG_PTR cr4 = { 0 };								// Value of CR4 register (we must enable the XSAVE feature)
	DWORD dwPtAreaSize = 0;								// XSAVE area with Intel PT enable
	if (!lpXSaveArea || !dwSize) return STATUS_INVALID_PARAMETER;

	ntStatus = CheckPtXSaveSupport(NULL, NULL, &dwPtAreaSize);
	if (!NT_SUCCESS(ntStatus)) return ntStatus;

	// Step 1. Enable XSAVE in CR4 register
	cr4 = __readcr4();
	cr4 = (cr4 | OSXSAVE_CR4_MASK);
	__writecr4(cr4);

	// Check the XSAVE area (must be 64-BYTE aligned)
	if (((ULONG_PTR)lpXSaveArea & 0x0FF) != 0)
		return STATUS_INVALID_ADDRESS;

	RtlZeroMemory(lpXSaveArea, dwSize);

	// Set the proper bit in the MSR_IA32_XSS and in XCR0
	xcr0OrgDesc.value = _xgetbv(0);					// Read the original XCR0 descriptor, because otherwise we could have problem with the Windows Context Dispatcher
	xcr0Desc.Bits.FpuMmx = 1;
	xssDesc.Bits.IntelPt = 1;
	__writemsr(MSR_IA32_XSS, xssDesc.value);
	_xsetbv(0, xcr0Desc.value);

	// Check the size of the XSAVE area
	dwPtAreaSize = GetCurXSaveAreaSize();
	if (dwSize < dwPtAreaSize) return STATUS_INVALID_BUFFER_SIZE;

	// Now perform the XSAVES
	DBG_BREAK();
	_xsaves((LPVOID)lpXSaveArea, xssDesc.value);

	// Restore old XCR0 register
	_xsetbv(0, xcr0OrgDesc.value);

	return STATUS_SUCCESS;
}
```

`WindowsPtDriver/IntelPtXSave.h`:

```h
/**********************************************************************
*  Windows Intel Processor Trace (PT) Driver 0.5
*  Filename: IntelPtXSave.h
*  Defines the Intel Processor Trace support data structures for XSAVE feature
*  Last revision: 01/25/2017
*
*  Copyright© 2017 Andrea Allievi, Richard Johnson
*  TALOS Research and Intelligence Group and Microsoft Ltd
*  All right reserved
**********************************************************************/
#pragma once
#include "Intel_Defs.h"

// The XSAVES function used in AMD64/X86 CPUs (defined in Amd64XSAve.asm)
extern "C" void _xsaves(void *mem, unsigned __int64 save_mask);

#define CPUID_XSAVE_MASK			(1 << 26)			// The XSAVE support in CPUID leaf 1
#define PT_XSAVE_MASK				(1 << 8)			// The PT support in XSAVE 
#define IA32_XSS_XSAVE_MASK			(1 << 8)			// The XSS MSR support in XSAVE 
#define MSR_IA32_XSS				(0x00000DA0)		// IA32_XSS Model specific register ID
#define OSXSAVE_CR4_MASK			(1i64 << 18)		// The XSAVE on/off bitmask in CR4 register

typedef struct _GLOBAL_DATA {
	DWORD dwXSaveSAreaSize;					// Supervisor XSAVE Area maximum size
	DWORD dwXSaveUAreaSize;					// User-mode XSAVE Area maximum size
} GLOBAL_DATA;

// Intel PT XSAVE Area
typedef struct DECLSPEC_ALIGN(16) _XSAVE_PT_EXTENDED_AREA {
	MSR_RTIT_CTL_DESC rtit_ctl;								// + 0x00 - IA32_RTIT_CTL MSR
	MSR_RTIT_OUTPUTBASE_DESC rtit_outputbase;				// + 0x08 - IA32_RTIT_OUTPUTBASE MSR
	MSR_RTIT_OUTPUT_MASK_PTRS_DESC rtit_output_mask_ptrs;	// + 0x10 - IA32_RTIT_OUTPUTMASK_PTRS MSR
	MSR_RTIT_STATUS_DESC rtit_status;						// + 0x18 - IA32_RTIT_STATUS MSR
	ULONGLONG rtit_cr3_match;								// + 0x20 - IA32_RTIT_CR3_MATCH
	ULONGLONG rtit_addr0_a;									// + 0x28 - MSR_IA32_RTIT_ADDR0_A (start) MSR 
	ULONGLONG rtit_addr0_b;									// + 0x30 - MSR_IA32_RTIT_ADDR0_B (end) MSR 
	ULONGLONG rtit_addr1_a;									// + 0x38 - MSR_IA32_RTIT_ADDR0_A (start) MSR 
	ULONGLONG rtit_addr1_b;									// + 0x40 - MSR_IA32_RTIT_ADDR0_B (end) MSR 
} XSAVE_PT_EXTENDED_AREA;

typedef struct DECLSPEC_ALIGN(16) _XSAVE_AREA_EX {
	XSAVE_FORMAT LegacyState;					// + 0x00
	XSAVE_AREA_HEADER Header;					// + 0x200
	XSAVE_PT_EXTENDED_AREA ExtendedArea;		// + 0x240
} XSAVE_AREA_EX, *PXSAVE_AREA_EX;

#pragma pack(push)
#pragma pack(1)
typedef union _MSR_IA32_XSS_DESC {
	struct {
		DWORD Reserved : 8;					// [7:0] Reserved
		DWORD IntelPt : 1;					// [8] Trace Packet Configuration State (R/W)
		DWORD Reserved2 : 23;
	} Bits;
	ULONG64 value;
} MSR_IA32_XSS_DESC;

typedef union _XCR0_DESC {
	struct {
		DWORD FpuMmx : 1;					// [0] x87 FPU/MMX state (must be 1)
		DWORD Sse : 1;						// [1] SSE state
		DWORD Avx : 1;						// [2] AVX state	
		DWORD BNDREG : 1;					// [3] BNDREG state
		DWORD BNDCSR : 1;					// [4] BNDCSR state
		DWORD OpMask : 1;					// [5] Opmask state	
		DWORD ZMM_Hi256 : 1;				// [6] ZMM_Hi256 state	
		DWORD Hi16_ZMM : 1;					// [7] Hi16_ZMM state
		DWORD Reserved : 1;					// [8] Reserved - Used for Intel PT in IA32_XSS MSR
		DWORD PKRU : 1;						// [9] PKRU state
		DWORD Reserved2 : 22;				// [10:32] Reserved for future expansion
	} Bits;
	ULONG64 value;
} XCR0_DESC;
#pragma pack(pop)

// Check if the current processor support the XSAVE feature for Intel PT
NTSTATUS CheckPtXSaveSupport(DWORD * pdwSAreaSize, DWORD * pdwUAreaSize, DWORD * pdwPtSize);
// Get the current XSAVE Area size for the enabled features in XCR0 and IA32_XSS MSR of current CPU
DWORD GetCurXSaveAreaSize();
// Save all the PT data to an XSAVE area
NTSTATUS SavePtData(PXSAVE_AREA_EX lpXSaveArea, DWORD dwSize);

```

`WindowsPtDriver/Intel_Defs.h`:

```h
/**********************************************************************
 *  Windows Intel Processor Trace (PT) Driver
 *  Filename: Intel_Defs.h
 *  Intel Processor Trace definitions and data structures
 *  Last revision: 01/24/2017
 *
 *  Copyright© 2017 Andrea Allievi, Richard Johnson
 *  TALOS Research and Intelligence Group and Microsoft Ltd
 *  All right reserved
 **********************************************************************/
#pragma once

#define MSR_IA32_PERF_GLOBAL_STATUS		0x0000038E
#define MSR_IA32_APIC_BASE				0x0000001B			// The APIC base address register
#define MSR_IA32_PERF_GLOBAL_OVF_CTRL	0x00000390			// Aka IA32_GLOBAL_STATUS_RESET
#define MSR_IA32_RTIT_OUTPUT_BASE		0x00000560
#define MSR_IA32_RTIT_OUTPUT_MASK_PTRS	0x00000561
#define MSR_IA32_RTIT_CTL				0x00000570
#define MSR_IA32_RTIT_STATUS			0x00000571
#define MSR_IA32_X2APIC_LVT_PMI			0x00000834
#define MSR_IA32_VMX_MISC_CTLS			0x00000485			// The VMX MISC MSR (Appendix A.6 of the System Programming Guide - Vol 3)

// Filtering by CR3:
#define MSR_IA32_RTIT_CR3_MATCH			0x00000572

// Filtering by IP:
#define MSR_IA32_RTIT_ADDR0_START		0x00000580
#define MSR_IA32_RTIT_ADDR0_END			0x00000581
#define MSR_IA32_RTIT_ADDR1_START		0x00000582
#define MSR_IA32_RTIT_ADDR1_END			0x00000583
#define MSR_IA32_RTIT_ADDR2_START		0x00000584
#define MSR_IA32_RTIT_ADDR2_END			0x00000585
#define MSR_IA32_RTIT_ADDR3_START		0x00000586
#define MSR_IA32_RTIT_ADDR3_END			0x00000587


// The maximum physical address (set to 48 bit)
#define MAXPHYADDR 48

#pragma pack(push)
#pragma pack(1)
// IA32_RTIT_CTL MSR descriptor (paragraph 36.2.5.2)
union MSR_RTIT_CTL_DESC {
	struct {
		QWORD TraceEn : 1;					// [0] - If 1, enables tracing; else tracing is disabled if 0.
		QWORD CycEn : 1;					// [1] - Enables or disables CYC Packet (see Section 36.4.2.14).
		QWORD Os : 1;						// [2] - Packet generation is enabled/disabled when CPL = 0.
		QWORD User : 1;						// [3] - Packet generation is enabled/disabled when CPL > 0.
		QWORD Reserved : 2;					// [4:5] - MUST BE 0
		QWORD FabricEn : 1;					// [6] - 0: Trace output is directed to the memory subsystem, mechanism depends on IA32_RTIT_CTL.ToPA. / 1: Trace output is directed to the trace transport subsystem, IA32_RTIT_CTL.ToPA is ignored.
		QWORD CR3Filter : 1;				// [7] - Enables/disables CR3 filtering
		QWORD ToPA : 1;						// [8] - Single-range output scheme / ToPA output scheme
		QWORD MTCEn : 1;					// [9] - Enables/disables MTC Packet
		QWORD TSCEn : 1;					// [10] - Enables/disables TSC packets
		QWORD DisRETC : 1;					// [11] - Enables/disables RET compression
		QWORD Reserved2 : 1;				// [12] - MUST BE 0
		QWORD BranchEn : 1;					// [13] - Enables/disables COFI-based packets: FUP, TIP, TIP.PGE, TIP.PGD, TNT, MODE.Exec, MODE.TSX
		QWORD MTCFreq : 4;					// [14:17] - Defines MTC packet Frequency, which is based on the core crystal clock, or Always Running Timer(ART)
		QWORD Reserved3 : 1;				// [18] - Must be 0
		QWORD CycThresh : 4;				// [19:22] - CYC packet threshold (Section 36.3.6)
		QWORD Reserved4 : 1;				// [23] - Must be 0
		QWORD PSBFreq : 4;					// [24:27] - Indicates the frequency of PSB packets
		QWORD Reserved5 : 4;				// [28:31] - Must be 0
		QWORD Addr0Cfg : 4;					// [32:35] - Configures the base/limit register pair IA32_RTIT_ADDR0_A/B. This field is reserved if CPUID.(EAX=14H, ECX=1):EBX.RANGECNT[2:0] >= 0.
		QWORD Addr1Cfg : 4;					// [36:39] - Configures the base/limit register pair IA32_RTIT_ADDR1_A/B. This field is reserved if CPUID.(EAX=14H, ECX=1):EBX.RANGECNT[2:0] < 2.
		QWORD Addr2Cfg : 4;					// [40:43] - Configures the base/limit register pair IA32_RTIT_ADDR2_A/B. This field is reserved if CPUID.(EAX=14H, ECX=1):EBX.RANGECNT[2:0] < 3.
		QWORD Addr3Cfg : 4;					// [44:47] - Configures the base/limit register pair IA32_RTIT_ADDR3_A/B. This field is reserved if CPUID.(EAX=14H, ECX=1):EBX.RANGECNT[2:0] < 4.
		QWORD Reserved6 : 16;				// [48:63] - Must be 0
	} Fields;
	ULONGLONG All;
};

// IA32_RTIT_STATUS MSR descriptor (paragraph 36.2.5.4)
union MSR_RTIT_STATUS_DESC {
	struct {
		ULONG FilterEn : 1;					// [0] - This bit is written by the processor, and indicates that tracing is allowed for the current IP
		ULONG ContextEn : 1;				// [1] - The processor sets this bit to indicate that tracing is allowed for the current context
		ULONG TriggerEn : 1;				// [2] - The processor sets this bit to indicate that tracing is enabled
		ULONG Reserved1 : 1;				// [3] - Must be 0
		ULONG Error : 1;					// [4] - The processor sets this bit to indicate that an operational error has been encountered
		ULONG Stopped : 1;					// [5] - The processor sets this bit to indicate that a ToPA Stop condition has been encountered
		ULONG Reserved2 : 26;				// [6:31] - Must be 0
		ULONG PacketByteCnt : 17;			// [32:48] - This field is written by the processor, and holds a count of packet bytes that have been sent out
		ULONG Reserved3 : 15;				// [49:63] - Must be 0
	} Fields;
	ULONGLONG All;
};

// The Table of Physical Address Entry format (Section 36.2.4.2)
// The Table of Physical Address Entry format (Section 36.2.4.2)
union TOPA_TABLE_ENTRY {
	struct {
		QWORD End : 1;						// [0] - If set, indicates that this is an END entry, and thus the address field points to a table base rather than an output region base.
		QWORD Reserved1 : 1;				// [1] - Must be 0
		QWORD Int : 1;						// [2] - When the output region indicated by this entry is filled, signal Perfmon LVT interrupt.
		QWORD Reserved2 : 1;				// [3] - Must be 0
		QWORD Stop : 1;						// [4] - When the output region indicated by this entry is filled, software should disable packet generation
		QWORD Reserved3 : 1;				// [5] - Must be 0
		QWORD Size : 4;						// [6:9] - Indicates the size of the associated output region. Encodings are: 0: 4K, 1 : 8K, 2 : 16K, 3 : 32K, 4 : 64K, 5 : 128K, 6 : 256K, 7 : 512K, 8 : 1M, 9 : 2M, 10 : 4M, 11 : 8M, 12 : 16M, 13 : 32M, 14 : 64M, 15 : 128M
		QWORD Reserved4 : 2;				// [10] - Must be 0
		QWORD BaseAddr : 48;				// [12:MAXPHYADDR-1] - If END=0, this is the base physical address of the output region specified by this entry; If END=1, this is the 4K-aligned base physical address of the next ToPA table
	} Fields;
	ULONGLONG All;
};

// IA32_RTIT_OUTPUTBASE MSR descriptor (paragraph 36.2.5.7)
union MSR_RTIT_OUTPUTBASE_DESC {
	struct {
		QWORD Reserved : 7;					// [0:6] - Must be 0 
		QWORD BasePhysAddr : MAXPHYADDR;	// [7:MAXPHYADDR-1] - The base physical address
		QWORD Reserved2 : 57 - MAXPHYADDR;	// [MAXPHYADDR:63] - Must be 0
	} Fields;
	ULONGLONG All;
};

// IA32_RTIT_OUTPUTMASK_PTRS MSR descriptor (paragraph 36.2.5.8)
union MSR_RTIT_OUTPUT_MASK_PTRS_DESC {
	struct {
		ULONG LowerMask : 7;				// [0:6] - Forced to 1
		ULONG MaskOrTableOffset : 25;		// [7:31] - The use of this field depends on the value of IA32_RTIT_CTL.ToPA:
											//			0: This field holds bits 31:7 of the mask value for the single, contiguous physical output region
											//			1: This field holds bits 27:3 of the offset pointer into the current ToPA table
		ULONG OutputOffset;					// [32:63] - The use of this field depends on the value of IA32_RTIT_CTL.ToPA
											//			0: This is bits 31:0 of the offset pointer into the single, contiguous physical output region
											//			1: This field holds bits 31:0 of the offset pointer into the current ToPA output region
	} Fields;
	ULONGLONG All;
};

// The APIC Base physical address MSR in xAPIC Mode
union MSR_IA32_APIC_BASE_DESC {
	struct {
		ULONGLONG Reserved1 : 8;			// [0:7] - Reserved
		ULONGLONG Bsp : 1;					// [8] - Indicates if the processor is the bootstrap processor (BSP)
		ULONGLONG Reserved2 : 1;			// [9] - Reserved
		ULONGLONG EXTD : 1;					// [10] - Enable x2APIC mode
		ULONGLONG EN : 1;					// [11] - APIC global enable/disable
		ULONGLONG ApicBase : 24;			// [12:35] - Base Physical Address
	} Fields;
	ULONGLONG All;
};

// A local vector table (LVT) entry
union LVT_Entry {
	struct {
		USHORT Vector : 8;					// [0:7] - The Vector number
		USHORT Reserved1 : 4;				// [8:11] - Reserved
		USHORT DeliveryStatus : 1;			// [12] - Delivery status: 0 - Idle; 1 - Send Pending;
		USHORT Reserved2 : 3;				// [13:15] - Reserved
		USHORT Masked : 1;					// [16] - Masked: 0 - Not Masked; 1 - Masked
		USHORT TimerMode : 2;				// [17:18] - Timer mode: 00 - One-shot; 01 - Periodic; 10 - TSC-Deadline;
		USHORT Reserved3 : 13;				// [19:31] - Reserved
	} Fields;
	DWORD All;
};

// The IA32_PERF_GLOBAL_STATUS descriptor of Intel Broadwell microarchitecture 
union MSR_IA32_PERF_GLOBAL_STATUS_DESC {
	struct {
		DWORD PMC0_OVF: 1;					// [0] - Read only
		DWORD PMC1_OVF : 1;					// [1] - Read only 
		DWORD PMC2_OVF : 1;					// [2] - Read only
		DWORD PMC3_OVF : 1;					// [3] - Read only
		DWORD PMC4_OVF : 1;					// [4] - Read only (if PMC4 present)
		DWORD PMC5_OVF : 1;					// [5] - Read only (if PMC5 present) 
		DWORD PMC6_OVF : 1;					// [6] - Read only (if PMC6 present)
		DWORD PMC7_OVF : 1;					// [7] - Read only (if PMC7 present)
		DWORD Reserved : 24;				// [8:31] - Reserved
		DWORD FIXED_CTR0 : 1;				// [32] - FIXED_CTR0 Overflow (RO)
		DWORD FIXED_CTR1 : 1;				// [33] - FIXED_CTR1 Overflow (RO)
		DWORD FIXED_CTR2 : 1;				// [34] - FIXED_CTR2 Overflow (RO)
		DWORD Reserved2 : 20;				// [35:54] - Reserved
		DWORD TraceToPAPMI : 1;				// [55] - The ToPA PMI Interrupt status
		DWORD Reserved3 : 5;				// [56:60] - Reserved
		DWORD Ovf_UncorePMU : 1;			// [61]
		DWORD Ovf_Buffer : 1;				// [62]
		DWORD CondChgd : 1;					// [63]
	} Fields;
	ULONGLONG All;
};

// The IA32_PERF_GLOBAL_OVF_CTRL descriptor of Intel Broadwell microarchitecture 
// Global Performance Counter Overflow Control (Section 18-73 of System Programming Guide Volume 3B)
union MSR_IA32_PERF_GLOBAL_OVF_CTRL_DESC {
	struct {
		DWORD PMC0_ClrOVF : 1;				// [0]
		DWORD PMC1_ClrOVF : 1;				// [1]
		DWORD PMC2_ClrOVF : 1;				// [2]
		DWORD PMC3_ClrOVF : 1;				// [3]
		DWORD PMC4_ClrOVF : 1;				// [4] - (if PMC4 present)
		DWORD PMC5_ClrOVF : 1;				// [5] - (if PMC5 present) 
		DWORD PMC6_ClrOVF : 1;				// [6] - (if PMC6 present)
		DWORD PMC7_ClrOVF : 1;				// [7] - (if PMC7 present)
		DWORD Reserved : 24;				// [8:31] - Reserved
		DWORD FIXED_CTR0 : 1;				// [32] - FIXED_CTR0 ClrOverflow
		DWORD FIXED_CTR1 : 1;				// [33] - FIXED_CTR1 ClrOverflow
		DWORD FIXED_CTR2 : 1;				// [34] - FIXED_CTR2 ClrOverflow
		DWORD Reserved2 : 20;				// [35:54] - Reserved
		DWORD ClrTraceToPA_PMI : 1;			// [55] - The ToPA PMI Interrupt status
		DWORD Reserved3 : 5;				// [56:60] - Reserved
		DWORD ClrOvfUncore : 1;				// [61]
		DWORD ClrOvfDsBuffer : 1;			// [62]
		DWORD ClrCondChgd : 1;				// [63]
	} Fields;
	ULONGLONG All;
};

//
// The VMX_MISC_CTLS descriptor register (Appendix A.6 - MISCELLANEOUS DATA of Intel Progamming Guide Volume 3)
//
union MSR_IA32_VMX_MISC_CTLS_DESC {
	struct {
		UINT64 VmxPreemptionRate : 5;			// [4-0] - Specifies the relationship between the rate of the VMX-preemption timer and that of the timestamp counter(TSC)
		UINT64 UnrestrictedGuestSupport : 1;	// [5]
		UINT64 HltSupport : 1;					// [6] - Support for activity state 1 (HLT)
		UINT64 ShutdownSupport : 1;				// [7] - Support for activity state 2 (shutdown)
		UINT64 WaitForSipiSupport : 1;			// [8] - Support for activity state 3 (wait-for-SIPI)
		UINT64 Reserved : 5;					// [13:09]
		UINT64 IntelPtVmxSupport : 1;			// [14] - Intel Processor Trace (Intel PT) can be used in VMX operation
		UINT64 RdmsrSmmSupport : 1;				// [15] - If set to 1, RDMSR can be used in system-management mode (SMM) to read the IA32_SMBASE MSR(MSR address 9EH)
		UINT64 NumberOfCR3Support : 9;			// [24:16] - Number of CR3-target values supported by the processor
		UINT64 Others : 39;
	} Fields;
	UINT64 All;
};

#pragma pack(pop)

#define MTC_MASK	(0xf << 14)
#define CYC_MASK	(0xf << 19)
#define PSB_MASK	(0xf << 24)

#define ADDR0_SHIFT	32
#define ADDR1_SHIFT	32
#define ADDR0_MASK	(0xfULL << ADDR0_SHIFT)
#define ADDR1_MASK	(0xfULL << ADDR1_SHIFT)
#define TOPA_SIZE_SHIFT 6

```

`WindowsPtDriver/KernelTracing.cpp`:

```cpp
/**********************************************************************
 *  Windows Intel Processor Trace (PT) Driver
 * 	Filename: KernelTracing.cpp
 *	Implement the exported functions needed for Kernel Tracing
 *	Last revision: 01/06/2016
 *
 *  Copyright© 2016 Andrea Allievi, Richard Johnson 
 * 	Microsoft Ltd & TALOS Research and Intelligence Group
 *	All right reserved
 **********************************************************************/
#include "stdafx.h"
#include "IntelPt.h"
#include "DriverEntry.h"
#include "KernelTracing.h"


// Allocate the buffer needed for kernel tracing
NTSTATUS IntelPtAllocBuffer(PPT_BUFFER_DESCRIPTOR * ppBuffDesc, QWORD qwSize, BOOLEAN bUseTopa, BOOLEAN bSetStdPmi) {
	NTSTATUS ntStatus = STATUS_SUCCESS;
	PPT_BUFFER_DESCRIPTOR ptBuffDesc = { 0 };

	if (bUseTopa)
		ntStatus = AllocAndSetTopa(&ptBuffDesc, qwSize, bSetStdPmi);
	else
		ntStatus = AllocPtBuffer(&ptBuffDesc, qwSize, FALSE);

	if (NT_SUCCESS(ntStatus)) 
		if (ppBuffDesc) *ppBuffDesc = ptBuffDesc;
	
	return ntStatus;
}

// Add a PMI interrupt for a page in the ToPA
NTSTATUS IntelPtAddBufferPmi(PT_BUFFER_DESCRIPTOR * pBuffDesc, QWORD qwOffset) {
	QWORD qwEntryOffset = (qwOffset / PAGE_SIZE);
	TOPA_TABLE_ENTRY * pCurTopaEntry = NULL;
	if (!pBuffDesc) return STATUS_INVALID_PARAMETER;
	if (!pBuffDesc->bUseTopa || !pBuffDesc->u.ToPA.lpTopaVa) return STATUS_INVALID_PARAMETER_1;

	// Calculate and get the current ToPA entry:
	pCurTopaEntry = (TOPA_TABLE_ENTRY*)((LPBYTE)pBuffDesc->u.ToPA.lpTopaVa + (qwEntryOffset * sizeof(TOPA_TABLE_ENTRY)));
	pCurTopaEntry->Fields.Int = 1;
	return STATUS_SUCCESS;
}

// Remove a PMI interrupt from a page in the ToPA
NTSTATUS IntelPtRemoveBufferPmi(PT_BUFFER_DESCRIPTOR * pBuffDesc, QWORD qwOffset) {
	QWORD qwEntryOffset = (qwOffset / PAGE_SIZE);
	TOPA_TABLE_ENTRY * pCurTopaEntry = NULL;
	if (!pBuffDesc) return STATUS_INVALID_PARAMETER;
	if (!pBuffDesc->bUseTopa || !pBuffDesc->u.ToPA.lpTopaVa) return STATUS_INVALID_PARAMETER_1;
	// Calculate and get the current ToPA entry:
	pCurTopaEntry = (TOPA_TABLE_ENTRY*)((LPBYTE)pBuffDesc->u.ToPA.lpTopaVa + (qwEntryOffset * sizeof(TOPA_TABLE_ENTRY)));
	pCurTopaEntry->Fields.Int = 0;
	return STATUS_SUCCESS;
}

// Delete the previous registered Intel PT PMI handler routine
NTSTATUS IntelPtRemovePmiHandler(INTELPT_PMI_HANDLER pCustomPmiHandler) {
	if (g_pDrvData->pCustomPmiIsr != pCustomPmiHandler) return STATUS_NOT_FOUND;
	else g_pDrvData->pCustomPmiIsr = NULL;
	return STATUS_SUCCESS;
}

// Register a PMI handler for ALL processor
NTSTATUS IntelPtRegisterPmiHandler(INTELPT_PMI_HANDLER pCustomPmiHandler) {
	if (g_pDrvData->pCustomPmiIsr) return STATUS_ALREADY_REGISTERED;
	g_pDrvData->pCustomPmiIsr = pCustomPmiHandler;
	return STATUS_SUCCESS;
}

// Start the Kernel tracing for current processor
NTSTATUS IntelPtStartTracing(PT_TRACE_DESC traceDesc, PT_BUFFER_DESCRIPTOR * pBuffDesc) {
	return StartCpuTrace(traceDesc, pBuffDesc);
}

// Stop the Tracing 
VOID IntelPtStopTrace() {
	DWORD dwCurCpuId = KeGetCurrentProcessorNumber();
	StopAndDisablePt();
	// Do not forget to do the following:
	// We are using external buffer here, it is not our duty to clean-up
	if (g_pDrvData) g_pDrvData->procData[dwCurCpuId].pPtBuffDesc = NULL;		
}

// Set/Get the Trace options for current CPU
NTSTATUS IntelPtSetOptions(TRACE_OPTIONS opts) {
	DWORD dwCurCpuId = KeGetCurrentProcessorNumber();
	NTSTATUS retStatus = SetTraceOptions(dwCurCpuId, opts);
	return retStatus;
}

TRACE_OPTIONS IntelPtGetOptions() {
	NTSTATUS ntStatus = STATUS_SUCCESS;
	TRACE_OPTIONS opts = { 0 };
	DWORD dwCurCpuId = KeGetCurrentProcessorNumber();
	ntStatus = GetTraceOptions(dwCurCpuId, &opts);
	return opts;
}

```

`WindowsPtDriver/KernelTracing.h`:

```h
/**********************************************************************
 *  Windows Intel Processor Trace (PT) Driver 0.4
 *  Filename: KernelTracing.h
 *  Defines data structures needed for Kernel Tracing
 *  Last revision: 01/06/2016
 *
 *  Copyright© 2016 Andrea Allievi, Richard Johnson
 *  TALOS Research and Intelligence Group and Microsoft Ltd
 *  All right reserved
 **********************************************************************/
#pragma once

#ifndef INTEL_PT_HDRS
 // Data structure that describe the trace type request
struct PT_TRACE_DESC {
	PEPROCESS peProc;						// Trace by CR3: The Process address space to trace (if any)
	BOOLEAN bTraceKernel;					// Trace by CPL: TRUE to trace Kernel mode components
	BOOLEAN bTraceUser;						// Trace by CPL: TRUE to trace User mode components
	DWORD dwNumOfRanges;					// Trace by IP: Number of range to trace
	struct PT_TRACE_RANGE Ranges[4];		// Trace by IP: the VA ranges to trace
};

// The trace options Bitmask
union TRACE_OPTIONS {
	struct {
		BOOLEAN bTraceCycPcks : 1;					// [0] - Enables/disables CYC Packet (Cycle Count Packet - default is 0)
		BOOLEAN bTraceMtcPcks : 1;					// [1] - Enables/disables MTC Packet (Wall-clock time packets - default is 0)
		BOOLEAN bTraceTscPcks : 1;					// [2] - Enables/disables TSC Packet (Time Stamp packets - default is 0)
		BOOLEAN bTraceBranchPcks : 1;				// [3] - Enables/disables COFI-based packets: FUP, TIP, TIP.PGE, TIP.PGD, TNT, MODE.Exec, MODE.TSX.		(default is 1)
		BOOLEAN bUseTopa : 1;						// [4] - Enable/disable the usage of Table of Physical Address (if available, default is 1)
		BOOLEAN bEnableRetCompression : 1;			// [5] - Enables/disables RET compression (default is 1)
		BOOLEAN bInitialized : 1;					// [6] - Set to 1 if this structure is initialized
		BOOLEAN Reserved : 1;						// [7] - Reserved
		BYTE MTCFreq : 4;							// [8:11] - MTC packet Frequency, which is based on the core crystal clock, or Always Running Timer (ART)
		BYTE CycThresh : 4;							// [12:15] - CYC packet threshold. CYC packets will be sent with the first eligible packet after N cycles have passed since the last CYC packet
		BYTE PSBFreq : 4;							// [16:19] - The frequency of PSB packets. PSB packet frequency is based on the number of Intel PT packet bytes output
	} Fields;
	DWORD All;
};

// The descriptor of the Tracing buffer
typedef struct _PT_BUFFER_DESCRIPTOR {
	union {
		struct {
			LPVOID lpTraceBuffVa;					// + 0x00 - Kernel VA Pointer to a contiguous memory buffer
			ULONG_PTR lpTraceBuffPhysAddr;			// + 0x08 - The physical address of the contiguous memory buffer
		} Simple;
		struct {
			LPVOID lpTopaVa;						// + 0x00 - Kernel VA pointer to the ToPA
			ULONG_PTR lpTopaPhysAddr;				// + 0x08 - The Physical adress of the ToPA
		} ToPA;
	} u;
	BOOLEAN bUseTopa;								// + 0x10 - TRUE if this processor uses ToPa
	BOOLEAN bDefaultPmiSet;							// + 0x11 - TRUE if the default PMI is on
	BOOLEAN bBuffIsFull;							// + 0x12 - TRUE if the ToPa or Simple buffer is full
	QWORD qwBuffSize;								// + 0x18 - The physical buffer size
	PMDL pTraceMdl;									// + 0x20 - The MDL used for mapping pages
	LPVOID lpKernelVa;								// + 0x28 - The kernel-mode virtual address 
}PT_BUFFER_DESCRIPTOR, *PPT_BUFFER_DESCRIPTOR;

// The custom PMI ISR routines
typedef VOID(*INTELPT_PMI_HANDLER)(DWORD dwProcId, PT_BUFFER_DESCRIPTOR * ptBuffDesc);

// Check the Intel Processor Trace support on this processor
NTSTATUS IntelPtCheckCpuSupport(INTEL_PT_CAPABILITIES * lpPtCap);

// Pause/Resume the Trace
NTSTATUS IntelPtPauseResumeTrace(BOOLEAN bPause);

// Free and destroy a Trace buffer
NTSTATUS IntelPtFreeBuffer(PT_BUFFER_DESCRIPTOR * ptBuffDesc);
#endif // !INTEL_PT_HDRS

// Allocate the buffer needed for kernel tracing
NTSTATUS IntelPtAllocBuffer(PPT_BUFFER_DESCRIPTOR * pBuffDesc, QWORD qwSize, BOOLEAN bUseTopa, BOOLEAN bSetStdPmi = TRUE);

// Add a PMI interrupt for a page in the ToPA
NTSTATUS IntelPtAddBufferPmi(PT_BUFFER_DESCRIPTOR * pBuffDesc, QWORD qwOffset);

// Remove a PMI interrupt from a page in the ToPA
NTSTATUS IntelPtRemoveBufferPmi(PT_BUFFER_DESCRIPTOR * pBuffDesc, QWORD qwOffset);

// Start the Kernel tracing for current processor
NTSTATUS IntelPtStartTracing(PT_TRACE_DESC traceDesc, PT_BUFFER_DESCRIPTOR * pBuffDesc);

// Register a PMI handler for ALL processor
NTSTATUS IntelPtRegisterPmiHandler(INTELPT_PMI_HANDLER pCustomPmiHandler);

// Delete the previous registered Intel PT PMI handler routine
NTSTATUS IntelPtRemovePmiHandler(INTELPT_PMI_HANDLER pCustomPmiHandler);

// Set/Get the Trace options for current CPU
NTSTATUS IntelPtSetOptions(TRACE_OPTIONS opts);
TRACE_OPTIONS IntelPtGetOptions();

// Stop the Tracing 
VOID IntelPtStopTrace();

```

`WindowsPtDriver/PtTests.cpp`:

```cpp
/**********************************************************************
 *  Windows Intel Processor Trace (PT) Driver
 * 	Filename: PtTests.cpp
 *	Implements some tests and use cases, especially for kernel tracing
 *	Last revision: 01/06/2016
 *
 *  Copyright© 2016 Andrea Allievi, Richard Johnson 
 * 	Microsoft Ltd & TALOS Research and Intelligence Group
 *	All right reserved
 **********************************************************************/
#include "stdafx.h"
#include "IntelPt.h"
#include "UndocNt.h"
#include "KernelTracing.h"
#include "Ntstrsafe.h"

#ifdef _DEBUG
// Find a Kernel module in memory using documented method
NTSTATUS GetKernelModule(LPTSTR lpName, SYSTEM_MODULE_INFORMATION * pSysModuleDesc);

struct {
	PPT_BUFFER_DESCRIPTOR pBuffDesc;
	KEVENT workItemEvt;
	NTSTATUS workItmStatus;
	BOOLEAN bKernelExcRaised;
} g_testData = { 0 };

int DriverExcFilter(DWORD excCode, struct _EXCEPTION_POINTERS *ep, LPTSTR lpDrvFileName) {
	// Process here the exception and continue the execution if possible
	NTSTATUS ntStatus = 0;
	PT_TRACE_DESC ptDesc = { 0 };
	SYSTEM_MODULE_INFORMATION sysModInfo = { 0 };
	UNREFERENCED_PARAMETER(excCode);
	
	// Search the actual loaded module
	ntStatus = GetKernelModule(lpDrvFileName, &sysModInfo);
	if (!NT_SUCCESS(ntStatus))
		return EXCEPTION_EXECUTE_HANDLER;

	// Modify the guilty opcode in a NOP
	ULONG_PTR lpAddr = (ULONG_PTR)ep->ContextRecord->Rip;
	DWORD dwOffset = (DWORD)(lpAddr % PAGE_SIZE);
	PMDL pNewMdl = IoAllocateMdl((LPVOID)(lpAddr - dwOffset), PAGE_SIZE, NULL, FALSE, NULL);
	MmProbeAndLockPages(pNewMdl, KernelMode, IoWriteAccess);
	LPBYTE lpNewAddr = (LPBYTE)MmMapLockedPagesSpecifyCache(pNewMdl, KernelMode, MmNonCached, NULL, FALSE, NormalPagePriority);
	
	if (lpNewAddr[dwOffset+1] == 0x89)
		lpNewAddr[dwOffset] = 0x48;				// Put a MOV QWORD PTR opcode
	else
		lpNewAddr[dwOffset] = 0x90;				// Put a NOP opcode
	MmUnmapLockedPages(lpNewAddr, pNewMdl);
	IoFreeMdl(pNewMdl);

	// Enable here processor trace
	ptDesc.bTraceKernel = TRUE;
	ptDesc.dwNumOfRanges = 1;
	ptDesc.Ranges[0].lpStartVa = sysModInfo.Base;
	ptDesc.Ranges[0].lpEndVa = (LPVOID)((QWORD)sysModInfo.Base + sysModInfo.Size);
	ntStatus = IntelPtStartTracing(ptDesc, g_testData.pBuffDesc);
	g_testData.bKernelExcRaised = TRUE;

	return EXCEPTION_CONTINUE_EXECUTION;
}

// The Driver Trace Test work item (runs in System process context)
VOID KernelTraceWorkItem(PVOID Parameter) {
	// Get the parameters
	LPTSTR lpDrvFileName = *((LPTSTR*)Parameter);
	LPTSTR lpDumpFile = *((LPTSTR*)Parameter + 1);
	DWORD dwBuffSize = *((DWORD*)Parameter + 2);
	KIRQL kIrql = KeGetCurrentIrql();
	PEPROCESS pCurProc = IoGetCurrentProcess();
	NTSTATUS ntStatus = STATUS_SUCCESS;
	ASSERT(kIrql < DISPATCH_LEVEL && pCurProc == PsInitialSystemProcess);

	DWORD dwCurCpuId = KeGetCurrentProcessorNumber();
	KAFFINITY kAffinity = (KAFFINITY)(1i64 << dwCurCpuId);
	KeSetSystemAffinityThread(kAffinity);
	ntStatus = DoDriverTraceTest(lpDrvFileName, lpDumpFile, dwBuffSize);
	g_testData.workItmStatus = ntStatus;
	KeSetEvent(&g_testData.workItemEvt, IO_NO_INCREMENT, FALSE);
}


NTSTATUS DoDriverTraceTest(LPTSTR lpDrvFileName, LPTSTR lpDumpFile, DWORD dwBuffSize) {
	NTSTATUS ntStatus = 0;					// Returned NTSTATUS
	KIRQL kIrql = KeGetCurrentIrql();		// Current IRQL
	TCHAR lpDrvRegPath[0x200] = { 0 };		// The complete driver's service registry path
	LPTSTR lpDotPtr = NULL;
	DWORD dwStrLen = 0;						// String size in characters
	UNICODE_STRING drvRegString = { 0 };
	ASSERT(kIrql == PASSIVE_LEVEL);

	if (PsGetCurrentProcess() != PsInitialSystemProcess) {
		WORK_QUEUE_ITEM workItem = { 0 };
		KeInitializeEvent(&g_testData.workItemEvt, NotificationEvent, FALSE);
		ExInitializeWorkItem(&workItem, KernelTraceWorkItem, (LPVOID)&lpDrvFileName);
		ExQueueWorkItem(&workItem, DelayedWorkQueue);
		KeWaitForSingleObject((LPVOID)&g_testData.workItemEvt, Executive, KernelMode, FALSE, NULL);
		return g_testData.workItmStatus;

	}

	// Check the parameters:
	if (!dwBuffSize) dwBuffSize = 512 * 1024;
	if (!lpDumpFile || lpDumpFile[0] == 0) lpDumpFile = L"\\??\\c:\\pt_dump.bin";

	// Compose the full registry path
	RtlStringCchCopyW(lpDrvRegPath, COUNTOF(lpDrvRegPath), L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\");
	lpDotPtr = wcsrchr(lpDrvFileName, L'.');
	if (lpDotPtr) dwStrLen = (DWORD)(lpDotPtr - lpDrvFileName);
	else dwStrLen = (DWORD)wcslen(lpDrvFileName);
	RtlStringCchCatNW(lpDrvRegPath, COUNTOF(lpDrvRegPath), lpDrvFileName, dwStrLen);
	RtlInitUnicodeString(&drvRegString, lpDrvRegPath);

	// Allocate a buffer big enough for processor trace
	ntStatus = IntelPtAllocBuffer(&g_testData.pBuffDesc, dwBuffSize, TRUE, TRUE);
	if (!NT_SUCCESS(ntStatus)) return ntStatus;

	__try {
		ntStatus = ZwLoadDriver(&drvRegString);
	}
	__except (DriverExcFilter(GetExceptionCode(), GetExceptionInformation(), lpDrvFileName)) {
		// PASS
		ntStatus = STATUS_UNHANDLED_EXCEPTION;
	}

	// Check the exception:
	if (!g_testData.bKernelExcRaised) {
		// The exception handler has not run exception :-)
		ZwUnloadDriver(&drvRegString);
		ntStatus = STATUS_INVALID_EXCEPTION_HANDLER;
	}

	if (!NT_SUCCESS(ntStatus)) {
		FreePtBuffer(g_testData.pBuffDesc);
		g_testData.pBuffDesc = NULL;
		return ntStatus;
	}
	ntStatus = ZwUnloadDriver(&drvRegString);

	// Stop the PT Trace
	IntelPtStopTrace();
	// Dump the buffer
	g_testData.pBuffDesc->lpKernelVa = MmGetSystemAddressForMdlSafe(g_testData.pBuffDesc->pTraceMdl, NormalPagePriority);

	// Create a target file
	HANDLE hOutFile = NULL;
	OBJECT_ATTRIBUTES outFileOa = { 0 };
	UNICODE_STRING outFileName = { 0 };
	IO_STATUS_BLOCK ioSb = { 0 };
	LARGE_INTEGER fileOffset = { 0 };

	RtlInitUnicodeString(&outFileName, lpDumpFile);
	InitializeObjectAttributes(&outFileOa, &outFileName, OBJ_KERNEL_HANDLE, NULL, NULL);
	ntStatus = ZwCreateFile(&hOutFile, FILE_ALL_ACCESS, &outFileOa, &ioSb, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_SUPERSEDE, FILE_NON_DIRECTORY_FILE, NULL, 0);
	if (NT_SUCCESS(ntStatus)) {
		ntStatus = ZwWriteFile(hOutFile, NULL, NULL, NULL, &ioSb, g_testData.pBuffDesc->lpKernelVa, (DWORD)g_testData.pBuffDesc->qwBuffSize, &fileOffset, NULL);
		ZwClose(hOutFile);
	}

	FreePtBuffer(g_testData.pBuffDesc);
	g_testData.pBuffDesc = NULL;

	return STATUS_SUCCESS;
}
#endif

// Find a Kernel module in memory using documented method
NTSTATUS GetKernelModule(LPTSTR lpName, SYSTEM_MODULE_INFORMATION * pSysModuleDesc) {
	NTSTATUS ntStatus = 0;
	SYSTEM_ALL_MODULES * pAllModules = NULL;
	ULONG dwBuffSize = 0,
		dwRetLength = 0;
	KIRQL kIrql = KeGetCurrentIrql();	// Current IRQL
	ASSERT(kIrql == PASSIVE_LEVEL);

	ntStatus = ZwQuerySystemInformation(SystemModuleInformation, (PVOID)pAllModules, NULL, &dwBuffSize);
	if (ntStatus != STATUS_INFO_LENGTH_MISMATCH) return ntStatus;

	pAllModules = (SYSTEM_ALL_MODULES*)ExAllocatePoolWithTag(PagedPool, dwBuffSize, MEMTAG);
	RtlZeroMemory(pAllModules, dwBuffSize);
	ntStatus = ZwQuerySystemInformation(SystemModuleInformation, (PVOID)pAllModules, dwBuffSize, &dwRetLength);

	if (!NT_SUCCESS(ntStatus)) {
		ExFreePool(pAllModules);
		return ntStatus;
	}

	ntStatus = STATUS_NOT_FOUND;
	for (unsigned i = 0; i < pAllModules->dwNumOfModules; i++) {
		TCHAR lpCurModName[0x100] = { 0 };
		SYSTEM_MODULE_INFORMATION * pCurModule = &pAllModules->modules[i];

		RtlStringCchPrintfW(lpCurModName, COUNTOF(lpCurModName), L"%S", pCurModule->ImageName + pCurModule->ModuleNameOffset);
		if (_wcsicmp(lpCurModName, lpName) == 0) {
			// Found
			if (pSysModuleDesc != NULL)
				(*pSysModuleDesc) = (*pCurModule);
			ntStatus = STATUS_SUCCESS;
			break;
		}
	}

	ExFreePool(pAllModules);
	return ntStatus;
}

```

`WindowsPtDriver/UndocNt.h`:

```h
/**********************************************************************
 *  Windows Intel Processor Trace (PT) Driver
 *  Filename: UndocNt.h
 *  Defines the undocumented Windows Nt data structures
 *  Last revision: 01/06/2016
 *
 *  Copyright© 2016 Andrea Allievi, Richard Johnson
 *  Microsoft Ltd & TALOS Research and Intelligence Group
 *  All right reserved
 **********************************************************************/
#pragma once
#define ANYSIZE_ARRAY 1

typedef enum _SYSTEM_INFORMATION_CLASS {
	SystemBasicInformation, // 0 Y N
	SystemProcessorInformation, // 1 Y N
	SystemPerformanceInformation, // 2 Y N
	SystemTimeOfDayInformation, // 3 Y N
	SystemNotImplemented1, // 4 Y N
	SystemProcessesAndThreadsInformation, // 5 Y N
	SystemCallCounts, // 6 Y N
	SystemConfigurationInformation, // 7 Y N
	SystemProcessorTimes, // 8 Y N
	SystemGlobalFlag, // 9 Y Y
	SystemNotImplemented2, // 10 Y N
	SystemModuleInformation // 11 Y N
} SYSTEM_INFORMATION_CLASS;

// Undocumented NT functions
NTKERNELAPI BOOLEAN PsIsThreadTerminating(PETHREAD Thread);
NTKERNELAPI NTSTATUS PsLookupThreadByThreadId(HANDLE ThreadId, PETHREAD *Thread);
NTKERNELAPI NTSTATUS PsLookupProcessByProcessId(HANDLE ProcessId, PEPROCESS *Process);
NTKERNELAPI NTSTATUS PsSuspendProcess(PEPROCESS Process);
NTKERNELAPI NTSTATUS ZwCreateEvent(PHANDLE EventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, EVENT_TYPE EventType, BOOLEAN InitialState);
NTKERNELAPI BOOLEAN HalEnableInterrupt(PKINTERRUPT pkInterrupt);
NTKERNELAPI BOOLEAN PsGetProcessExitProcessCalled(PEPROCESS Process);
NTKERNELAPI NTSTATUS ZwSetSystemInformation(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength);
NTKERNELAPI NTSTATUS ZwQuerySystemInformation(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);


// APC Routines and data structures
typedef enum _KAPC_ENVIRONMENT {
	OriginalApcEnvironment,
	AttachedApcEnvironment,
	CurrentApcEnvironment,
	InsertApcEnvironment
} KAPC_ENVIRONMENT;

typedef struct _KAPC_STATE {
	LIST_ENTRY ApcListHead[MaximumMode];
	struct _KPROCESS *Process;
	union {
		UCHAR InProgressFlags;
		struct {
			BOOLEAN KernelApcInProgress : 1;
			BOOLEAN SpecialApcInProgress : 1;
		}u;
	};

	BOOLEAN KernelApcPending;
	BOOLEAN UserApcPending;
} KAPC_STATE, *PKAPC_STATE, *PRKAPC_STATE;

typedef VOID(*PKNORMAL_ROUTINE) (IN PVOID NormalContext, IN PVOID SystemArgument1, IN PVOID SystemArgument2);

typedef VOID(*PKKERNEL_ROUTINE) (IN struct _KAPC *Apc, IN OUT PKNORMAL_ROUTINE *NormalRoutine,
	IN OUT PVOID *NormalContext, IN OUT PVOID *SystemArgument1, IN OUT PVOID *SystemArgument2);

typedef VOID(*PKRUNDOWN_ROUTINE) (IN struct _KAPC *Apc);

NTKERNELAPI VOID KeInitializeApc(PRKAPC Apc, PRKTHREAD Thread, KAPC_ENVIRONMENT Environment, PKKERNEL_ROUTINE KernelRoutine, PKRUNDOWN_ROUTINE RundownRoutine,
	PKNORMAL_ROUTINE NormalRoutine, KPROCESSOR_MODE ApcMode, PVOID NormalContext);
NTKERNELAPI BOOLEAN KeInsertQueueApc(PRKAPC Apc, PVOID SystemArgument1, PVOID SystemArgument2, KPRIORITY Increment);



typedef struct _SYSTEM_MODULE_INFORMATION { // Information Class 11
	PVOID Reserved[2];						// + 0x00
	PVOID Base;								// + 0x10
	ULONG Size;								// + 0x18
	ULONG Flags;							// + 0x1C
	USHORT Index;							// + 0x20
	USHORT Unknown;							// + 0x22
	USHORT LoadCount;						// + 0x24
	USHORT ModuleNameOffset;				// + 0x26
	CHAR ImageName[256];					// + 0x28
} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;

struct SYSTEM_ALL_MODULES {
	DWORD dwNumOfModules;
	SYSTEM_MODULE_INFORMATION modules[ANYSIZE_ARRAY];
};
```

`WindowsPtDriver/WindowsIntelPtDriver.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winresrc.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""afxres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 0,5,0,1
 PRODUCTVERSION 0,5,0,1
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x0L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "000904b0"
        BEGIN
            VALUE "CompanyName", "MSTIC, Cisco TALOS"
            VALUE "FileDescription", "Intel PT Driver for Windows"
            VALUE "FileVersion", "0.5.0.1"
            VALUE "InternalName", "WindowsPtDriver"
            VALUE "LegalCopyright", "Copyright 2016 Andrea Allievi, Richard Johnson"
            VALUE "OriginalFilename", "WindowsPtDriver"
            VALUE "ProductName", "Intel PT Driver for Windows"
            VALUE "ProductVersion", "0.5.0.1"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x9, 1200
    END
END

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`WindowsPtDriver/WindowsIntelPtDriver.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{44253DD8-98B2-4229-8305-5DD1E272CDE3}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>11.0</MinimumVisualStudioVersion>
    <Configuration>Win8 Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
  </PropertyGroup>
  <PropertyGroup Label="Globals">
    <RootNamespace>TestDriver</RootNamespace>
    <VCTargetsPath Condition="'$(VCTargetsPath11)' != '' and '$(VisualStudioVersion)' == '11.0'">$(VCTargetsPath11)</VCTargetsPath>
    <ProjectName>WindowsPtDriver</ProjectName>
    <WindowsTargetPlatformVersion>10.0.14393.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <PropertyGroup Label="PropertySheets">
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <TargetVersion>
    </TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <TargetVersion>
    </TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <TargetVersion>
    </TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <TargetVersion>
    </TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <SupportsPackaging>false</SupportsPackaging>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <TimeStampServer>http://timestamp.verisign.com/scripts/timstamp.dll</TimeStampServer>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <PostBuildEventUseInBuild>true</PostBuildEventUseInBuild>
    <EnableInf2cat>false</EnableInf2cat>
    <Inf2CatWindowsVersionList>10_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Inf2CatWindowsVersionList>10_$(DDKPlatform)</Inf2CatWindowsVersionList>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <EnableInf2cat>false</EnableInf2cat>
    <Inf2CatWindowsVersionList>10_$(DDKPlatform)</Inf2CatWindowsVersionList>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Vista Debug|Win32'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <TreatWarningAsError>false</TreatWarningAsError>
      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
    </ClCompile>
    <Link>
      <ModuleDefinitionFile>Export.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Vista Release|Win32'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
    </ClCompile>
    <Link>
      <ModuleDefinitionFile>Export.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Vista Debug|x64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
      <WarningLevel>Level4</WarningLevel>
    </ClCompile>
    <PostBuildEvent>
      <Command>
      </Command>
    </PostBuildEvent>
    <Link>
      <ModuleDefinitionFile>Export.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Vista Release|x64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <DriverSign>
      <AdditionalOptions>
      </AdditionalOptions>
    </DriverSign>
    <Link>
      <AdditionalDependencies>%(AdditionalDependencies);$(KernelBufferOverflowLib);$(DDK_LIB_PATH)ntoskrnl.lib;$(DDK_LIB_PATH)hal.lib;$(DDK_LIB_PATH)wmilib.lib;$(DDK_LIB_PATH)wdmsec.lib</AdditionalDependencies>
      <ModuleDefinitionFile>Export.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
    <FilesToPackage Include="@(Inf->'%(CopyOutput)')" Condition="'@(Inf)'!=''" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Debug.cpp" />
    <ClCompile Include="DriverEntry.cpp" />
    <ClCompile Include="DriverIo.cpp" />
    <ClCompile Include="IntelPt.cpp" />
    <ClCompile Include="IntelPtXSave.cpp" />
    <ClCompile Include="KernelTracing.cpp" />
    <ClCompile Include="PtTests.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Debug.h" />
    <ClInclude Include="DriverEntry.h" />
    <ClInclude Include="DriverIo.h" />
    <ClInclude Include="IntelPt.h" />
    <ClInclude Include="IntelPtXSave.h" />
    <ClInclude Include="Intel_Defs.h" />
    <ClInclude Include="KernelTracing.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="UndocNt.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="WindowsIntelPtDriver.rc" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Export.def" />
    <None Include="readme.md">
      <SubType>Designer</SubType>
    </None>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="asm\Amd64XSave.asm">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</ExcludedFromBuild>
    </MASM>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`WindowsPtDriver/WindowsIntelPtDriver.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="Debug.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="DriverEntry.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="DriverIo.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IntelPt.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="KernelTracing.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="PtTests.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IntelPtXSave.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Debug.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="DriverEntry.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="DriverIo.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Intel_Defs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IntelPt.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="KernelTracing.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="UndocNt.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IntelPtXSave.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{0a59f678-349f-4b75-b196-ac6e6f051185}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{cc981622-83ff-4000-be86-2e79af42be21}</UniqueIdentifier>
    </Filter>
    <Filter Include="Resources">
      <UniqueIdentifier>{4b959927-b2e1-4594-8fff-e51a0d8bfc8a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Assembly Files">
      <UniqueIdentifier>{0d7a4089-f791-4f8d-b924-3adb4c817f29}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <None Include="readme.md" />
    <None Include="Export.def" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="WindowsIntelPtDriver.rc">
      <Filter>Resources</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="asm\Amd64XSave.asm">
      <Filter>Assembly Files</Filter>
    </MASM>
  </ItemGroup>
</Project>
```

`WindowsPtDriver/WindowsIntelPtDriver2015.sln`:

```sln
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 14
VisualStudioVersion = 14.0.25420.1
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "WindowsPtDriver", "WindowsIntelPtDriver.vcxproj", "{44253DD8-98B2-4229-8305-5DD1E272CDE3}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "PtControlApp", "..\PtControlApp\PtControlApp.vcxproj", "{AEEB84F9-A268-4642-8CCC-CE05D80ACD74}"
EndProject
Project("{888888A0-9F3D-457C-B088-3A5042F75D52}") = "IdaPt", "..\IdaPt\IdaPt.pyproj", "{0B4592C2-FAC6-429F-80F0-C57638C2D472}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "SimpleTestDriver", "..\SimpleTestDriver\SimpleTestDriver.vcxproj", "{A9D835FD-18CC-4CA8-B29B-48077C43C48B}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Debug|Win32 = Debug|Win32
		Debug|x64 = Debug|x64
		Release|Any CPU = Release|Any CPU
		Release|Win32 = Release|Win32
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{44253DD8-98B2-4229-8305-5DD1E272CDE3}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{44253DD8-98B2-4229-8305-5DD1E272CDE3}.Debug|Win32.ActiveCfg = Debug|Win32
		{44253DD8-98B2-4229-8305-5DD1E272CDE3}.Debug|Win32.Build.0 = Debug|Win32
		{44253DD8-98B2-4229-8305-5DD1E272CDE3}.Debug|x64.ActiveCfg = Debug|x64
		{44253DD8-98B2-4229-8305-5DD1E272CDE3}.Debug|x64.Build.0 = Debug|x64
		{44253DD8-98B2-4229-8305-5DD1E272CDE3}.Debug|x64.Deploy.0 = Debug|x64
		{44253DD8-98B2-4229-8305-5DD1E272CDE3}.Release|Any CPU.ActiveCfg = Release|Win32
		{44253DD8-98B2-4229-8305-5DD1E272CDE3}.Release|Win32.ActiveCfg = Release|Win32
		{44253DD8-98B2-4229-8305-5DD1E272CDE3}.Release|Win32.Build.0 = Release|Win32
		{44253DD8-98B2-4229-8305-5DD1E272CDE3}.Release|Win32.Deploy.0 = Release|Win32
		{44253DD8-98B2-4229-8305-5DD1E272CDE3}.Release|x64.ActiveCfg = Release|x64
		{44253DD8-98B2-4229-8305-5DD1E272CDE3}.Release|x64.Build.0 = Release|x64
		{AEEB84F9-A268-4642-8CCC-CE05D80ACD74}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{AEEB84F9-A268-4642-8CCC-CE05D80ACD74}.Debug|Win32.ActiveCfg = Debug|Win32
		{AEEB84F9-A268-4642-8CCC-CE05D80ACD74}.Debug|Win32.Build.0 = Debug|Win32
		{AEEB84F9-A268-4642-8CCC-CE05D80ACD74}.Debug|x64.ActiveCfg = Debug|x64
		{AEEB84F9-A268-4642-8CCC-CE05D80ACD74}.Debug|x64.Build.0 = Debug|x64
		{AEEB84F9-A268-4642-8CCC-CE05D80ACD74}.Release|Any CPU.ActiveCfg = Release|Win32
		{AEEB84F9-A268-4642-8CCC-CE05D80ACD74}.Release|Win32.ActiveCfg = Release|Win32
		{AEEB84F9-A268-4642-8CCC-CE05D80ACD74}.Release|Win32.Build.0 = Release|Win32
		{AEEB84F9-A268-4642-8CCC-CE05D80ACD74}.Release|x64.ActiveCfg = Release|x64
		{AEEB84F9-A268-4642-8CCC-CE05D80ACD74}.Release|x64.Build.0 = Release|x64
		{0B4592C2-FAC6-429F-80F0-C57638C2D472}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{0B4592C2-FAC6-429F-80F0-C57638C2D472}.Debug|Win32.ActiveCfg = Debug|Any CPU
		{0B4592C2-FAC6-429F-80F0-C57638C2D472}.Debug|x64.ActiveCfg = Debug|Any CPU
		{0B4592C2-FAC6-429F-80F0-C57638C2D472}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{0B4592C2-FAC6-429F-80F0-C57638C2D472}.Release|Win32.ActiveCfg = Release|Any CPU
		{0B4592C2-FAC6-429F-80F0-C57638C2D472}.Release|x64.ActiveCfg = Release|Any CPU
		{A9D835FD-18CC-4CA8-B29B-48077C43C48B}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{A9D835FD-18CC-4CA8-B29B-48077C43C48B}.Debug|Win32.ActiveCfg = Debug|Win32
		{A9D835FD-18CC-4CA8-B29B-48077C43C48B}.Debug|Win32.Build.0 = Debug|Win32
		{A9D835FD-18CC-4CA8-B29B-48077C43C48B}.Debug|Win32.Deploy.0 = Debug|Win32
		{A9D835FD-18CC-4CA8-B29B-48077C43C48B}.Debug|x64.ActiveCfg = Debug|x64
		{A9D835FD-18CC-4CA8-B29B-48077C43C48B}.Debug|x64.Build.0 = Debug|x64
		{A9D835FD-18CC-4CA8-B29B-48077C43C48B}.Debug|x64.Deploy.0 = Debug|x64
		{A9D835FD-18CC-4CA8-B29B-48077C43C48B}.Release|Any CPU.ActiveCfg = Release|Win32
		{A9D835FD-18CC-4CA8-B29B-48077C43C48B}.Release|Win32.ActiveCfg = Release|Win32
		{A9D835FD-18CC-4CA8-B29B-48077C43C48B}.Release|Win32.Build.0 = Release|Win32
		{A9D835FD-18CC-4CA8-B29B-48077C43C48B}.Release|Win32.Deploy.0 = Release|Win32
		{A9D835FD-18CC-4CA8-B29B-48077C43C48B}.Release|x64.ActiveCfg = Release|x64
		{A9D835FD-18CC-4CA8-B29B-48077C43C48B}.Release|x64.Build.0 = Release|x64
		{A9D835FD-18CC-4CA8-B29B-48077C43C48B}.Release|x64.Deploy.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`WindowsPtDriver/asm/Amd64XSave.asm`:

```asm
;   Windows Intel PT Driver
;   Filename: Amd64XSave.asm
;	Description: Implement the support for the Supervisor XSAVE routines
;	Last revision: 01/25/2017
TITLE Windows Pt Driver AMD64 Assembler File


;Declare an external function
;EXTERN ExternalCFunc: PROC

.data

.code
;void _xsaves(void *mem, unsigned __int64 save_mask);
_xsaves PROC
	mov r8, rcx
	mov ecx, edx
	shr rdx, 020h
	xsaves qword ptr [r8]
	ret
_xsaves ENDP


END
```

`WindowsPtDriver/hv.h`:

```h
/**********************************************************************
*  Windows Intel Processor Trace (PT) Driver
*  Filename: hv.h
*  Defines all the HyperV data structures and functions for Intercepts
*  https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/reference/tlfs
*  Last revision: xx/xx/2017
*
*  Copyright© 2017 Andrea Allievi, Richard Johnson
*  Microsoft Ltd and TALOS Research and Intelligence Group
*  All right reserved
**********************************************************************/

#pragma once

// Memory Types

typedef UINT64 HV_SPA, *PHV_SPA;
typedef UINT64 HV_GVA, *PHV_GVA;

#ifndef X64_PAGE_SIZE
#define X64_PAGE_SIZE 0x1000
#endif

typedef UINT64 HV_GPA_PAGE_NUMBER, *PHV_GPA_PAGE_NUMBER;
typedef UINT64 HV_GVA_PAGE_NUMBER, *PHV_GVA_PAGE_NUMBER;

typedef const HV_GPA_PAGE_NUMBER *PCHV_GPA_PAGE_NUMBER;
typedef const HV_GVA_PAGE_NUMBER *PCHV_GVA_PAGE_NUMBER;

// Some HyperV return codes
// https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/reference/tlfs
// Appendix B - Page 202
typedef unsigned short HV_STATUS;
#define HV_STATUS_SUCCESS                ((HV_STATUS)0x0000)
// The hypervisor does not support the operation because the specified hypercall code is not supported.
#define HV_STATUS_INVALID_HYPERCALL_CODE ((HV_STATUS)0x0002)
// The hypervisor does not support the operation because the encoding for the hypercall input register is not supported.
#define HV_STATUS_INVALID_HYPERCALL_INPUT ((HV_STATUS)0x0003)
// The hypervisor could not perform the operation because a parameter has an invalid alignment.
#define HV_STATUS_INVALID_ALIGNMENT      ((HV_STATUS)0x0004)
// The hypervisor could not perform the operation because an invalid parameter was specified.
#define HV_STATUS_INVALID_PARAMETER      ((HV_STATUS)0x0005)
// Access to the specified object was denied.
#define HV_STATUS_ACCESS_DENIED          ((HV_STATUS)0x0006)
// The hypervisor could not perform the operation because the partition is entering or in an invalid state.
#define HV_STATUS_INVALID_PARTITION_STATE ((HV_STATUS)0x0007)
// The operation is not allowed in the current state.
#define HV_STATUS_OPERATION_DENIED       ((HV_STATUS)0x0008)
// The requested operation was unsuccessful.
#define HV_STATUS_UNSUCCESSFUL           ((HV_STATUS)0x1001)


#pragma pack(push)
#pragma pack(1)

#define HV_X64_MSR_HYPERCALL 0x40000001
#define HvCallGetLogicalProcessorRegisters		0x0088

typedef enum _HV_LOGICAL_PROC_REGISTER_TYPE
{
	HvX64LpRegisterTypeCpuid = 0x00010000,
	HvX64LpRegisterTypeMsr = 0x00010001
} HV_LOGICAL_PROC_REGISTER_TYPE, *PHV_LOGICAL_PROC_REGISTER_TYPE;

typedef union _HV_LOGICAL_PROC_REGISTER_ADDRESS
{
	struct
	{
		UINT32 Eax;
		UINT32 Ecx;
	} CpuId;
	UINT32 MsrIndex;
} HV_LOGICAL_PROC_REGISTER_ADDRESS, *PHV_LOGICAL_PROC_REGISTER_ADDRESS;

// HvCallGetLogicalProcessorRegisters input - passed in RDX
typedef struct _HV_LOGICAL_PROC_REGISTERS_INPUT
{
	UINT32									VCpuIndex;
	HV_LOGICAL_PROC_REGISTER_TYPE			Type;
	HV_LOGICAL_PROC_REGISTER_ADDRESS		Address;
} HV_LOGICAL_PROC_REGISTERS_INPUT, *PHV_LOGICAL_PROC_REGISTERS_INPUT;

typedef struct _HYPERV_LIMITS {
	DWORD	MaxVpSupported;
	DWORD	MaxRealCpuSupported;
	DWORD	MAxInterruptsAvail;
} HYPERV_LIMITS, *PHYPERV_LIMITS;

// HyperV Partition privilege mask 
typedef struct _HV_PARTITION_PRIVILEGE_MASK {
	// Access to virtual MSRs 
	UINT64 AccessVpRunTimeReg : 1;
	UINT64 AccessPartitionReferenceCounter : 1;
	UINT64 AccessSynicRegs : 1;
	UINT64 AccessSyntheticTimerRegs : 1;
	UINT64 AccessIntrCtrlRegs : 1;
	UINT64 AccessHypercallMsrs : 1;
	UINT64 AccessVpIndex : 1;
	UINT64 AccessResetReg : 1;
	UINT64 AccessStatsReg : 1;
	UINT64 AccessPartitionReferenceTsc : 1;
	UINT64 AccessGuestIdleReg : 1;
	UINT64 AccessFrequencyRegs : 1;
	UINT64 AccessDebugRegs : 1;
	UINT64 Reserved1 : 19;
	
	// Access to hypercalls 
	UINT64 CreatePartitions : 1;
	UINT64 AccessPartitionId : 1;
	UINT64 AccessMemoryPool : 1;
	UINT64 AdjustMessageBuffers : 1;
	UINT64 PostMessages : 1;
	UINT64 SignalEvents : 1;
	UINT64 CreatePort : 1;
	UINT64 ConnectPort : 1;
	UINT64 AccessStats : 1;
	UINT64 Reserved2 : 2;
	UINT64 Debugging : 1;
	UINT64 CpuManagement : 1;
	UINT64 Reserved3 : 3;
	UINT64 AccessVSM : 1;
	UINT64 AccessVpRegisters : 1;
	UINT64 Reserved4 : 2;
	UINT64 EnableExtendedHypercalls : 1;
	UINT64 StartVirtualProcessor : 1;
	UINT64 Reserved5 : 10;
} HV_PARTITION_PRIVILEGE_MASK, *PHV_PARTITION_PRIVILEGE_MASK;

// HyperV Partition features (Chapter 2.4.4 of the TLFS)
typedef struct _HYPERV_FEATURES {
	HV_PARTITION_PRIVILEGE_MASK	 PartitionPrivilegeMask;
	UINT32 Reserved;
	union {
		struct {
			UINT32 MWaitSupport : 1; 					// [0] - Deprecated (previously indicated availability of the MWAIT command).
			UINT32 GuestDebugging : 1; 					// [1] - Guest debugging support is available
			UINT32 PmuSupport : 1; 						// [2] - Performance Monitor support is available
			UINT32 CpuDynamicPartitions : 1; 			// [3] - Support for physical CPU dynamic partitioning events is available
			UINT32 HypercallsViaXmm : 1; 				// [4] - Support for passing hypercall input parameter block via XMM registers is available
			UINT32 VirtualIdleState : 1; 				// [5] - Support for a virtual guest idle state is available
			UINT32 HvSleepState : 1; 					// [6] - Support for hypervisor sleep state is available.
			UINT32 QueryNumaDistance : 1; 				// [7] - Support for querying NUMA distances is available.
			UINT32 TimerFrequencies : 1; 				// [8] - Support for determining timer frequencies is available.
			UINT32 InjectSyntMachineChecks : 1; 		// [9] - Support for injecting synthetic machine checks is available.
			UINT32 GuestCrashMSRs : 1; 					// [10] - Support for guest crash MSRs is available.
			UINT32 DebugMSRs : 1; 						// [11] - Support for debug MSRs is available.
			UINT32 NpiepSupport : 1; 					// [12] - Support for NPIEP is available.
			UINT32 DisableHypervisor : 1; 				// [13] - DisableHypervisorAvailable
			UINT32 ExtendedGvaRangesForFlushVirtualAddressList : 1; 		// [14] - ExtendedGvaRangesForFlushVirtualAddressListAvailable
			UINT32 HypercallsOutputViaXmm : 1; 			// [15] - Support for returning hypercall output via XMM registers is available.
			UINT32 Reserved1 : 1; 						// [16] - Reserved
			UINT32 SintPollingMode : 1; 				// [17] - SintPollingModeAvailable
			UINT32 HypercallMsrLock : 1; 				// [18] - HypercallMsrLockAvailable
			UINT32 UseDirectSyntTimers : 1; 			// [19] - Use direct synthetic timers
			UINT32 Reserved2 : 12; 						// [31:20] - Reserved
		} Fields;
		UINT32 AsUInt32;
	} HvFeatures;
} HYPERV_FEATURES, *PHYPERV_FEATURES;

typedef struct _HYPERV_INFO {
	DWORD				Build;
	WORD				MajorVersion;
	WORD				MinorVersion;
	DWORD				ServicePack;
	UCHAR				ServiceBranch;
	DWORD				ServiceNumber;
	HYPERV_FEATURES		Features;
	//HYPERV_IMPLEMENTATION			Implementations;
	//HYPERV_LIMITS					Limits;
	//HYPERV_HARDWARE_FEATURES		HardwareFeatures;
	//HYPERV_CPU_MANAGEMENT			CpuManagementFeatures;
	//HYPERV_NESTED_HV_FEATURES		NestedHvFeatures;
	//HYPERV_NESTED_VIRT_FEATURES	NestedVirtFeatures;
} HYPERV_INFO, *PHYPERV_INFO;

// The Hypercall Input Value (RCX, first param, see page 21 of the TLFS) 
typedef union _HV_HYPERCALL_INFO
{
	// See the Specs: https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/reference/tlfs (page 29)
	struct
	{
		UINT32 CallCode : 16;				// [15:0] HyperCall code
		UINT32 IsFast : 1;					// [16]  Set to 1 if the hypercall uses the register-based calling convention
		UINT32 VarHdr : 9;					// [25:17]  Variable header size
		UINT32 Reserved1 : 5;				// [30:26]	Reserved
		UINT32 IsNested : 1;				// [31]	 This hypercall is nested, comes from the L0 Hypervisor
		UINT32 CountOfElements : 12;		// [43:31]  REP Counter
		UINT32 Reserved2 : 4;				// [47:44]
		UINT32 RepStartIndex : 12;			// [59:48]  Indicates the particular repetition relative to the start of the list
		UINT32 Reserved3 : 4;				// [63:60]
	} Fields;
	UINT64 AsUINT64;
} HV_HYPERCALL_INFO, *PHV_HYPERCALL_INFO;

// The Hypercall Result Value (RAX, page 32)
typedef union _HV_HYPERCALL_OUTPUT
{
	struct
	{
		UINT16 Result;					// [15:0]  The Hypercall results
		UINT16 Reserved1;				// [31:15]
		UINT32 RepsCompleted : 12;		// [43:32]  Number of reps successfully completed
		UINT32 Reserved2 : 20;			// [63:44]
	} Fields;
	UINT64 AsUINT64;
} HV_HYPERCALL_OUTPUT, *PHV_HYPERCALL_OUTPUT;

union HV_X64_MSR_HYPERCALL_DESC {
	struct {
		UINT64		EnableHypercallPage : 1;	// [0] - Enables the hypercall page
		UINT64		Locked : 1;					// [1] - Indicates if this MSR is immutable
		UINT64		Reserved : 10;				// [11:2]
		UINT64		HypercallGPA : 52;			// [63:12] - ndicates the Guest Physical Page Number of the hypercall page
	} Fields;
	UINT64 AsUINT64;
};
#pragma pack(pop)

// The Hypervisor Memory descriptor
typedef struct _HV_MEMDESC {
	LPVOID VirtualAddr;
	PHYSICAL_ADDRESS PhysicalAddr;
	DWORD Size;
} HV_MEMDESC, *PHV_MEMDESC;

typedef HV_HYPERCALL_OUTPUT(*PHV_PERFORM_HYPERCALL)(HV_HYPERCALL_INFO HvCallInfo, PHYSICAL_ADDRESS Argument1_Phys, PHYSICAL_ADDRESS Argument2_Phys);

typedef struct _HYPERV_DATA {
	BOOLEAN IsValid;
	HYPERV_INFO Info;
	// TODO: Move the following 3 buffer descriptor to a Per CPU data structure
	HV_MEMDESC InputPage;
	HV_MEMDESC OutputPage;
	HV_MEMDESC HypercallPage;
	PHV_PERFORM_HYPERCALL CallHv;
} HYPERV_DATA, *PHYPERV_DATA;


// Detect the Hypervisor
NTSTATUS DetectMicrosoftHyperV(HYPERV_INFO * HyperVInfo);

// Emit an HyperV real CPUINFO
NTSTATUS HvCpuId(int CpuInfo[4], int Function, int SubLeaf);

// Initialize HyperV data structures and memory
NTSTATUS InitGlobalHv();

// Destroy the HyperV data structures and memory
VOID DestroyGlobalHv();

// Convert a HV_STATUS value to the corresponding NTSTATUS
NTSTATUS HvStatusToNtStatus(HV_STATUS HvStatus);
```

`WindowsPtDriver/hv_intercepts.h`:

```h
/**********************************************************************
*  Windows Intel Processor Trace (PT) Driver
*  Filename: hv_intercepts.h
*  Defines all the HyperV data structures and functions for Intercepts
*  Last revision: xx/xx/2017
*
*  Copyright© 2017 Andrea Allievi, Richard Johnson
*  Microsoft Ltd and TALOS Research and Intelligence Group
*  All right reserved
**********************************************************************/

#pragma once

// Define partition identifier type.
typedef UINT64 HV_PARTITION_ID, *PHV_PARTITION_ID;

// Define port type.
typedef enum _HV_PORT_TYPE
{
	HvPortTypeMessage = 1,
	HvPortTypeEvent = 2,
	HvPortTypeMonitor = 3
} HV_PORT_TYPE, *PHV_PORT_TYPE;

// Define the intercept access types.
typedef UINT8 HV_INTERCEPT_ACCESS_TYPE;

#define HV_INTERCEPT_ACCESS_READ    0
#define HV_INTERCEPT_ACCESS_WRITE   1
#define HV_INTERCEPT_ACCESS_EXECUTE 2

typedef UINT32 HV_INTERCEPT_ACCESS_TYPE_MASK;

#define HV_INTERCEPT_ACCESS_MASK_NONE       0x00
#define HV_INTERCEPT_ACCESS_MASK_READ       0X01
#define HV_INTERCEPT_ACCESS_MASK_WRITE      0x02
#define HV_INTERCEPT_ACCESS_MASK_EXECUTE    0x04

#define HV_CALL_ATTRIBUTES DECLSPEC_ALIGN(8)

// Define intercept types.
typedef enum _HV_INTERCEPT_TYPE
{
	HvInterceptTypeX64IoPort = 0x00000000,
	HvInterceptTypeX64Msr = 0x00000001,
	HvInterceptTypeX64Cpuid = 0x00000002,
	HvInterceptTypeException = 0x00000003,
	HvInterceptTypeRegister = 0x00000004,
} HV_INTERCEPT_TYPE, *PHV_INTERCEPT_TYPE;
typedef UINT16 HV_X64_IO_PORT, *PHV_X64_IO_PORT;

// Define intercept parameters.
typedef union _HV_INTERCEPT_PARAMETERS
{
	UINT64 AsUINT64;
	// HvInterceptTypeX64IoPort.
	HV_X64_IO_PORT IoPort;
	// HvInterceptTypeX64Cpuid.
	UINT32 CpuidIndex;
	// HvInterceptTypeException.
	UINT16 ExceptionVector;
	// Other intercept paramaters.....
} HV_INTERCEPT_PARAMETERS, *PHV_INTERCEPT_PARAMETERS;
// Define intercept descriptor structure.
typedef struct  _HV_INTERCEPT_DESCRIPTOR
{
	HV_INTERCEPT_TYPE Type;
	HV_INTERCEPT_PARAMETERS Parameters;
} HV_INTERCEPT_DESCRIPTOR, *PHV_INTERCEPT_DESCRIPTOR;
typedef const HV_INTERCEPT_DESCRIPTOR *PCHV_INTERCEPT_DESCRIPTOR;

// Definition of the HvCallRegisterInterceptResult hypercall input structure.
typedef struct HV_CALL_ATTRIBUTES _HV_REGISTER_X64_CPUID_RESULT_PARAMETERS
{
	struct
	{
		UINT32 Eax;
		UINT32 Ecx;
		BOOLEAN SubleafSpecific;
		BOOLEAN AlwaysOverride;
	} Input;

	struct
	{
		UINT32 Eax;
		UINT32 EaxMask;
		UINT32 Ebx;
		UINT32 EbxMask;
		UINT32 Ecx;
		UINT32 EcxMask;
		UINT32 Edx;
		UINT32 EdxMask;
	} Result;
} HV_REGISTER_X64_CPUID_RESULT_PARAMETERS, *PHV_REGISTER_X64_CPUID_RESULT_PARAMETERS;

// Definition of the HvCallUnregisterInterceptResult hypercall input structure.
typedef struct HV_CALL_ATTRIBUTES _HV_UNREGISTER_X64_CPUID_RESULT_PARAMETERS
{
	UINT32 Eax;
	UINT32 Ecx;
	BOOLEAN SubleafSpecific;
} HV_UNREGISTER_X64_CPUID_RESULT_PARAMETERS, *PHV_UNREGISTER_X64_CPUID_RESULT_PARAMETERS;

#define HV_UNREGISTER_X64_CPUID_RESULT_PARAMETERS HV_UNREGISTER_X64_CPUID_RESULT_PARAMETERS
#define PHV_UNREGISTER_X64_CPUID_RESULT_PARAMETERS PHV_UNREGISTER_X64_CPUID_RESULT_PARAMETERS

typedef union HV_CALL_ATTRIBUTES _HV_REGISTER_INTERCEPT_RESULT_PARAMETERS
{
	HV_REGISTER_X64_CPUID_RESULT_PARAMETERS Cpuid;
} HV_REGISTER_INTERCEPT_RESULT_PARAMETERS, *PHV_REGISTER_INTERCEPT_RESULT_PARAMETERS;

typedef union HV_CALL_ATTRIBUTES _HV_UNREGISTER_INTERCEPT_RESULT_PARAMETERS
{
	HV_UNREGISTER_X64_CPUID_RESULT_PARAMETERS Cpuid;
} HV_UNREGISTER_INTERCEPT_RESULT_PARAMETERS, *PHV_UNREGISTER_INTERCEPT_RESULT_PARAMETERS;


#define WINHVAPI

extern "C" {
	WINHVAPI KIRQL NTAPI WinHvQueryInterceptIrql(VOID);

	// Interception Interfaces
	NTSTATUS NTAPI WinHvInstallIntercept(HV_PARTITION_ID PartitionId, HV_INTERCEPT_ACCESS_TYPE_MASK AccessType, PCHV_INTERCEPT_DESCRIPTOR Descriptor);
	NTSTATUS NTAPI WinHvRegisterInterceptResult(HV_PARTITION_ID PartitionId, HV_INTERCEPT_TYPE InterceptType, const PHV_REGISTER_INTERCEPT_RESULT_PARAMETERS Parameters);
	NTSTATUS NTAPI WinHvUnregisterInterceptResult(HV_PARTITION_ID PartitionId, HV_INTERCEPT_TYPE InterceptType, const PHV_UNREGISTER_INTERCEPT_RESULT_PARAMETERS Parameters);
	//NTSTATUS NTAPI WinHvCheckForIoIntercept(HV_PARTITION_ID PartitionId, HV_VP_INDEX VpIndex, HV_INPUT_VTL TargetVtl, HV_IO_PORT Port, UINT8 Size, BOOLEAN IsWrite, PBOOLEAN Intercept);
}
```

`WindowsPtDriver/lib/How_To_Generate_Libs.txt`:

```txt
These files have been generated with the following commands:

1. List all the Exports
   dumpbin /exports winhv.sys > winhv_exports.txt
   dumpbin /exports winhvr.sys > winhvr_exports.txt

2. Copy all the names (and optionally the ordinals) in a DEF file like the following:
   LIBRARY WinHv
   EXPORTS
   DllInitialize @1
   DllUnload @2                          
   DriverEntry @3                       
   WinHvAcceptGpaPages @4
   <List of Exported Entry Points>

3. Generate the LIB files
   lib /def:winhv_exports.def /out:winhv.lib

Simple, isn't it?

Last revision: 04/15/2018
by AaLl86

```

`WindowsPtDriver/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by WindowsIntelPtDriver.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`WindowsPtDriver/rules/masm64.rules`:

```rules
<?xml version="1.0" encoding="utf-8"?>
<VisualStudioToolFile
	Name="Microsoft Macro Assembler 64"
	Version="8,00"
	>
	<Rules>
		<CustomBuildRule
			Name="MASM64"
			DisplayName="Microsoft Macro Assembler 64"
			CommandLine="ml64.exe /c [AllOptions] [AdditionalOptions] /Ta[inputs]"
			Outputs="[$ObjectFileName]"
			FileExtensions="*.asm"
			ExecutionDescription="Assembling..."
			>
			<Properties>
				<BooleanProperty
					Name="NoLogo"
					DisplayName="Suppress Startup Banner"
					Description="Suppress the display of the startup banner and information messages.     (/nologo)"
					HelpURL="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
					Switch="/nologo"
					DefaultValue="true"
				/>
				<BooleanProperty
					Name="TinyMemoryModelSupport"
					DisplayName="Tiny Memory Model Support"
					PropertyPageName="Advanced"
					Description="Enables tiny-memory-model support. Note that this is not equivalent to the .MODEL TINY directive.     (/AT)"
					HelpURL="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
					Switch="/AT"
				/>
				<StringProperty
					Name="ObjectFileName"
					DisplayName="Object File Name"
					PropertyPageName="Object File"
					Description="Specifies the name of the output object file.     (/Fo:[file])"
					HelpURL="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
					Switch="/Fo&quot;[value]&quot;"
					DefaultValue="$(IntDir)\$(InputName).obj"
				/>
				<EnumProperty
					Name="PreserveIdentifierCase"
					DisplayName="Preserve Identifier Case"
					Description="Specifies preservation of case of user identifiers.     (/Cp, /Cu, /Cx)"
					HelpURL="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
					>
					<Values>
						<EnumValue
							Value="0"
							DisplayName="Default"
						/>
						<EnumValue
							Value="1"
							Switch="/Cp"
							DisplayName="Preserves Identifier Case (/Cp)"
						/>
						<EnumValue
							Value="2"
							Switch="/Cu"
							DisplayName="Maps all identifiers to upper case. (/Cu)"
						/>
						<EnumValue
							Value="3"
							Switch="/Cx"
							DisplayName="Preserves case in public and extern symbols. (/Cx)"
						/>
					</Values>
				</EnumProperty>
				<StringProperty
					Name="PreprocessorDefinitions"
					DisplayName="Preprocessor Definitions"
					Description="Defines a text macro with the given name.     (/D[symbol])"
					HelpURL="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
					Switch="/D&quot;[value]&quot;"
					Delimited="true"
					Inheritable="true"
				/>
				<BooleanProperty
					Name="GeneratePreprocessedSourceListing"
					DisplayName="Generate Preprocessed Source Listing"
					PropertyPageName="Listing File"
					Description="Generates a preprocessed source listing to the Output Window.     (/EP)"
					HelpURL="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
					Switch="/EP"
				/>
				<StringProperty
					Name="AssembledCodeListingFile"
					DisplayName="Assembled Code Listing File"
					PropertyPageName="Listing File"
					Description="Generates an assembled code listing file.     (/Fl[file])"
					HelpURL="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
					Switch="/Fl&quot;[value]&quot;"
				/>
				<StringProperty
					Name="SourceListingLineWidth"
					DisplayName="Source Listing Line Width"
					PropertyPageName="Listing File"
					Description="Sets the line width of source listing in characters per line. Range is 60 to 255. Same as PAGE width.     (/Sl [width])"
					HelpURL="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
					Switch="/Sl [value]"
				/>
				<StringProperty
					Name="SourceListingPageLength"
					DisplayName="Source Listing Page Length"
					PropertyPageName="Listing File"
					Description="Sets the page length of source listing in lines per page. Range is 10 to 255. Same as PAGE length.     (/Sp [length])"
					HelpURL="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
					Switch="/Sp [value]"
				/>
				<StringProperty
					Name="IncludePaths"
					DisplayName="Include Paths"
					Description="Sets path for include file. A maximum of 10 /I options is allowed.     (/I [path])"
					HelpURL="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
					Switch="/I &quot;[value]&quot;"
					Delimited="true"
					Inheritable="true"
				/>
				<BooleanProperty
					Name="ListAllAvailableInformation"
					DisplayName="List All Available Information"
					PropertyPageName="Listing File"
					Description="Turns on listing of all available information.     (/Sa)"
					HelpURL="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
					Switch="/Sa"
				/>
				<BooleanProperty
					Name="UseSafeExceptionHandlers"
					DisplayName="Use Safe Exception Handlers"
					PropertyPageName="Advanced"
					Description="Marks the object as either containing no exception handlers or containing exception handlers that are all declared with .SAFESEH.     (/safeseh)"
					HelpURL="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
					Switch="/safeseh"
				/>
				<BooleanProperty
					Name="AddFirstPassListing"
					DisplayName="Add First Pass Listing"
					PropertyPageName="Listing File"
					Description="Adds first-pass listing to listing file.     (/Sf)"
					HelpURL="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
					Switch="/Sf"
				/>
				<BooleanProperty
					Name="EnableAssemblyGeneratedCodeListing"
					DisplayName="Enable Assembly Generated Code Listing"
					PropertyPageName="Listing File"
					Description="Turns on listing of assembly-generated code.     (/Sg)"
					HelpURL="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
					Switch="/Sg"
				/>
				<BooleanProperty
					Name="DisableSymbolTable"
					DisplayName="Disable Symbol Table"
					PropertyPageName="Listing File"
					Description="Turns off symbol table when producing a listing.     (/Sn)"
					HelpURL="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
					Switch="/Sn"
				/>
				<StringProperty
					Name="SourceListingSubTitle"
					DisplayName="Source Listing Subtitle"
					PropertyPageName="Listing File"
					Description="Specifies subtitle text for source listing. Same as SUBTITLE text.     (/Ss [subtitle])"
					HelpURL="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
					Switch="/Ss [value]"
				/>
				<StringProperty
					Name="SourceListingTitle"
					DisplayName="Source Listing Title"
					PropertyPageName="Listing File"
					Description="Specifies title for source listing. Same as TITLE text.     (/St [title])"
					HelpURL="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
					Switch="/St [value]"
				/>
				<BooleanProperty
					Name="EnableFalseConditionalsInListing"
					DisplayName="Enable False Conditionals In Listing"
					PropertyPageName="Listing File"
					Description="Turns on false conditionals in listing.     (/Sx)"
					HelpURL="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
					Switch="/Sx"
				/>
				<EnumProperty
					Name="WarningLevel"
					DisplayName="Warning Level"
					Description="Sets the warning level, where level = 0, 1, 2, or 3.    (/W0, /W1, /W2, /W3)"
					HelpURL="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
					DefaultValue="3"
					>
					<Values>
						<EnumValue
							Value="0"
							Switch="/W0"
							DisplayName="Warning Level 0 (/W0)"
						/>
						<EnumValue
							Value="1"
							Switch="/W1"
							DisplayName="Warning Level 1 (/W1)"
						/>
						<EnumValue
							Value="2"
							Switch="/W2"
							DisplayName="Warning Level 2 (/W2)"
						/>
						<EnumValue
							Value="3"
							Switch="/W3"
							DisplayName="Warning Level 3 (/W3)"
						/>
					</Values>
				</EnumProperty>
				<BooleanProperty
					Name="TreatWarningsAsErrors"
					DisplayName="Treat Warnings As Errors"
					Description="Returns an error code if warnings are generated.     (/WX)"
					HelpURL="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
					Switch="/WX"
				/>
				<BooleanProperty
					Name="MakeAllSymbolsPublic"
					DisplayName="Make All Symbols Public"
					PropertyPageName="Object File"
					Description="Makes all symbols public.     (/Zf)"
					HelpURL="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
					Switch="/Zf"
				/>
				<BooleanProperty
					Name="GenerateDebugInformation"
					DisplayName="Generate Debug Information"
					Description="Generates Debug Information.     (/Zi)"
					HelpURL="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
					Switch="/Zi"
					DefaultValue="true"
				/>
				<BooleanProperty
					Name="EnableMASM51Compatibility"
					DisplayName="Enable MASM 5.1 Compatibility"
					Description="Enables M510 option for maximum compatibility with MASM 5.1.     (/Zm)"
					HelpURL="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
					Switch="/Zm"
				/>
				<EnumProperty
					Name="PackAlignmentBoundary"
					DisplayName="Pack Alignment Boundary"
					PropertyPageName="Advanced"
					Description="Packs structures on the specified byte boundary. The alignment can be 1, 2, 4, 8 or 16.     (/Zp1, /Zp2, /Zp4, /Zp8, /Zp16)"
					HelpURL="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
					>
					<Values>
						<EnumValue
							Value="0"
							DisplayName="Default"
						/>
						<EnumValue
							Value="1"
							Switch="/Zp1"
							DisplayName="One Byte Boundary (/Zp1)"
						/>
						<EnumValue
							Value="2"
							Switch="/Zp2"
							DisplayName="Two Byte Boundary (/Zp2)"
						/>
						<EnumValue
							Value="3"
							Switch="/Zp4"
							DisplayName="Four Byte Boundary (/Zp4)"
						/>
						<EnumValue
							Value="4"
							Switch="/Zp8"
							DisplayName="Eight Byte Boundary (/Zp8)"
						/>
						<EnumValue
							Value="5"
							Switch="/Zp16"
							DisplayName="Sixteen Byte Boundary (/Zp16)"
						/>
					</Values>
				</EnumProperty>
				<BooleanProperty
					Name="PerformSyntaxCheckOnly"
					DisplayName="Perform Syntax Check Only"
					Description="Performs a syntax check only.     (/Zs)"
					HelpURL="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
					Switch="/Zs"
				/>
				<EnumProperty
					Name="CallingConvention"
					DisplayName="Calling Convention"
					PropertyPageName="Advanced"
					Description="Selects calling convention for your application.     (/Gc, /Gd. /Gz)"
					HelpURL="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
					>
					<Values>
						<EnumValue
							Value="0"
							DisplayName="Default"
						/>
						<EnumValue
							Value="1"
							Switch="/Gd"
							DisplayName="Use C-style Calling Convention (/Gd)"
						/>
						<EnumValue
							Value="2"
							Switch="/Gz"
							DisplayName="Use stdcall Calling Convention (/Gz)"
						/>
						<EnumValue
							Value="3"
							Switch="/Gc"
							DisplayName="Use Pascal Calling Convention (/Gc)"
						/>
					</Values>
				</EnumProperty>
				<EnumProperty
					Name="ErrorReporting"
					DisplayName="Error Reporting"
					PropertyPageName="Advanced"
					Description="Reports internal assembler errors to Microsoft.     (/errorReport:[method])"
					HelpURL="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
					>
					<Values>
						<EnumValue
							Value="0"
							Switch="/errorReport:prompt"
							DisplayName="Prompt to send report immediately (/errorReport:prompt)"
						/>
						<EnumValue
							Value="1"
							Switch="/errorReport:queue"
							DisplayName="Prompt to send report at the next logon (/errorReport:queue)"
						/>
						<EnumValue
							Value="2"
							Switch="/errorReport:send"
							DisplayName="Automatically send report (/errorReport:send)"
						/>
						<EnumValue
							Value="3"
							Switch="/errorReport:none"
							DisplayName="Do not send report (/errorReport:none)"
						/>
					</Values>
				</EnumProperty>
				<StringProperty
					Name="BrowseFile"
					DisplayName="Generate Browse Information File"
					PropertyPageName="Advanced"
					Description="Specifies whether to generate browse information file and its optional name or location of the browse information file.     (/FR[name])"
					HelpURL="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
					Switch="/FR&quot;[value]&quot;"
					Delimited="true"
					Inheritable="true"
				/>
			</Properties>
		</CustomBuildRule>
	</Rules>
</VisualStudioToolFile>

```

`WindowsPtDriver/stdafx.h`:

```h
/**********************************************************************
 *  Windows Intel Processor Trace (PT) Driver 0.4
 *  Filename: stdafx.h
 *	Implement Driver Standard definitions
 *  Last revision: 01/06/2016
 *
 *  Copyright© 2016 Andrea Allievi, Richard Johnson
 *  TALOS Research and Intelligence Group and Microsoft Ltd
 *  All right reserved
 **********************************************************************/
#pragma once
#include <ntddk.h>
#include <wdmsec.h>

// My driver name
#define DRV_NAME "WindowsPtDriver"
#define ENABLE_EXPERIMENTAL_XSAVE				1				// Enable the experimental XSAVE support

// Common data types
typedef unsigned char BYTE, *LPBYTE, *PBYTE;
typedef unsigned long DWORD, UINT, *LPDWORD, *PDWORD;
typedef unsigned __int64 QWORD, *LPQWORD, *PQWORD;
typedef unsigned short WORD, *LPWORD, *PWORD;
typedef int BOOL, *PBOOL;
typedef unsigned char BOOLEAN, *PBOOLEAN, *LPBOOLEAN;
typedef void * LPVOID;

// Default Memory Tag
#define MEMTAG (ULONG)'rDtP'

// Definizione per far sentire il compilatore contento
#pragma warning(disable: 4005)
#define DECLSPEC_IMPORT extern "C" __declspec(dllimport)
#define DDKBUILD extern "C"
#define EXTERN_C extern "C"
#pragma warning(default: 4005)

#pragma warning (disable : 4302)			// HANDLE to DWORD truncation
#pragma warning (disable : 4311)			// HANDLE to DWORD truncation

#define COUNTOF(x) sizeof(x) / sizeof(x[0])

// 
// The following type of breakpoint will disappear in RELEASE version
//
#ifdef _DEBUG
#define DBG_BREAK() if ((*KdDebuggerNotPresent) == FALSE) { __debugbreak(); }
#else
#define DBG_BREAK() __noop()
#endif


```