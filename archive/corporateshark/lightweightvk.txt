Project Path: arc_corporateshark_lightweightvk_lok8ov9d

Source Tree:

```txt
arc_corporateshark_lightweightvk_lok8ov9d
├── AGENTS.md
├── CLAUDE.md
├── CMakeLists.txt
├── LICENSE.md
├── README.md
├── android
│   ├── app
│   │   ├── AndroidManifest.xml.in
│   │   ├── MainActivity.java.in
│   │   ├── build.gradle.in
│   │   └── data_extraction_rules.xml.in
│   ├── build.gradle
│   ├── gradle
│   │   └── wrapper
│   │       ├── gradle-wrapper.jar
│   │       └── gradle-wrapper.properties
│   ├── gradle.properties
│   ├── gradlew
│   ├── gradlew.bat
│   └── settings.gradle.in
├── build
│   └── .gitignore
├── cmake
│   └── CommonMacros.txt
├── deploy_content.py
├── deploy_content_android.py
├── deploy_deps.py
├── lvk
│   ├── CMakeLists.txt
│   ├── HelpersImGui.cpp
│   ├── HelpersImGui.h
│   ├── LVK.cpp
│   ├── LVK.h
│   ├── LVK.mm
│   ├── Pool.h
│   └── vulkan
│       ├── CMakeLists.txt
│       ├── VulkanClasses.cpp
│       ├── VulkanClasses.h
│       ├── VulkanUtils.cpp
│       └── VulkanUtils.h
├── samples
│   ├── 001_HelloTriangle.cpp
│   ├── 002_RenderToCubeMap.cpp
│   ├── 003_RenderToCubeMapSinglePass.cpp
│   ├── 004_YUV.cpp
│   ├── 005_MeshShaders.cpp
│   ├── 006_SwapchainHDR.cpp
│   ├── 007_DynamicRenderingLocalRead.cpp
│   ├── 008_MeshShaderFireworks.cpp
│   ├── 009_TriplanarMapping.cpp
│   ├── 010_OmniShadows.cpp
│   ├── Bistro.h
│   ├── CMakeLists.txt
│   ├── DEMO_001_SolarSystem.cpp
│   ├── DEMO_002_Bistro.cpp
│   ├── README.md
│   ├── RTX_001_Hello.cpp
│   ├── RTX_002_AO.cpp
│   ├── RTX_003_Pipeline.cpp
│   ├── RTX_004_Textures.cpp
│   ├── Tiny_MeshLarge.cpp
│   ├── VulkanApp.cpp
│   └── VulkanApp.h
└── third-party
    ├── bootstrap-content.json
    ├── bootstrap-deps.json
    └── bootstrap.py

```

`AGENTS.md`:

```md
# Repository Guidelines

## Project Structure & Modules
- `lvk/`: Core LightweightVK library (C++). Vulkan interop and backend in `lvk/vulkan/`.
- `samples/`: Desktop demo apps (headless-friendly flags available).
- `android/`: Templates for Android sample APKs (Gradle).
- `cmake/`, `CMakeLists.txt`: Build system.
- `third-party/`: External deps (populated by scripts).
- `.github/workflows/`: CI builds and headless run checks.

## Build, Test, Develop
- Bootstrap deps: `python3 deploy_content.py && python3 deploy_deps.py`.
- Configure (Unix Makefiles): `cmake -S . -B build -G "Unix Makefiles"`.
- macOS (Xcode): `cmake -S . -B build -G "Xcode"`.
- Windows (VS2022): `cmake -S . -B build -G "Visual Studio 17 2022"`.
- Build: `cmake --build build --parallel`.
- Android (generate Gradle projects): `cmake -S . -B build -DLVK_WITH_SAMPLES_ANDROID=ON`.
- Assemble APK (example): `cd build/android/009_TriplanarMapping && ./gradlew assembleDebug`.
- Quick run (headless): `./build/samples/001_HelloTriangle --headless --screenshot-frame 1 --screenshot-file out.png`.

## Coding Style & Naming
- C/C++: enforced by `.clang-format` (2‑space indent, width 140, no tabs, sorted includes, left‑aligned pointers). Apply via `clang-format -i`.
- Prefer C++20 designated initializers. Prefer `const` modifiers. Can use local lambdas (sparingly).
- CMake: `.cmake-format` (2‑space indent, canonical command case). Run `cmake-format -i` if available.
- Naming: Types/structs `PascalCase` (e.g., `Result`, `Viewport`); enums `EnumName_Value`; functions `lowerCamelCase` (e.g., `getVertexFormatSize()`); macros `LVK_*`.

## Testing Guidelines
- No unit test framework; GitHub Actions CI validates builds and runs selected samples headless (.github/workflows/c-cpp.ymp).
- Local sanity test: build, then run at least `001_HelloTriangle` and `005_MeshShaders` with `--headless` and capture a screenshot/log.
- Keep samples runnable on Linux/macOS/Windows; note Mac limitations (MoltenVK 1.3+).

## Commit & Pull Requests
- Commits: imperative, concise, start with capital; optional scope prefix (e.g., `macOS:`, `Samples:`, `Android:`). Examples: `Update README`, `Fix shader stage flags`.
- PRs: clear description, motivation, and platform notes; link issues if applicable; include build/run commands used and (for samples) screenshots/logs. Ensure CI passes across matrices.

## Security & Configuration Tips
- Requirements: Vulkan SDK 1.4.341+ (CI), KosmicKrisp on macOS; Android needs `ANDROID_NDK`, `JAVA_HOME`, and `adb` in `PATH`.
- GPUs must support Vulkan 1.3 (see README for details).

```

`CLAUDE.md`:

```md
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

LightweightVK is a bindless-only fork of IGL designed to run on Vulkan 1.3+ with optional mesh shaders and ray tracing support. It serves as a modern, minimalistic graphics API wrapper focused on rapid prototyping of Vulkan-based renderers.

## Build System and Commands

### Initial Setup
Before building, run the deployment scripts to download dependencies:
```bash
python3 deploy_content.py
python3 deploy_deps.py
```

### Platform-Specific Build Commands

**Windows:**
```bash
cd build
cmake .. -G "Visual Studio 18 2026"
```

**Linux:**
```bash
sudo apt-get install clang xorg-dev libxinerama-dev libxcursor-dev libgles2-mesa-dev libegl1-mesa-dev libglfw3-dev libglew-dev libstdc++-12-dev extra-cmake-modules libxkbcommon-x11-dev wayland-protocols
cd build
cmake .. -G "Unix Makefiles"
```

For Wayland: `cmake .. -G "Unix Makefiles" -DLVK_WITH_WAYLAND=ON`

**macOS:**
Requires VulkanSDK 1.4.341+
```bash
cd build
cmake .. -G "Xcode"
```

**Android:**
Requires Android Studio, ANDROID_NDK, JAVA_HOME, and adb in PATH
```bash
cd build
cmake .. -DLVK_WITH_SAMPLES_ANDROID=ON
cd android/Tiny  # or any other sample
./gradlew assembleDebug
```

For Android devices: `python3 deploy_content_android.py`

### CMake Configuration Options
- `LVK_WITH_SAMPLES`: Enable sample demo apps (default: ON)
- `LVK_WITH_TRACY`: Enable Tracy profiler (default: ON)
- `LVK_WITH_TRACY_GPU`: Enable Tracy GPU profiler (default: OFF)
- `LVK_WITH_WAYLAND`: Enable Wayland on Linux (default: OFF)
- `LVK_WITH_SLANG`: Enable Slang compiler (default: OFF)

## Architecture Overview

### Core Components
- **LVK Library** (`lvk/`): Main graphics API abstraction layer
  - `LVK.h/cpp`: Core API definitions and implementations
  - `vulkan/`: Vulkan-specific backend implementation
  - `HelpersImGui.h/cpp`: ImGui integration helpers
  - `Pool.h`: Resource management utilities

### Key Design Principles
1. **Bindless-only**: Utilizes Vulkan 1.3+ dynamic rendering, descriptor indexing, and buffer device address
2. **Minimal API surface**: No STL containers in public API
3. **Ray tracing integration**: Fully integrated with bindless design
4. **Cross-platform**: Windows, Linux, macOS (via KosmicKrisp), Android

### Sample Applications
Located in `samples/`, includes:
- Basic rendering (`001_HelloTriangle.cpp`)
- Cube mapping (`002_RenderToCubeMap.cpp`)
- Mesh shaders (`005_MeshShaders.cpp`)
- Ray tracing demos (`RTX_*.cpp`)
- Complex demos (`DEMO_001_SolarSystem.cpp`)

### Common Development Patterns
- All samples use `VulkanApp` base class (`samples/VulkanApp.h`)
- Platform abstraction through preprocessor macros
- Resource management via LVK handles and holders
- Tracy profiler integration when enabled

### Dependencies
- Vulkan 1.3+ (required)
- GLFW (desktop platforms)
- GLM (math library)
- ImGui (UI)
- Tracy (optional profiling)
- Various third-party libraries managed via bootstrap scripts

### Vulkan Interop
LVK provides helper functions in `lvk/vulkan/VulkanUtils.h` to access underlying Vulkan objects, enabling mixing of LVK and raw Vulkan API calls.

```

`CMakeLists.txt`:

```txt
# Copyright (c) Meta Platforms, Inc. and affiliates.
#
# This source code is licensed under the MIT license found in the
# LICENSE file in the root directory of this source tree.

cmake_minimum_required(VERSION 3.22)

include(CMakeDependentOption)
include(FetchContent)

project("LVK"
  LANGUAGES CXX C
  HOMEPAGE_URL "https://github.com/corporateshark/lightweightvk"
)

set_property(GLOBAL PROPERTY USE_FOLDERS ON)

# cmake-format: off
option(LVK_DEPLOY_DEPS             "Deploy dependencies via CMake"           ON)
option(LVK_WITH_GLFW               "Enable GLFW"                             ON)
option(LVK_WITH_SAMPLES            "Enable sample demo apps"                 ON)
option(LVK_WITH_SAMPLES_ANDROID    "Generate Android projects for demo apps" OFF)
option(LVK_WITH_TRACY              "Enable Tracy profiler"                   ON)
option(LVK_WITH_TRACY_GPU          "Enable Tracy GPU profiler"               OFF)
option(LVK_WITH_WAYLAND            "Enable Wayland"                          OFF)
option(LVK_WITH_IMPLOT             "Enable ImPlot"                           ON)
option(LVK_WITH_OPENXR             "Enable OpenXR"                           OFF)
option(LVK_WITH_ANDROID_VALIDATION "Enable validation layers on Android"     ON)
option(LVK_WITH_SLANG              "Enable Slang compiler"                   OFF)
option(LVK_ENABLE_LONG_PATHS_WIN32 "Enable long paths on Windows"            ON)

set(LVK_ANDROID_ABI "arm64-v8a" CACHE STRING "Enabled ABI on Android")
set(LVK_CUSTOM_MOLTENVK_PATH "" CACHE STRING "Path to custom MoltenVK")
# cmake-format: on

if(LVK_WITH_SAMPLES AND NOT LVK_WITH_GLFW)
  message(STATUS "WARNING: Setting LVK_WITH_SAMPLES=ON forces LVK_WITH_GLFW=ON")
  set(LVK_WITH_GLFW ON)
endif()

if(ANDROID)
  message(STATUS "WARNING: LVK_WITH_GLFW and LVK_WITH_SLANG were set to OFF for Android")
  set(LVK_WITH_GLFW OFF)
  set(LVK_WITH_SLANG OFF)
endif()

if(LVK_WITH_TRACY_GPU AND NOT LVK_WITH_TRACY)
  message(STATUS "WARNING: Setting LVK_WITH_TRACY_GPU=ON forces LVK_WITH_TRACY=ON")
  set(LVK_WITH_TRACY ON)
endif()

if(LVK_WITH_WAYLAND AND (ANDROID OR APPLE OR WIN32))
  message(FATAL_ERROR "LVK_WITH_WAYLAND=ON can be set only on Linux")
endif()

if(APPLE)
  if(EXISTS ${LVK_CUSTOM_MOLTENVK_PATH})
    message("Custom MoltenVK found at ${LVK_CUSTOM_MOLTENVK_PATH}")
    set(LVK_USE_CUSTOM_MOLTENVK ON)
  else()
    set(LVK_USE_CUSTOM_MOLTENVK OFF)
  endif()
endif()

if(LVK_ENABLE_LONG_PATHS_WIN32 AND WIN32)
  execute_process(
    COMMAND reg query "HKLM\\SYSTEM\\CurrentControlSet\\Control\\FileSystem" /v LongPathsEnabled
    OUTPUT_VARIABLE LONG_PATHS_OUTPUT
    ERROR_VARIABLE LONG_PATHS_ERROR
    RESULT_VARIABLE LONG_PATHS_RESULT
    OUTPUT_STRIP_TRAILING_WHITESPACE
  )
  if(LONG_PATHS_RESULT EQUAL 0 AND LONG_PATHS_OUTPUT MATCHES "0x1")
    message(STATUS "Windows long paths enabled")
  else()
    message(FATAL_ERROR "Windows long paths not enabled. Enable via PowerShell (admin): New-ItemProperty -Path 'HKLM:\\SYSTEM\\CurrentControlSet\\Control\\FileSystem' -Name 'LongPathsEnabled' -Value 1 -PropertyType DWORD -Force")
  endif()
endif()

include(cmake/CommonMacros.txt)

if(NOT LVK_USE_CUSTOM_MOLTENVK AND DEFINED ENV{VULKAN_SDK})
  message(STATUS "VULKAN_SDK=$ENV{VULKAN_SDK}")
  if(NOT EXISTS $ENV{VULKAN_SDK})
    message(FATAL_ERROR "$ENV{VULKAN_SDK} does not exist.")
  endif()
endif()

function(lvk_set_folder target folder_name)
  set_property(TARGET ${target} PROPERTY FOLDER ${folder_name})
endfunction()

function(lvk_set_cxxstd target cpp_version)
  set_property(TARGET ${target} PROPERTY CXX_STANDARD ${cpp_version})
  set_property(TARGET ${target} PROPERTY CXX_STANDARD_REQUIRED ON)
endfunction()

# cmake-format: off
message(STATUS "LVK_DEPLOY_DEPS             = ${LVK_DEPLOY_DEPS}")
message(STATUS "LVK_WITH_GLFW               = ${LVK_WITH_GLFW}")
message(STATUS "LVK_WITH_SAMPLES            = ${LVK_WITH_SAMPLES}")
message(STATUS "LVK_WITH_SAMPLES_ANDROID    = ${LVK_WITH_SAMPLES_ANDROID}")
message(STATUS "LVK_WITH_TRACY              = ${LVK_WITH_TRACY}")
message(STATUS "LVK_WITH_TRACY_GPU          = ${LVK_WITH_TRACY_GPU}")
message(STATUS "LVK_WITH_WAYLAND            = ${LVK_WITH_WAYLAND}")
message(STATUS "LVK_WITH_IMPLOT             = ${LVK_WITH_IMPLOT}")
message(STATUS "LVK_WITH_OPENXR             = ${LVK_WITH_OPENXR}")
# cmake-format: on

# cmake-format: off
if(LVK_WITH_SAMPLES_ANDROID)
  message(STATUS "LVK_ANDROID_ABI             = ${LVK_ANDROID_ABI}")
  message(STATUS "LVK_WITH_ANDROID_VALIDATION = ${LVK_WITH_ANDROID_VALIDATION}")
endif()
# cmake-format: on

if(NOT DEFINED CMAKE_BUILD_TYPE)
  set(CMAKE_BUILD_TYPE "Debug")
endif()

add_compile_options("$<$<CONFIG:DEBUG>:-DDEBUG>")

message(STATUS "Generator : " ${CMAKE_GENERATOR})
message(STATUS "Build type: " ${CMAKE_BUILD_TYPE})

set(LVK_ROOT_DIR ${CMAKE_CURRENT_SOURCE_DIR})
set(LVK_DEPS_CACHE_FILE "${LVK_ROOT_DIR}/third-party/.bootstrap-deps.json")
find_package(Python3 COMPONENTS Interpreter)

message(STATUS "LVK_ROOT_DIR = " ${LVK_ROOT_DIR})

# enable multithreaded builds for Visual Studio
add_compile_options($<$<CXX_COMPILER_ID:MSVC>:/MP>)

if(LVK_DEPLOY_DEPS)
  # deploy dependencies during configuration
  execute_process(COMMAND ${Python3_EXECUTABLE} deploy_deps.py WORKING_DIRECTORY ${LVK_ROOT_DIR} COMMAND_ERROR_IS_FATAL ANY)

  if(NOT EXISTS ${LVK_DEPS_CACHE_FILE})
    message(FATAL_ERROR "Cannot deploy dependencies.")
  endif()

  # regenerate dependencies when .bootstrap-deps.json is older than bootstrap-deps.json
  add_custom_command(COMMAND ${Python3_EXECUTABLE} deploy_deps.py OUTPUT ${LVK_DEPS_CACHE_FILE}
                     DEPENDS "${LVK_ROOT_DIR}/third-party/bootstrap-deps.json" WORKING_DIRECTORY ${LVK_ROOT_DIR})
  add_custom_target(LVKDependencies DEPENDS ${LVK_DEPS_CACHE_FILE})

  lvk_set_folder(LVKDependencies "LVK")

  if(LVK_WITH_SLANG)
    FetchContent_Populate(
      slang
      GIT_REPOSITORY https://github.com/shader-slang/slang
      GIT_TAG        v2026.1.1
      SOURCE_DIR     ${LVK_ROOT_DIR}/third-party/deps/src/slang
    )
  endif()
endif()

if(LVK_WITH_WAYLAND)
  include(${LVK_ROOT_DIR}/third-party/deps/src/cmake-wayland/FindWayland.cmake)
  if(NOT WAYLAND_FOUND)
    message(FATAL_ERROR "Wayland is not found in this OS")
  endif()
endif()

if(LVK_WITH_TRACY)
  set(TRACY_ENABLE ON CACHE BOOL "")
  add_subdirectory(third-party/deps/src/tracy)
  lvk_set_folder(TracyClient "third-party")
endif()

if(LVK_WITH_OPENXR)
  if(NOT WIN32)
    message(FATAL_ERROR "OpenXR can be enabled only on Windows.")
  endif()
  add_subdirectory(third-party/deps/src/openxr-sdk)
  # cmake-format: off
  lvk_set_folder(openxr_loader             "third-party/OpenXR")
  lvk_set_folder(generate_openxr_header    "third-party/OpenXR")
  lvk_set_folder(xr_common_generated_files "third-party/OpenXR")
  lvk_set_folder(xr_global_generated_files "third-party/OpenXR")
  # cmake-format: on
endif()

# cmake-format: off
set(MINILOG_BUILD_EXAMPLE OFF CACHE BOOL "")
set(MINILOG_RAW_OUTPUT     ON CACHE BOOL "")
# cmake-format: on
add_subdirectory(third-party/deps/src/minilog)
lvk_set_folder(minilog "third-party")
target_compile_definitions(minilog PUBLIC "-DMINILOG_ENABLE_VA_LIST=1")

# temporary
if(NOT LVK_USE_CUSTOM_MOLTENVK AND NOT LVK_WITH_SLANG)
  find_package(Vulkan REQUIRED)
endif()

include_directories(.)
include_directories(src)

add_subdirectory(lvk)

target_include_directories(LVKLibrary PUBLIC ${LVK_ROOT_DIR})
target_include_directories(LVKLibrary PUBLIC ${LVK_ROOT_DIR}/src)

if(LVK_WITH_TRACY)
  target_link_libraries(LVKVulkan PUBLIC TracyClient)
  target_compile_definitions(LVKVulkan PUBLIC "LVK_WITH_TRACY=1")
  if(LVK_WITH_TRACY_GPU)
    target_compile_definitions(LVKVulkan PUBLIC "LVK_WITH_TRACY_GPU=1")
  endif()
endif()

if(LVK_WITH_GLFW)
  target_compile_definitions(LVKLibrary PUBLIC "LVK_WITH_GLFW=1")
endif()

if(LVK_WITH_IMPLOT)
  target_compile_definitions(LVKLibrary PUBLIC "LVK_WITH_IMPLOT=1")
endif()

if(LVK_DEPLOY_DEPS)
  add_dependencies(LVKLibrary LVKDependencies)
endif()

add_library(LVKstb third-party/deps/patches/stb_impl/stb_image.c third-party/deps/patches/stb_impl/stb_image_resize2.c
                   third-party/deps/patches/stb_impl/stb_image_write.c)
target_include_directories(LVKstb PUBLIC "third-party/deps/src/stb")
if(ANDROID)
  target_compile_definitions(LVKstb PUBLIC "STBI_NO_SIMD=1")
  target_compile_definitions(LVKstb PUBLIC "STBIR_NO_SIMD=1")
endif()
lvk_set_folder(LVKstb "LVK")

target_link_libraries(LVKLibrary PUBLIC minilog)
target_include_directories(LVKLibrary PUBLIC "third-party/deps/src")

if(LVK_WITH_GLFW)
  # cmake-format: off
  set(GLFW_BUILD_DOCS     OFF CACHE BOOL "")
  set(GLFW_BUILD_EXAMPLES OFF CACHE BOOL "")
  set(GLFW_BUILD_TESTS    OFF CACHE BOOL "")
  set(GLFW_INSTALL        OFF CACHE BOOL "")
  set(GLFW_VULKAN_STATIC  OFF CACHE BOOL "")
  if(WAYLAND_FOUND)
    set(GLFW_BUILD_WAYLAND  ON)
    set(GLFW_BUILD_X11     OFF)
  else()
    set(GLFW_BUILD_WAYLAND OFF)
    set(GLFW_BUILD_X11      ON)
  endif()
  add_subdirectory(third-party/deps/src/glfw)
  lvk_set_folder(glfw            "third-party/GLFW3")
  lvk_set_folder(update_mappings "third-party/GLFW3")
  # cmake-format: on
endif()
  
if(LVK_WITH_SAMPLES)
  include_directories("third-party/deps/src")
  include_directories("third-party/deps/src/glm")
  include_directories("third-party/deps/src/stb")
  include_directories("third-party/deps/src/taskflow")
  include_directories("third-party/deps/src/3D-Graphics-Rendering-Cookbook")
  if(UNIX AND NOT ANDROID)
    find_package(OpenGL REQUIRED)
  endif()
  # cmake-format: off
  set(LIBKTX_VERSION_READ_ONLY    OFF CACHE BOOL "")
  set(LIBKTX_VERSION_FULL          ON CACHE BOOL "")
  set(LIBKTX_FEATURE_KTX1          ON CACHE BOOL "")
  set(LIBKTX_FEATURE_KTX2          ON CACHE BOOL "")
  set(LIBKTX_FEATURE_VK_UPLOAD    OFF CACHE BOOL "")
  set(LIBKTX_FEATURE_GL_UPLOAD    OFF CACHE BOOL "")
  set(LIBKTX_FEATURE_ETC_UNPACK    ON CACHE BOOL "")
  # cmake-format: on
  add_subdirectory(third-party/deps/src/ldrutils)
  lvk_set_folder(LUtils "third-party")
  add_subdirectory(third-party/deps/src/ktx-software/lib)
  # patch LIBKTX: this file interferes with normal Vulkan headers
  list(REMOVE_ITEM LIBKTX_MAIN_SRC "../external/dfdutils/vulkan/vulkan_core.h")
  lvk_set_folder(ktx "third-party/ktx-software")
  lvk_set_folder(ktx_version "third-party/ktx-software")
  lvk_set_folder(basisu_encoder "third-party/ktx-software")
  if(CMAKE_CXX_COMPILER_ID STREQUAL "Clang")
    target_compile_options(basisu_encoder PUBLIC "-Wno-deprecated-anon-enum-enum-conversion")
  endif()
  if(TARGET astcenc-avx2-static)
    lvk_set_folder(astcenc-avx2-static "third-party/ktx-software")
  endif()
  add_subdirectory(third-party/deps/src/meshoptimizer)
  add_subdirectory(third-party/deps/src/fast_obj)
  add_subdirectory(samples)
  # cmake-format: off
  lvk_set_folder(meshoptimizer "third-party")
  lvk_set_folder(fast_obj_lib  "third-party")
  # cmake-format: on
endif()

if(LVK_WITH_OPENXR)
  target_compile_definitions(LVKVulkan PRIVATE "XR_USE_GRAPHICS_API_VULKAN=1")
  target_compile_definitions(LVKLibrary PUBLIC "LVK_WITH_OPENXR=1")
  target_link_libraries(LVKLibrary PUBLIC OpenXR::openxr_loader)
  target_include_directories(LVKLibrary PUBLIC "${LVK_ROOT_DIR}/third-party/deps/src/openxr-sdk/include")
endif()

# ImGui
target_include_directories(LVKLibrary PUBLIC "${LVK_ROOT_DIR}/third-party/deps/src/imgui")

```

`LICENSE.md`:

```md
## LightweightVK

MIT License

Copyright (c) Sergey Kosarevsky, 2023-2026

## Based on https://github.com/facebook/igl/

MIT License

Copyright (c) Meta Platforms, Inc. and affiliates.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

## Dependencies

3D-Graphics-Rendering-Cookbook
https://github.com/PacktPublishing/3D-Graphics-Rendering-Cookbook/blob/master/LICENSE

3D-Graphics-Rendering-Cookbook (2nd Edition)
https://github.com/PacktPublishing/3D-Graphics-Rendering-Cookbook-Second-Edition/blob/master/LICENSE

Amazon Lumberyard Bistro
https://developer.nvidia.com/orca/amazon-lumberyard-bistro
https://casual-effects.com/data/

bc7env
https://github.com/richgel999/bc7enc/blob/master/LICENSE

Bootstrap
https://github.com/corporateshark/bootstrapping/blob/master/LICENSE

Damaged Helmet
https://github.com/KhronosGroup/glTF-Sample-Models/blob/master/2.0/DamagedHelmet/README.md

fast_obj
https://github.com/thisistherk/fast_obj/blob/master/LICENSE

fmt
https://github.com/fmtlib/fmt/blob/master/LICENSE.rst

glfw
https://github.com/glfw/glfw/blob/master/LICENSE.md

glm
https://github.com/g-truc/glm

glslang
https://github.com/KhronosGroup/glslang/blob/main/LICENSE.txt

googletest
https://github.com/google/googletest/blob/main/LICENSE

IGL
https://github.com/facebook/igl/blob/main/LICENSE.md

imgui
https://github.com/ocornut/imgui/blob/master/LICENSE.txt

implot
https://github.com/epezent/implot/blob/master/LICENSE

ios-cmake
https://github.com/leetal/ios-cmake/blob/master/LICENSE.md

ldrutils
https://github.com/corporateshark/ldrutils/blob/master/LICENSE.md

Meshoptimizer
https://github.com/zeux/meshoptimizer/blob/master/LICENSE.md

minilog
https://github.com/corporateshark/minilog/blob/main/LICENSE

stb
https://github.com/nothings/stb/blob/master/LICENSE

taskflow
https://github.com/taskflow/taskflow/blob/master/LICENSE

tracy
https://github.com/wolfpld/tracy/blob/master/LICENSE

volk
https://github.com/zeux/volk/blob/master/LICENSE.md

Vulkan Memory Allocator
https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator/blob/master/LICENSE.txt

```

`README.md`:

```md
LightweightVK [![Build Status](https://github.com/corporateshark/lightweightvk/actions/workflows/c-cpp.yml/badge.svg)](https://github.com/corporateshark/lightweightvk/actions)
========================

LightweightVK is a deeply refactored **bindless-only** fork of [IGL](https://github.com/facebook/igl) which is designed to run on top of **Vulkan 1.3** with optional **mesh shaders** and **ray tracing** support.

The main goals of LightweightVK:

1. **Lean.** Minimalistic API without bloat (no `std::vector`, `std::unordered_map` etc in the API).
2. **Bindless.** Utilize Vulkan 1.3+ dynamic rendering, descriptor indexing, and buffer device address features for modern bindless-only API design. Ray tracing features are fully integrated with the bindless-only design.
3. **Agile.** A playground for experiments to enable quick exploration of ideas and adoption of Vulkan API changes.
4. **Multilingual.** In addition to raw SPIR-V, there's built-in support for `Glslang` and `Slang` shaders, which is invaluable for rapid prototyping.

Designed for rapid prototyping of modern Vulkan-based renderers.

There are **no plans to keep this fork in sync with upstream**, since the **API was completely redesigned** in a *bindless* manner.

Discord: https://discord.com/invite/bEyHyKCrvq

## Supported rendering backends

 * Vulkan 1.3 (Windows, Linux, MacOS, Android)
   * mandatory **VK_KHR_dynamic_rendering_local_read**
   * mandatory **VK_KHR_maintenance5**
   * mandatory **VK_KHR_push_descriptor**
   * mandatory **VK_EXT_surface_maintenance1**
   * optional **VK_KHR_acceleration_structure** (Windows, Linux, Android)
   * optional **VK_KHR_ray_tracing_pipeline** (Windows, Linux, Android)
   * optional **VK_KHR_ray_query** (Windows, Linux, Android)
   * optional **VK_EXT_mesh_shader** (Windows, Linux)

## Supported platforms

 * Linux
 * Windows
 * MacOS (via MoltenVK)
 * Android

## API Support

|                               | Windows                    | Linux                      | MacOS                      | Android                    |
| ----------------------------- | -------------------------- | -------------------------- | -------------------------- | -------------------------- |
| Vulkan 1.3                    | :heavy_check_mark:         | :heavy_check_mark:         | :heavy_check_mark:         | :heavy_check_mark:         |
| VK_KHR_acceleration_structure | :heavy_check_mark:         | :heavy_check_mark:         |                            | :heavy_check_mark:         |
| VK_KHR_ray_tracing_pipeline   | :heavy_check_mark:         | :heavy_check_mark:         |                            | :heavy_check_mark:         |
| VK_KHR_ray_query              | :heavy_check_mark:         | :heavy_check_mark:         |                            | :heavy_check_mark:         |
| VK_EXT_mesh_shader            | :heavy_check_mark:         | :heavy_check_mark:         |                            |                            |

On MacOS, `MoltenVK 1.4+` and `VulkanSDK 1.4.321+` are required.

## Build

Before building, run the deployment scripts:

```
python3 deploy_content.py
python3 deploy_deps.py
```

These scripts download external third-party dependencies. Please check [LICENSE.md](./LICENSE.md) for the full list.

### Windows

```
cd build
cmake .. -G "Visual Studio 18 2026"
```

### Linux

```
sudo apt-get install clang xorg-dev libxinerama-dev libxcursor-dev libgles2-mesa-dev libegl1-mesa-dev libglfw3-dev libglew-dev libstdc++-12-dev extra-cmake-modules libxkbcommon-x11-dev wayland-protocols
cd build
cmake .. -G "Unix Makefiles"
```

:heavy_exclamation_mark: Use `cmake .. -G "Unix Makefiles" -DLVK_WITH_WAYLAND=ON` to build for Wayland, X11 is used by default.

### MacOS

:heavy_exclamation_mark: Be sure that `VulkanSDK 1.4.321+` for MacOS is installed https://vulkan.lunarg.com/sdk/home#mac

:heavy_exclamation_mark: Not all demos work on MacOS due to missing features and bugs in SPIRV-Cross https://github.com/KhronosGroup/Vulkan-ValidationLayers/issues/7512

```
cd build
cmake .. -G "Xcode"
```

### Android

:heavy_exclamation_mark: Be sure that [Android Studio](https://developer.android.com/studio) is set up.

:heavy_exclamation_mark: Be sure that the `ANDROID_NDK` environment variable points to your Android NDK.

:heavy_exclamation_mark: Be sure that the `JAVA_HOME` environment variable is set to the path of the Java Runtime.

:heavy_exclamation_mark: Be sure that the `adb` platform tool is in the `PATH` environment variable.

```
cd build
cmake .. -DLVK_WITH_SAMPLES_ANDROID=ON
cd android/Tiny                         # or any other sample
./gradlew assembleDebug                 # or assembleRelease
```
You can also open the project in Android Studio and build it from there.

Before running demo apps on your device, connect the device to a desktop machine and run the deployment script:

```
python3 deploy_content_android.py
```

> NOTE: To run demos on an Android device, it should support Vulkan 1.3. Please check https://vulkan.gpuinfo.org/listdevices.php?platform=android 

> NOTE: At the moment, demo apps do not support touch input on Android.

## Using the Slang compiler

By default, the [Slang](https://github.com/shader-slang/slang) compiler is disabled,
and only GLSL shaders are supported through the [glslang](https://github.com/KhronosGroup/glslang) compiler.
To enable [Slang](https://github.com/shader-slang/slang), configure the project with the following CMake option:

```
cmake .. -DLVK_WITH_SLANG=ON
```

## Screenshots

Check out [https://github.com/corporateshark/lightweightvk/samples](https://github.com/corporateshark/lightweightvk/tree/master/samples).

A comprehensive set of examples can be found in this repository [3D Graphics Rendering Cookbook: 2nd edition](https://github.com/PacktPublishing/3D-Graphics-Rendering-Cookbook-Second-Edition) and in the book
[Vulkan 3D Graphics Rendering Cookbook - 2nd Edition](https://www.amazon.com/Vulkan-Graphics-Rendering-Cookbook-High-Performance/dp/1803248114).

[![Vulkan 3D Graphics Rendering Cookbook](.github/screenshot01.jpg)](https://github.com/PacktPublishing/3D-Graphics-Rendering-Cookbook-Second-Edition/tree/main/Chapter11/06_FinalDemo/src)
![image](.github/samples/007_RayTracingAO.jpg)
[![Solar System Demo](.github/screenshot02.jpg)](https://github.com/corporateshark/lightweightvk/blob/master/samples/DEMO_001_SolarSystem.cpp)

## Interop with raw Vulkan API calls

The header file `lvk/vulkan/VulkanUtils.h` offers a collection of functions that allow you to access the underlying Vulkan API objects from LightweightVK handles. This makes it easy to mix LVK and Vulkan code, as shown in the following example:

```c
lvk::Holder<lvk::BufferHandle> vertexBuffer = ctx_->createBuffer({...});
...
lvk::ICommandBuffer& buffer = ctx_->acquireCommandBuffer();
VkCommandBuffer cmdBuf = getVkCommandBuffer(buffer);
VkBuffer buf = getVkBuffer(vertexBuffer);
vkCmdUpdateBuffer(cmdBuf, buf, 0, sizeof(params), &params);
ctx_->submit(buffer, ctx_->getCurrentSwapchainTexture());
```

If you'd like to add more helper functions, feel free to submit a pull request.

## License

LightweightVK is released under the MIT license, see [LICENSE.md](./LICENSE.md) for the full text as well as third-party library
acknowledgements.

```

`android/app/AndroidManifest.xml.in`:

```in
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools">

  <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"   android:maxSdkVersion="32" />
  <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"  android:maxSdkVersion="29" />
  <uses-permission android:name="android.permission.MANAGE_EXTERNAL_STORAGE" tools:ignore="ScopedStorage" />
  <uses-permission android:name="android.permission.READ_MEDIA_IMAGES" />
  <uses-permission android:name="android.permission.READ_MEDIA_VIDEO" />
  <uses-permission android:name="android.permission.READ_MEDIA_AUDIO" />

  <application
      android:allowBackup="false"
      android:dataExtractionRules="@xml/data_extraction_rules"
      android:fullBackupContent="false"
      android:label="lvk_@APP_NAME@"
      android:enableOnBackInvokedCallback="true">
    <activity
        android:exported="true"
        android:name="org.lvk.samples.MainActivity"
        android:configChanges="screenSize|screenLayout|orientation|keyboardHidden|keyboard|navigation|uiMode|density"
        android:screenOrientation="landscape"
        android:launchMode="singleTask"
        android:theme="@android:style/Theme.NoTitleBar.Fullscreen"
        android:label="@APP_NAME@">
      <meta-data
          android:name="android.app.lib_name"
          android:value="lvk_android_native_@APP_NAME@" />
      <intent-filter>
        <action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.LAUNCHER" />
      </intent-filter>
    </activity>
  </application>
</manifest>

```

`android/app/MainActivity.java.in`:

```in
package org.lvk.samples;

import android.content.Intent;
import android.content.pm.PackageManager;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;
import android.os.Environment;
import android.provider.Settings;
import android.view.WindowInsets;
import android.view.WindowInsetsController;

public class MainActivity extends android.app.NativeActivity {
  private static final String PERMISSION_READ_EXTERNAL_STORAGE = "android.permission.READ_EXTERNAL_STORAGE";
  private static final String PERMISSION_WRITE_EXTERNAL_STORAGE = "android.permission.WRITE_EXTERNAL_STORAGE";
  private static final int REQUEST_PERMISSION_CODE = 1;

  static {
    System.loadLibrary("lvk_android_native_@APP_NAME@");
  }

  private void hideSystemBars() {
    getWindow().setDecorFitsSystemWindows(false);
    final WindowInsetsController controller = getWindow().getInsetsController();
    if (controller != null) {
      controller.hide(WindowInsets.Type.statusBars() | WindowInsets.Type.navigationBars());
      controller.setSystemBarsBehavior(WindowInsetsController.BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE);
    }
  }

  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    hideSystemBars();
    if (checkSelfPermission(PERMISSION_READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED ||
        checkSelfPermission(PERMISSION_WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
      requestPermissions(new String[] {PERMISSION_READ_EXTERNAL_STORAGE, 
                                       PERMISSION_WRITE_EXTERNAL_STORAGE}, REQUEST_PERMISSION_CODE);
    }
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
      if (!Environment.isExternalStorageManager()) {
        Intent intent = new Intent(Settings.ACTION_MANAGE_APP_ALL_FILES_ACCESS_PERMISSION);
        Uri uri = Uri.fromParts("package", getPackageName(), null);
        intent.setData(uri);
        startActivity(intent);
      }
    }
  }

  @Override
  public void onWindowFocusChanged(boolean hasFocus) {
    super.onWindowFocusChanged(hasFocus);
    if (hasFocus) {
      hideSystemBars();
    }
  }

  @SuppressWarnings("deprecation")
  @Override
  public void onBackPressed() {
    System.gc();
    System.exit(0);
  }
}

```

`android/app/build.gradle.in`:

```in
plugins {
  id 'com.android.application'
}

android {
  namespace = 'org.lvk.samples'
  compileSdk = 34

  defaultConfig {
    applicationId = "org.lvk.samples.lvk_@APP_NAME@"
    minSdk = 30
    targetSdk = 34
    versionCode = 1
    versionName = "1.0"
    ndk {
      abiFilters.addAll(@ANDROID_ABI_FILTERS@)
    }
    externalNativeBuild {
      cmake {
        targets 'lvk_android_native_@APP_NAME@'
        cppFlags '-std=c++20'
        arguments '-DCMAKE_OBJECT_PATH_MAX=1024', '-DLVK_DEPLOY_DEPS=OFF', '-DLVK_WITH_GLFW=OFF', '-DLVK_WITH_SAMPLES=ON', '-DLVK_WITH_SAMPLES_ANDROID=ON', '-DLVK_WITH_TRACY=OFF', '-DLVK_WITH_WAYLAND=OFF', '-DLVK_WITH_IMPLOT=ON', '-DLVK_WITH_OPENXR=OFF'
      }
    }
  }

  androidResources {
    noCompress.addAll(['png', 'ktx', 'data'])
  }

  buildTypes {
    release {
      signingConfig = signingConfigs.debug
    }
  }

  compileOptions {
    sourceCompatibility = JavaVersion.VERSION_1_8
    targetCompatibility = JavaVersion.VERSION_1_8
  }

  ndkVersion = '29.0.14206865'

  externalNativeBuild {
    cmake {
      path = file('../../../../CMakeLists.txt')
    }
  }

  buildFeatures {
    viewBinding = true
  }
}

```

`android/app/data_extraction_rules.xml.in`:

```in
<?xml version="1.0" encoding="utf-8"?>
<data-extraction-rules>
  <cloud-backup>
    <exclude domain="root" path="." />
  </cloud-backup>
  <device-transfer>
    <exclude domain="root" path="." />
  </device-transfer>
</data-extraction-rules>

```

`android/build.gradle`:

```gradle
// Top-level build file where you can add configuration options common to all sub-projects/modules.
plugins {
  id 'com.android.application' version '9.0.0' apply false
}
```

`android/gradle.properties`:

```properties
# Project-wide Gradle settings.
# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.
# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html
# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. More details, visit
# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
# org.gradle.parallel=true
# AndroidX package structure to make it clearer which packages are bundled with the
# Android operating system, and which are packaged with your app's APK
# https://developer.android.com/topic/libraries/support-library/androidx-rn
android.useAndroidX=true
# Kotlin code style for this project: "official" or "obsolete":
kotlin.code.style=official
# Enables namespacing of each library's R class so that its R class includes only the
# resources declared in the library itself and none from the library's dependencies,
# thereby reducing the size of the R class for that library
android.nonTransitiveRClass=true
```

`android/gradle/wrapper/gradle-wrapper.properties`:

```properties
#Sat Feb 10 20:00:48 GMT 2024
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-9.3.0-bin.zip
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists

```

`android/gradlew`:

```
#!/usr/bin/env sh

#
# Copyright 2015 the original author or authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

##############################################################################
##
##  Gradle start up script for UN*X
##
##############################################################################

# Attempt to set APP_HOME
# Resolve links: $0 may be a link
PRG="$0"
# Need this for relative symlinks.
while [ -h "$PRG" ] ; do
    ls=`ls -ld "$PRG"`
    link=`expr "$ls" : '.*-> \(.*\)$'`
    if expr "$link" : '/.*' > /dev/null; then
        PRG="$link"
    else
        PRG=`dirname "$PRG"`"/$link"
    fi
done
SAVED="`pwd`"
cd "`dirname \"$PRG\"`/" >/dev/null
APP_HOME="`pwd -P`"
cd "$SAVED" >/dev/null

APP_NAME="Gradle"
APP_BASE_NAME=`basename "$0"`

# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD="maximum"

warn () {
    echo "$*"
}

die () {
    echo
    echo "$*"
    echo
    exit 1
}

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "`uname`" in
  CYGWIN* )
    cygwin=true
    ;;
  Darwin* )
    darwin=true
    ;;
  MINGW* )
    msys=true
    ;;
  NONSTOP* )
    nonstop=true
    ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD="$JAVA_HOME/jre/sh/java"
    else
        JAVACMD="$JAVA_HOME/bin/java"
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD="java"
    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi

# Increase the maximum file descriptors if we can.
if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
    MAX_FD_LIMIT=`ulimit -H -n`
    if [ $? -eq 0 ] ; then
        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
            MAX_FD="$MAX_FD_LIMIT"
        fi
        ulimit -n $MAX_FD
        if [ $? -ne 0 ] ; then
            warn "Could not set maximum file descriptor limit: $MAX_FD"
        fi
    else
        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
    fi
fi

# For Darwin, add options to specify how the application appears in the dock
if $darwin; then
    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
fi

# For Cygwin or MSYS, switch paths to Windows format before running java
if [ "$cygwin" = "true" -o "$msys" = "true" ] ; then
    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`

    JAVACMD=`cygpath --unix "$JAVACMD"`

    # We build the pattern for arguments to be converted via cygpath
    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
    SEP=""
    for dir in $ROOTDIRSRAW ; do
        ROOTDIRS="$ROOTDIRS$SEP$dir"
        SEP="|"
    done
    OURCYGPATTERN="(^($ROOTDIRS))"
    # Add a user-defined pattern to the cygpath arguments
    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
    fi
    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    i=0
    for arg in "$@" ; do
        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option

        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
        else
            eval `echo args$i`="\"$arg\""
        fi
        i=`expr $i + 1`
    done
    case $i in
        0) set -- ;;
        1) set -- "$args0" ;;
        2) set -- "$args0" "$args1" ;;
        3) set -- "$args0" "$args1" "$args2" ;;
        4) set -- "$args0" "$args1" "$args2" "$args3" ;;
        5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
        6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
        7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
        8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
        9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
    esac
fi

# Escape application args
save () {
    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
    echo " "
}
APP_ARGS=`save "$@"`

# Collect all arguments for the java command, following the shell quoting and substitution rules
eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"

exec "$JAVACMD" "$@"

```

`android/gradlew.bat`:

```bat
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem

@if "%DEBUG%" == "" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%" == "" set DIRNAME=.
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if "%ERRORLEVEL%" == "0" goto execute

echo.
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo.
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if "%ERRORLEVEL%"=="0" goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
exit /b 1

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

```

`android/settings.gradle.in`:

```in
pluginManagement {
    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
    }
}

rootProject.name = "@APP_NAME@"
include ':app'

```

`build/.gitignore`:

```
*
*.*
!.gitignore

```

`cmake/CommonMacros.txt`:

```txt
#
# based on https://github.com/PacktPublishing/3D-Graphics-Rendering-Cookbook/blob/master/CMake/CommonMacros.txt
#

cmake_minimum_required(VERSION 3.22)

macro(lvk_setup_groups src_files)
  foreach(FILE ${src_files})
    get_filename_component(PARENT_DIR "${FILE}" PATH)

    # skip src or include and changes /'s to \\'s
    set(GROUP "${PARENT_DIR}")
    string(REPLACE "/" "\\" GROUP "${GROUP}")

    source_group("${GROUP}" FILES "${FILE}")
  endforeach()
endmacro()

macro(lvk_set_folder target folder_name)
  set_property(TARGET ${target} PROPERTY FOLDER ${folder_name})
endmacro()

macro(lvk_setup_target target)
  set_property(TARGET ${target} PROPERTY CXX_STANDARD 20)
  set_property(TARGET ${target} PROPERTY CXX_STANDARD_REQUIRED ON)
endmacro()

```

`deploy_content.py`:

```py
#!/usr/bin/python3
# Copyright (c) Meta Platforms, Inc. and affiliates.
#
# This source code is licensed under the MIT license found in the
# LICENSE file in the root directory of this source tree.


import os
import sys

folder = "third-party"
script = os.path.join(folder, "bootstrap.py")
json = os.path.join(folder, "bootstrap-content.json")
base = os.path.join(folder, "content")

try:
    os.mkdir(base)
except FileExistsError:
    pass

os.system(
    '"{}" {} -b {} --bootstrap-file={}'.format(sys.executable, script, base, json)
)

```

`deploy_content_android.py`:

```py
#!/usr/bin/python3
# LightweightVK
#
# This source code is licensed under the MIT license found in the
# LICENSE file in the root directory of this source tree.

import os
import subprocess

def get_external_storage():
    adb_command = ['adb', 'shell', 'echo', '$EXTERNAL_STORAGE']
    try:
        process = subprocess.Popen(adb_command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        stdout, stderr = process.communicate()
        output = stdout.decode().strip()
        if stderr:
            print("Error executing adb shell command:", stderr.decode().strip())
        return output
    except Exception as e:
        print("An error occurred:", e)
        return None

external_storage_path = get_external_storage()
if external_storage_path is not None:
    paths = [(os.path.join("third-party", "content"),
              os.path.join(external_storage_path, "LVK", "content").replace("\\", "/")),
             (os.path.join("third-party", "deps", "src", "3D-Graphics-Rendering-Cookbook", "data"),
              os.path.join(external_storage_path, "LVK", "deps", "src", "3D-Graphics-Rendering-Cookbook", "data").replace("\\", "/"))]
    for (desktop_path, android_path) in paths:
        try:
            print('Copying {} to {} ...'.format(desktop_path, android_path))
            process = subprocess.Popen(['adb', 'push', desktop_path, android_path], shell=False)
            process.communicate()
            process.wait()
            print('Completed')
        except Exception as e:
            print("An error occurred:", e)
else:
    print("External storage path is not found")

```

`deploy_deps.py`:

```py
#!/usr/bin/python3
# Copyright (c) Meta Platforms, Inc. and affiliates.
#
# This source code is licensed under the MIT license found in the
# LICENSE file in the root directory of this source tree.


import os
import sys

folder = "third-party"
script = os.path.join(folder, "bootstrap.py")
json = os.path.join(folder, "bootstrap-deps.json")
base = os.path.join(folder, "deps")

os.system(
    '"{}" {} -b {} --bootstrap-file={} --break-on-first-error'.format(
        sys.executable, script, base, json
    )
)

```

`lvk/CMakeLists.txt`:

```txt
# LightweightVK
#
# This source code is licensed under the MIT license found in the
# LICENSE file in the root directory of this source tree.

cmake_minimum_required(VERSION 3.22)

project(LVKLibrary CXX C)

file(GLOB SRC_FILES LIST_DIRECTORIES false RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} *.cpp)
file(GLOB HEADER_FILES LIST_DIRECTORIES false RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} *.h)
if(APPLE)
  file(GLOB SRC_FILES_MM LIST_DIRECTORIES false RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} *.mm)
  list(APPEND SRC_FILES ${SRC_FILES_MM})
endif()

add_library(LVKLibrary ${SRC_FILES} ${HEADER_FILES})

lvk_setup_groups("${SRC_FILES}")
lvk_setup_groups("${HEADER_FILES}")

target_include_directories(LVKLibrary PUBLIC "${LVK_ROOT_DIR}/lvk")
if(WAYLAND_FOUND)
  target_compile_definitions(LVKLibrary PUBLIC -DLVK_WITH_WAYLAND=1)
endif()

lvk_setup_target(LVKLibrary)
lvk_set_folder(LVKLibrary "LVK")

add_subdirectory(vulkan)

target_link_libraries(LVKLibrary PUBLIC LVKVulkan)
if(LVK_WITH_GLFW)
  target_link_libraries(LVKLibrary PUBLIC glfw)
endif()

if(APPLE)
  target_link_libraries(LVKLibrary PRIVATE "-framework Metal" "-framework AppKit" "-framework Foundation" "-framework QuartzCore")
endif()

```

`lvk/HelpersImGui.cpp`:

```cpp
/*
* LightweightVK
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/

#include "HelpersImGui.h"

#include "imgui/imgui.cpp"
#include "imgui/imgui_draw.cpp"
#include "imgui/imgui_tables.cpp"
#include "imgui/imgui_widgets.cpp"
#if defined(LVK_WITH_IMPLOT)
#include "implot/implot.cpp"
#include "implot/implot_items.cpp"
#endif // LVK_WITH_IMPLOT

#if LVK_WITH_GLFW
#include "imgui/backends/imgui_impl_glfw.cpp"
#endif // LVK_WITH_GLFW

#include <math.h>

#include <vector>

namespace {

static const char* codeVS = R"(
layout (location = 0) out vec4 out_color;
layout (location = 1) out vec2 out_uv;

struct Vertex {
  float x, y;
  float u, v;
  uint rgba;
};

layout(std430, buffer_reference) readonly buffer VertexBuffer {
  Vertex vertices[];
};

layout(push_constant) uniform PushConstants {
  vec4 LRTB;
  VertexBuffer vb;
  uint textureId;
  uint samplerId;
} pc;

void main() {
  float L = pc.LRTB.x;
  float R = pc.LRTB.y;
  float T = pc.LRTB.z;
  float B = pc.LRTB.w;
  mat4 proj = mat4(
    2.0 / (R - L),                   0.0,  0.0, 0.0,
    0.0,                   2.0 / (T - B),  0.0, 0.0,
    0.0,                             0.0, -1.0, 0.0,
    (R + L) / (L - R), (T + B) / (B - T),  0.0, 1.0);
  Vertex v = pc.vb.vertices[gl_VertexIndex];
  out_color = unpackUnorm4x8(v.rgba);
  out_uv = vec2(v.u, v.v);
  gl_Position = proj * vec4(v.x, v.y, 0, 1);
})";

static const char* codeFS = R"(
layout (location = 0) in vec4 in_color;
layout (location = 1) in vec2 in_uv;

layout (location = 0) out vec4 out_color;

layout (constant_id = 0) const bool kNonLinearColorSpace = false;

layout(push_constant) uniform PushConstants {
  vec4 LRTB;
  vec2 vb;
  uint textureId;
  uint samplerId;
} pc;

void main() {
  vec4 c = in_color * texture(nonuniformEXT(sampler2D(kTextures2D[pc.textureId], kSamplers[pc.samplerId])), in_uv);
  // Render UI in linear color space to sRGB framebuffer.
  out_color = kNonLinearColorSpace ? vec4(pow(c.rgb, vec3(2.2)), c.a) : c;
})";

} // namespace

namespace lvk {

struct ImGuiRendererImpl {
  std::vector<lvk::Holder<lvk::TextureHandle>> textures_;
};

lvk::Holder<lvk::RenderPipelineHandle> ImGuiRenderer::createNewPipelineState(const lvk::Framebuffer& desc) {
  const uint32_t nonLinearColorSpace = ctx_.getSwapchainColorSpace() == ColorSpace_SRGB_NONLINEAR ? 1u : 0u;
  static_assert(LVK_MAX_COLOR_ATTACHMENTS == 8, "Update all color attachments below");
  return ctx_.createRenderPipeline(
      {
          .smVert = vert_,
          .smFrag = frag_,
          .specInfo = {.entries = {{.constantId = 0, .size = sizeof(nonLinearColorSpace)}},
                       .data = &nonLinearColorSpace,
                       .dataSize = sizeof(nonLinearColorSpace)},
          .color = {{.format = ctx_.getFormat(desc.color[0].texture),
                     .blendEnabled = true,
                     .srcRGBBlendFactor = lvk::BlendFactor_SrcAlpha,
                     .dstRGBBlendFactor = lvk::BlendFactor_OneMinusSrcAlpha},
                    {.format = desc.color[1].texture ? ctx_.getFormat(desc.color[1].texture) : lvk::Format_Invalid},
                    {.format = desc.color[2].texture ? ctx_.getFormat(desc.color[2].texture) : lvk::Format_Invalid},
                    {.format = desc.color[3].texture ? ctx_.getFormat(desc.color[3].texture) : lvk::Format_Invalid},
                    {.format = desc.color[4].texture ? ctx_.getFormat(desc.color[4].texture) : lvk::Format_Invalid},
                    {.format = desc.color[5].texture ? ctx_.getFormat(desc.color[5].texture) : lvk::Format_Invalid},
                    {.format = desc.color[6].texture ? ctx_.getFormat(desc.color[6].texture) : lvk::Format_Invalid},
                    {.format = desc.color[7].texture ? ctx_.getFormat(desc.color[7].texture) : lvk::Format_Invalid}},
          .depthFormat = desc.depthStencil.texture ? ctx_.getFormat(desc.depthStencil.texture) : lvk::Format_Invalid,
          .cullMode = lvk::CullMode_None,
          .debugName = "ImGuiRenderer: createNewPipelineState()",
      },
      nullptr);
}

ImGuiRenderer::ImGuiRenderer(lvk::IContext& device, lvk::LVKwindow* window, const char* defaultFontTTF, float fontSizePixels)
:  ctx_(device), pimpl_(new ImGuiRendererImpl) {
  ImGui::CreateContext();
#if defined(LVK_WITH_IMPLOT)
  ImPlot::CreateContext();
#endif // LVK_WITH_IMPLOT

  ImGuiIO& io = ImGui::GetIO();
  io.BackendRendererName = "imgui-lvk";
  io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset;
  io.BackendFlags |= ImGuiBackendFlags_RendererHasTextures;
  io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;
  io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;

#if LVK_WITH_GLFW
  ImGui_ImplGlfw_InitForOther(window, window ? true : false);
#endif // LVK_WITH_GLFW

  updateFont(defaultFontTTF, fontSizePixels);

  vert_ = ctx_.createShaderModule({codeVS, Stage_Vert, "Shader Module: imgui (vert)"});
  frag_ = ctx_.createShaderModule({codeFS, Stage_Frag, "Shader Module: imgui (frag)"});
  samplerClamp_ = ctx_.createSampler({
      .wrapU = lvk::SamplerWrap_Clamp,
      .wrapV = lvk::SamplerWrap_Clamp,
      .wrapW = lvk::SamplerWrap_Clamp,
  });
}

ImGuiRenderer::~ImGuiRenderer() {
  ImGuiIO& io = ImGui::GetIO();
  io.Fonts->TexRef = ImTextureRef();
#if LVK_WITH_GLFW
  ImGui_ImplGlfw_Shutdown();
#endif // LVK_WITH_GLFW
#if defined(LVK_WITH_IMPLOT)
  ImPlot::DestroyContext();
#endif // LVK_WITH_IMPLOT
  ImGui::DestroyContext();

  delete (pimpl_);
}

void ImGuiRenderer::updateFont(const char* defaultFontTTF, float fontSizePixels) {
  ImGuiIO& io = ImGui::GetIO();

  ImFontConfig cfg = ImFontConfig();
  cfg.FontDataOwnedByAtlas = true;
  cfg.RasterizerMultiply = 1.5f;
  cfg.SizePixels = ceilf(fontSizePixels);
  cfg.PixelSnapH = true;
  cfg.OversampleH = 4;
  cfg.OversampleV = 4;
  ImFont* font = nullptr;
  if (defaultFontTTF) {
    font = io.Fonts->AddFontFromFileTTF(defaultFontTTF, cfg.SizePixels, &cfg);
  } else {
    font = io.Fonts->AddFontDefault(&cfg);
  }

  io.Fonts->Flags |= ImFontAtlasFlags_NoPowerOfTwoHeight;

  // init fonts
  io.FontDefault = font;
  if ((io.BackendFlags & ImGuiBackendFlags_RendererHasTextures) == 0) {
    unsigned char* pixels;
    int width, height;
    io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);
    fontTexture_ = ctx_.createTexture({.type = lvk::TextureType_2D,
                                       .format = lvk::Format_RGBA_UN8,
                                       .dimensions = {(uint32_t)width, (uint32_t)height},
                                       .usage = lvk::TextureUsageBits_Sampled,
                                       .data = pixels},
                                      "ImGuiRenderer::fontTexture_");
    io.Fonts->TexID = fontTexture_.index();
  }
}

void ImGuiRenderer::beginFrame(const lvk::Framebuffer& desc) {
  const lvk::Dimensions dim = ctx_.getDimensions(desc.color[0].texture);

  ImGuiIO& io = ImGui::GetIO();
  io.DisplaySize = ImVec2(dim.width / displayScale_, dim.height / displayScale_);
  io.DisplayFramebufferScale = ImVec2(displayScale_, displayScale_);
  io.IniFilename = nullptr;

  if (pipeline_.empty()) {
    pipeline_ = createNewPipelineState(desc);
  }
#if LVK_WITH_GLFW
  ImGui_ImplGlfw_NewFrame();
#endif // LVK_WITH_GLFW
  ImGui::NewFrame();
}

void ImGuiRenderer::endFrame(lvk::ICommandBuffer& cmdBuffer) {
  static_assert(sizeof(ImDrawIdx) == 2);
  LVK_ASSERT_MSG(sizeof(ImDrawIdx) == 2, "The constants below may not work with the ImGui data.");

  ImGui::EndFrame();
  ImGui::Render();

  ImDrawData* dd = ImGui::GetDrawData();

  const float fb_width = dd->DisplaySize.x * dd->FramebufferScale.x;
  const float fb_height = dd->DisplaySize.y * dd->FramebufferScale.y;
  if (fb_width <= 0 || fb_height <= 0 || dd->CmdListsCount == 0) {
    return;
  }

  if (dd->Textures) {
    for (ImTextureData* tex : *dd->Textures) {
      switch (tex->Status) {
      case ImTextureStatus_OK:
        continue;
      case ImTextureStatus_Destroyed:
        continue;
      case ImTextureStatus_WantCreate:
        LVK_ASSERT(tex->TexID == ImTextureID_Invalid && !tex->BackendUserData);
        LVK_ASSERT(tex->Format == ImTextureFormat_RGBA32);
        LVK_ASSERT(tex->BytesPerPixel == 4);
        pimpl_->textures_.emplace_back(ctx_.createTexture({
            .type = lvk::TextureType_2D,
            .format = lvk::Format_RGBA_UN8,
            .dimensions = {(uint32_t)tex->Width, (uint32_t)tex->Height},
            .usage = lvk::TextureUsageBits_Sampled,
            .data = tex->Pixels,
            .debugName = "ImGuiTexture",
        }));
        tex->SetTexID((ImTextureID)pimpl_->textures_.back().index());
        tex->BackendUserData = pimpl_->textures_.back().handleAsVoid();
        tex->SetStatus(ImTextureStatus_OK);
        continue;
      case ImTextureStatus_WantUpdates:
        LVK_ASSERT(tex->Format == ImTextureFormat_RGBA32);
        LVK_ASSERT(tex->BytesPerPixel == 4);
        ctx_.upload(TextureHandle(tex->BackendUserData),
                    TextureRangeDesc{
                        .offset = {tex->UpdateRect.x, tex->UpdateRect.y, 0},
                        .dimensions = {tex->UpdateRect.w, tex->UpdateRect.h, 1},
                    },
                    tex->GetPixelsAt(tex->UpdateRect.x, tex->UpdateRect.y),
                    tex->Width);
        tex->SetStatus(ImTextureStatus_OK);
        continue;
      case ImTextureStatus_WantDestroy:
        for (lvk::Holder<TextureHandle>& holder : pimpl_->textures_) {
          if (holder.handleAsVoid() == tex->BackendUserData) {
            holder = std::move(pimpl_->textures_.back());
            pimpl_->textures_.pop_back();
            break;
          }
        }
        tex->SetTexID(ImTextureID_Invalid);
        tex->SetStatus(ImTextureStatus_Destroyed);
        tex->BackendUserData = nullptr;
        continue;
      }
    }
  }

  cmdBuffer.cmdPushDebugGroupLabel("ImGui Rendering", 0xff00ff00);
  cmdBuffer.cmdBindDepthState({});
  cmdBuffer.cmdBindViewport({
      .x = 0.0f,
      .y = 0.0f,
      .width = fb_width,
      .height = fb_height,
  });

  const float L = dd->DisplayPos.x;
  const float R = dd->DisplayPos.x + dd->DisplaySize.x;
  const float T = dd->DisplayPos.y;
  const float B = dd->DisplayPos.y + dd->DisplaySize.y;

  const ImVec2 clip_off = dd->DisplayPos;
  const ImVec2 clip_scale = dd->FramebufferScale;

  DrawableData& drawableData = drawables_[frameIndex_];
  frameIndex_ = (frameIndex_ + 1) % LVK_ARRAY_NUM_ELEMENTS(drawables_);

  if (drawableData.numAllocatedIndices_ < dd->TotalIdxCount) {
    drawableData.ib_ = ctx_.createBuffer({
        .usage = lvk::BufferUsageBits_Index,
        .storage = lvk::StorageType_HostVisible,
        .size = dd->TotalIdxCount * sizeof(ImDrawIdx),
        .debugName = "ImGui: drawableData.ib_",
    });
    drawableData.numAllocatedIndices_ = dd->TotalIdxCount;
  }
  if (drawableData.numAllocatedVerteices_ < dd->TotalVtxCount) {
    drawableData.vb_ = ctx_.createBuffer({
        .usage = lvk::BufferUsageBits_Storage,
        .storage = lvk::StorageType_HostVisible,
        .size = dd->TotalVtxCount * sizeof(ImDrawVert),
        .debugName = "ImGui: drawableData.vb_",
    });
    drawableData.numAllocatedVerteices_ = dd->TotalVtxCount;
  }

  // upload vertex/index buffers
  {
    ImDrawVert* vtx = (ImDrawVert*)ctx_.getMappedPtr(drawableData.vb_);
    uint16_t* idx = (uint16_t*)ctx_.getMappedPtr(drawableData.ib_);
    for (const ImDrawList* cmdList : dd->CmdLists) {
      memcpy(vtx, cmdList->VtxBuffer.Data, cmdList->VtxBuffer.Size * sizeof(ImDrawVert));
      memcpy(idx, cmdList->IdxBuffer.Data, cmdList->IdxBuffer.Size * sizeof(ImDrawIdx));
      vtx += cmdList->VtxBuffer.Size;
      idx += cmdList->IdxBuffer.Size;
    }
    ctx_.flushMappedMemory(drawableData.vb_, 0, dd->TotalVtxCount * sizeof(ImDrawVert));
    ctx_.flushMappedMemory(drawableData.ib_, 0, dd->TotalIdxCount * sizeof(ImDrawIdx));
  }

  uint32_t idxOffset = 0;
  uint32_t vtxOffset = 0;

  cmdBuffer.cmdBindIndexBuffer(drawableData.ib_, lvk::IndexFormat_UI16);
  cmdBuffer.cmdBindRenderPipeline(pipeline_);

  for (const ImDrawList* cmdList : dd->CmdLists) {
    for (int cmd_i = 0; cmd_i < cmdList->CmdBuffer.Size; cmd_i++) {
      const ImDrawCmd cmd = cmdList->CmdBuffer[cmd_i];
      LVK_ASSERT(cmd.UserCallback == nullptr);

      ImVec2 clipMin((cmd.ClipRect.x - clip_off.x) * clip_scale.x, (cmd.ClipRect.y - clip_off.y) * clip_scale.y);
      ImVec2 clipMax((cmd.ClipRect.z - clip_off.x) * clip_scale.x, (cmd.ClipRect.w - clip_off.y) * clip_scale.y);
      // clang-format off
      if (clipMin.x < 0.0f) clipMin.x = 0.0f;
      if (clipMin.y < 0.0f) clipMin.y = 0.0f;
      if (clipMax.x > fb_width ) clipMax.x = fb_width;
      if (clipMax.y > fb_height) clipMax.y = fb_height;
      if (clipMax.x <= clipMin.x || clipMax.y <= clipMin.y)
         continue;
      // clang-format on
      struct VulkanImguiBindData {
        float LRTB[4]; // ortho projection: left, right, top, bottom
        uint64_t vb = 0;
        uint32_t textureId = 0;
        uint32_t samplerId = 0;
      } bindData = {
          .LRTB = {L, R, T, B},
          .vb = ctx_.gpuAddress(drawableData.vb_),
          .textureId = static_cast<uint32_t>(cmd.GetTexID()),
          .samplerId = samplerClamp_.index(),
      };
      cmdBuffer.cmdPushConstants(bindData);
      cmdBuffer.cmdBindScissorRect(
          {uint32_t(clipMin.x), uint32_t(clipMin.y), uint32_t(clipMax.x - clipMin.x), uint32_t(clipMax.y - clipMin.y)});
      cmdBuffer.cmdDrawIndexed(cmd.ElemCount, 1u, idxOffset + cmd.IdxOffset, int32_t(vtxOffset + cmd.VtxOffset));
    }
    idxOffset += cmdList->IdxBuffer.Size;
    vtxOffset += cmdList->VtxBuffer.Size;
  }

  cmdBuffer.cmdPopDebugGroupLabel();
}

void ImGuiRenderer::setDisplayScale(float displayScale) {
  displayScale_ = displayScale;
}

} // namespace lvk

```

`lvk/HelpersImGui.h`:

```h
/*
* LightweightVK
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/

#pragma once

#if !defined(IMGUI_DEFINE_MATH_OPERATORS)
#define IMGUI_DEFINE_MATH_OPERATORS
#endif // !defined(IMGUI_DEFINE_MATH_OPERATORS)

#include <lvk/LVK.h>
#include <imgui/imgui.h>

namespace lvk {

class ImGuiRenderer {
 public:
  explicit ImGuiRenderer(lvk::IContext& device, lvk::LVKwindow* window, const char* defaultFontTTF = nullptr, float fontSizePixels = 24.0f);
  ~ImGuiRenderer();
  
  void updateFont(const char* defaultFontTTF, float fontSizePixels);

  void beginFrame(const lvk::Framebuffer& desc);
  void endFrame(lvk::ICommandBuffer& cmdBuffer);
  
  void setDisplayScale(float displayScale);

 private:
  lvk::Holder<lvk::RenderPipelineHandle> createNewPipelineState(const lvk::Framebuffer& desc);

 private:
  lvk::IContext& ctx_;
  lvk::Holder<lvk::ShaderModuleHandle> vert_;
  lvk::Holder<lvk::ShaderModuleHandle> frag_;
  lvk::Holder<lvk::RenderPipelineHandle> pipeline_;
  lvk::Holder<lvk::TextureHandle> fontTexture_;
  lvk::Holder<lvk::SamplerHandle> samplerClamp_;
  struct ImGuiRendererImpl* pimpl_ = nullptr;
  float displayScale_ = 1.0f;

  uint32_t frameIndex_ = 0;

  struct DrawableData {
    lvk::Holder<BufferHandle> vb_;
    lvk::Holder<BufferHandle> ib_;
    uint32_t numAllocatedIndices_ = 0;
    uint32_t numAllocatedVerteices_ = 0;
  };

  DrawableData drawables_[3] = {};
};

} // namespace lvk

```

`lvk/LVK.cpp`:

```cpp
/*
 * LightweightVK
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#include "LVK.h"

#include <assert.h>

#define NOMINMAX
#define WIN32_LEAN_AND_MEAN

#if LVK_WITH_GLFW
#define GLFW_INCLUDE_NONE
#include <GLFW/glfw3.h>

// clang-format off
#ifdef _WIN32
#  define GLFW_EXPOSE_NATIVE_WIN32
#elif defined(__linux__)
#  if defined(LVK_WITH_WAYLAND)
#    define GLFW_EXPOSE_NATIVE_WAYLAND
#  else
#    define GLFW_EXPOSE_NATIVE_X11
#  endif
#elif __APPLE__
#  define GLFW_EXPOSE_NATIVE_COCOA
#else
#  error Unsupported OS
#endif
// clang-format on

#include <GLFW/glfw3native.h>
#endif // LVK_WITH_GLFW

#include <lvk/vulkan/VulkanClasses.h>

namespace {

struct TextureFormatProperties {
  const lvk::Format format = lvk::Format_Invalid;
  const uint8_t bytesPerBlock : 5 = 1;
  const uint8_t blockWidth : 3 = 1;
  const uint8_t blockHeight : 3 = 1;
  const uint8_t minBlocksX : 2 = 1;
  const uint8_t minBlocksY : 2 = 1;
  const bool depth : 1 = false;
  const bool stencil : 1 = false;
  const bool compressed : 1 = false;
  const uint8_t numPlanes : 2 = 1;
};

// clang-format off
#define PROPS(fmt, bpb, ...) \
  TextureFormatProperties { .format = lvk::Format_##fmt, .bytesPerBlock = bpb, ##__VA_ARGS__ }
// clang-format on

static constexpr TextureFormatProperties properties[] = {
    PROPS(Invalid, 1),
    PROPS(R_UN8, 1),
    PROPS(R_UI16, 2),
    PROPS(R_UI32, 4),
    PROPS(R_UN16, 2),
    PROPS(R_F16, 2),
    PROPS(R_F32, 4),
    PROPS(RG_UN8, 2),
    PROPS(RG_UI16, 4),
    PROPS(RG_UI32, 8),
    PROPS(RG_UN16, 4),
    PROPS(RG_F16, 4),
    PROPS(RG_F32, 8),
    PROPS(RGBA_UN8, 4),
    PROPS(RGBA_UI32, 16),
    PROPS(RGBA_F16, 8),
    PROPS(RGBA_F32, 16),
    PROPS(RGBA_SRGB8, 4),
    PROPS(BGRA_UN8, 4),
    PROPS(BGRA_SRGB8, 4),
    PROPS(A2B10G10R10_UN, 4),
    PROPS(A2R10G10B10_UN, 4),
    PROPS(ETC2_RGB8, 8, .blockWidth = 4, .blockHeight = 4, .compressed = true),
    PROPS(ETC2_SRGB8, 8, .blockWidth = 4, .blockHeight = 4, .compressed = true),
    PROPS(BC7_RGBA, 16, .blockWidth = 4, .blockHeight = 4, .compressed = true),
    PROPS(Z_UN16, 2, .depth = true),
    PROPS(Z_UN24, 3, .depth = true),
    PROPS(Z_F32, 4, .depth = true),
    PROPS(Z_UN24_S_UI8, 4, .depth = true, .stencil = true),
    PROPS(Z_F32_S_UI8, 5, .depth = true, .stencil = true),
    PROPS(YUV_NV12, 24, .blockWidth = 4, .blockHeight = 4, .compressed = true, .numPlanes = 2), // Subsampled 420
    PROPS(YUV_420p, 24, .blockWidth = 4, .blockHeight = 4, .compressed = true, .numPlanes = 3), // Subsampled 420
};

} // namespace

#if __APPLE__ && LVK_WITH_GLFW
void* createCocoaWindowView(GLFWwindow* window, void** outLayer);
#endif

static_assert(sizeof(TextureFormatProperties) <= sizeof(uint32_t));
static_assert(LVK_ARRAY_NUM_ELEMENTS(properties) == lvk::Format_YUV_420p + 1);

bool lvk::isDepthOrStencilFormat(lvk::Format format) {
  return properties[format].depth || properties[format].stencil;
}

uint32_t lvk::getNumImagePlanes(lvk::Format format) {
  return properties[format].numPlanes;
}

uint32_t lvk::getVertexFormatSize(lvk::VertexFormat format) {
  // clang-format off
#define SIZE4(LVKBaseType, BaseType)           \
  case VertexFormat::LVKBaseType##1: return sizeof(BaseType) * 1u; \
  case VertexFormat::LVKBaseType##2: return sizeof(BaseType) * 2u; \
  case VertexFormat::LVKBaseType##3: return sizeof(BaseType) * 3u; \
  case VertexFormat::LVKBaseType##4: return sizeof(BaseType) * 4u;
#define SIZE2_4_NORM(LVKBaseType, BaseType)           \
  case VertexFormat::LVKBaseType##2Norm: return sizeof(BaseType) * 2u; \
  case VertexFormat::LVKBaseType##4Norm: return sizeof(BaseType) * 4u;

  // clang-format on

  switch (format) {
    SIZE4(Float, float);
    SIZE4(Byte, uint8_t);
    SIZE4(UByte, uint8_t);
    SIZE4(Short, uint16_t);
    SIZE4(UShort, uint16_t);
    SIZE2_4_NORM(Byte, uint8_t);
    SIZE2_4_NORM(UByte, uint8_t);
    SIZE2_4_NORM(Short, uint16_t);
    SIZE2_4_NORM(UShort, uint16_t);
    SIZE4(Int, uint32_t);
    SIZE4(UInt, uint32_t);
    SIZE4(HalfFloat, uint16_t);
  case VertexFormat::Int_2_10_10_10_REV:
    return sizeof(uint32_t);
  default:
    assert(false);
    return 0;
  }
#undef SIZE4
#undef SIZE2_4_NORM
}

uint32_t lvk::getTextureBytesPerLayer(uint32_t width, uint32_t height, lvk::Format format, uint32_t level) {
  const uint32_t levelWidth = std::max(width >> level, 1u);
  const uint32_t levelHeight = std::max(height >> level, 1u);

  const TextureFormatProperties props = properties[format];

  if (!props.compressed) {
    return props.bytesPerBlock * levelWidth * levelHeight;
  }

  const uint32_t blockWidth = std::max((uint32_t)props.blockWidth, 1u);
  const uint32_t blockHeight = std::max((uint32_t)props.blockHeight, 1u);
  const uint32_t widthInBlocks = (levelWidth + props.blockWidth - 1) / props.blockWidth;
  const uint32_t heightInBlocks = (levelHeight + props.blockHeight - 1) / props.blockHeight;
  return widthInBlocks * heightInBlocks * props.bytesPerBlock;
}

uint32_t lvk::getTextureBytesPerPlane(uint32_t width, uint32_t height, lvk::Format format, uint32_t plane) {
  const TextureFormatProperties props = properties[format];

  LVK_ASSERT(plane < props.numPlanes);

  switch (format) {
  case Format_YUV_NV12:
    return width * height / (plane + 1);
  case Format_YUV_420p:
    return width * height / (plane ? 4 : 1);
  default:;
  }

  return getTextureBytesPerLayer(width, height, format, 0);
}

bool lvk::Assert(bool cond, const char* file, int line, const char* format, ...) {
  if (!cond) {
    va_list ap;
    va_start(ap, format);
    LLOGW("[LVK] Assertion failed in %s:%d: ", file, line);
    MINILOG_LOG_PROC(minilog::Warning, format, ap);
    LLOGW("\n");
    va_end(ap);
    assert(false);
  }
  return cond;
}

void lvk::destroy(lvk::IContext* ctx, lvk::ComputePipelineHandle handle) {
  if (ctx) {
    ctx->destroy(handle);
  }
}

void lvk::destroy(lvk::IContext* ctx, lvk::RenderPipelineHandle handle) {
  if (ctx) {
    ctx->destroy(handle);
  }
}

void lvk::destroy(lvk::IContext* ctx, lvk::RayTracingPipelineHandle handle) {
  if (ctx) {
    ctx->destroy(handle);
  }
}

void lvk::destroy(lvk::IContext* ctx, lvk::ShaderModuleHandle handle) {
  if (ctx) {
    ctx->destroy(handle);
  }
}

void lvk::destroy(lvk::IContext* ctx, lvk::SamplerHandle handle) {
  if (ctx) {
    ctx->destroy(handle);
  }
}

void lvk::destroy(lvk::IContext* ctx, lvk::BufferHandle handle) {
  if (ctx) {
    ctx->destroy(handle);
  }
}

void lvk::destroy(lvk::IContext* ctx, lvk::TextureHandle handle) {
  if (ctx) {
    ctx->destroy(handle);
  }
}

void lvk::destroy(lvk::IContext* ctx, lvk::QueryPoolHandle handle) {
  if (ctx) {
    ctx->destroy(handle);
  }
}

void lvk::destroy(lvk::IContext* ctx, lvk::AccelStructHandle handle) {
  if (ctx) {
    ctx->destroy(handle);
  }
}

// Logs GLSL shaders with line numbers annotation
void lvk::logShaderSource(const char* text) {
  uint32_t line = 0;
  uint32_t numChars = 0;
  const char* lineStart = text;

  while (text && *text) {
    if (*text == '\n') {
      if (numChars) {
#if defined(MINILOG_RAW_OUTPUT)
        LLOGL("(%3u) %.*s\n", ++line, numChars, lineStart);
#else
        LLOGL("(%3u) %.*s", ++line, numChars, lineStart);
#endif // MINILOG_RAW_OUTPUT
      } else {
#if defined(MINILOG_RAW_OUTPUT)
        LLOGL("(%3u)\n", ++line);
#else
        LLOGL("(%3u)", ++line);
#endif // MINILOG_RAW_OUTPUT
      }
      numChars = 0;
      lineStart = text + 1;
    } else if (*text == '\r') {
      // skip it to support Windows/UNIX EOLs
      numChars = 0;
      lineStart = text + 1;
    } else {
      numChars++;
    }
    text++;
  }
  if (numChars) {
#if defined(MINILOG_RAW_OUTPUT)
    LLOGL("(%3u) %.*s\n", ++line, numChars, lineStart);
#else
    LLOGL("(%3u) %.*s", ++line, numChars, lineStart);
#endif // MINILOG_RAW_OUTPUT
  }
  LLOGL("\n");
}

uint32_t lvk::VertexInput::getVertexSize() const {
  uint32_t vertexSize = 0;
  for (uint32_t i = 0; i < LVK_VERTEX_ATTRIBUTES_MAX && attributes[i].format != VertexFormat::Invalid; i++) {
    LVK_ASSERT_MSG(attributes[i].offset == vertexSize, "Unsupported vertex attributes format");
    vertexSize += lvk::getVertexFormatSize(attributes[i].format);
  }
  return vertexSize;
}

#if LVK_WITH_GLFW
lvk::LVKwindow* lvk::initWindow(const char* windowTitle, int& outWidth, int& outHeight, bool resizable, bool headless) {
  if (!glfwInit()) {
    LVK_ASSERT_MSG(headless, "glfwInit() failed. Make sure the headless mode is enabled");
    return nullptr;
  }

  const bool wantsWholeArea = outWidth <= 0 || outHeight <= 0;

  glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
  glfwWindowHint(GLFW_RESIZABLE, wantsWholeArea || !resizable ? GLFW_FALSE : GLFW_TRUE);

  // render full screen without overlapping taskbar
  GLFWmonitor* monitor = glfwGetPrimaryMonitor();

  int x = 0;
  int y = 0;
  int w = outWidth;
  int h = outHeight;

  if (wantsWholeArea) {
    int areaW = 0;
    int areaH = 0;
    glfwGetMonitorWorkarea(monitor, &x, &y, &areaW, &areaH);
    auto getPercent = [](int value, int percent) {
      assert(percent > 0 && percent <= 100);
      return static_cast<int>(static_cast<float>(value) * static_cast<float>(percent) / 100.0f);
    };
    if (outWidth < 0) {
      w = getPercent(areaW, -outWidth);
      x = (areaW - w) / 2;
    } else {
      w = areaW;
    }
    if (outHeight < 0) {
      h = getPercent(areaH, -outHeight);
      y = (areaH - h) / 2;
    } else {
      h = areaH;
    }
  }

  GLFWwindow* window = glfwCreateWindow(w, h, windowTitle, nullptr, nullptr);

  if (!window) {
    glfwTerminate();
    return nullptr;
  }

  if (wantsWholeArea) {
    glfwSetWindowPos(window, x, y);
  }

  glfwGetWindowSize(window, &outWidth, &outHeight);

  glfwSetKeyCallback(window, [](GLFWwindow* window, int key, int, int action, int) {
    if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS) {
      glfwSetWindowShouldClose(window, GLFW_TRUE);
    }
  });

  glfwSetErrorCallback([](int error, const char* description) { printf("GLFW Error (%i): %s\n", error, description); });

  return window;
}
#endif // LVK_WITH_GLFW

#if LVK_WITH_GLFW || defined(ANDROID)
std::unique_ptr<lvk::IContext> lvk::createVulkanContextWithSwapchain(LVKwindow* window,
                                                                     uint32_t width,
                                                                     uint32_t height,
                                                                     const lvk::ContextConfig& cfg,
                                                                     lvk::HWDeviceType preferredDeviceType,
                                                                     int selectedDevice) {
  using namespace lvk;

  std::unique_ptr<VulkanContext> ctx;

#if defined(_WIN32)
  ctx = std::make_unique<VulkanContext>(cfg, (void*)glfwGetWin32Window(window));
#elif defined(ANDROID)
  ctx = std::make_unique<VulkanContext>(cfg, (void*)window);
#elif defined(__linux__)
#if defined(LVK_WITH_WAYLAND)
  wl_surface* waylandWindow = glfwGetWaylandWindow(window);
  if (!cfg.enableHeadlessSurface && !waylandWindow) {
    LVK_ASSERT_MSG(false, "Wayland window not found");
    return nullptr;
  }
  ctx = std::make_unique<VulkanContext>(cfg, (void*)waylandWindow, (void*)glfwGetWaylandDisplay());
#else
  ctx = std::make_unique<VulkanContext>(cfg, (void*)glfwGetX11Window(window), (void*)glfwGetX11Display());
#endif
#elif defined(__APPLE__)
  void* layer = nullptr;
  void* contentView = createCocoaWindowView(window, &layer);
  ctx = std::make_unique<VulkanContext>(cfg, contentView, layer);
#else
#error Unsupported OS
#endif

  HWDeviceDesc devices[16];
  const uint32_t numDevices = ctx->queryDevices(devices, LVK_ARRAY_NUM_ELEMENTS(devices));

  if (!numDevices) {
    LVK_ASSERT_MSG(false, "GPU is not found");
    return nullptr;
  }

  if (selectedDevice < 0) {
    selectedDevice = [preferredDeviceType, &devices, numDevices]() -> int {
      // define device type priority order
      HWDeviceType priority[4] = {preferredDeviceType};
      {
        int index = 1;
        for (int type = HWDeviceType_Integrated; type <= HWDeviceType_Software; type++) {
          if (type != preferredDeviceType)
            priority[index++] = (HWDeviceType)type;
        }
      }
      // search devices in priority order
      for (HWDeviceType type : priority) {
        for (uint32_t i = 0; i < numDevices; i++) {
          if (devices[i].type == type)
            return (int)i;
        }
      }
      return 0;
    }();
  }

  if (selectedDevice >= numDevices) {
    LVK_ASSERT_MSG(false, "Invalid device index");
    return nullptr;
  }

  Result res = ctx->initContext(devices[selectedDevice]);

  if (!res.isOk()) {
    LVK_ASSERT_MSG(false, "createVulkanContextWithSwapchain() failed");
    return nullptr;
  }

  if (width > 0 && height > 0) {
    res = ctx->initSwapchain(width, height);
    if (!res.isOk()) {
      LVK_ASSERT_MSG(false, "initSwapchain() failed");
      return nullptr;
    }
  }

  return std::move(ctx);
}
#endif // LVK_WITH_GLFW || defined(ANDROID)

```

`lvk/LVK.h`:

```h
/*
 * LightweightVK
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#pragma once

#include <cstdarg>
#include <cstddef>
#include <cstdint>
#include <cstring>
#include <memory>
#include <utility>

#include <minilog/minilog.h>

#if defined(ANDROID)
#include <android/native_window.h>
#endif

// clang-format off
#if defined(LVK_WITH_TRACY)
  #include "tracy/Tracy.hpp"
  // predefined RGB colors for "heavy" point-of-interest operations
  #define LVK_PROFILER_COLOR_WAIT 0xff0000
  #define LVK_PROFILER_COLOR_SUBMIT 0x0000ff
  #define LVK_PROFILER_COLOR_PRESENT 0x00ff00
  #define LVK_PROFILER_COLOR_CREATE 0xff6600
  #define LVK_PROFILER_COLOR_DESTROY 0xffa500
  #define LVK_PROFILER_COLOR_BARRIER 0xffffff
  #define LVK_PROFILER_COLOR_CMD_DRAW 0x8b0000
  #define LVK_PROFILER_COLOR_CMD_COPY 0x8b0a50
  #define LVK_PROFILER_COLOR_CMD_RTX 0x8b0000
  #define LVK_PROFILER_COLOR_CMD_DISPATCH 0x8b0000
  //
  #define LVK_PROFILER_FUNCTION() ZoneScoped
  #define LVK_PROFILER_FUNCTION_COLOR(color) ZoneScopedC(color)
  #define LVK_PROFILER_ZONE(name, color) \
    {                                    \
      ZoneScopedC(color);                \
      ZoneName(name, strlen(name))
  #define LVK_PROFILER_ZONE_END() }
  #define LVK_PROFILER_THREAD(name) tracy::SetThreadName(name)
  #define LVK_PROFILER_FRAME(name) FrameMarkNamed(name)
#else
  #define LVK_PROFILER_FUNCTION()
  #define LVK_PROFILER_FUNCTION_COLOR(color)
  #define LVK_PROFILER_ZONE(name, color) {
  #define LVK_PROFILER_ZONE_END() }
  #define LVK_PROFILER_THREAD(name)
  #define LVK_PROFILER_FRAME(name)
#endif // LVK_WITH_TRACY
// clang-format on

#define LVK_ARRAY_NUM_ELEMENTS(x) (sizeof(x) / sizeof((x)[0]))

namespace lvk {

class IContext;

bool Assert(bool cond, const char* file, int line, const char* format, ...);

// Non-ref counted handles; based on:
// https://enginearchitecture.realtimerendering.com/downloads/reac2023_modern_mobile_rendering_at_hypehype.pdf
template<typename ObjectType>
class Handle final {
 public:
  Handle() = default;
  explicit Handle(void* ptr)
  : index_(reinterpret_cast<ptrdiff_t>(ptr) & 0xffffffff)
  , gen_((reinterpret_cast<ptrdiff_t>(ptr) >> 32) & 0xffffffff) {}

  bool empty() const {
    return gen_ == 0;
  }
  bool valid() const {
    return gen_ != 0;
  }
  uint32_t index() const {
    return index_;
  }
  uint32_t gen() const {
    return gen_;
  }
  void* indexAsVoid() const {
    return reinterpret_cast<void*>(static_cast<ptrdiff_t>(index_));
  }
  void* handleAsVoid() const {
    static_assert(sizeof(void*) >= sizeof(uint64_t));
    return reinterpret_cast<void*>((static_cast<ptrdiff_t>(gen_) << 32) + static_cast<ptrdiff_t>(index_));
  }
  bool operator==(const Handle<ObjectType>& other) const {
    return index_ == other.index_ && gen_ == other.gen_;
  }
  bool operator!=(const Handle<ObjectType>& other) const {
    return index_ != other.index_ || gen_ != other.gen_;
  }
  // allow conditions 'if (handle)'
  explicit operator bool() const {
    return gen_ != 0;
  }

 private:
  Handle(uint32_t index, uint32_t gen) : index_(index), gen_(gen) {};

  template<typename ObjectType_, typename ImplObjectType>
  friend class Pool;

  uint32_t index_ = 0;
  uint32_t gen_ = 0;
};

static_assert(sizeof(Handle<class Foo>) == sizeof(uint64_t));

// specialized with dummy structs for type safety
using ComputePipelineHandle = lvk::Handle<struct ComputePipeline>;
using RenderPipelineHandle = lvk::Handle<struct RenderPipeline>;
using RayTracingPipelineHandle = lvk::Handle<struct RayTracingPipeline>;
using ShaderModuleHandle = lvk::Handle<struct ShaderModule>;
using SamplerHandle = lvk::Handle<struct Sampler>;
using BufferHandle = lvk::Handle<struct Buffer>;
using TextureHandle = lvk::Handle<struct Texture>;
using QueryPoolHandle = lvk::Handle<struct QueryPool>;
using AccelStructHandle = lvk::Handle<struct AccelerationStructure>;

// forward declarations to access incomplete type IContext
void destroy(lvk::IContext* ctx, lvk::ComputePipelineHandle handle);
void destroy(lvk::IContext* ctx, lvk::RenderPipelineHandle handle);
void destroy(lvk::IContext* ctx, lvk::RayTracingPipelineHandle handle);
void destroy(lvk::IContext* ctx, lvk::ShaderModuleHandle handle);
void destroy(lvk::IContext* ctx, lvk::SamplerHandle handle);
void destroy(lvk::IContext* ctx, lvk::BufferHandle handle);
void destroy(lvk::IContext* ctx, lvk::TextureHandle handle);
void destroy(lvk::IContext* ctx, lvk::QueryPoolHandle handle);
void destroy(lvk::IContext* ctx, lvk::AccelStructHandle handle);

template<typename HandleType>
class Holder final {
 public:
  Holder() = default;
  Holder(lvk::IContext* ctx, HandleType handle) : ctx_(ctx), handle_(handle) {}
  ~Holder() {
    lvk::destroy(ctx_, handle_);
  }
  Holder(const Holder&) = delete;
  Holder(Holder&& other) : ctx_(other.ctx_), handle_(other.handle_) {
    other.ctx_ = nullptr;
    other.handle_ = HandleType{};
  }
  Holder& operator=(const Holder&) = delete;
  Holder& operator=(Holder&& other) {
    std::swap(ctx_, other.ctx_);
    std::swap(handle_, other.handle_);
    return *this;
  }
  Holder& operator=(std::nullptr_t) {
    this->reset();
    return *this;
  }

  inline operator HandleType() const {
    return handle_;
  }

  bool valid() const {
    return handle_.valid();
  }

  bool empty() const {
    return handle_.empty();
  }

  void reset() {
    lvk::destroy(ctx_, handle_);
    ctx_ = nullptr;
    handle_ = HandleType{};
  }

  HandleType release() {
    ctx_ = nullptr;
    return std::exchange(handle_, HandleType{});
  }

  uint32_t gen() const {
    return handle_.gen();
  }
  uint32_t index() const {
    return handle_.index();
  }
  void* indexAsVoid() const {
    return handle_.indexAsVoid();
  }
  void* handleAsVoid() const {
    return handle_.handleAsVoid();
  }

 private:
  lvk::IContext* ctx_ = nullptr;
  HandleType handle_ = {};
};

} // namespace lvk

// clang-format off
#if !defined(NDEBUG) && (defined(DEBUG) || defined(_DEBUG) || defined(__DEBUG))
  #define LVK_VERIFY(cond) ::lvk::Assert((cond), __FILE__, __LINE__, #cond)
  #define LVK_ASSERT(cond) (void)LVK_VERIFY(cond)
  #define LVK_ASSERT_MSG(cond, format, ...) (void)::lvk::Assert((cond), __FILE__, __LINE__, (format), ##__VA_ARGS__)
#else
  #define LVK_VERIFY(cond) (cond)
  #define LVK_ASSERT(cond)
  #define LVK_ASSERT_MSG(cond, format, ...)
#endif
// clang-format on

namespace lvk {

enum { LVK_MAX_COLOR_ATTACHMENTS = 8 };
enum { LVK_MAX_MIP_LEVELS = 16 };

enum IndexFormat : uint8_t {
  IndexFormat_UI8,
  IndexFormat_UI16,
  IndexFormat_UI32,
};

enum Topology : uint8_t {
  Topology_Point,
  Topology_Line,
  Topology_LineStrip,
  Topology_Triangle,
  Topology_TriangleStrip,
  Topology_Patch,
};

enum ColorSpace : uint8_t {
  ColorSpace_SRGB_NONLINEAR,
  ColorSpace_SRGB_EXTENDED_LINEAR,
  ColorSpace_HDR10,
  ColorSpace_BT709_LINEAR,
};

enum PresentMode : uint8_t {
  PresentMode_FIFO = 0, // default mode
  PresentMode_FIFO_Relaxed,
  PresentMode_Immediate,
  PresentMode_Mailbox,
  PresentMode_Shared_Demand_Refresh, // VK_KHR_shared_presentable_image
  PresentMode_Shared_Continuous_Refresh, // VK_KHR_shared_presentable_image
  PresentMode_FIFO_Latest_Ready, // VK_KHR_present_mode_fifo_latest_ready
};

enum TextureType : uint8_t {
  TextureType_2D,
  TextureType_3D,
  TextureType_Cube,
};

enum SamplerFilter : uint8_t { SamplerFilter_Nearest = 0, SamplerFilter_Linear };
enum SamplerMip : uint8_t { SamplerMip_Disabled = 0, SamplerMip_Nearest, SamplerMip_Linear };
enum SamplerWrap : uint8_t {
  SamplerWrap_Repeat = 0,
  SamplerWrap_Clamp, // to edge
  SamplerWrap_ClampToBorder,
  SamplerWrap_MirrorRepeat,
  SamplerWrap_MirrorClampToEdge,
};

enum HWDeviceType {
  HWDeviceType_Integrated = 1,
  HWDeviceType_Discrete = 2,
  HWDeviceType_External = 3,
  HWDeviceType_Software = 4,
};

struct HWDeviceDesc {
  enum { LVK_MAX_PHYSICAL_DEVICE_NAME_SIZE = 256 };
  uintptr_t guid = 0;
  HWDeviceType type = HWDeviceType_Software;
  char name[LVK_MAX_PHYSICAL_DEVICE_NAME_SIZE] = {0};
};

enum StorageType {
  StorageType_Device,
  StorageType_HostVisible,
  StorageType_Memoryless,
};

enum CullMode : uint8_t { CullMode_None, CullMode_Front, CullMode_Back };
enum WindingMode : uint8_t { WindingMode_CCW, WindingMode_CW };

struct Result {
  enum class Code {
    Ok,
    ArgumentOutOfRange,
    RuntimeError,
  };

  Code code = Code::Ok;
  const char* message = "";
  explicit Result() = default;
  explicit Result(Code code, const char* message = "") : code(code), message(message) {}

  bool isOk() const {
    return code == Result::Code::Ok;
  }

  static void setResult(Result* outResult, Code code, const char* message = "") {
    if (outResult) {
      outResult->code = code;
      outResult->message = message;
    }
  }

  static void setResult(Result* outResult, const Result& sourceResult) {
    if (outResult) {
      *outResult = sourceResult;
    }
  }
};

struct ScissorRect {
  uint32_t x = 0;
  uint32_t y = 0;
  uint32_t width = 0;
  uint32_t height = 0;
};

struct Dimensions {
  uint32_t width = 1;
  uint32_t height = 1;
  uint32_t depth = 1;
  inline Dimensions divide1D(uint32_t v) const {
    return {.width = width / v, .height = height, .depth = depth};
  }
  inline Dimensions divide2D(uint32_t v) const {
    return {.width = width / v, .height = height / v, .depth = depth};
  }
  inline Dimensions divide3D(uint32_t v) const {
    return {.width = width / v, .height = height / v, .depth = depth / v};
  }
  inline bool operator==(const Dimensions& other) const {
    return width == other.width && height == other.height && depth == other.depth;
  }
};

struct Viewport {
  float x = 0.0f;
  float y = 0.0f;
  float width = 1.0f;
  float height = 1.0f;
  float minDepth = 0.0f;
  float maxDepth = 1.0f;
};

enum CompareOp : uint8_t {
  CompareOp_Never = 0,
  CompareOp_Less,
  CompareOp_Equal,
  CompareOp_LessEqual,
  CompareOp_Greater,
  CompareOp_NotEqual,
  CompareOp_GreaterEqual,
  CompareOp_AlwaysPass
};

enum StencilOp : uint8_t {
  StencilOp_Keep = 0,
  StencilOp_Zero,
  StencilOp_Replace,
  StencilOp_IncrementClamp,
  StencilOp_DecrementClamp,
  StencilOp_Invert,
  StencilOp_IncrementWrap,
  StencilOp_DecrementWrap
};

enum BlendOp : uint8_t {
  BlendOp_Add = 0,
  BlendOp_Subtract,
  BlendOp_ReverseSubtract,
  BlendOp_Min,
  BlendOp_Max,
};

enum BlendFactor : uint8_t {
  BlendFactor_Zero = 0,
  BlendFactor_One,
  BlendFactor_SrcColor,
  BlendFactor_OneMinusSrcColor,
  BlendFactor_SrcAlpha,
  BlendFactor_OneMinusSrcAlpha,
  BlendFactor_DstColor,
  BlendFactor_OneMinusDstColor,
  BlendFactor_DstAlpha,
  BlendFactor_OneMinusDstAlpha,
  BlendFactor_SrcAlphaSaturated,
  BlendFactor_BlendColor,
  BlendFactor_OneMinusBlendColor,
  BlendFactor_BlendAlpha,
  BlendFactor_OneMinusBlendAlpha,
  BlendFactor_Src1Color,
  BlendFactor_OneMinusSrc1Color,
  BlendFactor_Src1Alpha,
  BlendFactor_OneMinusSrc1Alpha
};

struct SamplerStateDesc {
  SamplerFilter minFilter = SamplerFilter_Linear;
  SamplerFilter magFilter = SamplerFilter_Linear;
  SamplerMip mipMap = SamplerMip_Disabled;
  SamplerWrap wrapU = SamplerWrap_Repeat;
  SamplerWrap wrapV = SamplerWrap_Repeat;
  SamplerWrap wrapW = SamplerWrap_Repeat;
  CompareOp depthCompareOp = CompareOp_LessEqual;
  uint8_t mipLodMin = 0;
  uint8_t mipLodMax = 15;
  uint8_t maxAnisotropic = 1;
  bool depthCompareEnabled = false;
  const char* debugName = "";
};

struct StencilState {
  StencilOp stencilFailureOp = StencilOp_Keep;
  StencilOp depthFailureOp = StencilOp_Keep;
  StencilOp depthStencilPassOp = StencilOp_Keep;
  CompareOp stencilCompareOp = CompareOp_AlwaysPass;
  uint32_t readMask = (uint32_t)~0;
  uint32_t writeMask = (uint32_t)~0;
};

struct DepthState {
  CompareOp compareOp = CompareOp_AlwaysPass;
  bool isDepthWriteEnabled = false;
};

enum PolygonMode : uint8_t {
  PolygonMode_Fill = 0,
  PolygonMode_Line = 1,
  PolygonMode_Point = 2,
};

enum class VertexFormat {
  Invalid = 0,

  Float1,
  Float2,
  Float3,
  Float4,

  Byte1,
  Byte2,
  Byte3,
  Byte4,

  UByte1,
  UByte2,
  UByte3,
  UByte4,

  Short1,
  Short2,
  Short3,
  Short4,

  UShort1,
  UShort2,
  UShort3,
  UShort4,

  Byte2Norm,
  Byte4Norm,

  UByte2Norm,
  UByte4Norm,

  Short2Norm,
  Short4Norm,

  UShort2Norm,
  UShort4Norm,

  Int1,
  Int2,
  Int3,
  Int4,

  UInt1,
  UInt2,
  UInt3,
  UInt4,

  HalfFloat1,
  HalfFloat2,
  HalfFloat3,
  HalfFloat4,

  Int_2_10_10_10_REV,
};

enum VertexInputRate : uint8_t {
  VertexInputRate_Vertex,
  VertexInputRate_Instance,
};

enum Format : uint8_t {
  Format_Invalid = 0,

  Format_R_UN8,
  Format_R_UI16,
  Format_R_UI32,
  Format_R_UN16,
  Format_R_F16,
  Format_R_F32,

  Format_RG_UN8,
  Format_RG_UI16,
  Format_RG_UI32,
  Format_RG_UN16,
  Format_RG_F16,
  Format_RG_F32,

  Format_RGBA_UN8,
  Format_RGBA_UI32,
  Format_RGBA_F16,
  Format_RGBA_F32,
  Format_RGBA_SRGB8,

  Format_BGRA_UN8,
  Format_BGRA_SRGB8,

  Format_A2B10G10R10_UN,
  Format_A2R10G10B10_UN,

  Format_ETC2_RGB8,
  Format_ETC2_SRGB8,
  Format_BC7_RGBA,

  Format_Z_UN16,
  Format_Z_UN24,
  Format_Z_F32,
  Format_Z_UN24_S_UI8,
  Format_Z_F32_S_UI8,

  Format_YUV_NV12,
  Format_YUV_420p,
};

enum LoadOp : uint8_t {
  LoadOp_Invalid = 0,
  LoadOp_DontCare,
  LoadOp_Load,
  LoadOp_Clear,
  LoadOp_None,
};

enum StoreOp : uint8_t {
  StoreOp_DontCare = 0,
  StoreOp_Store,
  StoreOp_MsaaResolve,
  StoreOp_None,
};

enum ResolveMode : uint8_t {
  ResolveMode_None = 0,
  ResolveMode_SampleZero, // always supported
  ResolveMode_Average,
  ResolveMode_Min,
  ResolveMode_Max,
};

enum ShaderStage : uint8_t {
  Stage_Vert,
  Stage_Tesc,
  Stage_Tese,
  Stage_Geom,
  Stage_Frag,
  Stage_Comp,
  Stage_Task,
  Stage_Mesh,
  // ray tracing
  Stage_RayGen,
  Stage_AnyHit,
  Stage_ClosestHit,
  Stage_Miss,
  Stage_Intersection,
  Stage_Callable,
};

union ClearColorValue {
  float float32[4];
  int32_t int32[4];
  uint32_t uint32[4];
};

struct VertexInput final {
  enum { LVK_VERTEX_ATTRIBUTES_MAX = 16 };
  enum { LVK_VERTEX_BUFFER_MAX = 16 };
  struct VertexAttribute final {
    uint32_t location = 0; // a buffer which contains this attribute stream
    uint32_t binding = 0;
    VertexFormat format = VertexFormat::Invalid; // per-element format
    uintptr_t offset = 0; // an offset where the first element of this attribute stream starts
  } attributes[LVK_VERTEX_ATTRIBUTES_MAX];
  struct VertexInputBinding final {
    uint32_t stride = 0;
    VertexInputRate inputRate = VertexInputRate::VertexInputRate_Vertex;
  } inputBindings[LVK_VERTEX_BUFFER_MAX];

  // clang-format off
  uint32_t getNumAttributes() const {
    uint32_t n = 0;
    while (n < LVK_VERTEX_ATTRIBUTES_MAX && attributes[n].format != VertexFormat::Invalid) n++;
    return n;
  }
  uint32_t getNumInputBindings() const {
    uint32_t n = 0;
    while (n < LVK_VERTEX_BUFFER_MAX && inputBindings[n].stride) n++;
    return n;
  }
  // clang-format on

  uint32_t getVertexSize() const;

  bool operator==(const VertexInput& other) const {
    return memcmp(this, &other, sizeof(VertexInput)) == 0;
  }
};

struct ColorAttachment {
  Format format = Format_Invalid;
  bool blendEnabled = false;
  BlendOp rgbBlendOp = BlendOp::BlendOp_Add;
  BlendOp alphaBlendOp = BlendOp::BlendOp_Add;
  BlendFactor srcRGBBlendFactor = BlendFactor_One;
  BlendFactor srcAlphaBlendFactor = BlendFactor_One;
  BlendFactor dstRGBBlendFactor = BlendFactor_Zero;
  BlendFactor dstAlphaBlendFactor = BlendFactor_Zero;
};

struct ShaderModuleDesc {
  ShaderStage stage = Stage_Frag;
  const char* data = nullptr;
  size_t dataSize = 0; // if `dataSize` is non-zero, interpret `data` as binary SPIR-V shader data
  const char* entryPointName = nullptr;
  const char* debugName = "";

  ShaderModuleDesc(const char* source, lvk::ShaderStage stage, const char* debugName) : stage(stage), data(source), debugName(debugName) {}
  ShaderModuleDesc(const char* source, const char* entryPointName, lvk::ShaderStage stage, const char* debugName)
  : stage(stage)
  , data(source)
  , entryPointName(entryPointName)
  , debugName(debugName) {}
  ShaderModuleDesc(const void* data, size_t dataLength, lvk::ShaderStage stage, const char* debugName)
  : stage(stage)
  , data(static_cast<const char*>(data))
  , dataSize(dataLength)
  , debugName(debugName) {
    LVK_ASSERT(dataSize);
  }
};

struct SpecializationConstantEntry {
  uint32_t constantId = 0;
  uint32_t offset = 0; // offset within SpecializationConstantDesc::data
  size_t size = 0;
};

struct SpecializationConstantDesc {
  enum { LVK_SPECIALIZATION_CONSTANTS_MAX = 16 };
  SpecializationConstantEntry entries[LVK_SPECIALIZATION_CONSTANTS_MAX] = {};
  const void* data = nullptr;
  size_t dataSize = 0;
  uint32_t getNumSpecializationConstants() const {
    uint32_t n = 0;
    while (n < LVK_SPECIALIZATION_CONSTANTS_MAX && entries[n].size) {
      n++;
    }
    return n;
  }
};

struct RenderPipelineDesc final {
  Topology topology = Topology_Triangle;

  lvk::VertexInput vertexInput;

  ShaderModuleHandle smVert;
  ShaderModuleHandle smTesc;
  ShaderModuleHandle smTese;
  ShaderModuleHandle smGeom;
  ShaderModuleHandle smTask;
  ShaderModuleHandle smMesh;
  ShaderModuleHandle smFrag;

  SpecializationConstantDesc specInfo = {};

  const char* entryPointVert = "main";
  const char* entryPointTesc = "main";
  const char* entryPointTese = "main";
  const char* entryPointGeom = "main";
  const char* entryPointTask = "main";
  const char* entryPointMesh = "main";
  const char* entryPointFrag = "main";

  ColorAttachment color[LVK_MAX_COLOR_ATTACHMENTS] = {};
  Format depthFormat = Format_Invalid;
  Format stencilFormat = Format_Invalid;

  CullMode cullMode = lvk::CullMode_None;
  WindingMode frontFace = lvk::WindingMode_CCW;
  PolygonMode polygonMode = lvk::PolygonMode_Fill;

  StencilState backFaceStencil = {};
  StencilState frontFaceStencil = {};

  uint32_t samplesCount = 1u;
  uint32_t patchControlPoints = 0;
  float minSampleShading = 0.0f;

  const char* debugName = "";

  uint32_t getNumColorAttachments() const {
    uint32_t n = 0;
    while (n < LVK_MAX_COLOR_ATTACHMENTS && color[n].format != Format_Invalid) {
      n++;
    }
    return n;
  }
};

struct ComputePipelineDesc final {
  ShaderModuleHandle smComp;
  SpecializationConstantDesc specInfo = {};
  const char* entryPoint = "main";
  const char* debugName = "";
};

// a single hit group - one "material" worth of shaders
struct RayTracingHitGroupDesc final {
  ShaderModuleHandle smClosestHit = {};
  ShaderModuleHandle smAnyHit = {};
  ShaderModuleHandle smIntersection = {};
};

struct RayTracingPipelineDesc final {
  enum { LVK_MAX_RAY_TRACING_SHADERS = 4 };
  enum { LVK_MAX_RAY_TRACING_HIT_GROUPS = 8 };
  ShaderModuleHandle smRayGen[LVK_MAX_RAY_TRACING_SHADERS] = {}; // typically just one, but spec allows more
  ShaderModuleHandle smMiss[LVK_MAX_RAY_TRACING_SHADERS] = {}; // index 0 for primary rays, 1 for shadow rays, etc
  ShaderModuleHandle smCallable[LVK_MAX_RAY_TRACING_SHADERS] = {};
  RayTracingHitGroupDesc hitGroups[LVK_MAX_RAY_TRACING_HIT_GROUPS] = {}; // hit groups - one per material
  SpecializationConstantDesc specInfo = {};
  const char* debugName = "";
  // clang-format off
#define GET_SHADER_GROUP_SIZE(name, sm) \
  [[nodiscard]] uint32_t getNum##name##Shaders() const { uint32_t n = 0; while (n < LVK_ARRAY_NUM_ELEMENTS(sm) && sm[n]) n++; return n; }
  // clang-format on
  GET_SHADER_GROUP_SIZE(RayGen, smRayGen)
  GET_SHADER_GROUP_SIZE(Miss, smMiss)
  GET_SHADER_GROUP_SIZE(Callable, smCallable)
#undef GET_SHADER_GROUP_SIZE
  [[nodiscard]] uint32_t getNumHitGroups() const {
    uint32_t n = 0;
    while (n < LVK_ARRAY_NUM_ELEMENTS(hitGroups) && (hitGroups[n].smAnyHit || hitGroups[n].smClosestHit || hitGroups[n].smIntersection))
      n++;
    return n;
  }
};

struct RenderPass final {
  struct AttachmentDesc final {
    LoadOp loadOp = LoadOp_Invalid;
    StoreOp storeOp = StoreOp_Store;
    ResolveMode resolveMode = ResolveMode_Average;
    uint8_t layer = 0;
    uint8_t level = 0;
    ClearColorValue clearColor = {.float32 = {0.0f, 0.0f, 0.0f, 0.0f}};
    float clearDepth = 1.0f;
    uint32_t clearStencil = 0;
  };

  AttachmentDesc color[LVK_MAX_COLOR_ATTACHMENTS] = {};
  AttachmentDesc depth = {.loadOp = LoadOp_DontCare, .storeOp = StoreOp_DontCare};
  AttachmentDesc stencil = {.loadOp = LoadOp_Invalid, .storeOp = StoreOp_DontCare};

  uint32_t layerCount = 1;
  uint32_t viewMask = 0;

  uint32_t getNumColorAttachments() const {
    uint32_t n = 0;
    while (n < LVK_MAX_COLOR_ATTACHMENTS && color[n].loadOp != LoadOp_Invalid) {
      n++;
    }
    return n;
  }
};

struct Framebuffer final {
  struct AttachmentDesc {
    TextureHandle texture;
    TextureHandle resolveTexture;
  };

  AttachmentDesc color[LVK_MAX_COLOR_ATTACHMENTS] = {};
  AttachmentDesc depthStencil;

  const char* debugName = "";

  uint32_t getNumColorAttachments() const {
    uint32_t n = 0;
    while (n < LVK_MAX_COLOR_ATTACHMENTS && color[n].texture) {
      n++;
    }
    return n;
  }
};

enum BufferUsageBits : uint8_t {
  BufferUsageBits_Index = 1 << 0,
  BufferUsageBits_Vertex = 1 << 1,
  BufferUsageBits_Uniform = 1 << 2,
  BufferUsageBits_Storage = 1 << 3,
  BufferUsageBits_Indirect = 1 << 4,
  // ray tracing
  BufferUsageBits_ShaderBindingTable = 1 << 5,
  BufferUsageBits_AccelStructBuildInputReadOnly = 1 << 6,
  BufferUsageBits_AccelStructStorage = 1 << 7
};

struct BufferDesc final {
  uint8_t usage = 0;
  StorageType storage = StorageType_HostVisible;
  size_t size = 0;
  const void* data = nullptr;
  const char* debugName = "";
};

struct Offset3D {
  int32_t x = 0;
  int32_t y = 0;
  int32_t z = 0;
};

struct TextureLayers {
  uint32_t mipLevel = 0;
  uint32_t layer = 0;
  uint32_t numLayers = 1;
};

struct TextureRangeDesc {
  Offset3D offset = {};
  Dimensions dimensions = {1, 1, 1};
  uint32_t layer = 0;
  uint32_t numLayers = 1;
  uint32_t mipLevel = 0;
  uint32_t numMipLevels = 1;
};

enum TextureUsageBits : uint8_t {
  TextureUsageBits_Sampled = 1 << 0,
  TextureUsageBits_Storage = 1 << 1,
  TextureUsageBits_Attachment = 1 << 2,
  TextureUsageBits_InputAttachment = 1 << 3,
};

enum Swizzle : uint8_t {
  Swizzle_Default = 0,
  Swizzle_0,
  Swizzle_1,
  Swizzle_R,
  Swizzle_G,
  Swizzle_B,
  Swizzle_A,
};

struct ComponentMapping {
  Swizzle r = Swizzle_Default;
  Swizzle g = Swizzle_Default;
  Swizzle b = Swizzle_Default;
  Swizzle a = Swizzle_Default;
  bool identity() const {
    return r == Swizzle_Default && g == Swizzle_Default && b == Swizzle_Default && a == Swizzle_Default;
  }
};

struct TextureDesc {
  TextureType type = TextureType_2D;
  Format format = Format_Invalid;

  Dimensions dimensions = {1, 1, 1};
  uint32_t numLayers = 1;
  uint32_t numSamples = 1;
  uint8_t usage = TextureUsageBits_Sampled;
  uint32_t numMipLevels = 1;
  StorageType storage = StorageType_Device;
  ComponentMapping components = {};
  const void* data = nullptr;
  uint32_t dataNumMipLevels = 1; // how many mip-levels we want to upload
  bool generateMipmaps = false; // generate mip-levels immediately, valid only with non-null data
  const char* debugName = "";
};

struct TextureViewDesc {
  TextureType type = TextureType_2D;
  uint32_t layer = 0;
  uint32_t numLayers = 1;
  uint32_t mipLevel = 0;
  uint32_t numMipLevels = 1;
  ComponentMapping components = {};
};

enum AccelStructType : uint8_t {
  AccelStructType_Invalid = 0,
  AccelStructType_TLAS = 1,
  AccelStructType_BLAS = 2,
};

enum AccelStructGeomType : uint8_t {
  AccelStructGeomType_Triangles = 0,
  AccelStructGeomType_AABBs = 1,
  AccelStructGeomType_Instances = 2,
};

enum AccelStructBuildFlagBits : uint8_t {
  AccelStructBuildFlagBits_AllowUpdate = 1 << 0,
  AccelStructBuildFlagBits_AllowCompaction = 1 << 1,
  AccelStructBuildFlagBits_PreferFastTrace = 1 << 2,
  AccelStructBuildFlagBits_PreferFastBuild = 1 << 3,
  AccelStructBuildFlagBits_LowMemory = 1 << 4,
};

enum AccelStructGeometryFlagBits : uint8_t {
  AccelStructGeometryFlagBits_Opaque = 1 << 0,
  AccelStructGeometryFlagBits_NoDuplicateAnyHit = 1 << 1,
};

enum AccelStructInstanceFlagBits : uint8_t {
  AccelStructInstanceFlagBits_TriangleFacingCullDisable = 1 << 0,
  AccelStructInstanceFlagBits_TriangleFlipFacing = 1 << 1,
  AccelStructInstanceFlagBits_ForceOpaque = 1 << 2,
  AccelStructInstanceFlagBits_ForceNoOpaque = 1 << 3,
};

struct AccelStructSizes {
  uint64_t accelerationStructureSize = 0;
  uint64_t updateScratchSize = 0;
  uint64_t buildScratchSize = 0;
};

struct AccelStructBuildRange {
  uint32_t primitiveCount = 0;
  uint32_t primitiveOffset = 0;
  uint32_t firstVertex = 0;
  uint32_t transformOffset = 0;
};

struct mat3x4 {
  float matrix[3][4];
};

struct AccelStructInstance {
  mat3x4 transform;
  uint32_t instanceCustomIndex : 24 = 0;
  uint32_t mask : 8 = 0xff;
  uint32_t instanceShaderBindingTableRecordOffset : 24 = 0;
  uint32_t flags : 8 = AccelStructInstanceFlagBits_TriangleFacingCullDisable;
  uint64_t accelerationStructureReference = 0;
};

struct AccelStructDesc {
  AccelStructType type = AccelStructType_Invalid;
  AccelStructGeomType geometryType = AccelStructGeomType_Triangles;
  uint8_t geometryFlags = AccelStructGeometryFlagBits_Opaque;

  VertexFormat vertexFormat = VertexFormat::Invalid;
  BufferHandle vertexBuffer;
  uint32_t vertexStride = 0; // zero means the size of `vertexFormat`
  uint32_t numVertices = 0;
  IndexFormat indexFormat = IndexFormat_UI32;
  BufferHandle indexBuffer;
  BufferHandle transformBuffer;
  BufferHandle instancesBuffer;
  AccelStructBuildRange buildRange = {};
  uint8_t buildFlags = AccelStructBuildFlagBits_PreferFastTrace;
  const char* debugName = "";
};

struct Dependencies {
  enum { LVK_MAX_SUBMIT_DEPENDENCIES = 4 };
  TextureHandle textures[LVK_MAX_SUBMIT_DEPENDENCIES] = {};
  BufferHandle buffers[LVK_MAX_SUBMIT_DEPENDENCIES] = {};
  TextureHandle inputAttachments[LVK_MAX_COLOR_ATTACHMENTS] = {};
};

class ICommandBuffer {
 public:
  virtual ~ICommandBuffer() = default;

  virtual void transitionToShaderReadOnly(TextureHandle surface) const = 0;
  virtual void transitionToRenderingLocalRead(TextureHandle surface) const = 0;

  virtual void cmdPushDebugGroupLabel(const char* label, uint32_t colorRGBA = 0xffffffff) const = 0;
  virtual void cmdInsertDebugEventLabel(const char* label, uint32_t colorRGBA = 0xffffffff) const = 0;
  virtual void cmdPopDebugGroupLabel() const = 0;

  virtual void cmdBindRayTracingPipeline(lvk::RayTracingPipelineHandle handle) = 0;

  virtual void cmdBindComputePipeline(lvk::ComputePipelineHandle handle) = 0;
  virtual void cmdDispatchThreadGroups(const Dimensions& threadgroupCount, const Dependencies& deps = {}) = 0;

  virtual void cmdBeginRendering(const lvk::RenderPass& renderPass, const lvk::Framebuffer& desc, const Dependencies& deps = {}) = 0;
  virtual void cmdEndRendering() = 0;
  virtual void cmdNextSubpass() = 0;

  virtual void cmdBindViewport(const Viewport& viewport) = 0;
  virtual void cmdBindScissorRect(const ScissorRect& rect) = 0;

  virtual void cmdBindRenderPipeline(lvk::RenderPipelineHandle handle) = 0;
  virtual void cmdBindDepthState(const DepthState& state) = 0;

  virtual void cmdBindVertexBuffer(uint32_t index, BufferHandle buffer, uint64_t bufferOffset = 0) = 0;
  virtual void cmdBindIndexBuffer(BufferHandle indexBuffer, IndexFormat indexFormat, uint64_t indexBufferOffset = 0) = 0;
  virtual void cmdPushConstants(const void* data, size_t size, size_t offset = 0) = 0;
  template<typename Struct>
  void cmdPushConstants(const Struct& data, size_t offset = 0) {
    this->cmdPushConstants(&data, sizeof(Struct), offset);
  }

  virtual void cmdCopyBuffer(BufferHandle srcBuffer, BufferHandle dstBuffer, size_t srcOffset, size_t dstOffset, size_t size) = 0;
  virtual void cmdFillBuffer(BufferHandle buffer, size_t bufferOffset, size_t size, uint32_t data) = 0;
  virtual void cmdUpdateBuffer(BufferHandle buffer, size_t bufferOffset, size_t size, const void* data) = 0;
  template<typename Struct>
  void cmdUpdateBuffer(BufferHandle buffer, const Struct& data, size_t bufferOffset = 0) {
    this->cmdUpdateBuffer(buffer, bufferOffset, sizeof(Struct), &data);
  }

  virtual void cmdDraw(uint32_t vertexCount, uint32_t instanceCount = 1, uint32_t firstVertex = 0, uint32_t baseInstance = 0) = 0;
  virtual void cmdDrawIndexed(uint32_t indexCount,
                              uint32_t instanceCount = 1,
                              uint32_t firstIndex = 0,
                              int32_t vertexOffset = 0,
                              uint32_t baseInstance = 0) = 0;
  virtual void cmdDrawIndirect(BufferHandle indirectBuffer, size_t indirectBufferOffset, uint32_t drawCount, uint32_t stride = 0) = 0;
  virtual void cmdDrawIndexedIndirect(BufferHandle indirectBuffer,
                                      size_t indirectBufferOffset,
                                      uint32_t drawCount,
                                      uint32_t stride = 0) = 0;
  virtual void cmdDrawIndexedIndirectCount(BufferHandle indirectBuffer,
                                           size_t indirectBufferOffset,
                                           BufferHandle countBuffer,
                                           size_t countBufferOffset,
                                           uint32_t maxDrawCount,
                                           uint32_t stride = 0) = 0;
  virtual void cmdDrawMeshTasks(const Dimensions& threadgroupCount) = 0;
  virtual void cmdDrawMeshTasksIndirect(BufferHandle indirectBuffer,
                                        size_t indirectBufferOffset,
                                        uint32_t drawCount,
                                        uint32_t stride = 0) = 0;
  virtual void cmdDrawMeshTasksIndirectCount(BufferHandle indirectBuffer,
                                             size_t indirectBufferOffset,
                                             BufferHandle countBuffer,
                                             size_t countBufferOffset,
                                             uint32_t maxDrawCount,
                                             uint32_t stride = 0) = 0;
  virtual void cmdTraceRays(uint32_t width, uint32_t height, uint32_t depth = 1, const Dependencies& deps = {}) = 0;

  virtual void cmdSetBlendColor(const float color[4]) = 0;
  // the argument order is correct, so the `clamp` parameter can have a default value
  virtual void cmdSetDepthBias(float constantFactor, float slopeFactor, float clamp = 0.0f) = 0;
  virtual void cmdSetDepthBiasEnable(bool enable) = 0;

  virtual void cmdResetQueryPool(QueryPoolHandle pool, uint32_t firstQuery, uint32_t queryCount) = 0;
  virtual void cmdWriteTimestamp(QueryPoolHandle pool, uint32_t query) = 0;

  virtual void cmdClearColorImage(TextureHandle tex, const ClearColorValue& value, const TextureLayers& layers = {}) = 0;
  virtual void cmdCopyImage(TextureHandle src,
                            TextureHandle dst,
                            const Dimensions& extent,
                            const Offset3D& srcOffset = {},
                            const Offset3D& dstOffset = {},
                            const TextureLayers& srcLayers = {},
                            const TextureLayers& dstLayers = {}) = 0;
  virtual void cmdGenerateMipmap(TextureHandle handle) = 0;
  virtual void cmdUpdateTLAS(AccelStructHandle handle, BufferHandle instancesBuffer) = 0;
};

struct SubmitHandle {
  uint32_t bufferIndex_ = 0;
  uint32_t submitId_ = 0;
  SubmitHandle() = default;
  explicit SubmitHandle(uint64_t handle) : bufferIndex_(uint32_t(handle & 0xffffffff)), submitId_(uint32_t(handle >> 32)) {
    LVK_ASSERT(submitId_);
  }
  bool empty() const {
    return submitId_ == 0;
  }
  uint64_t handle() const {
    return (uint64_t(submitId_) << 32) + bufferIndex_;
  }
};

static_assert(sizeof(SubmitHandle) == sizeof(uint64_t));

class IContext {
 protected:
  IContext() = default;

 public:
  virtual ~IContext() = default;

  virtual ICommandBuffer& acquireCommandBuffer() = 0;

  virtual SubmitHandle submit(ICommandBuffer& commandBuffer, TextureHandle present = {}) = 0;
  virtual void wait(SubmitHandle handle) = 0; // waiting on an empty handle results in vkDeviceWaitIdle()

  [[nodiscard]] virtual Holder<BufferHandle> createBuffer(const BufferDesc& desc,
                                                          const char* debugName = nullptr,
                                                          Result* outResult = nullptr) = 0;
  [[nodiscard]] virtual Holder<SamplerHandle> createSampler(const SamplerStateDesc& desc, Result* outResult = nullptr) = 0;
  [[nodiscard]] virtual Holder<TextureHandle> createTexture(const TextureDesc& desc,
                                                            const char* debugName = nullptr,
                                                            Result* outResult = nullptr) = 0;
  [[nodiscard]] virtual Holder<TextureHandle> createTextureView(TextureHandle texture,
                                                                const TextureViewDesc& desc,
                                                                const char* debugName = nullptr,
                                                                Result* outResult = nullptr) = 0;
  [[nodiscard]] virtual Holder<ComputePipelineHandle> createComputePipeline(const ComputePipelineDesc& desc,
                                                                            Result* outResult = nullptr) = 0;
  [[nodiscard]] virtual Holder<RenderPipelineHandle> createRenderPipeline(const RenderPipelineDesc& desc, Result* outResult = nullptr) = 0;
  [[nodiscard]] virtual Holder<RayTracingPipelineHandle> createRayTracingPipeline(const RayTracingPipelineDesc& desc,
                                                                                  Result* outResult = nullptr) = 0;
  [[nodiscard]] virtual Holder<ShaderModuleHandle> createShaderModule(const ShaderModuleDesc& desc, Result* outResult = nullptr) = 0;

  [[nodiscard]] virtual Holder<QueryPoolHandle> createQueryPool(uint32_t numQueries,
                                                                const char* debugName,
                                                                Result* outResult = nullptr) = 0;

  [[nodiscard]] virtual Holder<AccelStructHandle> createAccelerationStructure(const AccelStructDesc& desc, Result* outResult = nullptr) = 0;

  virtual void destroy(ComputePipelineHandle handle) = 0;
  virtual void destroy(RenderPipelineHandle handle) = 0;
  virtual void destroy(RayTracingPipelineHandle) = 0;
  virtual void destroy(ShaderModuleHandle handle) = 0;
  virtual void destroy(SamplerHandle handle) = 0;
  virtual void destroy(BufferHandle handle) = 0;
  virtual void destroy(TextureHandle handle) = 0;
  virtual void destroy(QueryPoolHandle handle) = 0;
  virtual void destroy(AccelStructHandle handle) = 0;
  virtual void destroy(Framebuffer& fb) = 0;

  [[nodiscard]] virtual uint64_t gpuAddress(AccelStructHandle handle) const = 0;

#pragma region Acceleration structure functions
  [[nodiscard]] virtual AccelStructSizes getAccelStructSizes(const AccelStructDesc& desc, Result* outResult = nullptr) const = 0;
#pragma endregion

#pragma region Buffer functions
  virtual Result upload(BufferHandle handle, const void* data, size_t size, size_t offset = 0) = 0;
  virtual Result download(BufferHandle handle, void* data, size_t size, size_t offset) = 0;
  [[nodiscard]] virtual uint8_t* getMappedPtr(BufferHandle handle) const = 0;
  [[nodiscard]] virtual uint64_t gpuAddress(BufferHandle handle, size_t offset = 0) const = 0;
  virtual void flushMappedMemory(BufferHandle handle, size_t offset, size_t size) const = 0;
  [[nodiscard]] virtual uint32_t getMaxStorageBufferRange() const = 0;
#pragma endregion

#pragma region Texture functions
  // `data` contains mip-levels and layers as in https://registry.khronos.org/KTX/specs/1.0/ktxspec.v1.html
  virtual Result upload(TextureHandle handle, const TextureRangeDesc& range, const void* data, uint32_t bufferRowLength = 0) = 0;
  virtual Result download(TextureHandle handle, const TextureRangeDesc& range, void* outData) = 0;
  [[nodiscard]] virtual Dimensions getDimensions(TextureHandle handle) const = 0;
  [[nodiscard]] virtual float getAspectRatio(TextureHandle handle) const = 0;
  [[nodiscard]] virtual Format getFormat(TextureHandle handle) const = 0;
#pragma endregion

  virtual TextureHandle getCurrentSwapchainTexture() = 0;
  virtual Format getSwapchainFormat() const = 0;
  virtual ColorSpace getSwapchainColorSpace() const = 0;
  virtual uint32_t getSwapchainCurrentImageIndex() const = 0;
  virtual uint32_t getNumSwapchainImages() const = 0;
  virtual void recreateSwapchain(int newWidth, int newHeight) = 0;
  [[nodiscard]] virtual bool setCurrentPresentMode(PresentMode mode) = 0; // VK_KHR_swapchain_maintenance1
  [[nodiscard]] virtual PresentMode getCurrentPresentMode() const = 0;

  // MSAA level is supported if ((samples & bitmask) != 0), where samples must be power of two.
  virtual uint32_t getFramebufferMSAABitMask() const = 0;

  virtual bool isExtensionEnabled(const char* ext) const = 0;

#pragma region Performance queries
  virtual double getTimestampPeriodToMs() const = 0;
  virtual bool getQueryPoolResults(QueryPoolHandle pool,
                                   uint32_t firstQuery,
                                   uint32_t queryCount,
                                   size_t dataSize,
                                   void* outData,
                                   size_t stride) const = 0;
#pragma endregion
};

} // namespace lvk

#if LVK_WITH_GLFW
typedef struct GLFWwindow GLFWwindow;
#endif

namespace lvk {

constexpr uint32_t kMaxCustomExtensions = 32;
constexpr uint32_t kMaxPresentModes = 8;

enum VulkanVersion {
  VulkanVersion_1_3,
  VulkanVersion_1_4,
};

struct ContextConfig {
  VulkanVersion vulkanVersion = VulkanVersion_1_3;
  bool terminateOnValidationError = false; // invoke std::terminate() on any validation error
  bool enableValidation = true;
  lvk::ColorSpace swapchainRequestedColorSpace = lvk::ColorSpace_SRGB_NONLINEAR;
  // owned by the application - should be alive until createVulkanContextWithSwapchain() returns
  const void* pipelineCacheData = nullptr;
  size_t pipelineCacheDataSize = 0;
  // Define preferred present modes, the first available present mode will  be used. PresentMode_FIFO is always available
  lvk::PresentMode presentModes[kMaxPresentModes] = {
#if defined(__linux__) || defined(_M_ARM64)
      PresentMode_Immediate,
#endif // __linux__
      PresentMode_Mailbox,
      PresentMode_Immediate,
      PresentMode_FIFO_Relaxed,
      PresentMode_FIFO,
  };
  const char* extensionsInstance[kMaxCustomExtensions] = {}; // add extra instance extensions on top of required ones
  const char* extensionsDevice[kMaxCustomExtensions] = {}; // add extra device extensions on top of required ones
  void* extensionsDeviceFeatures = nullptr; // inserted into VkPhysicalDeviceVulkan11Features::pNext

  // LVK knows about these extensions and can manage them automatically upon request
  bool enableHeadlessSurface = false; // VK_EXT_headless_surface

  uint64_t maxStagingBufferSize = 128ull * 1024ull * 1024ull; // a reasonable default
};

[[nodiscard]] bool isDepthOrStencilFormat(lvk::Format format);
[[nodiscard]] uint32_t getNumImagePlanes(lvk::Format format);
[[nodiscard]] uint32_t getTextureBytesPerLayer(uint32_t width, uint32_t height, lvk::Format format, uint32_t level);
[[nodiscard]] uint32_t getTextureBytesPerPlane(uint32_t width, uint32_t height, lvk::Format format, uint32_t plane);
[[nodiscard]] uint32_t getVertexFormatSize(lvk::VertexFormat format);
void logShaderSource(const char* text);

constexpr uint32_t calcNumMipLevels(uint32_t width, uint32_t height) {
  uint32_t levels = 1;

  while ((width | height) >> levels)
    levels++;

  return levels;
}

#if LVK_WITH_GLFW || defined(ANDROID)
#if defined(ANDROID)
using LVKwindow = ANativeWindow;
#else
using LVKwindow = GLFWwindow;
#endif
std::unique_ptr<lvk::IContext> createVulkanContextWithSwapchain(LVKwindow* window,
                                                                uint32_t width,
                                                                uint32_t height,
                                                                const lvk::ContextConfig& cfg,
                                                                lvk::HWDeviceType preferredDeviceType = lvk::HWDeviceType_Discrete,
                                                                int selectedDevice = -1);
#endif // LVK_WITH_GLFW || defined(ANDROID)

#if LVK_WITH_GLFW
/*
 * width/height  > 0: window size in pixels
 * width/height == 0: take the whole monitor work area
 * width/height  < 0: take a percentage of the monitor work area, for example (-95, -90)
 *   The actual values in pixels are returned in parameters.
 */
LVKwindow* initWindow(const char* windowTitle, int& outWidth, int& outHeight, bool resizable = false, bool headless = false);
#endif // LVK_WITH_GLFW

} // namespace lvk

```

`lvk/LVK.mm`:

```mm
/*
 * LightweightVK
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#if LVK_WITH_GLFW
#define GLFW_INCLUDE_NONE
#include <GLFW/glfw3.h>

// clang-format off
#if __APPLE__
#  define GLFW_EXPOSE_NATIVE_COCOA
#else
#  error Unsupported OS
#endif
// clang-format on

#include <GLFW/glfw3native.h>

#import <Cocoa/Cocoa.h>
#import <Metal/Metal.h>
#import <QuartzCore/CAMetalLayer.h>

void* createCocoaWindowView(GLFWwindow* window, void** outLayer) {
  NSWindow* nswindow = glfwGetCocoaWindow(window);
  CAMetalLayer* layer = [CAMetalLayer layer];
  layer.device = MTLCreateSystemDefaultDevice();
  layer.opaque = YES;
  layer.displaySyncEnabled = YES;
  NSScreen* screen = [NSScreen mainScreen];
  CGFloat factor = [screen backingScaleFactor];
  layer.contentsScale = factor;
  nswindow.contentView.layer = layer;
  nswindow.contentView.wantsLayer = YES;

  *outLayer = layer;

  return nswindow.contentView;
}
#endif // LVK_WITH_GLFW

```

`lvk/Pool.h`:

```h
#pragma once

#include <assert.h>
#include <cstdint>
#include <vector>

#include "lvk/LVK.h"

/// Pool<> is used only by the implementation
namespace lvk {

template<typename ObjectType, typename ImplObjectType>
class Pool {
  static constexpr uint32_t kListEndSentinel = 0xffffffff;
  struct PoolEntry {
    explicit PoolEntry(ImplObjectType& obj) : obj_(std::move(obj)) {}
    ImplObjectType obj_ = {};
    uint32_t gen_ = 1;
    uint32_t nextFree_ = kListEndSentinel;
  };
  uint32_t freeListHead_ = kListEndSentinel;
  uint32_t numObjects_ = 0;

 public:
  std::vector<PoolEntry> objects_;

  Handle<ObjectType> create(ImplObjectType&& obj) {
    uint32_t idx = 0;
    if (freeListHead_ != kListEndSentinel) {
      idx = freeListHead_;
      freeListHead_ = objects_[idx].nextFree_;
      objects_[idx].obj_ = std::move(obj);
    } else {
      idx = (uint32_t)objects_.size();
      objects_.emplace_back(obj);
    }
    numObjects_++;
    return Handle<ObjectType>(idx, objects_[idx].gen_);
  }
  void destroy(Handle<ObjectType> handle) {
    if (handle.empty())
      return;
    assert(numObjects_ > 0); // double deletion
    const uint32_t index = handle.index();
    assert(index < objects_.size());
    assert(handle.gen() == objects_[index].gen_); // double deletion
    objects_[index].obj_ = ImplObjectType{};
    objects_[index].gen_++;
    objects_[index].nextFree_ = freeListHead_;
    freeListHead_ = index;
    numObjects_--;
  }
  const ImplObjectType* get(Handle<ObjectType> handle) const {
    if (handle.empty())
      return nullptr;

    const uint32_t index = handle.index();
    assert(index < objects_.size());
    assert(handle.gen() == objects_[index].gen_); // accessing deleted object
    return &objects_[index].obj_;
  }
  ImplObjectType* get(Handle<ObjectType> handle) {
    if (handle.empty())
      return nullptr;

    const uint32_t index = handle.index();
    assert(index < objects_.size());
    assert(handle.gen() == objects_[index].gen_); // accessing deleted object
    return &objects_[index].obj_;
  }
  Handle<ObjectType> getHandle(uint32_t index) const {
    assert(index < objects_.size());
    if (index >= objects_.size())
      return {};

    return Handle<ObjectType>(index, objects_[index].gen_);
  }
  Handle<ObjectType> findObject(const ImplObjectType* obj) {
    if (!obj)
      return {};

    for (size_t idx = 0; idx != objects_.size(); idx++) {
      if (objects_[idx].obj_ == *obj) {
        return Handle<ObjectType>((uint32_t)idx, objects_[idx].gen_);
      }
    }

    return {};
  }
  void clear() {
    objects_.clear();
    freeListHead_ = kListEndSentinel;
    numObjects_ = 0;
  }
  uint32_t numObjects() const {
    return numObjects_;
  }
};

} // namespace lvk

```

`lvk/vulkan/CMakeLists.txt`:

```txt
# LightweightVK
#
# This source code is licensed under the MIT license found in the
# LICENSE file in the root directory of this source tree.

cmake_minimum_required(VERSION 3.22)

project(LVKVulkan CXX C)

file(GLOB SRC_FILES LIST_DIRECTORIES false RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} *.cpp *.c)
file(GLOB HEADER_FILES LIST_DIRECTORIES false RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} *.h)

add_library(LVKVulkan STATIC ${SRC_FILES} ${HEADER_FILES})

lvk_setup_target(LVKVulkan)
lvk_set_folder(LVKVulkan "LVK")

lvk_setup_groups("${SRC_FILES}")
lvk_setup_groups("${HEADER_FILES}")

# glslang
# cmake-format: off
set(ENABLE_GLSLANG_BINARIES OFF CACHE BOOL "")
set(ENABLE_HLSL             OFF CACHE BOOL "")
set(ENABLE_CTEST            OFF CACHE BOOL "")
set(ENABLE_OPT              OFF CACHE BOOL "")
set(ENABLE_SPVREMAPPER      OFF CACHE BOOL "")
set(SKIP_GLSLANG_INSTALL    ON  CACHE BOOL "")
add_subdirectory(${LVK_ROOT_DIR}/third-party/deps/src/glslang "glslang")
lvk_set_folder(GenericCodeGen     "third-party/glslang")
lvk_set_folder(glslang            "third-party/glslang")
lvk_set_folder(MachineIndependent "third-party/glslang")
lvk_set_folder(OSDependent        "third-party/glslang")
lvk_set_folder(SPIRV              "third-party/glslang")
lvk_set_folder(glslang-default-resource-limits "third-party/glslang")
# cmake-format: on

# slang
# cmake-format: off
if(LVK_WITH_SLANG)
  set(SLANG_ENABLE_CUDA          OFF CACHE BOOL "")
  set(SLANG_ENABLE_OPTIX         OFF CACHE BOOL "")
  set(SLANG_ENABLE_NVAPI         OFF CACHE BOOL "")
  set(SLANG_ENABLE_XLIB          OFF CACHE BOOL "")
  set(SLANG_ENABLE_AFTERMATH     OFF CACHE BOOL "")
  set(SLANG_ENABLE_DX_ON_VK      OFF CACHE BOOL "")
  set(SLANG_ENABLE_GFX           OFF CACHE BOOL "")
  if(WIN32)
    set(SLANG_ENABLE_SLANGC      OFF CACHE BOOL "")
  else()
    set(SLANG_ENABLE_SLANGC      ON  CACHE BOOL "")
  endif()
  set(SLANG_ENABLE_SLANGRT       ON  CACHE BOOL "")
  set(SLANG_ENABLE_SLANG_GLSLANG OFF CACHE BOOL "")
  set(SLANG_ENABLE_TESTS         OFF CACHE BOOL "")
  set(SLANG_ENABLE_EXAMPLES      OFF CACHE BOOL "")
  set(SLANG_ENABLE_REPLAYER      OFF CACHE BOOL "")
  set(SLANG_ENABLE_PREBUILT_BINARIES OFF CACHE BOOL "")
  set(SLANG_EMBED_CORE_MODULE_SOURCE OFF CACHE BOOL "")
  set(SLANG_ENABLE_DXIL              OFF CACHE BOOL "")
  set(SLANG_RHI_ENABLE_D3D11         OFF CACHE BOOL "")
  set(SLANG_RHI_ENABLE_D3D12         OFF CACHE BOOL "")
  set(SLANG_RHI_ENABLE_METAL         OFF CACHE BOOL "")
  set(SLANG_RHI_ENABLE_CUDA          OFF CACHE BOOL "")
  set(SLANG_RHI_ENABLE_WGPU          OFF CACHE BOOL "")
  add_subdirectory(${LVK_ROOT_DIR}/third-party/deps/src/slang "slang")
  lvk_set_folder(miniz                  "third-party")
  lvk_set_folder(lz4_static             "third-party")
  lvk_set_folder(compiler-core          "third-party/slang")
  lvk_set_folder(core                   "third-party/slang")
  lvk_set_folder(slang                  "third-party/slang")
  lvk_set_folder(slangd                 "third-party/slang")
  lvk_set_folder(slangi                 "third-party/slang")
  lvk_set_folder(slang-common-objects   "third-party/slang")
  if(TARGET slang-proxy)
    lvk_set_folder(slang-proxy            "third-party/slang")
  endif()
  lvk_set_folder(slang-rt               "third-party/slang")
  lvk_set_folder(slang-rhi              "third-party/slang")
  lvk_set_folder(slang-rhi-copy-files   "third-party/slang")
  lvk_set_folder(slang-rhi-resources    "third-party/slang")
  lvk_set_folder(slang-rhi-tests        "third-party/slang")
  target_compile_definitions(LVKVulkan PUBLIC "LVK_WITH_SLANG=1")
  target_link_libraries(LVKVulkan PRIVATE slang-rt core)
  target_include_directories(LVKVulkan PRIVATE "${LVK_ROOT_DIR}/third-party/deps/src/slang/include")
endif()
# cmake-format: on

# SPIRV-Reflect
set(SPIRV_REFLECT_EXECUTABLE OFF CACHE BOOL "")
set(SPIRV_REFLECT_STATIC_LIB ON  CACHE BOOL "")
add_subdirectory(${LVK_ROOT_DIR}/third-party/deps/src/SPIRV-Reflect "SPIRV-Reflect")
lvk_set_folder(spirv-reflect-static "third-party")

if(NOT LVK_USE_CUSTOM_MOLTENVK)
  find_package(Vulkan REQUIRED)
endif()

target_link_libraries(LVKVulkan INTERFACE LVKLibrary)
target_link_libraries(LVKVulkan PRIVATE glslang SPIRV glslang-default-resource-limits)
target_link_libraries(LVKVulkan PRIVATE spirv-reflect-static)
target_link_libraries(LVKVulkan INTERFACE minilog)
if(LVK_WITH_SLANG)
  target_link_libraries(LVKVulkan PRIVATE slang)
  target_link_libraries(LVKVulkan PRIVATE slang-rt)
endif()

if(LVK_USE_CUSTOM_MOLTENVK)
  target_include_directories(LVKVulkan PUBLIC "${LVK_CUSTOM_MOLTENVK_PATH}/include")
  target_link_libraries(LVKVulkan PUBLIC "${LVK_CUSTOM_MOLTENVK_PATH}/dylib/macOS/libMoltenVK.dylib")
else()
  target_link_libraries(LVKVulkan PUBLIC Vulkan::Vulkan)
endif()

target_include_directories(LVKVulkan PUBLIC "${LVK_ROOT_DIR}/third-party/deps/src/")
target_include_directories(LVKVulkan PUBLIC "${LVK_ROOT_DIR}/third-party/deps/src/volk")
target_include_directories(LVKVulkan PUBLIC "${LVK_ROOT_DIR}/third-party/deps/src/vma/include")
target_include_directories(LVKVulkan PUBLIC "${LVK_ROOT_DIR}/third-party/deps/src/vulkan-headers/include")

if(WIN32)
  add_definitions("-DVK_USE_PLATFORM_WIN32_KHR=1")
  add_definitions("-DNOMINMAX")
elseif(ANDROID)
  add_definitions("-DVK_USE_PLATFORM_ANDROID_KHR=1")
elseif(UNIX AND NOT APPLE)
  if(WAYLAND_FOUND)
    add_definitions("-DVK_USE_PLATFORM_WAYLAND_KHR=1")
  else()
    add_definitions("-DVK_USE_PLATFORM_XLIB_KHR=1")
  endif()
elseif(APPLE)
  if(${CMAKE_SYSTEM_NAME} MATCHES "Darwin")
    add_definitions("-DVK_USE_PLATFORM_MACOS_MVK=1")
    add_definitions("-DVK_USE_PLATFORM_METAL_EXT=1")
  endif()
endif()

if(CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  target_compile_options(LVKVulkan PRIVATE "-Wno-nullability-completeness")
endif()

```

`lvk/vulkan/VulkanClasses.cpp`:

```cpp
/*
 * LightweightVK
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#include <cstring>
#include <vector>

#define VMA_IMPLEMENTATION
#define VOLK_IMPLEMENTATION

#include "VulkanClasses.h"
#include "VulkanUtils.h"

#include <SPIRV-Reflect/spirv_reflect.h>
#include <glslang/Include/glslang_c_interface.h>
#include <ldrutils/lutils/ScopeExit.h>

#if defined(VK_USE_PLATFORM_METAL_EXT)
#include <vulkan/vulkan_metal.h>
#endif // VK_USE_PLATFORM_METAL_EXT

#ifndef VK_USE_PLATFORM_WIN32_KHR
#include <unistd.h>
#endif

// clang-format off
#if defined(LVK_WITH_TRACY_GPU)
  #include "tracy/TracyVulkan.hpp"
  #define LVK_PROFILER_GPU_ZONE(name, ctx, cmdBuffer, color) TracyVkZoneC(ctx->pimpl_->tracyVkCtx_, cmdBuffer, name, color);
#else
  #define LVK_PROFILER_GPU_ZONE(name, ctx, cmdBuffer, color)
#endif // LVK_WITH_TRACY_GPU
// clang-format on

#if !defined(__APPLE__)
#include <malloc.h>
#endif

uint32_t lvk::VulkanPipelineBuilder::numPipelinesCreated_ = 0;

static_assert(lvk::HWDeviceDesc::LVK_MAX_PHYSICAL_DEVICE_NAME_SIZE == VK_MAX_PHYSICAL_DEVICE_NAME_SIZE);
static_assert(lvk::Swizzle_Default == (uint32_t)VK_COMPONENT_SWIZZLE_IDENTITY);
static_assert(lvk::Swizzle_0 == (uint32_t)VK_COMPONENT_SWIZZLE_ZERO);
static_assert(lvk::Swizzle_1 == (uint32_t)VK_COMPONENT_SWIZZLE_ONE);
static_assert(lvk::Swizzle_R == (uint32_t)VK_COMPONENT_SWIZZLE_R);
static_assert(lvk::Swizzle_G == (uint32_t)VK_COMPONENT_SWIZZLE_G);
static_assert(lvk::Swizzle_B == (uint32_t)VK_COMPONENT_SWIZZLE_B);
static_assert(lvk::Swizzle_A == (uint32_t)VK_COMPONENT_SWIZZLE_A);
static_assert(sizeof(lvk::AccelStructInstance) == sizeof(VkAccelerationStructureInstanceKHR));
static_assert(sizeof(lvk::mat3x4) == sizeof(VkTransformMatrixKHR));
static_assert(sizeof(lvk::ClearColorValue) == sizeof(VkClearColorValue));

namespace {

const char* kDefaultValidationLayers[] = {"VK_LAYER_KHRONOS_validation"};

// These bindings should match GLSL declarations injected into shaders in VulkanContext::createShaderModule().
enum Bindings {
  kBinding_Textures = 0,
  kBinding_Samplers = 1,
  kBinding_StorageImages = 2,
  kBinding_YUVImages = 3,
  kBinding_AccelerationStructures = 4,
  kBinding_NumBindings = 5,
};

const uint32_t kDescriptorSet_InputAttachments = 4; // for VkDescriptorSetLayout in getVkPipeline()

VkDeviceSize getAlignedSize(uint64_t value, uint64_t alignment) {
  return (value + alignment - 1) & ~(alignment - 1);
}

uint64_t getAlignedAddress(uint64_t addr, uint64_t align) {
  const uint64_t offs = addr % align;
  return offs ? addr + (align - offs) : addr;
}

VKAPI_ATTR VkBool32 VKAPI_CALL vulkanDebugCallback(VkDebugUtilsMessageSeverityFlagBitsEXT msgSeverity,
                                                   [[maybe_unused]] VkDebugUtilsMessageTypeFlagsEXT msgType,
                                                   const VkDebugUtilsMessengerCallbackDataEXT* cbData,
                                                   void* userData) {
  if (msgSeverity < VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT) {
    return VK_FALSE;
  }

  const bool isError = (msgSeverity & VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT) != 0;
  const bool isWarning = (msgSeverity & VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT) != 0;

  const size_t len = cbData->pMessage ? strlen(cbData->pMessage) : 128u;

  LVK_ASSERT(len < 65536);

  char* errorName = (char*)alloca(len + 1);
  int object = 0;
  void* handle = nullptr;
  char typeName[128] = {};
  void* messageID = nullptr;

  minilog::eLogLevel level = minilog::Log;
  if (isError) {
    lvk::VulkanContext* ctx = static_cast<lvk::VulkanContext*>(userData);
    level = ctx->config_.terminateOnValidationError ? minilog::FatalError : minilog::Warning;
  }

  if (!isError && !isWarning && cbData->pMessageIdName) {
    if (strcmp(cbData->pMessageIdName, "Loader Message") == 0) {
      return VK_FALSE;
    }
  }

  if (sscanf(cbData->pMessage,
             "Validation Error: [ %[^]] ] Object %i: handle = %p, type = %127s | MessageID = %p",
             errorName,
             &object,
             &handle,
             typeName,
             &messageID) >= 2) {
    const char* message = strrchr(cbData->pMessage, '|') + 1;

    MINILOG_LOG_PROC(level,
                     "%sValidation layer:\n Validation Error: %s \n Object %i: handle = %p, type = %s\n "
                     "MessageID = %p \n%s \n",
                     isError ? "\nERROR:\n" : "",
                     errorName,
                     object,
                     handle,
                     typeName,
                     messageID,
                     message);
  } else {
    MINILOG_LOG_PROC(level, "%sValidation layer:\n%s\n", isError ? "\nERROR:\n" : "", cbData->pMessage);
  }

  if (isError) {
    lvk::VulkanContext* ctx = static_cast<lvk::VulkanContext*>(userData);
    if (ctx->config_.terminateOnValidationError) {
      LVK_ASSERT(false);
      std::terminate();
    }
  }

  return VK_FALSE;
}

VkIndexType indexFormatToVkIndexType(lvk::IndexFormat fmt) {
  switch (fmt) {
  case lvk::IndexFormat_UI8:
    return VK_INDEX_TYPE_UINT8_EXT;
  case lvk::IndexFormat_UI16:
    return VK_INDEX_TYPE_UINT16;
  case lvk::IndexFormat_UI32:
    return VK_INDEX_TYPE_UINT32;
  };
  LVK_ASSERT(false);
  return VK_INDEX_TYPE_NONE_KHR;
}

VkPrimitiveTopology topologyToVkPrimitiveTopology(lvk::Topology t) {
  switch (t) {
  case lvk::Topology_Point:
    return VK_PRIMITIVE_TOPOLOGY_POINT_LIST;
  case lvk::Topology_Line:
    return VK_PRIMITIVE_TOPOLOGY_LINE_LIST;
  case lvk::Topology_LineStrip:
    return VK_PRIMITIVE_TOPOLOGY_LINE_STRIP;
  case lvk::Topology_Triangle:
    return VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
  case lvk::Topology_TriangleStrip:
    return VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP;
  case lvk::Topology_Patch:
    return VK_PRIMITIVE_TOPOLOGY_PATCH_LIST;
  }
  LVK_ASSERT_MSG(false, "Implement Topology = %u", (uint32_t)t);
  return VK_PRIMITIVE_TOPOLOGY_MAX_ENUM;
}

VkAttachmentLoadOp loadOpToVkAttachmentLoadOp(lvk::LoadOp a) {
  switch (a) {
  case lvk::LoadOp_Invalid:
    LVK_ASSERT(false);
    return VK_ATTACHMENT_LOAD_OP_DONT_CARE;
  case lvk::LoadOp_DontCare:
    return VK_ATTACHMENT_LOAD_OP_DONT_CARE;
  case lvk::LoadOp_Load:
    return VK_ATTACHMENT_LOAD_OP_LOAD;
  case lvk::LoadOp_Clear:
    return VK_ATTACHMENT_LOAD_OP_CLEAR;
  case lvk::LoadOp_None:
    return VK_ATTACHMENT_LOAD_OP_NONE_EXT;
  }
  LVK_ASSERT(false);
  return VK_ATTACHMENT_LOAD_OP_DONT_CARE;
}

VkAttachmentStoreOp storeOpToVkAttachmentStoreOp(lvk::StoreOp a) {
  switch (a) {
  case lvk::StoreOp_DontCare:
    return VK_ATTACHMENT_STORE_OP_DONT_CARE;
  case lvk::StoreOp_Store:
    return VK_ATTACHMENT_STORE_OP_STORE;
  case lvk::StoreOp_MsaaResolve:
    // for MSAA resolve, we have to store data into a special "resolve" attachment
    return VK_ATTACHMENT_STORE_OP_DONT_CARE;
  case lvk::StoreOp_None:
    return VK_ATTACHMENT_STORE_OP_NONE;
  }
  LVK_ASSERT(false);
  return VK_ATTACHMENT_STORE_OP_DONT_CARE;
}

VkResolveModeFlagBits resolveModeToVkResolveModeFlagBits(lvk::ResolveMode mode, VkResolveModeFlags supported) {
  switch (mode) {
  case lvk::ResolveMode_None:
    return VK_RESOLVE_MODE_NONE;
  case lvk::ResolveMode_SampleZero:
    return VK_RESOLVE_MODE_SAMPLE_ZERO_BIT;
  case lvk::ResolveMode_Average:
    return supported & VK_RESOLVE_MODE_AVERAGE_BIT ? VK_RESOLVE_MODE_AVERAGE_BIT : VK_RESOLVE_MODE_SAMPLE_ZERO_BIT;
  case lvk::ResolveMode_Min:
    return supported & VK_RESOLVE_MODE_MIN_BIT ? VK_RESOLVE_MODE_MIN_BIT : VK_RESOLVE_MODE_SAMPLE_ZERO_BIT;
  case lvk::ResolveMode_Max:
    return supported & VK_RESOLVE_MODE_MAX_BIT ? VK_RESOLVE_MODE_MAX_BIT : VK_RESOLVE_MODE_SAMPLE_ZERO_BIT;
  }
  LVK_ASSERT(false);
  return VK_RESOLVE_MODE_SAMPLE_ZERO_BIT;
}

VkShaderStageFlagBits shaderStageToVkShaderStage(lvk::ShaderStage stage) {
  switch (stage) {
  case lvk::Stage_Vert:
    return VK_SHADER_STAGE_VERTEX_BIT;
  case lvk::Stage_Tesc:
    return VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT;
  case lvk::Stage_Tese:
    return VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT;
  case lvk::Stage_Geom:
    return VK_SHADER_STAGE_GEOMETRY_BIT;
  case lvk::Stage_Frag:
    return VK_SHADER_STAGE_FRAGMENT_BIT;
  case lvk::Stage_Comp:
    return VK_SHADER_STAGE_COMPUTE_BIT;
  case lvk::Stage_Task:
    return VK_SHADER_STAGE_TASK_BIT_EXT;
  case lvk::Stage_Mesh:
    return VK_SHADER_STAGE_MESH_BIT_EXT;
  case lvk::Stage_RayGen:
    return VK_SHADER_STAGE_RAYGEN_BIT_KHR;
  case lvk::Stage_AnyHit:
    return VK_SHADER_STAGE_ANY_HIT_BIT_KHR;
  case lvk::Stage_ClosestHit:
    return VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR;
  case lvk::Stage_Miss:
    return VK_SHADER_STAGE_MISS_BIT_KHR;
  case lvk::Stage_Intersection:
    return VK_SHADER_STAGE_INTERSECTION_BIT_KHR;
  case lvk::Stage_Callable:
    return VK_SHADER_STAGE_CALLABLE_BIT_KHR;
  };
  LVK_ASSERT(false);
  return VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM;
}

VkMemoryPropertyFlags storageTypeToVkMemoryPropertyFlags(lvk::StorageType storage) {
  VkMemoryPropertyFlags memFlags{0};

  switch (storage) {
  case lvk::StorageType_Device:
    memFlags |= VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;
    break;
  case lvk::StorageType_HostVisible:
    memFlags |= VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT;
    break;
  case lvk::StorageType_Memoryless:
    memFlags |= VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT;
    break;
  }
  return memFlags;
}

VkBuildAccelerationStructureFlagsKHR buildFlagsToVkBuildAccelerationStructureFlags(uint8_t buildFlags) {
  VkBuildAccelerationStructureFlagsKHR flags = 0;

  if (buildFlags & lvk::AccelStructBuildFlagBits_AllowUpdate) {
    flags |= VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR;
  }
  if (buildFlags & lvk::AccelStructBuildFlagBits_AllowCompaction) {
    flags |= VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR;
  }
  if (buildFlags & lvk::AccelStructBuildFlagBits_PreferFastTrace) {
    flags |= VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR;
  }
  if (buildFlags & lvk::AccelStructBuildFlagBits_PreferFastBuild) {
    flags |= VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR;
  }
  if (buildFlags & lvk::AccelStructBuildFlagBits_LowMemory) {
    flags |= VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR;
  }

  return flags;
}

VkPolygonMode polygonModeToVkPolygonMode(lvk::PolygonMode mode) {
  switch (mode) {
  case lvk::PolygonMode_Fill:
    return VK_POLYGON_MODE_FILL;
  case lvk::PolygonMode_Line:
    return VK_POLYGON_MODE_LINE;
  case lvk::PolygonMode_Point:
    return VK_POLYGON_MODE_POINT;
  }
  LVK_ASSERT_MSG(false, "Implement a missing polygon fill mode");
  return VK_POLYGON_MODE_FILL;
}

VkBlendFactor blendFactorToVkBlendFactor(lvk::BlendFactor value) {
  switch (value) {
  case lvk::BlendFactor_Zero:
    return VK_BLEND_FACTOR_ZERO;
  case lvk::BlendFactor_One:
    return VK_BLEND_FACTOR_ONE;
  case lvk::BlendFactor_SrcColor:
    return VK_BLEND_FACTOR_SRC_COLOR;
  case lvk::BlendFactor_OneMinusSrcColor:
    return VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR;
  case lvk::BlendFactor_DstColor:
    return VK_BLEND_FACTOR_DST_COLOR;
  case lvk::BlendFactor_OneMinusDstColor:
    return VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR;
  case lvk::BlendFactor_SrcAlpha:
    return VK_BLEND_FACTOR_SRC_ALPHA;
  case lvk::BlendFactor_OneMinusSrcAlpha:
    return VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
  case lvk::BlendFactor_DstAlpha:
    return VK_BLEND_FACTOR_DST_ALPHA;
  case lvk::BlendFactor_OneMinusDstAlpha:
    return VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA;
  case lvk::BlendFactor_BlendColor:
    return VK_BLEND_FACTOR_CONSTANT_COLOR;
  case lvk::BlendFactor_OneMinusBlendColor:
    return VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR;
  case lvk::BlendFactor_BlendAlpha:
    return VK_BLEND_FACTOR_CONSTANT_ALPHA;
  case lvk::BlendFactor_OneMinusBlendAlpha:
    return VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA;
  case lvk::BlendFactor_SrcAlphaSaturated:
    return VK_BLEND_FACTOR_SRC_ALPHA_SATURATE;
  case lvk::BlendFactor_Src1Color:
    return VK_BLEND_FACTOR_SRC1_COLOR;
  case lvk::BlendFactor_OneMinusSrc1Color:
    return VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR;
  case lvk::BlendFactor_Src1Alpha:
    return VK_BLEND_FACTOR_SRC1_ALPHA;
  case lvk::BlendFactor_OneMinusSrc1Alpha:
    return VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA;
  default:
    LVK_ASSERT(false);
    return VK_BLEND_FACTOR_ONE; // default for unsupported values
  }
}

VkBlendOp blendOpToVkBlendOp(lvk::BlendOp value) {
  switch (value) {
  case lvk::BlendOp_Add:
    return VK_BLEND_OP_ADD;
  case lvk::BlendOp_Subtract:
    return VK_BLEND_OP_SUBTRACT;
  case lvk::BlendOp_ReverseSubtract:
    return VK_BLEND_OP_REVERSE_SUBTRACT;
  case lvk::BlendOp_Min:
    return VK_BLEND_OP_MIN;
  case lvk::BlendOp_Max:
    return VK_BLEND_OP_MAX;
  }

  LVK_ASSERT(false);
  return VK_BLEND_OP_ADD;
}

VkCullModeFlags cullModeToVkCullMode(lvk::CullMode mode) {
  switch (mode) {
  case lvk::CullMode_None:
    return VK_CULL_MODE_NONE;
  case lvk::CullMode_Front:
    return VK_CULL_MODE_FRONT_BIT;
  case lvk::CullMode_Back:
    return VK_CULL_MODE_BACK_BIT;
  }
  LVK_ASSERT_MSG(false, "Implement a missing cull mode");
  return VK_CULL_MODE_NONE;
}

VkFrontFace windingModeToVkFrontFace(lvk::WindingMode mode) {
  switch (mode) {
  case lvk::WindingMode_CCW:
    return VK_FRONT_FACE_COUNTER_CLOCKWISE;
  case lvk::WindingMode_CW:
    return VK_FRONT_FACE_CLOCKWISE;
  }
  LVK_ASSERT_MSG(false, "Wrong winding order (cannot be more than 2)");
  return VK_FRONT_FACE_CLOCKWISE;
}

VkStencilOp stencilOpToVkStencilOp(lvk::StencilOp op) {
  switch (op) {
  case lvk::StencilOp_Keep:
    return VK_STENCIL_OP_KEEP;
  case lvk::StencilOp_Zero:
    return VK_STENCIL_OP_ZERO;
  case lvk::StencilOp_Replace:
    return VK_STENCIL_OP_REPLACE;
  case lvk::StencilOp_IncrementClamp:
    return VK_STENCIL_OP_INCREMENT_AND_CLAMP;
  case lvk::StencilOp_DecrementClamp:
    return VK_STENCIL_OP_DECREMENT_AND_CLAMP;
  case lvk::StencilOp_Invert:
    return VK_STENCIL_OP_INVERT;
  case lvk::StencilOp_IncrementWrap:
    return VK_STENCIL_OP_INCREMENT_AND_WRAP;
  case lvk::StencilOp_DecrementWrap:
    return VK_STENCIL_OP_DECREMENT_AND_WRAP;
  }
  LVK_ASSERT(false);
  return VK_STENCIL_OP_KEEP;
}

VkVertexInputRate vertexInputRateToVkVertexInputRate(lvk::VertexInputRate rate) {
  switch (rate) {
  case lvk::VertexInputRate_Vertex:
    return VK_VERTEX_INPUT_RATE_VERTEX;
  case lvk::VertexInputRate_Instance:
    return VK_VERTEX_INPUT_RATE_INSTANCE;
  }
  LVK_ASSERT(false);
  return VK_VERTEX_INPUT_RATE_VERTEX;
}

VkFormat vertexFormatToVkFormat(lvk::VertexFormat fmt) {
  using lvk::VertexFormat;
  switch (fmt) {
  case VertexFormat::Invalid:
    LVK_ASSERT(false);
    return VK_FORMAT_UNDEFINED;
  case VertexFormat::Float1:
    return VK_FORMAT_R32_SFLOAT;
  case VertexFormat::Float2:
    return VK_FORMAT_R32G32_SFLOAT;
  case VertexFormat::Float3:
    return VK_FORMAT_R32G32B32_SFLOAT;
  case VertexFormat::Float4:
    return VK_FORMAT_R32G32B32A32_SFLOAT;
  case VertexFormat::Byte1:
    return VK_FORMAT_R8_SINT;
  case VertexFormat::Byte2:
    return VK_FORMAT_R8G8_SINT;
  case VertexFormat::Byte3:
    return VK_FORMAT_R8G8B8_SINT;
  case VertexFormat::Byte4:
    return VK_FORMAT_R8G8B8A8_SINT;
  case VertexFormat::UByte1:
    return VK_FORMAT_R8_UINT;
  case VertexFormat::UByte2:
    return VK_FORMAT_R8G8_UINT;
  case VertexFormat::UByte3:
    return VK_FORMAT_R8G8B8_UINT;
  case VertexFormat::UByte4:
    return VK_FORMAT_R8G8B8A8_UINT;
  case VertexFormat::Short1:
    return VK_FORMAT_R16_SINT;
  case VertexFormat::Short2:
    return VK_FORMAT_R16G16_SINT;
  case VertexFormat::Short3:
    return VK_FORMAT_R16G16B16_SINT;
  case VertexFormat::Short4:
    return VK_FORMAT_R16G16B16A16_SINT;
  case VertexFormat::UShort1:
    return VK_FORMAT_R16_UINT;
  case VertexFormat::UShort2:
    return VK_FORMAT_R16G16_UINT;
  case VertexFormat::UShort3:
    return VK_FORMAT_R16G16B16_UINT;
  case VertexFormat::UShort4:
    return VK_FORMAT_R16G16B16A16_UINT;
    // Normalized variants
  case VertexFormat::Byte2Norm:
    return VK_FORMAT_R8G8_SNORM;
  case VertexFormat::Byte4Norm:
    return VK_FORMAT_R8G8B8A8_SNORM;
  case VertexFormat::UByte2Norm:
    return VK_FORMAT_R8G8_UNORM;
  case VertexFormat::UByte4Norm:
    return VK_FORMAT_R8G8B8A8_UNORM;
  case VertexFormat::Short2Norm:
    return VK_FORMAT_R16G16_SNORM;
  case VertexFormat::Short4Norm:
    return VK_FORMAT_R16G16B16A16_SNORM;
  case VertexFormat::UShort2Norm:
    return VK_FORMAT_R16G16_UNORM;
  case VertexFormat::UShort4Norm:
    return VK_FORMAT_R16G16B16A16_UNORM;
  case VertexFormat::Int1:
    return VK_FORMAT_R32_SINT;
  case VertexFormat::Int2:
    return VK_FORMAT_R32G32_SINT;
  case VertexFormat::Int3:
    return VK_FORMAT_R32G32B32_SINT;
  case VertexFormat::Int4:
    return VK_FORMAT_R32G32B32A32_SINT;
  case VertexFormat::UInt1:
    return VK_FORMAT_R32_UINT;
  case VertexFormat::UInt2:
    return VK_FORMAT_R32G32_UINT;
  case VertexFormat::UInt3:
    return VK_FORMAT_R32G32B32_UINT;
  case VertexFormat::UInt4:
    return VK_FORMAT_R32G32B32A32_UINT;
  case VertexFormat::HalfFloat1:
    return VK_FORMAT_R16_SFLOAT;
  case VertexFormat::HalfFloat2:
    return VK_FORMAT_R16G16_SFLOAT;
  case VertexFormat::HalfFloat3:
    return VK_FORMAT_R16G16B16_SFLOAT;
  case VertexFormat::HalfFloat4:
    return VK_FORMAT_R16G16B16A16_SFLOAT;
  case VertexFormat::Int_2_10_10_10_REV:
    return VK_FORMAT_A2B10G10R10_SNORM_PACK32;
  }
  LVK_ASSERT(false);
  return VK_FORMAT_UNDEFINED;
}

bool supportsFormat(VkPhysicalDevice physicalDevice, VkFormat format) {
  VkFormatProperties2 props = {
      .sType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2,
  };
  vkGetPhysicalDeviceFormatProperties2(physicalDevice, format, &props);
  return props.formatProperties.bufferFeatures != 0 || props.formatProperties.linearTilingFeatures != 0 ||
         props.formatProperties.optimalTilingFeatures != 0;
}

std::vector<VkFormat> getCompatibleDepthStencilFormats(lvk::Format format) {
  switch (format) {
  case lvk::Format_Z_UN16:
    return {VK_FORMAT_D16_UNORM, VK_FORMAT_D16_UNORM_S8_UINT, VK_FORMAT_D24_UNORM_S8_UINT, VK_FORMAT_D32_SFLOAT};
  case lvk::Format_Z_UN24:
    return {VK_FORMAT_D24_UNORM_S8_UINT, VK_FORMAT_D32_SFLOAT, VK_FORMAT_D16_UNORM_S8_UINT};
  case lvk::Format_Z_F32:
    return {VK_FORMAT_D32_SFLOAT, VK_FORMAT_D32_SFLOAT_S8_UINT, VK_FORMAT_D24_UNORM_S8_UINT};
  case lvk::Format_Z_UN24_S_UI8:
    return {VK_FORMAT_D24_UNORM_S8_UINT, VK_FORMAT_D16_UNORM_S8_UINT};
  case lvk::Format_Z_F32_S_UI8:
    return {VK_FORMAT_D32_SFLOAT_S8_UINT, VK_FORMAT_D24_UNORM_S8_UINT, VK_FORMAT_D16_UNORM_S8_UINT};
  default:
    return {VK_FORMAT_D24_UNORM_S8_UINT, VK_FORMAT_D32_SFLOAT};
  }
  return {VK_FORMAT_D24_UNORM_S8_UINT, VK_FORMAT_D32_SFLOAT};
}

bool validateImageLimits(VkImageType imageType,
                         VkSampleCountFlagBits samples,
                         const VkExtent3D& extent,
                         const VkPhysicalDeviceLimits& limits,
                         lvk::Result* outResult) {
  using lvk::Result;

  if (samples != VK_SAMPLE_COUNT_1_BIT && !LVK_VERIFY(imageType == VK_IMAGE_TYPE_2D)) {
    Result::setResult(outResult, Result(Result::Code::ArgumentOutOfRange, "Multisampling is supported only for 2D images"));
    return false;
  }

  if (imageType == VK_IMAGE_TYPE_2D &&
      !LVK_VERIFY(extent.width <= limits.maxImageDimension2D && extent.height <= limits.maxImageDimension2D)) {
    Result::setResult(outResult, Result(Result::Code::ArgumentOutOfRange, "2D texture size exceeded"));
    return false;
  }
  if (imageType == VK_IMAGE_TYPE_3D &&
      !LVK_VERIFY(extent.width <= limits.maxImageDimension3D && extent.height <= limits.maxImageDimension3D &&
                  extent.depth <= limits.maxImageDimension3D)) {
    Result::setResult(outResult, Result(Result::Code::ArgumentOutOfRange, "3D texture size exceeded"));
    return false;
  }

  return true;
}

lvk::Result validateRange(const VkExtent3D& ext, uint32_t numLevels, const lvk::TextureRangeDesc& range) {
  if (!LVK_VERIFY(range.dimensions.width > 0 && range.dimensions.height > 0 || range.dimensions.depth > 0 || range.numLayers > 0 ||
                  range.numMipLevels > 0)) {
    return lvk::Result{lvk::Result::Code::ArgumentOutOfRange, "width, height, depth numLayers, and numMipLevels must be > 0"};
  }
  if (range.mipLevel > numLevels) {
    return lvk::Result{lvk::Result::Code::ArgumentOutOfRange, "range.mipLevel exceeds texture mip-levels"};
  }

  const uint32_t texWidth = std::max(ext.width >> range.mipLevel, 1u);
  const uint32_t texHeight = std::max(ext.height >> range.mipLevel, 1u);
  const uint32_t texDepth = std::max(ext.depth >> range.mipLevel, 1u);

  if (range.dimensions.width > texWidth || range.dimensions.height > texHeight || range.dimensions.depth > texDepth) {
    return lvk::Result{lvk::Result::Code::ArgumentOutOfRange, "range dimensions exceed texture dimensions"};
  }
  if (range.offset.x > texWidth - range.dimensions.width || range.offset.y > texHeight - range.dimensions.height ||
      range.offset.z > texDepth - range.dimensions.depth) {
    return lvk::Result{lvk::Result::Code::ArgumentOutOfRange, "range dimensions exceed texture dimensions"};
  }

  return lvk::Result{};
}

bool isHostVisibleSingleHeapMemory(VkPhysicalDevice physDev) {
  VkPhysicalDeviceMemoryProperties2 props = {
      .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2,
  };

  vkGetPhysicalDeviceMemoryProperties2(physDev, &props);

  if (props.memoryProperties.memoryHeapCount != 1) {
    return false;
  }

  const uint32_t flag = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;

  for (uint32_t i = 0; i < props.memoryProperties.memoryTypeCount; i++) {
    if ((props.memoryProperties.memoryTypes[i].propertyFlags & flag) == flag) {
      return true;
    }
  }

  return false;
}

void getDeviceExtensionProps(VkPhysicalDevice dev, std::vector<VkExtensionProperties>& props, const char* validationLayer = nullptr) {
  uint32_t numExtensions = 0;
  vkEnumerateDeviceExtensionProperties(dev, validationLayer, &numExtensions, nullptr);
  std::vector<VkExtensionProperties> p(numExtensions);
  vkEnumerateDeviceExtensionProperties(dev, validationLayer, &numExtensions, p.data());
  props.insert(props.end(), p.begin(), p.end());
}

bool hasExtension(const char* ext, const std::vector<VkExtensionProperties>& props) {
  for (const VkExtensionProperties& p : props) {
    if (strcmp(ext, p.extensionName) == 0)
      return true;
  }
  return false;
}

void transitionToColorAttachment(VkCommandBuffer buffer, lvk::VulkanImage* colorTex) {
  if (!LVK_VERIFY(colorTex)) {
    return;
  }

  if (!LVK_VERIFY(!colorTex->isDepthFormat_ && !colorTex->isStencilFormat_)) {
    LVK_ASSERT_MSG(false, "Color attachments cannot have depth/stencil formats");
    return;
  }
  LVK_ASSERT_MSG(colorTex->vkImageFormat_ != VK_FORMAT_UNDEFINED, "Invalid color attachment format");
  colorTex->transitionLayout(buffer,
                             VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,
                             VkImageSubresourceRange{VK_IMAGE_ASPECT_COLOR_BIT, 0, VK_REMAINING_MIP_LEVELS, 0, VK_REMAINING_ARRAY_LAYERS});
}

VkSurfaceFormatKHR chooseSwapSurfaceFormat(const std::vector<VkSurfaceFormatKHR>& formats,
                                           lvk::ColorSpace requestedColorSpace,
                                           bool hasSwapchainColorspaceExt) {
  LVK_ASSERT(!formats.empty());

  auto isNativeSwapChainBGR = [](const std::vector<VkSurfaceFormatKHR>& formats) -> bool {
    for (const VkSurfaceFormatKHR& fmt : formats) {
      // The preferred format should be the one which is closer to the beginning of the formats
      // container. If BGR is encountered earlier, it should be picked as the format of choice. If RGB
      // happens to be earlier, take it.
      if (fmt.format == VK_FORMAT_R8G8B8A8_UNORM || fmt.format == VK_FORMAT_R8G8B8A8_SRGB ||
          fmt.format == VK_FORMAT_A2R10G10B10_UNORM_PACK32) {
        return false;
      }
      if (fmt.format == VK_FORMAT_B8G8R8A8_UNORM || fmt.format == VK_FORMAT_B8G8R8A8_SRGB ||
          fmt.format == VK_FORMAT_A2B10G10R10_UNORM_PACK32) {
        return true;
      }
    }
    return false;
  };

  auto colorSpaceToVkSurfaceFormat = [](lvk::ColorSpace colorSpace, bool isBGR, bool hasSwapchainColorspaceExt) -> VkSurfaceFormatKHR {
    switch (colorSpace) {
    case lvk::ColorSpace_SRGB_NONLINEAR:
      return VkSurfaceFormatKHR{isBGR ? VK_FORMAT_B8G8R8A8_UNORM : VK_FORMAT_R8G8B8A8_UNORM, VK_COLOR_SPACE_SRGB_NONLINEAR_KHR};
    case lvk::ColorSpace_SRGB_EXTENDED_LINEAR:
      if (hasSwapchainColorspaceExt)
        return VkSurfaceFormatKHR{VK_FORMAT_R16G16B16A16_SFLOAT, VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT};
      [[fallthrough]];
    case lvk::ColorSpace_HDR10:
      if (hasSwapchainColorspaceExt) {
        return VkSurfaceFormatKHR{isBGR ? VK_FORMAT_A2B10G10R10_UNORM_PACK32 : VK_FORMAT_A2R10G10B10_UNORM_PACK32,
                                  VK_COLOR_SPACE_HDR10_ST2084_EXT};
      }
      [[fallthrough]];
    default:
      // default to normal sRGB non linear.
      return VkSurfaceFormatKHR{isBGR ? VK_FORMAT_B8G8R8A8_SRGB : VK_FORMAT_R8G8B8A8_SRGB, VK_COLOR_SPACE_SRGB_NONLINEAR_KHR};
    }
  };

  const VkSurfaceFormatKHR preferred =
      colorSpaceToVkSurfaceFormat(requestedColorSpace, isNativeSwapChainBGR(formats), hasSwapchainColorspaceExt);

  for (const VkSurfaceFormatKHR& fmt : formats) {
    if (fmt.format == preferred.format && fmt.colorSpace == preferred.colorSpace) {
      return fmt;
    }
  }

  // if we can't find a matching format and color space, fallback on matching only format
  for (const VkSurfaceFormatKHR& fmt : formats) {
    if (fmt.format == preferred.format) {
      return fmt;
    }
  }

  LLOGL("Could not find a native swap chain format that matched our designed swapchain format. Defaulting to first supported format.");

  return formats[0];
}

} // namespace

namespace lvk {

struct DeferredTask {
  DeferredTask(std::packaged_task<void()>&& task, SubmitHandle handle) : task_(std::move(task)), handle_(handle) {}
  std::packaged_task<void()> task_;
  SubmitHandle handle_;
};

struct VulkanContextImpl final {
  // Vulkan Memory Allocator
  VmaAllocator vma_ = VK_NULL_HANDLE;

  lvk::CommandBuffer currentCommandBuffer_;

  std::vector<DeferredTask> deferredTasks_;

  struct YcbcrConversionData {
    VkSamplerYcbcrConversionInfo info;
    lvk::Holder<SamplerHandle> sampler;
  };
  YcbcrConversionData ycbcrConversionData_[256]; // indexed by lvk::Format
  uint32_t numYcbcrSamplers_ = 0;
  // max of all used values of VkSamplerYcbcrConversionImageFormatProperties::combinedImageSamplerDescriptorCount
  uint32_t maxCombinedImageSamplerDescriptorCount_ = 1;

#if defined(LVK_WITH_TRACY_GPU)
  TracyVkCtx tracyVkCtx_ = nullptr;
  VkCommandPool tracyCommandPool_ = VK_NULL_HANDLE;
  VkCommandBuffer tracyCommandBuffer_ = VK_NULL_HANDLE;
#endif // LVK_WITH_TRACY_GPU
};

} // namespace lvk

void lvk::VulkanBuffer::flushMappedMemory(const VulkanContext& ctx, VkDeviceSize offset, VkDeviceSize size) const {
  if (!LVK_VERIFY(isMapped())) {
    return;
  }

  if (LVK_VULKAN_USE_VMA) {
    vmaFlushAllocation((VmaAllocator)ctx.getVmaAllocator(), vmaAllocation_, offset, size);
  } else {
    const VkMappedMemoryRange range = {
        .sType = VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE,
        .memory = vkMemory_,
        .offset = offset,
        .size = size,
    };
    vkFlushMappedMemoryRanges(ctx.getVkDevice(), 1, &range);
  }
}

void lvk::VulkanBuffer::invalidateMappedMemory(const VulkanContext& ctx, VkDeviceSize offset, VkDeviceSize size) const {
  if (!LVK_VERIFY(isMapped())) {
    return;
  }

  if (LVK_VULKAN_USE_VMA) {
    vmaInvalidateAllocation(static_cast<VmaAllocator>(ctx.getVmaAllocator()), vmaAllocation_, offset, size);
  } else {
    const VkMappedMemoryRange range = {
        .sType = VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE,
        .memory = vkMemory_,
        .offset = offset,
        .size = size,
    };
    vkInvalidateMappedMemoryRanges(ctx.getVkDevice(), 1, &range);
  }
}

void lvk::VulkanBuffer::getBufferSubData(const VulkanContext& ctx, size_t offset, size_t size, void* data) {
  // only host-visible buffers can be downloaded this way
  LVK_ASSERT(mappedPtr_);

  if (!mappedPtr_) {
    return;
  }

  LVK_ASSERT(offset + size <= bufferSize_);

  if (!isCoherentMemory_) {
    invalidateMappedMemory(ctx, offset, size);
  }

  const uint8_t* src = static_cast<uint8_t*>(mappedPtr_) + offset;
  memcpy(data, src, size);
}

void lvk::VulkanBuffer::bufferSubData(const VulkanContext& ctx, size_t offset, size_t size, const void* data) {
  // only host-visible buffers can be uploaded this way
  LVK_ASSERT(mappedPtr_);

  if (!mappedPtr_) {
    return;
  }

  LVK_ASSERT(offset + size <= bufferSize_);

  if (data) {
    memcpy((uint8_t*)mappedPtr_ + offset, data, size);
  } else {
    memset((uint8_t*)mappedPtr_ + offset, 0, size);
  }

  if (!isCoherentMemory_) {
    flushMappedMemory(ctx, offset, size);
  }
}

VkImageView lvk::VulkanImage::createImageView(VkDevice device,
                                              VkImageViewType type,
                                              VkFormat format,
                                              VkImageAspectFlags aspectMask,
                                              uint32_t baseLevel,
                                              uint32_t numLevels,
                                              uint32_t baseLayer,
                                              uint32_t numLayers,
                                              const VkComponentMapping components,
                                              const VkSamplerYcbcrConversionInfo* ycbcr,
                                              const char* debugName) const {
  LVK_PROFILER_FUNCTION_COLOR(LVK_PROFILER_COLOR_CREATE);

  const VkImageViewCreateInfo ci = {
      .sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
      .pNext = ycbcr,
      .image = vkImage_,
      .viewType = type,
      .format = format,
      .components = components,
      .subresourceRange = {aspectMask, baseLevel, numLevels ? numLevels : numLevels_, baseLayer, numLayers},
  };
  VkImageView vkView = VK_NULL_HANDLE;
  VK_ASSERT(vkCreateImageView(device, &ci, nullptr, &vkView));
  VK_ASSERT(lvk::setDebugObjectName(device, VK_OBJECT_TYPE_IMAGE_VIEW, (uint64_t)vkView, debugName));

  return vkView;
}

void lvk::VulkanImage::transitionLayout(VkCommandBuffer commandBuffer,
                                        VkImageLayout newImageLayout,
                                        const VkImageSubresourceRange& subresourceRange) const {
  LVK_PROFILER_FUNCTION_COLOR(LVK_PROFILER_COLOR_BARRIER);

  const VkImageLayout oldImageLayout =
      vkImageLayout_ == VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL
          ? (isDepthAttachment() ? VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL : VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL)
          : vkImageLayout_;

  if (newImageLayout == VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL) {
    newImageLayout = isDepthAttachment() ? VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL : VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
  }

  StageAccess src = getPipelineStageAccess(oldImageLayout);
  StageAccess dst = getPipelineStageAccess(newImageLayout);

  if (isDepthAttachment() && isResolveAttachment) {
    // https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#renderpass-resolve-operations
    src.stage |= VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT;
    dst.stage |= VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT;
    src.access |= VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT;
    dst.access |= VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT;
  }

  const VkImageMemoryBarrier2 barrier = {
      .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2,
      .srcStageMask = src.stage,
      .srcAccessMask = src.access,
      .dstStageMask = dst.stage,
      .dstAccessMask = dst.access,
      .oldLayout = vkImageLayout_,
      .newLayout = newImageLayout,
      .srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
      .dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
      .image = vkImage_,
      .subresourceRange = subresourceRange,
  };

  const VkDependencyInfo depInfo{
      .sType = VK_STRUCTURE_TYPE_DEPENDENCY_INFO,
      .imageMemoryBarrierCount = 1,
      .pImageMemoryBarriers = &barrier,
  };

  vkCmdPipelineBarrier2(commandBuffer, &depInfo);

  vkImageLayout_ = newImageLayout;
}

VkImageAspectFlags lvk::VulkanImage::getImageAspectFlags() const {
  VkImageAspectFlags flags = 0;

  flags |= isDepthFormat_ ? VK_IMAGE_ASPECT_DEPTH_BIT : 0;
  flags |= isStencilFormat_ ? VK_IMAGE_ASPECT_STENCIL_BIT : 0;
  flags |= !(isDepthFormat_ || isStencilFormat_) ? VK_IMAGE_ASPECT_COLOR_BIT : 0;

  return flags;
}

void lvk::VulkanImage::generateMipmap(VkCommandBuffer commandBuffer) const {
  LVK_PROFILER_FUNCTION();

  // Check if device supports downscaling for color or depth/stencil buffer based on image format
  {
    const uint32_t formatFeatureMask = (VK_FORMAT_FEATURE_BLIT_SRC_BIT | VK_FORMAT_FEATURE_BLIT_DST_BIT);

    const bool hardwareDownscalingSupported = (vkFormatProperties_.optimalTilingFeatures & formatFeatureMask) == formatFeatureMask;

    if (!hardwareDownscalingSupported) {
      LLOGW("Doesn't support hardware downscaling of this image format: %p", vkImageFormat_);
      return;
    }
  }

  // Choose linear filter for color formats if supported by the device, else use nearest filter
  // Choose nearest filter by default for depth/stencil formats
  const VkFilter blitFilter = [](bool isDepthOrStencilFormat, bool imageFilterLinear) {
    if (isDepthOrStencilFormat) {
      return VK_FILTER_NEAREST;
    }
    if (imageFilterLinear) {
      return VK_FILTER_LINEAR;
    }
    return VK_FILTER_NEAREST;
  }(isDepthFormat_ || isStencilFormat_, vkFormatProperties_.optimalTilingFeatures & VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT);

  const VkImageAspectFlags imageAspectFlags = getImageAspectFlags();

  if (vkCmdBeginDebugUtilsLabelEXT) {
    const VkDebugUtilsLabelEXT utilsLabel = {
        .sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT,
        .pLabelName = "Generate mipmaps",
        .color = {1.0f, 0.75f, 1.0f, 1.0f},
    };
    vkCmdBeginDebugUtilsLabelEXT(commandBuffer, &utilsLabel);
  }

  const VkImageLayout originalImageLayout = vkImageLayout_;

  LVK_ASSERT(originalImageLayout != VK_IMAGE_LAYOUT_UNDEFINED);

  // 0: Transition the first level and all layers into VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL
  transitionLayout(commandBuffer, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, VkImageSubresourceRange{imageAspectFlags, 0, 1, 0, numLayers_});

  for (uint32_t layer = 0; layer < numLayers_; ++layer) {
    int32_t mipWidth = (int32_t)vkExtent_.width;
    int32_t mipHeight = (int32_t)vkExtent_.height;

    for (uint32_t i = 1; i < numLevels_; ++i) {
      // 1: Transition the i-th level to VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL; it will be copied into from the (i-1)-th layer
      lvk::imageMemoryBarrier2(commandBuffer,
                               vkImage_,
                               StageAccess{.stage = VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT, .access = VK_ACCESS_2_NONE},
                               StageAccess{.stage = VK_PIPELINE_STAGE_2_TRANSFER_BIT, .access = VK_ACCESS_2_TRANSFER_WRITE_BIT},
                               VK_IMAGE_LAYOUT_UNDEFINED, // oldImageLayout
                               VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, // newImageLayout
                               VkImageSubresourceRange{imageAspectFlags, i, 1, layer, 1});

      const int32_t nextLevelWidth = mipWidth > 1 ? mipWidth / 2 : 1;
      const int32_t nextLevelHeight = mipHeight > 1 ? mipHeight / 2 : 1;

      const VkOffset3D srcOffsets[2] = {
          VkOffset3D{0, 0, 0},
          VkOffset3D{mipWidth, mipHeight, 1},
      };
      const VkOffset3D dstOffsets[2] = {
          VkOffset3D{0, 0, 0},
          VkOffset3D{nextLevelWidth, nextLevelHeight, 1},
      };

      // 2: Blit the image from the prev mip-level (i-1) (VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL) to the current mip-level (i)
      // (VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL)
#if LVK_VULKAN_PRINT_COMMANDS
      LLOGL("%p vkCmdBlitImage()\n", commandBuffer);
#endif // LVK_VULKAN_PRINT_COMMANDS
      const VkImageBlit blit = {
          .srcSubresource = VkImageSubresourceLayers{imageAspectFlags, i - 1, layer, 1},
          .srcOffsets = {srcOffsets[0], srcOffsets[1]},
          .dstSubresource = VkImageSubresourceLayers{imageAspectFlags, i, layer, 1},
          .dstOffsets = {dstOffsets[0], dstOffsets[1]},
      };
      vkCmdBlitImage(commandBuffer,
                     vkImage_,
                     VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
                     vkImage_,
                     VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
                     1,
                     &blit,
                     blitFilter);
      // 3: Transition i-th level to VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL as it will be read from in the next iteration
      lvk::imageMemoryBarrier2(commandBuffer,
                               vkImage_,
                               StageAccess{.stage = VK_PIPELINE_STAGE_2_TRANSFER_BIT, .access = VK_ACCESS_2_TRANSFER_WRITE_BIT},
                               StageAccess{.stage = VK_PIPELINE_STAGE_2_TRANSFER_BIT, .access = VK_ACCESS_2_TRANSFER_READ_BIT},
                               VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, /* oldImageLayout */
                               VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, /* newImageLayout */
                               VkImageSubresourceRange{imageAspectFlags, i, 1, layer, 1});

      // Compute the size of the next mip-level
      mipWidth = nextLevelWidth;
      mipHeight = nextLevelHeight;
    }
  }

  // 4: Transition all levels and layers (faces) to their final layout
  lvk::imageMemoryBarrier2(
      commandBuffer,
      vkImage_,
      StageAccess{.stage = VK_PIPELINE_STAGE_2_TRANSFER_BIT, .access = VK_ACCESS_2_TRANSFER_READ_BIT},
      StageAccess{.stage = VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, .access = VK_ACCESS_2_MEMORY_READ_BIT | VK_ACCESS_2_MEMORY_WRITE_BIT},
      VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, // oldImageLayout
      originalImageLayout, // newImageLayout
      VkImageSubresourceRange{imageAspectFlags, 0, numLevels_, 0, numLayers_});

  if (vkCmdEndDebugUtilsLabelEXT) {
    vkCmdEndDebugUtilsLabelEXT(commandBuffer);
  }

  vkImageLayout_ = originalImageLayout;
}

bool lvk::VulkanImage::isDepthFormat(VkFormat format) {
  return (format == VK_FORMAT_D16_UNORM) || (format == VK_FORMAT_X8_D24_UNORM_PACK32) || (format == VK_FORMAT_D32_SFLOAT) ||
         (format == VK_FORMAT_D16_UNORM_S8_UINT) || (format == VK_FORMAT_D24_UNORM_S8_UINT) || (format == VK_FORMAT_D32_SFLOAT_S8_UINT);
}

bool lvk::VulkanImage::isStencilFormat(VkFormat format) {
  return (format == VK_FORMAT_S8_UINT) || (format == VK_FORMAT_D16_UNORM_S8_UINT) || (format == VK_FORMAT_D24_UNORM_S8_UINT) ||
         (format == VK_FORMAT_D32_SFLOAT_S8_UINT);
}

VkImageView lvk::VulkanImage::getOrCreateVkImageViewForFramebuffer(VulkanContext& ctx, uint8_t level, uint16_t layer, uint32_t viewMask) {
  LVK_ASSERT(level < LVK_MAX_MIP_LEVELS);
  LVK_ASSERT(layer < LVK_ARRAY_NUM_ELEMENTS(imageViewForFramebuffer_[0]));
  LVK_ASSERT(!viewMask || layer == 0);

  if (level >= LVK_MAX_MIP_LEVELS || layer >= LVK_ARRAY_NUM_ELEMENTS(imageViewForFramebuffer_[0])) {
    return VK_NULL_HANDLE;
  }

  if (!viewMask && imageViewForFramebuffer_[level][layer] != VK_NULL_HANDLE) {
    return imageViewForFramebuffer_[level][layer];
  }
  if (viewMask && imageViewForFramebufferMultiview_[level] != VK_NULL_HANDLE) {
    return imageViewForFramebufferMultiview_[level];
  }

  char debugNameImageView[320] = {0};
  snprintf(debugNameImageView,
           sizeof(debugNameImageView) - 1,
           "Image View: '%s' imageViewForFramebuffer[%u][%u][%u]",
           debugName_,
           level,
           layer,
           viewMask);

  const uint32_t numViews = viewMask ?
#if defined(_MSC_VER)
                                     _mm_popcnt_u32(viewMask)
#else
                                     __builtin_popcount(viewMask)
#endif
                                     : 1;

  VkImageView view = createImageView(ctx.getVkDevice(),
                                     viewMask ? VK_IMAGE_VIEW_TYPE_2D_ARRAY : VK_IMAGE_VIEW_TYPE_2D,
                                     vkImageFormat_,
                                     getImageAspectFlags(),
                                     level,
                                     1u,
                                     layer,
                                     numViews,
                                     {},
                                     nullptr,
                                     debugNameImageView);

  if (viewMask) {
    imageViewForFramebufferMultiview_[level] = view;
  } else {
    imageViewForFramebuffer_[level][layer] = view;
  }

  return view;
}

lvk::VulkanSwapchain::VulkanSwapchain(VulkanContext& ctx, uint32_t width, uint32_t height)
: ctx_(ctx)
, device_(ctx.vkDevice_)
, graphicsQueue_(ctx.deviceQueues_.graphicsQueue)
, width_(width)
, height_(height) {
  surfaceFormat_ =
      chooseSwapSurfaceFormat(ctx.deviceSurfaceFormats_, ctx.config_.swapchainRequestedColorSpace, ctx.has_EXT_swapchain_colorspace_);

  LVK_ASSERT_MSG(ctx.vkSurface_ != VK_NULL_HANDLE,
                 "You are trying to create a swapchain but your OS surface is empty. Did you want to "
                 "create an offscreen rendering context? If so, set 'width' and 'height' to 0 when you "
                 "create your lvk::IContext");

  VkBool32 queueFamilySupportsPresentation = VK_FALSE;
  VK_ASSERT(vkGetPhysicalDeviceSurfaceSupportKHR(
      ctx.getVkPhysicalDevice(), ctx.deviceQueues_.graphicsQueueFamilyIndex, ctx.vkSurface_, &queueFamilySupportsPresentation));
  LVK_ASSERT_MSG(queueFamilySupportsPresentation == VK_TRUE, "The queue family used with the swapchain does not support presentation");

  auto chooseSwapImageCount = [](const VkSurfaceCapabilitiesKHR& caps) -> uint32_t {
    const uint32_t desired = caps.minImageCount + 1;
    const bool exceeded = caps.maxImageCount > 0 && desired > caps.maxImageCount;
    return exceeded ? caps.maxImageCount : desired;
  };

  auto chooseSwapPresentMode = [config = &ctx.config_](const std::vector<VkPresentModeKHR>& modes) -> VkPresentModeKHR {
    for (lvk::PresentMode mode : config->presentModes) {
      const VkPresentModeKHR vkMode = presentModeToVkPresentMode(mode);
      if (std::find(modes.cbegin(), modes.cend(), vkMode) != modes.cend()) {
        return vkMode;
      }
    }
    return VK_PRESENT_MODE_FIFO_KHR;
  };

  VkSurfaceCapabilitiesKHR caps = {};
  VK_ASSERT(vkGetPhysicalDeviceSurfaceCapabilitiesKHR(ctx.getVkPhysicalDevice(), ctx.vkSurface_, &caps));

  VkFormatProperties2 props = {
      .sType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2,
  };
  vkGetPhysicalDeviceFormatProperties2(ctx.getVkPhysicalDevice(), surfaceFormat_.format, &props);

  // trim the image extent
  width_ = width = std::min(width, caps.maxImageExtent.width);
  height_ = height = std::min(height, caps.maxImageExtent.width);

  auto chooseUsageFlags = [](const VkSurfaceCapabilitiesKHR& caps, const VkFormatProperties& props) -> VkImageUsageFlags {
    VkImageUsageFlags usageFlags = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_TRANSFER_SRC_BIT;

    const bool isStorageSupported = (caps.supportedUsageFlags & VK_IMAGE_USAGE_STORAGE_BIT) > 0;
    const bool isTilingOptimalSupported = (props.optimalTilingFeatures & VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT) > 0;

    if (isStorageSupported && isTilingOptimalSupported) {
      usageFlags |= VK_IMAGE_USAGE_STORAGE_BIT;
    }

    return usageFlags;
  };

  currentPresentMode_ = chooseSwapPresentMode(ctx.devicePresentModes_);

  // query modes compatible with presentMode
  std::vector<VkPresentModeKHR> compatiblePresentModes;
  if (ctx.has_KHR_swapchain_maintenance1_) {
    const VkSurfacePresentModeKHR surfacePresentMode = {
        .sType = VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR,
        .presentMode = currentPresentMode_,
    };
    const VkPhysicalDeviceSurfaceInfo2KHR surfaceInfo = {
        .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR,
        .pNext = &surfacePresentMode,
        .surface = ctx.vkSurface_,
    };
    VkSurfacePresentModeCompatibilityKHR compatibility = {
        .sType = VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR,
    };
    VkSurfaceCapabilities2KHR caps2 = {
        .sType = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR,
        .pNext = &compatibility,
    };
    vkGetPhysicalDeviceSurfaceCapabilities2KHR(ctx.getVkPhysicalDevice(), &surfaceInfo, &caps2);
    compatiblePresentModes.resize(compatibility.presentModeCount);
    compatibility.pPresentModes = compatiblePresentModes.data();
    vkGetPhysicalDeviceSurfaceCapabilities2KHR(ctx.getVkPhysicalDevice(), &surfaceInfo, &caps2);
  }

  registeredPresentModes_[numRegisteredPresentModes_++] = currentPresentMode_;
  // keep every compatible entry from ContextConfig::presentModes[]
  for (const lvk::PresentMode m : ctx.config_.presentModes) {
    const VkPresentModeKHR vk = presentModeToVkPresentMode(m);
    if (!std::count(compatiblePresentModes.cbegin(), compatiblePresentModes.cend(), vk)) {
      continue; // not compatible with the chosen presentMode
    }
    if (std::count(std::cbegin(registeredPresentModes_), std::cbegin(registeredPresentModes_) + numRegisteredPresentModes_, vk)) {
      continue; // already registered
    }
    registeredPresentModes_[numRegisteredPresentModes_++] = vk;
  }

  const VkImageUsageFlags usageFlags = chooseUsageFlags(caps, props.formatProperties);
  const bool isCompositeAlphaOpaqueSupported = (ctx.deviceSurfaceCaps_.supportedCompositeAlpha & VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR) != 0;

  const VkSwapchainPresentModesCreateInfoKHR pmci = {
      .sType = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR,
      .presentModeCount = numRegisteredPresentModes_,
      .pPresentModes = registeredPresentModes_,
  };
  const VkSwapchainCreateInfoKHR ci = {
      .sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR,
      .pNext = ctx.has_KHR_swapchain_maintenance1_ ? &pmci : nullptr,
      .surface = ctx.vkSurface_,
      .minImageCount = chooseSwapImageCount(ctx.deviceSurfaceCaps_),
      .imageFormat = surfaceFormat_.format,
      .imageColorSpace = surfaceFormat_.colorSpace,
      .imageExtent = {.width = width, .height = height},
      .imageArrayLayers = 1,
      .imageUsage = usageFlags,
      .imageSharingMode = VK_SHARING_MODE_EXCLUSIVE,
      .queueFamilyIndexCount = 1,
      .pQueueFamilyIndices = &ctx.deviceQueues_.graphicsQueueFamilyIndex,
#if defined(ANDROID)
      .preTransform = VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR,
#else
      .preTransform = ctx.deviceSurfaceCaps_.currentTransform,
#endif
      .compositeAlpha = isCompositeAlphaOpaqueSupported ? VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR : VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR,
      .presentMode = currentPresentMode_,
      .clipped = VK_TRUE,
      .oldSwapchain = VK_NULL_HANDLE,
  };
  VK_ASSERT(vkCreateSwapchainKHR(device_, &ci, nullptr, &swapchain_));

  if (ctx_.has_EXT_hdr_metadata_) {
    const VkHdrMetadataEXT metadata = {
        .sType = VK_STRUCTURE_TYPE_HDR_METADATA_EXT,
        .displayPrimaryRed = {.x = 0.680f, .y = 0.320f},
        .displayPrimaryGreen = {.x = 0.265f, .y = 0.690f},
        .displayPrimaryBlue = {.x = 0.150f, .y = 0.060f},
        .whitePoint = {.x = 0.3127f, .y = 0.3290f},
        .maxLuminance = 80.0f,
        .minLuminance = 0.001f,
        .maxContentLightLevel = 2000.0f,
        .maxFrameAverageLightLevel = 500.0f,
    };
    vkSetHdrMetadataEXT(device_, 1, &swapchain_, &metadata);
  }

  VkImage swapchainImages[LVK_MAX_SWAPCHAIN_IMAGES];
  VK_ASSERT(vkGetSwapchainImagesKHR(device_, swapchain_, &numSwapchainImages_, nullptr));
  if (numSwapchainImages_ > LVK_MAX_SWAPCHAIN_IMAGES) {
    LVK_ASSERT(numSwapchainImages_ <= LVK_MAX_SWAPCHAIN_IMAGES);
    numSwapchainImages_ = LVK_MAX_SWAPCHAIN_IMAGES;
  }
  VK_ASSERT(vkGetSwapchainImagesKHR(device_, swapchain_, &numSwapchainImages_, swapchainImages));

  LVK_ASSERT(numSwapchainImages_ > 0);

  char debugNameImage[256] = {0};
  char debugNameImageView[256] = {0};

  // create images, image views and framebuffers
  for (uint32_t i = 0; i < numSwapchainImages_; i++) {
    acquireSemaphore_[i] = lvk::createSemaphore(device_, "Semaphore: swapchain-acquire");

    if (!ctx_.has_KHR_swapchain_maintenance1_) {
      char debugNameFence[256] = {0};
      snprintf(debugNameFence, sizeof(debugNameFence) - 1, "Fence: swapchain %u", i);
      acquireFence_[i] = lvk::createFence(device_, debugNameFence, true);
    }

    snprintf(debugNameImage, sizeof(debugNameImage) - 1, "Image: swapchain %u", i);
    snprintf(debugNameImageView, sizeof(debugNameImageView) - 1, "Image View: swapchain %u", i);
    VulkanImage image = {
        .vkImage_ = swapchainImages[i],
        .vkUsageFlags_ = usageFlags,
        .vkExtent_ = VkExtent3D{.width = width_, .height = height_, .depth = 1},
        .vkType_ = VK_IMAGE_TYPE_2D,
        .vkImageFormat_ = surfaceFormat_.format,
        .isSwapchainImage_ = true,
        .isOwningVkImage_ = false,
        .isDepthFormat_ = VulkanImage::isDepthFormat(surfaceFormat_.format),
        .isStencilFormat_ = VulkanImage::isStencilFormat(surfaceFormat_.format),
    };

    VK_ASSERT(lvk::setDebugObjectName(device_, VK_OBJECT_TYPE_IMAGE, (uint64_t)image.vkImage_, debugNameImage));

    image.imageView_ = image.createImageView(device_,
                                             VK_IMAGE_VIEW_TYPE_2D,
                                             surfaceFormat_.format,
                                             VK_IMAGE_ASPECT_COLOR_BIT,
                                             0,
                                             VK_REMAINING_MIP_LEVELS,
                                             0,
                                             1,
                                             {},
                                             nullptr,
                                             debugNameImageView);

    swapchainTextures_[i] = ctx_.texturesPool_.create(std::move(image));
  }
}

lvk::VulkanSwapchain::~VulkanSwapchain() {
  for (TextureHandle handle : swapchainTextures_) {
    ctx_.destroy(handle);
  }
  vkDestroySwapchainKHR(device_, swapchain_, nullptr);
  for (VkSemaphore sem : acquireSemaphore_) {
    vkDestroySemaphore(device_, sem, nullptr);
  }
  for (VkFence fence : presentFence_) {
    if (fence)
      vkDestroyFence(device_, fence, nullptr);
  }
  for (VkFence fence : acquireFence_) {
    if (fence)
      vkDestroyFence(device_, fence, nullptr);
  }
}

VkImage lvk::VulkanSwapchain::getCurrentVkImage() const {
  if (LVK_VERIFY(currentImageIndex_ < numSwapchainImages_)) {
    lvk::VulkanImage* tex = ctx_.texturesPool_.get(swapchainTextures_[currentImageIndex_]);
    return tex->vkImage_;
  }
  return VK_NULL_HANDLE;
}

VkImageView lvk::VulkanSwapchain::getCurrentVkImageView() const {
  if (LVK_VERIFY(currentImageIndex_ < numSwapchainImages_)) {
    lvk::VulkanImage* tex = ctx_.texturesPool_.get(swapchainTextures_[currentImageIndex_]);
    return tex->imageView_;
  }
  return VK_NULL_HANDLE;
}

lvk::TextureHandle lvk::VulkanSwapchain::getCurrentTexture() {
  LVK_PROFILER_FUNCTION();

  if (getNextImage_) {
    const VkSemaphoreWaitInfo waitInfo = {
        .sType = VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO,
        .semaphoreCount = 1,
        .pSemaphores = &ctx_.timelineSemaphore_,
        .pValues = &timelineWaitValues_[currentImageIndex_],
    };
    VK_ASSERT(vkWaitSemaphores(device_, &waitInfo, UINT64_MAX));

    VkFence acquireFence = VK_NULL_HANDLE;

    if (ctx_.has_KHR_swapchain_maintenance1_) {
      // VK_KHR_swapchain_maintenance1: before acquiring again, wait for the presentation operation to finish
      if (presentFence_[currentImageIndex_]) {
        VK_ASSERT(vkWaitForFences(device_, 1, &presentFence_[currentImageIndex_], VK_TRUE, UINT64_MAX));
        VK_ASSERT(vkResetFences(device_, 1, &presentFence_[currentImageIndex_]));
      }
    } else {
      // without VK_KHR_swapchain_maintenance1: use acquire fences to synchronize semaphore reuse
      VK_ASSERT(vkWaitForFences(device_, 1, &acquireFence_[currentImageIndex_], VK_TRUE, UINT64_MAX));
      VK_ASSERT(vkResetFences(device_, 1, &acquireFence_[currentImageIndex_]));

      acquireFence = acquireFence_[currentImageIndex_];
    }

    VkSemaphore acquireSemaphore = acquireSemaphore_[currentImageIndex_];
    // when timeout is set to UINT64_MAX, we wait until the next image has been acquired
    VkResult r = vkAcquireNextImageKHR(device_, swapchain_, UINT64_MAX, acquireSemaphore, acquireFence, &currentImageIndex_);
    if (r != VK_SUCCESS && r != VK_SUBOPTIMAL_KHR && r != VK_ERROR_OUT_OF_DATE_KHR) {
      VK_ASSERT(r);
    }
    getNextImage_ = false;
    ctx_.immediate_->waitSemaphore(acquireSemaphore);
  }

  if (LVK_VERIFY(currentImageIndex_ < numSwapchainImages_)) {
    return swapchainTextures_[currentImageIndex_];
  }

  return {};
}

const VkSurfaceFormatKHR& lvk::VulkanSwapchain::getSurfaceFormat() const {
  return surfaceFormat_;
}

uint32_t lvk::VulkanSwapchain::getNumSwapchainImages() const {
  return numSwapchainImages_;
}

uint32_t lvk::VulkanSwapchain::getSwapchainCurrentImageIndex() const {
  return currentImageIndex_;
}

bool lvk::VulkanSwapchain::setCurrentPresentMode(VkPresentModeKHR mode) {
  for (uint32_t i = 0; i != numRegisteredPresentModes_; i++) {
    if (registeredPresentModes_[i] == mode) {
      currentPresentMode_ = mode;
      presentFenceInfo_.pNext = &presentModeInfo_; // switch to the new present mode in the next present() call
      return true;
    }
  }
  return false;
}

lvk::Result lvk::VulkanSwapchain::present(VkSemaphore waitSemaphore) {
  LVK_PROFILER_FUNCTION();

  LVK_PROFILER_ZONE("vkQueuePresent()", LVK_PROFILER_COLOR_PRESENT);
  if (ctx_.has_KHR_swapchain_maintenance1_ && !presentFence_[currentImageIndex_]) {
    presentFence_[currentImageIndex_] = lvk::createFence(device_, "Fence: present-fence");
  }
  presentFenceInfo_.pFences = &presentFence_[currentImageIndex_];
  const VkPresentInfoKHR pi = {
      .sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,
      .pNext = ctx_.has_KHR_swapchain_maintenance1_ ? &presentFenceInfo_ : nullptr,
      .waitSemaphoreCount = 1,
      .pWaitSemaphores = &waitSemaphore,
      .swapchainCount = 1u,
      .pSwapchains = &swapchain_,
      .pImageIndices = &currentImageIndex_,
  };
  VkResult r = vkQueuePresentKHR(graphicsQueue_, &pi);
  if (r != VK_SUCCESS && r != VK_SUBOPTIMAL_KHR && r != VK_ERROR_OUT_OF_DATE_KHR) {
    VK_ASSERT(r);
  }
  LVK_PROFILER_ZONE_END();

  // drop the previous present mode so we don't set it again in the next `present()` call if the present mode is not switched at runtime
  presentFenceInfo_.pNext = nullptr;

  // ready to call `acquireNextImage()` on the next `getCurrentVulkanTexture()`
  getNextImage_ = true;
  currentFrameIndex_++;

  LVK_PROFILER_FRAME(nullptr);

  return Result();
}

lvk::VulkanImmediateCommands::VulkanImmediateCommands(VkDevice device,
                                                      uint32_t queueFamilyIndex,
                                                      bool has_EXT_device_fault,
                                                      const char* debugName)
: device_(device)
, queueFamilyIndex_(queueFamilyIndex)
, has_EXT_device_fault_(has_EXT_device_fault)
, debugName_(debugName) {
  LVK_PROFILER_FUNCTION_COLOR(LVK_PROFILER_COLOR_CREATE);

  vkGetDeviceQueue(device, queueFamilyIndex, 0, &queue_);

  const VkCommandPoolCreateInfo ci = {
      .sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,
      .flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT | VK_COMMAND_POOL_CREATE_TRANSIENT_BIT,
      .queueFamilyIndex = queueFamilyIndex,
  };
  VK_ASSERT(vkCreateCommandPool(device, &ci, nullptr, &commandPool_));
  VK_ASSERT(lvk::setDebugObjectName(device, VK_OBJECT_TYPE_COMMAND_POOL, (uint64_t)commandPool_, debugName));

  const VkCommandBufferAllocateInfo ai = {
      .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,
      .commandPool = commandPool_,
      .level = VK_COMMAND_BUFFER_LEVEL_PRIMARY,
      .commandBufferCount = 1,
  };

  for (uint32_t i = 0; i != kMaxCommandBuffers; i++) {
    CommandBufferWrapper& buf = buffers_[i];
    char fenceName[256] = {0};
    char semaphoreName[256] = {0};
    if (debugName) {
      snprintf(fenceName, sizeof(fenceName) - 1, "Fence: %s (cmdbuf %u)", debugName, i);
      snprintf(semaphoreName, sizeof(semaphoreName) - 1, "Semaphore: %s (cmdbuf %u)", debugName, i);
    }
    buf.semaphore_ = lvk::createSemaphore(device, semaphoreName);
    buf.fence_ = lvk::createFence(device, fenceName);
    VK_ASSERT(vkAllocateCommandBuffers(device, &ai, &buf.cmdBufAllocated_));
    buffers_[i].handle_.bufferIndex_ = i;
  }
}

lvk::VulkanImmediateCommands::~VulkanImmediateCommands() {
  LVK_PROFILER_FUNCTION_COLOR(LVK_PROFILER_COLOR_DESTROY);

  waitAll();

  for (CommandBufferWrapper& buf : buffers_) {
    // lifetimes of all VkFence objects are managed explicitly we do not use deferredTask() for them
    vkDestroyFence(device_, buf.fence_, nullptr);
    vkDestroySemaphore(device_, buf.semaphore_, nullptr);
  }

  vkDestroyCommandPool(device_, commandPool_, nullptr);
}

void lvk::VulkanImmediateCommands::purge() {
  LVK_PROFILER_FUNCTION();

  const uint32_t numBuffers = static_cast<uint32_t>(LVK_ARRAY_NUM_ELEMENTS(buffers_));

  for (uint32_t i = 0; i != numBuffers; i++) {
    // always start checking with the oldest submitted buffer, then wrap around
    CommandBufferWrapper& buf = buffers_[(i + lastSubmitHandle_.bufferIndex_ + 1) % numBuffers];

    if (buf.cmdBuf_ == VK_NULL_HANDLE || buf.isEncoding_) {
      continue;
    }

    const VkResult result = vkWaitForFences(device_, 1, &buf.fence_, VK_TRUE, 0);

    if (result == VK_SUCCESS) {
      VK_ASSERT(vkResetCommandBuffer(buf.cmdBuf_, VkCommandBufferResetFlags{0}));
      VK_ASSERT(vkResetFences(device_, 1, &buf.fence_));
      buf.cmdBuf_ = VK_NULL_HANDLE;
      numAvailableCommandBuffers_++;
    } else {
      if (result != VK_TIMEOUT) {
        VK_ASSERT(result);
      }
    }
  }
}

const lvk::VulkanImmediateCommands::CommandBufferWrapper& lvk::VulkanImmediateCommands::acquire() {
  LVK_PROFILER_FUNCTION();

  if (!numAvailableCommandBuffers_) {
    purge();
  }

  while (!numAvailableCommandBuffers_) {
    LLOGL("Waiting for command buffers...\n");
    LVK_PROFILER_ZONE("Waiting for command buffers...", LVK_PROFILER_COLOR_WAIT);
    purge();
    LVK_PROFILER_ZONE_END();
  }

  VulkanImmediateCommands::CommandBufferWrapper* current = nullptr;

  // we are ok with any available buffer
  for (CommandBufferWrapper& buf : buffers_) {
    if (buf.cmdBuf_ == VK_NULL_HANDLE) {
      current = &buf;
      break;
    }
  }

  // make clang happy
  assert(current);

  LVK_ASSERT_MSG(numAvailableCommandBuffers_, "No available command buffers");
  LVK_ASSERT_MSG(current, "No available command buffers");
  LVK_ASSERT(current->cmdBufAllocated_ != VK_NULL_HANDLE);

  current->handle_.submitId_ = submitCounter_;
  numAvailableCommandBuffers_--;

  current->cmdBuf_ = current->cmdBufAllocated_;
  current->isEncoding_ = true;
  const VkCommandBufferBeginInfo bi = {
      .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,
      .flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT,
  };
  VK_ASSERT(vkBeginCommandBuffer(current->cmdBuf_, &bi));

  nextSubmitHandle_ = current->handle_;

  return *current;
}

void lvk::VulkanImmediateCommands::wait(const SubmitHandle handle) {
  LVK_PROFILER_FUNCTION_COLOR(LVK_PROFILER_COLOR_WAIT);

  if (handle.empty()) {
    vkDeviceWaitIdle(device_);
    return;
  }

  if (isReady(handle)) {
    return;
  }

  if (!LVK_VERIFY(!buffers_[handle.bufferIndex_].isEncoding_)) {
    // we are waiting for a buffer which has not been submitted - this is probably a logic error somewhere in the calling code
    return;
  }

  VK_ASSERT(vkWaitForFences(device_, 1, &buffers_[handle.bufferIndex_].fence_, VK_TRUE, UINT64_MAX));

  purge();
}

void lvk::VulkanImmediateCommands::waitAll() {
  LVK_PROFILER_FUNCTION_COLOR(LVK_PROFILER_COLOR_WAIT);

  VkFence fences[kMaxCommandBuffers];

  uint32_t numFences = 0;

  for (const CommandBufferWrapper& buf : buffers_) {
    if (buf.cmdBuf_ != VK_NULL_HANDLE && !buf.isEncoding_) {
      fences[numFences++] = buf.fence_;
    }
  }

  if (numFences) {
    VK_ASSERT(vkWaitForFences(device_, numFences, fences, VK_TRUE, UINT64_MAX));
  }

  purge();
}

bool lvk::VulkanImmediateCommands::isReady(const SubmitHandle handle, bool fastCheckNoVulkan) const {
  LVK_ASSERT(handle.bufferIndex_ < kMaxCommandBuffers);

  if (handle.empty()) {
    // a null handle
    return true;
  }

  const CommandBufferWrapper& buf = buffers_[handle.bufferIndex_];

  if (buf.cmdBuf_ == VK_NULL_HANDLE) {
    // already recycled and not yet reused
    return true;
  }

  if (buf.handle_.submitId_ != handle.submitId_) {
    // already recycled and reused by another command buffer
    return true;
  }

  if (fastCheckNoVulkan) {
    // do not ask the Vulkan API about it, just let it retire naturally (when submitId for this bufferIndex gets incremented)
    return false;
  }

  return vkWaitForFences(device_, 1, &buf.fence_, VK_TRUE, 0) == VK_SUCCESS;
}

lvk::SubmitHandle lvk::VulkanImmediateCommands::submit(const CommandBufferWrapper& wrapper) {
  LVK_PROFILER_FUNCTION_COLOR(LVK_PROFILER_COLOR_SUBMIT);
  LVK_ASSERT(wrapper.isEncoding_);
  VK_ASSERT(vkEndCommandBuffer(wrapper.cmdBuf_));

  VkSemaphoreSubmitInfo waitSemaphores[] = {{}, {}};
  uint32_t numWaitSemaphores = 0;
  if (waitSemaphore_.semaphore) {
    waitSemaphores[numWaitSemaphores++] = waitSemaphore_;
  }
  if (lastSubmitSemaphore_.semaphore) {
    waitSemaphores[numWaitSemaphores++] = lastSubmitSemaphore_;
  }
  VkSemaphoreSubmitInfo signalSemaphores[] = {
      VkSemaphoreSubmitInfo{.sType = VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO,
                            .semaphore = wrapper.semaphore_,
                            .stageMask = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT},
      {},
  };
  uint32_t numSignalSemaphores = 1;
  if (signalSemaphore_.semaphore) {
    signalSemaphores[numSignalSemaphores++] = signalSemaphore_;
  }

  LVK_PROFILER_ZONE("vkQueueSubmit2()", LVK_PROFILER_COLOR_SUBMIT);
#if LVK_VULKAN_PRINT_COMMANDS
  LLOGL("%p vkQueueSubmit2()\n\n", wrapper.cmdBuf_);
#endif // LVK_VULKAN_PRINT_COMMANDS
  const VkCommandBufferSubmitInfo bufferSI = {
      .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO,
      .commandBuffer = wrapper.cmdBuf_,
  };
  const VkSubmitInfo2 si = {
      .sType = VK_STRUCTURE_TYPE_SUBMIT_INFO_2,
      .waitSemaphoreInfoCount = numWaitSemaphores,
      .pWaitSemaphoreInfos = waitSemaphores,
      .commandBufferInfoCount = 1u,
      .pCommandBufferInfos = &bufferSI,
      .signalSemaphoreInfoCount = numSignalSemaphores,
      .pSignalSemaphoreInfos = signalSemaphores,
  };
  const VkResult result = vkQueueSubmit2(queue_, 1u, &si, wrapper.fence_);
  if (has_EXT_device_fault_ && result == VK_ERROR_DEVICE_LOST) {
    VkDeviceFaultCountsEXT count = {
        .sType = VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT,
    };
    vkGetDeviceFaultInfoEXT(device_, &count, nullptr);
    std::vector<VkDeviceFaultAddressInfoEXT> addressInfo(count.addressInfoCount);
    std::vector<VkDeviceFaultVendorInfoEXT> vendorInfo(count.vendorInfoCount);
    std::vector<uint8_t> binary(count.vendorBinarySize);
    VkDeviceFaultInfoEXT info = {
        .sType = VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT,
        .pAddressInfos = addressInfo.data(),
        .pVendorInfos = vendorInfo.data(),
        .pVendorBinaryData = binary.data(),
    };
    vkGetDeviceFaultInfoEXT(device_, &count, &info);
    LLOGW("VK_ERROR_DEVICE_LOST: %s\n", info.description);
    for (const VkDeviceFaultAddressInfoEXT& aInfo : addressInfo) {
      VkDeviceSize lowerAddress = aInfo.reportedAddress & ~(aInfo.addressPrecision - 1);
      VkDeviceSize upperAddress = aInfo.reportedAddress | (aInfo.addressPrecision - 1);
      LLOGW("...address range [ %" PRIx64 ", %" PRIx64 " ]: %s\n",
            lowerAddress,
            upperAddress,
            getVkDeviceFaultAddressTypeString(aInfo.addressType));
    }
    for (const VkDeviceFaultVendorInfoEXT& vInfo : vendorInfo) {
      LLOGW("...caused by `%s` with error code %" PRIx64 " and data %" PRIx64 "\n",
            vInfo.description,
            vInfo.vendorFaultCode,
            vInfo.vendorFaultData);
    }
    const VkDeviceSize binarySize = count.vendorBinarySize;
    if (info.pVendorBinaryData && binarySize >= sizeof(VkDeviceFaultVendorBinaryHeaderVersionOneEXT)) {
      const VkDeviceFaultVendorBinaryHeaderVersionOneEXT* header =
          std::launder(reinterpret_cast<const VkDeviceFaultVendorBinaryHeaderVersionOneEXT*>(info.pVendorBinaryData));
      const char hexDigits[] = "0123456789abcdef";
      char uuid[VK_UUID_SIZE * 2 + 1] = {};
      for (uint32_t i = 0; i < VK_UUID_SIZE; ++i) {
        uuid[i * 2 + 0] = hexDigits[(header->pipelineCacheUUID[i] >> 4) & 0xF];
        uuid[i * 2 + 1] = hexDigits[header->pipelineCacheUUID[i] & 0xF];
      }
      LLOGW("VkDeviceFaultVendorBinaryHeaderVersionOne:");
      LLOGW("   headerSize        : %u\n", header->headerSize);
      LLOGW("   headerVersion     : %u\n", (uint32_t)header->headerVersion);
      LLOGW("   vendorID          : %u\n", header->vendorID);
      LLOGW("   deviceID          : %u\n", header->deviceID);
      LLOGW("   driverVersion     : %u\n", header->driverVersion);
      LLOGW("   pipelineCacheUUID : %s\n", uuid);
      if (header->applicationNameOffset && header->applicationNameOffset < binarySize) {
        LLOGW("   applicationName   : %s\n", (const char*)info.pVendorBinaryData + header->applicationNameOffset);
      }
      LLOGW("   applicationVersion: %i.%i.%i\n",
            VK_API_VERSION_MAJOR(header->applicationVersion),
            VK_API_VERSION_MINOR(header->applicationVersion),
            VK_API_VERSION_PATCH(header->applicationVersion));
      if (header->engineNameOffset && header->engineNameOffset < binarySize) {
        LLOGW("   engineName        : %s\n", (const char*)info.pVendorBinaryData + header->engineNameOffset);
      }
      LLOGW("   engineVersion     : %i.%i.%i\n",
            VK_API_VERSION_MAJOR(header->engineVersion),
            VK_API_VERSION_MINOR(header->engineVersion),
            VK_API_VERSION_PATCH(header->engineVersion));
      LLOGW("   apiVersion        : %i.%i.%i.%i\n",
            VK_API_VERSION_MAJOR(header->apiVersion),
            VK_API_VERSION_MINOR(header->apiVersion),
            VK_API_VERSION_PATCH(header->apiVersion),
            VK_API_VERSION_VARIANT(header->apiVersion));
    }
  }
  VK_ASSERT(result);
  LVK_PROFILER_ZONE_END();

  lastSubmitSemaphore_.semaphore = wrapper.semaphore_;
  lastSubmitHandle_ = wrapper.handle_;
  waitSemaphore_.semaphore = VK_NULL_HANDLE;
  signalSemaphore_.semaphore = VK_NULL_HANDLE;

  // reset
  const_cast<CommandBufferWrapper&>(wrapper).isEncoding_ = false;
  submitCounter_++;

  if (!submitCounter_) {
    // skip the 0 value - when uint32_t wraps around (null SubmitHandle)
    submitCounter_++;
  }

  return lastSubmitHandle_;
}

void lvk::VulkanImmediateCommands::waitSemaphore(VkSemaphore semaphore) {
  LVK_ASSERT(waitSemaphore_.semaphore == VK_NULL_HANDLE);

  waitSemaphore_.semaphore = semaphore;
}

void lvk::VulkanImmediateCommands::signalSemaphore(VkSemaphore semaphore, uint64_t signalValue) {
  LVK_ASSERT(signalSemaphore_.semaphore == VK_NULL_HANDLE);

  signalSemaphore_.semaphore = semaphore;
  signalSemaphore_.value = signalValue;
}

VkSemaphore lvk::VulkanImmediateCommands::acquireLastSubmitSemaphore() {
  return std::exchange(lastSubmitSemaphore_.semaphore, VK_NULL_HANDLE);
}

VkFence lvk::VulkanImmediateCommands::getVkFence(lvk::SubmitHandle handle) const {
  if (handle.empty()) {
    return VK_NULL_HANDLE;
  }

  return buffers_[handle.bufferIndex_].fence_;
}

lvk::SubmitHandle lvk::VulkanImmediateCommands::getLastSubmitHandle() const {
  return lastSubmitHandle_;
}

lvk::SubmitHandle lvk::VulkanImmediateCommands::getNextSubmitHandle() const {
  return nextSubmitHandle_;
}

lvk::VulkanPipelineBuilder::VulkanPipelineBuilder()
: vertexInputState_(VkPipelineVertexInputStateCreateInfo{
      .sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,
      .vertexBindingDescriptionCount = 0,
      .pVertexBindingDescriptions = nullptr,
      .vertexAttributeDescriptionCount = 0,
      .pVertexAttributeDescriptions = nullptr,
  })
, inputAssembly_({
      .sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO,
      .flags = 0,
      .topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
      .primitiveRestartEnable = VK_FALSE,
  })
, tessellationState_({
      .sType = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO,
      .flags = 0,
      .patchControlPoints = 0,
  })
, rasterizationState_({
      .sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO,
      .flags = 0,
      .depthClampEnable = VK_FALSE,
      .rasterizerDiscardEnable = VK_FALSE,
      .polygonMode = VK_POLYGON_MODE_FILL,
      .cullMode = VK_CULL_MODE_NONE,
      .frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE,
      .depthBiasEnable = VK_FALSE,
      .depthBiasConstantFactor = 0.0f,
      .depthBiasClamp = 0.0f,
      .depthBiasSlopeFactor = 0.0f,
      .lineWidth = 1.0f,
  })
, multisampleState_({
      .sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,
      .rasterizationSamples = VK_SAMPLE_COUNT_1_BIT,
      .sampleShadingEnable = VK_FALSE,
      .minSampleShading = 0.0f,
      .pSampleMask = nullptr,
      .alphaToCoverageEnable = VK_FALSE,
      .alphaToOneEnable = VK_FALSE,
  })
, depthStencilState_({
      .sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO,
      .pNext = NULL,
      .flags = 0,
      .depthTestEnable = VK_FALSE,
      .depthWriteEnable = VK_FALSE,
      .depthCompareOp = VK_COMPARE_OP_LESS,
      .depthBoundsTestEnable = VK_FALSE,
      .stencilTestEnable = VK_FALSE,
      .front =
          {
              .failOp = VK_STENCIL_OP_KEEP,
              .passOp = VK_STENCIL_OP_KEEP,
              .depthFailOp = VK_STENCIL_OP_KEEP,
              .compareOp = VK_COMPARE_OP_NEVER,
              .compareMask = 0,
              .writeMask = 0,
              .reference = 0,
          },
      .back =
          {
              .failOp = VK_STENCIL_OP_KEEP,
              .passOp = VK_STENCIL_OP_KEEP,
              .depthFailOp = VK_STENCIL_OP_KEEP,
              .compareOp = VK_COMPARE_OP_NEVER,
              .compareMask = 0,
              .writeMask = 0,
              .reference = 0,
          },
      .minDepthBounds = 0.0f,
      .maxDepthBounds = 1.0f,
  }) {}

lvk::VulkanPipelineBuilder& lvk::VulkanPipelineBuilder::dynamicState(VkDynamicState state) {
  LVK_ASSERT(numDynamicStates_ < LVK_MAX_DYNAMIC_STATES);
  dynamicStates_[numDynamicStates_++] = state;
  return *this;
}

lvk::VulkanPipelineBuilder& lvk::VulkanPipelineBuilder::primitiveTopology(VkPrimitiveTopology topology) {
  inputAssembly_.topology = topology;
  return *this;
}

lvk::VulkanPipelineBuilder& lvk::VulkanPipelineBuilder::rasterizationSamples(VkSampleCountFlagBits samples, float minSampleShading) {
  multisampleState_.rasterizationSamples = samples;
  multisampleState_.sampleShadingEnable = minSampleShading > 0 ? VK_TRUE : VK_FALSE;
  multisampleState_.minSampleShading = minSampleShading;
  return *this;
}

lvk::VulkanPipelineBuilder& lvk::VulkanPipelineBuilder::cullMode(VkCullModeFlags mode) {
  rasterizationState_.cullMode = mode;
  return *this;
}

lvk::VulkanPipelineBuilder& lvk::VulkanPipelineBuilder::frontFace(VkFrontFace mode) {
  rasterizationState_.frontFace = mode;
  return *this;
}

lvk::VulkanPipelineBuilder& lvk::VulkanPipelineBuilder::polygonMode(VkPolygonMode mode) {
  rasterizationState_.polygonMode = mode;
  return *this;
}

lvk::VulkanPipelineBuilder& lvk::VulkanPipelineBuilder::vertexInputState(const VkPipelineVertexInputStateCreateInfo& state) {
  vertexInputState_ = state;
  return *this;
}

lvk::VulkanPipelineBuilder& lvk::VulkanPipelineBuilder::viewMask(uint32_t mask) {
  viewMask_ = mask;
  return *this;
}

lvk::VulkanPipelineBuilder& lvk::VulkanPipelineBuilder::colorAttachments(const VkPipelineColorBlendAttachmentState* states,
                                                                         const VkFormat* formats,
                                                                         uint32_t numColorAttachments) {
  LVK_ASSERT(states);
  LVK_ASSERT(formats);
  LVK_ASSERT(numColorAttachments <= LVK_ARRAY_NUM_ELEMENTS(colorBlendAttachmentStates_));
  LVK_ASSERT(numColorAttachments <= LVK_ARRAY_NUM_ELEMENTS(colorAttachmentFormats_));
  for (uint32_t i = 0; i != numColorAttachments; i++) {
    colorBlendAttachmentStates_[i] = states[i];
    colorAttachmentFormats_[i] = formats[i];
  }
  numColorAttachments_ = numColorAttachments;
  return *this;
}

lvk::VulkanPipelineBuilder& lvk::VulkanPipelineBuilder::depthAttachmentFormat(VkFormat format) {
  depthAttachmentFormat_ = format;
  return *this;
}

lvk::VulkanPipelineBuilder& lvk::VulkanPipelineBuilder::stencilAttachmentFormat(VkFormat format) {
  stencilAttachmentFormat_ = format;
  return *this;
}

lvk::VulkanPipelineBuilder& lvk::VulkanPipelineBuilder::patchControlPoints(uint32_t numPoints) {
  tessellationState_.patchControlPoints = numPoints;
  return *this;
}

lvk::VulkanPipelineBuilder& lvk::VulkanPipelineBuilder::shaderStage(VkPipelineShaderStageCreateInfo stage) {
  if (stage.pNext) {
    LVK_ASSERT(numShaderStages_ < LVK_ARRAY_NUM_ELEMENTS(shaderStages_));
    shaderStages_[numShaderStages_++] = stage;
  }
  return *this;
}

lvk::VulkanPipelineBuilder& lvk::VulkanPipelineBuilder::stencilStateOps(VkStencilFaceFlags faceMask,
                                                                        VkStencilOp failOp,
                                                                        VkStencilOp passOp,
                                                                        VkStencilOp depthFailOp,
                                                                        VkCompareOp compareOp) {
  depthStencilState_.stencilTestEnable = depthStencilState_.stencilTestEnable == VK_TRUE || failOp != VK_STENCIL_OP_KEEP ||
                                                 passOp != VK_STENCIL_OP_KEEP || depthFailOp != VK_STENCIL_OP_KEEP ||
                                                 compareOp != VK_COMPARE_OP_ALWAYS
                                             ? VK_TRUE
                                             : VK_FALSE;

  if (faceMask & VK_STENCIL_FACE_FRONT_BIT) {
    VkStencilOpState& s = depthStencilState_.front;
    s.failOp = failOp;
    s.passOp = passOp;
    s.depthFailOp = depthFailOp;
    s.compareOp = compareOp;
  }

  if (faceMask & VK_STENCIL_FACE_BACK_BIT) {
    VkStencilOpState& s = depthStencilState_.back;
    s.failOp = failOp;
    s.passOp = passOp;
    s.depthFailOp = depthFailOp;
    s.compareOp = compareOp;
  }
  return *this;
}

lvk::VulkanPipelineBuilder& lvk::VulkanPipelineBuilder::stencilMasks(VkStencilFaceFlags faceMask,
                                                                     uint32_t compareMask,
                                                                     uint32_t writeMask,
                                                                     uint32_t reference) {
  if (faceMask & VK_STENCIL_FACE_FRONT_BIT) {
    VkStencilOpState& s = depthStencilState_.front;
    s.compareMask = compareMask;
    s.writeMask = writeMask;
    s.reference = reference;
  }

  if (faceMask & VK_STENCIL_FACE_BACK_BIT) {
    VkStencilOpState& s = depthStencilState_.back;
    s.compareMask = compareMask;
    s.writeMask = writeMask;
    s.reference = reference;
  }
  return *this;
}

VkResult lvk::VulkanPipelineBuilder::build(VkDevice device,
                                           VkPipelineCache pipelineCache,
                                           VkPipelineLayout pipelineLayout,
                                           VkPipeline* outPipeline,
                                           const char* debugName) noexcept {
  const VkPipelineDynamicStateCreateInfo dynamicState = {
      .sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO,
      .dynamicStateCount = numDynamicStates_,
      .pDynamicStates = dynamicStates_,
  };
  // viewport and scissor can be NULL if the viewport state is dynamic
  // https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineViewportStateCreateInfo.html
  const VkPipelineViewportStateCreateInfo viewportState = {
      .sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO,
      .viewportCount = 1,
      .pViewports = nullptr,
      .scissorCount = 1,
      .pScissors = nullptr,
  };
  const VkPipelineColorBlendStateCreateInfo colorBlendState = {
      .sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO,
      .logicOpEnable = VK_FALSE,
      .logicOp = VK_LOGIC_OP_COPY,
      .attachmentCount = numColorAttachments_,
      .pAttachments = colorBlendAttachmentStates_,
  };
  const VkPipelineRenderingCreateInfo renderingInfo = {
      .sType = VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO_KHR,
      .pNext = nullptr,
      .viewMask = viewMask_,
      .colorAttachmentCount = numColorAttachments_,
      .pColorAttachmentFormats = colorAttachmentFormats_,
      .depthAttachmentFormat = depthAttachmentFormat_,
      .stencilAttachmentFormat = stencilAttachmentFormat_,
  };

  const VkGraphicsPipelineCreateInfo ci = {
      .sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
      .pNext = &renderingInfo,
      .flags = 0,
      .stageCount = numShaderStages_,
      .pStages = shaderStages_,
      .pVertexInputState = &vertexInputState_,
      .pInputAssemblyState = &inputAssembly_,
      .pTessellationState = &tessellationState_,
      .pViewportState = &viewportState,
      .pRasterizationState = &rasterizationState_,
      .pMultisampleState = &multisampleState_,
      .pDepthStencilState = &depthStencilState_,
      .pColorBlendState = &colorBlendState,
      .pDynamicState = &dynamicState,
      .layout = pipelineLayout,
      .renderPass = VK_NULL_HANDLE,
      .subpass = 0,
      .basePipelineHandle = VK_NULL_HANDLE,
      .basePipelineIndex = -1,
  };

#if defined(ANDROID)
  LLOGD("vkCreateGraphicsPipelines(): %s\n", debugName);
#endif // defined(ANDROID)
  const VkResult result = vkCreateGraphicsPipelines(device, pipelineCache, 1, &ci, nullptr, outPipeline);

  if (!LVK_VERIFY(result == VK_SUCCESS)) {
    return result;
  }

  numPipelinesCreated_++;

  // set debug name
  return lvk::setDebugObjectName(device, VK_OBJECT_TYPE_PIPELINE, (uint64_t)*outPipeline, debugName);
}

lvk::CommandBuffer::CommandBuffer(VulkanContext* ctx) : ctx_(ctx), wrapper_(&ctx_->immediate_->acquire()) {}

lvk::CommandBuffer::~CommandBuffer() {
  // did you forget to call cmdEndRendering()?
  LVK_ASSERT(!isRendering_);
}

void lvk::CommandBuffer::transitionToShaderReadOnly(TextureHandle handle) const {
  LVK_PROFILER_FUNCTION();

  const lvk::VulkanImage& img = *ctx_->texturesPool_.get(handle);

  LVK_ASSERT(!img.isSwapchainImage_);

  // transition only non-multisampled images - MSAA images cannot be accessed from shaders
  if (img.vkSamples_ == VK_SAMPLE_COUNT_1_BIT) {
    const VkImageAspectFlags flags = img.getImageAspectFlags();
    // set the result of the previous render pass
    img.transitionLayout(wrapper_->cmdBuf_,
                         img.isSampledImage() ? VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL : VK_IMAGE_LAYOUT_GENERAL,
                         VkImageSubresourceRange{flags, 0, VK_REMAINING_MIP_LEVELS, 0, VK_REMAINING_ARRAY_LAYERS});
  }
}

void lvk::CommandBuffer::transitionToRenderingLocalRead(TextureHandle handle) const {
  LVK_PROFILER_FUNCTION();

  const lvk::VulkanImage& img = *ctx_->texturesPool_.get(handle);

  LVK_ASSERT(!img.isSwapchainImage_);
  LVK_ASSERT_MSG(img.vkUsageFlags_ & VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT,
                 "Input attachment texture must have VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT (lvk::TextureUsageBits_InputAttachment)");

  const VkImageAspectFlags flags = img.getImageAspectFlags();
  img.transitionLayout(wrapper_->cmdBuf_,
                       VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ_KHR,
                       VkImageSubresourceRange{flags, 0, VK_REMAINING_MIP_LEVELS, 0, VK_REMAINING_ARRAY_LAYERS});
}

void lvk::CommandBuffer::cmdBindRayTracingPipeline(lvk::RayTracingPipelineHandle handle) {
  LVK_PROFILER_FUNCTION();

  if (!LVK_VERIFY(!handle.empty() && ctx_->has_KHR_ray_tracing_pipeline_)) {
    return;
  }

  currentPipelineGraphics_ = {};
  currentPipelineCompute_ = {};
  currentPipelineRayTracing_ = handle;

  VkPipeline pipeline = ctx_->getVkPipeline(handle);

  const lvk::RayTracingPipelineState* rtps = ctx_->rayTracingPipelinesPool_.get(handle);

  LVK_ASSERT(rtps);
  LVK_ASSERT(pipeline != VK_NULL_HANDLE);

  if (lastPipelineBound_ != pipeline) {
    lastPipelineBound_ = pipeline;
    vkCmdBindPipeline(wrapper_->cmdBuf_, VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR, pipeline);
    ctx_->checkAndUpdateDescriptorSets();
    ctx_->bindDefaultDescriptorSets(wrapper_->cmdBuf_, VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR, rtps->pipelineLayout_);
  }
}

void lvk::CommandBuffer::cmdBindComputePipeline(lvk::ComputePipelineHandle handle) {
  LVK_PROFILER_FUNCTION();

  if (!LVK_VERIFY(!handle.empty())) {
    return;
  }

  currentPipelineGraphics_ = {};
  currentPipelineCompute_ = handle;
  currentPipelineRayTracing_ = {};

  VkPipeline pipeline = ctx_->getVkPipeline(handle);

  const lvk::ComputePipelineState* cps = ctx_->computePipelinesPool_.get(handle);

  LVK_ASSERT(cps);
  LVK_ASSERT(pipeline != VK_NULL_HANDLE);

  if (lastPipelineBound_ != pipeline) {
    lastPipelineBound_ = pipeline;
    vkCmdBindPipeline(wrapper_->cmdBuf_, VK_PIPELINE_BIND_POINT_COMPUTE, pipeline);
    ctx_->checkAndUpdateDescriptorSets();
    ctx_->bindDefaultDescriptorSets(wrapper_->cmdBuf_, VK_PIPELINE_BIND_POINT_COMPUTE, cps->pipelineLayout_);
  }
}

void lvk::CommandBuffer::cmdDispatchThreadGroups(const Dimensions& threadgroupCount, const Dependencies& deps) {
  LVK_PROFILER_FUNCTION();
  LVK_PROFILER_GPU_ZONE("cmdDispatchThreadGroups()", ctx_, wrapper_->cmdBuf_, LVK_PROFILER_COLOR_CMD_DISPATCH);

  LVK_ASSERT(!isRendering_);

  for (uint32_t i = 0; i != Dependencies::LVK_MAX_SUBMIT_DEPENDENCIES && deps.textures[i]; i++) {
    useComputeTexture(deps.textures[i], VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT);
  }
  for (uint32_t i = 0; i != Dependencies::LVK_MAX_SUBMIT_DEPENDENCIES && deps.buffers[i]; i++) {
    const lvk::VulkanBuffer* buf = ctx_->buffersPool_.get(deps.buffers[i]);
    LVK_ASSERT_MSG(buf->vkUsageFlags_ & VK_BUFFER_USAGE_STORAGE_BUFFER_BIT,
                   "Did you forget to specify BufferUsageBits_Storage on your buffer?");
    bufferBarrier(deps.buffers[i],
                  VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT | VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT,
                  VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT);
  }

  vkCmdDispatch(wrapper_->cmdBuf_, threadgroupCount.width, threadgroupCount.height, threadgroupCount.depth);
}

void lvk::CommandBuffer::cmdPushDebugGroupLabel(const char* label, uint32_t colorRGBA) const {
  LVK_ASSERT(label);

  if (!label || !vkCmdBeginDebugUtilsLabelEXT) {
    return;
  }
  const VkDebugUtilsLabelEXT utilsLabel = {
      .sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT,
      .pNext = nullptr,
      .pLabelName = label,
      .color = {float((colorRGBA >> 0) & 0xff) / 255.0f,
                float((colorRGBA >> 8) & 0xff) / 255.0f,
                float((colorRGBA >> 16) & 0xff) / 255.0f,
                float((colorRGBA >> 24) & 0xff) / 255.0f},
  };
  vkCmdBeginDebugUtilsLabelEXT(wrapper_->cmdBuf_, &utilsLabel);
}

void lvk::CommandBuffer::cmdInsertDebugEventLabel(const char* label, uint32_t colorRGBA) const {
  LVK_ASSERT(label);

  if (!label || !vkCmdInsertDebugUtilsLabelEXT) {
    return;
  }
  const VkDebugUtilsLabelEXT utilsLabel = {
      .sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT,
      .pNext = nullptr,
      .pLabelName = label,
      .color = {float((colorRGBA >> 0) & 0xff) / 255.0f,
                float((colorRGBA >> 8) & 0xff) / 255.0f,
                float((colorRGBA >> 16) & 0xff) / 255.0f,
                float((colorRGBA >> 24) & 0xff) / 255.0f},
  };
  vkCmdInsertDebugUtilsLabelEXT(wrapper_->cmdBuf_, &utilsLabel);
}

void lvk::CommandBuffer::cmdPopDebugGroupLabel() const {
  if (!vkCmdEndDebugUtilsLabelEXT) {
    return;
  }
  vkCmdEndDebugUtilsLabelEXT(wrapper_->cmdBuf_);
}

void lvk::CommandBuffer::useComputeTexture(TextureHandle handle, VkPipelineStageFlags2 dstStage) {
  LVK_PROFILER_FUNCTION_COLOR(LVK_PROFILER_COLOR_BARRIER);

  LVK_ASSERT(!handle.empty());
  lvk::VulkanImage& tex = *ctx_->texturesPool_.get(handle);

  (void)dstStage; // TODO: add extra dstStage

  if (!tex.isStorageImage() && !tex.isSampledImage()) {
    LVK_ASSERT_MSG(false, "Did you forget to specify TextureUsageBits::Storage or TextureUsageBits::Sampled on your texture?");
    return;
  }

  tex.transitionLayout(wrapper_->cmdBuf_,
                       tex.isStorageImage() ? VK_IMAGE_LAYOUT_GENERAL : VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
                       VkImageSubresourceRange{tex.getImageAspectFlags(), 0, VK_REMAINING_MIP_LEVELS, 0, VK_REMAINING_ARRAY_LAYERS});
}

void lvk::CommandBuffer::bufferBarrier(BufferHandle handle, VkPipelineStageFlags2 srcStage, VkPipelineStageFlags2 dstStage) {
  LVK_PROFILER_FUNCTION_COLOR(LVK_PROFILER_COLOR_BARRIER);

  lvk::VulkanBuffer* buf = ctx_->buffersPool_.get(handle);

  VkBufferMemoryBarrier2 barrier = {
      .sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2,
      .srcStageMask = srcStage,
      .srcAccessMask = 0,
      .dstStageMask = dstStage,
      .dstAccessMask = 0,
      .srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
      .dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
      .buffer = buf->vkBuffer_,
      .offset = 0,
      .size = VK_WHOLE_SIZE,
  };

  if (srcStage & VK_PIPELINE_STAGE_2_TRANSFER_BIT) {
    barrier.srcAccessMask |= VK_ACCESS_2_TRANSFER_READ_BIT | VK_ACCESS_2_TRANSFER_WRITE_BIT;
  } else {
    barrier.srcAccessMask |= VK_ACCESS_2_SHADER_READ_BIT | VK_ACCESS_2_SHADER_WRITE_BIT;
  }

  if (dstStage & VK_PIPELINE_STAGE_2_TRANSFER_BIT) {
    barrier.dstAccessMask |= VK_ACCESS_2_TRANSFER_READ_BIT | VK_ACCESS_2_TRANSFER_WRITE_BIT;
  } else {
    barrier.dstAccessMask |= VK_ACCESS_2_SHADER_READ_BIT | VK_ACCESS_2_SHADER_WRITE_BIT;
  }
  if (dstStage & VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT) {
    barrier.dstAccessMask |= VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT;
  }
  if (buf->vkUsageFlags_ & VK_BUFFER_USAGE_INDEX_BUFFER_BIT) {
    barrier.dstAccessMask |= VK_ACCESS_2_INDEX_READ_BIT;
  }

  const VkDependencyInfo depInfo = {
      .sType = VK_STRUCTURE_TYPE_DEPENDENCY_INFO,
      .bufferMemoryBarrierCount = 1,
      .pBufferMemoryBarriers = &barrier,
  };

  vkCmdPipelineBarrier2(wrapper_->cmdBuf_, &depInfo);
}

void lvk::CommandBuffer::cmdBeginRendering(const lvk::RenderPass& renderPass, const lvk::Framebuffer& fb, const Dependencies& deps) {
  LVK_PROFILER_FUNCTION();

  LVK_ASSERT(!isRendering_);

  isRendering_ = true;
  viewMask_ = renderPass.viewMask;

  for (uint32_t i = 0; i != Dependencies::LVK_MAX_SUBMIT_DEPENDENCIES && deps.textures[i]; i++) {
    transitionToShaderReadOnly(deps.textures[i]);
  }
  for (uint32_t i = 0; i != Dependencies::LVK_MAX_SUBMIT_DEPENDENCIES && deps.buffers[i]; i++) {
    VkPipelineStageFlags2 dstStageFlags = VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT | VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT;
    const lvk::VulkanBuffer* buf = ctx_->buffersPool_.get(deps.buffers[i]);
    LVK_ASSERT(buf);
    if ((buf->vkUsageFlags_ & VK_BUFFER_USAGE_INDEX_BUFFER_BIT) || (buf->vkUsageFlags_ & VK_BUFFER_USAGE_VERTEX_BUFFER_BIT)) {
      dstStageFlags |= VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT;
    }
    if (buf->vkUsageFlags_ & VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT) {
      dstStageFlags |= VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT;
    }
    bufferBarrier(deps.buffers[i], VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT, dstStageFlags);
  }

  const uint32_t numFbColorAttachments = fb.getNumColorAttachments();
  const uint32_t numPassColorAttachments = renderPass.getNumColorAttachments();

  LVK_ASSERT(numPassColorAttachments == numFbColorAttachments);

  framebuffer_ = fb;

  // transition all the color attachments
  for (uint32_t i = 0; i != numFbColorAttachments; i++) {
    if (TextureHandle handle = fb.color[i].texture) {
      lvk::VulkanImage* colorTex = ctx_->texturesPool_.get(handle);
      transitionToColorAttachment(wrapper_->cmdBuf_, colorTex);
    }
    // handle MSAA
    if (TextureHandle handle = fb.color[i].resolveTexture) {
      lvk::VulkanImage* colorResolveTex = ctx_->texturesPool_.get(handle);
      colorResolveTex->isResolveAttachment = true;
      transitionToColorAttachment(wrapper_->cmdBuf_, colorResolveTex);
    }
  }
  // transition depth-stencil attachment
  TextureHandle depthTex = fb.depthStencil.texture;
  if (depthTex) {
    const lvk::VulkanImage& depthImg = *ctx_->texturesPool_.get(depthTex);
    LVK_ASSERT_MSG(depthImg.vkImageFormat_ != VK_FORMAT_UNDEFINED, "Invalid depth attachment format");
    LVK_ASSERT_MSG(depthImg.isDepthFormat_, "Invalid depth attachment format");
    const VkImageAspectFlags flags = depthImg.getImageAspectFlags();
    depthImg.transitionLayout(wrapper_->cmdBuf_,
                              VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
                              VkImageSubresourceRange{flags, 0, VK_REMAINING_MIP_LEVELS, 0, VK_REMAINING_ARRAY_LAYERS});
  }
  // handle depth MSAA
  if (TextureHandle handle = fb.depthStencil.resolveTexture) {
    lvk::VulkanImage& depthResolveImg = *ctx_->texturesPool_.get(handle);
    LVK_ASSERT_MSG(depthResolveImg.isDepthFormat_, "Invalid resolve depth attachment format");
    depthResolveImg.isResolveAttachment = true;
    const VkImageAspectFlags flags = depthResolveImg.getImageAspectFlags();
    depthResolveImg.transitionLayout(wrapper_->cmdBuf_,
                                     VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
                                     VkImageSubresourceRange{flags, 0, VK_REMAINING_MIP_LEVELS, 0, VK_REMAINING_ARRAY_LAYERS});
  }

  // calculate and transition input attachments
  {
    uint32_t i = 0;
    while (i != LVK_MAX_COLOR_ATTACHMENTS && deps.inputAttachments[i]) {
      const lvk::TextureHandle handle = deps.inputAttachments[i];
      const lvk::VulkanImage* tex = ctx_->texturesPool_.get(handle);
      LVK_ASSERT(tex);
      transitionToRenderingLocalRead(handle);
      inputAttachments_.imageInfos[i] = {
          .sampler = VK_NULL_HANDLE,
          .imageView = tex->imageView_,
          .imageLayout = VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ_KHR,
      };
      inputAttachments_.writes[i] = {
          .sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
          .dstSet = VK_NULL_HANDLE, // ignored for push descriptors
          .dstBinding = i,
          .dstArrayElement = 0,
          .descriptorCount = 1,
          .descriptorType = VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT,
          .pImageInfo = &inputAttachments_.imageInfos[i],
      };
      i++;
    }
    inputAttachments_.count = i;
  }

  VkSampleCountFlagBits samples = VK_SAMPLE_COUNT_1_BIT;
  uint32_t mipLevel = 0;
  uint32_t fbWidth = 0;
  uint32_t fbHeight = 0;

  VkRenderingAttachmentInfo colorAttachments[LVK_MAX_COLOR_ATTACHMENTS];

  for (uint32_t i = 0; i != numFbColorAttachments; i++) {
    const lvk::Framebuffer::AttachmentDesc& attachment = fb.color[i];
    LVK_ASSERT(!attachment.texture.empty());

    lvk::VulkanImage& colorTexture = *ctx_->texturesPool_.get(attachment.texture);
    const lvk::RenderPass::AttachmentDesc& descColor = renderPass.color[i];
    if (mipLevel && descColor.level) {
      LVK_ASSERT_MSG(descColor.level == mipLevel, "All color attachments should have the same mip-level");
    }
    const VkExtent3D dim = colorTexture.vkExtent_;
    if (fbWidth) {
      LVK_ASSERT_MSG(dim.width == fbWidth, "All attachments should have the same width");
    }
    if (fbHeight) {
      LVK_ASSERT_MSG(dim.height == fbHeight, "All attachments should have the same height");
    }
    mipLevel = descColor.level;
    fbWidth = dim.width;
    fbHeight = dim.height;
    samples = colorTexture.vkSamples_;
    colorAttachments[i] = {
        .sType = VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO,
        .pNext = nullptr,
        .imageView = colorTexture.getOrCreateVkImageViewForFramebuffer(*ctx_, descColor.level, descColor.layer, viewMask_),
        .imageLayout = colorTexture.vkImageLayout_, // VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,
        .resolveMode = (samples > 1) ? resolveModeToVkResolveModeFlagBits(descColor.resolveMode, VK_RESOLVE_MODE_FLAG_BITS_MAX_ENUM)
                                     : VK_RESOLVE_MODE_NONE,
        .resolveImageView = VK_NULL_HANDLE,
        .resolveImageLayout = VK_IMAGE_LAYOUT_UNDEFINED,
        .loadOp = loadOpToVkAttachmentLoadOp(descColor.loadOp),
        .storeOp = storeOpToVkAttachmentStoreOp(descColor.storeOp),
    };
    memcpy(&colorAttachments[i].clearValue.color, &descColor.clearColor, sizeof(descColor.clearColor));
    // handle MSAA
    if (descColor.storeOp == StoreOp_MsaaResolve) {
      LVK_ASSERT(samples > 1);
      LVK_ASSERT_MSG(!attachment.resolveTexture.empty(), "Framebuffer attachment should contain a resolve texture");
      lvk::VulkanImage& colorResolveTexture = *ctx_->texturesPool_.get(attachment.resolveTexture);
      colorAttachments[i].resolveImageView =
          colorResolveTexture.getOrCreateVkImageViewForFramebuffer(*ctx_, descColor.level, descColor.layer, viewMask_);
      colorAttachments[i].resolveImageLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
    }
  }

  VkRenderingAttachmentInfo depthAttachment = {};

  if (fb.depthStencil.texture) {
    lvk::VulkanImage& depthTexture = *ctx_->texturesPool_.get(fb.depthStencil.texture);
    const RenderPass::AttachmentDesc& descDepth = renderPass.depth;
    LVK_ASSERT_MSG(descDepth.level == mipLevel, "Depth attachment should have the same mip-level as color attachments");
    depthAttachment = {
        .sType = VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO,
        .pNext = nullptr,
        .imageView = depthTexture.getOrCreateVkImageViewForFramebuffer(*ctx_, descDepth.level, descDepth.layer, viewMask_),
        .imageLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
        .resolveMode = VK_RESOLVE_MODE_NONE,
        .resolveImageView = VK_NULL_HANDLE,
        .resolveImageLayout = VK_IMAGE_LAYOUT_UNDEFINED,
        .loadOp = loadOpToVkAttachmentLoadOp(descDepth.loadOp),
        .storeOp = storeOpToVkAttachmentStoreOp(descDepth.storeOp),
        .clearValue = {.depthStencil = {.depth = descDepth.clearDepth, .stencil = descDepth.clearStencil}},
    };
    // handle depth MSAA
    if (descDepth.storeOp == StoreOp_MsaaResolve) {
      LVK_ASSERT(depthTexture.vkSamples_ == samples);
      const lvk::Framebuffer::AttachmentDesc& attachment = fb.depthStencil;
      LVK_ASSERT_MSG(!attachment.resolveTexture.empty(), "Framebuffer depth attachment should contain a resolve texture");
      lvk::VulkanImage& depthResolveTexture = *ctx_->texturesPool_.get(attachment.resolveTexture);
      depthAttachment.resolveImageView =
          depthResolveTexture.getOrCreateVkImageViewForFramebuffer(*ctx_, descDepth.level, descDepth.layer, viewMask_);
      depthAttachment.resolveImageLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;
      depthAttachment.resolveMode =
          resolveModeToVkResolveModeFlagBits(descDepth.resolveMode, ctx_->vkPhysicalDeviceVulkan12Properties_.supportedDepthResolveModes);
    }
    const VkExtent3D dim = depthTexture.vkExtent_;
    if (fbWidth) {
      LVK_ASSERT_MSG(dim.width == fbWidth, "All attachments should have the same width");
    }
    if (fbHeight) {
      LVK_ASSERT_MSG(dim.height == fbHeight, "All attachments should have the same height");
    }
    mipLevel = descDepth.level;
    fbWidth = dim.width;
    fbHeight = dim.height;
  }

  const uint32_t width = std::max(fbWidth >> mipLevel, 1u);
  const uint32_t height = std::max(fbHeight >> mipLevel, 1u);
  const lvk::Viewport viewport = {0.0f, 0.0f, (float)width, (float)height, 0.0f, +1.0f};
  const lvk::ScissorRect scissor = {0, 0, width, height};

  VkRenderingAttachmentInfo stencilAttachment = depthAttachment;

  const bool isStencilFormat = renderPass.stencil.loadOp != lvk::LoadOp_Invalid;

  const VkRenderingInfo renderingInfo = {
      .sType = VK_STRUCTURE_TYPE_RENDERING_INFO,
      .pNext = nullptr,
      .flags = 0,
      .renderArea = {VkOffset2D{(int32_t)scissor.x, (int32_t)scissor.y}, VkExtent2D{scissor.width, scissor.height}},
      .layerCount = renderPass.layerCount,
      .viewMask = renderPass.viewMask,
      .colorAttachmentCount = numFbColorAttachments,
      .pColorAttachments = colorAttachments,
      .pDepthAttachment = depthTex ? &depthAttachment : nullptr,
      .pStencilAttachment = isStencilFormat ? &stencilAttachment : nullptr,
  };

  cmdBindViewport(viewport);
  cmdBindScissorRect(scissor);
  cmdBindDepthState({});

  ctx_->checkAndUpdateDescriptorSets();

  vkCmdSetDepthCompareOp(wrapper_->cmdBuf_, VK_COMPARE_OP_ALWAYS);
  vkCmdSetDepthBiasEnable(wrapper_->cmdBuf_, VK_FALSE);

  vkCmdBeginRendering(wrapper_->cmdBuf_, &renderingInfo);
}

void lvk::CommandBuffer::cmdEndRendering() {
  LVK_ASSERT(isRendering_);

  isRendering_ = false;

  vkCmdEndRendering(wrapper_->cmdBuf_);

  framebuffer_ = {};
}

void lvk::CommandBuffer::cmdNextSubpass() {
  LVK_ASSERT(isRendering_);

  const VkMemoryBarrier2 memoryBarrier = {
      .sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER_2,
      .srcStageMask = VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT,
      .srcAccessMask = VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT,
      .dstStageMask = VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT,
      .dstAccessMask = VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT,
  };

  const VkDependencyInfo dependencyInfo = {
      .sType = VK_STRUCTURE_TYPE_DEPENDENCY_INFO,
      .dependencyFlags = VK_DEPENDENCY_BY_REGION_BIT,
      .memoryBarrierCount = 1,
      .pMemoryBarriers = &memoryBarrier,
  };

  vkCmdPipelineBarrier2(wrapper_->cmdBuf_, &dependencyInfo);
}

void lvk::CommandBuffer::cmdBindViewport(const Viewport& viewport) {
  // https://www.saschawillems.de/blog/2019/03/29/flipping-the-vulkan-viewport/
  const VkViewport vp = {
      .x = viewport.x, // float x;
      .y = viewport.height - viewport.y, // float y;
      .width = viewport.width, // float width;
      .height = -viewport.height, // float height;
      .minDepth = viewport.minDepth, // float minDepth;
      .maxDepth = viewport.maxDepth, // float maxDepth;
  };
  vkCmdSetViewport(wrapper_->cmdBuf_, 0, 1, &vp);
}

void lvk::CommandBuffer::cmdBindScissorRect(const ScissorRect& rect) {
  const VkRect2D scissor = {
      VkOffset2D{(int32_t)rect.x, (int32_t)rect.y},
      VkExtent2D{rect.width, rect.height},
  };
  vkCmdSetScissor(wrapper_->cmdBuf_, 0, 1, &scissor);
}

void lvk::CommandBuffer::cmdBindRenderPipeline(lvk::RenderPipelineHandle handle) {
  if (!LVK_VERIFY(!handle.empty())) {
    return;
  }

  currentPipelineGraphics_ = handle;
  currentPipelineCompute_ = {};
  currentPipelineRayTracing_ = {};

  const lvk::RenderPipelineState* rps = ctx_->renderPipelinesPool_.get(handle);

  LVK_ASSERT(rps);

  const bool hasDepthAttachmentPipeline = rps->desc_.depthFormat != Format_Invalid;
  const bool hasDepthAttachmentPass = !framebuffer_.depthStencil.texture.empty();

  if (hasDepthAttachmentPipeline != hasDepthAttachmentPass) {
    LVK_ASSERT(false);
    LLOGW("Make sure your render pass and render pipeline both have matching depth attachments");
  }

  VkPipeline pipeline = ctx_->getVkPipeline(handle, viewMask_);

  LVK_ASSERT(pipeline != VK_NULL_HANDLE);

  if (lastPipelineBound_ != pipeline) {
    lastPipelineBound_ = pipeline;
    vkCmdBindPipeline(wrapper_->cmdBuf_, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline);
    ctx_->bindDefaultDescriptorSets(wrapper_->cmdBuf_, VK_PIPELINE_BIND_POINT_GRAPHICS, rps->pipelineLayout_);
    if (inputAttachments_.count) {
      vkCmdPushDescriptorSetKHR(wrapper_->cmdBuf_,
                                VK_PIPELINE_BIND_POINT_GRAPHICS,
                                rps->pipelineLayout_,
                                kDescriptorSet_InputAttachments,
                                inputAttachments_.count,
                                inputAttachments_.writes);
    }
  }
}

void lvk::CommandBuffer::cmdBindDepthState(const DepthState& desc) {
  LVK_PROFILER_FUNCTION();

  const VkCompareOp op = compareOpToVkCompareOp(desc.compareOp);
  vkCmdSetDepthWriteEnable(wrapper_->cmdBuf_, desc.isDepthWriteEnabled ? VK_TRUE : VK_FALSE);
  vkCmdSetDepthTestEnable(wrapper_->cmdBuf_, (op != VK_COMPARE_OP_ALWAYS || desc.isDepthWriteEnabled) ? VK_TRUE : VK_FALSE);

#if defined(ANDROID)
  // This is a workaround for the issue.
  // On Android (Mali-G715-Immortalis MC11 v1.r38p1-01eac0.c1a71ccca2acf211eb87c5db5322f569)
  // if depth-stencil texture is not set, call of vkCmdSetDepthCompareOp leads to disappearing of all content.
  if (!framebuffer_.depthStencil.texture) {
    return;
  }
#endif
  vkCmdSetDepthCompareOp(wrapper_->cmdBuf_, op);
}

void lvk::CommandBuffer::cmdBindVertexBuffer(uint32_t index, BufferHandle buffer, uint64_t bufferOffset) {
  LVK_PROFILER_FUNCTION();

  if (!LVK_VERIFY(!buffer.empty())) {
    return;
  }

  lvk::VulkanBuffer* buf = ctx_->buffersPool_.get(buffer);

  LVK_ASSERT(buf->vkUsageFlags_ & VK_BUFFER_USAGE_VERTEX_BUFFER_BIT);

  vkCmdBindVertexBuffers2(wrapper_->cmdBuf_, index, 1, &buf->vkBuffer_, &bufferOffset, nullptr, nullptr);
}

void lvk::CommandBuffer::cmdBindIndexBuffer(BufferHandle indexBuffer, IndexFormat indexFormat, uint64_t indexBufferOffset) {
  lvk::VulkanBuffer* buf = ctx_->buffersPool_.get(indexBuffer);

  LVK_ASSERT(buf->vkUsageFlags_ & VK_BUFFER_USAGE_INDEX_BUFFER_BIT);

  const VkIndexType type = indexFormatToVkIndexType(indexFormat);
  vkCmdBindIndexBuffer(wrapper_->cmdBuf_, buf->vkBuffer_, indexBufferOffset, type);
}

void lvk::CommandBuffer::cmdPushConstants(const void* data, size_t size, size_t offset) {
  LVK_PROFILER_FUNCTION();

  LVK_ASSERT(size % 4 == 0); // VUID-vkCmdPushConstants-size-00369: size must be a multiple of 4

  // check push constant size is within max size
  const VkPhysicalDeviceLimits& limits = ctx_->getVkPhysicalDeviceProperties().limits;
  if (!LVK_VERIFY(size + offset <= limits.maxPushConstantsSize)) {
    LLOGW("Push constants size exceeded %u (max %u bytes)", size + offset, limits.maxPushConstantsSize);
  }

  if (currentPipelineGraphics_.empty() && currentPipelineCompute_.empty() && currentPipelineRayTracing_.empty()) {
    LVK_ASSERT_MSG(false, "No pipeline bound - cannot set push constants");
    return;
  }

  const lvk::RenderPipelineState* stateGraphics = ctx_->renderPipelinesPool_.get(currentPipelineGraphics_);
  const lvk::ComputePipelineState* stateCompute = ctx_->computePipelinesPool_.get(currentPipelineCompute_);
  const lvk::RayTracingPipelineState* stateRayTracing = ctx_->rayTracingPipelinesPool_.get(currentPipelineRayTracing_);

  LVK_ASSERT(stateGraphics || stateCompute || stateRayTracing);

  VkPipelineLayout layout = stateGraphics ? stateGraphics->pipelineLayout_
                                          : (stateCompute ? stateCompute->pipelineLayout_ : stateRayTracing->pipelineLayout_);
  VkShaderStageFlags shaderStageFlags = stateGraphics ? stateGraphics->shaderStageFlags_
                                                      : (stateCompute ? VK_SHADER_STAGE_COMPUTE_BIT : stateRayTracing->shaderStageFlags_);

  vkCmdPushConstants(wrapper_->cmdBuf_, layout, shaderStageFlags, (uint32_t)offset, (uint32_t)size, data);
}

void lvk::CommandBuffer::cmdFillBuffer(BufferHandle buffer, size_t bufferOffset, size_t size, uint32_t data) {
  LVK_PROFILER_FUNCTION();
  LVK_ASSERT(buffer.valid());
  LVK_ASSERT(size);
  LVK_ASSERT(size % 4 == 0);
  LVK_ASSERT(bufferOffset % 4 == 0);

  lvk::VulkanBuffer* buf = ctx_->buffersPool_.get(buffer);

  bufferBarrier(buffer, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, VK_PIPELINE_STAGE_2_TRANSFER_BIT);

  vkCmdFillBuffer(wrapper_->cmdBuf_, buf->vkBuffer_, bufferOffset, size, data);

  VkPipelineStageFlags2 dstStage = VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT;

  if (buf->vkUsageFlags_ & VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT) {
    dstStage |= VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT;
  }
  if (buf->vkUsageFlags_ & VK_BUFFER_USAGE_VERTEX_BUFFER_BIT) {
    dstStage |= VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT;
  }

  bufferBarrier(buffer, VK_PIPELINE_STAGE_2_TRANSFER_BIT, dstStage);
}

void lvk::CommandBuffer::cmdCopyBuffer(BufferHandle srcBuffer, BufferHandle dstBuffer, size_t srcOffset, size_t dstOffset, size_t size) {
  LVK_PROFILER_FUNCTION();
  LVK_ASSERT(srcBuffer.valid());
  LVK_ASSERT(dstBuffer.valid());
  LVK_ASSERT(size);
  // Check buffer regions do not overlap
  if (srcBuffer == dstBuffer) {
    if (srcOffset < dstOffset) {
      LVK_ASSERT(dstOffset - srcOffset >= size);
    } else {
      LVK_ASSERT(srcOffset - dstOffset >= size);
    }
  }

  lvk::VulkanBuffer* srcBuf = ctx_->buffersPool_.get(srcBuffer);
  lvk::VulkanBuffer* dstBuf = ctx_->buffersPool_.get(dstBuffer);

  bufferBarrier(srcBuffer, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, VK_PIPELINE_STAGE_2_TRANSFER_BIT);
  bufferBarrier(dstBuffer, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, VK_PIPELINE_STAGE_2_TRANSFER_BIT);

  const VkBufferCopy2 copyRegion = {
      .sType = VK_STRUCTURE_TYPE_BUFFER_COPY_2,
      .srcOffset = srcOffset,
      .dstOffset = dstOffset,
      .size = size,
  };

  const VkCopyBufferInfo2 copyInfo = {
      .sType = VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2,
      .srcBuffer = srcBuf->vkBuffer_,
      .dstBuffer = dstBuf->vkBuffer_,
      .regionCount = 1,
      .pRegions = &copyRegion,
  };

  vkCmdCopyBuffer2(wrapper_->cmdBuf_, &copyInfo);

  VkPipelineStageFlags2 srcStage = VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT;

  if (srcBuf->vkUsageFlags_ & VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT) {
    srcStage |= VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT;
  }
  if (srcBuf->vkUsageFlags_ & VK_BUFFER_USAGE_VERTEX_BUFFER_BIT) {
    srcStage |= VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT;
  }

  VkPipelineStageFlags2 dstStage = VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT;

  if (dstBuf->vkUsageFlags_ & VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT) {
    dstStage |= VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT;
  }
  if (dstBuf->vkUsageFlags_ & VK_BUFFER_USAGE_VERTEX_BUFFER_BIT) {
    dstStage |= VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT;
  }

  bufferBarrier(srcBuffer, VK_PIPELINE_STAGE_2_TRANSFER_BIT, srcStage);
  bufferBarrier(dstBuffer, VK_PIPELINE_STAGE_2_TRANSFER_BIT, dstStage);
}

void lvk::CommandBuffer::cmdUpdateBuffer(BufferHandle buffer, size_t bufferOffset, size_t size, const void* data) {
  LVK_PROFILER_FUNCTION();
  LVK_ASSERT(buffer.valid());
  LVK_ASSERT(data);
  LVK_ASSERT(size && size <= 65536);
  LVK_ASSERT(size % 4 == 0);
  LVK_ASSERT(bufferOffset % 4 == 0);

  lvk::VulkanBuffer* buf = ctx_->buffersPool_.get(buffer);

  bufferBarrier(buffer, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, VK_PIPELINE_STAGE_2_TRANSFER_BIT);

  vkCmdUpdateBuffer(wrapper_->cmdBuf_, buf->vkBuffer_, bufferOffset, size, data);

  VkPipelineStageFlags2 dstStage = VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT;

  if (buf->vkUsageFlags_ & VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT) {
    dstStage |= VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT;
  }
  if (buf->vkUsageFlags_ & VK_BUFFER_USAGE_VERTEX_BUFFER_BIT) {
    dstStage |= VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT;
  }

  bufferBarrier(buffer, VK_PIPELINE_STAGE_2_TRANSFER_BIT, dstStage);
}

void lvk::CommandBuffer::cmdDraw(uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t baseInstance) {
  LVK_PROFILER_FUNCTION();
  LVK_PROFILER_GPU_ZONE("cmdDraw()", ctx_, wrapper_->cmdBuf_, LVK_PROFILER_COLOR_CMD_DRAW);

  if (vertexCount == 0) {
    return;
  }

  vkCmdDraw(wrapper_->cmdBuf_, vertexCount, instanceCount, firstVertex, baseInstance);
}

void lvk::CommandBuffer::cmdDrawIndexed(uint32_t indexCount,
                                        uint32_t instanceCount,
                                        uint32_t firstIndex,
                                        int32_t vertexOffset,
                                        uint32_t baseInstance) {
  LVK_PROFILER_FUNCTION();
  LVK_PROFILER_GPU_ZONE("cmdDrawIndexed()", ctx_, wrapper_->cmdBuf_, LVK_PROFILER_COLOR_CMD_DRAW);

  if (indexCount == 0) {
    return;
  }

  LVK_ASSERT(ctx_->awaitingCreation_ == false);

  vkCmdDrawIndexed(wrapper_->cmdBuf_, indexCount, instanceCount, firstIndex, vertexOffset, baseInstance);
}

void lvk::CommandBuffer::cmdDrawIndirect(BufferHandle indirectBuffer, size_t indirectBufferOffset, uint32_t drawCount, uint32_t stride) {
  LVK_PROFILER_FUNCTION();
  LVK_PROFILER_GPU_ZONE("cmdDrawIndirect()", ctx_, wrapper_->cmdBuf_, LVK_PROFILER_COLOR_CMD_DRAW);

  lvk::VulkanBuffer* bufIndirect = ctx_->buffersPool_.get(indirectBuffer);

  LVK_ASSERT(bufIndirect);

  vkCmdDrawIndirect(
      wrapper_->cmdBuf_, bufIndirect->vkBuffer_, indirectBufferOffset, drawCount, stride ? stride : sizeof(VkDrawIndirectCommand));
}

void lvk::CommandBuffer::cmdDrawIndexedIndirect(BufferHandle indirectBuffer,
                                                size_t indirectBufferOffset,
                                                uint32_t drawCount,
                                                uint32_t stride) {
  LVK_PROFILER_FUNCTION();
  LVK_PROFILER_GPU_ZONE("cmdDrawIndexedIndirect()", ctx_, wrapper_->cmdBuf_, LVK_PROFILER_COLOR_CMD_DRAW);

  lvk::VulkanBuffer* bufIndirect = ctx_->buffersPool_.get(indirectBuffer);

  LVK_ASSERT(bufIndirect);

  vkCmdDrawIndexedIndirect(
      wrapper_->cmdBuf_, bufIndirect->vkBuffer_, indirectBufferOffset, drawCount, stride ? stride : sizeof(VkDrawIndexedIndirectCommand));
}

void lvk::CommandBuffer::cmdDrawIndexedIndirectCount(BufferHandle indirectBuffer,
                                                     size_t indirectBufferOffset,
                                                     BufferHandle countBuffer,
                                                     size_t countBufferOffset,
                                                     uint32_t maxDrawCount,
                                                     uint32_t stride) {
  LVK_PROFILER_FUNCTION();
  LVK_PROFILER_GPU_ZONE("cmdDrawIndexedIndirectCount()", ctx_, wrapper_->cmdBuf_, LVK_PROFILER_COLOR_CMD_DRAW);

  lvk::VulkanBuffer* bufIndirect = ctx_->buffersPool_.get(indirectBuffer);
  lvk::VulkanBuffer* bufCount = ctx_->buffersPool_.get(countBuffer);

  LVK_ASSERT(bufIndirect);
  LVK_ASSERT(bufCount);

  vkCmdDrawIndexedIndirectCount(wrapper_->cmdBuf_,
                                bufIndirect->vkBuffer_,
                                indirectBufferOffset,
                                bufCount->vkBuffer_,
                                countBufferOffset,
                                maxDrawCount,
                                stride ? stride : sizeof(VkDrawIndexedIndirectCommand));
}

void lvk::CommandBuffer::cmdDrawMeshTasks(const Dimensions& threadgroupCount) {
  LVK_PROFILER_FUNCTION();
  LVK_PROFILER_GPU_ZONE("cmdDrawMeshTasks()", ctx_, wrapper_->cmdBuf_, LVK_PROFILER_COLOR_CMD_DRAW);

  LVK_ASSERT_MSG(ctx_->has_EXT_mesh_shader_, "Mesh shaders not supported\n");

  vkCmdDrawMeshTasksEXT(wrapper_->cmdBuf_, threadgroupCount.width, threadgroupCount.height, threadgroupCount.depth);
}

void lvk::CommandBuffer::cmdDrawMeshTasksIndirect(BufferHandle indirectBuffer,
                                                  size_t indirectBufferOffset,
                                                  uint32_t drawCount,
                                                  uint32_t stride) {
  LVK_PROFILER_FUNCTION();
  LVK_PROFILER_GPU_ZONE("cmdDrawMeshTasksIndirect()", ctx_, wrapper_->cmdBuf_, LVK_PROFILER_COLOR_CMD_DRAW);

  LVK_ASSERT_MSG(ctx_->has_EXT_mesh_shader_, "Mesh shaders not supported\n");

  lvk::VulkanBuffer* bufIndirect = ctx_->buffersPool_.get(indirectBuffer);

  LVK_ASSERT(bufIndirect);

  vkCmdDrawMeshTasksIndirectEXT(wrapper_->cmdBuf_,
                                bufIndirect->vkBuffer_,
                                indirectBufferOffset,
                                drawCount,
                                stride ? stride : sizeof(VkDrawMeshTasksIndirectCommandEXT));
}

void lvk::CommandBuffer::cmdDrawMeshTasksIndirectCount(BufferHandle indirectBuffer,
                                                       size_t indirectBufferOffset,
                                                       BufferHandle countBuffer,
                                                       size_t countBufferOffset,
                                                       uint32_t maxDrawCount,
                                                       uint32_t stride) {
  LVK_PROFILER_FUNCTION();
  LVK_PROFILER_GPU_ZONE("cmdDrawMeshTasksIndirectCount()", ctx_, wrapper_->cmdBuf_, LVK_PROFILER_COLOR_CMD_DRAW);

  LVK_ASSERT_MSG(ctx_->has_EXT_mesh_shader_, "Mesh shaders not supported\n");

  lvk::VulkanBuffer* bufIndirect = ctx_->buffersPool_.get(indirectBuffer);
  lvk::VulkanBuffer* bufCount = ctx_->buffersPool_.get(countBuffer);

  LVK_ASSERT(bufIndirect);
  LVK_ASSERT(bufCount);

  vkCmdDrawMeshTasksIndirectCountEXT(wrapper_->cmdBuf_,
                                     bufIndirect->vkBuffer_,
                                     indirectBufferOffset,
                                     bufCount->vkBuffer_,
                                     countBufferOffset,
                                     maxDrawCount,
                                     stride ? stride : sizeof(VkDrawMeshTasksIndirectCommandEXT));
}

void lvk::CommandBuffer::cmdTraceRays(uint32_t width, uint32_t height, uint32_t depth, const Dependencies& deps) {
  LVK_PROFILER_FUNCTION();
  LVK_PROFILER_GPU_ZONE("cmdTraceRays()", ctx_, wrapper_->cmdBuf_, LVK_PROFILER_COLOR_CMD_RTX);

  lvk::RayTracingPipelineState* rtps = ctx_->rayTracingPipelinesPool_.get(currentPipelineRayTracing_);

  if (!LVK_VERIFY(rtps)) {
    return;
  }

  LVK_ASSERT(!isRendering_);

  for (uint32_t i = 0; i != Dependencies::LVK_MAX_SUBMIT_DEPENDENCIES && deps.textures[i]; i++) {
    useComputeTexture(deps.textures[i], VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR);
  }
  for (uint32_t i = 0; i != Dependencies::LVK_MAX_SUBMIT_DEPENDENCIES && deps.buffers[i]; i++) {
    bufferBarrier(deps.buffers[i],
                  VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT | VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT,
                  VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR);
  }

  vkCmdTraceRaysKHR(
      wrapper_->cmdBuf_, &rtps->sbtEntryRayGen, &rtps->sbtEntryMiss, &rtps->sbtEntryHit, &rtps->sbtEntryCallable, width, height, depth);
}

void lvk::CommandBuffer::cmdSetBlendColor(const float color[4]) {
  vkCmdSetBlendConstants(wrapper_->cmdBuf_, color);
}

void lvk::CommandBuffer::cmdSetDepthBias(float constantFactor, float slopeFactor, float clamp) {
  vkCmdSetDepthBias(wrapper_->cmdBuf_, constantFactor, clamp, slopeFactor);
}

void lvk::CommandBuffer::cmdSetDepthBiasEnable(bool enable) {
  vkCmdSetDepthBiasEnable(wrapper_->cmdBuf_, enable ? VK_TRUE : VK_FALSE);
}

void lvk::CommandBuffer::cmdResetQueryPool(QueryPoolHandle pool, uint32_t firstQuery, uint32_t queryCount) {
  VkQueryPool vkPool = *ctx_->queriesPool_.get(pool);

  vkCmdResetQueryPool(wrapper_->cmdBuf_, vkPool, firstQuery, queryCount);
}

void lvk::CommandBuffer::cmdWriteTimestamp(QueryPoolHandle pool, uint32_t query) {
  VkQueryPool vkPool = *ctx_->queriesPool_.get(pool);

  vkCmdWriteTimestamp(wrapper_->cmdBuf_, VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT, vkPool, query);
}

void lvk::CommandBuffer::cmdClearColorImage(TextureHandle tex, const ClearColorValue& value, const TextureLayers& layers) {
  LVK_PROFILER_GPU_ZONE("cmdClearColorImage()", ctx_, wrapper_->cmdBuf_, LVK_PROFILER_COLOR_CMD_COPY);

  static_assert(sizeof(ClearColorValue) == sizeof(VkClearColorValue));

  lvk::VulkanImage* img = ctx_->texturesPool_.get(tex);

  if (!LVK_VERIFY(img)) {
    return;
  }

  const VkImageSubresourceRange range = {
      .aspectMask = img->getImageAspectFlags(),
      .baseMipLevel = layers.mipLevel,
      .levelCount = VK_REMAINING_MIP_LEVELS,
      .baseArrayLayer = layers.layer,
      .layerCount = layers.numLayers,
  };

  lvk::imageMemoryBarrier2(
      wrapper_->cmdBuf_,
      img->vkImage_,
      StageAccess{.stage = VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, .access = VK_ACCESS_2_MEMORY_READ_BIT | VK_ACCESS_2_MEMORY_WRITE_BIT},
      StageAccess{.stage = VK_PIPELINE_STAGE_2_TRANSFER_BIT, .access = VK_ACCESS_2_TRANSFER_WRITE_BIT},
      img->vkImageLayout_,
      VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
      range);

  vkCmdClearColorImage(wrapper_->cmdBuf_,
                       img->vkImage_,
                       VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
                       reinterpret_cast<const VkClearColorValue*>(&value),
                       1,
                       &range);

  // a ternary cascade...
  const VkImageLayout newLayout = img->vkImageLayout_ == VK_IMAGE_LAYOUT_UNDEFINED
                                      ? (img->isAttachment()     ? VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL
                                         : img->isSampledImage() ? VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL
                                                                 : VK_IMAGE_LAYOUT_GENERAL)
                                      : img->vkImageLayout_;

  lvk::imageMemoryBarrier2(
      wrapper_->cmdBuf_,
      img->vkImage_,
      StageAccess{.stage = VK_PIPELINE_STAGE_2_TRANSFER_BIT, .access = VK_ACCESS_2_TRANSFER_WRITE_BIT},
      StageAccess{.stage = VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, .access = VK_ACCESS_2_MEMORY_READ_BIT | VK_ACCESS_2_MEMORY_WRITE_BIT},
      VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
      newLayout,
      range);

  img->vkImageLayout_ = newLayout;
}

void lvk::CommandBuffer::cmdCopyImage(TextureHandle src,
                                      TextureHandle dst,
                                      const Dimensions& extent,
                                      const Offset3D& srcOffset,
                                      const Offset3D& dstOffset,
                                      const TextureLayers& srcLayers,
                                      const TextureLayers& dstLayers) {
  LVK_PROFILER_GPU_ZONE("cmdCopyImage()", ctx_, wrapper_->cmdBuf_, LVK_PROFILER_COLOR_CMD_COPY);

  lvk::VulkanImage* imgSrc = ctx_->texturesPool_.get(src);
  lvk::VulkanImage* imgDst = ctx_->texturesPool_.get(dst);

  LVK_ASSERT(imgSrc && imgDst);
  LVK_ASSERT(srcLayers.numLayers == dstLayers.numLayers);

  if (!imgSrc || !imgDst) {
    return;
  }

  const VkImageSubresourceRange rangeSrc = {
      .aspectMask = imgSrc->getImageAspectFlags(),
      .baseMipLevel = srcLayers.mipLevel,
      .levelCount = 1,
      .baseArrayLayer = srcLayers.layer,
      .layerCount = srcLayers.numLayers,
  };
  const VkImageSubresourceRange rangeDst = {
      .aspectMask = imgDst->getImageAspectFlags(),
      .baseMipLevel = dstLayers.mipLevel,
      .levelCount = 1,
      .baseArrayLayer = dstLayers.layer,
      .layerCount = dstLayers.numLayers,
  };

  LVK_ASSERT(imgSrc->vkImageLayout_ != VK_IMAGE_LAYOUT_UNDEFINED);

  const VkExtent3D dstExtent = imgDst->vkExtent_;
  const bool coversFullDstImage = dstExtent.width == extent.width && dstExtent.height == extent.height && dstExtent.depth == extent.depth &&
                                  dstOffset.x == 0 && dstOffset.y == 0 && dstOffset.z == 0;

  LVK_ASSERT(coversFullDstImage || imgDst->vkImageLayout_ != VK_IMAGE_LAYOUT_UNDEFINED);

  lvk::imageMemoryBarrier2(
      wrapper_->cmdBuf_,
      imgSrc->vkImage_,
      StageAccess{.stage = VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, .access = VK_ACCESS_2_MEMORY_READ_BIT | VK_ACCESS_2_MEMORY_WRITE_BIT},
      StageAccess{.stage = VK_PIPELINE_STAGE_2_TRANSFER_BIT, .access = VK_ACCESS_2_TRANSFER_READ_BIT},
      imgSrc->vkImageLayout_,
      VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
      rangeSrc);
  lvk::imageMemoryBarrier2(
      wrapper_->cmdBuf_,
      imgDst->vkImage_,
      StageAccess{.stage = VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, .access = VK_ACCESS_2_MEMORY_READ_BIT | VK_ACCESS_2_MEMORY_WRITE_BIT},
      StageAccess{.stage = VK_PIPELINE_STAGE_2_TRANSFER_BIT, .access = VK_ACCESS_2_TRANSFER_WRITE_BIT},
      coversFullDstImage ? VK_IMAGE_LAYOUT_UNDEFINED : imgDst->vkImageLayout_,
      VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
      rangeDst);

  const VkImageCopy regionCopy = {
      .srcSubresource =
          {
              .aspectMask = imgSrc->getImageAspectFlags(),
              .mipLevel = srcLayers.mipLevel,
              .baseArrayLayer = srcLayers.layer,
              .layerCount = srcLayers.numLayers,
          },
      .srcOffset = {.x = srcOffset.x, .y = srcOffset.y, .z = srcOffset.z},
      .dstSubresource =
          {
              .aspectMask = imgDst->getImageAspectFlags(),
              .mipLevel = dstLayers.mipLevel,
              .baseArrayLayer = dstLayers.layer,
              .layerCount = dstLayers.numLayers,
          },
      .dstOffset = {.x = dstOffset.x, .y = dstOffset.y, .z = dstOffset.z},
      .extent = {.width = extent.width, .height = extent.height, .depth = extent.depth},
  };
  const VkImageBlit regionBlit = {
      .srcSubresource = regionCopy.srcSubresource,
      .srcOffsets = {{},
                     {.x = int32_t(srcOffset.x + imgSrc->vkExtent_.width),
                      .y = int32_t(srcOffset.y + imgSrc->vkExtent_.height),
                      .z = int32_t(srcOffset.z + imgSrc->vkExtent_.depth)}},
      .dstSubresource = regionCopy.dstSubresource,
      .dstOffsets = {{},
                     {.x = int32_t(dstOffset.x + imgDst->vkExtent_.width),
                      .y = int32_t(dstOffset.y + imgDst->vkExtent_.height),
                      .z = int32_t(dstOffset.z + imgDst->vkExtent_.depth)}},
  };

  const bool isCompatible = getBytesPerPixel(imgSrc->vkImageFormat_) == getBytesPerPixel(imgDst->vkImageFormat_);

  isCompatible ? vkCmdCopyImage(wrapper_->cmdBuf_,
                                imgSrc->vkImage_,
                                VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
                                imgDst->vkImage_,
                                VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
                                1,
                                &regionCopy)
               : vkCmdBlitImage(wrapper_->cmdBuf_,
                                imgSrc->vkImage_,
                                VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
                                imgDst->vkImage_,
                                VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
                                1,
                                &regionBlit,
                                VK_FILTER_LINEAR);

  lvk::imageMemoryBarrier2(
      wrapper_->cmdBuf_,
      imgSrc->vkImage_,
      StageAccess{.stage = VK_PIPELINE_STAGE_2_TRANSFER_BIT, .access = VK_ACCESS_2_TRANSFER_READ_BIT},
      StageAccess{.stage = VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, .access = VK_ACCESS_2_MEMORY_READ_BIT | VK_ACCESS_2_MEMORY_WRITE_BIT},
      VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
      imgSrc->vkImageLayout_,
      rangeSrc);

  // a ternary cascade...
  const VkImageLayout newLayout = imgDst->vkImageLayout_ == VK_IMAGE_LAYOUT_UNDEFINED
                                      ? (imgDst->isAttachment()     ? VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL
                                         : imgDst->isSampledImage() ? VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL
                                                                    : VK_IMAGE_LAYOUT_GENERAL)
                                      : imgDst->vkImageLayout_;

  lvk::imageMemoryBarrier2(
      wrapper_->cmdBuf_,
      imgDst->vkImage_,
      StageAccess{.stage = VK_PIPELINE_STAGE_2_TRANSFER_BIT, .access = VK_ACCESS_2_TRANSFER_WRITE_BIT},
      StageAccess{.stage = VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, .access = VK_ACCESS_2_MEMORY_READ_BIT | VK_ACCESS_2_MEMORY_WRITE_BIT},
      VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
      newLayout,
      rangeDst);

  imgDst->vkImageLayout_ = newLayout;
}

void lvk::CommandBuffer::cmdGenerateMipmap(TextureHandle handle) {
  if (handle.empty()) {
    return;
  }

  const lvk::VulkanImage* tex = ctx_->texturesPool_.get(handle);

  if (tex->numLevels_ <= 1) {
    return;
  }

  LVK_ASSERT(tex->vkImageLayout_ != VK_IMAGE_LAYOUT_UNDEFINED);

  tex->generateMipmap(wrapper_->cmdBuf_);
}

void lvk::CommandBuffer::cmdUpdateTLAS(AccelStructHandle handle, BufferHandle instancesBuffer) {
  LVK_PROFILER_GPU_ZONE("cmdUpdateTLAS()", ctx_, wrapper_->cmdBuf_, LVK_PROFILER_COLOR_CMD_RTX);

  if (handle.empty()) {
    return;
  }

  lvk::AccelerationStructure* as = ctx_->accelStructuresPool_.get(handle);

  const VkAccelerationStructureGeometryKHR accelerationStructureGeometry{
      .sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR,
      .geometryType = VK_GEOMETRY_TYPE_INSTANCES_KHR,
      .geometry =
          {
              .instances =
                  {
                      .sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR,
                      .arrayOfPointers = VK_FALSE,
                      .data = {.deviceAddress = ctx_->gpuAddress(instancesBuffer)},
                  },
          },
      .flags = VK_GEOMETRY_OPAQUE_BIT_KHR,
  };

  VkAccelerationStructureBuildGeometryInfoKHR accelerationStructureBuildGeometryInfo{
      .sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR,
      .type = VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR,
      .flags = VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR | VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR,
      .geometryCount = 1,
      .pGeometries = &accelerationStructureGeometry,
  };
  VkAccelerationStructureBuildSizesInfoKHR accelerationStructureBuildSizesInfo{
      .sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR,
  };
  vkGetAccelerationStructureBuildSizesKHR(ctx_->getVkDevice(),
                                          VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR,
                                          &accelerationStructureBuildGeometryInfo,
                                          &as->buildRangeInfo.primitiveCount,
                                          &accelerationStructureBuildSizesInfo);

  const uint32_t alignment = ctx_->accelerationStructureProperties_.minAccelerationStructureScratchOffsetAlignment;
  accelerationStructureBuildSizesInfo.accelerationStructureSize += alignment;
  accelerationStructureBuildSizesInfo.updateScratchSize += alignment;
  accelerationStructureBuildSizesInfo.buildScratchSize += alignment;

  if (!as->scratchBuffer.valid() || getBufferSize(ctx_, as->scratchBuffer) < accelerationStructureBuildSizesInfo.updateScratchSize) {
    LLOGD("Recreating scratch buffer for TLAS update");
    as->scratchBuffer = ctx_->createBuffer(
        lvk::BufferDesc{
            .usage = lvk::BufferUsageBits_Storage,
            .storage = lvk::StorageType_Device,
            .size = accelerationStructureBuildSizesInfo.updateScratchSize,
            .debugName = "scratchBuffer",
        },
        nullptr,
        nullptr);
  }

  const VkAccelerationStructureBuildGeometryInfoKHR accelerationBuildGeometryInfo = {
      .sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR,
      .type = VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR,
      .flags = VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR | VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR,
      .mode = VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR,
      .srcAccelerationStructure = as->vkHandle,
      .dstAccelerationStructure = as->vkHandle,
      .geometryCount = 1,
      .pGeometries = &accelerationStructureGeometry,
      .scratchData = {.deviceAddress =
                          getAlignedAddress(ctx_->gpuAddress(as->scratchBuffer),
                                            ctx_->accelerationStructureProperties_.minAccelerationStructureScratchOffsetAlignment)},
  };

  const VkAccelerationStructureBuildRangeInfoKHR* accelerationBuildStructureRangeInfos[] = {&as->buildRangeInfo};

  {
    const VkBufferMemoryBarrier2 barriers[] = {
        {
            .sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2,
            .srcStageMask = VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR,
            .srcAccessMask = VK_ACCESS_MEMORY_READ_BIT,
            .dstStageMask = VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR,
            .dstAccessMask = VK_ACCESS_MEMORY_READ_BIT | VK_ACCESS_MEMORY_WRITE_BIT,
            .buffer = getVkBuffer(ctx_, handle),
            .size = VK_WHOLE_SIZE,
        },
        {
            .sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2,
            .srcStageMask = VK_PIPELINE_STAGE_TRANSFER_BIT | VK_PIPELINE_STAGE_HOST_BIT,
            .srcAccessMask = VK_ACCESS_MEMORY_WRITE_BIT,
            .dstStageMask = VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR,
            .dstAccessMask = VK_ACCESS_MEMORY_READ_BIT,
            .buffer = getVkBuffer(ctx_, instancesBuffer),
            .size = VK_WHOLE_SIZE,
        },
    };
    const VkDependencyInfo dependencyInfo{
        .sType = VK_STRUCTURE_TYPE_DEPENDENCY_INFO,
        .bufferMemoryBarrierCount = LVK_ARRAY_NUM_ELEMENTS(barriers),
        .pBufferMemoryBarriers = barriers,
    };
    vkCmdPipelineBarrier2(wrapper_->cmdBuf_, &dependencyInfo);
  }
  vkCmdBuildAccelerationStructuresKHR(wrapper_->cmdBuf_, 1, &accelerationBuildGeometryInfo, accelerationBuildStructureRangeInfos);
  {
    const VkBufferMemoryBarrier2 barrier = {
        .sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2,
        .srcStageMask = VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR,
        .srcAccessMask = VK_ACCESS_MEMORY_READ_BIT | VK_ACCESS_MEMORY_WRITE_BIT,
        .dstStageMask = VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR,
        .dstAccessMask = VK_ACCESS_MEMORY_READ_BIT,
        .buffer = getVkBuffer(ctx_, handle),
        .offset = 0,
        .size = VK_WHOLE_SIZE,
    };
    const VkDependencyInfo dependencyInfo{
        .sType = VK_STRUCTURE_TYPE_DEPENDENCY_INFO, .bufferMemoryBarrierCount = 1, .pBufferMemoryBarriers = &barrier};
    vkCmdPipelineBarrier2(wrapper_->cmdBuf_, &dependencyInfo);
  }
}

lvk::VulkanStagingDevice::VulkanStagingDevice(VulkanContext& ctx) : ctx_(ctx) {
  LVK_PROFILER_FUNCTION();

  const VkDeviceSize maxMemoryAllocationSize = ctx_.vkPhysicalDeviceVulkan11Properties_.maxMemoryAllocationSize;

  LVK_ASSERT(ctx_.config_.maxStagingBufferSize <= maxMemoryAllocationSize);

  // clamped to the max limits
  maxBufferSize_ = std::min(maxMemoryAllocationSize, ctx_.config_.maxStagingBufferSize);
  minBufferSize_ = std::min(minBufferSize_, maxBufferSize_);
}

void lvk::VulkanStagingDevice::bufferSubData(VulkanBuffer& buffer, size_t dstOffset, size_t size, const void* data) {
  LVK_PROFILER_FUNCTION();

  if (buffer.isMapped()) {
    buffer.bufferSubData(ctx_, dstOffset, size, data);
    return;
  }

  lvk::VulkanBuffer* stagingBuffer = ctx_.buffersPool_.get(stagingBuffer_);

  LVK_ASSERT(stagingBuffer);

  while (size) {
    // get next staging buffer free offset
    MemoryRegionDesc desc = getNextFreeOffset((uint32_t)size);
    const uint32_t chunkSize = std::min((uint64_t)size, desc.size_);

    // copy data into staging buffer
    stagingBuffer->bufferSubData(ctx_, desc.offset_, chunkSize, data);

    // do the transfer
    const VkBufferCopy copy = {
        .srcOffset = desc.offset_,
        .dstOffset = dstOffset,
        .size = chunkSize,
    };

    const lvk::VulkanImmediateCommands::CommandBufferWrapper& wrapper = ctx_.immediate_->acquire();
    vkCmdCopyBuffer(wrapper.cmdBuf_, stagingBuffer->vkBuffer_, buffer.vkBuffer_, 1, &copy);
    VkBufferMemoryBarrier barrier = {
        .sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,
        .srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT,
        .dstAccessMask = 0,
        .srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
        .dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
        .buffer = buffer.vkBuffer_,
        .offset = dstOffset,
        .size = chunkSize,
    };
    VkPipelineStageFlags dstMask = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT;
    if (buffer.vkUsageFlags_ & VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT) {
      dstMask |= VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT;
      barrier.dstAccessMask |= VK_ACCESS_INDIRECT_COMMAND_READ_BIT;
    }
    if (buffer.vkUsageFlags_ & VK_BUFFER_USAGE_INDEX_BUFFER_BIT) {
      dstMask |= VK_PIPELINE_STAGE_VERTEX_INPUT_BIT;
      barrier.dstAccessMask |= VK_ACCESS_INDEX_READ_BIT;
    }
    if (buffer.vkUsageFlags_ & VK_BUFFER_USAGE_VERTEX_BUFFER_BIT) {
      dstMask |= VK_PIPELINE_STAGE_VERTEX_INPUT_BIT;
      barrier.dstAccessMask |= VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT;
    }
    if (buffer.vkUsageFlags_ & VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR) {
      dstMask |= VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR;
      barrier.dstAccessMask |= VK_ACCESS_MEMORY_READ_BIT;
    }
    vkCmdPipelineBarrier(
        wrapper.cmdBuf_, VK_PIPELINE_STAGE_TRANSFER_BIT, dstMask, VkDependencyFlags{}, 0, nullptr, 1, &barrier, 0, nullptr);
    desc.handle_ = ctx_.immediate_->submit(wrapper);
    regions_.push_back(desc);

    size -= chunkSize;
    data = (uint8_t*)data + chunkSize;
    dstOffset += chunkSize;
  }
}

void lvk::VulkanStagingDevice::imageData2D(VulkanImage& image,
                                           const VkRect2D& imageRegion,
                                           uint32_t baseMipLevel,
                                           uint32_t numMipLevels,
                                           uint32_t layer,
                                           uint32_t numLayers,
                                           VkFormat format,
                                           const void* data,
                                           uint32_t bufferRowLength) {
  LVK_PROFILER_FUNCTION();

  LVK_ASSERT(numMipLevels <= LVK_MAX_MIP_LEVELS);

  const Format texFormat = vkFormatToFormat(format);

  // divide the width and height by 2 until we get to the size of level 'baseMipLevel'
  const uint32_t width = image.vkExtent_.width >> baseMipLevel;
  const uint32_t height = image.vkExtent_.height >> baseMipLevel;
  const bool coversFullImage = !imageRegion.offset.x && !imageRegion.offset.y && imageRegion.extent.width == width &&
                               imageRegion.extent.height == height;

  LVK_ASSERT(coversFullImage || image.vkImageLayout_ != VK_IMAGE_LAYOUT_UNDEFINED);

  if (numMipLevels > 1 || numLayers > 1) {
    LVK_ASSERT(!bufferRowLength);
    LVK_ASSERT_MSG(coversFullImage, "Uploading mip-levels with an image region that is smaller than the base mip-level is not supported");
  }

  // find the storage size for all mip-levels being uploaded
  uint32_t layerStorageSize = 0;
  for (uint32_t i = 0; i < numMipLevels; ++i) {
    const uint32_t mipSize =
        lvk::getTextureBytesPerLayer(bufferRowLength ? bufferRowLength : imageRegion.extent.width, imageRegion.extent.height, texFormat, i);
    layerStorageSize += mipSize;
  }

  const uint32_t storageSize = layerStorageSize * numLayers;

  ensureStagingBufferSize(storageSize);

  LVK_ASSERT(storageSize <= stagingBufferSize_);

  MemoryRegionDesc desc = getNextFreeOffset(storageSize);
  // No support for copying image in multiple smaller chunk sizes. If we get smaller buffer size than storageSize, we will wait for GPU idle
  // and get bigger chunk.
  if (desc.size_ < storageSize) {
    waitAndReset();
    desc = getNextFreeOffset(storageSize);
  }
  LVK_ASSERT(desc.size_ >= storageSize);

  const lvk::VulkanImmediateCommands::CommandBufferWrapper& wrapper = ctx_.immediate_->acquire();

  lvk::VulkanBuffer* stagingBuffer = ctx_.buffersPool_.get(stagingBuffer_);

  stagingBuffer->bufferSubData(ctx_, desc.offset_, storageSize, data);

  uint32_t offset = 0;

  const uint32_t numPlanes = lvk::getNumImagePlanes(image.vkImageFormat_);

  if (numPlanes > 1) {
    LVK_ASSERT(layer == 0 && baseMipLevel == 0);
    LVK_ASSERT(numLayers == 1 && numMipLevels == 1);
    LVK_ASSERT(imageRegion.offset.x == 0 && imageRegion.offset.y == 0);
    LVK_ASSERT(image.vkType_ == VK_IMAGE_TYPE_2D);
    LVK_ASSERT(image.vkExtent_.width == imageRegion.extent.width && image.vkExtent_.height == imageRegion.extent.height);
  }

  VkImageAspectFlags imageAspect = VK_IMAGE_ASPECT_COLOR_BIT;

  if (numPlanes == 2) {
    imageAspect = VK_IMAGE_ASPECT_PLANE_0_BIT | VK_IMAGE_ASPECT_PLANE_1_BIT;
  }
  if (numPlanes == 3) {
    imageAspect = VK_IMAGE_ASPECT_PLANE_0_BIT | VK_IMAGE_ASPECT_PLANE_1_BIT | VK_IMAGE_ASPECT_PLANE_2_BIT;
  }

  // https://registry.khronos.org/KTX/specs/1.0/ktxspec.v1.html
  for (uint32_t mipLevel = 0; mipLevel < numMipLevels; ++mipLevel) {
    for (uint32_t layer = 0; layer != numLayers; layer++) {
      const uint32_t currentMipLevel = baseMipLevel + mipLevel;

      LVK_ASSERT(currentMipLevel < image.numLevels_);
      LVK_ASSERT(mipLevel < image.numLevels_);

      // 1. Transition initial image layout into TRANSFER_DST_OPTIMAL
      lvk::imageMemoryBarrier2(wrapper.cmdBuf_,
                               image.vkImage_,
                               StageAccess{.stage = VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT, .access = VK_ACCESS_2_NONE},
                               StageAccess{.stage = VK_PIPELINE_STAGE_2_TRANSFER_BIT, .access = VK_ACCESS_2_TRANSFER_WRITE_BIT},
                               coversFullImage ? VK_IMAGE_LAYOUT_UNDEFINED : image.vkImageLayout_,
                               VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
                               VkImageSubresourceRange{imageAspect, currentMipLevel, 1, layer, 1});

#if LVK_VULKAN_PRINT_COMMANDS
      LLOGL("%p vkCmdCopyBufferToImage()\n", wrapper.cmdBuf_);
#endif // LVK_VULKAN_PRINT_COMMANDS
      // 2. Copy the pixel data from the staging buffer into the image
      uint32_t planeOffset = 0;
      for (uint32_t plane = 0; plane != numPlanes; plane++) {
        const VkExtent2D extent = lvk::getImagePlaneExtent(
            {
                .width = std::max(1u, imageRegion.extent.width >> mipLevel),
                .height = std::max(1u, imageRegion.extent.height >> mipLevel),
            },
            vkFormatToFormat(format),
            plane);
        const VkRect2D region = {
            .offset = {.x = imageRegion.offset.x >> mipLevel, .y = imageRegion.offset.y >> mipLevel},
            .extent = extent,
        };
        const VkBufferImageCopy copy = {
            // the offset for this level is at the start of all mip-levels plus the size of all previous mip-levels being uploaded
            .bufferOffset = desc.offset_ + offset + planeOffset,
            .bufferRowLength = bufferRowLength,
            .bufferImageHeight = 0,
            .imageSubresource =
                VkImageSubresourceLayers{numPlanes > 1 ? VK_IMAGE_ASPECT_PLANE_0_BIT << plane : imageAspect, currentMipLevel, layer, 1},
            .imageOffset = {.x = region.offset.x, .y = region.offset.y, .z = 0},
            .imageExtent = {.width = region.extent.width, .height = region.extent.height, .depth = 1u},
        };
        vkCmdCopyBufferToImage(wrapper.cmdBuf_, stagingBuffer->vkBuffer_, image.vkImage_, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &copy);
        planeOffset += lvk::getTextureBytesPerPlane(imageRegion.extent.width, imageRegion.extent.height, vkFormatToFormat(format), plane);
      }

      // 3. Transition TRANSFER_DST_OPTIMAL into SHADER_READ_ONLY_OPTIMAL
      lvk::imageMemoryBarrier2(
          wrapper.cmdBuf_,
          image.vkImage_,
          StageAccess{.stage = VK_PIPELINE_STAGE_2_TRANSFER_BIT, .access = VK_ACCESS_2_TRANSFER_WRITE_BIT},
          StageAccess{.stage = VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, .access = VK_ACCESS_2_MEMORY_READ_BIT | VK_ACCESS_2_MEMORY_WRITE_BIT},
          VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
          VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
          VkImageSubresourceRange{imageAspect, currentMipLevel, 1, layer, 1});

      offset += lvk::getTextureBytesPerLayer(imageRegion.extent.width, imageRegion.extent.height, texFormat, currentMipLevel);
    }
  }

  image.vkImageLayout_ = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;

  desc.handle_ = ctx_.immediate_->submit(wrapper);
  regions_.push_back(desc);
}

void lvk::VulkanStagingDevice::imageData3D(VulkanImage& image,
                                           const VkOffset3D& offset,
                                           const VkExtent3D& extent,
                                           VkFormat format,
                                           const void* data) {
  LVK_PROFILER_FUNCTION();
  LVK_ASSERT_MSG(image.numLevels_ == 1, "Can handle only 3D images with exactly 1 mip-level");
  LVK_ASSERT_MSG((offset.x == 0) && (offset.y == 0) && (offset.z == 0), "Can upload only full-size 3D images");
  const uint32_t storageSize = extent.width * extent.height * extent.depth * getBytesPerPixel(format);

  ensureStagingBufferSize(storageSize);

  LVK_ASSERT_MSG(storageSize <= stagingBufferSize_, "No support for copying image in multiple smaller chunk sizes");

  // get next staging buffer free offset
  MemoryRegionDesc desc = getNextFreeOffset(storageSize);

  // No support for copying image in multiple smaller chunk sizes.
  // If we get smaller buffer size than storageSize, we will wait for GPU idle and get a bigger chunk.
  if (desc.size_ < storageSize) {
    waitAndReset();
    desc = getNextFreeOffset(storageSize);
  }

  LVK_ASSERT(desc.size_ >= storageSize);

  lvk::VulkanBuffer* stagingBuffer = ctx_.buffersPool_.get(stagingBuffer_);

  // 1. Copy the pixel data into the host visible staging buffer
  stagingBuffer->bufferSubData(ctx_, desc.offset_, storageSize, data);

  const lvk::VulkanImmediateCommands::CommandBufferWrapper& wrapper = ctx_.immediate_->acquire();

  // 1. Transition initial image layout into TRANSFER_DST_OPTIMAL
  lvk::imageMemoryBarrier2(wrapper.cmdBuf_,
                           image.vkImage_,
                           StageAccess{.stage = VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT, .access = VK_ACCESS_2_NONE},
                           StageAccess{.stage = VK_PIPELINE_STAGE_2_TRANSFER_BIT, .access = VK_ACCESS_2_TRANSFER_WRITE_BIT},
                           VK_IMAGE_LAYOUT_UNDEFINED,
                           VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
                           VkImageSubresourceRange{VK_IMAGE_ASPECT_COLOR_BIT, 0, 1, 0, 1});

  // 2. Copy the pixel data from the staging buffer into the image
  const VkBufferImageCopy copy = {
      .bufferOffset = desc.offset_,
      .bufferRowLength = 0,
      .bufferImageHeight = 0,
      .imageSubresource = VkImageSubresourceLayers{VK_IMAGE_ASPECT_COLOR_BIT, 0, 0, 1},
      .imageOffset = offset,
      .imageExtent = extent,
  };
  vkCmdCopyBufferToImage(wrapper.cmdBuf_, stagingBuffer->vkBuffer_, image.vkImage_, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &copy);

  // 3. Transition TRANSFER_DST_OPTIMAL into SHADER_READ_ONLY_OPTIMAL
  lvk::imageMemoryBarrier2(
      wrapper.cmdBuf_,
      image.vkImage_,
      StageAccess{.stage = VK_PIPELINE_STAGE_2_TRANSFER_BIT, .access = VK_ACCESS_2_TRANSFER_WRITE_BIT},
      StageAccess{.stage = VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, .access = VK_ACCESS_2_MEMORY_READ_BIT | VK_ACCESS_2_MEMORY_WRITE_BIT},
      VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
      VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
      VkImageSubresourceRange{VK_IMAGE_ASPECT_COLOR_BIT, 0, 1, 0, 1});

  image.vkImageLayout_ = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;

  desc.handle_ = ctx_.immediate_->submit(wrapper);
  regions_.push_back(desc);
}

void lvk::VulkanStagingDevice::getImageData(VulkanImage& image,
                                            const VkOffset3D& offset,
                                            const VkExtent3D& extent,
                                            VkImageSubresourceRange range,
                                            VkFormat format,
                                            void* outData) {
  LVK_ASSERT(image.vkImageLayout_ != VK_IMAGE_LAYOUT_UNDEFINED);
  LVK_ASSERT(range.layerCount == 1);

  const uint32_t storageSize = extent.width * extent.height * extent.depth * getBytesPerPixel(format);

  ensureStagingBufferSize(storageSize);

  LVK_ASSERT(storageSize <= stagingBufferSize_);

  // get next staging buffer free offset
  MemoryRegionDesc desc = getNextFreeOffset(storageSize);

  // No support for copying image in multiple smaller chunk sizes.
  // If we get smaller buffer size than storageSize, we will wait for GPU idle and get a bigger chunk.
  if (desc.size_ < storageSize) {
    waitAndReset();
    desc = getNextFreeOffset(storageSize);
  }

  LVK_ASSERT(desc.size_ >= storageSize);

  lvk::VulkanBuffer* stagingBuffer = ctx_.buffersPool_.get(stagingBuffer_);

  const lvk::VulkanImmediateCommands::CommandBufferWrapper& wrapper1 = ctx_.immediate_->acquire();

  // 1. Transition to VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL
  lvk::imageMemoryBarrier2(
      wrapper1.cmdBuf_,
      image.vkImage_,
      StageAccess{.stage = VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT, .access = VK_ACCESS_2_MEMORY_READ_BIT | VK_ACCESS_2_MEMORY_WRITE_BIT},
      StageAccess{.stage = VK_PIPELINE_STAGE_2_TRANSFER_BIT, .access = VK_ACCESS_2_TRANSFER_READ_BIT},
      image.vkImageLayout_,
      VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
      range);

  // 2.  Copy the pixel data from the image into the staging buffer
  const VkBufferImageCopy copy = {
      .bufferOffset = desc.offset_,
      .bufferRowLength = 0,
      .bufferImageHeight = extent.height,
      .imageSubresource =
          VkImageSubresourceLayers{
              .aspectMask = range.aspectMask,
              .mipLevel = range.baseMipLevel,
              .baseArrayLayer = range.baseArrayLayer,
              .layerCount = range.layerCount,
          },
      .imageOffset = offset,
      .imageExtent = extent,
  };
  vkCmdCopyImageToBuffer(wrapper1.cmdBuf_, image.vkImage_, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, stagingBuffer->vkBuffer_, 1, &copy);

  desc.handle_ = ctx_.immediate_->submit(wrapper1);
  regions_.push_back(desc);

  waitAndReset();

  if (!stagingBuffer->isCoherentMemory_) {
    stagingBuffer->invalidateMappedMemory(ctx_, desc.offset_, desc.size_);
  }

  // 3. Copy data from staging buffer into data
  memcpy(outData, stagingBuffer->getMappedPtr() + desc.offset_, storageSize);

  // 4. Transition back to the initial image layout
  const lvk::VulkanImmediateCommands::CommandBufferWrapper& wrapper2 = ctx_.immediate_->acquire();

  lvk::imageMemoryBarrier2(
      wrapper2.cmdBuf_,
      image.vkImage_,
      StageAccess{.stage = VK_PIPELINE_STAGE_2_TRANSFER_BIT, .access = VK_ACCESS_2_TRANSFER_READ_BIT},
      StageAccess{.stage = VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT, .access = VK_ACCESS_2_MEMORY_READ_BIT | VK_ACCESS_2_MEMORY_WRITE_BIT},
      VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
      image.vkImageLayout_,
      range);

  ctx_.immediate_->wait(ctx_.immediate_->submit(wrapper2));
}

void lvk::VulkanStagingDevice::ensureStagingBufferSize(uint32_t sizeNeeded) {
  LVK_PROFILER_FUNCTION();

  const uint32_t alignedSize = std::max(getAlignedSize(sizeNeeded, kStagingBufferAlignment), minBufferSize_);

  sizeNeeded = alignedSize < ctx_.config_.maxStagingBufferSize ? alignedSize : ctx_.config_.maxStagingBufferSize;

  if (!stagingBuffer_.empty()) {
    const bool isEnoughSize = sizeNeeded <= stagingBufferSize_;
    const bool isMaxSize = stagingBufferSize_ == ctx_.config_.maxStagingBufferSize;

    if (isEnoughSize || isMaxSize) {
      return;
    }
  }

  waitAndReset();

  // deallocate the previous staging buffer
  stagingBuffer_ = nullptr;

  // if the combined size of the new staging buffer and the existing one is larger than the limit imposed by some architectures on buffers
  // that are device and host visible, we need to wait for the current buffer to be destroyed before we can allocate a new one
  if ((sizeNeeded + stagingBufferSize_) > ctx_.config_.maxStagingBufferSize) {
    ctx_.waitDeferredTasks();
  }

  stagingBufferSize_ = sizeNeeded;

  char debugName[256] = {0};
  snprintf(debugName, sizeof(debugName) - 1, "Buffer: staging buffer %u", stagingBufferCounter_++);

  stagingBuffer_ = {&ctx_,
                    ctx_.createBuffer(stagingBufferSize_,
                                      VK_BUFFER_USAGE_TRANSFER_SRC_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT,
                                      VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT,
                                      nullptr,
                                      debugName)};
  LVK_ASSERT(!stagingBuffer_.empty());

  regions_.clear();
  regions_.push_back({0, stagingBufferSize_, SubmitHandle()});
}

lvk::VulkanStagingDevice::MemoryRegionDesc lvk::VulkanStagingDevice::getNextFreeOffset(uint32_t size) {
  LVK_PROFILER_FUNCTION();

  const uint32_t requestedAlignedSize = getAlignedSize(size, kStagingBufferAlignment);

  ensureStagingBufferSize(requestedAlignedSize);

  LVK_ASSERT(!regions_.empty());

  // if we can't find an available region that is big enough to store requestedAlignedSize, return whatever we could find, which will be
  // stored in bestNextIt
  auto bestNextIt = regions_.begin();

  for (auto it = regions_.begin(); it != regions_.end(); ++it) {
    if (ctx_.immediate_->isReady(it->handle_)) {
      // This region is free, but is it big enough?
      if (it->size_ >= requestedAlignedSize) {
        // It is big enough!
        const uint32_t unusedSize = it->size_ - requestedAlignedSize;
        const uint32_t unusedOffset = it->offset_ + requestedAlignedSize;

        // Return this region and add the remaining unused size to the regions_ deque
        SCOPE_EXIT {
          regions_.erase(it);
          if (unusedSize > 0) {
            regions_.insert(regions_.begin(), {unusedOffset, unusedSize, SubmitHandle()});
          }
        };

        return {it->offset_, requestedAlignedSize, SubmitHandle()};
      }
      // cache the largest available region that isn't as big as the one we're looking for
      if (it->size_ > bestNextIt->size_) {
        bestNextIt = it;
      }
    }
  }

  // we found a region that is available that is smaller than the requested size. It's the best we can do
  if (bestNextIt != regions_.end() && ctx_.immediate_->isReady(bestNextIt->handle_)) {
    SCOPE_EXIT {
      regions_.erase(bestNextIt);
    };

    return {bestNextIt->offset_, bestNextIt->size_, SubmitHandle()};
  }

  // nothing was available. Let's wait for the entire staging buffer to become free
  waitAndReset();

  // waitAndReset() adds a region that spans the entire buffer. Since we'll be using part of it, we need to replace it with a used block and
  // an unused portion
  regions_.clear();

  // store the unused size in the deque first...
  const uint64_t unusedSize = stagingBufferSize_ > requestedAlignedSize ? stagingBufferSize_ - requestedAlignedSize : 0;

  if (unusedSize) {
    const uint64_t unusedOffset = stagingBufferSize_ - unusedSize;
    regions_.insert(regions_.begin(), {unusedOffset, unusedSize, SubmitHandle()});
  }

  // ...and then return the smallest free region that can hold the requested size
  return {
      .offset_ = 0,
      .size_ = stagingBufferSize_ - unusedSize,
      .handle_ = SubmitHandle(),
  };
}

void lvk::VulkanStagingDevice::waitAndReset() {
  LVK_PROFILER_FUNCTION_COLOR(LVK_PROFILER_COLOR_WAIT);

  for (const MemoryRegionDesc& r : regions_) {
    ctx_.immediate_->wait(r.handle_);
  };

  regions_.clear();
  regions_.push_back({0, stagingBufferSize_, SubmitHandle()});
}

lvk::VulkanContext::VulkanContext(const lvk::ContextConfig& config, void* window, void* display, VkSurfaceKHR surface)
: config_(config)
, vkSurface_(surface) {
  LVK_PROFILER_THREAD("MainThread");

  pimpl_ = std::make_unique<VulkanContextImpl>();

  if (volkInitialize() != VK_SUCCESS) {
    LLOGW("volkInitialize() failed\n");
    exit(255);
  };

  glslang_initialize_process();

  if (!LVK_VERIFY(createInstance().isOk())) {
    LLOGW("createInstance() failed\n");
    exit(255);
  }

  if (!surface) {
    if (config_.enableHeadlessSurface) {
      createHeadlessSurface();
    } else if (window || display) {
      createSurface(window, display);
    }
  }
}

lvk::VulkanContext::~VulkanContext() {
  LVK_PROFILER_FUNCTION();

  VK_ASSERT(vkDeviceWaitIdle(vkDevice_));

#if defined(LVK_WITH_TRACY_GPU)
  TracyVkDestroy(pimpl_->tracyVkCtx_);
  if (pimpl_->tracyCommandPool_) {
    vkDestroyCommandPool(vkDevice_, pimpl_->tracyCommandPool_, nullptr);
  }
#endif // LVK_WITH_TRACY_GPU

  stagingDevice_.reset(nullptr);
  swapchain_.reset(nullptr); // swapchain has to be destroyed prior to Surface

  vkDestroySemaphore(vkDevice_, timelineSemaphore_, nullptr);

  destroy(dummyTexture_);

  for (VulkanContextImpl::YcbcrConversionData& data : pimpl_->ycbcrConversionData_) {
    if (data.info.conversion != VK_NULL_HANDLE) {
      vkDestroySamplerYcbcrConversion(vkDevice_, data.info.conversion, nullptr);
      data.sampler.reset();
    }
  }

  if (shaderModulesPool_.numObjects()) {
    LLOGW("Leaked %u shader modules\n", shaderModulesPool_.numObjects());
  }
  if (renderPipelinesPool_.numObjects()) {
    LLOGW("Leaked %u render pipelines\n", renderPipelinesPool_.numObjects());
  }
  if (computePipelinesPool_.numObjects()) {
    LLOGW("Leaked %u compute pipelines\n", computePipelinesPool_.numObjects());
  }
  if (samplersPool_.numObjects() > 1) {
    // the dummy value is owned by the context
    LLOGW("Leaked %u samplers\n", samplersPool_.numObjects() - 1);
  }
  if (texturesPool_.numObjects()) {
    LLOGW("Leaked %u textures\n", texturesPool_.numObjects());
  }
  if (buffersPool_.numObjects()) {
    LLOGW("Leaked %u buffers\n", buffersPool_.numObjects());
  }

  // manually destroy the dummy sampler
  vkDestroySampler(vkDevice_, samplersPool_.objects_.front().obj_, nullptr);
  samplersPool_.clear();
  computePipelinesPool_.clear();
  renderPipelinesPool_.clear();
  shaderModulesPool_.clear();
  texturesPool_.clear();

  waitDeferredTasks();

  immediate_.reset(nullptr);

  for (const DescriptorSet& dset : DSets_) {
    vkDestroyDescriptorPool(vkDevice_, dset.vkDPool, nullptr);
    vkDestroyDescriptorSetLayout(vkDevice_, dset.vkDSL, nullptr);
  }
  vkDestroyDescriptorSetLayout(vkDevice_, dslInputAttachments_, nullptr);
  vkDestroySurfaceKHR(vkInstance_, vkSurface_, nullptr);
  vkDestroyPipelineCache(vkDevice_, pipelineCache_, nullptr);

  // Clean up VMA
  if (LVK_VULKAN_USE_VMA) {
    vmaDestroyAllocator(pimpl_->vma_);
  }

  // Device has to be destroyed prior to Instance
  vkDestroyDevice(vkDevice_, nullptr);

  if (vkDebugUtilsMessenger_) {
    vkDestroyDebugUtilsMessengerEXT(vkInstance_, vkDebugUtilsMessenger_, nullptr);
  }

  vkDestroyInstance(vkInstance_, nullptr);

  glslang_finalize_process();

  LLOGL("Vulkan graphics pipelines created: %u\n", VulkanPipelineBuilder::getNumPipelinesCreated());
}

lvk::ICommandBuffer& lvk::VulkanContext::acquireCommandBuffer() {
  LVK_PROFILER_FUNCTION();

  LVK_ASSERT_MSG(!pimpl_->currentCommandBuffer_.ctx_, "Cannot acquire more than 1 command buffer simultaneously");

#if defined(_M_ARM64)
  vkDeviceWaitIdle(vkDevice_); // a temporary workaround for Windows on Snapdragon
#endif

  pimpl_->currentCommandBuffer_ = CommandBuffer(this);

  return pimpl_->currentCommandBuffer_;
}

lvk::SubmitHandle lvk::VulkanContext::submit(lvk::ICommandBuffer& commandBuffer, TextureHandle present) {
  LVK_PROFILER_FUNCTION();

  CommandBuffer* vkCmdBuffer = static_cast<CommandBuffer*>(&commandBuffer);

  LVK_ASSERT(vkCmdBuffer);
  LVK_ASSERT(vkCmdBuffer->ctx_);
  LVK_ASSERT(vkCmdBuffer->wrapper_);

#if defined(LVK_WITH_TRACY_GPU)
  TracyVkCollect(pimpl_->tracyVkCtx_, vkCmdBuffer->wrapper_->cmdBuf_);
#endif // LVK_WITH_TRACY_GPU

  if (present) {
    const lvk::VulkanImage& tex = *texturesPool_.get(present);

    LVK_ASSERT(tex.isSwapchainImage_);

    tex.transitionLayout(vkCmdBuffer->wrapper_->cmdBuf_,
                         VK_IMAGE_LAYOUT_PRESENT_SRC_KHR,
                         VkImageSubresourceRange{VK_IMAGE_ASPECT_COLOR_BIT, 0, VK_REMAINING_MIP_LEVELS, 0, VK_REMAINING_ARRAY_LAYERS});
  }

  const bool shouldPresent = hasSwapchain() && present;

  if (shouldPresent) {
    // if we a presenting a swapchain image, signal our timeline semaphore
    const uint64_t signalValue = swapchain_->currentFrameIndex_ + swapchain_->getNumSwapchainImages();
    // we wait for this value next time we want to acquire this swapchain image
    swapchain_->timelineWaitValues_[swapchain_->currentImageIndex_] = signalValue;
    immediate_->signalSemaphore(timelineSemaphore_, signalValue);
  }

  vkCmdBuffer->lastSubmitHandle_ = immediate_->submit(*vkCmdBuffer->wrapper_);

  if (shouldPresent) {
    swapchain_->present(immediate_->acquireLastSubmitSemaphore());
  }

  processDeferredTasks();

  SubmitHandle handle = vkCmdBuffer->lastSubmitHandle_;

  // assign the last submit handle to all previous "orphan" dsets
  const size_t numSets = DSets_.size();
  for (size_t count = 0; count != numSets; count++) {
    // calculate index wrapping backwards
    const size_t idx = (lastUpdatedDSet_ + numSets - 1 - count) % numSets;
    if (!DSets_[idx].handle_.empty()) {
      // break once we reach a "non-orphan" dset
      break;
    }
    DSets_[idx].handle_ = handle;
  }

  // reset
  pimpl_->currentCommandBuffer_ = {};

  return handle;
}

void lvk::VulkanContext::wait(SubmitHandle handle) {
  immediate_->wait(handle);
}

lvk::Holder<lvk::BufferHandle> lvk::VulkanContext::createBuffer(const BufferDesc& requestedDesc, const char* debugName, Result* outResult) {
  BufferDesc desc = requestedDesc;

  if (debugName && *debugName)
    desc.debugName = debugName;

  if (!useStaging_ && (desc.storage == StorageType_Device)) {
    desc.storage = StorageType_HostVisible;
  }

  // Use staging device to transfer data into the buffer when the storage is private to the device
  VkBufferUsageFlags usageFlags = (desc.storage == StorageType_Device) ? VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_TRANSFER_SRC_BIT
                                                                       : 0;

  if (desc.usage == 0) {
    Result::setResult(outResult, Result(Result::Code::ArgumentOutOfRange, "Invalid buffer usage"));
    return {};
  }

  if (desc.usage & BufferUsageBits_Index) {
    usageFlags |= VK_BUFFER_USAGE_INDEX_BUFFER_BIT;
  }
  if (desc.usage & BufferUsageBits_Vertex) {
    usageFlags |= VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
  }
  if (desc.usage & BufferUsageBits_Uniform) {
    usageFlags |= VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT;
  }

  if (desc.usage & BufferUsageBits_Storage) {
    usageFlags |= VK_BUFFER_USAGE_STORAGE_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT;
  }

  if (desc.usage & BufferUsageBits_Indirect) {
    usageFlags |= VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT | VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT;
  }

  if (desc.usage & BufferUsageBits_ShaderBindingTable) {
    usageFlags |= VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR | VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT;
  }

  if (desc.usage & BufferUsageBits_AccelStructBuildInputReadOnly) {
    usageFlags |= VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR | VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT |
                  VK_BUFFER_USAGE_TRANSFER_DST_BIT;
  }

  if (desc.usage & BufferUsageBits_AccelStructStorage) {
    usageFlags |= VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR | VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT;
  }

  LVK_ASSERT_MSG(usageFlags, "Invalid buffer usage");

  const VkMemoryPropertyFlags memFlags = storageTypeToVkMemoryPropertyFlags(desc.storage);

  Result result;
  BufferHandle handle = createBuffer(desc.size, usageFlags, memFlags, &result, desc.debugName);

  if (!LVK_VERIFY(result.isOk())) {
    Result::setResult(outResult, result);
    return {};
  }

  if (desc.data) {
    upload(handle, desc.data, desc.size, 0);
  }

  Result::setResult(outResult, Result());

  return {this, handle};
}

lvk::Holder<lvk::QueryPoolHandle> lvk::VulkanContext::createQueryPool(uint32_t numQueries, const char* debugName, Result* outResult) {
  LVK_PROFILER_FUNCTION();

  const VkQueryPoolCreateInfo createInfo = {
      .sType = VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO,
      .flags = 0,
      .queryType = VK_QUERY_TYPE_TIMESTAMP,
      .queryCount = numQueries,
      .pipelineStatistics = 0,
  };

  VkQueryPool queryPool = VK_NULL_HANDLE;
  VK_ASSERT(vkCreateQueryPool(vkDevice_, &createInfo, 0, &queryPool));

  if (!queryPool) {
    Result::setResult(outResult, Result(Result::Code::RuntimeError, "Cannot create QueryPool"));
    return {};
  }

  if (debugName && *debugName) {
    VK_ASSERT(lvk::setDebugObjectName(vkDevice_, VK_OBJECT_TYPE_QUERY_POOL, (uint64_t)queryPool, debugName));
  }

  lvk::QueryPoolHandle handle = queriesPool_.create(std::move(queryPool));

  return {this, handle};
}

lvk::Holder<lvk::AccelStructHandle> lvk::VulkanContext::createAccelerationStructure(const AccelStructDesc& desc, Result* outResult) {
  LVK_PROFILER_FUNCTION();

  if (!LVK_VERIFY(has_KHR_acceleration_structure_)) {
    Result::setResult(outResult, Result(Result::Code::RuntimeError, "VK_KHR_acceleration_structure is not enabled"));
    return {};
  }

  Result result;

  AccelStructHandle handle;

  switch (desc.type) {
  case AccelStructType_BLAS:
    handle = createBLAS(desc, &result);
    break;
  case AccelStructType_TLAS:
    handle = createTLAS(desc, &result);
    break;
  default:
    LVK_ASSERT_MSG(false, "Invalid acceleration structure type");
    Result::setResult(outResult, Result(Result::Code::ArgumentOutOfRange, "Invalid acceleration structure type"));
    return {};
  }

  if (!LVK_VERIFY(result.isOk() && handle.valid())) {
    Result::setResult(outResult, Result(Result::Code::RuntimeError, "Cannot create AccelerationStructure"));
    return {};
  }

  Result::setResult(outResult, result);

  awaitingCreation_ = true;

  return {this, handle};
}

lvk::Holder<lvk::SamplerHandle> lvk::VulkanContext::createSampler(const SamplerStateDesc& desc, Result* outResult) {
  LVK_PROFILER_FUNCTION();

  Result result;

  const VkSamplerCreateInfo info = samplerStateDescToVkSamplerCreateInfo(desc, getVkPhysicalDeviceProperties().limits);

  SamplerHandle handle = createSampler(info, &result, Format_Invalid, desc.debugName);

  if (!LVK_VERIFY(result.isOk())) {
    Result::setResult(outResult, Result(Result::Code::RuntimeError, "Cannot create Sampler"));
    return {};
  }

  Result::setResult(outResult, result);

  return {this, handle};
}

lvk::Holder<lvk::TextureHandle> lvk::VulkanContext::createTexture(const TextureDesc& requestedDesc,
                                                                  const char* debugName,
                                                                  Result* outResult) {
  LVK_PROFILER_FUNCTION_COLOR(LVK_PROFILER_COLOR_CREATE);

  TextureDesc desc(requestedDesc);

  if (debugName && *debugName) {
    desc.debugName = debugName;
  }

  auto getClosestDepthStencilFormat = [this](lvk::Format desiredFormat) -> VkFormat {
    // Get a list of compatible depth formats for a given desired format.
    // The list will contain depth format that are ordered from most to least closest
    const std::vector<VkFormat> compatibleDepthStencilFormatList = getCompatibleDepthStencilFormats(desiredFormat);

    // check if any of the format in compatible list is supported
    for (VkFormat format : compatibleDepthStencilFormatList) {
      if (std::find(deviceDepthFormats_.cbegin(), deviceDepthFormats_.cend(), format) != deviceDepthFormats_.cend()) {
        return format;
      }
    }

    // no matching found, choose the first supported format
    return !deviceDepthFormats_.empty() ? deviceDepthFormats_[0] : VK_FORMAT_D24_UNORM_S8_UINT;
  };

  const VkFormat vkFormat = lvk::isDepthOrStencilFormat(desc.format) ? getClosestDepthStencilFormat(desc.format)
                                                                     : formatToVkFormat(desc.format);

  LVK_ASSERT_MSG(vkFormat != VK_FORMAT_UNDEFINED, "Invalid VkFormat value");

  const lvk::TextureType type = desc.type;
  if (!LVK_VERIFY(type == TextureType_2D || type == TextureType_Cube || type == TextureType_3D)) {
    LVK_ASSERT_MSG(false, "Only 2D, 3D and Cube textures are supported");
    Result::setResult(outResult, Result::Code::RuntimeError);
    return {};
  }

  if (desc.numMipLevels == 0) {
    LVK_ASSERT_MSG(false, "The number of mip levels specified must be greater than 0");
    desc.numMipLevels = 1;
  }

  if (desc.numSamples > 1 && desc.numMipLevels != 1) {
    LVK_ASSERT_MSG(false, "The number of mip levels for multisampled images should be 1");
    Result::setResult(outResult, Result::Code::ArgumentOutOfRange, "The number of mip-levels for multisampled images should be 1");
    return {};
  }

  if (desc.numSamples > 1 && type == TextureType_3D) {
    LVK_ASSERT_MSG(false, "Multisampled 3D images are not supported");
    Result::setResult(outResult, Result::Code::ArgumentOutOfRange, "Multisampled 3D images are not supported");
    return {};
  }

  if (!LVK_VERIFY(desc.numMipLevels <= lvk::calcNumMipLevels(desc.dimensions.width, desc.dimensions.height))) {
    Result::setResult(outResult,
                      Result::Code::ArgumentOutOfRange,
                      "The number of specified mip-levels is greater than the maximum possible "
                      "number of mip-levels.");
    return {};
  }

  if (desc.usage == 0) {
    LVK_ASSERT_MSG(false, "Texture usage flags are not set");
    desc.usage = lvk::TextureUsageBits_Sampled;
  }

  /* Use staging device to transfer data into the image when the storage is private to the device */
  VkImageUsageFlags usageFlags = (desc.storage == StorageType_Device) ? VK_IMAGE_USAGE_TRANSFER_DST_BIT : 0;

  if (desc.usage & lvk::TextureUsageBits_Sampled) {
    usageFlags |= VK_IMAGE_USAGE_SAMPLED_BIT;
  }
  if (desc.usage & lvk::TextureUsageBits_Storage) {
    LVK_ASSERT_MSG(desc.numSamples <= 1, "Storage images cannot be multisampled");
    usageFlags |= VK_IMAGE_USAGE_STORAGE_BIT;
  }
  if (desc.usage & lvk::TextureUsageBits_Attachment) {
    usageFlags |= lvk::isDepthOrStencilFormat(desc.format) ? VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT
                                                           : VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;
    if (desc.storage == lvk::StorageType_Memoryless) {
      usageFlags |= VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT;
    }
  }
  if (desc.usage & lvk::TextureUsageBits_InputAttachment) {
    LVK_ASSERT_MSG(desc.usage & lvk::TextureUsageBits_Attachment, "Input attachments must be TextureUsageBits_Attachment");
    usageFlags |= VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT;
  }

  if (desc.storage != lvk::StorageType_Memoryless) {
    // For now, always set this flag so we can read it back
    usageFlags |= VK_IMAGE_USAGE_TRANSFER_SRC_BIT;
  }

  LVK_ASSERT_MSG(usageFlags != 0, "Invalid usage flags");

  const VkMemoryPropertyFlags memFlags = storageTypeToVkMemoryPropertyFlags(desc.storage);

  const bool hasDebugName = desc.debugName && *desc.debugName;

  char debugNameImage[256] = {0};
  char debugNameImageView[256] = {0};

  if (hasDebugName) {
    snprintf(debugNameImage, sizeof(debugNameImage) - 1, "Image: %s", desc.debugName);
    snprintf(debugNameImageView, sizeof(debugNameImageView) - 1, "Image View: %s", desc.debugName);
  }

  VkImageCreateFlags vkCreateFlags = 0;
  VkImageViewType vkImageViewType;
  VkImageType vkImageType;
  VkSampleCountFlagBits vkSamples = VK_SAMPLE_COUNT_1_BIT;
  uint32_t numLayers = desc.numLayers;
  switch (desc.type) {
  case TextureType_2D:
    vkImageViewType = numLayers > 1 ? VK_IMAGE_VIEW_TYPE_2D_ARRAY : VK_IMAGE_VIEW_TYPE_2D;
    vkImageType = VK_IMAGE_TYPE_2D;
    vkSamples = lvk::getVulkanSampleCountFlags(desc.numSamples, getFramebufferMSAABitMask());
    break;
  case TextureType_3D:
    vkImageViewType = VK_IMAGE_VIEW_TYPE_3D;
    vkImageType = VK_IMAGE_TYPE_3D;
    break;
  case TextureType_Cube:
    vkImageViewType = numLayers > 1 ? VK_IMAGE_VIEW_TYPE_CUBE_ARRAY : VK_IMAGE_VIEW_TYPE_CUBE;
    vkImageType = VK_IMAGE_TYPE_2D;
    vkCreateFlags = VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT;
    numLayers *= 6;
    break;
  default:
    LVK_ASSERT_MSG(false, "Code should NOT be reached");
    Result::setResult(outResult, Result::Code::RuntimeError, "Unsupported texture type");
    return {};
  }

  const VkExtent3D vkExtent{desc.dimensions.width, desc.dimensions.height, desc.dimensions.depth};
  const uint32_t numLevels = desc.numMipLevels;

  if (!LVK_VERIFY(validateImageLimits(vkImageType, vkSamples, vkExtent, getVkPhysicalDeviceProperties().limits, outResult))) {
    return {};
  }

  LVK_ASSERT_MSG(numLevels > 0, "The image must contain at least one mip-level");
  LVK_ASSERT_MSG(numLayers > 0, "The image must contain at least one layer");
  LVK_ASSERT_MSG(vkSamples > 0, "The image must contain at least one sample");
  LVK_ASSERT(vkExtent.width > 0);
  LVK_ASSERT(vkExtent.height > 0);
  LVK_ASSERT(vkExtent.depth > 0);

  lvk::VulkanImage image = {
      .vkUsageFlags_ = usageFlags,
      .vkExtent_ = vkExtent,
      .vkType_ = vkImageType,
      .vkImageFormat_ = vkFormat,
      .vkSamples_ = vkSamples,
      .numLevels_ = numLevels,
      .numLayers_ = numLayers,
      .isDepthFormat_ = VulkanImage::isDepthFormat(vkFormat),
      .isStencilFormat_ = VulkanImage::isStencilFormat(vkFormat),
  };

  if (hasDebugName) {
    // store debug name
    snprintf(image.debugName_, sizeof(image.debugName_) - 1, "%s", desc.debugName);
  }

  const uint32_t numPlanes = lvk::getNumImagePlanes(desc.format);
  const bool isDisjoint = numPlanes > 1;

  if (isDisjoint) {
    // some constraints for multiplanar image formats
    LVK_ASSERT(vkImageType == VK_IMAGE_TYPE_2D);
    LVK_ASSERT(vkSamples == VK_SAMPLE_COUNT_1_BIT);
    LVK_ASSERT(numLayers == 1);
    LVK_ASSERT(numLevels == 1);
    VkFormatProperties2 props = {
        .sType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2,
    };
    vkGetPhysicalDeviceFormatProperties2(vkPhysicalDevice_, vkFormat, &props);
    if ((props.formatProperties.optimalTilingFeatures & VK_FORMAT_FEATURE_DISJOINT_BIT) == 0) {
      LLOGW("VK_FORMAT_FEATURE_DISJOINT_BIT is not supported for VkFormat = %u\n", (uint32_t)vkFormat);
    }
    vkCreateFlags |= VK_IMAGE_CREATE_DISJOINT_BIT | VK_IMAGE_CREATE_ALIAS_BIT | VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT;
    awaitingNewImmutableSamplers_ = true;
  }

  const VkImageCreateInfo ci = {
      .sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
      .pNext = nullptr,
      .flags = vkCreateFlags,
      .imageType = vkImageType,
      .format = vkFormat,
      .extent = vkExtent,
      .mipLevels = numLevels,
      .arrayLayers = numLayers,
      .samples = vkSamples,
      .tiling = VK_IMAGE_TILING_OPTIMAL,
      .usage = usageFlags,
      .sharingMode = VK_SHARING_MODE_EXCLUSIVE,
      .queueFamilyIndexCount = 0,
      .pQueueFamilyIndices = nullptr,
      .initialLayout = VK_IMAGE_LAYOUT_UNDEFINED,
  };

  if (LVK_VULKAN_USE_VMA && numPlanes == 1) {
    VmaAllocationCreateInfo vmaAllocInfo = {
        .usage = memFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT ? VMA_MEMORY_USAGE_CPU_TO_GPU : VMA_MEMORY_USAGE_AUTO,
    };

    VkResult result = vmaCreateImage((VmaAllocator)getVmaAllocator(), &ci, &vmaAllocInfo, &image.vkImage_, &image.vmaAllocation_, nullptr);

    if (!LVK_VERIFY(result == VK_SUCCESS)) {
      LLOGW("Failed: error result: %d, memflags: %d,  imageformat: %d\n", result, memFlags, image.vkImageFormat_);
      Result::setResult(outResult, Result::Code::RuntimeError, "vmaCreateImage() failed");
      return {};
    }

    // handle memory-mapped buffers
    if (memFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) {
      vmaMapMemory((VmaAllocator)getVmaAllocator(), image.vmaAllocation_, &image.mappedPtr_);
    }
  } else {
    // create image
    VK_ASSERT(vkCreateImage(vkDevice_, &ci, nullptr, &image.vkImage_));

    // back the image with some memory
    constexpr uint32_t kNumMaxImagePlanes = LVK_ARRAY_NUM_ELEMENTS(image.vkMemory_);

    VkMemoryRequirements2 memRequirements[kNumMaxImagePlanes] = {
        {.sType = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2},
        {.sType = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2},
        {.sType = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2},
    };

    const VkImagePlaneMemoryRequirementsInfo planes[kNumMaxImagePlanes] = {
        {.sType = VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO, .planeAspect = VK_IMAGE_ASPECT_PLANE_0_BIT},
        {.sType = VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO, .planeAspect = VK_IMAGE_ASPECT_PLANE_1_BIT},
        {.sType = VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO, .planeAspect = VK_IMAGE_ASPECT_PLANE_2_BIT},
    };

    const VkImage img = image.vkImage_;

    const VkImageMemoryRequirementsInfo2 imgRequirements[kNumMaxImagePlanes] = {
        {.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2, .pNext = numPlanes > 0 ? &planes[0] : nullptr, .image = img},
        {.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2, .pNext = numPlanes > 1 ? &planes[1] : nullptr, .image = img},
        {.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2, .pNext = numPlanes > 2 ? &planes[2] : nullptr, .image = img},
    };

    const VkDeviceSize maxMemoryAllocationSize = vkPhysicalDeviceVulkan11Properties_.maxMemoryAllocationSize;

    for (uint32_t p = 0; p != numPlanes; p++) {
      vkGetImageMemoryRequirements2(vkDevice_, &imgRequirements[p], &memRequirements[p]);
      LVK_ASSERT(memRequirements[p].memoryRequirements.size <= maxMemoryAllocationSize);
      VK_ASSERT(lvk::allocateMemory2(vkPhysicalDevice_, vkDevice_, &memRequirements[p], memFlags, &image.vkMemory_[p]));
    }

    const VkBindImagePlaneMemoryInfo bindImagePlaneMemoryInfo[kNumMaxImagePlanes] = {
        {VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO, nullptr, VK_IMAGE_ASPECT_PLANE_0_BIT},
        {VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO, nullptr, VK_IMAGE_ASPECT_PLANE_1_BIT},
        {VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO, nullptr, VK_IMAGE_ASPECT_PLANE_2_BIT},
    };
    const VkBindImageMemoryInfo bindInfo[kNumMaxImagePlanes] = {
        lvk::getBindImageMemoryInfo(isDisjoint ? &bindImagePlaneMemoryInfo[0] : nullptr, img, image.vkMemory_[0]),
        lvk::getBindImageMemoryInfo(&bindImagePlaneMemoryInfo[1], img, image.vkMemory_[1]),
        lvk::getBindImageMemoryInfo(&bindImagePlaneMemoryInfo[2], img, image.vkMemory_[2]),
    };
    VK_ASSERT(vkBindImageMemory2(vkDevice_, numPlanes, bindInfo));

    // handle memory-mapped images
    if (memFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT && numPlanes == 1) {
      VK_ASSERT(vkMapMemory(vkDevice_, image.vkMemory_[0], 0, VK_WHOLE_SIZE, 0, &image.mappedPtr_));
    }
  }

  VK_ASSERT(lvk::setDebugObjectName(vkDevice_, VK_OBJECT_TYPE_IMAGE, (uint64_t)image.vkImage_, debugNameImage));

  // get physical device's properties for the image's format
  {
    VkFormatProperties2 props = {
        .sType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2,
    };
    vkGetPhysicalDeviceFormatProperties2(vkPhysicalDevice_, image.vkImageFormat_, &props);
    image.vkFormatProperties_ = props.formatProperties;
  }

  VkImageAspectFlags aspect = 0;
  if (image.isDepthFormat_ || image.isStencilFormat_) {
    if (image.isDepthFormat_) {
      aspect |= VK_IMAGE_ASPECT_DEPTH_BIT;
    } else if (image.isStencilFormat_) {
      aspect |= VK_IMAGE_ASPECT_STENCIL_BIT;
    }
  } else {
    aspect = VK_IMAGE_ASPECT_COLOR_BIT;
  }

  const VkComponentMapping components = {
      .r = VkComponentSwizzle(desc.components.r),
      .g = VkComponentSwizzle(desc.components.g),
      .b = VkComponentSwizzle(desc.components.b),
      .a = VkComponentSwizzle(desc.components.a),
  };

  const VkSamplerYcbcrConversionInfo* ycbcrInfo = isDisjoint ? getOrCreateYcbcrConversionInfo(desc.format) : nullptr;

  image.imageView_ = image.createImageView(
      vkDevice_, vkImageViewType, vkFormat, aspect, 0, VK_REMAINING_MIP_LEVELS, 0, numLayers, components, ycbcrInfo, debugNameImageView);

  if (image.vkUsageFlags_ & VK_IMAGE_USAGE_STORAGE_BIT) {
    if (!desc.components.identity()) {
      // use identity swizzle for storage images
      image.imageViewStorage_ = image.createImageView(
          vkDevice_, vkImageViewType, vkFormat, aspect, 0, VK_REMAINING_MIP_LEVELS, 0, numLayers, {}, ycbcrInfo, debugNameImageView);
      LVK_ASSERT(image.imageViewStorage_ != VK_NULL_HANDLE);
    }
  }

  if (!LVK_VERIFY(image.imageView_ != VK_NULL_HANDLE)) {
    Result::setResult(outResult, Result::Code::RuntimeError, "Cannot create VkImageView");
    return {};
  }

  TextureHandle handle = texturesPool_.create(std::move(image));

  awaitingCreation_ = true;

  if (desc.data) {
    LVK_ASSERT(desc.type == TextureType_2D || desc.type == TextureType_Cube);
    LVK_ASSERT(desc.dataNumMipLevels <= desc.numMipLevels);
    const uint32_t numLayers = desc.type == TextureType_Cube ? 6 : 1;
    Result res = upload(handle, {.dimensions = desc.dimensions, .numLayers = numLayers, .numMipLevels = desc.dataNumMipLevels}, desc.data);
    if (!res.isOk()) {
      Result::setResult(outResult, res);
      return {};
    }
    if (desc.generateMipmaps) {
      this->generateMipmap(handle);
    }
  }

  Result::setResult(outResult, Result());

  return {this, handle};
}

lvk::Holder<lvk::TextureHandle> lvk::VulkanContext::createTextureView(lvk::TextureHandle texture,
                                                                      const TextureViewDesc& desc,
                                                                      const char* debugName,
                                                                      Result* outResult) {
  if (!texture) {
    LVK_ASSERT(texture.valid());
    return {};
  }

  // make a copy and make it non-owning
  VulkanImage image = *texturesPool_.get(texture);
  image.isOwningVkImage_ = false;

  // drop all existing image views - they belong to the base image
  memset(&image.imageViewStorage_, 0, sizeof(image.imageViewStorage_));
  memset(&image.imageViewForFramebuffer_, 0, sizeof(image.imageViewForFramebuffer_));
  memset(&image.imageViewForFramebufferMultiview_, 0, sizeof(image.imageViewForFramebufferMultiview_));

  VkImageAspectFlags aspect = 0;
  if (image.isDepthFormat_ || image.isStencilFormat_) {
    if (image.isDepthFormat_) {
      aspect |= VK_IMAGE_ASPECT_DEPTH_BIT;
    } else if (image.isStencilFormat_) {
      aspect |= VK_IMAGE_ASPECT_STENCIL_BIT;
    }
  } else {
    aspect = VK_IMAGE_ASPECT_COLOR_BIT;
  }

  VkImageViewType vkImageViewType = VK_IMAGE_VIEW_TYPE_MAX_ENUM;
  switch (desc.type) {
  case TextureType_2D:
    vkImageViewType = desc.numLayers > 1 ? VK_IMAGE_VIEW_TYPE_2D_ARRAY : VK_IMAGE_VIEW_TYPE_2D;
    break;
  case TextureType_3D:
    vkImageViewType = VK_IMAGE_VIEW_TYPE_3D;
    break;
  case TextureType_Cube:
    vkImageViewType = desc.numLayers > 1 ? VK_IMAGE_VIEW_TYPE_CUBE_ARRAY : VK_IMAGE_VIEW_TYPE_CUBE;
    break;
  default:
    LVK_ASSERT_MSG(false, "Code should NOT be reached");
    Result::setResult(outResult, Result::Code::RuntimeError, "Unsupported texture view type");
    return {};
  }

  const VkComponentMapping components = {
      .r = VkComponentSwizzle(desc.components.r),
      .g = VkComponentSwizzle(desc.components.g),
      .b = VkComponentSwizzle(desc.components.b),
      .a = VkComponentSwizzle(desc.components.a),
  };

  LVK_ASSERT_MSG(lvk::getNumImagePlanes(image.vkImageFormat_) == 1, "Unsupported multiplanar image");

  image.imageView_ = image.createImageView(vkDevice_,
                                           vkImageViewType,
                                           image.vkImageFormat_,
                                           aspect,
                                           desc.mipLevel,
                                           desc.numMipLevels,
                                           desc.layer,
                                           desc.numLayers,
                                           components,
                                           nullptr,
                                           debugName);

  if (!LVK_VERIFY(image.imageView_ != VK_NULL_HANDLE)) {
    Result::setResult(outResult, Result::Code::RuntimeError, "Cannot create VkImageView");
    return {};
  }

  if (image.vkUsageFlags_ & VK_IMAGE_USAGE_STORAGE_BIT) {
    if (!desc.components.identity()) {
      // use identity swizzle for storage images
      image.imageViewStorage_ = image.createImageView(vkDevice_,
                                                      vkImageViewType,
                                                      image.vkImageFormat_,
                                                      aspect,
                                                      desc.mipLevel,
                                                      desc.numMipLevels,
                                                      desc.layer,
                                                      desc.numLayers,
                                                      {},
                                                      nullptr,
                                                      debugName);
      LVK_ASSERT(image.imageViewStorage_ != VK_NULL_HANDLE);
    }
  }

  TextureHandle handle = texturesPool_.create(std::move(image));

  awaitingCreation_ = true;

  return {this, handle};
}

lvk::AccelStructHandle lvk::VulkanContext::createBLAS(const AccelStructDesc& desc, Result* outResult) {
  VkAccelerationStructureGeometryKHR accelerationStructureGeometry{};
  VkAccelerationStructureBuildSizesInfoKHR accelerationStructureBuildSizesInfo{};
  getBuildInfoBLAS(desc, accelerationStructureGeometry, accelerationStructureBuildSizesInfo);

  char debugNameBuffer[256] = {0};
  if (desc.debugName) {
    snprintf(debugNameBuffer, sizeof(debugNameBuffer) - 1, "Buffer: %s", desc.debugName);
  }
  lvk::AccelerationStructure accelStruct = {
      .buildRangeInfo =
          {
              .primitiveCount = desc.buildRange.primitiveCount,
              .primitiveOffset = desc.buildRange.primitiveOffset,
              .firstVertex = desc.buildRange.firstVertex,
              .transformOffset = desc.buildRange.transformOffset,
          },
      .buffer = createBuffer(
          {
              .usage = lvk::BufferUsageBits_AccelStructStorage,
              .storage = lvk::StorageType_Device,
              .size = accelerationStructureBuildSizesInfo.accelerationStructureSize,
              .debugName = debugNameBuffer,
          },
          nullptr,
          outResult),
  };
  const VkAccelerationStructureCreateInfoKHR ciAccelerationStructure = {
      .sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR,
      .buffer = getVkBuffer(this, accelStruct.buffer),
      .size = accelerationStructureBuildSizesInfo.accelerationStructureSize,
      .type = VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR,
  };
  VK_ASSERT(vkCreateAccelerationStructureKHR(vkDevice_, &ciAccelerationStructure, nullptr, &accelStruct.vkHandle));

  lvk::Holder<lvk::BufferHandle> scratchBuffer = createBuffer(
      {
          .usage = lvk::BufferUsageBits_Storage,
          .storage = lvk::StorageType_Device,
          .size = accelerationStructureBuildSizesInfo.buildScratchSize,
          .debugName = "Buffer: BLAS scratch",
      },
      nullptr,
      outResult);

  const VkAccelerationStructureBuildGeometryInfoKHR accelerationBuildGeometryInfo{
      .sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR,
      .type = VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR,
      .flags = buildFlagsToVkBuildAccelerationStructureFlags(desc.buildFlags),
      .mode = VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR,
      .dstAccelerationStructure = accelStruct.vkHandle,
      .geometryCount = 1,
      .pGeometries = &accelerationStructureGeometry,
      .scratchData = {.deviceAddress = getAlignedAddress(gpuAddress(scratchBuffer),
                                                         accelerationStructureProperties_.minAccelerationStructureScratchOffsetAlignment)},
  };

  const VkAccelerationStructureBuildRangeInfoKHR* accelerationBuildStructureRangeInfos[] = {&accelStruct.buildRangeInfo};

  lvk::ICommandBuffer& buffer = acquireCommandBuffer();
  vkCmdBuildAccelerationStructuresKHR(
      lvk::getVkCommandBuffer(buffer), 1, &accelerationBuildGeometryInfo, accelerationBuildStructureRangeInfos);
  wait(submit(buffer, {}));

  const VkAccelerationStructureDeviceAddressInfoKHR accelerationDeviceAddressInfo{
      .sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR,
      .accelerationStructure = accelStruct.vkHandle,
  };
  accelStruct.deviceAddress = vkGetAccelerationStructureDeviceAddressKHR(vkDevice_, &accelerationDeviceAddressInfo);

  return accelStructuresPool_.create(std::move(accelStruct));
}

lvk::AccelStructHandle lvk::VulkanContext::createTLAS(const AccelStructDesc& desc, Result* outResult) {
  VkAccelerationStructureGeometryKHR accelerationStructureGeometry{};
  VkAccelerationStructureBuildSizesInfoKHR accelerationStructureBuildSizesInfo{};
  getBuildInfoTLAS(desc, accelerationStructureGeometry, accelerationStructureBuildSizesInfo);

  char debugNameBuffer[256] = {0};
  if (desc.debugName) {
    snprintf(debugNameBuffer, sizeof(debugNameBuffer) - 1, "Buffer: %s", desc.debugName);
  }
  lvk::AccelerationStructure accelStruct = {
      .isTLAS = true,
      .buildRangeInfo =
          {
              .primitiveCount = desc.buildRange.primitiveCount,
              .primitiveOffset = desc.buildRange.primitiveOffset,
              .firstVertex = desc.buildRange.firstVertex,
              .transformOffset = desc.buildRange.transformOffset,
          },
      .buffer = createBuffer(
          {
              .usage = lvk::BufferUsageBits_AccelStructStorage,
              .storage = lvk::StorageType_Device,
              .size = accelerationStructureBuildSizesInfo.accelerationStructureSize,
              .debugName = debugNameBuffer,
          },
          nullptr,
          outResult),
  };

  const VkAccelerationStructureCreateInfoKHR ciAccelerationStructure = {
      .sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR,
      .buffer = getVkBuffer(this, accelStruct.buffer),
      .size = accelerationStructureBuildSizesInfo.accelerationStructureSize,
      .type = VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR,
  };
  vkCreateAccelerationStructureKHR(vkDevice_, &ciAccelerationStructure, nullptr, &accelStruct.vkHandle);

  lvk::Holder<lvk::BufferHandle> scratchBuffer = createBuffer(
      {
          .usage = lvk::BufferUsageBits_Storage,
          .storage = lvk::StorageType_Device,
          .size = accelerationStructureBuildSizesInfo.buildScratchSize,
          .debugName = "Buffer: TLAS scratch",
      },
      nullptr,
      outResult);

  const VkAccelerationStructureBuildGeometryInfoKHR accelerationBuildGeometryInfo = {
      .sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR,
      .type = VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR,
      .flags = buildFlagsToVkBuildAccelerationStructureFlags(desc.buildFlags),
      .mode = VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR,
      .dstAccelerationStructure = accelStruct.vkHandle,
      .geometryCount = 1,
      .pGeometries = &accelerationStructureGeometry,
      .scratchData = {.deviceAddress = getAlignedAddress(gpuAddress(scratchBuffer),
                                                         accelerationStructureProperties_.minAccelerationStructureScratchOffsetAlignment)},
  };
  if (desc.buildFlags & lvk::AccelStructBuildFlagBits_AllowUpdate) {
    // Store scratch buffer for future updates
    accelStruct.scratchBuffer = std::move(scratchBuffer);
  }

  const VkAccelerationStructureBuildRangeInfoKHR* accelerationBuildStructureRangeInfos[] = {&accelStruct.buildRangeInfo};

  lvk::ICommandBuffer& buffer = acquireCommandBuffer();
  vkCmdBuildAccelerationStructuresKHR(
      lvk::getVkCommandBuffer(buffer), 1, &accelerationBuildGeometryInfo, accelerationBuildStructureRangeInfos);
  wait(submit(buffer, {}));

  const VkAccelerationStructureDeviceAddressInfoKHR accelerationDeviceAddressInfo = {
      .sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR,
      .accelerationStructure = accelStruct.vkHandle,
  };
  accelStruct.deviceAddress = vkGetAccelerationStructureDeviceAddressKHR(vkDevice_, &accelerationDeviceAddressInfo);

  return accelStructuresPool_.create(std::move(accelStruct));
}

static_assert(1 << (sizeof(lvk::Format) * 8) <= LVK_ARRAY_NUM_ELEMENTS(lvk::VulkanContextImpl::ycbcrConversionData_),
              "There aren't enough elements in `ycbcrConversionData_` to be accessed by lvk::Format");

VkSampler lvk::VulkanContext::getOrCreateYcbcrSampler(lvk::Format format) {
  const VkSamplerYcbcrConversionInfo* info = getOrCreateYcbcrConversionInfo(format);

  if (!info) {
    return VK_NULL_HANDLE;
  }

  return *samplersPool_.get(pimpl_->ycbcrConversionData_[format].sampler);
}

const VkSamplerYcbcrConversionInfo* lvk::VulkanContext::getOrCreateYcbcrConversionInfo(lvk::Format format) {
  if (pimpl_->ycbcrConversionData_[format].info.sType) {
    return &pimpl_->ycbcrConversionData_[format].info;
  }

  if (!LVK_VERIFY(vkFeatures11_.samplerYcbcrConversion)) {
    LVK_ASSERT_MSG(false, "Ycbcr samplers are not supported");
    return nullptr;
  }

  const VkFormat vkFormat = lvk::formatToVkFormat(format);

  VkFormatProperties2 props = {
      .sType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2,
  };
  vkGetPhysicalDeviceFormatProperties2(getVkPhysicalDevice(), vkFormat, &props);

  const bool cosited = (props.formatProperties.optimalTilingFeatures & VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT) != 0;
  const bool midpoint = (props.formatProperties.optimalTilingFeatures & VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT) != 0;

  if (!LVK_VERIFY(cosited || midpoint)) {
    LVK_ASSERT_MSG(cosited || midpoint, "Unsupported Ycbcr feature");
    return nullptr;
  }

  const VkSamplerYcbcrConversionCreateInfo ci = {
      .sType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO,
      .format = vkFormat,
      .ycbcrModel = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709,
      .ycbcrRange = VK_SAMPLER_YCBCR_RANGE_ITU_FULL,
      .components = {VK_COMPONENT_SWIZZLE_IDENTITY,
                     VK_COMPONENT_SWIZZLE_IDENTITY,
                     VK_COMPONENT_SWIZZLE_IDENTITY,
                     VK_COMPONENT_SWIZZLE_IDENTITY},
      .xChromaOffset = midpoint ? VK_CHROMA_LOCATION_MIDPOINT : VK_CHROMA_LOCATION_COSITED_EVEN,
      .yChromaOffset = midpoint ? VK_CHROMA_LOCATION_MIDPOINT : VK_CHROMA_LOCATION_COSITED_EVEN,
      .chromaFilter = VK_FILTER_LINEAR,
      .forceExplicitReconstruction = VK_FALSE,
  };

  VkSamplerYcbcrConversionInfo info = {
      .sType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO,
      .pNext = nullptr,
  };
  vkCreateSamplerYcbcrConversion(vkDevice_, &ci, nullptr, &info.conversion);

  // check properties
  VkSamplerYcbcrConversionImageFormatProperties samplerYcbcrConversionImageFormatProps = {
      .sType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES,
  };
  VkImageFormatProperties2 imageFormatProps = {
      .sType = VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2,
      .pNext = &samplerYcbcrConversionImageFormatProps,
  };
  const VkPhysicalDeviceImageFormatInfo2 imageFormatInfo = {
      .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2,
      .format = vkFormat,
      .type = VK_IMAGE_TYPE_2D,
      .tiling = VK_IMAGE_TILING_OPTIMAL,
      .usage = VK_IMAGE_USAGE_SAMPLED_BIT,
      .flags = VK_IMAGE_CREATE_DISJOINT_BIT,
  };
  vkGetPhysicalDeviceImageFormatProperties2(getVkPhysicalDevice(), &imageFormatInfo, &imageFormatProps);

  LVK_ASSERT(samplerYcbcrConversionImageFormatProps.combinedImageSamplerDescriptorCount <= 3);

  // update maximum
  pimpl_->maxCombinedImageSamplerDescriptorCount_ =
      std::max(pimpl_->maxCombinedImageSamplerDescriptorCount_, samplerYcbcrConversionImageFormatProps.combinedImageSamplerDescriptorCount);

  const VkSamplerCreateInfo cinfo = samplerStateDescToVkSamplerCreateInfo({}, getVkPhysicalDeviceProperties().limits);

  pimpl_->ycbcrConversionData_[format].info = info;
  pimpl_->ycbcrConversionData_[format].sampler = {this, this->createSampler(cinfo, nullptr, format, "YUV sampler")};
  pimpl_->numYcbcrSamplers_++;
  awaitingNewImmutableSamplers_ = true;

  return &pimpl_->ycbcrConversionData_[format].info;
}

VkPipeline lvk::VulkanContext::getVkPipeline(RenderPipelineHandle handle, uint32_t viewMask) {
  lvk::RenderPipelineState* rps = renderPipelinesPool_.get(handle);

  if (!rps) {
    return VK_NULL_HANDLE;
  }

  checkAndUpdateDescriptorSets();

  const DescriptorSet& dset = DSets_[lastUpdatedDSet_];

  if (rps->lastVkDescriptorSetLayout_ != dset.vkDSL || rps->viewMask_ != viewMask) {
    deferredTask(std::packaged_task<void()>(
        [device = getVkDevice(), pipeline = rps->pipeline_]() { vkDestroyPipeline(device, pipeline, nullptr); }));
    deferredTask(std::packaged_task<void()>(
        [device = getVkDevice(), layout = rps->pipelineLayout_]() { vkDestroyPipelineLayout(device, layout, nullptr); }));
    rps->pipeline_ = VK_NULL_HANDLE;
    rps->lastVkDescriptorSetLayout_ = dset.vkDSL;
    rps->viewMask_ = viewMask;
  }

  if (rps->pipeline_ != VK_NULL_HANDLE) {
    return rps->pipeline_;
  }

  // build a new Vulkan pipeline

  VkPipelineLayout layout = VK_NULL_HANDLE;
  VkPipeline pipeline = VK_NULL_HANDLE;

  const RenderPipelineDesc& desc = rps->desc_;

  const uint32_t numColorAttachments = rps->desc_.getNumColorAttachments();

  // Not all attachments are valid. We need to create color blend attachments only for active attachments
  VkPipelineColorBlendAttachmentState colorBlendAttachmentStates[LVK_MAX_COLOR_ATTACHMENTS] = {};
  VkFormat colorAttachmentFormats[LVK_MAX_COLOR_ATTACHMENTS] = {};

  for (uint32_t i = 0; i != numColorAttachments; i++) {
    const lvk::ColorAttachment& attachment = desc.color[i];
    LVK_ASSERT(attachment.format != Format_Invalid);
    colorAttachmentFormats[i] = formatToVkFormat(attachment.format);
    if (!attachment.blendEnabled) {
      colorBlendAttachmentStates[i] = VkPipelineColorBlendAttachmentState{
          .blendEnable = VK_FALSE,
          .srcColorBlendFactor = VK_BLEND_FACTOR_ONE,
          .dstColorBlendFactor = VK_BLEND_FACTOR_ZERO,
          .colorBlendOp = VK_BLEND_OP_ADD,
          .srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE,
          .dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO,
          .alphaBlendOp = VK_BLEND_OP_ADD,
          .colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT,
      };
    } else {
      colorBlendAttachmentStates[i] = VkPipelineColorBlendAttachmentState{
          .blendEnable = VK_TRUE,
          .srcColorBlendFactor = blendFactorToVkBlendFactor(attachment.srcRGBBlendFactor),
          .dstColorBlendFactor = blendFactorToVkBlendFactor(attachment.dstRGBBlendFactor),
          .colorBlendOp = blendOpToVkBlendOp(attachment.rgbBlendOp),
          .srcAlphaBlendFactor = blendFactorToVkBlendFactor(attachment.srcAlphaBlendFactor),
          .dstAlphaBlendFactor = blendFactorToVkBlendFactor(attachment.dstAlphaBlendFactor),
          .alphaBlendOp = blendOpToVkBlendOp(attachment.alphaBlendOp),
          .colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT,
      };
    }
  }

  const lvk::ShaderModuleState* vertModule = shaderModulesPool_.get(desc.smVert);
  const lvk::ShaderModuleState* tescModule = shaderModulesPool_.get(desc.smTesc);
  const lvk::ShaderModuleState* teseModule = shaderModulesPool_.get(desc.smTese);
  const lvk::ShaderModuleState* geomModule = shaderModulesPool_.get(desc.smGeom);
  const lvk::ShaderModuleState* fragModule = shaderModulesPool_.get(desc.smFrag);
  const lvk::ShaderModuleState* taskModule = shaderModulesPool_.get(desc.smTask);
  const lvk::ShaderModuleState* meshModule = shaderModulesPool_.get(desc.smMesh);

  LVK_ASSERT(vertModule || meshModule);
  LVK_ASSERT(fragModule);

  if (tescModule || teseModule || desc.patchControlPoints) {
    LVK_ASSERT_MSG(tescModule && teseModule, "Both tessellation control and evaluation shaders should be provided");
    LVK_ASSERT(desc.patchControlPoints > 0 &&
               desc.patchControlPoints <= vkPhysicalDeviceProperties2_.properties.limits.maxTessellationPatchSize);
  }

  const VkPipelineVertexInputStateCreateInfo ciVertexInputState = {
      .sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,
      .vertexBindingDescriptionCount = rps->numBindings_,
      .pVertexBindingDescriptions = rps->numBindings_ ? rps->vkBindings_ : nullptr,
      .vertexAttributeDescriptionCount = rps->numAttributes_,
      .pVertexAttributeDescriptions = rps->numAttributes_ ? rps->vkAttributes_ : nullptr,
  };

  VkSpecializationMapEntry entries[SpecializationConstantDesc::LVK_SPECIALIZATION_CONSTANTS_MAX] = {};

  const VkSpecializationInfo si = lvk::getPipelineShaderStageSpecializationInfo(desc.specInfo, entries);

  // create pipeline layout
  {
#define UPDATE_PUSH_CONSTANT_SIZE(sm, bit)                                  \
  if (sm) {                                                                 \
    pushConstantsSize = std::max(pushConstantsSize, sm->pushConstantsSize); \
    rps->shaderStageFlags_ |= bit;                                          \
  }
    rps->shaderStageFlags_ = 0;
    uint32_t pushConstantsSize = 0;
    UPDATE_PUSH_CONSTANT_SIZE(vertModule, VK_SHADER_STAGE_VERTEX_BIT);
    UPDATE_PUSH_CONSTANT_SIZE(tescModule, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT);
    UPDATE_PUSH_CONSTANT_SIZE(teseModule, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT);
    UPDATE_PUSH_CONSTANT_SIZE(geomModule, VK_SHADER_STAGE_GEOMETRY_BIT);
    UPDATE_PUSH_CONSTANT_SIZE(fragModule, VK_SHADER_STAGE_FRAGMENT_BIT);
    UPDATE_PUSH_CONSTANT_SIZE(taskModule, VK_SHADER_STAGE_TASK_BIT_EXT);
    UPDATE_PUSH_CONSTANT_SIZE(meshModule, VK_SHADER_STAGE_MESH_BIT_EXT);
#undef UPDATE_PUSH_CONSTANT_SIZE

    // maxPushConstantsSize is guaranteed to be at least 128 bytes
    // https://www.khronos.org/registry/vulkan/specs/1.3/html/vkspec.html#features-limits
    // Table 32. Required Limits
    const VkPhysicalDeviceLimits& limits = getVkPhysicalDeviceProperties().limits;
    if (!LVK_VERIFY(pushConstantsSize <= limits.maxPushConstantsSize)) {
      LLOGW("Push constants size exceeded %u (max %u bytes)", pushConstantsSize, limits.maxPushConstantsSize);
    }

    // duplicate for MoltenVK
    const VkDescriptorSetLayout dsls[kDescriptorSet_InputAttachments + 1] = {
        dset.vkDSL,
        dset.vkDSL,
        dset.vkDSL,
        dset.vkDSL,
        dslInputAttachments_,
    };
    const VkPushConstantRange range = {
        .stageFlags = rps->shaderStageFlags_,
        .offset = 0,
        .size = (uint32_t)getAlignedSize(pushConstantsSize, 16),
    };
    const VkPipelineLayoutCreateInfo ci = {
        .sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
        .setLayoutCount = (uint32_t)LVK_ARRAY_NUM_ELEMENTS(dsls),
        .pSetLayouts = dsls,
        .pushConstantRangeCount = pushConstantsSize ? 1u : 0u,
        .pPushConstantRanges = pushConstantsSize ? &range : nullptr,
    };
    VK_ASSERT(vkCreatePipelineLayout(vkDevice_, &ci, nullptr, &layout));
    char pipelineLayoutName[256] = {0};
    if (rps->desc_.debugName) {
      snprintf(pipelineLayoutName, sizeof(pipelineLayoutName) - 1, "Pipeline Layout: %s", rps->desc_.debugName);
    }
    VK_ASSERT(lvk::setDebugObjectName(vkDevice_, VK_OBJECT_TYPE_PIPELINE_LAYOUT, (uint64_t)layout, pipelineLayoutName));
  }

  lvk::VulkanPipelineBuilder()
      // from Vulkan 1.0
      .dynamicState(VK_DYNAMIC_STATE_VIEWPORT)
      .dynamicState(VK_DYNAMIC_STATE_SCISSOR)
      .dynamicState(VK_DYNAMIC_STATE_DEPTH_BIAS)
      .dynamicState(VK_DYNAMIC_STATE_BLEND_CONSTANTS)
      // from Vulkan 1.3 or VK_EXT_extended_dynamic_state
      .dynamicState(VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE)
      .dynamicState(VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE)
      .dynamicState(VK_DYNAMIC_STATE_DEPTH_COMPARE_OP)
      // from Vulkan 1.3 or VK_EXT_extended_dynamic_state2
      .dynamicState(VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE)
      .primitiveTopology(topologyToVkPrimitiveTopology(desc.topology))
      .rasterizationSamples(getVulkanSampleCountFlags(desc.samplesCount, getFramebufferMSAABitMask()), desc.minSampleShading)
      .polygonMode(polygonModeToVkPolygonMode(desc.polygonMode))
      .stencilStateOps(VK_STENCIL_FACE_FRONT_BIT,
                       stencilOpToVkStencilOp(desc.frontFaceStencil.stencilFailureOp),
                       stencilOpToVkStencilOp(desc.frontFaceStencil.depthStencilPassOp),
                       stencilOpToVkStencilOp(desc.frontFaceStencil.depthFailureOp),
                       compareOpToVkCompareOp(desc.frontFaceStencil.stencilCompareOp))
      .stencilStateOps(VK_STENCIL_FACE_BACK_BIT,
                       stencilOpToVkStencilOp(desc.backFaceStencil.stencilFailureOp),
                       stencilOpToVkStencilOp(desc.backFaceStencil.depthStencilPassOp),
                       stencilOpToVkStencilOp(desc.backFaceStencil.depthFailureOp),
                       compareOpToVkCompareOp(desc.backFaceStencil.stencilCompareOp))
      .stencilMasks(VK_STENCIL_FACE_FRONT_BIT, 0xFF, desc.frontFaceStencil.writeMask, desc.frontFaceStencil.readMask)
      .stencilMasks(VK_STENCIL_FACE_BACK_BIT, 0xFF, desc.backFaceStencil.writeMask, desc.backFaceStencil.readMask)
      .shaderStage(taskModule
                       ? lvk::getPipelineShaderStageCreateInfo(VK_SHADER_STAGE_TASK_BIT_EXT, taskModule->ci, desc.entryPointTask, &si)
                       : VkPipelineShaderStageCreateInfo{.module = VK_NULL_HANDLE})
      .shaderStage(meshModule
                       ? lvk::getPipelineShaderStageCreateInfo(VK_SHADER_STAGE_MESH_BIT_EXT, meshModule->ci, desc.entryPointMesh, &si)
                       : lvk::getPipelineShaderStageCreateInfo(VK_SHADER_STAGE_VERTEX_BIT, vertModule->ci, desc.entryPointVert, &si))
      .shaderStage(lvk::getPipelineShaderStageCreateInfo(VK_SHADER_STAGE_FRAGMENT_BIT, fragModule->ci, desc.entryPointFrag, &si))
      .shaderStage(tescModule ? lvk::getPipelineShaderStageCreateInfo(
                                    VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, tescModule->ci, desc.entryPointTesc, &si)
                              : VkPipelineShaderStageCreateInfo{.module = VK_NULL_HANDLE})
      .shaderStage(teseModule ? lvk::getPipelineShaderStageCreateInfo(
                                    VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, teseModule->ci, desc.entryPointTese, &si)
                              : VkPipelineShaderStageCreateInfo{.module = VK_NULL_HANDLE})
      .shaderStage(geomModule
                       ? lvk::getPipelineShaderStageCreateInfo(VK_SHADER_STAGE_GEOMETRY_BIT, geomModule->ci, desc.entryPointGeom, &si)
                       : VkPipelineShaderStageCreateInfo{.module = VK_NULL_HANDLE})
      .cullMode(cullModeToVkCullMode(desc.cullMode))
      .frontFace(windingModeToVkFrontFace(desc.frontFace))
      .vertexInputState(ciVertexInputState)
      .viewMask(viewMask)
      .colorAttachments(colorBlendAttachmentStates, colorAttachmentFormats, numColorAttachments)
      .depthAttachmentFormat(formatToVkFormat(desc.depthFormat))
      .stencilAttachmentFormat(formatToVkFormat(desc.stencilFormat))
      .patchControlPoints(desc.patchControlPoints)
      .build(vkDevice_, pipelineCache_, layout, &pipeline, desc.debugName);

  rps->pipeline_ = pipeline;
  rps->pipelineLayout_ = layout;

  return pipeline;
}

VkPipeline lvk::VulkanContext::getVkPipeline(RayTracingPipelineHandle handle) {
  lvk::RayTracingPipelineState* rtps = rayTracingPipelinesPool_.get(handle);

  if (!rtps) {
    return VK_NULL_HANDLE;
  }

  checkAndUpdateDescriptorSets();

  const DescriptorSet& dset = DSets_[lastUpdatedDSet_];

  if (rtps->lastVkDescriptorSetLayout_ != dset.vkDSL) {
    deferredTask(
        std::packaged_task<void()>([device = vkDevice_, pipeline = rtps->pipeline_]() { vkDestroyPipeline(device, pipeline, nullptr); }));
    deferredTask(std::packaged_task<void()>(
        [device = vkDevice_, layout = rtps->pipelineLayout_]() { vkDestroyPipelineLayout(device, layout, nullptr); }));
    rtps->pipeline_ = VK_NULL_HANDLE;
    rtps->pipelineLayout_ = VK_NULL_HANDLE;
    rtps->lastVkDescriptorSetLayout_ = dset.vkDSL;
  }

  if (rtps->pipeline_) {
    return rtps->pipeline_;
  }

  // build a new Vulkan ray tracing pipeline
  const RayTracingPipelineDesc& desc = rtps->desc_;

  using RayTracingPipelineDesc::LVK_MAX_RAY_TRACING_SHADERS;
  using RayTracingPipelineDesc::LVK_MAX_RAY_TRACING_HIT_GROUPS;

  const lvk::ShaderModuleState* moduleRGen[LVK_MAX_RAY_TRACING_SHADERS] = {};
  const lvk::ShaderModuleState* moduleMiss[LVK_MAX_RAY_TRACING_SHADERS] = {};
  const lvk::ShaderModuleState* moduleCall[LVK_MAX_RAY_TRACING_SHADERS] = {};
  const lvk::ShaderModuleState* moduleAHit[LVK_MAX_RAY_TRACING_HIT_GROUPS] = {};
  const lvk::ShaderModuleState* moduleCHit[LVK_MAX_RAY_TRACING_HIT_GROUPS] = {};
  const lvk::ShaderModuleState* moduleIntr[LVK_MAX_RAY_TRACING_HIT_GROUPS] = {};
  for (int i = 0; i < LVK_MAX_RAY_TRACING_SHADERS; ++i) {
    if (desc.smRayGen[i])
      moduleRGen[i] = shaderModulesPool_.get(desc.smRayGen[i]);
    if (desc.smMiss[i])
      moduleMiss[i] = shaderModulesPool_.get(desc.smMiss[i]);
    if (desc.smCallable[i])
      moduleCall[i] = shaderModulesPool_.get(desc.smCallable[i]);
  }
  for (int i = 0; i < LVK_ARRAY_NUM_ELEMENTS(desc.hitGroups); ++i) {
    if (desc.hitGroups[i].smAnyHit)
      moduleAHit[i] = shaderModulesPool_.get(desc.hitGroups[i].smAnyHit);
    if (desc.hitGroups[i].smClosestHit)
      moduleCHit[i] = shaderModulesPool_.get(desc.hitGroups[i].smClosestHit);
    if (desc.hitGroups[i].smIntersection)
      moduleIntr[i] = shaderModulesPool_.get(desc.hitGroups[i].smIntersection);
  }

  LVK_ASSERT(moduleRGen);

  // create pipeline layout
  {
#define UPDATE_PUSH_CONSTANT_SIZE(sm, bit)                                       \
  for (int i = 0; i < LVK_ARRAY_NUM_ELEMENTS(sm); ++i) {                         \
    if (sm[i] && sm[i]->pushConstantsSize) {                                     \
      pushConstantsSize = std::max(pushConstantsSize, sm[i]->pushConstantsSize); \
      rtps->shaderStageFlags_ |= bit;                                            \
    }                                                                            \
  }
    rtps->shaderStageFlags_ = 0;
    uint32_t pushConstantsSize = 0;
    UPDATE_PUSH_CONSTANT_SIZE(moduleRGen, VK_SHADER_STAGE_RAYGEN_BIT_KHR);
    UPDATE_PUSH_CONSTANT_SIZE(moduleAHit, VK_SHADER_STAGE_ANY_HIT_BIT_KHR);
    UPDATE_PUSH_CONSTANT_SIZE(moduleCHit, VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR);
    UPDATE_PUSH_CONSTANT_SIZE(moduleMiss, VK_SHADER_STAGE_MISS_BIT_KHR);
    UPDATE_PUSH_CONSTANT_SIZE(moduleIntr, VK_SHADER_STAGE_INTERSECTION_BIT_KHR);
    UPDATE_PUSH_CONSTANT_SIZE(moduleCall, VK_SHADER_STAGE_CALLABLE_BIT_KHR);
#undef UPDATE_PUSH_CONSTANT_SIZE

    // maxPushConstantsSize is guaranteed to be at least 128 bytes
    // https://www.khronos.org/registry/vulkan/specs/1.3/html/vkspec.html#features-limits
    // Table 32. Required Limits
    const VkPhysicalDeviceLimits& limits = getVkPhysicalDeviceProperties().limits;
    if (!LVK_VERIFY(pushConstantsSize <= limits.maxPushConstantsSize)) {
      LLOGW("Push constants size exceeded %u (max %u bytes)", pushConstantsSize, limits.maxPushConstantsSize);
    }

    const VkDescriptorSetLayout dsls[] = {dset.vkDSL, dset.vkDSL, dset.vkDSL, dset.vkDSL};
    const VkPushConstantRange range = {
        .stageFlags = rtps->shaderStageFlags_,
        .size = (uint32_t)getAlignedSize(pushConstantsSize, 16),
    };

    const VkPipelineLayoutCreateInfo ciPipelineLayout = {
        .sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
        .setLayoutCount = LVK_ARRAY_NUM_ELEMENTS(dsls),
        .pSetLayouts = dsls,
        .pushConstantRangeCount = 1,
        .pPushConstantRanges = &range,
    };
    VK_ASSERT(vkCreatePipelineLayout(vkDevice_, &ciPipelineLayout, nullptr, &rtps->pipelineLayout_));
    char pipelineLayoutName[256] = {0};
    if (rtps->desc_.debugName) {
      snprintf(pipelineLayoutName, sizeof(pipelineLayoutName) - 1, "Pipeline Layout: %s", rtps->desc_.debugName);
    }
    VK_ASSERT(lvk::setDebugObjectName(vkDevice_, VK_OBJECT_TYPE_PIPELINE_LAYOUT, (uint64_t)rtps->pipelineLayout_, pipelineLayoutName));
  }

  VkSpecializationMapEntry entries[SpecializationConstantDesc::LVK_SPECIALIZATION_CONSTANTS_MAX] = {};

  const VkSpecializationInfo siComp = lvk::getPipelineShaderStageSpecializationInfo(rtps->desc_.specInfo, entries);

  const uint32_t kMaxRayTracingShaderStages = 6 * LVK_MAX_RAY_TRACING_HIT_GROUPS;
  VkPipelineShaderStageCreateInfo ciShaderStages[kMaxRayTracingShaderStages];
  uint32_t numShaderStages = 0;

  // append a shader stage entry and return its index into ciShaderStages[]
  auto addStage = [&](VkShaderStageFlagBits flag, const VkShaderModuleCreateInfo& ci) -> uint32_t {
    ciShaderStages[numShaderStages] = lvk::getPipelineShaderStageCreateInfo(flag, ci, "main", &siComp);
    return numShaderStages++;
  };

  // raygen + miss + hit + callable, each up to LVK_MAX_RAY_TRACING_HIT_GROUPS
  const uint32_t kMaxShaderGroups = 4 * LVK_MAX_RAY_TRACING_HIT_GROUPS;
  VkRayTracingShaderGroupCreateInfoKHR shaderGroups[kMaxShaderGroups];
  uint32_t numShaderGroups = 0;
  uint32_t idxMiss = 0;
  uint32_t numMissGroups = 0;
  uint32_t idxHit = 0;
  uint32_t numHitGroups = 0;
  uint32_t idxCallable = 0;
  uint32_t numCallableGroups = 0;

  // ray generation groups
  for (int i = 0; i < LVK_ARRAY_NUM_ELEMENTS(moduleRGen); ++i) {
    if (moduleRGen[i]) {
      shaderGroups[numShaderGroups++] = VkRayTracingShaderGroupCreateInfoKHR{
          .sType = VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR,
          .type = VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR,
          .generalShader = addStage(VK_SHADER_STAGE_RAYGEN_BIT_KHR, moduleRGen[i]->ci),
          .closestHitShader = VK_SHADER_UNUSED_KHR,
          .anyHitShader = VK_SHADER_UNUSED_KHR,
          .intersectionShader = VK_SHADER_UNUSED_KHR,
      };
    }
  }
  // miss groups
  for (int i = 0; i < LVK_ARRAY_NUM_ELEMENTS(moduleMiss); ++i) {
    if (moduleMiss[i]) {
      if (!numMissGroups)
        idxMiss = numShaderGroups;
      numMissGroups++;
      shaderGroups[numShaderGroups++] = VkRayTracingShaderGroupCreateInfoKHR{
          .sType = VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR,
          .type = VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR,
          .generalShader = addStage(VK_SHADER_STAGE_MISS_BIT_KHR, moduleMiss[i]->ci),
          .closestHitShader = VK_SHADER_UNUSED_KHR,
          .anyHitShader = VK_SHADER_UNUSED_KHR,
          .intersectionShader = VK_SHADER_UNUSED_KHR,
      };
    }
  }
  // hit groups: add chit/ahit/intr stages per-group so indices are correct for each pairing
  for (int i = 0; i < LVK_MAX_RAY_TRACING_HIT_GROUPS; ++i) {
    if (moduleAHit[i] || moduleCHit[i] || moduleIntr[i]) {
      if (!numHitGroups)
        idxHit = numShaderGroups;
      numHitGroups++;
      shaderGroups[numShaderGroups++] = VkRayTracingShaderGroupCreateInfoKHR{
          .sType = VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR,
          .type = VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR,
          .generalShader = VK_SHADER_UNUSED_KHR,
          .closestHitShader = moduleCHit[i] ? addStage(VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR, moduleCHit[i]->ci) : VK_SHADER_UNUSED_KHR,
          .anyHitShader = moduleAHit[i] ? addStage(VK_SHADER_STAGE_ANY_HIT_BIT_KHR, moduleAHit[i]->ci) : VK_SHADER_UNUSED_KHR,
          .intersectionShader = moduleIntr[i] ? addStage(VK_SHADER_STAGE_INTERSECTION_BIT_KHR, moduleIntr[i]->ci) : VK_SHADER_UNUSED_KHR,
      };
    }
  }
  // callable groups
  for (int i = 0; i < LVK_ARRAY_NUM_ELEMENTS(moduleCall); ++i) {
    if (moduleCall[i]) {
      if (!numCallableGroups)
        idxCallable = numShaderGroups;
      numCallableGroups++;
      shaderGroups[numShaderGroups++] = VkRayTracingShaderGroupCreateInfoKHR{
          .sType = VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR,
          .type = VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR,
          .generalShader = addStage(VK_SHADER_STAGE_CALLABLE_BIT_KHR, moduleCall[i]->ci),
          .closestHitShader = VK_SHADER_UNUSED_KHR,
          .anyHitShader = VK_SHADER_UNUSED_KHR,
          .intersectionShader = VK_SHADER_UNUSED_KHR,
      };
    }
  }

  const VkRayTracingPipelineCreateInfoKHR ciRayTracingPipeline = {
      .sType = VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR,
      .stageCount = numShaderStages,
      .pStages = ciShaderStages,
      .groupCount = numShaderGroups,
      .pGroups = shaderGroups,
      .maxPipelineRayRecursionDepth = rayTracingPipelineProperties_.maxRayRecursionDepth,
      .layout = rtps->pipelineLayout_,
  };
  VK_ASSERT(vkCreateRayTracingPipelinesKHR(vkDevice_, VK_NULL_HANDLE, VK_NULL_HANDLE, 1, &ciRayTracingPipeline, nullptr, &rtps->pipeline_));

  // shader binding table
  const VkPhysicalDeviceRayTracingPipelinePropertiesKHR& props = rayTracingPipelineProperties_;
  const uint32_t handleSize = props.shaderGroupHandleSize;
  const uint32_t handleSizeAligned = getAlignedSize(props.shaderGroupHandleSize, props.shaderGroupHandleAlignment);
  const uint32_t sbtSize = numShaderGroups * handleSizeAligned;

  LVK_ASSERT(sbtSize);

  std::vector<uint8_t> shaderHandleStorage(sbtSize);
  VK_ASSERT(vkGetRayTracingShaderGroupHandlesKHR(vkDevice_, rtps->pipeline_, 0, numShaderGroups, sbtSize, shaderHandleStorage.data()));

  const uint32_t sbtEntrySizeAligned = getAlignedSize(handleSizeAligned, props.shaderGroupBaseAlignment);
  const uint32_t sbtBufferSize = numShaderGroups * sbtEntrySizeAligned;

  // repack SBT respecting `shaderGroupBaseAlignment`
  std::vector<uint8_t> sbtStorage(sbtBufferSize);
  for (uint32_t i = 0; i != numShaderGroups; i++) {
    memcpy(sbtStorage.data() + i * sbtEntrySizeAligned, shaderHandleStorage.data() + i * handleSizeAligned, handleSize);
  }

  rtps->sbt = createBuffer(
      {
          .usage = lvk::BufferUsageBits_ShaderBindingTable,
          .storage = lvk::StorageType_Device,
          .size = sbtBufferSize + props.shaderGroupBaseAlignment,
          .debugName = "Buffer: SBT",
      },
      nullptr,
      nullptr);
  const uint64_t baseAddress = getAlignedAddress(gpuAddress(rtps->sbt), props.shaderGroupBaseAlignment);
  const uint64_t offset = baseAddress - gpuAddress(rtps->sbt);
  upload(rtps->sbt, sbtStorage.data(), sbtBufferSize, offset);
  // generate SBT entries; stride must be sbtEntrySizeAligned (respects shaderGroupBaseAlignment),
  // and size must cover all records in each group so the hardware can index into them correctly
  rtps->sbtEntryRayGen = {
      .deviceAddress = baseAddress,
      .stride = sbtEntrySizeAligned,
      .size = sbtEntrySizeAligned, // ray gen: size == stride (exactly one record used at a time)
  };
  rtps->sbtEntryMiss = {
      .deviceAddress = numMissGroups ? baseAddress + idxMiss * sbtEntrySizeAligned : 0,
      .stride = sbtEntrySizeAligned,
      .size = numMissGroups * sbtEntrySizeAligned,
  };
  rtps->sbtEntryHit = {
      .deviceAddress = numHitGroups ? baseAddress + idxHit * sbtEntrySizeAligned : 0,
      .stride = sbtEntrySizeAligned,
      .size = numHitGroups * sbtEntrySizeAligned,
  };
  rtps->sbtEntryCallable = {
      .deviceAddress = numCallableGroups ? baseAddress + idxCallable * sbtEntrySizeAligned : 0,
      .stride = sbtEntrySizeAligned,
      .size = numCallableGroups * sbtEntrySizeAligned,
  };

  return rtps->pipeline_;
}

VkPipeline lvk::VulkanContext::getVkPipeline(ComputePipelineHandle handle) {
  lvk::ComputePipelineState* cps = computePipelinesPool_.get(handle);

  if (!cps) {
    return VK_NULL_HANDLE;
  }

  checkAndUpdateDescriptorSets();

  const DescriptorSet& dset = DSets_[lastUpdatedDSet_];

  if (cps->lastVkDescriptorSetLayout_ != dset.vkDSL) {
    deferredTask(
        std::packaged_task<void()>([device = vkDevice_, pipeline = cps->pipeline_]() { vkDestroyPipeline(device, pipeline, nullptr); }));
    deferredTask(std::packaged_task<void()>(
        [device = vkDevice_, layout = cps->pipelineLayout_]() { vkDestroyPipelineLayout(device, layout, nullptr); }));
    cps->pipeline_ = VK_NULL_HANDLE;
    cps->pipelineLayout_ = VK_NULL_HANDLE;
    cps->lastVkDescriptorSetLayout_ = dset.vkDSL;
  }

  if (cps->pipeline_ == VK_NULL_HANDLE) {
    const lvk::ShaderModuleState* sm = shaderModulesPool_.get(cps->desc_.smComp);

    LVK_ASSERT(sm);

    VkSpecializationMapEntry entries[SpecializationConstantDesc::LVK_SPECIALIZATION_CONSTANTS_MAX] = {};

    const VkSpecializationInfo siComp = lvk::getPipelineShaderStageSpecializationInfo(cps->desc_.specInfo, entries);

    // create pipeline layout
    {
      // duplicate for MoltenVK
      const VkDescriptorSetLayout dsls[] = {dset.vkDSL, dset.vkDSL, dset.vkDSL, dset.vkDSL};
      const VkPushConstantRange range = {
          .stageFlags = VK_SHADER_STAGE_COMPUTE_BIT,
          .offset = 0,
          .size = (uint32_t)getAlignedSize(sm->pushConstantsSize, 16),
      };
      const VkPipelineLayoutCreateInfo ci = {
          .sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
          .setLayoutCount = (uint32_t)LVK_ARRAY_NUM_ELEMENTS(dsls),
          .pSetLayouts = dsls,
          .pushConstantRangeCount = 1,
          .pPushConstantRanges = &range,
      };
      VK_ASSERT(vkCreatePipelineLayout(vkDevice_, &ci, nullptr, &cps->pipelineLayout_));
      char pipelineLayoutName[256] = {0};
      if (cps->desc_.debugName) {
        snprintf(pipelineLayoutName, sizeof(pipelineLayoutName) - 1, "Pipeline Layout: %s", cps->desc_.debugName);
      }
      VK_ASSERT(lvk::setDebugObjectName(vkDevice_, VK_OBJECT_TYPE_PIPELINE_LAYOUT, (uint64_t)cps->pipelineLayout_, pipelineLayoutName));
    }

    const VkComputePipelineCreateInfo ci = {
        .sType = VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO,
        .flags = 0,
        .stage = lvk::getPipelineShaderStageCreateInfo(VK_SHADER_STAGE_COMPUTE_BIT, sm->ci, cps->desc_.entryPoint, &siComp),
        .layout = cps->pipelineLayout_,
        .basePipelineHandle = VK_NULL_HANDLE,
        .basePipelineIndex = -1,
    };
    VK_ASSERT(vkCreateComputePipelines(vkDevice_, pipelineCache_, 1, &ci, nullptr, &cps->pipeline_));
    VK_ASSERT(lvk::setDebugObjectName(vkDevice_, VK_OBJECT_TYPE_PIPELINE, (uint64_t)cps->pipeline_, cps->desc_.debugName));
  }

  return cps->pipeline_;
}

lvk::Holder<lvk::ComputePipelineHandle> lvk::VulkanContext::createComputePipeline(const ComputePipelineDesc& desc, Result* outResult) {
  if (!LVK_VERIFY(desc.smComp.valid())) {
    Result::setResult(outResult, Result::Code::ArgumentOutOfRange, "Missing compute shader");
    return {};
  }

  lvk::ComputePipelineState cps{desc};

  if (desc.specInfo.data && desc.specInfo.dataSize) {
    // copy into a local storage
    cps.specConstantDataStorage_ = malloc(desc.specInfo.dataSize);
    memcpy(cps.specConstantDataStorage_, desc.specInfo.data, desc.specInfo.dataSize);
    cps.desc_.specInfo.data = cps.specConstantDataStorage_;
  }

  return {this, computePipelinesPool_.create(std::move(cps))};
}

lvk::Holder<lvk::RayTracingPipelineHandle> lvk::VulkanContext::createRayTracingPipeline(const RayTracingPipelineDesc& desc,
                                                                                        Result* outResult) {
  LVK_PROFILER_FUNCTION();

  if (!LVK_VERIFY(has_KHR_ray_tracing_pipeline_)) {
    Result::setResult(outResult, Result(Result::Code::RuntimeError, "VK_KHR_ray_tracing_pipeline is not enabled"));
    return {};
  }

  RayTracingPipelineState rtps{desc};

  if (desc.specInfo.data && desc.specInfo.dataSize) {
    // copy into a local storage
    rtps.specConstantDataStorage_ = malloc(desc.specInfo.dataSize);
    memcpy(rtps.specConstantDataStorage_, desc.specInfo.data, desc.specInfo.dataSize);
    rtps.desc_.specInfo.data = rtps.specConstantDataStorage_;
  }

  return {this, rayTracingPipelinesPool_.create(std::move(rtps))};
}

lvk::Holder<lvk::RenderPipelineHandle> lvk::VulkanContext::createRenderPipeline(const RenderPipelineDesc& desc, Result* outResult) {
  const bool hasColorAttachments = desc.getNumColorAttachments() > 0;
  const bool hasDepthAttachment = desc.depthFormat != Format_Invalid;
  const bool hasAnyAttachments = hasColorAttachments || hasDepthAttachment;
  if (!LVK_VERIFY(hasAnyAttachments)) {
    Result::setResult(outResult, Result::Code::ArgumentOutOfRange, "Need at least one attachment");
    return {};
  }

  if (desc.smMesh.valid()) {
    if (!LVK_VERIFY(!desc.vertexInput.getNumAttributes() && !desc.vertexInput.getNumInputBindings())) {
      Result::setResult(outResult, Result::Code::ArgumentOutOfRange, "Cannot have vertexInput with mesh shaders");
      return {};
    }
    if (!LVK_VERIFY(!desc.smVert.valid())) {
      Result::setResult(outResult, Result::Code::ArgumentOutOfRange, "Cannot have both vertex and mesh shaders");
      return {};
    }
    if (!LVK_VERIFY(!desc.smTesc.valid() && !desc.smTese.valid())) {
      Result::setResult(outResult, Result::Code::ArgumentOutOfRange, "Cannot have both tessellation and mesh shaders");
      return {};
    }
    if (!LVK_VERIFY(!desc.smGeom.valid())) {
      Result::setResult(outResult, Result::Code::ArgumentOutOfRange, "Cannot have both geometry and mesh shaders");
      return {};
    }
  } else {
    if (!LVK_VERIFY(desc.smVert.valid())) {
      Result::setResult(outResult, Result::Code::ArgumentOutOfRange, "Missing vertex shader");
      return {};
    }
  }

  if (!LVK_VERIFY(desc.smFrag.valid())) {
    Result::setResult(outResult, Result::Code::ArgumentOutOfRange, "Missing fragment shader");
    return {};
  }

  RenderPipelineState rps = {.desc_ = desc};

  // Iterate and cache vertex input bindings and attributes
  const lvk::VertexInput& vstate = rps.desc_.vertexInput;

  bool bufferAlreadyBound[VertexInput::LVK_VERTEX_BUFFER_MAX] = {};

  rps.numAttributes_ = vstate.getNumAttributes();

  for (uint32_t i = 0; i != rps.numAttributes_; i++) {
    const VertexInput::VertexAttribute& attr = vstate.attributes[i];

    rps.vkAttributes_[i] = {
        .location = attr.location, .binding = attr.binding, .format = vertexFormatToVkFormat(attr.format), .offset = (uint32_t)attr.offset};

    if (!bufferAlreadyBound[attr.binding]) {
      bufferAlreadyBound[attr.binding] = true;
      rps.vkBindings_[rps.numBindings_++] = {
          .binding = attr.binding,
          .stride = vstate.inputBindings[attr.binding].stride,
          .inputRate = vertexInputRateToVkVertexInputRate(vstate.inputBindings[attr.binding].inputRate),
      };
    }
  }

  if (desc.specInfo.data && desc.specInfo.dataSize) {
    // copy into a local storage
    rps.specConstantDataStorage_ = malloc(desc.specInfo.dataSize);
    memcpy(rps.specConstantDataStorage_, desc.specInfo.data, desc.specInfo.dataSize);
    rps.desc_.specInfo.data = rps.specConstantDataStorage_;
  }

  return {this, renderPipelinesPool_.create(std::move(rps))};
}

void lvk::VulkanContext::destroy(lvk::RayTracingPipelineHandle handle) {
  lvk::RayTracingPipelineState* rtps = rayTracingPipelinesPool_.get(handle);

  if (!rtps) {
    return;
  }

  free(rtps->specConstantDataStorage_);

  deferredTask(
      std::packaged_task<void()>([device = getVkDevice(), pipeline = rtps->pipeline_]() { vkDestroyPipeline(device, pipeline, nullptr); }));
  deferredTask(std::packaged_task<void()>(
      [device = getVkDevice(), layout = rtps->pipelineLayout_]() { vkDestroyPipelineLayout(device, layout, nullptr); }));

  rayTracingPipelinesPool_.destroy(handle);
}

void lvk::VulkanContext::destroy(lvk::ComputePipelineHandle handle) {
  lvk::ComputePipelineState* cps = computePipelinesPool_.get(handle);

  if (!cps) {
    return;
  }

  free(cps->specConstantDataStorage_);

  deferredTask(
      std::packaged_task<void()>([device = getVkDevice(), pipeline = cps->pipeline_]() { vkDestroyPipeline(device, pipeline, nullptr); }));
  deferredTask(std::packaged_task<void()>(
      [device = getVkDevice(), layout = cps->pipelineLayout_]() { vkDestroyPipelineLayout(device, layout, nullptr); }));

  computePipelinesPool_.destroy(handle);
}

void lvk::VulkanContext::destroy(lvk::RenderPipelineHandle handle) {
  lvk::RenderPipelineState* rps = renderPipelinesPool_.get(handle);

  if (!rps) {
    return;
  }

  free(rps->specConstantDataStorage_);

  deferredTask(
      std::packaged_task<void()>([device = getVkDevice(), pipeline = rps->pipeline_]() { vkDestroyPipeline(device, pipeline, nullptr); }));
  deferredTask(std::packaged_task<void()>(
      [device = getVkDevice(), layout = rps->pipelineLayout_]() { vkDestroyPipelineLayout(device, layout, nullptr); }));

  renderPipelinesPool_.destroy(handle);
}

void lvk::VulkanContext::destroy(lvk::ShaderModuleHandle handle) {
  const lvk::ShaderModuleState* state = shaderModulesPool_.get(handle);

  if (!state) {
    return;
  }

  free((void*)state->ci.pCode);

  shaderModulesPool_.destroy(handle);
}

void lvk::VulkanContext::destroy(SamplerHandle handle) {
  LVK_PROFILER_FUNCTION_COLOR(LVK_PROFILER_COLOR_DESTROY);

  VkSampler sampler = *samplersPool_.get(handle);

  samplersPool_.destroy(handle);

  deferredTask(std::packaged_task<void()>([device = vkDevice_, sampler = sampler]() { vkDestroySampler(device, sampler, nullptr); }));
}

void lvk::VulkanContext::destroy(BufferHandle handle) {
  LVK_PROFILER_FUNCTION_COLOR(LVK_PROFILER_COLOR_DESTROY);

  SCOPE_EXIT {
    buffersPool_.destroy(handle);
  };

  lvk::VulkanBuffer* buf = buffersPool_.get(handle);

  if (!buf) {
    return;
  }

  if (LVK_VULKAN_USE_VMA) {
    if (buf->mappedPtr_) {
      vmaUnmapMemory((VmaAllocator)getVmaAllocator(), buf->vmaAllocation_);
    }
    deferredTask(std::packaged_task<void()>([vma = getVmaAllocator(), buffer = buf->vkBuffer_, allocation = buf->vmaAllocation_]() {
      vmaDestroyBuffer((VmaAllocator)vma, buffer, allocation);
    }));
  } else {
    if (buf->mappedPtr_) {
      vkUnmapMemory(vkDevice_, buf->vkMemory_);
    }
    deferredTask(std::packaged_task<void()>([device = vkDevice_, buffer = buf->vkBuffer_, memory = buf->vkMemory_]() {
      vkDestroyBuffer(device, buffer, nullptr);
      vkFreeMemory(device, memory, nullptr);
    }));
  }
}

void lvk::VulkanContext::destroy(lvk::TextureHandle handle) {
  LVK_PROFILER_FUNCTION_COLOR(LVK_PROFILER_COLOR_DESTROY);

  SCOPE_EXIT {
    texturesPool_.destroy(handle);
    awaitingCreation_ = true; // make the validation layers happy
  };

  lvk::VulkanImage* tex = texturesPool_.get(handle);

  if (!tex) {
    return;
  }

  deferredTask(std::packaged_task<void()>(
      [device = getVkDevice(), imageView = tex->imageView_]() { vkDestroyImageView(device, imageView, nullptr); }));
  if (tex->imageViewStorage_) {
    deferredTask(std::packaged_task<void()>(
        [device = getVkDevice(), imageView = tex->imageViewStorage_]() { vkDestroyImageView(device, imageView, nullptr); }));
  }

  for (size_t i = 0; i != LVK_MAX_MIP_LEVELS; i++) {
    for (size_t j = 0; j != LVK_ARRAY_NUM_ELEMENTS(tex->imageViewForFramebuffer_[0]); j++) {
      VkImageView v = tex->imageViewForFramebuffer_[i][j];
      if (v != VK_NULL_HANDLE) {
        deferredTask(
            std::packaged_task<void()>([device = getVkDevice(), imageView = v]() { vkDestroyImageView(device, imageView, nullptr); }));
      }
    }
    VkImageView v = tex->imageViewForFramebufferMultiview_[i];
    if (v != VK_NULL_HANDLE) {
      deferredTask(
          std::packaged_task<void()>([device = getVkDevice(), imageView = v]() { vkDestroyImageView(device, imageView, nullptr); }));
    }
  }

  if (!tex->isOwningVkImage_) {
    return;
  }

  if (LVK_VULKAN_USE_VMA && tex->vkMemory_[1] == VK_NULL_HANDLE) {
    if (tex->mappedPtr_) {
      vmaUnmapMemory((VmaAllocator)getVmaAllocator(), tex->vmaAllocation_);
    }
    deferredTask(std::packaged_task<void()>([vma = getVmaAllocator(), image = tex->vkImage_, allocation = tex->vmaAllocation_]() {
      vmaDestroyImage((VmaAllocator)vma, image, allocation);
    }));
  } else {
    if (tex->mappedPtr_) {
      vkUnmapMemory(vkDevice_, tex->vkMemory_[0]);
    }
    deferredTask(std::packaged_task<void()>([device = vkDevice_,
                                             image = tex->vkImage_,
                                             memory0 = tex->vkMemory_[0],
                                             memory1 = tex->vkMemory_[1],
                                             memory2 = tex->vkMemory_[2]]() {
      vkDestroyImage(device, image, nullptr);
      if (memory0 != VK_NULL_HANDLE) {
        vkFreeMemory(device, memory0, nullptr);
      }
      if (memory1 != VK_NULL_HANDLE) {
        vkFreeMemory(device, memory1, nullptr);
      }
      if (memory2 != VK_NULL_HANDLE) {
        vkFreeMemory(device, memory2, nullptr);
      }
    }));
  }
}

void lvk::VulkanContext::destroy(lvk::QueryPoolHandle handle) {
  VkQueryPool pool = *queriesPool_.get(handle);

  queriesPool_.destroy(handle);

  deferredTask(std::packaged_task<void()>([device = vkDevice_, pool = pool]() { vkDestroyQueryPool(device, pool, nullptr); }));
}

void lvk::VulkanContext::destroy(lvk::AccelStructHandle handle) {
  AccelerationStructure* accelStruct = accelStructuresPool_.get(handle);

  SCOPE_EXIT {
    accelStructuresPool_.destroy(handle);
  };

  deferredTask(std::packaged_task<void()>(
      [device = vkDevice_, as = accelStruct->vkHandle]() { vkDestroyAccelerationStructureKHR(device, as, nullptr); }));
}

void lvk::VulkanContext::destroy(Framebuffer& fb) {
  auto destroyFbTexture = [this](TextureHandle& handle) {
    {
      if (handle.empty())
        return;
      lvk::VulkanImage* tex = texturesPool_.get(handle);
      if (!tex || !tex->isOwningVkImage_)
        return;
      destroy(handle);
      handle = {};
    }
  };

  for (Framebuffer::AttachmentDesc& a : fb.color) {
    destroyFbTexture(a.texture);
    destroyFbTexture(a.resolveTexture);
  }
  destroyFbTexture(fb.depthStencil.texture);
  destroyFbTexture(fb.depthStencil.resolveTexture);
}

uint64_t lvk::VulkanContext::gpuAddress(AccelStructHandle handle) const {
  const lvk::AccelerationStructure* as = accelStructuresPool_.get(handle);

  LVK_ASSERT(as && as->deviceAddress);

  return as ? (uint64_t)as->deviceAddress : 0u;
}

lvk::Result lvk::VulkanContext::upload(lvk::BufferHandle handle, const void* data, size_t size, size_t offset) {
  LVK_PROFILER_FUNCTION();

  if (!LVK_VERIFY(data)) {
    return Result(Result::Code::ArgumentOutOfRange);
  }

  LVK_ASSERT_MSG(size, "Data size should be non-zero");

  lvk::VulkanBuffer* buf = buffersPool_.get(handle);

  if (!LVK_VERIFY(buf)) {
    return Result(Result::Code::ArgumentOutOfRange);
  }

  if (!LVK_VERIFY(offset + size <= buf->bufferSize_)) {
    return Result(Result::Code::ArgumentOutOfRange, "Out of range");
  }

  stagingDevice_->bufferSubData(*buf, offset, size, data);

  return Result();
}

lvk::Result lvk::VulkanContext::download(lvk::BufferHandle handle, void* data, size_t size, size_t offset) {
  LVK_PROFILER_FUNCTION();

  if (!LVK_VERIFY(data)) {
    return Result(Result::Code::ArgumentOutOfRange);
  }

  LVK_ASSERT_MSG(size, "Data size should be non-zero");

  lvk::VulkanBuffer* buf = buffersPool_.get(handle);

  if (!LVK_VERIFY(buf)) {
    return Result(Result::Code::ArgumentOutOfRange);
  }

  if (!LVK_VERIFY(offset + size <= buf->bufferSize_)) {
    return Result(Result::Code::ArgumentOutOfRange, "Out of range");
  }

  buf->getBufferSubData(*this, offset, size, data);

  return Result();
}

uint8_t* lvk::VulkanContext::getMappedPtr(BufferHandle handle) const {
  const lvk::VulkanBuffer* buf = buffersPool_.get(handle);

  LVK_ASSERT(buf);

  return buf->isMapped() ? buf->getMappedPtr() : nullptr;
}

uint64_t lvk::VulkanContext::gpuAddress(BufferHandle handle, size_t offset) const {
  LVK_ASSERT_MSG((offset & 7) == 0, "Buffer offset must be 8 bytes aligned as per GLSL_EXT_buffer_reference spec.");

  const lvk::VulkanBuffer* buf = buffersPool_.get(handle);

  LVK_ASSERT(buf && buf->vkDeviceAddress_);

  return buf ? (uint64_t)buf->vkDeviceAddress_ + offset : 0u;
}

void lvk::VulkanContext::flushMappedMemory(BufferHandle handle, size_t offset, size_t size) const {
  const lvk::VulkanBuffer* buf = buffersPool_.get(handle);

  LVK_ASSERT(buf);

  buf->flushMappedMemory(*this, offset, size);
}

lvk::Result lvk::VulkanContext::download(lvk::TextureHandle handle, const TextureRangeDesc& range, void* outData) {
  if (!outData) {
    return Result(Result::Code::ArgumentOutOfRange);
  }

  lvk::VulkanImage* texture = texturesPool_.get(handle);

  LVK_ASSERT(texture);

  if (!texture) {
    return Result(Result::Code::RuntimeError);
  }

  const Result result = validateRange(texture->vkExtent_, texture->numLevels_, range);

  if (!LVK_VERIFY(result.isOk())) {
    return result;
  }

  stagingDevice_->getImageData(*texture,
                               VkOffset3D{range.offset.x, range.offset.y, range.offset.z},
                               VkExtent3D{range.dimensions.width, range.dimensions.height, range.dimensions.depth},
                               VkImageSubresourceRange{
                                   .aspectMask = texture->getImageAspectFlags(),
                                   .baseMipLevel = range.mipLevel,
                                   .levelCount = range.numMipLevels,
                                   .baseArrayLayer = range.layer,
                                   .layerCount = range.numLayers,
                               },
                               texture->vkImageFormat_,
                               outData);

  return Result();
}

lvk::Result lvk::VulkanContext::upload(lvk::TextureHandle handle,
                                       const TextureRangeDesc& range,
                                       const void* data,
                                       uint32_t bufferRowLength) {
  LVK_PROFILER_FUNCTION();

  if (!LVK_VERIFY(data)) {
    return Result(Result::Code::ArgumentOutOfRange);
  }

  lvk::VulkanImage* texture = texturesPool_.get(handle);

  if (!LVK_VERIFY(texture)) {
    return Result(Result::Code::ArgumentOutOfRange);
  }

  const Result result = validateRange(texture->vkExtent_, texture->numLevels_, range);

  if (!LVK_VERIFY(result.isOk())) {
    return Result(Result::Code::ArgumentOutOfRange);
  }

  const uint32_t numLayers = std::max(range.numLayers, 1u);

  VkFormat vkFormat = texture->vkImageFormat_;

  if (texture->vkType_ == VK_IMAGE_TYPE_3D) {
    stagingDevice_->imageData3D(*texture,
                                VkOffset3D{range.offset.x, range.offset.y, range.offset.z},
                                VkExtent3D{range.dimensions.width, range.dimensions.height, range.dimensions.depth},
                                vkFormat,
                                data);
  } else {
    const VkRect2D imageRegion = {
        .offset = {.x = range.offset.x, .y = range.offset.y},
        .extent = {.width = range.dimensions.width, .height = range.dimensions.height},
    };
    stagingDevice_->imageData2D(
        *texture, imageRegion, range.mipLevel, range.numMipLevels, range.layer, range.numLayers, vkFormat, data, bufferRowLength);
  }

  return Result();
}

lvk::Dimensions lvk::VulkanContext::getDimensions(TextureHandle handle) const {
  if (!handle) {
    return {};
  }

  const lvk::VulkanImage* tex = texturesPool_.get(handle);

  LVK_ASSERT(tex);

  if (!tex) {
    return {};
  }

  return {
      .width = tex->vkExtent_.width,
      .height = tex->vkExtent_.height,
      .depth = tex->vkExtent_.depth,
  };
}

float lvk::VulkanContext::getAspectRatio(TextureHandle handle) const {
  if (!handle) {
    return 1.0f;
  }

  const lvk::VulkanImage* tex = texturesPool_.get(handle);

  LVK_ASSERT(tex);

  if (!tex) {
    return 1.0f;
  }

  return static_cast<float>(tex->vkExtent_.width) / static_cast<float>(tex->vkExtent_.height);
}

void lvk::VulkanContext::generateMipmap(TextureHandle handle) const {
  if (handle.empty()) {
    return;
  }

  const lvk::VulkanImage* tex = texturesPool_.get(handle);

  if (tex->numLevels_ <= 1) {
    return;
  }

  LVK_ASSERT(tex->vkImageLayout_ != VK_IMAGE_LAYOUT_UNDEFINED);
  const lvk::VulkanImmediateCommands::CommandBufferWrapper& wrapper = immediate_->acquire();
  tex->generateMipmap(wrapper.cmdBuf_);
  immediate_->submit(wrapper);
}

lvk::Format lvk::VulkanContext::getFormat(TextureHandle handle) const {
  if (handle.empty()) {
    return Format_Invalid;
  }

  return vkFormatToFormat(texturesPool_.get(handle)->vkImageFormat_);
}

lvk::Holder<lvk::ShaderModuleHandle> lvk::VulkanContext::createShaderModule(const ShaderModuleDesc& desc, Result* outResult) {
  Result result;
  auto isSlang = [](const char* code) {
    if (!code)
      return false;
    return strstr(code, "[shader(\"") != nullptr;
  };
  ShaderModuleState sm = desc.dataSize ? createShaderModuleFromSPIRV(desc.data, desc.dataSize, desc.debugName, &result) // binary
                         : isSlang(desc.data) // text
                             ? createShaderModuleFromSlang(desc.stage, desc.data, desc.entryPointName, desc.debugName, &result)
                             : createShaderModuleFromGLSL(desc.stage, desc.data, desc.debugName, &result);

  if (!result.isOk()) {
    Result::setResult(outResult, result);
    return {};
  }
  Result::setResult(outResult, result);

  return {this, shaderModulesPool_.create(std::move(sm))};
}

lvk::ShaderModuleState lvk::VulkanContext::createShaderModuleFromSPIRV(const void* spirv,
                                                                       size_t numBytes,
                                                                       const char* debugName,
                                                                       Result* outResult) const {
  (void)debugName;

  if (!spirv || !numBytes) {
    Result::setResult(outResult, Result(Result::Code::ArgumentOutOfRange, "Expecting non-empty SPIR-V code"));
    return {};
  }

  SpvReflectShaderModule mdl;
  SpvReflectResult result = spvReflectCreateShaderModule(numBytes, spirv, &mdl);
  LVK_ASSERT(result == SPV_REFLECT_RESULT_SUCCESS);
  SCOPE_EXIT {
    spvReflectDestroyShaderModule(&mdl);
  };

  uint32_t pushConstantsSize = 0;

  for (uint32_t i = 0; i < mdl.push_constant_block_count; ++i) {
    const SpvReflectBlockVariable& block = mdl.push_constant_blocks[i];
    pushConstantsSize = std::max(pushConstantsSize, block.offset + block.size);
  }

  const VkShaderModuleCreateInfo ci = {
      .sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
      .codeSize = numBytes,
      .pCode = (const uint32_t*)malloc(numBytes),
  };

  memcpy((void*)ci.pCode, spirv, numBytes);

  return {
      .ci = ci,
      .pushConstantsSize = pushConstantsSize,
  };
}

lvk::ShaderModuleState lvk::VulkanContext::createShaderModuleFromGLSL(ShaderStage stage,
                                                                      const char* source,
                                                                      const char* debugName,
                                                                      Result* outResult) const {
  const VkShaderStageFlagBits vkStage = shaderStageToVkShaderStage(stage);
  LVK_ASSERT(vkStage != VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM);
  LVK_ASSERT(source);

  std::string sourcePatched;

  if (!source || !*source) {
    Result::setResult(outResult, Result::Code::ArgumentOutOfRange, "Shader source is empty");
    return {};
  }

  auto addCode = [source, &sourcePatched](const char* substr, const char* code) -> void {
    if (strstr(source, substr)) {
      sourcePatched.append(code);
    }
  };

  if (strstr(source, "#version ") == nullptr) {
    if (vkStage == VK_SHADER_STAGE_TASK_BIT_EXT || vkStage == VK_SHADER_STAGE_MESH_BIT_EXT) {
      sourcePatched +=
          "#version 460\n"
          "#extension GL_EXT_buffer_reference : require\n"
          "#extension GL_EXT_buffer_reference_uvec2 : require\n"
          "#extension GL_EXT_debug_printf : enable\n"
          "#extension GL_EXT_nonuniform_qualifier : require\n"
          "#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require\n"
          "#extension GL_EXT_mesh_shader : require\n";
    }
    if (vkStage == VK_SHADER_STAGE_VERTEX_BIT || vkStage == VK_SHADER_STAGE_COMPUTE_BIT ||
        vkStage == VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT || vkStage == VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT) {
      sourcePatched +=
          "#version 460\n"
          "#extension GL_EXT_buffer_reference : require\n"
          "#extension GL_EXT_buffer_reference_uvec2 : require\n"
          "#extension GL_EXT_debug_printf : enable\n"
          "#extension GL_EXT_nonuniform_qualifier : require\n"
          "#extension GL_EXT_samplerless_texture_functions : require\n"
          "#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require\n";
    }
    if (vkStage == VK_SHADER_STAGE_FRAGMENT_BIT) {
      // Note how nonuniformEXT() should be used:
      // https://github.com/KhronosGroup/Vulkan-Samples/blob/main/shaders/descriptor_indexing/nonuniform-quads.frag#L33-L39
      sourcePatched +=
          "#version 460\n"
          "#extension GL_EXT_buffer_reference_uvec2 : require\n"
          "#extension GL_EXT_debug_printf : enable\n"
          "#extension GL_EXT_nonuniform_qualifier : require\n"
          "#extension GL_EXT_samplerless_texture_functions : require\n"
          "#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require\n";
      addCode("kTLAS[",
              "#extension GL_EXT_buffer_reference : require\n"
              "#extension GL_EXT_ray_query : require\n"
              "layout(set = 0, binding = 4) uniform accelerationStructureEXT kTLAS[];\n");
      sourcePatched +=
          "layout (set = 0, binding = 0) uniform texture2D   kTextures2D[];\n"
          "layout (set = 1, binding = 0) uniform texture3D   kTextures3D[];\n"
          "layout (set = 2, binding = 0) uniform textureCube kTexturesCube[];\n"
          "layout (set = 3, binding = 0) uniform texture2D   kTextures2DShadow[];\n"
          "layout (set = 0, binding = 1) uniform sampler       kSamplers[];\n"
          "layout (set = 3, binding = 1) uniform samplerShadow kSamplersShadow[];\n"
          "layout (set = 0, binding = 3) uniform sampler2D     kSamplersYUV[];\n";
      addCode("textureBindless2D(",
              "vec4 textureBindless2D(uint textureid, uint samplerid, vec2 uv) {\n"
              "  return texture(nonuniformEXT(sampler2D(kTextures2D[textureid], kSamplers[samplerid])), uv);\n"
              "}\n");
      addCode("textureBindless2DLod(",
              "vec4 textureBindless2DLod(uint textureid, uint samplerid, vec2 uv, float lod) {\n"
              "  return textureLod(nonuniformEXT(sampler2D(kTextures2D[textureid], kSamplers[samplerid])), uv, lod);\n"
              "}\n");
      addCode("textureBindless2DShadow(",
              "float textureBindless2DShadow(uint textureid, uint samplerid, vec3 uvw) {"
              "  return texture(nonuniformEXT(sampler2DShadow(kTextures2DShadow[textureid], kSamplersShadow[samplerid])), uvw);\n"
              "}\n");
      addCode("textureBindlessSize2D(",
              "ivec2 textureBindlessSize2D(uint textureid) {\n"
              "  return textureSize(nonuniformEXT(kTextures2D[textureid]), 0);\n"
              "}\n");
      addCode("textureBindlessCube(",
              "vec4 textureBindlessCube(uint textureid, uint samplerid, vec3 uvw) {\n"
              "  return texture(nonuniformEXT(samplerCube(kTexturesCube[textureid], kSamplers[samplerid])), uvw);\n"
              "}\n");
      addCode("textureBindlessCubeLod(",
              "vec4 textureBindlessCubeLod(uint textureid, uint samplerid, vec3 uvw, float lod) {\n"
              "  return textureLod(nonuniformEXT(samplerCube(kTexturesCube[textureid], kSamplers[samplerid])), uvw, lod);\n"
              "}\n");
      addCode("textureBindlessQueryLevels2D(",
              "int textureBindlessQueryLevels2D(uint textureid) {\n"
              "  return textureQueryLevels(nonuniformEXT(kTextures2D[textureid]));\n"
              "}\n");
      addCode("textureBindlessQueryLevelsCube(",
              "int textureBindlessQueryLevelsCube(uint textureid) {\n"
              "  return textureQueryLevels(nonuniformEXT(kTexturesCube[textureid]));\n"
              "}\n");
    }
    sourcePatched += source;
    source = sourcePatched.c_str();
  }

  const glslang_resource_t glslangResource = lvk::getGlslangResource(getVkPhysicalDeviceProperties().limits);

  std::vector<uint8_t> spirv;
  lvk::Result::setResult(outResult, lvk::compileShaderGlslang(stage, source, &spirv, &glslangResource));

  return createShaderModuleFromSPIRV(spirv.data(), spirv.size(), debugName, outResult);
}

lvk::ShaderModuleState lvk::VulkanContext::createShaderModuleFromSlang(ShaderStage stage,
                                                                       const char* source,
                                                                       const char* entryPointName,
                                                                       const char* debugName,
                                                                       Result* outResult) const {
  std::string sourcePatched;

  if (!source || !*source) {
    Result::setResult(outResult, Result::Code::ArgumentOutOfRange, "Shader source is empty");
    return {};
  }

  auto addCode = [source, &sourcePatched](const char* substr, const char* code) -> void {
    if (strstr(source, substr)) {
      sourcePatched.append(code);
    }
  };

  // overloaded operators to mimic GLSL matrix operations
  sourcePatched +=
      "float2x2 operator*(float2x2 a, float2x2 b) { return mul(b, a); }\n"
      "float2   operator*(float2x2 a, float2   b) { return mul(b, a); }\n"
      "float3x3 operator*(float3x3 a, float3x3 b) { return mul(b, a); }\n"
      "float3   operator*(float3x3 a, float3   b) { return mul(b, a); }\n"
      "float4x4 operator*(float4x4 a, float4x4 b) { return mul(b, a); }\n"
      "float4   operator*(float4x4 a, float4   b) { return mul(b, a); }\n";
  // bindless texture and sampler arrays
  sourcePatched +=
      "[[vk::binding(0, 0)]] Texture2D    kTextures2D[];\n"
      "[[vk::binding(0, 1)]] Texture3D    kTextures3D[];\n"
      "[[vk::binding(0, 2)]] TextureCube  kTexturesCube[];\n"
      "[[vk::binding(0, 3)]] Texture2D    kTextures2DShadow[];\n"
      "[[vk::binding(1, 0)]] SamplerState kSamplers[];\n"
      "[[vk::binding(1, 3)]] SamplerComparisonState kSamplersShadow[];\n"
      "[[vk::binding(3, 0)]] Sampler2D    kSamplersYUV[];\n";
  // cannot handle unbounded arrays https://github.com/shader-slang/slang/issues/8902
  addCode("kTLAS[", "[[vk::binding(4, 0)]] RaytracingAccelerationStructure kTLAS[];\n");
  addCode("textureBindless2D(",
          "float4 textureBindless2D(uint textureid, uint samplerid, float2 uv) {\n"
          "  return kTextures2D[NonUniformResourceIndex(textureid)].Sample(\n"
          "    kSamplers[NonUniformResourceIndex(samplerid)], uv);\n"
          "}\n");
  addCode("textureBindless2DLod(",
          "float4 textureBindless2DLod(uint textureid, uint samplerid, float2 uv, float lod) {\n"
          "  return kTextures2D[NonUniformResourceIndex(textureid)].SampleLevel(\n"
          "    kSamplers[NonUniformResourceIndex(samplerid)], uv, lod);\n"
          "}\n");
  addCode("textureBindlessCube(",
          "float4 textureBindlessCube(uint textureid, uint samplerid, float3 dir) {\n"
          "  return kTexturesCube[NonUniformResourceIndex(textureid)].Sample(\n"
          "    kSamplers[NonUniformResourceIndex(samplerid)], dir);\n"
          "}\n");
  addCode("textureBindlessSize2D(",
          "int2 textureBindlessSize2D(uint textureid) {\n"
          "  uint width, height;\n"
          "  kTextures2D[NonUniformResourceIndex(textureid)].GetDimensions(width, height);\n"
          "  return int2(width, height);\n"
          "}\n");
  addCode("textureBindless2DShadow(",
          "float textureBindless2DShadow(uint textureid, uint samplerid, float3 uvw) {\n"
          "  return kTextures2DShadow[NonUniformResourceIndex(textureid)].SampleCmpLevelZero(\n"
          "    kSamplersShadow[NonUniformResourceIndex(samplerid)], uvw.xy, uvw.z);\n"
          "}\n");

  sourcePatched += source;
  source = sourcePatched.c_str();

  std::vector<uint8_t> spirv;
  lvk::Result::setResult(outResult, lvk::compileShaderSlang(stage, source, entryPointName, &spirv));

  return createShaderModuleFromSPIRV(spirv.data(), spirv.size(), debugName, outResult);
}

lvk::Format lvk::VulkanContext::getSwapchainFormat() const {
  if (!hasSwapchain()) {
    return Format_Invalid;
  }

  return vkFormatToFormat(swapchain_->getSurfaceFormat().format);
}

lvk::ColorSpace lvk::VulkanContext::getSwapchainColorSpace() const {
  if (!hasSwapchain()) {
    return ColorSpace_SRGB_NONLINEAR;
  }

  return vkColorSpaceToColorSpace(swapchain_->getSurfaceFormat().colorSpace);
}

uint32_t lvk::VulkanContext::getNumSwapchainImages() const {
  return hasSwapchain() ? swapchain_->getNumSwapchainImages() : 0;
}

lvk::TextureHandle lvk::VulkanContext::getCurrentSwapchainTexture() {
  LVK_PROFILER_FUNCTION();

  if (!hasSwapchain()) {
    return {};
  }

  TextureHandle tex = swapchain_->getCurrentTexture();

  if (!LVK_VERIFY(tex.valid())) {
    LVK_ASSERT_MSG(false, "Swapchain has no valid texture");
    return {};
  }

  LVK_ASSERT_MSG(texturesPool_.get(tex)->vkImageFormat_ != VK_FORMAT_UNDEFINED, "Invalid image format");

  return tex;
}

uint32_t lvk::VulkanContext::getSwapchainCurrentImageIndex() const {
  if (hasSwapchain()) {
    // make sure we do not use a stale image
    (void)swapchain_->getCurrentTexture();
  }

  return hasSwapchain() ? swapchain_->getSwapchainCurrentImageIndex() : 0;
}

void lvk::VulkanContext::recreateSwapchain(int newWidth, int newHeight) {
  initSwapchain(newWidth, newHeight);
}

bool lvk::VulkanContext::setCurrentPresentMode(PresentMode mode) {
  if (!hasSwapchain() || !has_KHR_swapchain_maintenance1_) {
    return false;
  }

  return swapchain_->setCurrentPresentMode(presentModeToVkPresentMode(mode));
}

[[nodiscard]] lvk::PresentMode lvk::VulkanContext::getCurrentPresentMode() const {
  return swapchain_ ? vkPresentModeToPresentMode(swapchain_->currentPresentMode_) : PresentMode_FIFO;
}

uint32_t lvk::VulkanContext::getFramebufferMSAABitMask() const {
  const VkPhysicalDeviceLimits& limits = getVkPhysicalDeviceProperties().limits;
  return limits.framebufferColorSampleCounts & limits.framebufferDepthSampleCounts;
}

double lvk::VulkanContext::getTimestampPeriodToMs() const {
  return double(getVkPhysicalDeviceProperties().limits.timestampPeriod) * 1e-6;
}

bool lvk::VulkanContext::getQueryPoolResults(QueryPoolHandle pool,
                                             uint32_t firstQuery,
                                             uint32_t queryCount,
                                             size_t dataSize,
                                             void* outData,
                                             size_t stride) const {
  VkQueryPool vkPool = *queriesPool_.get(pool);

  VK_ASSERT(vkGetQueryPoolResults(
      vkDevice_, vkPool, firstQuery, queryCount, dataSize, outData, stride, VK_QUERY_RESULT_WAIT_BIT | VK_QUERY_RESULT_64_BIT));

  return true;
}

lvk::AccelStructSizes lvk::VulkanContext::getAccelStructSizes(const AccelStructDesc& desc, Result* outResult) const {
  LVK_PROFILER_FUNCTION();

  if (!LVK_VERIFY(has_KHR_acceleration_structure_)) {
    Result::setResult(outResult, Result(Result::Code::RuntimeError, "VK_KHR_acceleration_structure is not enabled"));
    return {};
  }

  Result result;
  VkAccelerationStructureGeometryKHR accelerationStructureGeometry{};
  VkAccelerationStructureBuildSizesInfoKHR accelerationStructureBuildSizesInfo{};
  switch (desc.type) {
  case AccelStructType_BLAS:
    getBuildInfoBLAS(desc, accelerationStructureGeometry, accelerationStructureBuildSizesInfo);
    break;
  case AccelStructType_TLAS:
    getBuildInfoTLAS(desc, accelerationStructureGeometry, accelerationStructureBuildSizesInfo);
    break;
  default:
    LVK_ASSERT_MSG(false, "Invalid acceleration structure type");
    Result::setResult(outResult, Result(Result::Code::ArgumentOutOfRange, "Invalid acceleration structure type"));
    return {};
  }

  Result::setResult(outResult, Result::Code::Ok);

  return lvk::AccelStructSizes{
      .accelerationStructureSize = accelerationStructureBuildSizesInfo.accelerationStructureSize,
      .updateScratchSize = accelerationStructureBuildSizesInfo.updateScratchSize,
      .buildScratchSize = accelerationStructureBuildSizesInfo.buildScratchSize,
  };
}

lvk::Result lvk::VulkanContext::createInstance() {
  vkInstance_ = VK_NULL_HANDLE;

  // check if we have validation layers in the system
  {
    uint32_t numLayerProperties = 0;
    vkEnumerateInstanceLayerProperties(&numLayerProperties, nullptr);
    std::vector<VkLayerProperties> layerProperties(numLayerProperties);
    vkEnumerateInstanceLayerProperties(&numLayerProperties, layerProperties.data());

    [this, &layerProperties]() -> void {
      for (const VkLayerProperties& props : layerProperties) {
        for (const char* layer : kDefaultValidationLayers) {
          if (!strcmp(props.layerName, layer)) {
            khronosValidationVersion_ = props.specVersion;
            return;
          }
        }
      }
      config_.enableValidation = false; // no validation layers available
    }();
  }

  std::vector<VkExtensionProperties> allInstanceExtensions;
  {
    uint32_t count = 0;
    VK_ASSERT(vkEnumerateInstanceExtensionProperties(nullptr, &count, nullptr));
    allInstanceExtensions.resize(count);
    VK_ASSERT(vkEnumerateInstanceExtensionProperties(nullptr, &count, allInstanceExtensions.data()));
  }
  // collect instance extensions from all validation layers
  if (config_.enableValidation) {
    for (const char* layer : kDefaultValidationLayers) {
      uint32_t count = 0;
      VK_ASSERT(vkEnumerateInstanceExtensionProperties(layer, &count, nullptr));
      if (count > 0) {
        const size_t sz = allInstanceExtensions.size();
        allInstanceExtensions.resize(sz + count);
        VK_ASSERT(vkEnumerateInstanceExtensionProperties(layer, &count, allInstanceExtensions.data() + sz));
      }
    }
  }

  enabledInstanceExtensionNames_ = {
      VK_KHR_SURFACE_EXTENSION_NAME,
#if defined(_WIN32)
      VK_KHR_WIN32_SURFACE_EXTENSION_NAME,
#elif defined(VK_USE_PLATFORM_ANDROID_KHR)
      VK_KHR_ANDROID_SURFACE_EXTENSION_NAME,
#elif defined(__linux__)
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
      VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME,
#else
      VK_KHR_XLIB_SURFACE_EXTENSION_NAME,
#endif // VK_USE_PLATFORM_WAYLAND_KHR
#endif
  };

  const bool hasPortabilityEnumeration = hasExtension(VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME, allInstanceExtensions);

#if defined(__APPLE__)
  if (hasExtension(VK_EXT_LAYER_SETTINGS_EXTENSION_NAME, allInstanceExtensions)) {
    enabledInstanceExtensionNames_.push_back(VK_EXT_LAYER_SETTINGS_EXTENSION_NAME);
  }
  if (hasExtension(VK_MVK_MACOS_SURFACE_EXTENSION_NAME, allInstanceExtensions)) {
    has_MVK_macos_surface_ = true;
    enabledInstanceExtensionNames_.push_back(VK_MVK_MACOS_SURFACE_EXTENSION_NAME);
  }
  if (hasExtension(VK_EXT_METAL_SURFACE_EXTENSION_NAME, allInstanceExtensions)) {
    enabledInstanceExtensionNames_.push_back(VK_EXT_METAL_SURFACE_EXTENSION_NAME);
  }
  if (hasPortabilityEnumeration) {
    enabledInstanceExtensionNames_.push_back(VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME);
  }
#endif // __APPLE__

  // check if we have the VK_EXT_debug_utils extension
  const bool hasDebugUtils = hasExtension(VK_EXT_DEBUG_UTILS_EXTENSION_NAME, allInstanceExtensions);

  if (hasDebugUtils) {
    enabledInstanceExtensionNames_.push_back(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);
  }

  if (config_.enableValidation) {
    enabledInstanceExtensionNames_.push_back(VK_EXT_VALIDATION_FEATURES_EXTENSION_NAME); // enabled only for validation
  }

  if (config_.enableHeadlessSurface) {
    enabledInstanceExtensionNames_.push_back(VK_EXT_HEADLESS_SURFACE_EXTENSION_NAME);
  }

  if (hasExtension(VK_KHR_SURFACE_MAINTENANCE_1_EXTENSION_NAME, allInstanceExtensions)) {
    enabledInstanceExtensionNames_.push_back(VK_KHR_SURFACE_MAINTENANCE_1_EXTENSION_NAME);
  }
  // Lavapipe 25.3.3 supports both `VK_KHR_surface_maintenance` and `VK_EXT_surface_maintenance`,
  // but only supports `VK_EXT_swapchain_maintenance1`, which in turn requires `VK_EXT_surface_maintenance1`
  if (hasExtension(VK_EXT_SURFACE_MAINTENANCE_1_EXTENSION_NAME, allInstanceExtensions)) {
    // remove once VK_KHR_surface_maintenance1 becomes mandatory
    enabledInstanceExtensionNames_.push_back(VK_EXT_SURFACE_MAINTENANCE_1_EXTENSION_NAME);
  }

  if (hasExtension(VK_EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME, allInstanceExtensions)) {
    has_EXT_swapchain_colorspace_ = true;
    enabledInstanceExtensionNames_.push_back(VK_EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME);
  }

  if (hasExtension(VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME, allInstanceExtensions)) {
    // required by the instance extension VK_EXT_surface_maintenance1
    enabledInstanceExtensionNames_.push_back(VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME);
  }

  for (const char* ext : config_.extensionsInstance) {
    if (ext) {
      enabledInstanceExtensionNames_.push_back(ext);
    }
  }

#if !defined(ANDROID)
  // GPU Assisted Validation doesn't work on Android.
  // It implicitly requires vertexPipelineStoresAndAtomics feature that's not supported even on high-end devices.
  const VkValidationFeatureEnableEXT validationFeaturesEnabled[] = {
      VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT,
      VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT,
  };
#endif // ANDROID

#if defined(__APPLE__)
  // Shader validation doesn't work in MoltenVK for SPIR-V 1.6 under Vulkan 1.3:
  // "Invalid SPIR-V binary version 1.6 for target environment SPIR-V 1.5 (under Vulkan 1.2 semantics)."
  const VkValidationFeatureDisableEXT validationFeaturesDisabled[] = {
      VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT,
      VK_VALIDATION_FEATURE_DISABLE_SHADER_VALIDATION_CACHE_EXT,
  };
#endif // __APPLE__

  const VkValidationFeaturesEXT features = {
      .sType = VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT,
      .pNext = nullptr,
#if !defined(ANDROID)
      .enabledValidationFeatureCount = config_.enableValidation ? (uint32_t)LVK_ARRAY_NUM_ELEMENTS(validationFeaturesEnabled) : 0u,
      .pEnabledValidationFeatures = config_.enableValidation ? validationFeaturesEnabled : nullptr,
#endif
#if defined(__APPLE__)
      .disabledValidationFeatureCount = config_.enableValidation ? (uint32_t)LVK_ARRAY_NUM_ELEMENTS(validationFeaturesDisabled) : 0u,
      .pDisabledValidationFeatures = config_.enableValidation ? validationFeaturesDisabled : nullptr,
#endif
  };

#if defined(VK_EXT_layer_settings) && VK_EXT_layer_settings
  // https://github.com/KhronosGroup/MoltenVK/blob/main/Docs/MoltenVK_Configuration_Parameters.md
  const int useMetalArgumentBuffers = 1;
  const VkBool32 gpuav_descriptor_checks = VK_FALSE; // https://github.com/KhronosGroup/Vulkan-ValidationLayers/issues/8688
  const VkBool32 gpuav_indirect_draws_buffers = VK_FALSE; // https://github.com/KhronosGroup/Vulkan-ValidationLayers/issues/8579
  const VkBool32 gpuav_post_process_descriptor_indexing = VK_FALSE; // https://github.com/KhronosGroup/Vulkan-ValidationLayers/issues/9222
#define LAYER_SETTINGS_BOOL32(name, var)                                                                                        \
  VkLayerSettingEXT {                                                                                                           \
    .pLayerName = kDefaultValidationLayers[0], .pSettingName = name, .type = VK_LAYER_SETTING_TYPE_BOOL32_EXT, .valueCount = 1, \
    .pValues = var,                                                                                                             \
  }
  const VkLayerSettingEXT settings[] = {
      LAYER_SETTINGS_BOOL32("gpuav_descriptor_checks", &gpuav_descriptor_checks),
      LAYER_SETTINGS_BOOL32("gpuav_indirect_draws_buffers", &gpuav_indirect_draws_buffers),
      LAYER_SETTINGS_BOOL32("gpuav_post_process_descriptor_indexing", &gpuav_post_process_descriptor_indexing),
      {"MoltenVK", "MVK_CONFIG_USE_METAL_ARGUMENT_BUFFERS", VK_LAYER_SETTING_TYPE_INT32_EXT, 1, &useMetalArgumentBuffers},
  };
#undef LAYER_SETTINGS_BOOL32
  const VkLayerSettingsCreateInfoEXT layerSettingsCreateInfo = {
      .sType = VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT,
      .pNext = config_.enableValidation ? &features : nullptr,
      .settingCount = (uint32_t)LVK_ARRAY_NUM_ELEMENTS(settings),
      .pSettings = settings,
  };
#endif // defined(VK_EXT_layer_settings) && VK_EXT_layer_settings

  // check extensions
  {
    std::string missingExtensions;
    for (const char* ext : enabledInstanceExtensionNames_) {
      if (!hasExtension(ext, allInstanceExtensions))
        missingExtensions += "\n   " + std::string(ext);
    }
    if (!missingExtensions.empty()) {
      MINILOG_LOG_PROC(minilog::FatalError, "Missing Vulkan instance extensions: %s\n", missingExtensions.c_str());
      assert(false);
      return Result(Result::Code::RuntimeError);
    }
  }

  const VkApplicationInfo appInfo = {
      .sType = VK_STRUCTURE_TYPE_APPLICATION_INFO,
      .pNext = nullptr,
      .pApplicationName = "LVK/Vulkan",
      .applicationVersion = VK_MAKE_VERSION(1, 0, 0),
      .pEngineName = "LVK/Vulkan",
      .engineVersion = VK_MAKE_VERSION(1, 0, 0),
#if defined(VK_API_VERSION_1_4)
      .apiVersion = config_.vulkanVersion == VulkanVersion_1_3 ? VK_API_VERSION_1_3 : VK_API_VERSION_1_4,
#else
      .apiVersion = VK_API_VERSION_1_3,
#endif // VK_API_VERSION_1_4
  };

  const VkInstanceCreateInfo ci = {
      .sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
#if defined(VK_EXT_layer_settings) && VK_EXT_layer_settings
      .pNext = &layerSettingsCreateInfo,
#else
      .pNext = config_.enableValidation ? &features : nullptr,
#endif // defined(VK_EXT_layer_settings) && VK_EXT_layer_settings
      .flags = hasPortabilityEnumeration ? VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR : 0u,
      .pApplicationInfo = &appInfo,
      .enabledLayerCount = config_.enableValidation ? (uint32_t)LVK_ARRAY_NUM_ELEMENTS(kDefaultValidationLayers) : 0u,
      .ppEnabledLayerNames = config_.enableValidation ? kDefaultValidationLayers : nullptr,
      .enabledExtensionCount = (uint32_t)enabledInstanceExtensionNames_.size(),
      .ppEnabledExtensionNames = enabledInstanceExtensionNames_.data(),
  };
  VK_ASSERT(vkCreateInstance(&ci, nullptr, &vkInstance_));

  volkLoadInstance(vkInstance_);

  // debug messenger
  if (hasDebugUtils) {
    const VkDebugUtilsMessengerCreateInfoEXT ci = {
        .sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT,
        .messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT |
                           VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT,
        .messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT |
                       VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT,
        .pfnUserCallback = &vulkanDebugCallback,
        .pUserData = this,
    };
    VK_ASSERT(vkCreateDebugUtilsMessengerEXT(vkInstance_, &ci, nullptr, &vkDebugUtilsMessenger_));
  }

  LLOGL("%s layer version: %u.%u.%u\n",
        kDefaultValidationLayers[0],
        VK_VERSION_MAJOR(khronosValidationVersion_),
        VK_VERSION_MINOR(khronosValidationVersion_),
        VK_VERSION_PATCH(khronosValidationVersion_));

  // log available instance extensions
  LLOGL("\nVulkan instance extensions:\n");

  for (const VkExtensionProperties& extension : allInstanceExtensions) {
    LLOGL("  %s\n", extension.extensionName);
  }

  return Result();
}

void lvk::VulkanContext::createHeadlessSurface() {
  const VkHeadlessSurfaceCreateInfoEXT ci = {
      .sType = VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT,
      .pNext = nullptr,
      .flags = 0,
  };
  VK_ASSERT(vkCreateHeadlessSurfaceEXT(vkInstance_, &ci, nullptr, &vkSurface_));
}

void lvk::VulkanContext::createSurface(void* window, void* display) {
#if defined(VK_USE_PLATFORM_WIN32_KHR)
  const VkWin32SurfaceCreateInfoKHR ci = {
      .sType = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR,
      .hinstance = GetModuleHandle(nullptr),
      .hwnd = (HWND)window,
  };
  VK_ASSERT(vkCreateWin32SurfaceKHR(vkInstance_, &ci, nullptr, &vkSurface_));
#elif defined(VK_USE_PLATFORM_ANDROID_KHR)
  const VkAndroidSurfaceCreateInfoKHR ci = {
      .sType = VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR,
      .pNext = nullptr,
      .flags = 0,
      .window = (ANativeWindow*)window,
  };
  VK_ASSERT(vkCreateAndroidSurfaceKHR(vkInstance_, &ci, nullptr, &vkSurface_));
#elif defined(VK_USE_PLATFORM_XLIB_KHR)
  const VkXlibSurfaceCreateInfoKHR ci = {
      .sType = VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR,
      .flags = 0,
      .dpy = (Display*)display,
      .window = (Window)window,
  };
  VK_ASSERT(vkCreateXlibSurfaceKHR(vkInstance_, &ci, nullptr, &vkSurface_));
#elif defined(VK_USE_PLATFORM_WAYLAND_KHR)
  const VkWaylandSurfaceCreateInfoKHR ci = {
      .sType = VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR,
      .flags = 0,
      .display = (wl_display*)display,
      .surface = (wl_surface*)window,
  };
  VK_ASSERT(vkCreateWaylandSurfaceKHR(vkInstance_, &ci, nullptr, &vkSurface_));
#elif defined(VK_USE_PLATFORM_MACOS_MVK) || defined(VK_USE_PLATFORM_METAL_EXT)
  if (has_MVK_macos_surface_) {
    const VkMacOSSurfaceCreateInfoMVK ci = {
        .sType = VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK,
        .flags = 0,
        .pView = window,
    };
    VK_ASSERT(vkCreateMacOSSurfaceMVK(vkInstance_, &ci, nullptr, &vkSurface_));
  } else {
    const VkMetalSurfaceCreateInfoEXT ci = {
        .sType = VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT,
        .flags = 0,
        .pLayer = display, // layer
    };
    VK_ASSERT(vkCreateMetalSurfaceEXT(vkInstance_, &ci, nullptr, &vkSurface_));
  }
#else
#error Implement for other platforms
#endif
}

uint32_t lvk::VulkanContext::queryDevices(HWDeviceDesc* outDevices, uint32_t maxOutDevices) {
  // Physical devices
  uint32_t deviceCount = 0;
  VK_ASSERT(vkEnumeratePhysicalDevices(vkInstance_, &deviceCount, nullptr));
  std::vector<VkPhysicalDevice> vkDevices(deviceCount);
  VK_ASSERT(vkEnumeratePhysicalDevices(vkInstance_, &deviceCount, vkDevices.data()));

  auto convertVulkanDeviceTypeToLVK = [](VkPhysicalDeviceType vkDeviceType) -> HWDeviceType {
    switch (vkDeviceType) {
    case VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU:
      return HWDeviceType_Integrated;
    case VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU:
      return HWDeviceType_Discrete;
    case VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU:
      return HWDeviceType_External;
    case VK_PHYSICAL_DEVICE_TYPE_CPU:
      return HWDeviceType_Software;
    default:
      return HWDeviceType_Software;
    }
  };

  uint32_t numCompatibleDevices = 0;

  for (uint32_t i = 0; i < deviceCount; ++i) {
    VkPhysicalDevice physicalDevice = vkDevices[i];
    VkPhysicalDeviceProperties deviceProperties;
    vkGetPhysicalDeviceProperties(physicalDevice, &deviceProperties);

    const HWDeviceType deviceType = convertVulkanDeviceTypeToLVK(deviceProperties.deviceType);

    if (outDevices && numCompatibleDevices < maxOutDevices) {
      outDevices[numCompatibleDevices] = {.guid = (uintptr_t)vkDevices[i], .type = deviceType};
      strncpy(outDevices[numCompatibleDevices].name, deviceProperties.deviceName, strlen(deviceProperties.deviceName));
      numCompatibleDevices++;
    }
  }

  return numCompatibleDevices;
}

void lvk::VulkanContext::addNextPhysicalDeviceProperties(void* properties) {
  if (!properties)
    return;

  std::launder(reinterpret_cast<VkBaseOutStructure*>(properties))->pNext =
      std::launder(reinterpret_cast<VkBaseOutStructure*>(vkPhysicalDeviceProperties2_.pNext));

  vkPhysicalDeviceProperties2_.pNext = properties;
}

void lvk::VulkanContext::getBuildInfoBLAS(const AccelStructDesc& desc,
                                          VkAccelerationStructureGeometryKHR& outGeometry,
                                          VkAccelerationStructureBuildSizesInfoKHR& outSizesInfo) const {
  LVK_ASSERT(desc.type == AccelStructType_BLAS);
  LVK_ASSERT(desc.geometryType == AccelStructGeomType_Triangles);
  LVK_ASSERT(desc.numVertices);
  LVK_ASSERT(desc.indexBuffer.valid());
  LVK_ASSERT(desc.vertexBuffer.valid());
  LVK_ASSERT(desc.transformBuffer.valid());
  LVK_ASSERT(desc.buildRange.primitiveCount);

  LVK_ASSERT(buffersPool_.get(desc.indexBuffer)->vkUsageFlags_ & VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR);
  LVK_ASSERT(buffersPool_.get(desc.vertexBuffer)->vkUsageFlags_ & VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR);
  LVK_ASSERT(buffersPool_.get(desc.transformBuffer)->vkUsageFlags_ & VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR);

  VkGeometryFlagsKHR geometryFlags = 0;

  if (desc.geometryFlags & AccelStructGeometryFlagBits_Opaque) {
    geometryFlags |= VK_GEOMETRY_OPAQUE_BIT_KHR;
  }
  if (desc.geometryFlags & AccelStructGeometryFlagBits_NoDuplicateAnyHit) {
    geometryFlags |= VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR;
  }

  outGeometry = VkAccelerationStructureGeometryKHR{
      .sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR,
      .geometryType = VK_GEOMETRY_TYPE_TRIANGLES_KHR,
      .geometry =
          {
              .triangles =
                  {
                      .sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR,
                      .vertexFormat = vertexFormatToVkFormat(desc.vertexFormat),
                      .vertexData = {.deviceAddress = gpuAddress(desc.vertexBuffer)},
                      .vertexStride = desc.vertexStride ? desc.vertexStride : lvk::getVertexFormatSize(desc.vertexFormat),
                      .maxVertex = desc.numVertices - 1,
                      .indexType = VK_INDEX_TYPE_UINT32,
                      .indexData = {.deviceAddress = gpuAddress(desc.indexBuffer)},
                      .transformData = {.deviceAddress = gpuAddress(desc.transformBuffer)},
                  },
          },
      .flags = geometryFlags,
  };

  const VkAccelerationStructureBuildGeometryInfoKHR accelerationBuildGeometryInfo{
      .sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR,
      .type = VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR,
      .flags = VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR,
      .geometryCount = 1,
      .pGeometries = &outGeometry,
  };

  outSizesInfo.sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR;
  vkGetAccelerationStructureBuildSizesKHR(vkDevice_,
                                          VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR,
                                          &accelerationBuildGeometryInfo,
                                          &desc.buildRange.primitiveCount,
                                          &outSizesInfo);
  const uint32_t alignment = accelerationStructureProperties_.minAccelerationStructureScratchOffsetAlignment;
  outSizesInfo.accelerationStructureSize += alignment;
  outSizesInfo.updateScratchSize += alignment;
  outSizesInfo.buildScratchSize += alignment;
}

void lvk::VulkanContext::getBuildInfoTLAS(const AccelStructDesc& desc,
                                          VkAccelerationStructureGeometryKHR& outGeometry,
                                          VkAccelerationStructureBuildSizesInfoKHR& outSizesInfo) const {
  LVK_ASSERT(desc.type == AccelStructType_TLAS);
  LVK_ASSERT(desc.geometryType == AccelStructGeomType_Instances);
  LVK_ASSERT(desc.numVertices == 0);
  LVK_ASSERT(desc.instancesBuffer.valid());
  LVK_ASSERT(desc.buildRange.primitiveCount);
  LVK_ASSERT(buffersPool_.get(desc.instancesBuffer)->vkUsageFlags_ & VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR);

  VkGeometryFlagsKHR geometryFlags = 0;

  if (desc.geometryFlags & AccelStructGeometryFlagBits_Opaque) {
    geometryFlags |= VK_GEOMETRY_OPAQUE_BIT_KHR;
  }
  if (desc.geometryFlags & AccelStructGeometryFlagBits_NoDuplicateAnyHit) {
    geometryFlags |= VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR;
  }

  outGeometry = VkAccelerationStructureGeometryKHR{
      .sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR,
      .geometryType = VK_GEOMETRY_TYPE_INSTANCES_KHR,
      .geometry =
          {
              .instances =
                  {
                      .sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR,
                      .arrayOfPointers = VK_FALSE,
                      .data = {.deviceAddress = gpuAddress(desc.instancesBuffer)},
                  },
          },
      .flags = geometryFlags,
  };

  const VkAccelerationStructureBuildGeometryInfoKHR accelerationStructureBuildGeometryInfo = {
      .sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR,
      .type = VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR,
      .flags = buildFlagsToVkBuildAccelerationStructureFlags(desc.buildFlags),
      .geometryCount = 1,
      .pGeometries = &outGeometry,
  };

  outSizesInfo.sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR,
  vkGetAccelerationStructureBuildSizesKHR(vkDevice_,
                                          VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR,
                                          &accelerationStructureBuildGeometryInfo,
                                          &desc.buildRange.primitiveCount,
                                          &outSizesInfo);
  const uint32_t alignment = accelerationStructureProperties_.minAccelerationStructureScratchOffsetAlignment;
  outSizesInfo.accelerationStructureSize += alignment;
  outSizesInfo.updateScratchSize += alignment;
  outSizesInfo.buildScratchSize += alignment;
}

lvk::Result lvk::VulkanContext::initContext(const HWDeviceDesc& desc) {
  if (desc.guid == 0UL) {
    LLOGW("Invalid hardwareGuid(%lu)", desc.guid);
    return Result(Result::Code::RuntimeError, "Vulkan is not supported");
  }

  vkPhysicalDevice_ = (VkPhysicalDevice)desc.guid;

  useStaging_ = !isHostVisibleSingleHeapMemory(vkPhysicalDevice_);

  std::vector<VkExtensionProperties> allDeviceExtensions;
  getDeviceExtensionProps(vkPhysicalDevice_, allDeviceExtensions);
  if (config_.enableValidation) {
    for (const char* layer : kDefaultValidationLayers) {
      getDeviceExtensionProps(vkPhysicalDevice_, allDeviceExtensions, layer);
    }
  }

  if (hasExtension(VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME, allDeviceExtensions)) {
    addNextPhysicalDeviceProperties(&accelerationStructureProperties_);
  }
  if (hasExtension(VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME, allDeviceExtensions)) {
    addNextPhysicalDeviceProperties(&rayTracingPipelineProperties_);
  }

#if defined(VK_API_VERSION_1_4)
  if (config_.vulkanVersion >= VulkanVersion_1_4) {
    addNextPhysicalDeviceProperties(&vkPhysicalDeviceVulkan14Properties_);
    vkFeatures13_.pNext = &vkFeatures14_;
  }
#else
  LVK_ASSERT_MSG(config_.vulkanVersion == VulkanVersion_1_3, "Only Vulkan 1.3 is supported on this platform");
#endif // VK_API_VERSION_1_4

  vkGetPhysicalDeviceFeatures2(vkPhysicalDevice_, &vkFeatures10_);
  vkGetPhysicalDeviceProperties2(vkPhysicalDevice_, &vkPhysicalDeviceProperties2_);

  const uint32_t apiVersion = vkPhysicalDeviceProperties2_.properties.apiVersion;

  LLOGL("Vulkan physical device: %s\n", vkPhysicalDeviceProperties2_.properties.deviceName);
  LLOGL("           API version: %i.%i.%i.%i\n",
        VK_API_VERSION_MAJOR(apiVersion),
        VK_API_VERSION_MINOR(apiVersion),
        VK_API_VERSION_PATCH(apiVersion),
        VK_API_VERSION_VARIANT(apiVersion));
  LLOGL("           Driver info: %s %s\n", vkPhysicalDeviceDriverProperties_.driverName, vkPhysicalDeviceDriverProperties_.driverInfo);

  LLOGL("Vulkan physical device extensions:\n");

  // log available physical device extensions
  for (const VkExtensionProperties& ext : allDeviceExtensions) {
    LLOGL("  %s\n", ext.extensionName);
  }

  deviceQueues_.graphicsQueueFamilyIndex = lvk::findQueueFamilyIndex(vkPhysicalDevice_, VK_QUEUE_GRAPHICS_BIT);
  deviceQueues_.computeQueueFamilyIndex = lvk::findQueueFamilyIndex(vkPhysicalDevice_, VK_QUEUE_COMPUTE_BIT);

  if (deviceQueues_.graphicsQueueFamilyIndex == DeviceQueues::INVALID) {
    LLOGW("VK_QUEUE_GRAPHICS_BIT is not supported");
    return Result(Result::Code::RuntimeError, "VK_QUEUE_GRAPHICS_BIT is not supported");
  }

  if (deviceQueues_.computeQueueFamilyIndex == DeviceQueues::INVALID) {
    LLOGW("VK_QUEUE_COMPUTE_BIT is not supported");
    return Result(Result::Code::RuntimeError, "VK_QUEUE_COMPUTE_BIT is not supported");
  }

  const float queuePriority = 1.0f;

  const VkDeviceQueueCreateInfo ciQueue[2] = {
      {
          .sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
          .queueFamilyIndex = deviceQueues_.graphicsQueueFamilyIndex,
          .queueCount = 1,
          .pQueuePriorities = &queuePriority,
      },
      {
          .sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
          .queueFamilyIndex = deviceQueues_.computeQueueFamilyIndex,
          .queueCount = 1,
          .pQueuePriorities = &queuePriority,
      },
  };
  const uint32_t numQueues = ciQueue[0].queueFamilyIndex == ciQueue[1].queueFamilyIndex ? 1 : 2;

  enabledDeviceExtensionNames_ = {
      VK_KHR_SWAPCHAIN_EXTENSION_NAME,
  };

  if (hasExtension("VK_KHR_portability_subset", allDeviceExtensions)) {
    enabledDeviceExtensionNames_.push_back("VK_KHR_portability_subset");
  }

  for (const char* ext : config_.extensionsDevice) {
    if (ext) {
      enabledDeviceExtensionNames_.push_back(ext);
    }
  }

  VkPhysicalDeviceFeatures deviceFeatures10 = {
      .independentBlend = vkFeatures10_.features.independentBlend, // enable if supported
      .geometryShader = vkFeatures10_.features.geometryShader, // enable if supported
      .tessellationShader = vkFeatures10_.features.tessellationShader, // enable if supported
      .sampleRateShading = vkFeatures10_.features.sampleRateShading, // enable if supported
      .multiDrawIndirect = VK_TRUE,
      .drawIndirectFirstInstance = VK_TRUE,
      .depthBiasClamp = vkFeatures10_.features.depthBiasClamp, // enable if supported,
      .fillModeNonSolid = vkFeatures10_.features.fillModeNonSolid, // enable if supported
      .samplerAnisotropy = VK_TRUE,
      .textureCompressionBC = vkFeatures10_.features.textureCompressionBC, // enable if supported
      .vertexPipelineStoresAndAtomics = vkFeatures10_.features.vertexPipelineStoresAndAtomics, // enable if supported
      .fragmentStoresAndAtomics = VK_TRUE,
      .shaderImageGatherExtended = VK_TRUE,
      .shaderInt64 = vkFeatures10_.features.shaderInt64, // enable if supported
      .shaderInt16 = vkFeatures10_.features.shaderInt16, // enable if supported
  };
  VkPhysicalDeviceVulkan11Features deviceFeatures11 = {
      .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES,
      .pNext = config_.extensionsDeviceFeatures,
      .storageBuffer16BitAccess = VK_TRUE,
      .multiview = vkFeatures11_.multiview, // enable if supported
      .samplerYcbcrConversion = vkFeatures11_.samplerYcbcrConversion, // enable if supported
      .shaderDrawParameters = VK_TRUE,
  };
  VkPhysicalDeviceVulkan12Features deviceFeatures12 = {
      .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES,
      .pNext = &deviceFeatures11,
      .samplerMirrorClampToEdge = VK_TRUE,
      .drawIndirectCount = vkFeatures12_.drawIndirectCount, // enable if supported
      .storageBuffer8BitAccess = vkFeatures12_.storageBuffer8BitAccess, // enable if supported
      .uniformAndStorageBuffer8BitAccess = vkFeatures12_.uniformAndStorageBuffer8BitAccess, // enable if supported
      .shaderFloat16 = vkFeatures12_.shaderFloat16, // enable if supported
      .shaderInt8 = vkFeatures12_.shaderInt8, // enable if supported
      .descriptorIndexing = VK_TRUE,
      .shaderSampledImageArrayNonUniformIndexing = VK_TRUE,
      .descriptorBindingSampledImageUpdateAfterBind = VK_TRUE,
      .descriptorBindingStorageImageUpdateAfterBind = VK_TRUE,
      .descriptorBindingUpdateUnusedWhilePending = VK_TRUE,
      .descriptorBindingPartiallyBound = VK_TRUE,
      .descriptorBindingVariableDescriptorCount = VK_TRUE,
      .runtimeDescriptorArray = VK_TRUE,
      .scalarBlockLayout = VK_TRUE,
      .uniformBufferStandardLayout = VK_TRUE,
      .hostQueryReset = vkFeatures12_.hostQueryReset, // enable if supported
      .timelineSemaphore = VK_TRUE,
      .bufferDeviceAddress = VK_TRUE,
      .vulkanMemoryModel = vkFeatures12_.vulkanMemoryModel, // enable if supported
      .vulkanMemoryModelDeviceScope = vkFeatures12_.vulkanMemoryModelDeviceScope, // enable if supported
  };
  VkPhysicalDeviceVulkan13Features deviceFeatures13 = {
      .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES,
      .pNext = &deviceFeatures12,
      .shaderDemoteToHelperInvocation = vkFeatures13_.shaderDemoteToHelperInvocation, // enable if supported
      .subgroupSizeControl = VK_TRUE,
      .synchronization2 = VK_TRUE,
      .dynamicRendering = VK_TRUE,
      .maintenance4 = VK_TRUE,
  };
#if defined(VK_API_VERSION_1_4)
  VkPhysicalDeviceVulkan14Features deviceFeatures14 = {
      .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES,
      .pNext = &deviceFeatures13,
      .indexTypeUint8 = vkFeatures14_.indexTypeUint8,
      .dynamicRenderingLocalRead = VK_TRUE,
      .maintenance5 = VK_TRUE,
  };
#endif // VK_API_VERSION_1_4

#if defined(VK_API_VERSION_1_4)
  void* createInfoNext = config_.vulkanVersion >= VulkanVersion_1_4 ? (void*)&deviceFeatures14 : (void*)&deviceFeatures13;
#else
  void* createInfoNext = &deviceFeatures13;
#endif
  VkPhysicalDeviceAccelerationStructureFeaturesKHR accelerationStructureFeatures = {
      .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR,
      .accelerationStructure = VK_TRUE,
      .accelerationStructureCaptureReplay = VK_FALSE,
      .accelerationStructureIndirectBuild = VK_FALSE,
      .accelerationStructureHostCommands = VK_FALSE,
      .descriptorBindingAccelerationStructureUpdateAfterBind = VK_TRUE,
  };
  VkPhysicalDeviceRayTracingPipelineFeaturesKHR rayTracingFeatures = {
      .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR,
      .rayTracingPipeline = VK_TRUE,
      .rayTracingPipelineShaderGroupHandleCaptureReplay = VK_FALSE,
      .rayTracingPipelineShaderGroupHandleCaptureReplayMixed = VK_FALSE,
      .rayTracingPipelineTraceRaysIndirect = VK_TRUE,
      .rayTraversalPrimitiveCulling = VK_FALSE,
  };
  VkPhysicalDeviceRayQueryFeaturesKHR rayQueryFeatures = {
      .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR,
      .rayQuery = VK_TRUE,
  };
  VkPhysicalDeviceRayTracingInvocationReorderFeaturesEXT rayTracingInvocationReorderFeatures = {
      .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_EXT,
      .rayTracingInvocationReorder = VK_TRUE,
  };
  VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR swapchainMaintenance1Features = {
      .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR,
      .swapchainMaintenance1 = VK_TRUE,
  };
  VkPhysicalDeviceIndexTypeUint8FeaturesEXT indexTypeUint8Features = {
      .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT,
      .indexTypeUint8 = VK_TRUE,
  };
  VkPhysicalDeviceFaultFeaturesEXT deviceFaultFeatures = {
      .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT,
      .deviceFault = VK_TRUE,
  };
  VkPhysicalDeviceMaintenance5FeaturesKHR maintenance5Features = {
      .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR,
      .maintenance5 = VK_TRUE,
  };
  VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR dynamicRenderingLocalReadFeatures = {
      .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES_KHR,
      .dynamicRenderingLocalRead = VK_TRUE,
  };
  VkPhysicalDeviceShaderTileImageFeaturesEXT shaderTileImageFeatures = {
      .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT,
      .shaderTileImageColorReadAccess = VK_TRUE,
      .shaderTileImageDepthReadAccess = VK_TRUE,
  };
  VkPhysicalDeviceMeshShaderFeaturesEXT meshShaderFeatures = {
      .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT,
      .taskShader = VK_TRUE,
      .meshShader = VK_TRUE,
  };
  VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR presentModeLatestReadyFeatures = {
      .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR,
      .presentModeFifoLatestReady = VK_TRUE,
  };

  auto addExtension = [&allDeviceExtensions, this, &createInfoNext](const char* name, void* features = nullptr) mutable -> void {
    if (!hasExtension(name, allDeviceExtensions)) {
      LLOGW("Unsupported mandatory extension `%s`\n", name);
      return;
    }
    enabledDeviceExtensionNames_.push_back(name);
    if (features) {
      std::launder(reinterpret_cast<VkBaseOutStructure*>(features))->pNext =
          std::launder(reinterpret_cast<VkBaseOutStructure*>(createInfoNext));
      createInfoNext = features;
    }
  };

  auto addOptionalExtension = [&allDeviceExtensions, this, &createInfoNext](
                                  const char* name, bool& enabled, void* features = nullptr) mutable -> bool {
    if (!hasExtension(name, allDeviceExtensions))
      return false;
    enabled = true;
    enabledDeviceExtensionNames_.push_back(name);
    if (features) {
      std::launder(reinterpret_cast<VkBaseOutStructure*>(features))->pNext =
          std::launder(reinterpret_cast<VkBaseOutStructure*>(createInfoNext));
      createInfoNext = features;
    }
    return true;
  };
  auto addOptionalExtensions = [&allDeviceExtensions, this, &createInfoNext](
                                   const char* name1, const char* name2, bool& enabled, void* features = nullptr) mutable {
    if (!hasExtension(name1, allDeviceExtensions) || !hasExtension(name2, allDeviceExtensions))
      return;
    enabled = true;
    enabledDeviceExtensionNames_.push_back(name1);
    enabledDeviceExtensionNames_.push_back(name2);
    if (features) {
      std::launder(reinterpret_cast<VkBaseOutStructure*>(features))->pNext =
          std::launder(reinterpret_cast<VkBaseOutStructure*>(createInfoNext));
      createInfoNext = features;
    }
  };

  if (config_.vulkanVersion < VulkanVersion_1_4) {
    addExtension(VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME, nullptr);
    addExtension(VK_KHR_MAINTENANCE_5_EXTENSION_NAME, &maintenance5Features);
    addExtension(VK_KHR_DYNAMIC_RENDERING_LOCAL_READ_EXTENSION_NAME, &dynamicRenderingLocalReadFeatures);
    if (!addOptionalExtension(VK_KHR_INDEX_TYPE_UINT8_EXTENSION_NAME, has_8BitIndices_, &indexTypeUint8Features)) {
      addOptionalExtension(VK_EXT_INDEX_TYPE_UINT8_EXTENSION_NAME, has_8BitIndices_, &indexTypeUint8Features);
    }
  }
#if defined(LVK_WITH_TRACY)
  addOptionalExtension(VK_KHR_CALIBRATED_TIMESTAMPS_EXTENSION_NAME, has_KHR_calibrated_timestamps_, nullptr);
#endif
  addOptionalExtensions(VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME,
                        VK_KHR_DEFERRED_HOST_OPERATIONS_EXTENSION_NAME,
                        has_KHR_acceleration_structure_,
                        &accelerationStructureFeatures);
  addOptionalExtension(VK_KHR_RAY_QUERY_EXTENSION_NAME, has_KHR_ray_query_, &rayQueryFeatures);
  addOptionalExtension(VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME, has_KHR_ray_tracing_pipeline_, &rayTracingFeatures);
  addOptionalExtension(
      VK_EXT_RAY_TRACING_INVOCATION_REORDER_EXTENSION_NAME, has_EXT_ray_tracing_invocation_reorder, &rayTracingInvocationReorderFeatures);
  if (!addOptionalExtension(
          VK_KHR_SWAPCHAIN_MAINTENANCE_1_EXTENSION_NAME, has_KHR_swapchain_maintenance1_, &swapchainMaintenance1Features)) {
    addOptionalExtension(VK_EXT_SWAPCHAIN_MAINTENANCE_1_EXTENSION_NAME, has_KHR_swapchain_maintenance1_, &swapchainMaintenance1Features);
  }
  addOptionalExtension(VK_EXT_HDR_METADATA_EXTENSION_NAME, has_EXT_hdr_metadata_);
  addOptionalExtension(VK_EXT_DEVICE_FAULT_EXTENSION_NAME, has_EXT_device_fault_, &deviceFaultFeatures);
  addOptionalExtension(VK_EXT_SHADER_TILE_IMAGE_EXTENSION_NAME, has_EXT_shader_tile_image, &shaderTileImageFeatures);
  addOptionalExtension(VK_EXT_MESH_SHADER_EXTENSION_NAME, has_EXT_mesh_shader_, &meshShaderFeatures);
  addOptionalExtension(VK_KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME, has_KHR_shared_presentable_image_);
  addOptionalExtension(
      VK_KHR_PRESENT_MODE_FIFO_LATEST_READY_EXTENSION_NAME, has_KHR_present_mode_fifo_latest_ready_, &presentModeLatestReadyFeatures);

  // check extensions
  {
    std::string missingExtensions;
    for (const char* ext : enabledDeviceExtensionNames_) {
      if (!hasExtension(ext, allDeviceExtensions))
        missingExtensions += "\n   " + std::string(ext);
    }
    if (!missingExtensions.empty()) {
      MINILOG_LOG_PROC(minilog::FatalError, "Missing Vulkan device extensions: %s\n", missingExtensions.c_str());
      assert(false);
      return Result(Result::Code::RuntimeError);
    }
  }

  // check features
  {
    std::string missingFeatures;
#define CHECK_VULKAN_FEATURE(reqFeatures, availFeatures, feature, version)     \
  if ((reqFeatures.feature == VK_TRUE) && (availFeatures.feature == VK_FALSE)) \
    missingFeatures.append("\n   " version " ." #feature);
#define CHECK_FEATURE_1_0(feature) CHECK_VULKAN_FEATURE(deviceFeatures10, vkFeatures10_.features, feature, "1.0 ");
    CHECK_FEATURE_1_0(robustBufferAccess);
    CHECK_FEATURE_1_0(fullDrawIndexUint32);
    CHECK_FEATURE_1_0(imageCubeArray);
    CHECK_FEATURE_1_0(independentBlend);
    CHECK_FEATURE_1_0(geometryShader);
    CHECK_FEATURE_1_0(tessellationShader);
    CHECK_FEATURE_1_0(sampleRateShading);
    CHECK_FEATURE_1_0(dualSrcBlend);
    CHECK_FEATURE_1_0(logicOp);
    CHECK_FEATURE_1_0(multiDrawIndirect);
    CHECK_FEATURE_1_0(drawIndirectFirstInstance);
    CHECK_FEATURE_1_0(depthClamp);
    CHECK_FEATURE_1_0(depthBiasClamp);
    CHECK_FEATURE_1_0(fillModeNonSolid);
    CHECK_FEATURE_1_0(depthBounds);
    CHECK_FEATURE_1_0(wideLines);
    CHECK_FEATURE_1_0(largePoints);
    CHECK_FEATURE_1_0(alphaToOne);
    CHECK_FEATURE_1_0(multiViewport);
    CHECK_FEATURE_1_0(samplerAnisotropy);
    CHECK_FEATURE_1_0(textureCompressionETC2);
    CHECK_FEATURE_1_0(textureCompressionASTC_LDR);
    CHECK_FEATURE_1_0(textureCompressionBC);
    CHECK_FEATURE_1_0(occlusionQueryPrecise);
    CHECK_FEATURE_1_0(pipelineStatisticsQuery);
    CHECK_FEATURE_1_0(vertexPipelineStoresAndAtomics);
    CHECK_FEATURE_1_0(fragmentStoresAndAtomics);
    CHECK_FEATURE_1_0(shaderTessellationAndGeometryPointSize);
    CHECK_FEATURE_1_0(shaderImageGatherExtended);
    CHECK_FEATURE_1_0(shaderStorageImageExtendedFormats);
    CHECK_FEATURE_1_0(shaderStorageImageMultisample);
    CHECK_FEATURE_1_0(shaderStorageImageReadWithoutFormat);
    CHECK_FEATURE_1_0(shaderStorageImageWriteWithoutFormat);
    CHECK_FEATURE_1_0(shaderUniformBufferArrayDynamicIndexing);
    CHECK_FEATURE_1_0(shaderSampledImageArrayDynamicIndexing);
    CHECK_FEATURE_1_0(shaderStorageBufferArrayDynamicIndexing);
    CHECK_FEATURE_1_0(shaderStorageImageArrayDynamicIndexing);
    CHECK_FEATURE_1_0(shaderClipDistance);
    CHECK_FEATURE_1_0(shaderCullDistance);
    CHECK_FEATURE_1_0(shaderFloat64);
    CHECK_FEATURE_1_0(shaderInt64);
    CHECK_FEATURE_1_0(shaderInt16);
    CHECK_FEATURE_1_0(shaderResourceResidency);
    CHECK_FEATURE_1_0(shaderResourceMinLod);
    CHECK_FEATURE_1_0(sparseBinding);
    CHECK_FEATURE_1_0(sparseResidencyBuffer);
    CHECK_FEATURE_1_0(sparseResidencyImage2D);
    CHECK_FEATURE_1_0(sparseResidencyImage3D);
    CHECK_FEATURE_1_0(sparseResidency2Samples);
    CHECK_FEATURE_1_0(sparseResidency4Samples);
    CHECK_FEATURE_1_0(sparseResidency8Samples);
    CHECK_FEATURE_1_0(sparseResidency16Samples);
    CHECK_FEATURE_1_0(sparseResidencyAliased);
    CHECK_FEATURE_1_0(variableMultisampleRate);
    CHECK_FEATURE_1_0(inheritedQueries);
#undef CHECK_FEATURE_1_0
#define CHECK_FEATURE_1_1(feature) CHECK_VULKAN_FEATURE(deviceFeatures11, vkFeatures11_, feature, "1.1 ");
    CHECK_FEATURE_1_1(storageBuffer16BitAccess);
    CHECK_FEATURE_1_1(uniformAndStorageBuffer16BitAccess);
    CHECK_FEATURE_1_1(storagePushConstant16);
    CHECK_FEATURE_1_1(storageInputOutput16);
    CHECK_FEATURE_1_1(multiview);
    CHECK_FEATURE_1_1(multiviewGeometryShader);
    CHECK_FEATURE_1_1(multiviewTessellationShader);
    CHECK_FEATURE_1_1(variablePointersStorageBuffer);
    CHECK_FEATURE_1_1(variablePointers);
    CHECK_FEATURE_1_1(protectedMemory);
    CHECK_FEATURE_1_1(samplerYcbcrConversion);
    CHECK_FEATURE_1_1(shaderDrawParameters);
#undef CHECK_FEATURE_1_1
#define CHECK_FEATURE_1_2(feature) CHECK_VULKAN_FEATURE(deviceFeatures12, vkFeatures12_, feature, "1.2 ");
    CHECK_FEATURE_1_2(samplerMirrorClampToEdge);
    CHECK_FEATURE_1_2(drawIndirectCount);
    CHECK_FEATURE_1_2(storageBuffer8BitAccess);
    CHECK_FEATURE_1_2(uniformAndStorageBuffer8BitAccess);
    CHECK_FEATURE_1_2(storagePushConstant8);
    CHECK_FEATURE_1_2(shaderBufferInt64Atomics);
    CHECK_FEATURE_1_2(shaderSharedInt64Atomics);
    CHECK_FEATURE_1_2(shaderFloat16);
    CHECK_FEATURE_1_2(shaderInt8);
    CHECK_FEATURE_1_2(descriptorIndexing);
    CHECK_FEATURE_1_2(shaderInputAttachmentArrayDynamicIndexing);
    CHECK_FEATURE_1_2(shaderUniformTexelBufferArrayDynamicIndexing);
    CHECK_FEATURE_1_2(shaderStorageTexelBufferArrayDynamicIndexing);
    CHECK_FEATURE_1_2(shaderUniformBufferArrayNonUniformIndexing);
    CHECK_FEATURE_1_2(shaderSampledImageArrayNonUniformIndexing);
    CHECK_FEATURE_1_2(shaderStorageBufferArrayNonUniformIndexing);
    CHECK_FEATURE_1_2(shaderStorageImageArrayNonUniformIndexing);
    CHECK_FEATURE_1_2(shaderInputAttachmentArrayNonUniformIndexing);
    CHECK_FEATURE_1_2(shaderUniformTexelBufferArrayNonUniformIndexing);
    CHECK_FEATURE_1_2(shaderStorageTexelBufferArrayNonUniformIndexing);
    CHECK_FEATURE_1_2(descriptorBindingUniformBufferUpdateAfterBind);
    CHECK_FEATURE_1_2(descriptorBindingSampledImageUpdateAfterBind);
    CHECK_FEATURE_1_2(descriptorBindingStorageImageUpdateAfterBind);
    CHECK_FEATURE_1_2(descriptorBindingStorageBufferUpdateAfterBind);
    CHECK_FEATURE_1_2(descriptorBindingUniformTexelBufferUpdateAfterBind);
    CHECK_FEATURE_1_2(descriptorBindingStorageTexelBufferUpdateAfterBind);
    CHECK_FEATURE_1_2(descriptorBindingUpdateUnusedWhilePending);
    CHECK_FEATURE_1_2(descriptorBindingPartiallyBound);
    CHECK_FEATURE_1_2(descriptorBindingVariableDescriptorCount);
    CHECK_FEATURE_1_2(runtimeDescriptorArray);
    CHECK_FEATURE_1_2(samplerFilterMinmax);
    CHECK_FEATURE_1_2(scalarBlockLayout);
    CHECK_FEATURE_1_2(imagelessFramebuffer);
    CHECK_FEATURE_1_2(uniformBufferStandardLayout);
    CHECK_FEATURE_1_2(shaderSubgroupExtendedTypes);
    CHECK_FEATURE_1_2(separateDepthStencilLayouts);
    CHECK_FEATURE_1_2(hostQueryReset);
    CHECK_FEATURE_1_2(timelineSemaphore);
    CHECK_FEATURE_1_2(bufferDeviceAddress);
    CHECK_FEATURE_1_2(bufferDeviceAddressCaptureReplay);
    CHECK_FEATURE_1_2(bufferDeviceAddressMultiDevice);
    CHECK_FEATURE_1_2(vulkanMemoryModel);
    CHECK_FEATURE_1_2(vulkanMemoryModelDeviceScope);
    CHECK_FEATURE_1_2(vulkanMemoryModelAvailabilityVisibilityChains);
    CHECK_FEATURE_1_2(shaderOutputViewportIndex);
    CHECK_FEATURE_1_2(shaderOutputLayer);
    CHECK_FEATURE_1_2(subgroupBroadcastDynamicId);
#undef CHECK_FEATURE_1_2
#define CHECK_FEATURE_1_3(feature) CHECK_VULKAN_FEATURE(deviceFeatures13, vkFeatures13_, feature, "1.3 ");
    CHECK_FEATURE_1_3(robustImageAccess);
    CHECK_FEATURE_1_3(inlineUniformBlock);
    CHECK_FEATURE_1_3(descriptorBindingInlineUniformBlockUpdateAfterBind);
    CHECK_FEATURE_1_3(pipelineCreationCacheControl);
    CHECK_FEATURE_1_3(privateData);
    CHECK_FEATURE_1_3(shaderDemoteToHelperInvocation);
    CHECK_FEATURE_1_3(shaderTerminateInvocation);
    CHECK_FEATURE_1_3(subgroupSizeControl);
    CHECK_FEATURE_1_3(computeFullSubgroups);
    CHECK_FEATURE_1_3(synchronization2);
    CHECK_FEATURE_1_3(textureCompressionASTC_HDR);
    CHECK_FEATURE_1_3(shaderZeroInitializeWorkgroupMemory);
    CHECK_FEATURE_1_3(dynamicRendering);
    CHECK_FEATURE_1_3(shaderIntegerDotProduct);
    CHECK_FEATURE_1_3(maintenance4);
#undef CHECK_FEATURE_1_3
    if (!missingFeatures.empty()) {
      MINILOG_LOG_PROC(
#ifndef __APPLE__
          minilog::FatalError,
#else
          minilog::Warning,
#endif
          "Missing Vulkan features: %s\n",
          missingFeatures.c_str());
      // Do not exit here in case of MoltenVK, some 1.3 features are available via extensions.
#ifndef __APPLE__
      assert(false);
      return Result(Result::Code::RuntimeError);
#endif
    }
  }

  const VkDeviceCreateInfo ci = {
      .sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
      .pNext = createInfoNext,
      .queueCreateInfoCount = numQueues,
      .pQueueCreateInfos = ciQueue,
      .enabledExtensionCount = (uint32_t)enabledDeviceExtensionNames_.size(),
      .ppEnabledExtensionNames = enabledDeviceExtensionNames_.data(),
      .pEnabledFeatures = &deviceFeatures10,
  };
  VK_ASSERT_RETURN(vkCreateDevice(vkPhysicalDevice_, &ci, nullptr, &vkDevice_));

  volkLoadDevice(vkDevice_);

  vkGetDeviceQueue(vkDevice_, deviceQueues_.graphicsQueueFamilyIndex, 0, &deviceQueues_.graphicsQueue);
  vkGetDeviceQueue(vkDevice_, deviceQueues_.computeQueueFamilyIndex, 0, &deviceQueues_.computeQueue);

  VK_ASSERT(lvk::setDebugObjectName(vkDevice_, VK_OBJECT_TYPE_DEVICE, (uint64_t)vkDevice_, "Device: VulkanContext::vkDevice_"));

  immediate_ = std::make_unique<lvk::VulkanImmediateCommands>(
      vkDevice_, deviceQueues_.graphicsQueueFamilyIndex, has_EXT_device_fault_, "VulkanContext::immediate_");

  // create Vulkan pipeline cache
  {
    const VkPipelineCacheCreateInfo ci = {
        VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO,
        nullptr,
        VkPipelineCacheCreateFlags(0),
        config_.pipelineCacheDataSize,
        config_.pipelineCacheData,
    };
    vkCreatePipelineCache(vkDevice_, &ci, nullptr, &pipelineCache_);
  }

  if (LVK_VULKAN_USE_VMA) {
    pimpl_->vma_ = lvk::createVmaAllocator(
        vkPhysicalDevice_, vkDevice_, vkInstance_, apiVersion > VK_API_VERSION_1_3 ? VK_API_VERSION_1_3 : apiVersion);
    LVK_ASSERT(pimpl_->vma_ != VK_NULL_HANDLE);
  }

  stagingDevice_ = std::make_unique<lvk::VulkanStagingDevice>(*this);

  // default texture
  {
    const uint32_t pixel = 0xFF000000;
    Result result;
    dummyTexture_ = this->createTexture(
                            {
                                .format = lvk::Format_RGBA_UN8,
                                .dimensions = {1, 1, 1},
                                .usage = TextureUsageBits_Sampled | TextureUsageBits_Storage,
                                .data = &pixel,
                            },
                            "Dummy 1x1 (black)",
                            &result)
                        .release();
    if (!LVK_VERIFY(result.isOk())) {
      return result;
    }
    LVK_ASSERT(texturesPool_.numObjects() == 1);
  }

  // default sampler
  LVK_ASSERT(samplersPool_.numObjects() == 0);
  createSampler(
      {
          .sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,
          .pNext = nullptr,
          .flags = 0,
          .magFilter = VK_FILTER_LINEAR,
          .minFilter = VK_FILTER_LINEAR,
          .mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR,
          .addressModeU = VK_SAMPLER_ADDRESS_MODE_REPEAT,
          .addressModeV = VK_SAMPLER_ADDRESS_MODE_REPEAT,
          .addressModeW = VK_SAMPLER_ADDRESS_MODE_REPEAT,
          .mipLodBias = 0.0f,
          .anisotropyEnable = VK_FALSE,
          .maxAnisotropy = 0.0f,
          .compareEnable = VK_FALSE,
          .compareOp = VK_COMPARE_OP_ALWAYS,
          .minLod = 0.0f,
          .maxLod = static_cast<float>(LVK_MAX_MIP_LEVELS - 1),
          .borderColor = VK_BORDER_COLOR_INT_OPAQUE_BLACK,
          .unnormalizedCoordinates = VK_FALSE,
      },
      nullptr,
      Format_Invalid,
      "Sampler: default");

  querySurfaceCapabilities();

#if defined(LVK_WITH_TRACY_GPU)
  std::vector<VkTimeDomainEXT> timeDomains;

  if (has_KHR_calibrated_timestamps_) {
    uint32_t numTimeDomains = 0;
    VK_ASSERT(vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(vkPhysicalDevice_, &numTimeDomains, nullptr));
    timeDomains.resize(numTimeDomains);
    VK_ASSERT(vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(vkPhysicalDevice_, &numTimeDomains, timeDomains.data()));
  }

  const bool hasHostQuery = vkFeatures12_.hostQueryReset && [&timeDomains]() -> bool {
    for (VkTimeDomainEXT domain : timeDomains)
      if (domain == VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT || domain == VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT)
        return true;
    return false;
  }();

  if (hasHostQuery) {
    pimpl_->tracyVkCtx_ = TracyVkContextHostCalibrated(
        vkPhysicalDevice_, vkDevice_, vkResetQueryPool, vkGetPhysicalDeviceCalibrateableTimeDomainsEXT, vkGetCalibratedTimestampsEXT);
  } else {
    const VkCommandPoolCreateInfo ciCommandPool = {
        .sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,
        .flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT | VK_COMMAND_POOL_CREATE_TRANSIENT_BIT,
        .queueFamilyIndex = deviceQueues_.graphicsQueueFamilyIndex,
    };
    VK_ASSERT(vkCreateCommandPool(vkDevice_, &ciCommandPool, nullptr, &pimpl_->tracyCommandPool_));
    VK_ASSERT(lvk::setDebugObjectName(
        vkDevice_, VK_OBJECT_TYPE_COMMAND_POOL, (uint64_t)pimpl_->tracyCommandPool_, "Command Pool: VulkanContextImpl::tracyCommandPool_"));
    const VkCommandBufferAllocateInfo aiCommandBuffer = {
        .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,
        .commandPool = pimpl_->tracyCommandPool_,
        .level = VK_COMMAND_BUFFER_LEVEL_PRIMARY,
        .commandBufferCount = 1,
    };
    VK_ASSERT(vkAllocateCommandBuffers(vkDevice_, &aiCommandBuffer, &pimpl_->tracyCommandBuffer_));
    if (has_KHR_calibrated_timestamps_) {
      pimpl_->tracyVkCtx_ = TracyVkContextCalibrated(vkPhysicalDevice_,
                                                     vkDevice_,
                                                     deviceQueues_.graphicsQueue,
                                                     pimpl_->tracyCommandBuffer_,
                                                     vkGetPhysicalDeviceCalibrateableTimeDomainsEXT,
                                                     vkGetCalibratedTimestampsEXT);
    } else {
      pimpl_->tracyVkCtx_ = TracyVkContext(vkPhysicalDevice_, vkDevice_, deviceQueues_.graphicsQueue, pimpl_->tracyCommandBuffer_);
    };
  }
  LVK_ASSERT(pimpl_->tracyVkCtx_);
#endif // LVK_WITH_TRACY_GPU

  // add one empty dset
  DSets_.push_back({});

  // create one separate DSL for input attachments
  {
    VkDescriptorSetLayoutBinding bindings[LVK_MAX_COLOR_ATTACHMENTS];
    for (uint32_t i = 0; i != LVK_ARRAY_NUM_ELEMENTS(bindings); i++) {
      bindings[i] = lvk::getDSLBinding(i, VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, 1, VK_SHADER_STAGE_FRAGMENT_BIT);
    };
    const VkPhysicalDeviceLimits& limits = this->getVkPhysicalDeviceProperties().limits;
    const VkDescriptorSetLayoutCreateInfo dslci = {
        .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
        .flags = VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT,
        .bindingCount = std::min((uint32_t)LVK_MAX_COLOR_ATTACHMENTS, limits.maxPerStageDescriptorInputAttachments),
        .pBindings = bindings,
    };
    VK_ASSERT(vkCreateDescriptorSetLayout(vkDevice_, &dslci, nullptr, &dslInputAttachments_));
    VK_ASSERT(lvk::setDebugObjectName(vkDevice_,
                                      VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT,
                                      (uint64_t)dslInputAttachments_,
                                      "Descriptor Set Layout: VulkanContext::dslInputAttachments_"));
  }
  return Result();
}

lvk::Result lvk::VulkanContext::initSwapchain(uint32_t width, uint32_t height) {
  if (!vkDevice_ || !immediate_) {
    LLOGW("Call initContext() first");
    return Result(Result::Code::RuntimeError, "Call initContext() first");
  }

  if (swapchain_) {
    // destroy the old swapchain first
    // TODO: replace with VK_EXT_swapchain_maintenance1
    VK_ASSERT(vkDeviceWaitIdle(vkDevice_));
    swapchain_ = nullptr;
    vkDestroySemaphore(vkDevice_, timelineSemaphore_, nullptr);
  }

  if (!width || !height) {
    return Result(Result::Code::ArgumentOutOfRange, "Width and Height cannot be 0");
  }

  swapchain_ = std::make_unique<lvk::VulkanSwapchain>(*this, width, height);

  timelineSemaphore_ = lvk::createSemaphoreTimeline(vkDevice_, swapchain_->getNumSwapchainImages() - 1, "Semaphore: timelineSemaphore_");

  return swapchain_ ? Result() : Result(Result::Code::RuntimeError, "Failed to create swapchain");
}

lvk::Result lvk::VulkanContext::growDescriptorPool(VulkanContext::DescriptorSet& dset,
                                                   uint32_t maxTextures,
                                                   uint32_t maxSamplers,
                                                   uint32_t maxAccelStructs) {
  if (maxTextures == dset.maxTextures && maxSamplers == dset.maxSamplers && maxAccelStructs == dset.maxAccelStructs &&
      !awaitingNewImmutableSamplers_) {
    return Result();
  }

  dset.maxTextures = maxTextures;
  dset.maxSamplers = maxSamplers;
  dset.maxAccelStructs = maxAccelStructs;

#if LVK_VULKAN_PRINT_COMMANDS
  LLOGL("growDescriptorPool(%u, %u)\n", maxTextures, maxSamplers);
#endif // LVK_VULKAN_PRINT_COMMANDS

  if (!LVK_VERIFY(maxTextures <= vkPhysicalDeviceVulkan12Properties_.maxDescriptorSetUpdateAfterBindSampledImages)) {
    LLOGW("Max Textures exceeded: %u (max %u)",
          maxTextures,
          vkPhysicalDeviceVulkan12Properties_.maxDescriptorSetUpdateAfterBindSampledImages);
  }

  if (!LVK_VERIFY(maxSamplers <= vkPhysicalDeviceVulkan12Properties_.maxDescriptorSetUpdateAfterBindSamplers)) {
    LLOGW("Max Samplers exceeded %u (max %u)", maxSamplers, vkPhysicalDeviceVulkan12Properties_.maxDescriptorSetUpdateAfterBindSamplers);
  }

  if (dset.vkDSL != VK_NULL_HANDLE) {
    deferredTask(
        std::packaged_task<void()>([device = vkDevice_, dsl = dset.vkDSL]() { vkDestroyDescriptorSetLayout(device, dsl, nullptr); }));
  }
  if (dset.vkDPool != VK_NULL_HANDLE) {
    deferredTask(std::packaged_task<void()>([device = vkDevice_, dp = dset.vkDPool]() { vkDestroyDescriptorPool(device, dp, nullptr); }));
  }

  VkSampler firstYcbcrSampler = VK_NULL_HANDLE;

  // check if we have any YUV images
  for (const auto& obj : texturesPool_.objects_) {
    const VulkanImage* img = &obj.obj_;
    // multisampled images cannot be directly accessed from shaders
    const bool isTextureAvailable = (img->vkSamples_ & VK_SAMPLE_COUNT_1_BIT) == VK_SAMPLE_COUNT_1_BIT;
    const bool isYUVImage = isTextureAvailable && img->isSampledImage() && lvk::getNumImagePlanes(img->vkImageFormat_) > 1;
    if (isYUVImage) {
      // find the first Ycbcr sampler and use it as a dummy
      // (https://docs.vulkan.org/spec/latest/chapters/descriptorsets.html#VUID-VkDescriptorSetLayoutBinding-descriptorType-12200)
      firstYcbcrSampler = getOrCreateYcbcrSampler(vkFormatToFormat(img->vkImageFormat_));
      break;
    }
  }

  std::vector<VkSampler> immutableSamplers;
  const VkSampler* immutableSamplersData = nullptr;

  if (firstYcbcrSampler) {
    immutableSamplers.resize(maxTextures, firstYcbcrSampler);
    for (size_t i = 0; i != texturesPool_.objects_.size(); i++) {
      const auto& obj = texturesPool_.objects_[i];
      const VulkanImage* img = &obj.obj_;
      // multisampled images cannot be directly accessed from shaders
      const bool isTextureAvailable = (img->vkSamples_ & VK_SAMPLE_COUNT_1_BIT) == VK_SAMPLE_COUNT_1_BIT;
      const bool isYUVImage = isTextureAvailable && img->isSampledImage() && lvk::getNumImagePlanes(img->vkImageFormat_) > 1;
      immutableSamplers[i] = isYUVImage ? getOrCreateYcbcrSampler(vkFormatToFormat(img->vkImageFormat_)) : firstYcbcrSampler;
    }
    immutableSamplersData = immutableSamplers.data();
  }

  // create default descriptor set layout which is going to be shared by graphics pipelines
  VkShaderStageFlags stageFlags = VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT |
                                  VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT | VK_SHADER_STAGE_FRAGMENT_BIT | VK_SHADER_STAGE_COMPUTE_BIT;
  if (has_KHR_ray_tracing_pipeline_) {
    stageFlags |= (VK_SHADER_STAGE_RAYGEN_BIT_KHR | VK_SHADER_STAGE_ANY_HIT_BIT_KHR | VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR |
                   VK_SHADER_STAGE_MISS_BIT_KHR | VK_SHADER_STAGE_INTERSECTION_BIT_KHR | VK_SHADER_STAGE_CALLABLE_BIT_KHR);
  }
  const VkDescriptorSetLayoutBinding bindings[kBinding_NumBindings] = {
      lvk::getDSLBinding(kBinding_Textures, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, maxTextures, stageFlags),
      lvk::getDSLBinding(kBinding_Samplers, VK_DESCRIPTOR_TYPE_SAMPLER, maxSamplers, stageFlags),
      lvk::getDSLBinding(kBinding_StorageImages, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, maxTextures, stageFlags),
      lvk::getDSLBinding(kBinding_YUVImages,
                         VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
                         (uint32_t)immutableSamplers.size() ? maxTextures : 0,
                         stageFlags,
                         immutableSamplersData),
      lvk::getDSLBinding(kBinding_AccelerationStructures, VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR, maxAccelStructs, stageFlags),
  };
  const uint32_t flags = VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT | VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT |
                         VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT;
  VkDescriptorBindingFlags bindingFlags[kBinding_NumBindings];
  for (int i = 0; i < kBinding_NumBindings; ++i) {
    bindingFlags[i] = flags;
  }
  const VkDescriptorSetLayoutBindingFlagsCreateInfo setLayoutBindingFlagsCI = {
      .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT,
      .bindingCount = uint32_t(has_KHR_acceleration_structure_ ? kBinding_NumBindings : kBinding_NumBindings - 1),
      .pBindingFlags = bindingFlags,
  };
  const VkDescriptorSetLayoutCreateInfo dslci = {
      .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
      .pNext = &setLayoutBindingFlagsCI,
      .flags = VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT,
      .bindingCount = uint32_t(has_KHR_acceleration_structure_ ? kBinding_NumBindings : kBinding_NumBindings - 1),
      .pBindings = bindings,
  };
  VK_ASSERT(vkCreateDescriptorSetLayout(vkDevice_, &dslci, nullptr, &dset.vkDSL));
  VK_ASSERT(lvk::setDebugObjectName(
      vkDevice_, VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT, (uint64_t)dset.vkDSL, "Descriptor Set Layout: VulkanContext::vkDSL"));

  {
    // create default descriptor pool and allocate 1 descriptor set
    VkDescriptorPoolSize poolSizes[kBinding_NumBindings] = {
        VkDescriptorPoolSize{VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, maxTextures},
        VkDescriptorPoolSize{VK_DESCRIPTOR_TYPE_SAMPLER, maxSamplers},
        VkDescriptorPoolSize{VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, maxTextures},
    };
    uint32_t numPoolSizes = 3;
    if (!immutableSamplers.empty()) {
      poolSizes[numPoolSizes++] = VkDescriptorPoolSize{
          VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
          pimpl_->maxCombinedImageSamplerDescriptorCount_ * maxTextures,
      };
    }
    if (has_KHR_acceleration_structure_) {
      poolSizes[numPoolSizes++] = VkDescriptorPoolSize{VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR, maxAccelStructs};
    }
    LVK_ASSERT(numPoolSizes <= kBinding_NumBindings);
    const VkDescriptorPoolCreateInfo ci = {
        .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO,
        .flags = VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT,
        .maxSets = 1,
        .poolSizeCount = numPoolSizes,
        .pPoolSizes = poolSizes,
    };
    VK_ASSERT_RETURN(vkCreateDescriptorPool(vkDevice_, &ci, nullptr, &dset.vkDPool));
    const VkDescriptorSetAllocateInfo ai = {
        .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO,
        .descriptorPool = dset.vkDPool,
        .descriptorSetCount = 1,
        .pSetLayouts = &dset.vkDSL,
    };
    VK_ASSERT_RETURN(vkAllocateDescriptorSets(vkDevice_, &ai, &dset.vkDSet));
  }

  awaitingNewImmutableSamplers_ = false;

  return Result();
}

lvk::BufferHandle lvk::VulkanContext::createBuffer(VkDeviceSize bufferSize,
                                                   VkBufferUsageFlags usageFlags,
                                                   VkMemoryPropertyFlags memFlags,
                                                   lvk::Result* outResult,
                                                   const char* debugName) {
  LVK_PROFILER_FUNCTION_COLOR(LVK_PROFILER_COLOR_CREATE);

  LVK_ASSERT(bufferSize > 0);

#define ENSURE_BUFFER_SIZE(flag, maxSize)                                                             \
  if (usageFlags & flag) {                                                                            \
    if (!LVK_VERIFY(bufferSize <= maxSize)) {                                                         \
      Result::setResult(outResult, Result(Result::Code::RuntimeError, "Buffer size exceeded" #flag)); \
      return {};                                                                                      \
    }                                                                                                 \
  }

  const VkPhysicalDeviceLimits& limits = getVkPhysicalDeviceProperties().limits;

  ENSURE_BUFFER_SIZE(VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT, limits.maxUniformBufferRange);
  ENSURE_BUFFER_SIZE(VK_BUFFER_USAGE_STORAGE_BUFFER_BIT, limits.maxStorageBufferRange);
  // any buffer
  ENSURE_BUFFER_SIZE(VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM, vkPhysicalDeviceVulkan11Properties_.maxMemoryAllocationSize);
#undef ENSURE_BUFFER_SIZE

  VulkanBuffer buf = {
      .bufferSize_ = bufferSize,
      .vkUsageFlags_ = usageFlags,
      .vkMemFlags_ = memFlags,
  };

  const VkBufferCreateInfo ci = {
      .sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
      .pNext = nullptr,
      .flags = 0,
      .size = bufferSize,
      .usage = usageFlags,
      .sharingMode = VK_SHARING_MODE_EXCLUSIVE,
      .queueFamilyIndexCount = 0,
      .pQueueFamilyIndices = nullptr,
  };

  if (LVK_VULKAN_USE_VMA) {
    VmaAllocationCreateInfo vmaAllocInfo = {};

    // Initialize VmaAllocation Info
    if (memFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) {
      vmaAllocInfo = {
          .flags = VMA_ALLOCATION_CREATE_MAPPED_BIT | VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT,
          .requiredFlags = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT,
          .preferredFlags = VK_MEMORY_PROPERTY_HOST_COHERENT_BIT | VK_MEMORY_PROPERTY_HOST_CACHED_BIT,
      };
    }

    if (memFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) {
      // Check if coherent buffer is available.
      VK_ASSERT(vkCreateBuffer(vkDevice_, &ci, nullptr, &buf.vkBuffer_));
      VkMemoryRequirements requirements = {};
      vkGetBufferMemoryRequirements(vkDevice_, buf.vkBuffer_, &requirements);
      vkDestroyBuffer(vkDevice_, buf.vkBuffer_, nullptr);
      buf.vkBuffer_ = VK_NULL_HANDLE;

      if (requirements.memoryTypeBits & VK_MEMORY_PROPERTY_HOST_COHERENT_BIT) {
        vmaAllocInfo.requiredFlags |= VK_MEMORY_PROPERTY_HOST_COHERENT_BIT;
        buf.isCoherentMemory_ = true;
      }
    }

    vmaAllocInfo.usage = VMA_MEMORY_USAGE_AUTO;

    vmaCreateBufferWithAlignment((VmaAllocator)getVmaAllocator(), &ci, &vmaAllocInfo, 16, &buf.vkBuffer_, &buf.vmaAllocation_, nullptr);

    // handle memory-mapped buffers
    if (memFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) {
      vmaMapMemory((VmaAllocator)getVmaAllocator(), buf.vmaAllocation_, &buf.mappedPtr_);
    }
  } else {
    // create buffer
    VK_ASSERT(vkCreateBuffer(vkDevice_, &ci, nullptr, &buf.vkBuffer_));

    // back the buffer with some memory
    {
      const VkBufferMemoryRequirementsInfo2 ri = {
          .sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2,
          .buffer = buf.vkBuffer_,
      };
      VkMemoryRequirements2 requirements = {
          .sType = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2,
      };
      vkGetBufferMemoryRequirements2(vkDevice_, &ri, &requirements);
      if (requirements.memoryRequirements.memoryTypeBits & VK_MEMORY_PROPERTY_HOST_COHERENT_BIT) {
        buf.isCoherentMemory_ = true;
      }

      VK_ASSERT(lvk::allocateMemory2(vkPhysicalDevice_, vkDevice_, &requirements, memFlags, &buf.vkMemory_));
      VK_ASSERT(vkBindBufferMemory(vkDevice_, buf.vkBuffer_, buf.vkMemory_, 0));
    }

    // handle memory-mapped buffers
    if (memFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) {
      VK_ASSERT(vkMapMemory(vkDevice_, buf.vkMemory_, 0, buf.bufferSize_, 0, &buf.mappedPtr_));
    }
  }

  LVK_ASSERT(buf.vkBuffer_ != VK_NULL_HANDLE);

  // set debug name
  VK_ASSERT(lvk::setDebugObjectName(vkDevice_, VK_OBJECT_TYPE_BUFFER, (uint64_t)buf.vkBuffer_, debugName));

  // handle shader access
  if (usageFlags & VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT) {
    const VkBufferDeviceAddressInfo ai = {
        .sType = VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO,
        .buffer = buf.vkBuffer_,
    };
    buf.vkDeviceAddress_ = vkGetBufferDeviceAddress(vkDevice_, &ai);
    LVK_ASSERT(buf.vkDeviceAddress_);
  }

  return buffersPool_.create(std::move(buf));
}

void lvk::VulkanContext::bindDefaultDescriptorSets(VkCommandBuffer cmdBuf, VkPipelineBindPoint bindPoint, VkPipelineLayout layout) const {
  LVK_PROFILER_FUNCTION();
  const VkDescriptorSet dset = DSets_[lastUpdatedDSet_].vkDSet;
  const VkDescriptorSet dsets[4] = {dset, dset, dset, dset};
  vkCmdBindDescriptorSets(cmdBuf, bindPoint, layout, 0, (uint32_t)LVK_ARRAY_NUM_ELEMENTS(dsets), dsets, 0, nullptr);
}

void lvk::VulkanContext::checkAndUpdateDescriptorSets() {
  if (!awaitingCreation_) {
    // nothing to update here
    return;
  }

  // newly created resources can be used immediately - make sure they are put into descriptor sets
  LVK_PROFILER_FUNCTION();

  // update Vulkan descriptor set here

  lastUpdatedDSet_ = (lastUpdatedDSet_ + 1) % DSets_.size();

  if (const DescriptorSet& dset = DSets_[lastUpdatedDSet_]; dset.vkDSet) {
    // we can't reuse a dset that's either waiting to be submitted in a draw call
    // (which happens when textures are created mid-frame) or is still being processed
    if (dset.handle_.empty() || !immediate_->isReady(dset.handle_)) {
      // add a new empty dset to be populated right away
      lastUpdatedDSet_ = DSets_.size();
      DSets_.push_back({});
    }
  }

  DescriptorSet& dset = DSets_[lastUpdatedDSet_];

  dset.handle_ = {};

  // make sure the guard values are always there
  LVK_ASSERT(texturesPool_.numObjects() >= 1);
  LVK_ASSERT(samplersPool_.numObjects() >= 1);

  uint32_t newMaxTextures = std::max(dset.maxTextures, 16u);
  uint32_t newMaxSamplers = std::max(dset.maxSamplers, 16u);
  uint32_t newMaxAccelStructs = std::max(dset.maxAccelStructs, 1u);

  while (texturesPool_.objects_.size() > newMaxTextures) {
    newMaxTextures *= 2;
  }
  while (samplersPool_.objects_.size() > newMaxSamplers) {
    newMaxSamplers *= 2;
  }
  while (accelStructuresPool_.objects_.size() > newMaxAccelStructs) {
    newMaxAccelStructs *= 2;
  }
  growDescriptorPool(dset, newMaxTextures, newMaxSamplers, newMaxAccelStructs);

  // 1. Sampled and storage images
  std::vector<VkDescriptorImageInfo> infoSampledImages;
  std::vector<VkDescriptorImageInfo> infoStorageImages;
  std::vector<VkDescriptorImageInfo> infoYUVImages;

  infoSampledImages.reserve(texturesPool_.numObjects());
  infoStorageImages.reserve(texturesPool_.numObjects());

  const bool hasYcbcrSamplers = pimpl_->numYcbcrSamplers_ > 0;

  if (hasYcbcrSamplers) {
    infoYUVImages.reserve(texturesPool_.numObjects());
  }

  // use dummies to avoid sparse arrays
  VkImageView dummyImageView = texturesPool_.objects_[0].obj_.imageView_;
  VkSampler dummySampler = samplersPool_.objects_[0].obj_;

  for (const auto& obj : texturesPool_.objects_) {
    const VulkanImage& img = obj.obj_;
    const VkImageView view = obj.obj_.imageView_;
    const VkImageView storageView = obj.obj_.imageViewStorage_ ? obj.obj_.imageViewStorage_ : view;
    // multisampled images cannot be directly accessed from shaders
    const bool isTextureAvailable = (img.vkSamples_ & VK_SAMPLE_COUNT_1_BIT) == VK_SAMPLE_COUNT_1_BIT;
    const bool isYUVImage = isTextureAvailable && img.isSampledImage() && lvk::getNumImagePlanes(img.vkImageFormat_) > 1;
    const bool isSampledImage = isTextureAvailable && img.isSampledImage() && !isYUVImage;
    const bool isStorageImage = isTextureAvailable && img.isStorageImage();
    infoSampledImages.push_back(VkDescriptorImageInfo{
        .sampler = VK_NULL_HANDLE,
        .imageView = isSampledImage ? view : dummyImageView,
        .imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
    });
    LVK_ASSERT(infoSampledImages.back().imageView != VK_NULL_HANDLE);
    infoStorageImages.push_back(VkDescriptorImageInfo{
        .sampler = VK_NULL_HANDLE,
        .imageView = isStorageImage ? storageView : dummyImageView,
        .imageLayout = VK_IMAGE_LAYOUT_GENERAL,
    });
    if (hasYcbcrSamplers) {
      // we don't need to update this if there're no YUV samplers
      infoYUVImages.push_back(VkDescriptorImageInfo{
          .sampler = dummySampler, // this will be replaced by immutable samplers from VkPipeline
          .imageView = isYUVImage ? view : dummyImageView,
          .imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
      });
    }
  }

  // 2. Samplers
  std::vector<VkDescriptorImageInfo> infoSamplers;
  infoSamplers.reserve(samplersPool_.objects_.size());

  for (const auto& sampler : samplersPool_.objects_) {
    infoSamplers.push_back({
        .sampler = sampler.obj_ ? sampler.obj_ : samplersPool_.objects_[0].obj_,
        .imageView = VK_NULL_HANDLE,
        .imageLayout = VK_IMAGE_LAYOUT_UNDEFINED,
    });
  }

  // 3. Acceleration structures
  std::vector<VkAccelerationStructureKHR> handlesAccelStructs;
  handlesAccelStructs.reserve(accelStructuresPool_.objects_.size());

  // use the first valid TLAS as a dummy
  const VkAccelerationStructureKHR dummyTLAS = [this]() -> VkAccelerationStructureKHR {
    for (const auto& as : accelStructuresPool_.objects_) {
      if (as.obj_.vkHandle && as.obj_.isTLAS)
        return as.obj_.vkHandle;
    }
    return VK_NULL_HANDLE;
  }();

  for (const auto& as : accelStructuresPool_.objects_) {
    handlesAccelStructs.push_back(as.obj_.isTLAS ? as.obj_.vkHandle : dummyTLAS);
  }

  VkWriteDescriptorSetAccelerationStructureKHR writeAccelStruct = {
      .sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR,
      .accelerationStructureCount = (uint32_t)handlesAccelStructs.size(),
      .pAccelerationStructures = handlesAccelStructs.data(),
  };

  VkWriteDescriptorSet write[kBinding_NumBindings] = {};
  uint32_t numWrites = 0;

  if (!handlesAccelStructs.empty()) {
    write[numWrites++] = VkWriteDescriptorSet{
        .sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
        .pNext = &writeAccelStruct,
        .dstSet = dset.vkDSet,
        .dstBinding = kBinding_AccelerationStructures,
        .dstArrayElement = 0,
        .descriptorCount = (uint32_t)handlesAccelStructs.size(),
        .descriptorType = VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR,
    };
  }

  if (!infoSampledImages.empty()) {
    write[numWrites++] = VkWriteDescriptorSet{
        .sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
        .dstSet = dset.vkDSet,
        .dstBinding = kBinding_Textures,
        .dstArrayElement = 0,
        .descriptorCount = (uint32_t)infoSampledImages.size(),
        .descriptorType = VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
        .pImageInfo = infoSampledImages.data(),
    };
  }

  if (!infoSamplers.empty()) {
    write[numWrites++] = VkWriteDescriptorSet{
        .sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
        .dstSet = dset.vkDSet,
        .dstBinding = kBinding_Samplers,
        .dstArrayElement = 0,
        .descriptorCount = (uint32_t)infoSamplers.size(),
        .descriptorType = VK_DESCRIPTOR_TYPE_SAMPLER,
        .pImageInfo = infoSamplers.data(),
    };
  }

  if (!infoStorageImages.empty()) {
    write[numWrites++] = VkWriteDescriptorSet{
        .sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
        .dstSet = dset.vkDSet,
        .dstBinding = kBinding_StorageImages,
        .dstArrayElement = 0,
        .descriptorCount = (uint32_t)infoStorageImages.size(),
        .descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
        .pImageInfo = infoStorageImages.data(),
    };
  }

  if (!infoYUVImages.empty()) {
    write[numWrites++] = VkWriteDescriptorSet{
        .sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
        .dstSet = dset.vkDSet,
        .dstBinding = kBinding_YUVImages,
        .dstArrayElement = 0,
        .descriptorCount = (uint32_t)infoYUVImages.size(),
        .descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
        .pImageInfo = infoYUVImages.data(),
    };
  }

  // do not switch to the next descriptor set if there is nothing to update
  if (numWrites) {
#if LVK_VULKAN_PRINT_COMMANDS
    LLOGL("vkUpdateDescriptorSets()\n");
#endif // LVK_VULKAN_PRINT_COMMANDS
    LVK_PROFILER_ZONE("vkUpdateDescriptorSets()", LVK_PROFILER_COLOR_PRESENT);
    vkUpdateDescriptorSets(vkDevice_, numWrites, write, 0, nullptr);
    LVK_PROFILER_ZONE_END();
  }

  awaitingCreation_ = false;
}

lvk::SamplerHandle lvk::VulkanContext::createSampler(const VkSamplerCreateInfo& ci,
                                                     lvk::Result* outResult,
                                                     lvk::Format yuvFormat,
                                                     const char* debugName) {
  LVK_PROFILER_FUNCTION_COLOR(LVK_PROFILER_COLOR_CREATE);

  VkSamplerCreateInfo cinfo = ci;

  if (yuvFormat != Format_Invalid) {
    cinfo.pNext = getOrCreateYcbcrConversionInfo(yuvFormat);
    // must be CLAMP_TO_EDGE
    // https://vulkan.lunarg.com/doc/view/1.3.268.0/windows/1.3-extensions/vkspec.html#VUID-VkSamplerCreateInfo-addressModeU-01646
    cinfo.addressModeU = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
    cinfo.addressModeV = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
    cinfo.addressModeW = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
    cinfo.anisotropyEnable = VK_FALSE;
    cinfo.unnormalizedCoordinates = VK_FALSE;
  }

  VkSampler sampler = VK_NULL_HANDLE;
  VK_ASSERT(vkCreateSampler(vkDevice_, &cinfo, nullptr, &sampler));
  VK_ASSERT(lvk::setDebugObjectName(vkDevice_, VK_OBJECT_TYPE_SAMPLER, (uint64_t)sampler, debugName));

  SamplerHandle handle = samplersPool_.create(VkSampler(sampler));

  awaitingCreation_ = true;

  return handle;
}

void lvk::VulkanContext::querySurfaceCapabilities() {
  // enumerate only the formats we are using
  const VkFormat depthFormats[] = {
      VK_FORMAT_D32_SFLOAT_S8_UINT, VK_FORMAT_D24_UNORM_S8_UINT, VK_FORMAT_D16_UNORM_S8_UINT, VK_FORMAT_D32_SFLOAT, VK_FORMAT_D16_UNORM};
  for (const VkFormat& depthFormat : depthFormats) {
    VkFormatProperties2 props = {
        .sType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2,
    };
    vkGetPhysicalDeviceFormatProperties2(vkPhysicalDevice_, depthFormat, &props);

    if (props.formatProperties.optimalTilingFeatures) {
      deviceDepthFormats_.push_back(depthFormat);
    }
  }

  if (vkSurface_ == VK_NULL_HANDLE) {
    return;
  }

  vkGetPhysicalDeviceSurfaceCapabilitiesKHR(vkPhysicalDevice_, vkSurface_, &deviceSurfaceCaps_);

  uint32_t formatCount;
  vkGetPhysicalDeviceSurfaceFormatsKHR(vkPhysicalDevice_, vkSurface_, &formatCount, nullptr);

  if (formatCount) {
    deviceSurfaceFormats_.resize(formatCount);
    vkGetPhysicalDeviceSurfaceFormatsKHR(vkPhysicalDevice_, vkSurface_, &formatCount, deviceSurfaceFormats_.data());
  }

  uint32_t presentModeCount;
  vkGetPhysicalDeviceSurfacePresentModesKHR(vkPhysicalDevice_, vkSurface_, &presentModeCount, nullptr);

  if (presentModeCount) {
    devicePresentModes_.resize(presentModeCount);
    vkGetPhysicalDeviceSurfacePresentModesKHR(vkPhysicalDevice_, vkSurface_, &presentModeCount, devicePresentModes_.data());
  }
}

std::vector<uint8_t> lvk::VulkanContext::getPipelineCacheData() const {
  size_t size = 0;
  vkGetPipelineCacheData(vkDevice_, pipelineCache_, &size, nullptr);

  std::vector<uint8_t> data(size);

  if (size) {
    vkGetPipelineCacheData(vkDevice_, pipelineCache_, &size, data.data());
  }

  return data;
}

void lvk::VulkanContext::deferredTask(std::packaged_task<void()>&& task, SubmitHandle handle) const {
  if (handle.empty()) {
    handle = immediate_->getNextSubmitHandle();
  }
  pimpl_->deferredTasks_.emplace_back(std::move(task), handle);
}

void* lvk::VulkanContext::getVmaAllocator() const {
  return pimpl_->vma_;
}

void lvk::VulkanContext::processDeferredTasks() const {
  std::vector<DeferredTask>::iterator it = pimpl_->deferredTasks_.begin();

  while (it != pimpl_->deferredTasks_.end() && immediate_->isReady(it->handle_, true)) {
    (it++)->task_();
  }

  pimpl_->deferredTasks_.erase(pimpl_->deferredTasks_.begin(), it);
}

void lvk::VulkanContext::waitDeferredTasks() {
  for (auto& task : pimpl_->deferredTasks_) {
    immediate_->wait(task.handle_);
    task.task_();
  }
  pimpl_->deferredTasks_.clear();
}

uint32_t lvk::VulkanContext::getMaxStorageBufferRange() const {
  return vkPhysicalDeviceProperties2_.properties.limits.maxStorageBufferRange;
}

bool lvk::VulkanContext::isExtensionEnabled(const char* ext) const {
  for (const char* name : enabledInstanceExtensionNames_) {
    if (strcmp(ext, name) == 0)
      return true;
  }
  for (const char* name : enabledDeviceExtensionNames_) {
    if (strcmp(ext, name) == 0)
      return true;
  }
  return false;
}

```

`lvk/vulkan/VulkanClasses.h`:

```h
/*
 * LightweightVK
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#pragma once

#include <lvk/Pool.h>
#include <lvk/vulkan/VulkanUtils.h>

#include <future>
#include <memory>
#include <vector>

namespace lvk {

class VulkanContext;

struct DeviceQueues final {
  const static uint32_t INVALID = 0xFFFFFFFF;
  uint32_t graphicsQueueFamilyIndex = INVALID;
  uint32_t computeQueueFamilyIndex = INVALID;

  VkQueue graphicsQueue = VK_NULL_HANDLE;
  VkQueue computeQueue = VK_NULL_HANDLE;
};

struct VulkanBuffer final {
  // clang-format off
  [[nodiscard]] inline uint8_t* getMappedPtr() const { return static_cast<uint8_t*>(mappedPtr_); }
  [[nodiscard]] inline bool isMapped() const { return mappedPtr_ != nullptr;  }
  // clang-format on

  void bufferSubData(const VulkanContext& ctx, size_t offset, size_t size, const void* data);
  void getBufferSubData(const VulkanContext& ctx, size_t offset, size_t size, void* data);
  void flushMappedMemory(const VulkanContext& ctx, VkDeviceSize offset, VkDeviceSize size) const;
  void invalidateMappedMemory(const VulkanContext& ctx, VkDeviceSize offset, VkDeviceSize size) const;

 public:
  VkBuffer vkBuffer_ = VK_NULL_HANDLE;
  VkDeviceMemory vkMemory_ = VK_NULL_HANDLE;
  VmaAllocation vmaAllocation_ = VK_NULL_HANDLE;
  VkDeviceAddress vkDeviceAddress_ = 0;
  VkDeviceSize bufferSize_ = 0;
  VkBufferUsageFlags vkUsageFlags_ = 0;
  VkMemoryPropertyFlags vkMemFlags_ = 0;
  void* mappedPtr_ = nullptr;
  bool isCoherentMemory_ = false;
};

struct VulkanImage final {
  // clang-format off
  [[nodiscard]] inline bool isSampledImage() const { return (vkUsageFlags_ & VK_IMAGE_USAGE_SAMPLED_BIT) > 0; }
  [[nodiscard]] inline bool isStorageImage() const { return (vkUsageFlags_ & VK_IMAGE_USAGE_STORAGE_BIT) > 0; }
  [[nodiscard]] inline bool isColorAttachment() const { return (vkUsageFlags_ & VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT) > 0; }
  [[nodiscard]] inline bool isDepthAttachment() const { return (vkUsageFlags_ & VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT) > 0; }
  [[nodiscard]] inline bool isAttachment() const { return (vkUsageFlags_ & (VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT|VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT)) > 0; }
  // clang-format on

  /*
   * Setting `numLevels` to a non-zero value will override `mipLevels_` value from the original Vulkan image, and can be used to create
   * image views with different number of levels.
   */
  [[nodiscard]] VkImageView createImageView(VkDevice device,
                                            VkImageViewType type,
                                            VkFormat format,
                                            VkImageAspectFlags aspectMask,
                                            uint32_t baseLevel,
                                            uint32_t numLevels = VK_REMAINING_MIP_LEVELS,
                                            uint32_t baseLayer = 0,
                                            uint32_t numLayers = 1,
                                            const VkComponentMapping mapping = {.r = VK_COMPONENT_SWIZZLE_IDENTITY,
                                                                                .g = VK_COMPONENT_SWIZZLE_IDENTITY,
                                                                                .b = VK_COMPONENT_SWIZZLE_IDENTITY,
                                                                                .a = VK_COMPONENT_SWIZZLE_IDENTITY},
                                            const VkSamplerYcbcrConversionInfo* ycbcr = nullptr,
                                            const char* debugName = nullptr) const;

  void generateMipmap(VkCommandBuffer commandBuffer) const;
  void transitionLayout(VkCommandBuffer commandBuffer, VkImageLayout newImageLayout, const VkImageSubresourceRange& subresourceRange) const;

  [[nodiscard]] VkImageAspectFlags getImageAspectFlags() const;

  // framebuffers can render only into one level/layer
  [[nodiscard]] VkImageView getOrCreateVkImageViewForFramebuffer(VulkanContext& ctx, uint8_t level, uint16_t layer, uint32_t viewMask);

  [[nodiscard]] static bool isDepthFormat(VkFormat format);
  [[nodiscard]] static bool isStencilFormat(VkFormat format);

 public:
  VkImage vkImage_ = VK_NULL_HANDLE;
  VkImageUsageFlags vkUsageFlags_ = 0;
  VkDeviceMemory vkMemory_[3] = {VK_NULL_HANDLE, VK_NULL_HANDLE, VK_NULL_HANDLE};
  VmaAllocation vmaAllocation_ = VK_NULL_HANDLE;
  VkFormatProperties vkFormatProperties_ = {};
  VkExtent3D vkExtent_ = {0, 0, 0};
  VkImageType vkType_ = VK_IMAGE_TYPE_MAX_ENUM;
  VkFormat vkImageFormat_ = VK_FORMAT_UNDEFINED;
  VkSampleCountFlagBits vkSamples_ = VK_SAMPLE_COUNT_1_BIT;
  void* mappedPtr_ = nullptr;
  bool isSwapchainImage_ = false;
  bool isOwningVkImage_ = true;
  bool isResolveAttachment = false; // autoset by cmdBeginRendering() for extra synchronization
  uint32_t numLevels_ = 1u;
  uint32_t numLayers_ = 1u;
  bool isDepthFormat_ = false;
  bool isStencilFormat_ = false;
  char debugName_[256] = {0};
  // current image layout
  mutable VkImageLayout vkImageLayout_ = VK_IMAGE_LAYOUT_UNDEFINED;
  // precached image views - owned by this VulkanImage
  VkImageView imageView_ = VK_NULL_HANDLE; // default view with all mip-levels
  VkImageView imageViewStorage_ = VK_NULL_HANDLE; // default view with identity swizzle (all mip-levels)
  VkImageView imageViewForFramebuffer_[LVK_MAX_MIP_LEVELS][6] = {}; // max 6 faces for cubemap rendering
  VkImageView imageViewForFramebufferMultiview_[LVK_MAX_MIP_LEVELS] = {};
};

class VulkanSwapchain final {
  enum { LVK_MAX_SWAPCHAIN_IMAGES = 16 };

 public:
  VulkanSwapchain(VulkanContext& ctx, uint32_t width, uint32_t height);
  ~VulkanSwapchain();

  Result present(VkSemaphore waitSemaphore);
  VkImage getCurrentVkImage() const;
  VkImageView getCurrentVkImageView() const;
  TextureHandle getCurrentTexture();
  const VkSurfaceFormatKHR& getSurfaceFormat() const;
  uint32_t getSwapchainCurrentImageIndex() const;
  uint32_t getNumSwapchainImages() const;
  // runtime present mode switching without swapchain recreation (VK_KHR_swapchain_maintenance1), returns `false` if the mode cannot be set
  [[nodiscard]] bool setCurrentPresentMode(VkPresentModeKHR mode);

 public:
  VulkanContext& ctx_;
  VkDevice device_ = VK_NULL_HANDLE;
  VkQueue graphicsQueue_ = VK_NULL_HANDLE;
  uint32_t width_ = 0;
  uint32_t height_ = 0;
  uint32_t numSwapchainImages_ = 0;
  uint32_t currentImageIndex_ = 0; // [0...numSwapchainImages_)
  uint64_t currentFrameIndex_ = 0; // [0...+inf)
  bool getNextImage_ = true;
  VkSwapchainKHR swapchain_ = VK_NULL_HANDLE;
  VkSurfaceFormatKHR surfaceFormat_ = {.format = VK_FORMAT_UNDEFINED};
  VkPresentModeKHR currentPresentMode_ = VK_PRESENT_MODE_FIFO_KHR; // rewritten at swapchain creation
  VkPresentModeKHR registeredPresentModes_[kMaxPresentModes] = {};
  uint32_t numRegisteredPresentModes_ = 0;
  const VkSwapchainPresentModeInfoKHR presentModeInfo_ = {
      .sType = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR,
      .swapchainCount = 1,
      .pPresentModes = &currentPresentMode_, // allows runtime present mode switching without swapchain recreation
  };
  VkSwapchainPresentFenceInfoKHR presentFenceInfo_ = {
      .sType = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR,
      .pNext = &presentModeInfo_,
      .swapchainCount = 1,
      .pFences = nullptr, // we set `pFences` in present() to the current image's present fence
  };
  TextureHandle swapchainTextures_[LVK_MAX_SWAPCHAIN_IMAGES] = {};
  VkSemaphore acquireSemaphore_[LVK_MAX_SWAPCHAIN_IMAGES] = {};
  VkFence presentFence_[LVK_MAX_SWAPCHAIN_IMAGES] = {};
  VkFence acquireFence_[LVK_MAX_SWAPCHAIN_IMAGES] = {}; // remove once VK_EXT_swapchain_maintenance1 becomes mandatory
  uint64_t timelineWaitValues_[LVK_MAX_SWAPCHAIN_IMAGES] = {};
};

class VulkanImmediateCommands final {
 public:
  // the maximum number of command buffers which can similtaneously exist in the system; when we run out of buffers, we stall and wait until
  // an existing buffer becomes available
  static constexpr uint32_t kMaxCommandBuffers = 64;

  VulkanImmediateCommands(VkDevice device, uint32_t queueFamilyIndex, bool has_EXT_device_fault, const char* debugName);
  ~VulkanImmediateCommands();
  VulkanImmediateCommands(const VulkanImmediateCommands&) = delete;
  VulkanImmediateCommands& operator=(const VulkanImmediateCommands&) = delete;

  struct CommandBufferWrapper {
    VkCommandBuffer cmdBuf_ = VK_NULL_HANDLE;
    VkCommandBuffer cmdBufAllocated_ = VK_NULL_HANDLE;
    SubmitHandle handle_ = {};
    VkFence fence_ = VK_NULL_HANDLE;
    VkSemaphore semaphore_ = VK_NULL_HANDLE;
    bool isEncoding_ = false;
  };

  // returns the current command buffer (creates one if it does not exist)
  const CommandBufferWrapper& acquire();
  SubmitHandle submit(const CommandBufferWrapper& wrapper);
  void waitSemaphore(VkSemaphore semaphore);
  void signalSemaphore(VkSemaphore semaphore, uint64_t signalValue);
  VkSemaphore acquireLastSubmitSemaphore();
  VkFence getVkFence(SubmitHandle handle) const;
  SubmitHandle getLastSubmitHandle() const;
  SubmitHandle getNextSubmitHandle() const;
  bool isReady(SubmitHandle handle, bool fastCheckNoVulkan = false) const;
  void wait(SubmitHandle handle);
  void waitAll();

 private:
  void purge();

 private:
  VkDevice device_ = VK_NULL_HANDLE;
  VkQueue queue_ = VK_NULL_HANDLE;
  VkCommandPool commandPool_ = VK_NULL_HANDLE;
  uint32_t queueFamilyIndex_ = 0;
  bool has_EXT_device_fault_ = false;
  const char* debugName_ = "";
  CommandBufferWrapper buffers_[kMaxCommandBuffers];
  SubmitHandle lastSubmitHandle_ = SubmitHandle();
  SubmitHandle nextSubmitHandle_ = SubmitHandle();
  VkSemaphoreSubmitInfo lastSubmitSemaphore_ = {.sType = VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO,
                                                .stageMask = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT};
  VkSemaphoreSubmitInfo waitSemaphore_ = {.sType = VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO,
                                          .stageMask = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT}; // extra "wait" semaphore
  VkSemaphoreSubmitInfo signalSemaphore_ = {.sType = VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO,
                                            .stageMask = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT}; // extra "signal" semaphore
  uint32_t numAvailableCommandBuffers_ = kMaxCommandBuffers;
  uint32_t submitCounter_ = 1;
};

struct RenderPipelineState final {
  RenderPipelineDesc desc_;

  uint32_t numBindings_ = 0;
  uint32_t numAttributes_ = 0;
  VkVertexInputBindingDescription vkBindings_[VertexInput::LVK_VERTEX_BUFFER_MAX] = {};
  VkVertexInputAttributeDescription vkAttributes_[VertexInput::LVK_VERTEX_ATTRIBUTES_MAX] = {};

  // non-owning, the last seen VkDescriptorSetLayout from VulkanContext::vkDSL_ (if the context has a new layout, invalidate all VkPipeline
  // objects)
  VkDescriptorSetLayout lastVkDescriptorSetLayout_ = VK_NULL_HANDLE;

  VkShaderStageFlags shaderStageFlags_ = 0;
  VkPipelineLayout pipelineLayout_ = VK_NULL_HANDLE;
  VkPipeline pipeline_ = VK_NULL_HANDLE;

  void* specConstantDataStorage_ = nullptr;

  uint32_t viewMask_ = 0;
};

class VulkanPipelineBuilder final {
 public:
  VulkanPipelineBuilder();
  ~VulkanPipelineBuilder() = default;

  VulkanPipelineBuilder& dynamicState(VkDynamicState state);
  VulkanPipelineBuilder& primitiveTopology(VkPrimitiveTopology topology);
  VulkanPipelineBuilder& rasterizationSamples(VkSampleCountFlagBits samples, float minSampleShading);
  VulkanPipelineBuilder& shaderStage(VkPipelineShaderStageCreateInfo stage);
  VulkanPipelineBuilder& stencilStateOps(VkStencilFaceFlags faceMask,
                                         VkStencilOp failOp,
                                         VkStencilOp passOp,
                                         VkStencilOp depthFailOp,
                                         VkCompareOp compareOp);
  VulkanPipelineBuilder& stencilMasks(VkStencilFaceFlags faceMask, uint32_t compareMask, uint32_t writeMask, uint32_t reference);
  VulkanPipelineBuilder& cullMode(VkCullModeFlags mode);
  VulkanPipelineBuilder& frontFace(VkFrontFace mode);
  VulkanPipelineBuilder& polygonMode(VkPolygonMode mode);
  VulkanPipelineBuilder& vertexInputState(const VkPipelineVertexInputStateCreateInfo& state);
  VulkanPipelineBuilder& viewMask(uint32_t mask);
  VulkanPipelineBuilder& colorAttachments(const VkPipelineColorBlendAttachmentState* states,
                                          const VkFormat* formats,
                                          uint32_t numColorAttachments);
  VulkanPipelineBuilder& depthAttachmentFormat(VkFormat format);
  VulkanPipelineBuilder& stencilAttachmentFormat(VkFormat format);
  VulkanPipelineBuilder& patchControlPoints(uint32_t numPoints);

  VkResult build(VkDevice device,
                 VkPipelineCache pipelineCache,
                 VkPipelineLayout pipelineLayout,
                 VkPipeline* outPipeline,
                 const char* debugName = nullptr) noexcept;

  static uint32_t getNumPipelinesCreated() {
    return numPipelinesCreated_;
  }

 private:
  enum { LVK_MAX_DYNAMIC_STATES = 128 };
  uint32_t numDynamicStates_ = 0;
  VkDynamicState dynamicStates_[LVK_MAX_DYNAMIC_STATES] = {};

  uint32_t numShaderStages_ = 0;
  VkPipelineShaderStageCreateInfo shaderStages_[Stage_Frag + 1] = {};

  VkPipelineVertexInputStateCreateInfo vertexInputState_;
  VkPipelineInputAssemblyStateCreateInfo inputAssembly_;
  VkPipelineRasterizationStateCreateInfo rasterizationState_;
  VkPipelineMultisampleStateCreateInfo multisampleState_;
  VkPipelineDepthStencilStateCreateInfo depthStencilState_;
  VkPipelineTessellationStateCreateInfo tessellationState_;

  uint32_t viewMask_ = 0;
  uint32_t numColorAttachments_ = 0;
  VkPipelineColorBlendAttachmentState colorBlendAttachmentStates_[LVK_MAX_COLOR_ATTACHMENTS] = {};
  VkFormat colorAttachmentFormats_[LVK_MAX_COLOR_ATTACHMENTS] = {};

  VkFormat depthAttachmentFormat_ = VK_FORMAT_UNDEFINED;
  VkFormat stencilAttachmentFormat_ = VK_FORMAT_UNDEFINED;

  static uint32_t numPipelinesCreated_;
};

struct ComputePipelineState final {
  ComputePipelineDesc desc_;

  // non-owning, the last seen VkDescriptorSetLayout from VulkanContext::vkDSL_ (invalidate all VkPipeline objects on new layout)
  VkDescriptorSetLayout lastVkDescriptorSetLayout_ = VK_NULL_HANDLE;

  VkPipelineLayout pipelineLayout_ = VK_NULL_HANDLE;
  VkPipeline pipeline_ = VK_NULL_HANDLE;

  void* specConstantDataStorage_ = nullptr;
};

struct RayTracingPipelineState final {
  RayTracingPipelineDesc desc_;

  // non-owning, the last seen VkDescriptorSetLayout from VulkanContext::vkDSL_ (invalidate all VkPipeline objects on new layout)
  VkDescriptorSetLayout lastVkDescriptorSetLayout_ = VK_NULL_HANDLE;

  VkShaderStageFlags shaderStageFlags_ = 0;
  VkPipelineLayout pipelineLayout_ = VK_NULL_HANDLE;
  VkPipeline pipeline_ = VK_NULL_HANDLE;

  void* specConstantDataStorage_ = nullptr;

  lvk::Holder<lvk::BufferHandle> sbt;

  VkStridedDeviceAddressRegionKHR sbtEntryRayGen = {};
  VkStridedDeviceAddressRegionKHR sbtEntryMiss = {};
  VkStridedDeviceAddressRegionKHR sbtEntryHit = {};
  VkStridedDeviceAddressRegionKHR sbtEntryCallable = {};
};

struct ShaderModuleState final {
  VkShaderModuleCreateInfo ci = {
      .sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
      .pNext = nullptr,
      .flags = 0,
      .codeSize = 0,
      .pCode = nullptr,
  };
  uint32_t pushConstantsSize = 0;
};

struct AccelerationStructure {
  bool isTLAS = false;
  VkAccelerationStructureBuildRangeInfoKHR buildRangeInfo = {};
  VkAccelerationStructureKHR vkHandle = VK_NULL_HANDLE;
  uint64_t deviceAddress = 0;
  lvk::Holder<lvk::BufferHandle> buffer;
  lvk::Holder<lvk::BufferHandle> scratchBuffer; // Store only for TLAS
};

class CommandBuffer final : public ICommandBuffer {
 public:
  CommandBuffer() = default;
  explicit CommandBuffer(VulkanContext* ctx);
  ~CommandBuffer() override;

  CommandBuffer& operator=(CommandBuffer&& other) = default;

  operator VkCommandBuffer() const {
    return getVkCommandBuffer();
  }

  void transitionToShaderReadOnly(TextureHandle surface) const override;
  void transitionToRenderingLocalRead(TextureHandle surface) const override;

  void cmdBindRayTracingPipeline(lvk::RayTracingPipelineHandle handle) override;

  void cmdBindComputePipeline(lvk::ComputePipelineHandle handle) override;
  void cmdDispatchThreadGroups(const Dimensions& threadgroupCount, const Dependencies& deps) override;

  void cmdPushDebugGroupLabel(const char* label, uint32_t colorRGBA) const override;
  void cmdInsertDebugEventLabel(const char* label, uint32_t colorRGBA) const override;
  void cmdPopDebugGroupLabel() const override;

  void cmdBeginRendering(const lvk::RenderPass& renderPass, const lvk::Framebuffer& desc, const Dependencies& deps) override;
  void cmdEndRendering() override;
  void cmdNextSubpass() override;

  void cmdBindViewport(const Viewport& viewport) override;
  void cmdBindScissorRect(const ScissorRect& rect) override;

  void cmdBindRenderPipeline(lvk::RenderPipelineHandle handle) override;
  void cmdBindDepthState(const DepthState& state) override;

  void cmdBindVertexBuffer(uint32_t index, BufferHandle buffer, uint64_t bufferOffset) override;
  void cmdBindIndexBuffer(BufferHandle indexBuffer, IndexFormat indexFormat, uint64_t indexBufferOffset) override;
  void cmdPushConstants(const void* data, size_t size, size_t offset) override;

  void cmdCopyBuffer(BufferHandle srcBuffer, BufferHandle dstBuffer, size_t srcOffset, size_t dstOffset, size_t size) override;
  void cmdFillBuffer(BufferHandle buffer, size_t bufferOffset, size_t size, uint32_t data) override;
  void cmdUpdateBuffer(BufferHandle buffer, size_t bufferOffset, size_t size, const void* data) override;

  void cmdDraw(uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t baseInstance) override;
  void cmdDrawIndexed(uint32_t indexCount,
                      uint32_t instanceCount,
                      uint32_t firstIndex,
                      int32_t vertexOffset,
                      uint32_t baseInstance) override;
  void cmdDrawIndirect(BufferHandle indirectBuffer, size_t indirectBufferOffset, uint32_t drawCount, uint32_t stride = 0) override;
  void cmdDrawIndexedIndirect(BufferHandle indirectBuffer, size_t indirectBufferOffset, uint32_t drawCount, uint32_t stride = 0) override;
  void cmdDrawIndexedIndirectCount(BufferHandle indirectBuffer,
                                   size_t indirectBufferOffset,
                                   BufferHandle countBuffer,
                                   size_t countBufferOffset,
                                   uint32_t maxDrawCount,
                                   uint32_t stride = 0) override;
  void cmdDrawMeshTasks(const Dimensions& threadgroupCount) override;
  void cmdDrawMeshTasksIndirect(BufferHandle indirectBuffer, size_t indirectBufferOffset, uint32_t drawCount, uint32_t stride = 0) override;
  void cmdDrawMeshTasksIndirectCount(BufferHandle indirectBuffer,
                                     size_t indirectBufferOffset,
                                     BufferHandle countBuffer,
                                     size_t countBufferOffset,
                                     uint32_t maxDrawCount,
                                     uint32_t stride = 0) override;
  void cmdTraceRays(uint32_t width, uint32_t height, uint32_t depth, const Dependencies& deps) override;

  void cmdSetBlendColor(const float color[4]) override;
  void cmdSetDepthBias(float constantFactor, float slopeFactor, float clamp) override;
  void cmdSetDepthBiasEnable(bool enable) override;

  void cmdResetQueryPool(QueryPoolHandle pool, uint32_t firstQuery, uint32_t queryCount) override;
  void cmdWriteTimestamp(QueryPoolHandle pool, uint32_t query) override;

  void cmdClearColorImage(TextureHandle tex, const ClearColorValue& value, const TextureLayers& layers) override;
  void cmdCopyImage(TextureHandle src,
                    TextureHandle dst,
                    const Dimensions& extent,
                    const Offset3D& srcOffset,
                    const Offset3D& dstOffset,
                    const TextureLayers& srcLayers,
                    const TextureLayers& dstLayers) override;
  void cmdGenerateMipmap(TextureHandle handle) override;
  void cmdUpdateTLAS(AccelStructHandle handle, BufferHandle instancesBuffer) override;

  VkCommandBuffer getVkCommandBuffer() const {
    return wrapper_ ? wrapper_->cmdBuf_ : VK_NULL_HANDLE;
  }

 private:
  void useComputeTexture(TextureHandle texture, VkPipelineStageFlags2 dstStage);
  void bufferBarrier(BufferHandle handle, VkPipelineStageFlags2 srcStage, VkPipelineStageFlags2 dstStage);

 private:
  friend class VulkanContext;

  VulkanContext* ctx_ = nullptr;
  const VulkanImmediateCommands::CommandBufferWrapper* wrapper_ = nullptr;

  lvk::Framebuffer framebuffer_ = {};
  lvk::SubmitHandle lastSubmitHandle_ = {};

  struct {
    VkDescriptorImageInfo imageInfos[LVK_MAX_COLOR_ATTACHMENTS] = {};
    VkWriteDescriptorSet writes[LVK_MAX_COLOR_ATTACHMENTS] = {};
    uint32_t count = 0;
  } inputAttachments_;

  VkPipeline lastPipelineBound_ = VK_NULL_HANDLE;

  bool isRendering_ = false;
  uint32_t viewMask_ = 0;

  lvk::RenderPipelineHandle currentPipelineGraphics_ = {};
  lvk::ComputePipelineHandle currentPipelineCompute_ = {};
  lvk::RayTracingPipelineHandle currentPipelineRayTracing_ = {};
};

class VulkanStagingDevice final {
 public:
  explicit VulkanStagingDevice(VulkanContext& ctx);
  ~VulkanStagingDevice() = default;

  VulkanStagingDevice(const VulkanStagingDevice&) = delete;
  VulkanStagingDevice& operator=(const VulkanStagingDevice&) = delete;

  void bufferSubData(VulkanBuffer& buffer, size_t dstOffset, size_t size, const void* data);
  void imageData2D(VulkanImage& image,
                   const VkRect2D& imageRegion,
                   uint32_t baseMipLevel,
                   uint32_t numMipLevels,
                   uint32_t layer,
                   uint32_t numLayers,
                   VkFormat format,
                   const void* data,
                   uint32_t bufferRowLength);
  void imageData3D(VulkanImage& image, const VkOffset3D& offset, const VkExtent3D& extent, VkFormat format, const void* data);
  void getImageData(VulkanImage& image,
                    const VkOffset3D& offset,
                    const VkExtent3D& extent,
                    VkImageSubresourceRange range,
                    VkFormat format,
                    void* outData);

 private:
  enum { kStagingBufferAlignment = 16 }; // updated to support BC7 compressed image

  struct MemoryRegionDesc {
    uint64_t offset_ = 0;
    uint64_t size_ = 0;
    SubmitHandle handle_ = {};
  };

  MemoryRegionDesc getNextFreeOffset(uint32_t size);
  void ensureStagingBufferSize(uint32_t sizeNeeded);
  void waitAndReset();

 private:
  VulkanContext& ctx_;
  lvk::Holder<BufferHandle> stagingBuffer_;
  VkDeviceSize stagingBufferSize_ = 0;
  uint32_t stagingBufferCounter_ = 0;
  // the staging buffer grows from minBufferSize up to maxBufferSize as needed
  VkDeviceSize maxBufferSize_ = 0;
  VkDeviceSize minBufferSize_ = 4u * 2048u * 2048u; // ad hoc value to avoid frequent reallocations
  std::vector<MemoryRegionDesc> regions_;
};

class VulkanContext final : public IContext {
 public:
  VulkanContext(const lvk::ContextConfig& config, void* window, void* display = nullptr, VkSurfaceKHR surface = VK_NULL_HANDLE);
  ~VulkanContext();

  ICommandBuffer& acquireCommandBuffer() override;

  SubmitHandle submit(lvk::ICommandBuffer& commandBuffer, TextureHandle present) override;
  void wait(SubmitHandle handle) override;

  Holder<BufferHandle> createBuffer(const BufferDesc& desc, const char* debugName, Result* outResult) override;
  Holder<SamplerHandle> createSampler(const SamplerStateDesc& desc, Result* outResult) override;
  Holder<TextureHandle> createTexture(const TextureDesc& desc, const char* debugName, Result* outResult) override;
  Holder<TextureHandle> createTextureView(TextureHandle texture,
                                          const TextureViewDesc& desc,
                                          const char* debugName,
                                          Result* outResult) override;

  Holder<ComputePipelineHandle> createComputePipeline(const ComputePipelineDesc& desc, Result* outResult) override;
  Holder<RenderPipelineHandle> createRenderPipeline(const RenderPipelineDesc& desc, Result* outResult) override;
  Holder<RayTracingPipelineHandle> createRayTracingPipeline(const RayTracingPipelineDesc& desc, Result* outResult = nullptr) override;
  Holder<ShaderModuleHandle> createShaderModule(const ShaderModuleDesc& desc, Result* outResult) override;

  Holder<QueryPoolHandle> createQueryPool(uint32_t numQueries, const char* debugName, Result* outResult) override;

  Holder<AccelStructHandle> createAccelerationStructure(const AccelStructDesc& desc, Result* outResult) override;

  void destroy(ComputePipelineHandle handle) override;
  void destroy(RenderPipelineHandle handle) override;
  void destroy(RayTracingPipelineHandle handle) override;
  void destroy(ShaderModuleHandle handle) override;
  void destroy(SamplerHandle handle) override;
  void destroy(BufferHandle handle) override;
  void destroy(TextureHandle handle) override;
  void destroy(QueryPoolHandle handle) override;
  void destroy(AccelStructHandle handle) override;
  void destroy(Framebuffer& fb) override;

  uint64_t gpuAddress(AccelStructHandle handle) const override;

  Result upload(BufferHandle handle, const void* data, size_t size, size_t offset) override;
  Result download(BufferHandle handle, void* data, size_t size, size_t offset) override;
  uint8_t* getMappedPtr(BufferHandle handle) const override;
  uint64_t gpuAddress(BufferHandle handle, size_t offset = 0) const override;
  void flushMappedMemory(BufferHandle handle, size_t offset, size_t size) const override;

  Result upload(TextureHandle handle, const TextureRangeDesc& range, const void* data, uint32_t bufferRowLength = 0) override;
  Result download(TextureHandle handle, const TextureRangeDesc& range, void* outData) override;
  Dimensions getDimensions(TextureHandle handle) const override;
  float getAspectRatio(TextureHandle handle) const override;
  Format getFormat(TextureHandle handle) const override;

  TextureHandle getCurrentSwapchainTexture() override;
  Format getSwapchainFormat() const override;
  ColorSpace getSwapchainColorSpace() const override;
  uint32_t getSwapchainCurrentImageIndex() const override;
  uint32_t getNumSwapchainImages() const override;
  void recreateSwapchain(int newWidth, int newHeight) override;
  bool setCurrentPresentMode(PresentMode mode) override;
  PresentMode getCurrentPresentMode() const override;

  uint32_t getFramebufferMSAABitMask() const override;
  bool isExtensionEnabled(const char* ext) const override;

  double getTimestampPeriodToMs() const override;
  bool getQueryPoolResults(QueryPoolHandle pool, uint32_t firstQuery, uint32_t queryCount, size_t dataSize, void* outData, size_t stride)
      const override;

  [[nodiscard]] AccelStructSizes getAccelStructSizes(const AccelStructDesc& desc, Result* outResult) const override;

  ///////////////

  VkPipeline getVkPipeline(ComputePipelineHandle handle);
  VkPipeline getVkPipeline(RenderPipelineHandle handle, uint32_t viewMask);
  VkPipeline getVkPipeline(RayTracingPipelineHandle handle);

  uint32_t queryDevices(HWDeviceDesc* outDevices, uint32_t maxOutDevices = 1);
  lvk::Result initContext(const HWDeviceDesc& desc);
  lvk::Result initSwapchain(uint32_t width, uint32_t height);

  BufferHandle createBuffer(VkDeviceSize bufferSize,
                            VkBufferUsageFlags usageFlags,
                            VkMemoryPropertyFlags memFlags,
                            lvk::Result* outResult,
                            const char* debugName = nullptr);
  SamplerHandle createSampler(const VkSamplerCreateInfo& ci,
                              lvk::Result* outResult,
                              lvk::Format yuvFormat = Format_Invalid,
                              const char* debugName = nullptr);
  AccelStructHandle createBLAS(const AccelStructDesc& desc, Result* outResult);
  AccelStructHandle createTLAS(const AccelStructDesc& desc, Result* outResult);

  bool hasSwapchain() const noexcept {
    return swapchain_ != nullptr;
  }

  const VkPhysicalDeviceProperties& getVkPhysicalDeviceProperties() const {
    return vkPhysicalDeviceProperties2_.properties;
  }

  // OpenXR needs Vulkan instance to find physical device
  VkInstance getVkInstance() const {
    return vkInstance_;
  }
  VkDevice getVkDevice() const {
    return vkDevice_;
  }
  VkPhysicalDevice getVkPhysicalDevice() const {
    return vkPhysicalDevice_;
  }

  std::vector<uint8_t> getPipelineCacheData() const;

  // execute a task some time in the future after the submit handle finished processing
  void deferredTask(std::packaged_task<void()>&& task, SubmitHandle handle = SubmitHandle()) const;

  void* getVmaAllocator() const;

  void checkAndUpdateDescriptorSets();
  void bindDefaultDescriptorSets(VkCommandBuffer cmdBuf, VkPipelineBindPoint bindPoint, VkPipelineLayout layout) const;

  [[nodiscard]] uint32_t getMaxStorageBufferRange() const override;

 private:
  struct DescriptorSet {
    uint32_t maxTextures = 0;
    uint32_t maxSamplers = 0;
    uint32_t maxAccelStructs = 0;
    VkDescriptorSetLayout vkDSL = VK_NULL_HANDLE;
    VkDescriptorPool vkDPool = VK_NULL_HANDLE;
    VkDescriptorSet vkDSet = VK_NULL_HANDLE;
    SubmitHandle handle_ = {}; // last use
  };

  lvk::Result createInstance();
  void createSurface(void* window, void* display);
  void createHeadlessSurface();
  void querySurfaceCapabilities();
  void processDeferredTasks() const;
  void waitDeferredTasks();
  void generateMipmap(TextureHandle handle) const;
  lvk::Result growDescriptorPool(VulkanContext::DescriptorSet& dset, uint32_t maxTextures, uint32_t maxSamplers, uint32_t maxAccelStructs);
  ShaderModuleState createShaderModuleFromSPIRV(const void* spirv, size_t numBytes, const char* debugName, Result* outResult) const;
  ShaderModuleState createShaderModuleFromGLSL(ShaderStage stage, const char* source, const char* debugName, Result* outResult) const;
  ShaderModuleState createShaderModuleFromSlang(ShaderStage stage,
                                                const char* source,
                                                const char* entryPointName,
                                                const char* debugName,
                                                Result* outResult) const;
  const VkSamplerYcbcrConversionInfo* getOrCreateYcbcrConversionInfo(lvk::Format format);
  VkSampler getOrCreateYcbcrSampler(lvk::Format format);
  void addNextPhysicalDeviceProperties(void* properties);

  void getBuildInfoBLAS(const AccelStructDesc& desc,
                        VkAccelerationStructureGeometryKHR& geom,
                        VkAccelerationStructureBuildSizesInfoKHR& outSizesInfo) const;
  void getBuildInfoTLAS(const AccelStructDesc& desc,
                        VkAccelerationStructureGeometryKHR& outGeometry,
                        VkAccelerationStructureBuildSizesInfoKHR& outSizesInfo) const;

 private:
  friend class lvk::VulkanSwapchain;
  friend class lvk::VulkanStagingDevice;

  VkInstance vkInstance_ = VK_NULL_HANDLE;
  VkDebugUtilsMessengerEXT vkDebugUtilsMessenger_ = VK_NULL_HANDLE;
  VkSurfaceKHR vkSurface_ = VK_NULL_HANDLE;
  VkPhysicalDevice vkPhysicalDevice_ = VK_NULL_HANDLE;
  VkDevice vkDevice_ = VK_NULL_HANDLE;

  uint32_t khronosValidationVersion_ = 0;

#if defined(VK_API_VERSION_1_4)
  VkPhysicalDeviceVulkan14Features vkFeatures14_ = {.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES};
#endif // VK_API_VERSION_1_4
  VkPhysicalDeviceVulkan13Features vkFeatures13_ = {.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES};
  VkPhysicalDeviceVulkan12Features vkFeatures12_ = {.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES,
                                                    .pNext = &vkFeatures13_};
  VkPhysicalDeviceVulkan11Features vkFeatures11_ = {.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES,
                                                    .pNext = &vkFeatures12_};
  VkPhysicalDeviceFeatures2 vkFeatures10_ = {.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2, .pNext = &vkFeatures11_};

 public:
  VkPhysicalDeviceRayTracingPipelinePropertiesKHR rayTracingPipelineProperties_ = {
      VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR};
  VkPhysicalDeviceAccelerationStructurePropertiesKHR accelerationStructureProperties_ = {
      VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR};
  VkPhysicalDeviceDriverProperties vkPhysicalDeviceDriverProperties_ = {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES, nullptr};
#if defined(VK_API_VERSION_1_4)
  // provided by Vulkan 1.4
  VkPhysicalDeviceVulkan14Properties vkPhysicalDeviceVulkan14Properties_ = {
      VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES,
      &vkPhysicalDeviceDriverProperties_,
  };
#endif // VK_API_VERSION_1_4
  // provided by Vulkan 1.3
  VkPhysicalDeviceVulkan13Properties vkPhysicalDeviceVulkan13Properties_ = {
      VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES,
      &vkPhysicalDeviceDriverProperties_,
  };
  // provided by Vulkan 1.2
  VkPhysicalDeviceVulkan12Properties vkPhysicalDeviceVulkan12Properties_ = {
      VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES,
      &vkPhysicalDeviceVulkan13Properties_,
  };
  // provided by Vulkan 1.1
  VkPhysicalDeviceVulkan11Properties vkPhysicalDeviceVulkan11Properties_ = {
      VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES,
      &vkPhysicalDeviceVulkan12Properties_,
  };
  VkPhysicalDeviceProperties2 vkPhysicalDeviceProperties2_ = {
      VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
      &vkPhysicalDeviceVulkan11Properties_,
      VkPhysicalDeviceProperties{},
  };

  std::vector<VkFormat> deviceDepthFormats_;
  std::vector<VkSurfaceFormatKHR> deviceSurfaceFormats_;
  VkSurfaceCapabilitiesKHR deviceSurfaceCaps_;
  std::vector<VkPresentModeKHR> devicePresentModes_;

 public:
  DeviceQueues deviceQueues_;
  std::unique_ptr<lvk::VulkanSwapchain> swapchain_;
  VkSemaphore timelineSemaphore_ = VK_NULL_HANDLE;
  std::unique_ptr<lvk::VulkanImmediateCommands> immediate_;
  std::unique_ptr<lvk::VulkanStagingDevice> stagingDevice_;
  VkDescriptorSetLayout dslInputAttachments_ = VK_NULL_HANDLE;
  std::vector<DescriptorSet> DSets_ = {};
  size_t lastUpdatedDSet_ = 0;
  // don't use staging on devices with shared host-visible memory
  bool useStaging_ = true;

  std::unique_ptr<struct VulkanContextImpl> pimpl_;

  VkPipelineCache pipelineCache_ = VK_NULL_HANDLE;

  // a texture/sampler was created since the last descriptor set update
  mutable bool awaitingCreation_ = false;
  mutable bool awaitingNewImmutableSamplers_ = false;

  lvk::ContextConfig config_;
  bool has_KHR_acceleration_structure_ = false;
  bool has_KHR_ray_query_ = false;
  bool has_KHR_ray_tracing_pipeline_ = false;
  bool has_EXT_ray_tracing_invocation_reorder = false;
  bool has_8BitIndices_ = false; // VK_KHR_index_type_uint8 or VK_EXT_index_type_uint8
  bool has_KHR_calibrated_timestamps_ = false;
  bool has_EXT_swapchain_colorspace_ = false;
  bool has_KHR_swapchain_maintenance1_ = false; // VK_KHR_swapchain_maintenance1 or VK_EXT_swapchain_maintenance1
  bool has_EXT_hdr_metadata_ = false;
  bool has_EXT_device_fault_ = false;
  bool has_EXT_shader_tile_image = false;
  bool has_EXT_mesh_shader_ = false;
  bool has_MVK_macos_surface_ = false;
  bool has_KHR_shared_presentable_image_ = false;
  bool has_KHR_present_mode_fifo_latest_ready_ = false;
  std::vector<const char*> enabledInstanceExtensionNames_;
  std::vector<const char*> enabledDeviceExtensionNames_;

  TextureHandle dummyTexture_;

  lvk::Pool<lvk::ShaderModule, lvk::ShaderModuleState> shaderModulesPool_;
  lvk::Pool<lvk::RenderPipeline, lvk::RenderPipelineState> renderPipelinesPool_;
  lvk::Pool<lvk::ComputePipeline, lvk::ComputePipelineState> computePipelinesPool_;
  lvk::Pool<lvk::RayTracingPipeline, lvk::RayTracingPipelineState> rayTracingPipelinesPool_;
  lvk::Pool<lvk::Sampler, VkSampler> samplersPool_;
  lvk::Pool<lvk::Buffer, lvk::VulkanBuffer> buffersPool_;
  lvk::Pool<lvk::Texture, lvk::VulkanImage> texturesPool_;
  lvk::Pool<lvk::QueryPool, VkQueryPool> queriesPool_;
  lvk::Pool<lvk::AccelerationStructure, lvk::AccelerationStructure> accelStructuresPool_;
};

} // namespace lvk

```

`lvk/vulkan/VulkanUtils.cpp`:

```cpp
/*
 * LightweightVK
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#include <glslang/Include/glslang_c_interface.h>

#if defined(LVK_WITH_SLANG) && LVK_WITH_SLANG
#include <slang.h>
#include <slang-com-helper.h>
#include <slang-com-ptr.h>
#include <core/slang-basic.h>
#endif // defined(LVK_WITH_SLANG) && LVK_WITH_SLANG

#include "VulkanUtils.h"

#include <lvk/vulkan/VulkanClasses.h>
#include <ldrutils/lutils/ScopeExit.h>

const char* lvk::getVulkanResultString(VkResult result) {
#define RESULT_CASE(res) \
  case res:              \
    return #res
  switch (result) {
    RESULT_CASE(VK_SUCCESS);
    RESULT_CASE(VK_NOT_READY);
    RESULT_CASE(VK_TIMEOUT);
    RESULT_CASE(VK_EVENT_SET);
    RESULT_CASE(VK_EVENT_RESET);
    RESULT_CASE(VK_INCOMPLETE);
    RESULT_CASE(VK_ERROR_OUT_OF_HOST_MEMORY);
    RESULT_CASE(VK_ERROR_OUT_OF_DEVICE_MEMORY);
    RESULT_CASE(VK_ERROR_INITIALIZATION_FAILED);
    RESULT_CASE(VK_ERROR_DEVICE_LOST);
    RESULT_CASE(VK_ERROR_MEMORY_MAP_FAILED);
    RESULT_CASE(VK_ERROR_LAYER_NOT_PRESENT);
    RESULT_CASE(VK_ERROR_EXTENSION_NOT_PRESENT);
    RESULT_CASE(VK_ERROR_FEATURE_NOT_PRESENT);
    RESULT_CASE(VK_ERROR_INCOMPATIBLE_DRIVER);
    RESULT_CASE(VK_ERROR_TOO_MANY_OBJECTS);
    RESULT_CASE(VK_ERROR_FORMAT_NOT_SUPPORTED);
    RESULT_CASE(VK_ERROR_SURFACE_LOST_KHR);
    RESULT_CASE(VK_ERROR_OUT_OF_DATE_KHR);
    RESULT_CASE(VK_ERROR_INCOMPATIBLE_DISPLAY_KHR);
    RESULT_CASE(VK_ERROR_NATIVE_WINDOW_IN_USE_KHR);
    RESULT_CASE(VK_ERROR_VALIDATION_FAILED_EXT);
    RESULT_CASE(VK_ERROR_FRAGMENTED_POOL);
    RESULT_CASE(VK_ERROR_UNKNOWN);
    // Provided by VK_VERSION_1_1
    RESULT_CASE(VK_ERROR_OUT_OF_POOL_MEMORY);
    // Provided by VK_VERSION_1_1
    RESULT_CASE(VK_ERROR_INVALID_EXTERNAL_HANDLE);
    // Provided by VK_VERSION_1_2
    RESULT_CASE(VK_ERROR_FRAGMENTATION);
    // Provided by VK_VERSION_1_2
    RESULT_CASE(VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS);
    // Provided by VK_KHR_swapchain
    RESULT_CASE(VK_SUBOPTIMAL_KHR);
    // Provided by VK_NV_glsl_shader
    RESULT_CASE(VK_ERROR_INVALID_SHADER_NV);
#ifdef VK_ENABLE_BETA_EXTENSIONS
    // Provided by VK_KHR_video_queue
    RESULT_CASE(VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR);
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
    // Provided by VK_KHR_video_queue
    RESULT_CASE(VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR);
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
    // Provided by VK_KHR_video_queue
    RESULT_CASE(VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR);
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
    // Provided by VK_KHR_video_queue
    RESULT_CASE(VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR);
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
    // Provided by VK_KHR_video_queue
    RESULT_CASE(VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR);
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
    // Provided by VK_KHR_video_queue
    RESULT_CASE(VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR);
#endif
    // Provided by VK_EXT_image_drm_format_modifier
    RESULT_CASE(VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT);
    // Provided by VK_KHR_global_priority
    RESULT_CASE(VK_ERROR_NOT_PERMITTED_KHR);
    // Provided by VK_EXT_full_screen_exclusive
    RESULT_CASE(VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT);
    // Provided by VK_KHR_deferred_host_operations
    RESULT_CASE(VK_THREAD_IDLE_KHR);
    // Provided by VK_KHR_deferred_host_operations
    RESULT_CASE(VK_THREAD_DONE_KHR);
    // Provided by VK_KHR_deferred_host_operations
    RESULT_CASE(VK_OPERATION_DEFERRED_KHR);
    // Provided by VK_KHR_deferred_host_operations
    RESULT_CASE(VK_OPERATION_NOT_DEFERRED_KHR);
  default:
    return "Unknown VkResult value";
  }
#undef RESULT_CASE
}

const char* lvk::getVkDeviceFaultAddressTypeString(VkDeviceFaultAddressTypeEXT type) {
#define RESULT_CASE(res) \
  case res:              \
    return #res
  switch (type) {
    RESULT_CASE(VK_DEVICE_FAULT_ADDRESS_TYPE_NONE_EXT);
    RESULT_CASE(VK_DEVICE_FAULT_ADDRESS_TYPE_READ_INVALID_EXT);
    RESULT_CASE(VK_DEVICE_FAULT_ADDRESS_TYPE_WRITE_INVALID_EXT);
    RESULT_CASE(VK_DEVICE_FAULT_ADDRESS_TYPE_EXECUTE_INVALID_EXT);
    RESULT_CASE(VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_UNKNOWN_EXT);
    RESULT_CASE(VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_INVALID_EXT);
    RESULT_CASE(VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_FAULT_EXT);
  default:
    return "Unknown VkDeviceFaultAddressTypeEXT value";
  };
#undef RESULT_CASE
};

void lvk::setResultFrom(Result* outResult, VkResult result) {
  if (outResult) {
    *outResult = getResultFromVkResult(result);
  }
}

lvk::PresentMode lvk::vkPresentModeToPresentMode(VkPresentModeKHR mode) {
  switch (mode) {
  case VK_PRESENT_MODE_IMMEDIATE_KHR:
    return lvk::PresentMode_Immediate;
  case VK_PRESENT_MODE_MAILBOX_KHR:
    return lvk::PresentMode_Mailbox;
  case VK_PRESENT_MODE_FIFO_KHR:
    return lvk::PresentMode_FIFO;
  case VK_PRESENT_MODE_FIFO_RELAXED_KHR:
    return lvk::PresentMode_FIFO_Relaxed;
  case VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR:
    return lvk::PresentMode_Shared_Demand_Refresh;
  case VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR:
    return lvk::PresentMode_Shared_Continuous_Refresh;
  case VK_PRESENT_MODE_FIFO_LATEST_READY_KHR:
    return lvk::PresentMode_FIFO_Latest_Ready;
  case VK_PRESENT_MODE_MAX_ENUM_KHR:
    LVK_ASSERT(false);
    return lvk::PresentMode_FIFO;
  }
#if defined(_MSC_VER) || defined(__GNUC__)
  LVK_ASSERT(false);
  return lvk::PresentMode_FIFO;
#endif // _MSC_VER
}

VkPresentModeKHR lvk::presentModeToVkPresentMode(lvk::PresentMode mode) {
  switch (mode) {
  case lvk::PresentMode_Immediate:
    return VK_PRESENT_MODE_IMMEDIATE_KHR;
  case lvk::PresentMode_Mailbox:
    return VK_PRESENT_MODE_MAILBOX_KHR;
  case lvk::PresentMode_FIFO:
    return VK_PRESENT_MODE_FIFO_KHR;
  case lvk::PresentMode_FIFO_Relaxed:
    return VK_PRESENT_MODE_FIFO_RELAXED_KHR;
  case lvk::PresentMode_Shared_Demand_Refresh:
    return VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR;
  case lvk::PresentMode_Shared_Continuous_Refresh:
    return VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR;
  case lvk::PresentMode_FIFO_Latest_Ready:
    return VK_PRESENT_MODE_FIFO_LATEST_READY_KHR;
  }
#if defined(_MSC_VER) || defined(__GNUC__)
  LVK_ASSERT(false);
  return VK_PRESENT_MODE_FIFO_KHR;
#endif // _MSC_VER
}

lvk::Result lvk::getResultFromVkResult(VkResult result) {
  if (result == VK_SUCCESS) {
    return Result();
  }

  Result res(Result::Code::RuntimeError, lvk::getVulkanResultString(result));

  switch (result) {
  case VK_ERROR_OUT_OF_HOST_MEMORY:
  case VK_ERROR_OUT_OF_DEVICE_MEMORY:
  case VK_ERROR_OUT_OF_POOL_MEMORY:
  case VK_ERROR_TOO_MANY_OBJECTS:
    res.code = Result::Code::ArgumentOutOfRange;
    return res;
  default:;
    // skip other Vulkan error codes
  }
  return res;
}

VkFormat lvk::formatToVkFormat(lvk::Format format) {
  using TextureFormat = ::lvk::Format;
  switch (format) {
  case lvk::Format_Invalid:
    return VK_FORMAT_UNDEFINED;
  case lvk::Format_R_UN8:
    return VK_FORMAT_R8_UNORM;
  case lvk::Format_R_UN16:
    return VK_FORMAT_R16_UNORM;
  case lvk::Format_R_F16:
    return VK_FORMAT_R16_SFLOAT;
  case lvk::Format_R_UI16:
    return VK_FORMAT_R16_UINT;
  case lvk::Format_R_UI32:
    return VK_FORMAT_R32_UINT;
  case lvk::Format_RG_UN8:
    return VK_FORMAT_R8G8_UNORM;
  case lvk::Format_RG_UI16:
    return VK_FORMAT_R16G16_UINT;
  case lvk::Format_RG_UI32:
    return VK_FORMAT_R32G32_UINT;
  case lvk::Format_RG_UN16:
    return VK_FORMAT_R16G16_UNORM;
  case lvk::Format_BGRA_UN8:
    return VK_FORMAT_B8G8R8A8_UNORM;
  case lvk::Format_RGBA_UN8:
    return VK_FORMAT_R8G8B8A8_UNORM;
  case lvk::Format_RGBA_SRGB8:
    return VK_FORMAT_R8G8B8A8_SRGB;
  case lvk::Format_BGRA_SRGB8:
    return VK_FORMAT_B8G8R8A8_SRGB;
  case lvk::Format_RG_F16:
    return VK_FORMAT_R16G16_SFLOAT;
  case lvk::Format_RG_F32:
    return VK_FORMAT_R32G32_SFLOAT;
  case lvk::Format_R_F32:
    return VK_FORMAT_R32_SFLOAT;
  case lvk::Format_RGBA_F16:
    return VK_FORMAT_R16G16B16A16_SFLOAT;
  case lvk::Format_RGBA_UI32:
    return VK_FORMAT_R32G32B32A32_UINT;
  case lvk::Format_RGBA_F32:
    return VK_FORMAT_R32G32B32A32_SFLOAT;
  case lvk::Format_A2B10G10R10_UN:
    return VK_FORMAT_A2B10G10R10_UNORM_PACK32;
  case lvk::Format_A2R10G10B10_UN:
    return VK_FORMAT_A2R10G10B10_UNORM_PACK32;
  case lvk::Format_ETC2_RGB8:
    return VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK;
  case lvk::Format_ETC2_SRGB8:
    return VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK;
  case lvk::Format_BC7_RGBA:
    return VK_FORMAT_BC7_UNORM_BLOCK;
  case lvk::Format_Z_UN16:
    return VK_FORMAT_D16_UNORM;
  case lvk::Format_Z_UN24:
    return VK_FORMAT_D24_UNORM_S8_UINT;
  case lvk::Format_Z_F32:
    return VK_FORMAT_D32_SFLOAT;
  case lvk::Format_Z_UN24_S_UI8:
    return VK_FORMAT_D24_UNORM_S8_UINT;
  case lvk::Format_Z_F32_S_UI8:
    return VK_FORMAT_D32_SFLOAT_S8_UINT;
  case lvk::Format_YUV_NV12:
    return VK_FORMAT_G8_B8R8_2PLANE_420_UNORM;
  case lvk::Format_YUV_420p:
    return VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM;
  }
#if defined(_MSC_VER) || defined(__GNUC__)
  LVK_ASSERT_MSG(false, "TextureFormat value not handled: %d", (int)format);
  return VK_FORMAT_UNDEFINED;
#endif // _MSC_VER
}

lvk::ColorSpace lvk::vkColorSpaceToColorSpace(VkColorSpaceKHR colorSpace) {
  switch (colorSpace) {
  case VK_COLOR_SPACE_SRGB_NONLINEAR_KHR:
    return ColorSpace_SRGB_NONLINEAR;
  case VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT:
    return ColorSpace_SRGB_EXTENDED_LINEAR;
  case VK_COLOR_SPACE_HDR10_ST2084_EXT:
    return ColorSpace_HDR10;
  case VK_COLOR_SPACE_BT709_LINEAR_EXT:
    return ColorSpace_BT709_LINEAR;
  default:
    LVK_ASSERT_MSG(false, "Unsupported color space %u", (uint32_t)colorSpace);
    return ColorSpace_SRGB_NONLINEAR;
  }
}

lvk::Format lvk::vkFormatToFormat(VkFormat format) {
  switch (format) {
  case VK_FORMAT_UNDEFINED:
    return Format_Invalid;
  case VK_FORMAT_R8_UNORM:
    return Format_R_UN8;
  case VK_FORMAT_R16_UNORM:
    return Format_R_UN16;
  case VK_FORMAT_R16_SFLOAT:
    return Format_R_F16;
  case VK_FORMAT_R16_UINT:
    return Format_R_UI16;
  case VK_FORMAT_R8G8_UNORM:
    return Format_RG_UN8;
  case VK_FORMAT_B8G8R8A8_UNORM:
    return Format_BGRA_UN8;
  case VK_FORMAT_R8G8B8A8_UNORM:
    return Format_RGBA_UN8;
  case VK_FORMAT_R8G8B8A8_SRGB:
    return Format_RGBA_SRGB8;
  case VK_FORMAT_B8G8R8A8_SRGB:
    return Format_BGRA_SRGB8;
  case VK_FORMAT_R16G16_UNORM:
    return Format_RG_UN16;
  case VK_FORMAT_R16G16_SFLOAT:
    return Format_RG_F16;
  case VK_FORMAT_R32G32_SFLOAT:
    return Format_RG_F32;
  case VK_FORMAT_R16G16_UINT:
    return Format_RG_UI16;
  case VK_FORMAT_R32_SFLOAT:
    return Format_R_F32;
  case VK_FORMAT_R16G16B16A16_SFLOAT:
    return Format_RGBA_F16;
  case VK_FORMAT_R32G32B32A32_UINT:
    return Format_RGBA_UI32;
  case VK_FORMAT_R32G32B32A32_SFLOAT:
    return Format_RGBA_F32;
  case VK_FORMAT_A2B10G10R10_UNORM_PACK32:
    return Format_A2B10G10R10_UN;
  case VK_FORMAT_A2R10G10B10_UNORM_PACK32:
    return Format_A2R10G10B10_UN;
  case VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK:
    return Format_ETC2_RGB8;
  case VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK:
    return Format_ETC2_SRGB8;
  case VK_FORMAT_D16_UNORM:
    return Format_Z_UN16;
  case VK_FORMAT_BC7_UNORM_BLOCK:
    return Format_BC7_RGBA;
  case VK_FORMAT_X8_D24_UNORM_PACK32:
    return Format_Z_UN24;
  case VK_FORMAT_D24_UNORM_S8_UINT:
    return Format_Z_UN24_S_UI8;
  case VK_FORMAT_D32_SFLOAT:
    return Format_Z_F32;
  case VK_FORMAT_D32_SFLOAT_S8_UINT:
    return Format_Z_F32_S_UI8;
  case VK_FORMAT_G8_B8R8_2PLANE_420_UNORM:
    return Format_YUV_NV12;
  case VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM:
    return Format_YUV_420p;
  default:;
  }
  LVK_ASSERT_MSG(false, "VkFormat value not handled: %d", (int)format);
  return Format_Invalid;
}

VkSemaphore lvk::createSemaphore(VkDevice device, const char* debugName) {
  const VkSemaphoreCreateInfo ci = {
      .sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
      .flags = 0,
  };
  VkSemaphore semaphore = VK_NULL_HANDLE;
  VK_ASSERT(vkCreateSemaphore(device, &ci, nullptr, &semaphore));
  VK_ASSERT(lvk::setDebugObjectName(device, VK_OBJECT_TYPE_SEMAPHORE, (uint64_t)semaphore, debugName));
  return semaphore;
}

VkSemaphore lvk::createSemaphoreTimeline(VkDevice device, uint64_t initialValue, const char* debugName) {
  const VkSemaphoreTypeCreateInfo semaphoreTypeCreateInfo = {
      .sType = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO,
      .semaphoreType = VK_SEMAPHORE_TYPE_TIMELINE,
      .initialValue = initialValue,
  };
  const VkSemaphoreCreateInfo ci = {
      .sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
      .pNext = &semaphoreTypeCreateInfo,
      .flags = 0,
  };
  VkSemaphore semaphore = VK_NULL_HANDLE;
  VK_ASSERT(vkCreateSemaphore(device, &ci, nullptr, &semaphore));
  VK_ASSERT(lvk::setDebugObjectName(device, VK_OBJECT_TYPE_SEMAPHORE, (uint64_t)semaphore, debugName));
  return semaphore;
}

VkFence lvk::createFence(VkDevice device, const char* debugName, bool isSignaled) {
  const VkFenceCreateInfo ci = {
      .sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO,
      .flags = isSignaled ? VK_FENCE_CREATE_SIGNALED_BIT : 0u,
  };
  VkFence fence = VK_NULL_HANDLE;
  VK_ASSERT(vkCreateFence(device, &ci, nullptr, &fence));
  VK_ASSERT(lvk::setDebugObjectName(device, VK_OBJECT_TYPE_FENCE, (uint64_t)fence, debugName));
  return fence;
}

uint32_t lvk::findQueueFamilyIndex(VkPhysicalDevice physDev, VkQueueFlags flags) {
  using lvk::DeviceQueues;

  uint32_t queueFamilyCount = 0;
  vkGetPhysicalDeviceQueueFamilyProperties2(physDev, &queueFamilyCount, nullptr);

  std::vector<VkQueueFamilyProperties2> props(queueFamilyCount);
  for (VkQueueFamilyProperties2& p : props) {
    // https://docs.vulkan.org/spec/latest/chapters/devsandqueues.html#VUID-VkQueueFamilyProperties2-sType-sType
    p.sType = VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2;
  }
  vkGetPhysicalDeviceQueueFamilyProperties2(physDev, &queueFamilyCount, props.data());

  auto findDedicatedQueueFamilyIndex = [&props](VkQueueFlags require, VkQueueFlags avoid) -> uint32_t {
    for (uint32_t i = 0; i != props.size(); i++) {
      const VkQueueFamilyProperties& p = props[i].queueFamilyProperties;
      const bool isSuitable = (p.queueFlags & require) == require;
      const bool isDedicated = (p.queueFlags & avoid) == 0;
      if (p.queueCount && isSuitable && isDedicated)
        return i;
    }
    return DeviceQueues::INVALID;
  };

  // dedicated queue for compute
  if (flags & VK_QUEUE_COMPUTE_BIT) {
    const uint32_t q = findDedicatedQueueFamilyIndex(flags, VK_QUEUE_GRAPHICS_BIT);
    if (q != DeviceQueues::INVALID)
      return q;
  }

  // dedicated queue for transfer
  if (flags & VK_QUEUE_TRANSFER_BIT) {
    const uint32_t q = findDedicatedQueueFamilyIndex(flags, VK_QUEUE_GRAPHICS_BIT);
    if (q != DeviceQueues::INVALID)
      return q;
  }

  // any suitable
  return findDedicatedQueueFamilyIndex(flags, 0);
}

VmaAllocator lvk::createVmaAllocator(VkPhysicalDevice physDev, VkDevice device, VkInstance instance, uint32_t apiVersion) {
  const VmaVulkanFunctions funcs = {
      .vkGetInstanceProcAddr = vkGetInstanceProcAddr,
      .vkGetDeviceProcAddr = vkGetDeviceProcAddr,
      .vkGetPhysicalDeviceProperties = vkGetPhysicalDeviceProperties,
      .vkGetPhysicalDeviceMemoryProperties = vkGetPhysicalDeviceMemoryProperties,
      .vkAllocateMemory = vkAllocateMemory,
      .vkFreeMemory = vkFreeMemory,
      .vkMapMemory = vkMapMemory,
      .vkUnmapMemory = vkUnmapMemory,
      .vkFlushMappedMemoryRanges = vkFlushMappedMemoryRanges,
      .vkInvalidateMappedMemoryRanges = vkInvalidateMappedMemoryRanges,
      .vkBindBufferMemory = vkBindBufferMemory,
      .vkBindImageMemory = vkBindImageMemory,
      .vkGetBufferMemoryRequirements = vkGetBufferMemoryRequirements,
      .vkGetImageMemoryRequirements = vkGetImageMemoryRequirements,
      .vkCreateBuffer = vkCreateBuffer,
      .vkDestroyBuffer = vkDestroyBuffer,
      .vkCreateImage = vkCreateImage,
      .vkDestroyImage = vkDestroyImage,
      .vkCmdCopyBuffer = vkCmdCopyBuffer,
      .vkGetBufferMemoryRequirements2KHR = vkGetBufferMemoryRequirements2,
      .vkGetImageMemoryRequirements2KHR = vkGetImageMemoryRequirements2,
      .vkBindBufferMemory2KHR = vkBindBufferMemory2,
      .vkBindImageMemory2KHR = vkBindImageMemory2,
      .vkGetPhysicalDeviceMemoryProperties2KHR = vkGetPhysicalDeviceMemoryProperties2,
      .vkGetDeviceBufferMemoryRequirements = vkGetDeviceBufferMemoryRequirements,
      .vkGetDeviceImageMemoryRequirements = vkGetDeviceImageMemoryRequirements,
  };

  const VmaAllocatorCreateInfo ci = {
      .flags = VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT,
      .physicalDevice = physDev,
      .device = device,
      .preferredLargeHeapBlockSize = 0,
      .pAllocationCallbacks = nullptr,
      .pDeviceMemoryCallbacks = nullptr,
      .pHeapSizeLimit = nullptr,
      .pVulkanFunctions = &funcs,
      .instance = instance,
      .vulkanApiVersion = apiVersion,
  };
  VmaAllocator vma = VK_NULL_HANDLE;
  VK_ASSERT(vmaCreateAllocator(&ci, &vma));
  return vma;
}

glslang_resource_t lvk::getGlslangResource(const VkPhysicalDeviceLimits& limits) {
  const glslang_resource_t resource = {
      .max_lights = 32,
      .max_clip_planes = (int)limits.maxClipDistances,
      .max_texture_units = 32,
      .max_texture_coords = 32,
      .max_vertex_attribs = (int)limits.maxVertexInputAttributes,
      .max_vertex_uniform_components = (int)limits.maxUniformBufferRange / 4,
      .max_varying_floats = (int)std::min(limits.maxVertexOutputComponents, limits.maxFragmentInputComponents),
      .max_vertex_texture_image_units = 32,
      .max_combined_texture_image_units = 80,
      .max_texture_image_units = 32,
      .max_fragment_uniform_components = 4096,
      .max_draw_buffers = 32,
      .max_vertex_uniform_vectors = 128,
      .max_varying_vectors = 8,
      .max_fragment_uniform_vectors = 16,
      .max_vertex_output_vectors = (int)limits.maxVertexOutputComponents / 4,
      .max_fragment_input_vectors = (int)limits.maxFragmentInputComponents / 4,
      .min_program_texel_offset = limits.minTexelOffset,
      .max_program_texel_offset = (int)limits.maxTexelOffset,
      .max_clip_distances = (int)limits.maxClipDistances,
      .max_compute_work_group_count_x = (int)limits.maxComputeWorkGroupCount[0],
      .max_compute_work_group_count_y = (int)limits.maxComputeWorkGroupCount[1],
      .max_compute_work_group_count_z = (int)limits.maxComputeWorkGroupCount[2],
      .max_compute_work_group_size_x = (int)limits.maxComputeWorkGroupSize[0],
      .max_compute_work_group_size_y = (int)limits.maxComputeWorkGroupSize[1],
      .max_compute_work_group_size_z = (int)limits.maxComputeWorkGroupSize[2],
      .max_compute_uniform_components = 1024,
      .max_compute_texture_image_units = 16,
      .max_compute_image_uniforms = 8,
      .max_compute_atomic_counters = 8,
      .max_compute_atomic_counter_buffers = 1,
      .max_varying_components = 60,
      .max_vertex_output_components = (int)limits.maxVertexOutputComponents,
      .max_geometry_input_components = (int)limits.maxGeometryInputComponents,
      .max_geometry_output_components = (int)limits.maxGeometryOutputComponents,
      .max_fragment_input_components = (int)limits.maxFragmentInputComponents,
      .max_image_units = 8,
      .max_combined_image_units_and_fragment_outputs = 8,
      .max_combined_shader_output_resources = 8,
      .max_image_samples = 0,
      .max_vertex_image_uniforms = 0,
      .max_tess_control_image_uniforms = 0,
      .max_tess_evaluation_image_uniforms = 0,
      .max_geometry_image_uniforms = 0,
      .max_fragment_image_uniforms = 8,
      .max_combined_image_uniforms = 8,
      .max_geometry_texture_image_units = 16,
      .max_geometry_output_vertices = (int)limits.maxGeometryOutputVertices,
      .max_geometry_total_output_components = (int)limits.maxGeometryTotalOutputComponents,
      .max_geometry_uniform_components = 1024,
      .max_geometry_varying_components = 64,
      .max_tess_control_input_components = (int)limits.maxTessellationControlPerVertexInputComponents,
      .max_tess_control_output_components = (int)limits.maxTessellationControlPerVertexOutputComponents,
      .max_tess_control_texture_image_units = 16,
      .max_tess_control_uniform_components = 1024,
      .max_tess_control_total_output_components = 4096,
      .max_tess_evaluation_input_components = (int)limits.maxTessellationEvaluationInputComponents,
      .max_tess_evaluation_output_components = (int)limits.maxTessellationEvaluationOutputComponents,
      .max_tess_evaluation_texture_image_units = 16,
      .max_tess_evaluation_uniform_components = 1024,
      .max_tess_patch_components = 120,
      .max_patch_vertices = 32,
      .max_tess_gen_level = 64,
      .max_viewports = (int)limits.maxViewports,
      .max_vertex_atomic_counters = 0,
      .max_tess_control_atomic_counters = 0,
      .max_tess_evaluation_atomic_counters = 0,
      .max_geometry_atomic_counters = 0,
      .max_fragment_atomic_counters = 8,
      .max_combined_atomic_counters = 8,
      .max_atomic_counter_bindings = 1,
      .max_vertex_atomic_counter_buffers = 0,
      .max_tess_control_atomic_counter_buffers = 0,
      .max_tess_evaluation_atomic_counter_buffers = 0,
      .max_geometry_atomic_counter_buffers = 0,
      .max_fragment_atomic_counter_buffers = 1,
      .max_combined_atomic_counter_buffers = 1,
      .max_atomic_counter_buffer_size = 16384,
      .max_transform_feedback_buffers = 4,
      .max_transform_feedback_interleaved_components = 64,
      .max_cull_distances = (int)limits.maxCullDistances,
      .max_combined_clip_and_cull_distances = (int)limits.maxCombinedClipAndCullDistances,
      .max_samples = 4,
      .max_mesh_output_vertices_nv = 256,
      .max_mesh_output_primitives_nv = 512,
      .max_mesh_work_group_size_x_nv = 32,
      .max_mesh_work_group_size_y_nv = 1,
      .max_mesh_work_group_size_z_nv = 1,
      .max_task_work_group_size_x_nv = 32,
      .max_task_work_group_size_y_nv = 1,
      .max_task_work_group_size_z_nv = 1,
      .max_mesh_view_count_nv = 4,
      .max_mesh_output_vertices_ext = 256,
      .max_mesh_output_primitives_ext = 512,
      .max_mesh_work_group_size_x_ext = 32,
      .max_mesh_work_group_size_y_ext = 1,
      .max_mesh_work_group_size_z_ext = 1,
      .max_task_work_group_size_x_ext = 32,
      .max_task_work_group_size_y_ext = 1,
      .max_task_work_group_size_z_ext = 1,
      .max_mesh_view_count_ext = 4,
      .maxDualSourceDrawBuffersEXT = 1,
      .limits =
          {
              .non_inductive_for_loops = true,
              .while_loops = true,
              .do_while_loops = true,
              .general_uniform_indexing = true,
              .general_attribute_matrix_vector_indexing = true,
              .general_varying_indexing = true,
              .general_sampler_indexing = true,
              .general_variable_indexing = true,
              .general_constant_matrix_vector_indexing = true,
          },
  };

  return resource;
}

namespace {

VkFilter samplerFilterToVkFilter(lvk::SamplerFilter filter) {
  switch (filter) {
  case lvk::SamplerFilter_Nearest:
    return VK_FILTER_NEAREST;
  case lvk::SamplerFilter_Linear:
    return VK_FILTER_LINEAR;
  }
  LVK_ASSERT_MSG(false, "SamplerFilter value not handled: %d", (int)filter);
  return VK_FILTER_LINEAR;
}

VkSamplerMipmapMode samplerMipMapToVkSamplerMipmapMode(lvk::SamplerMip filter) {
  switch (filter) {
  case lvk::SamplerMip_Disabled:
  case lvk::SamplerMip_Nearest:
    return VK_SAMPLER_MIPMAP_MODE_NEAREST;
  case lvk::SamplerMip_Linear:
    return VK_SAMPLER_MIPMAP_MODE_LINEAR;
  }
  LVK_ASSERT_MSG(false, "SamplerMipMap value not handled: %d", (int)filter);
  return VK_SAMPLER_MIPMAP_MODE_NEAREST;
}

VkSamplerAddressMode samplerWrapModeToVkSamplerAddressMode(lvk::SamplerWrap mode) {
  switch (mode) {
  case lvk::SamplerWrap_Repeat:
    return VK_SAMPLER_ADDRESS_MODE_REPEAT;
  case lvk::SamplerWrap_Clamp:
    return VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
  case lvk::SamplerWrap_ClampToBorder:
    return VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER;
  case lvk::SamplerWrap_MirrorRepeat:
    return VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT;
  case lvk::SamplerWrap_MirrorClampToEdge:
    return VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE;
  }
  LVK_ASSERT_MSG(false, "SamplerWrapMode value not handled: %d", (int)mode);
  return VK_SAMPLER_ADDRESS_MODE_REPEAT;
}

} // namespace

VkSamplerCreateInfo lvk::samplerStateDescToVkSamplerCreateInfo(const lvk::SamplerStateDesc& desc, const VkPhysicalDeviceLimits& limits) {
  LVK_ASSERT_MSG(desc.mipLodMax >= desc.mipLodMin,
                 "mipLodMax (%d) must be greater than or equal to mipLodMin (%d)",
                 (int)desc.mipLodMax,
                 (int)desc.mipLodMin);

  VkSamplerCreateInfo ci = {
      .sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,
      .pNext = nullptr,
      .flags = 0,
      .magFilter = samplerFilterToVkFilter(desc.magFilter),
      .minFilter = samplerFilterToVkFilter(desc.minFilter),
      .mipmapMode = samplerMipMapToVkSamplerMipmapMode(desc.mipMap),
      .addressModeU = samplerWrapModeToVkSamplerAddressMode(desc.wrapU),
      .addressModeV = samplerWrapModeToVkSamplerAddressMode(desc.wrapV),
      .addressModeW = samplerWrapModeToVkSamplerAddressMode(desc.wrapW),
      .mipLodBias = 0.0f,
      .anisotropyEnable = VK_FALSE,
      .maxAnisotropy = 0.0f,
      .compareEnable = desc.depthCompareEnabled ? VK_TRUE : VK_FALSE,
      .compareOp = desc.depthCompareEnabled ? lvk::compareOpToVkCompareOp(desc.depthCompareOp) : VK_COMPARE_OP_ALWAYS,
      .minLod = float(desc.mipLodMin),
      .maxLod = desc.mipMap == lvk::SamplerMip_Disabled ? float(desc.mipLodMin) : float(desc.mipLodMax),
      .borderColor = VK_BORDER_COLOR_INT_OPAQUE_BLACK,
      .unnormalizedCoordinates = VK_FALSE,
  };

  if (desc.maxAnisotropic > 1) {
    const bool isAnisotropicFilteringSupported = limits.maxSamplerAnisotropy > 1;
    LVK_ASSERT_MSG(isAnisotropicFilteringSupported, "Anisotropic filtering is not supported by the device.");
    ci.anisotropyEnable = isAnisotropicFilteringSupported ? VK_TRUE : VK_FALSE;

    if (limits.maxSamplerAnisotropy < desc.maxAnisotropic) {
      LLOGL(
          "Supplied sampler anisotropic value greater than max supported by the device, setting to "
          "%.0f",
          static_cast<double>(limits.maxSamplerAnisotropy));
    }
    ci.maxAnisotropy = std::min((float)limits.maxSamplerAnisotropy, (float)desc.maxAnisotropic);
  }

  return ci;
}

static glslang_stage_t getGLSLangShaderStage(lvk::ShaderStage stage) {
  switch (stage) {
  case lvk::ShaderStage::Stage_Vert:
    return GLSLANG_STAGE_VERTEX;
  case lvk::ShaderStage::Stage_Tesc:
    return GLSLANG_STAGE_TESSCONTROL;
  case lvk::ShaderStage::Stage_Tese:
    return GLSLANG_STAGE_TESSEVALUATION;
  case lvk::ShaderStage::Stage_Geom:
    return GLSLANG_STAGE_GEOMETRY;
  case lvk::ShaderStage::Stage_Frag:
    return GLSLANG_STAGE_FRAGMENT;
  case lvk::ShaderStage::Stage_Comp:
    return GLSLANG_STAGE_COMPUTE;
  case lvk::ShaderStage::Stage_Task:
    return GLSLANG_STAGE_TASK;
  case lvk::ShaderStage::Stage_Mesh:
    return GLSLANG_STAGE_MESH;

  // ray tracing
  case lvk::ShaderStage::Stage_RayGen:
    return GLSLANG_STAGE_RAYGEN;
  case lvk::ShaderStage::Stage_AnyHit:
    return GLSLANG_STAGE_ANYHIT;
  case lvk::ShaderStage::Stage_ClosestHit:
    return GLSLANG_STAGE_CLOSESTHIT;
  case lvk::ShaderStage::Stage_Miss:
    return GLSLANG_STAGE_MISS;
  case lvk::ShaderStage::Stage_Intersection:
    return GLSLANG_STAGE_INTERSECT;
  case lvk::ShaderStage::Stage_Callable:
    return GLSLANG_STAGE_CALLABLE;
  default:
    assert(false);
  };
  assert(false);
  return GLSLANG_STAGE_COUNT;
}

lvk::Result lvk::compileShaderGlslang(lvk::ShaderStage stage,
                                      const char* code,
                                      std::vector<uint8_t>* outSPIRV,
                                      const glslang_resource_t* glslLangResource) {
  LVK_PROFILER_FUNCTION();

  if (!outSPIRV) {
    return Result(Result::Code::ArgumentOutOfRange, "outSPIRV is NULL");
  }

  const glslang_input_t input = {
      .language = GLSLANG_SOURCE_GLSL,
      .stage = getGLSLangShaderStage(stage),
      .client = GLSLANG_CLIENT_VULKAN,
      .client_version = GLSLANG_TARGET_VULKAN_1_3,
      .target_language = GLSLANG_TARGET_SPV,
      .target_language_version = GLSLANG_TARGET_SPV_1_6,
      .code = code,
      .default_version = 100,
      .default_profile = GLSLANG_NO_PROFILE,
      .force_default_version_and_profile = false,
      .forward_compatible = false,
      .messages = GLSLANG_MSG_DEFAULT_BIT,
      .resource = glslLangResource,
  };

  glslang_shader_t* shader = glslang_shader_create(&input);
  SCOPE_EXIT {
    glslang_shader_delete(shader);
  };

  if (!glslang_shader_preprocess(shader, &input)) {
    LLOGW("Shader preprocessing failed:\n");
    LLOGW("  %s\n", glslang_shader_get_info_log(shader));
    LLOGW("  %s\n", glslang_shader_get_info_debug_log(shader));
    lvk::logShaderSource(code);
    assert(false);
    return Result(Result::Code::RuntimeError, "glslang_shader_preprocess() failed");
  }

  if (!glslang_shader_parse(shader, &input)) {
    LLOGW("Shader parsing failed:\n");
    LLOGW("  %s\n", glslang_shader_get_info_log(shader));
    LLOGW("  %s\n", glslang_shader_get_info_debug_log(shader));
    lvk::logShaderSource(glslang_shader_get_preprocessed_code(shader));
    assert(false);
    return Result(Result::Code::RuntimeError, "glslang_shader_parse() failed");
  }

  glslang_program_t* program = glslang_program_create();
  glslang_program_add_shader(program, shader);

  SCOPE_EXIT {
    glslang_program_delete(program);
  };

  if (!glslang_program_link(program, GLSLANG_MSG_SPV_RULES_BIT | GLSLANG_MSG_VULKAN_RULES_BIT)) {
    LLOGW("Shader linking failed:\n");
    LLOGW("  %s\n", glslang_program_get_info_log(program));
    LLOGW("  %s\n", glslang_program_get_info_debug_log(program));
    assert(false);
    return Result(Result::Code::RuntimeError, "glslang_program_link() failed");
  }

  glslang_spv_options_t options = {
      .generate_debug_info = true,
      .strip_debug_info = false,
      .disable_optimizer = false,
      .optimize_size = true,
      .disassemble = false,
      .validate = true,
      .emit_nonsemantic_shader_debug_info = false,
      .emit_nonsemantic_shader_debug_source = false,
  };

  glslang_program_SPIRV_generate_with_options(program, input.stage, &options);

  if (glslang_program_SPIRV_get_messages(program)) {
    LLOGW("%s\n", glslang_program_SPIRV_get_messages(program));
  }

  const uint8_t* spirv = reinterpret_cast<const uint8_t*>(glslang_program_SPIRV_get_ptr(program));
  const size_t numBytes = glslang_program_SPIRV_get_size(program) * sizeof(uint32_t);

  *outSPIRV = std::vector(spirv, spirv + numBytes);

  return Result();
}

lvk::Result lvk::compileShaderSlang(lvk::ShaderStage stage,
                                    const char* code,
                                    const char* entryPointName,
                                    std::vector<uint8_t>* outSPIRV) {
  LVK_PROFILER_FUNCTION();

  if (!outSPIRV) {
    return Result(Result::Code::ArgumentOutOfRange, "outSPIRV is NULL");
  }

#if defined(LVK_WITH_SLANG) && LVK_WITH_SLANG
  Slang::ComPtr<slang::IGlobalSession> slangGlobalSession;
  if (SLANG_FAILED(slang::createGlobalSession(slangGlobalSession.writeRef()))) {
    return Result(Result::Code::RuntimeError, "slang::createGlobalSession() failed");
  }

  const slang::CompilerOptionEntry compilerOptions[] = {
      {.name = slang::CompilerOptionName::Capability,
       .value = {.kind = slang::CompilerOptionValueKind::String, .stringValue0 = "SPV_GOOGLE_user_type"}},
      {.name = slang::CompilerOptionName::Capability,
       .value = {.kind = slang::CompilerOptionValueKind::String, .stringValue0 = "spvDerivativeControl"}},
      {.name = slang::CompilerOptionName::Capability,
       .value = {.kind = slang::CompilerOptionValueKind::String, .stringValue0 = "spvImageQuery"}},
      {.name = slang::CompilerOptionName::Capability,
       .value = {.kind = slang::CompilerOptionValueKind::String, .stringValue0 = "spvImageGatherExtended"}},
      {.name = slang::CompilerOptionName::Capability,
       .value = {.kind = slang::CompilerOptionValueKind::String, .stringValue0 = "spvSparseResidency"}},
      {.name = slang::CompilerOptionName::Capability,
       .value = {.kind = slang::CompilerOptionValueKind::String, .stringValue0 = "spvMinLod"}},
      {.name = slang::CompilerOptionName::Capability,
       .value = {.kind = slang::CompilerOptionValueKind::String, .stringValue0 = "spvFragmentFullyCoveredEXT"}},
      {.name = slang::CompilerOptionName::Capability,
       .value = {.kind = slang::CompilerOptionValueKind::String, .stringValue0 = "spvRayTracingPositionFetchKHR"}},
      {.name = slang::CompilerOptionName::Capability,
       .value = {.kind = slang::CompilerOptionValueKind::String, .stringValue0 = "spvRayQueryKHR"}},
  };

  const slang::TargetDesc targetDesc = {
      .format = SLANG_SPIRV,
      .profile = slangGlobalSession->findProfile("spirv_1_6"),
      .flags = SLANG_TARGET_FLAG_GENERATE_SPIRV_DIRECTLY,
      .forceGLSLScalarBufferLayout = true,
      .compilerOptionEntries = &compilerOptions[0],
      .compilerOptionEntryCount = LVK_ARRAY_NUM_ELEMENTS(compilerOptions),
  };

  const slang::SessionDesc sessionDesc = {
      .targets = &targetDesc,
      .targetCount = 1,
  };

  Slang::ComPtr<slang::ISession> session;
  if (SLANG_FAILED(slangGlobalSession->createSession(sessionDesc, session.writeRef()))) {
    return Result(Result::Code::RuntimeError, "slang::createSession() failed");
  }

  slang::IModule* slangModule = nullptr;
  {
    Slang::ComPtr<slang::IBlob> diagnosticBlob;
    slangModule = session->loadModuleFromSourceString("", "", code, diagnosticBlob.writeRef());
    if (diagnosticBlob) {
      LLOGW("%s", (const char*)diagnosticBlob->getBufferPointer());
    }
    if (!slangModule) {
      return Result(Result::Code::RuntimeError, "slang::loadModuleFromSourceString() failed");
    }
  }

  Slang::ComPtr<slang::IEntryPoint> entryPoint;
  entryPointName = entryPointName ? entryPointName : [stage]() {
    switch (stage) {
    case lvk::Stage_Vert:
      return "vertexMain";
    case lvk::Stage_Frag:
      return "fragmentMain";
    case lvk::Stage_Comp:
      return "computeMain";
    case lvk::Stage_Task:
      return "taskMain";
    case lvk::Stage_Mesh:
      return "meshMain";
    case lvk::Stage_RayGen:
      return "rayGenMain";
    case Stage_AnyHit:
      return "anyHitMain";
    case Stage_ClosestHit:
      return "closestHitMain";
    case Stage_Miss:
      return "missMain";
    case Stage_Intersection:
      return "intersectionMain";
    case Stage_Callable:
      return "callableMain";
    }
    return "unknown shader type";
  }();
  if (SLANG_FAILED(slangModule->findEntryPointByName(entryPointName, entryPoint.writeRef()))) {
    LVK_ASSERT_MSG(entryPoint, "Entry point %s() not found", entryPointName);
    return Result(Result::Code::RuntimeError, "Entry point not found");
  }

  Slang::List<slang::IComponentType*> componentTypes;
  componentTypes.add(slangModule);
  componentTypes.add(entryPoint);

  Slang::ComPtr<slang::IComponentType> composedProgram;
  {
    Slang::ComPtr<slang::IBlob> diagnosticBlob;
    SlangResult result = session->createCompositeComponentType(
        componentTypes.getBuffer(), componentTypes.getCount(), composedProgram.writeRef(), diagnosticBlob.writeRef());
    if (diagnosticBlob) {
      LLOGW("%s\n", (const char*)diagnosticBlob->getBufferPointer());
    }
    if (SLANG_FAILED(result)) {
      LVK_ASSERT_MSG(false, "slang::createCompositeComponentType() failed");
      return Result(Result::Code::RuntimeError, "slang::createCompositeComponentType() failed");
    }
  }

  Slang::ComPtr<slang::IBlob> spirvCode;
  {
    Slang::ComPtr<slang::IBlob> diagnosticBlob;
    const int entryPointIndex = 0;
    const SlangResult result = composedProgram->getEntryPointCode(entryPointIndex, 0, spirvCode.writeRef(), diagnosticBlob.writeRef());
    if (diagnosticBlob) {
      LLOGW("%s\n", (const char*)diagnosticBlob->getBufferPointer());
    }
    if (SLANG_FAILED(result)) {
      LVK_ASSERT_MSG(false, "slang::getEntryPointCode() failed");
      return Result(Result::Code::RuntimeError, "slang::getEntryPointCode() failed");
    }
  }

  const uint8_t* ptr = reinterpret_cast<const uint8_t*>(spirvCode->getBufferPointer());

  *outSPIRV = std::vector<uint8_t>(ptr, ptr + spirvCode->getBufferSize());

  return Result();
#else
  LVK_ASSERT_MSG(false, "No Slang support available");
  return Result(Result::Code::RuntimeError, "No Slang support available");
#endif // defined(LVK_WITH_SLANG) && LVK_WITH_SLANG
}

VkResult lvk::setDebugObjectName(VkDevice device, VkObjectType type, uint64_t handle, const char* name) {
  if (!name || !*name || !vkSetDebugUtilsObjectNameEXT) {
    return VK_SUCCESS;
  }
  const VkDebugUtilsObjectNameInfoEXT ni = {
      .sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT,
      .objectType = type,
      .objectHandle = handle,
      .pObjectName = name,
  };
  return vkSetDebugUtilsObjectNameEXT(device, &ni);
}

VkSpecializationInfo lvk::getPipelineShaderStageSpecializationInfo(lvk::SpecializationConstantDesc desc,
                                                                   VkSpecializationMapEntry* outEntries) {
  const uint32_t numEntries = desc.getNumSpecializationConstants();
  if (outEntries) {
    for (uint32_t i = 0; i != numEntries; i++) {
      outEntries[i] = VkSpecializationMapEntry{
          .constantID = desc.entries[i].constantId,
          .offset = desc.entries[i].offset,
          .size = desc.entries[i].size,
      };
    }
  }
  return VkSpecializationInfo{
      .mapEntryCount = numEntries,
      .pMapEntries = outEntries,
      .dataSize = desc.dataSize,
      .pData = desc.data,
  };
}

VkBindImageMemoryInfo lvk::getBindImageMemoryInfo(const VkBindImagePlaneMemoryInfo* next, VkImage image, VkDeviceMemory memory) {
  return VkBindImageMemoryInfo{
      .sType = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO,
      .pNext = next,
      .image = image,
      .memory = memory,
      .memoryOffset = 0,
  };
}

VkPipelineShaderStageCreateInfo lvk::getPipelineShaderStageCreateInfo(VkShaderStageFlagBits stage,
                                                                      const VkShaderModuleCreateInfo& ci,
                                                                      const char* entryPoint,
                                                                      const VkSpecializationInfo* specializationInfo) {
  return VkPipelineShaderStageCreateInfo{
      .sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
      .pNext = &ci,
      .flags = 0,
      .stage = stage,
      .module = VK_NULL_HANDLE,
      .pName = entryPoint ? entryPoint : "main",
      .pSpecializationInfo = specializationInfo,
  };
}

static uint32_t findMemoryType(VkPhysicalDevice physDev, uint32_t memoryTypeBits, VkMemoryPropertyFlags flags) {
  VkPhysicalDeviceMemoryProperties2 props = {
      .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2,
  };
  vkGetPhysicalDeviceMemoryProperties2(physDev, &props);

  for (uint32_t i = 0; i < props.memoryProperties.memoryTypeCount; i++) {
    const bool hasProperties = (props.memoryProperties.memoryTypes[i].propertyFlags & flags) == flags;
    if ((memoryTypeBits & (1 << i)) && hasProperties) {
      return i;
    }
  }

  assert(false);

  return 0;
}

VkResult lvk::allocateMemory2(VkPhysicalDevice physDev,
                              VkDevice device,
                              const VkMemoryRequirements2* memRequirements,
                              VkMemoryPropertyFlags props,
                              VkDeviceMemory* outMemory) {
  assert(memRequirements);

  const VkMemoryAllocateFlagsInfo memoryAllocateFlagsInfo = {
      .sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO,
      .flags = VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR,
  };
  const VkMemoryAllocateInfo ai = {
      .sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
      .pNext = &memoryAllocateFlagsInfo,
      .allocationSize = memRequirements->memoryRequirements.size,
      .memoryTypeIndex = findMemoryType(physDev, memRequirements->memoryRequirements.memoryTypeBits, props),
  };

  return vkAllocateMemory(device, &ai, NULL, outMemory);
}

VkDescriptorSetLayoutBinding lvk::getDSLBinding(uint32_t binding,
                                                VkDescriptorType descriptorType,
                                                uint32_t descriptorCount,
                                                VkShaderStageFlags stageFlags,
                                                const VkSampler* immutableSamplers) {
  return VkDescriptorSetLayoutBinding{
      .binding = binding,
      .descriptorType = descriptorType,
      .descriptorCount = descriptorCount,
      .stageFlags = stageFlags,
      .pImmutableSamplers = immutableSamplers,
  };
}

void lvk::imageMemoryBarrier2(VkCommandBuffer buffer,
                              VkImage image,
                              StageAccess src,
                              StageAccess dst,
                              VkImageLayout oldImageLayout,
                              VkImageLayout newImageLayout,
                              VkImageSubresourceRange subresourceRange) {
  const VkImageMemoryBarrier2 barrier = {
      .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2,
      .srcStageMask = src.stage,
      .srcAccessMask = src.access,
      .dstStageMask = dst.stage,
      .dstAccessMask = dst.access,
      .oldLayout = oldImageLayout,
      .newLayout = newImageLayout,
      .srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
      .dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
      .image = image,
      .subresourceRange = subresourceRange,
  };

  const VkDependencyInfo depInfo = {
      .sType = VK_STRUCTURE_TYPE_DEPENDENCY_INFO,
      .imageMemoryBarrierCount = 1,
      .pImageMemoryBarriers = &barrier,
  };

  vkCmdPipelineBarrier2(buffer, &depInfo);
}

VkSampleCountFlagBits lvk::getVulkanSampleCountFlags(uint32_t numSamples, VkSampleCountFlags maxSamplesMask) {
  if (numSamples <= 1 || VK_SAMPLE_COUNT_2_BIT > maxSamplesMask) {
    return VK_SAMPLE_COUNT_1_BIT;
  }
  if (numSamples <= 2 || VK_SAMPLE_COUNT_4_BIT > maxSamplesMask) {
    return VK_SAMPLE_COUNT_2_BIT;
  }
  if (numSamples <= 4 || VK_SAMPLE_COUNT_8_BIT > maxSamplesMask) {
    return VK_SAMPLE_COUNT_4_BIT;
  }
  if (numSamples <= 8 || VK_SAMPLE_COUNT_16_BIT > maxSamplesMask) {
    return VK_SAMPLE_COUNT_8_BIT;
  }
  if (numSamples <= 16 || VK_SAMPLE_COUNT_32_BIT > maxSamplesMask) {
    return VK_SAMPLE_COUNT_16_BIT;
  }
  if (numSamples <= 32 || VK_SAMPLE_COUNT_64_BIT > maxSamplesMask) {
    return VK_SAMPLE_COUNT_32_BIT;
  }
  return VK_SAMPLE_COUNT_64_BIT;
}

uint32_t lvk::getBytesPerPixel(VkFormat format) {
  switch (format) {
  case VK_FORMAT_R8_UNORM:
    return 1;
  case VK_FORMAT_R16_SFLOAT:
    return 2;
  case VK_FORMAT_R8G8B8_UNORM:
  case VK_FORMAT_B8G8R8_UNORM:
    return 3;
  case VK_FORMAT_R8G8B8A8_UNORM:
  case VK_FORMAT_B8G8R8A8_UNORM:
  case VK_FORMAT_R8G8B8A8_SRGB:
  case VK_FORMAT_R16G16_SFLOAT:
  case VK_FORMAT_R32_SFLOAT:
  case VK_FORMAT_R32_UINT:
    return 4;
  case VK_FORMAT_R16G16B16_SFLOAT:
    return 6;
  case VK_FORMAT_R16G16B16A16_SFLOAT:
  case VK_FORMAT_R32G32_SFLOAT:
  case VK_FORMAT_R32G32_UINT:
    return 8;
  case VK_FORMAT_R32G32B32_SFLOAT:
    return 12;
  case VK_FORMAT_R32G32B32A32_SFLOAT:
    return 16;
  default:;
  }
  LVK_ASSERT_MSG(false, "VkFormat value not handled: %d", (int)format);
  return 1;
}

uint32_t lvk::getNumImagePlanes(VkFormat format) {
  switch (format) {
  case VK_FORMAT_UNDEFINED:
    return 0;
  case VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM:
  case VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM:
  case VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM:
  case VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16:
  case VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16:
  case VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16:
  case VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM:
  case VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM:
  case VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM:
    return 3;
  case VK_FORMAT_G8_B8R8_2PLANE_420_UNORM:
  case VK_FORMAT_G8_B8R8_2PLANE_422_UNORM:
  case VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16:
  case VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16:
  case VK_FORMAT_G16_B16R16_2PLANE_420_UNORM:
  case VK_FORMAT_G16_B16R16_2PLANE_422_UNORM:
  case VK_FORMAT_G8_B8R8_2PLANE_444_UNORM:
  case VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16:
  case VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16:
  case VK_FORMAT_G16_B16R16_2PLANE_444_UNORM:
    return 2;
  default:
    return 1;
  }
}

VkCompareOp lvk::compareOpToVkCompareOp(lvk::CompareOp func) {
  switch (func) {
  case lvk::CompareOp_Never:
    return VK_COMPARE_OP_NEVER;
  case lvk::CompareOp_Less:
    return VK_COMPARE_OP_LESS;
  case lvk::CompareOp_Equal:
    return VK_COMPARE_OP_EQUAL;
  case lvk::CompareOp_LessEqual:
    return VK_COMPARE_OP_LESS_OR_EQUAL;
  case lvk::CompareOp_Greater:
    return VK_COMPARE_OP_GREATER;
  case lvk::CompareOp_NotEqual:
    return VK_COMPARE_OP_NOT_EQUAL;
  case lvk::CompareOp_GreaterEqual:
    return VK_COMPARE_OP_GREATER_OR_EQUAL;
  case lvk::CompareOp_AlwaysPass:
    return VK_COMPARE_OP_ALWAYS;
  }
  LVK_ASSERT_MSG(false, "CompareFunction value not handled: %d", (int)func);
  return VK_COMPARE_OP_ALWAYS;
}

VkExtent2D lvk::getImagePlaneExtent(VkExtent2D plane0, lvk::Format format, uint32_t plane) {
  switch (format) {
  case Format_YUV_NV12:
    return VkExtent2D{
        .width = plane0.width >> plane,
        .height = plane0.height >> plane,
    };
  case Format_YUV_420p:
    return VkExtent2D{
        .width = plane0.width >> (plane ? 1 : 0),
        .height = plane0.height >> (plane ? 1 : 0),
    };
  default:;
  }
  return plane0;
}

StageAccess lvk::getPipelineStageAccess(VkImageLayout layout) {
  switch (layout) {
  case VK_IMAGE_LAYOUT_UNDEFINED:
    return {
        .stage = VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT,
        .access = VK_ACCESS_2_NONE,
    };
  case VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL:
    return {
        .stage = VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT,
        .access = VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT,
    };
  case VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL:
    return {
        .stage = VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT | VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT,
        .access = VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT | VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT,
    };
  case VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL:
    return {
        .stage = VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT | VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT |
                 VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT,
        .access = VK_ACCESS_2_SHADER_READ_BIT,
    };
  case VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL:
    return {
        .stage = VK_PIPELINE_STAGE_2_TRANSFER_BIT,
        .access = VK_ACCESS_2_TRANSFER_READ_BIT,
    };
  case VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL:
    return {
        .stage = VK_PIPELINE_STAGE_2_TRANSFER_BIT,
        .access = VK_ACCESS_2_TRANSFER_WRITE_BIT,
    };
  case VK_IMAGE_LAYOUT_GENERAL:
    return {
        .stage = VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT | VK_PIPELINE_STAGE_2_TRANSFER_BIT,
        .access = VK_ACCESS_2_MEMORY_READ_BIT | VK_ACCESS_2_MEMORY_WRITE_BIT | VK_ACCESS_2_TRANSFER_WRITE_BIT,
    };
  case VK_IMAGE_LAYOUT_PRESENT_SRC_KHR:
    return {
        .stage = VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT,
        .access = VK_ACCESS_2_NONE | VK_ACCESS_2_SHADER_WRITE_BIT,
    };
  case VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ_KHR:
    return {
        .stage = VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT,
        .access = VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT | VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT,
    };
  default:
    LVK_ASSERT_MSG(false, "Unsupported image layout transition!");
    return {
        .stage = VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT,
        .access = VK_ACCESS_2_MEMORY_READ_BIT | VK_ACCESS_2_MEMORY_WRITE_BIT,
    };
  }
};

VkDevice lvk::getVkDevice(const IContext* ctx) {
  if (!ctx)
    return VK_NULL_HANDLE;

  return static_cast<const VulkanContext*>(ctx)->getVkDevice();
}

VkPhysicalDevice lvk::getVkPhysicalDevice(const IContext* ctx) {
  if (!ctx)
    return VK_NULL_HANDLE;

  return static_cast<const VulkanContext*>(ctx)->getVkPhysicalDevice();
}

VkCommandBuffer lvk::getVkCommandBuffer(const ICommandBuffer& buffer) {
  return static_cast<const lvk::CommandBuffer&>(buffer).getVkCommandBuffer();
}

VkBuffer lvk::getVkBuffer(const IContext* ctx, BufferHandle buffer) {
  if (!ctx || buffer.empty())
    return VK_NULL_HANDLE;

  return static_cast<const VulkanContext*>(ctx)->buffersPool_.get(buffer)->vkBuffer_;
}

VkImage lvk::getVkImage(const IContext* ctx, TextureHandle texture) {
  if (!ctx || texture.empty())
    return VK_NULL_HANDLE;

  return static_cast<const VulkanContext*>(ctx)->texturesPool_.get(texture)->vkImage_;
}

VkImageView lvk::getVkImageView(const IContext* ctx, TextureHandle texture) {
  if (!ctx || texture.empty())
    return VK_NULL_HANDLE;

  return static_cast<const VulkanContext*>(ctx)->texturesPool_.get(texture)->imageView_;
}

VkDeviceAddress lvk::getVkAccelerationStructureDeviceAddress(const IContext* ctx, AccelStructHandle accelStruct) {
  if (!ctx || accelStruct.empty())
    return 0;

  return static_cast<const VulkanContext*>(ctx)->accelStructuresPool_.get(accelStruct)->deviceAddress;
}

VkAccelerationStructureKHR lvk::getVkAccelerationStructure(const IContext* ctx, AccelStructHandle accelStruct) {
  if (!ctx || accelStruct.empty())
    return 0;

  return static_cast<const VulkanContext*>(ctx)->accelStructuresPool_.get(accelStruct)->vkHandle;
}

VkBuffer lvk::getVkBuffer(const IContext* ctx, AccelStructHandle accelStruct) {
  if (!ctx || accelStruct.empty())
    return 0;

  return getVkBuffer(ctx, static_cast<const VulkanContext*>(ctx)->accelStructuresPool_.get(accelStruct)->buffer);
}

VkPipeline lvk::getVkPipeline(const IContext* ctx, RayTracingPipelineHandle pipeline) {
  if (!ctx || pipeline.empty())
    return 0;

  return static_cast<const VulkanContext*>(ctx)->rayTracingPipelinesPool_.get(pipeline)->pipeline_;
}

VkPipelineLayout lvk::getVkPipelineLayout(const IContext* ctx, RayTracingPipelineHandle pipeline) {
  if (!ctx || pipeline.empty())
    return 0;

  return static_cast<const VulkanContext*>(ctx)->rayTracingPipelinesPool_.get(pipeline)->pipelineLayout_;
}

VkDeviceSize lvk::getBufferSize(const IContext* ctx, lvk::BufferHandle handle) {
  const lvk::VulkanBuffer* buffer = static_cast<const VulkanContext*>(ctx)->buffersPool_.get(handle);
  return buffer ? buffer->bufferSize_ : 0;
}

const VkPhysicalDeviceProperties2& lvk::getVkPhysicalDeviceProperties2(const IContext* ctx) {
  return static_cast<const VulkanContext*>(ctx)->vkPhysicalDeviceProperties2_;
}

const VkPhysicalDeviceVulkan11Properties& lvk::getVkPhysicalDeviceVulkan11Properties(const IContext* ctx) {
  return static_cast<const VulkanContext*>(ctx)->vkPhysicalDeviceVulkan11Properties_;
}

const VkPhysicalDeviceVulkan12Properties& lvk::getVkPhysicalDeviceVulkan12Properties(const IContext* ctx) {
  return static_cast<const VulkanContext*>(ctx)->vkPhysicalDeviceVulkan12Properties_;
}

const VkPhysicalDeviceVulkan13Properties& lvk::getVkPhysicalDeviceVulkan13Properties(const IContext* ctx) {
  return static_cast<const VulkanContext*>(ctx)->vkPhysicalDeviceVulkan13Properties_;
}

```

`lvk/vulkan/VulkanUtils.h`:

```h
/*
 * LightweightVK
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#pragma once

#define VMA_VULKAN_VERSION 1003000
#define VMA_STATIC_VULKAN_FUNCTIONS 0
#define VMA_DYNAMIC_VULKAN_FUNCTIONS 1

// set to 1 to see very verbose debug console logs with Vulkan commands
#define LVK_VULKAN_PRINT_COMMANDS 0

#if !defined(VK_NO_PROTOTYPES)
#define VK_NO_PROTOTYPES 1
#endif // !defined(VK_NO_PROTOTYPES)

// enable to use VulkanMemoryAllocator (VMA)
#define LVK_VULKAN_USE_VMA 1

#include <cassert>
#include <cstdio>
#include <vector>

#include <volk.h>
#include <vk_mem_alloc.h>
#include <lvk/LVK.h>

#define VK_ASSERT(func)                                            \
  {                                                                \
    const VkResult vk_assert_result = func;                        \
    if (vk_assert_result != VK_SUCCESS) {                          \
      LLOGW("Vulkan API call failed: %s:%i\n  %s\n  %s\n", \
                    __FILE__,                                      \
                    __LINE__,                                      \
                    #func,                                         \
                    lvk::getVulkanResultString(vk_assert_result)); \
      assert(false);                                               \
    }                                                              \
  }

#define VK_ASSERT_RETURN(func)                                     \
  {                                                                \
    const VkResult vk_assert_result = func;                        \
    if (vk_assert_result != VK_SUCCESS) {                          \
      LLOGW("Vulkan API call failed: %s:%i\n  %s\n  %s\n", \
                    __FILE__,                                      \
                    __LINE__,                                      \
                    #func,                                         \
                    lvk::getVulkanResultString(vk_assert_result)); \
      assert(false);                                               \
      return getResultFromVkResult(vk_assert_result);              \
    }                                                              \
  }

typedef struct glslang_resource_s glslang_resource_t;

struct StageAccess {
  VkPipelineStageFlags2 stage;
  VkAccessFlags2 access;
};

namespace lvk {

VkSemaphore createSemaphore(VkDevice device, const char* debugName);
VkSemaphore createSemaphoreTimeline(VkDevice device, uint64_t initialValue, const char* debugName);
VkFence createFence(VkDevice device, const char* debugName, bool isSignaled = false);
VmaAllocator createVmaAllocator(VkPhysicalDevice physDev, VkDevice device, VkInstance instance, uint32_t apiVersion);
uint32_t findQueueFamilyIndex(VkPhysicalDevice physDev, VkQueueFlags flags);
VkResult setDebugObjectName(VkDevice device, VkObjectType type, uint64_t handle, const char* name);
VkResult allocateMemory2(VkPhysicalDevice physDev,
                         VkDevice device,
                         const VkMemoryRequirements2* memRequirements,
                         VkMemoryPropertyFlags props,
                         VkDeviceMemory* outMemory);

glslang_resource_t getGlslangResource(const VkPhysicalDeviceLimits& limits);
Result compileShaderGlslang(lvk::ShaderStage stage,
                            const char* code,
                            std::vector<uint8_t>* outSPIRV,
                            const glslang_resource_t* glslLangResource = nullptr);
Result compileShaderSlang(lvk::ShaderStage stage, const char* code, const char* entryPointName, std::vector<uint8_t>* outSPIRV);

VkSamplerCreateInfo samplerStateDescToVkSamplerCreateInfo(const lvk::SamplerStateDesc& desc, const VkPhysicalDeviceLimits& limits);
VkDescriptorSetLayoutBinding getDSLBinding(uint32_t binding,
                                           VkDescriptorType descriptorType,
                                           uint32_t descriptorCount,
                                           VkShaderStageFlags stageFlags,
                                           const VkSampler* immutableSamplers = nullptr);
VkSpecializationInfo getPipelineShaderStageSpecializationInfo(lvk::SpecializationConstantDesc desc, VkSpecializationMapEntry* outEntries);
VkPipelineShaderStageCreateInfo getPipelineShaderStageCreateInfo(VkShaderStageFlagBits stage,
                                                                 const VkShaderModuleCreateInfo& ci,
                                                                 const char* entryPoint,
                                                                 const VkSpecializationInfo* specializationInfo);
VkBindImageMemoryInfo getBindImageMemoryInfo(const VkBindImagePlaneMemoryInfo* next, VkImage image, VkDeviceMemory memory);

StageAccess getPipelineStageAccess(VkImageLayout state);

void imageMemoryBarrier2(VkCommandBuffer buffer,
                         VkImage image,
                         StageAccess src,
                         StageAccess dst,
                         VkImageLayout oldImageLayout,
                         VkImageLayout newImageLayout,
                         VkImageSubresourceRange subresourceRange);

VkSampleCountFlagBits getVulkanSampleCountFlags(uint32_t numSamples, VkSampleCountFlags maxSamplesMask);

void setResultFrom(Result* outResult, VkResult result);
Result getResultFromVkResult(VkResult result);
const char* getVulkanResultString(VkResult result);
const char* getVkDeviceFaultAddressTypeString(VkDeviceFaultAddressTypeEXT type);
uint32_t getBytesPerPixel(VkFormat format);
uint32_t getNumImagePlanes(VkFormat format);
lvk::Format vkFormatToFormat(VkFormat format);
lvk::ColorSpace vkColorSpaceToColorSpace(VkColorSpaceKHR colorSpace);
lvk::PresentMode vkPresentModeToPresentMode(VkPresentModeKHR mode);
VkPresentModeKHR presentModeToVkPresentMode(lvk::PresentMode mode);
VkFormat formatToVkFormat(lvk::Format format);
VkCompareOp compareOpToVkCompareOp(lvk::CompareOp func);
VkExtent2D getImagePlaneExtent(VkExtent2D plane0, lvk::Format format, uint32_t plane);

// raw Vulkan helpers: use this if you want to interop LightweightVK API with your own raw Vulkan API calls
VkDevice getVkDevice(const IContext* ctx);
VkPhysicalDevice getVkPhysicalDevice(const IContext* ctx);
VkCommandBuffer getVkCommandBuffer(const ICommandBuffer& buffer);
VkBuffer getVkBuffer(const IContext* ctx, BufferHandle buffer);
VkImage getVkImage(const IContext* ctx, TextureHandle texture);
VkImageView getVkImageView(const IContext* ctx, TextureHandle texture);
VkDeviceAddress getVkAccelerationStructureDeviceAddress(const IContext* ctx, AccelStructHandle accelStruct);
VkAccelerationStructureKHR getVkAccelerationStructure(const IContext* ctx, AccelStructHandle accelStruct);
VkBuffer getVkBuffer(const IContext* ctx, AccelStructHandle accelStruct);
VkPipeline getVkPipeline(const IContext* ctx, RayTracingPipelineHandle pipeline);
VkPipelineLayout getVkPipelineLayout(const IContext* ctx, RayTracingPipelineHandle pipeline);

VkDeviceSize getBufferSize(const IContext* ctx, lvk::BufferHandle handle);

// properties/limits
const VkPhysicalDeviceProperties2& getVkPhysicalDeviceProperties2(const IContext* ctx);
const VkPhysicalDeviceVulkan11Properties& getVkPhysicalDeviceVulkan11Properties(const IContext* ctx);
const VkPhysicalDeviceVulkan12Properties& getVkPhysicalDeviceVulkan12Properties(const IContext* ctx);
const VkPhysicalDeviceVulkan13Properties& getVkPhysicalDeviceVulkan13Properties(const IContext* ctx);

} // namespace lvk

```

`samples/001_HelloTriangle.cpp`:

```cpp
/*
 * LightweightVK
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#include "VulkanApp.h"

// Bilingual: GLSL (default) and Slang. Define the macro LVK_DEMO_WITH_SLANG to switch to Slang.

// Slang
const char* codeSlang = R"(
static const float2 pos[3] = float2[3](
  float2(-0.6, -0.4),
  float2( 0.6, -0.4),
  float2( 0.0,  0.6)
);
static const float3 col[3] = float3[3](
  float3(1.0, 0.0, 0.0),
  float3(0.0, 1.0, 0.0),
  float3(0.0, 0.0, 1.0)
);

struct VertexStageOutput {
  float4 sv_Position  : SV_Position;
  float3 color        : COLOR0;
};

[shader("vertex")]
VertexStageOutput vertexMain(uint vertexID : SV_VertexID) {
  return {
    float4(pos[vertexID], 0.0, 1.0),
    col[vertexID],
  };
}

[shader("fragment")]
float4 fragmentMain(float3 color : COLOR0) : SV_Target {
  return float4(color, 1.0);
}
)";

// GLSL
const char* codeVS = R"(
#version 460
layout (location=0) out vec3 color;
const vec2 pos[3] = vec2[3](
  vec2(-0.6, -0.4),
  vec2( 0.6, -0.4),
  vec2( 0.0,  0.6)
);
const vec3 col[3] = vec3[3](
  vec3(1.0, 0.0, 0.0),
  vec3(0.0, 1.0, 0.0),
  vec3(0.0, 0.0, 1.0)
);
void main() {
  gl_Position = vec4(pos[gl_VertexIndex], 0.0, 1.0);
  color = col[gl_VertexIndex];
}
)";

const char* codeFS = R"(
#version 460
layout (location=0) in vec3 color;
layout (location=0) out vec4 out_FragColor;

void main() {
  out_FragColor = vec4(color, 1.0);
};
)";

VULKAN_APP_MAIN {
  const VulkanAppConfig cfg{
      .width = 800,
      .height = 600,
      .resizable = true,
  };
  VULKAN_APP_DECLARE(app, cfg);

  lvk::IContext* ctx = app.ctx_.get();

  {
#if defined(LVK_DEMO_WITH_SLANG)
    lvk::Holder<lvk::ShaderModuleHandle> vert_ = ctx->createShaderModule({codeSlang, lvk::Stage_Vert, "Shader Module: main (vert)"});
    lvk::Holder<lvk::ShaderModuleHandle> frag_ = ctx->createShaderModule({codeSlang, lvk::Stage_Frag, "Shader Module: main (frag)"});
#else
    lvk::Holder<lvk::ShaderModuleHandle> vert_ = ctx->createShaderModule({codeVS, lvk::Stage_Vert, "Shader Module: main (vert)"});
    lvk::Holder<lvk::ShaderModuleHandle> frag_ = ctx->createShaderModule({codeFS, lvk::Stage_Frag, "Shader Module: main (frag)"});
#endif // defined(LVK_DEMO_WITH_SLANG)

    lvk::Holder<lvk::RenderPipelineHandle> renderPipelineState_Triangle_ = ctx->createRenderPipeline(
        {
            .smVert = vert_,
            .smFrag = frag_,
            .color = {{.format = ctx->getSwapchainFormat()}},
        },
        nullptr);

    LVK_ASSERT(renderPipelineState_Triangle_.valid());

    app.run([&](uint32_t width, uint32_t height, float aspectRatio, float deltaSeconds) {
      lvk::ICommandBuffer& buffer = ctx->acquireCommandBuffer();

      // this will clear the framebuffer
      buffer.cmdBeginRendering({.color = {{.loadOp = lvk::LoadOp_Clear, .clearColor = {1.0f, 1.0f, 1.0f, 1.0f}}}},
                               {.color = {{.texture = ctx->getCurrentSwapchainTexture()}}});
      buffer.cmdBindRenderPipeline(renderPipelineState_Triangle_);
      buffer.cmdPushDebugGroupLabel("Render Triangle", 0xff0000ff);
      buffer.cmdDraw(3);
      buffer.cmdPopDebugGroupLabel();
      buffer.cmdEndRendering();
      ctx->submit(buffer, ctx->getCurrentSwapchainTexture());
    });
  }

  VULKAN_APP_EXIT();
}

```

`samples/002_RenderToCubeMap.cpp`:

```cpp
/*
 * LightweightVK
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#include "VulkanApp.h"

// Bilingual: GLSL (default) and Slang. Define the macro LVK_DEMO_WITH_SLANG to switch to Slang.

const char* codeTriangleSlang = R"(
struct PushConstants {
  uint face;
  float time;
};

[[vk::push_constant]] PushConstants pc;

static const float2 pos[3] = {
  float2(-0.6, -0.6),
  float2( 0.6, -0.6),
  float2( 0.0,  0.6)
};

static const float3 col[6] = {
  float3(1.0, 0.0, 0.0),
  float3(0.0, 1.0, 0.0),
  float3(0.0, 0.0, 1.0),
  float3(1.0, 0.0, 1.0),
  float3(1.0, 1.0, 0.0),
  float3(0.0, 1.0, 1.0)
};

struct VertexStageOutput {
  float4 sv_Position : SV_Position;
  float3 color       : COLOR0;
};

[shader("vertex")]
VertexStageOutput vertexMain(uint vertexID : SV_VertexID) {
  return {
    float4(pos[vertexID] * (1.5 + sin(pc.time)) * 0.5, 0.0, 1.0),
    col[pc.face],
  };
}

[shader("fragment")]
float4 fragmentMain(float3 color : COLOR0) {
  return float4(color, 1.0);
}
)";

const char* codeTriangleVS = R"(
#version 460
layout (location=0) out vec3 color;
const vec2 pos[3] = vec2[3](
  vec2(-0.6, -0.6),
  vec2( 0.6, -0.6),
  vec2( 0.0,  0.6)
);
const vec3 col[6] = vec3[6](
  vec3(1.0, 0.0, 0.0),
  vec3(0.0, 1.0, 0.0),
  vec3(0.0, 0.0, 1.0),
  vec3(1.0, 0.0, 1.0),
  vec3(1.0, 1.0, 0.0),
  vec3(0.0, 1.0, 1.0)
);
layout(push_constant) uniform constants {
  uint face;
  float time;
} pc;

void main() {
  gl_Position = vec4(pos[gl_VertexIndex] * (1.5 + sin(pc.time)) * 0.5, 0.0, 1.0);
  color = col[pc.face];
}
)";

const char* codeTriangleFS = R"(
#version 460
layout (location=0) in vec3 color;
layout (location=0) out vec4 out_FragColor;

void main() {
  out_FragColor = vec4(color, 1.0);
}
)";

const char* codeSlang = R"(
struct VertexStageOutput {
  float4 sv_Position             : SV_Position;
  float3 dir                     : COLOR0;
  nointerpolation uint textureId : TEXTUREID;
};

struct PushConstants {
  float4x4 mvp;
  uint texture0;
};

[[vk::push_constant]] PushConstants pc;

static const float3 vertices[8] = {
  float3(-1.0, -1.0,  1.0), float3( 1.0, -1.0,  1.0),
  float3( 1.0,  1.0,  1.0), float3(-1.0,  1.0,  1.0),
  float3(-1.0, -1.0, -1.0), float3( 1.0, -1.0, -1.0),
  float3( 1.0,  1.0, -1.0), float3(-1.0,  1.0, -1.0)
};

[shader("vertex")]
VertexStageOutput vertexMain(uint vertexID : SV_VertexID) {
  VertexStageOutput out;
  float3 v = vertices[vertexID];
  out.sv_Position = pc.mvp * float4(v, 1.0);
  out.dir = v;
  out.textureId = pc.texture0;
  return out;
}

struct PSInput {
  float3 dir                     : COLOR0;
  nointerpolation uint textureId : TEXTUREID;
};

[shader("fragment")]
float4 fragmentMain(PSInput input) {
  return textureBindlessCube(input.textureId, 0, normalize(input.dir));
}
)";

const char* codeVS = R"(
layout (location=0) out vec3 dir;
layout (location=1) out flat uint textureId;

const vec3 vertices[8] = vec3[8](
  vec3(-1.0,-1.0, 1.0), vec3( 1.0,-1.0, 1.0), vec3( 1.0, 1.0, 1.0), vec3(-1.0, 1.0, 1.0),
  vec3(-1.0,-1.0,-1.0), vec3( 1.0,-1.0,-1.0), vec3( 1.0, 1.0,-1.0), vec3(-1.0, 1.0,-1.0)
);

layout(push_constant) uniform constants {
  mat4 mvp;
  uint texture0;
} pc;

void main() {
  vec3 v = vertices[gl_VertexIndex];
  gl_Position = pc.mvp * vec4(v, 1.0);
  dir = v;
  textureId = pc.texture0;
}
)";

const char* codeFS = R"(
layout (location=0) in vec3 dir;
layout (location=1) in flat uint textureId;
layout (location=0) out vec4 out_FragColor;

void main() {
  out_FragColor = textureBindlessCube(textureId, 0, normalize(dir));
};
)";

VULKAN_APP_MAIN {
  const VulkanAppConfig cfg{
      .width = 0,
      .height = 0,
  };
  VULKAN_APP_DECLARE(app, cfg);

  lvk::IContext* ctx = app.ctx_.get();

  {
    const uint16_t indexData[36] = {0, 1, 2, 2, 3, 0, 1, 5, 6, 6, 2, 1, 7, 6, 5, 5, 4, 7,
                                    4, 0, 3, 3, 7, 4, 4, 5, 1, 1, 0, 4, 3, 2, 6, 6, 7, 3};

    lvk::Holder<lvk::BufferHandle> ib0_ = ctx->createBuffer({
        .usage = lvk::BufferUsageBits_Index,
        .storage = lvk::StorageType_Device,
        .size = sizeof(indexData),
        .data = indexData,
        .debugName = "Buffer: index",
    });

    lvk::Holder<lvk::TextureHandle> texture_ = ctx->createTexture({
        .type = lvk::TextureType_Cube,
        .format = lvk::Format_BGRA_UN8,
        .dimensions = {512, 512},
        .usage = lvk::TextureUsageBits_Sampled | lvk::TextureUsageBits_Attachment,
        .debugName = "CubeMap",
    });

#if defined(LVK_DEMO_WITH_SLANG)
    lvk::Holder<lvk::ShaderModuleHandle> vert_ = ctx->createShaderModule({codeSlang, lvk::Stage_Vert, "Shader Module: main (vert)"});
    lvk::Holder<lvk::ShaderModuleHandle> frag_ = ctx->createShaderModule({codeSlang, lvk::Stage_Frag, "Shader Module: main (frag)"});
    lvk::Holder<lvk::ShaderModuleHandle> vertTriangle_ =
        ctx->createShaderModule({codeTriangleSlang, lvk::Stage_Vert, "Shader Module: triangle (vert)"});
    lvk::Holder<lvk::ShaderModuleHandle> fragTriangle_ =
        ctx->createShaderModule({codeTriangleSlang, lvk::Stage_Frag, "Shader Module: triangle (frag)"});
#else
    lvk::Holder<lvk::ShaderModuleHandle> vert_ = ctx->createShaderModule({codeVS, lvk::Stage_Vert, "Shader Module: main (vert)"});
    lvk::Holder<lvk::ShaderModuleHandle> frag_ = ctx->createShaderModule({codeFS, lvk::Stage_Frag, "Shader Module: main (frag)"});
    lvk::Holder<lvk::ShaderModuleHandle> vertTriangle_ =
        ctx->createShaderModule({codeTriangleVS, lvk::Stage_Vert, "Shader Module: triangle (vert)"});
    lvk::Holder<lvk::ShaderModuleHandle> fragTriangle_ =
        ctx->createShaderModule({codeTriangleFS, lvk::Stage_Frag, "Shader Module: triangle (frag)"});
#endif // defined(LVK_DEMO_WITH_SLANG)

    lvk::Holder<lvk::RenderPipelineHandle> renderPipelineState_Mesh_ = ctx->createRenderPipeline({
        .smVert = vert_,
        .smFrag = frag_,
        .color = {{.format = ctx->getSwapchainFormat()}},
        .cullMode = lvk::CullMode_Back,
        .frontFace = lvk::WindingMode_CW,
        .debugName = "Pipeline: mesh",
    });
    lvk::Holder<lvk::RenderPipelineHandle> renderPipelineState_Triangle_ = ctx->createRenderPipeline({
        .smVert = vertTriangle_,
        .smFrag = fragTriangle_,
        .color = {{.format = ctx->getFormat(texture_)}},
        .debugName = "Pipeline: triangle",
    });

    app.run([&](uint32_t width, uint32_t height, float aspectRatio, float deltaSeconds) {
      LVK_PROFILER_FUNCTION();

      const float fov = float(45.0f * (M_PI / 180.0f));
      const mat4 proj = glm::perspectiveLH(fov, aspectRatio, 0.1f, 500.0f);
      const mat4 view = glm::translate(mat4(1.0f), vec3(0.0f, 0.0f, 5.0f));
      const mat4 model = glm::rotate(mat4(1.0f), (float)glfwGetTime(), glm::normalize(vec3(1.0f, 1.0f, 1.0f)));

      lvk::ICommandBuffer& buffer = ctx->acquireCommandBuffer();

      buffer.cmdPushDebugGroupLabel("Render to Cube Map", 0xff0000ff);
      for (uint8_t face = 0; face != 6; face++) {
        const lvk::ClearColorValue colors[] = {{0.3f, 0.1f, 0.1f, 1.0f},
                                               {0.1f, 0.3f, 0.1f, 1.0f},
                                               {0.1f, 0.1f, 0.3f, 1.0f},
                                               {0.3f, 0.1f, 0.3f, 1.0f},
                                               {0.3f, 0.3f, 0.1f, 1.0f},
                                               {0.1f, 0.3f, 0.3f, 1.0f}};
        buffer.cmdBeginRendering({.color = {{
                                      .loadOp = lvk::LoadOp_Clear,
                                      .storeOp = lvk::StoreOp_Store,
                                      .layer = face,
                                      .clearColor = colors[face],
                                  }}},
                                 {.color = {{.texture = texture_}}});
        buffer.cmdBindRenderPipeline(renderPipelineState_Triangle_);
        const struct {
          uint32_t face;
          float time;
        } pc = {
            .face = face,
            .time = 10.0f * (float)glfwGetTime(),
        };
        buffer.cmdPushConstants(pc);
        buffer.cmdDraw(3);
        buffer.cmdEndRendering();
      }
      buffer.cmdPopDebugGroupLabel();

      buffer.cmdBeginRendering({.color = {{
                                    .loadOp = lvk::LoadOp_Clear,
                                    .storeOp = lvk::StoreOp_Store,
                                    .clearColor = {1.0f, 1.0f, 1.0f, 1.0f},
                                }}},
                               {.color = {{.texture = ctx->getCurrentSwapchainTexture()}}},
                               {.textures = {lvk::TextureHandle(texture_)}});
      {
        buffer.cmdBindRenderPipeline(renderPipelineState_Mesh_);
        buffer.cmdBindViewport({0.0f, 0.0f, (float)width, (float)height, 0.0f, +1.0f});
        buffer.cmdBindScissorRect({0, 0, (uint32_t)width, (uint32_t)height});
        buffer.cmdPushDebugGroupLabel("Render Mesh", 0xff0000ff);
        buffer.cmdBindDepthState({});
        buffer.cmdBindIndexBuffer(ib0_, lvk::IndexFormat_UI16);
        struct {
          mat4 mvp;
          uint32_t texture;
        } bindings = {
            .mvp = proj * view * model,
            .texture = texture_.index(),
        };
        buffer.cmdPushConstants(bindings);
        buffer.cmdDrawIndexed(3 * 6 * 2);
        buffer.cmdPopDebugGroupLabel();
      }
      buffer.cmdEndRendering();

      ctx->submit(buffer, ctx->getCurrentSwapchainTexture());
    });
  }

  VULKAN_APP_EXIT();
}

```

`samples/003_RenderToCubeMapSinglePass.cpp`:

```cpp
/*
 * LightweightVK
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#include "VulkanApp.h"

#include <lvk/vulkan/VulkanClasses.h>

// Bilingual: GLSL (default) and Slang. Define the macro LVK_DEMO_WITH_SLANG to switch to Slang.

const char* codeTriangleSlang = R"(
struct PushConstants {
  float time;
};

[[vk::push_constant]] PushConstants pc;

static const float2 pos[3] = {
  float2(-0.6, -0.6),
  float2( 0.6, -0.6),
  float2( 0.0,  0.6)
};

struct FragmentOutput {
  float4 color0 : SV_Target0;
  float4 color1 : SV_Target1;
  float4 color2 : SV_Target2;
  float4 color3 : SV_Target3;
  float4 color4 : SV_Target4;
  float4 color5 : SV_Target5;
};

[shader("vertex")]
float4 vertexMain(uint vertexID : SV_VertexID) : SV_Position {
  return float4(pos[vertexID] * (1.5 + sin(pc.time)) * 0.5, 0.0, 1.0);
}

[shader("fragment")]
FragmentOutput fragmentMain() {
  return {
    float4(1.0, 0.0, 0.0, 1.0),
    float4(0.0, 1.0, 0.0, 1.0),
    float4(0.0, 0.0, 1.0, 1.0),
    float4(1.0, 0.0, 1.0, 1.0),
    float4(1.0, 1.0, 0.0, 1.0),
    float4(0.0, 1.0, 1.0, 1.0),
  };
}
)";

const char* codeTriangleVS = R"(
#version 460
const vec2 pos[3] = vec2[3](
  vec2(-0.6, -0.6),
  vec2( 0.6, -0.6),
  vec2( 0.0,  0.6)
);
layout(push_constant) uniform constants {
  float time;
} pc;

void main() {
  gl_Position = vec4(pos[gl_VertexIndex] * (1.5 + sin(pc.time)) * 0.5, 0.0, 1.0);
}
)";

const char* codeTriangleFS = R"(
#version 460
layout (location=0) out vec4 out_FragColor0;
layout (location=1) out vec4 out_FragColor1;
layout (location=2) out vec4 out_FragColor2;
layout (location=3) out vec4 out_FragColor3;
layout (location=4) out vec4 out_FragColor4;
layout (location=5) out vec4 out_FragColor5;

void main() {
  out_FragColor0 = vec4(1.0, 0.0, 0.0, 1.0);
  out_FragColor1 = vec4(0.0, 1.0, 0.0, 1.0);
  out_FragColor2 = vec4(0.0, 0.0, 1.0, 1.0);
  out_FragColor3 = vec4(1.0, 0.0, 1.0, 1.0);
  out_FragColor4 = vec4(1.0, 1.0, 0.0, 1.0);
  out_FragColor5 = vec4(0.0, 1.0, 1.0, 1.0);
};
)";

const char* codeSlang = R"(
struct VertexStageOutput {
  float4 sv_Position             : SV_Position;
  float3 dir                     : COLOR0;
  nointerpolation uint textureId : TEXTUREID;
};

struct PushConstants {
  float4x4 mvp;
  uint texture0;
};

[[vk::push_constant]] PushConstants pc;

static const float3 vertices[8] = {
  float3(-1.0, -1.0,  1.0), float3( 1.0, -1.0,  1.0),
  float3( 1.0,  1.0,  1.0), float3(-1.0,  1.0,  1.0),
  float3(-1.0, -1.0, -1.0), float3( 1.0, -1.0, -1.0),
  float3( 1.0,  1.0, -1.0), float3(-1.0,  1.0, -1.0)
};

[shader("vertex")]
VertexStageOutput vertexMain(uint vertexID : SV_VertexID) {
  VertexStageOutput out;
  float3 v = vertices[vertexID];
  out.sv_Position = pc.mvp * float4(v, 1.0);
  out.dir = v;
  out.textureId = pc.texture0;
  return out;
}

struct PSInput {
  float3 dir                     : COLOR0;
  nointerpolation uint textureId : TEXTUREID;
};

[shader("fragment")]
float4 fragmentMain(PSInput input) {
  return textureBindlessCube(input.textureId, 0, normalize(input.dir));
}
)";

const char* codeVS = R"(
layout (location=0) out vec3 dir;
layout (location=1) out flat uint textureId;

const vec3 vertices[8] = vec3[8](
  vec3(-1.0,-1.0, 1.0), vec3( 1.0,-1.0, 1.0), vec3( 1.0, 1.0, 1.0), vec3(-1.0, 1.0, 1.0),
  vec3(-1.0,-1.0,-1.0), vec3( 1.0,-1.0,-1.0), vec3( 1.0, 1.0,-1.0), vec3(-1.0, 1.0,-1.0)
);

layout(push_constant) uniform constants {
  mat4 mvp;
  uint texture0;
} pc;

void main() {
  vec3 v = vertices[gl_VertexIndex];
  gl_Position = pc.mvp * vec4(v, 1.0);
  dir = v;
  textureId = pc.texture0;
}
)";

const char* codeFS = R"(
layout (location=0) in vec3 dir;
layout (location=1) in flat uint textureId;
layout (location=0) out vec4 out_FragColor;

void main() {
  out_FragColor = textureBindlessCube(textureId, 0, normalize(dir));
};
)";

VULKAN_APP_MAIN {
  const VulkanAppConfig cfg{
      .width = 0,
      .height = 0,
  };
  VULKAN_APP_DECLARE(app, cfg);

  lvk::IContext* ctx = app.ctx_.get();

  {
    const VkPhysicalDeviceProperties& props = static_cast<lvk::VulkanContext*>(ctx)->getVkPhysicalDeviceProperties();

    if (props.limits.maxColorAttachments < 6) {
      LVK_ASSERT_MSG(false, "This demo needs at least 6 color attachments to be supported");
      std::terminate();
    }

    const uint16_t indexData[36] = {0, 1, 2, 2, 3, 0, 1, 5, 6, 6, 2, 1, 7, 6, 5, 5, 4, 7,
                                    4, 0, 3, 3, 7, 4, 4, 5, 1, 1, 0, 4, 3, 2, 6, 6, 7, 3};

    lvk::Holder<lvk::BufferHandle> ib0_ = ctx->createBuffer({
        .usage = lvk::BufferUsageBits_Index,
        .storage = lvk::StorageType_Device,
        .size = sizeof(indexData),
        .data = indexData,
        .debugName = "Buffer: index",
    });

    lvk::Holder<lvk::TextureHandle> texture_ = ctx->createTexture({
        .type = lvk::TextureType_Cube,
        .format = lvk::Format_BGRA_UN8,
        .dimensions = {512, 512},
        .usage = lvk::TextureUsageBits_Sampled | lvk::TextureUsageBits_Attachment,
        .debugName = "CubeMap",
    });

#if defined(LVK_DEMO_WITH_SLANG)
    lvk::Holder<lvk::ShaderModuleHandle> vert_ = ctx->createShaderModule({codeSlang, lvk::Stage_Vert, "Shader Module: main (vert)"});
    lvk::Holder<lvk::ShaderModuleHandle> frag_ = ctx->createShaderModule({codeSlang, lvk::Stage_Frag, "Shader Module: main (frag)"});
    lvk::Holder<lvk::ShaderModuleHandle> vertTriangle_ =
        ctx->createShaderModule({codeTriangleSlang, lvk::Stage_Vert, "Shader Module: triangle (vert)"});
    lvk::Holder<lvk::ShaderModuleHandle> fragTriangle_ =
        ctx->createShaderModule({codeTriangleSlang, lvk::Stage_Frag, "Shader Module: triangle (frag)"});
#else
    lvk::Holder<lvk::ShaderModuleHandle> vert_ = ctx->createShaderModule({codeVS, lvk::Stage_Vert, "Shader Module: main (vert)"});
    lvk::Holder<lvk::ShaderModuleHandle> frag_ = ctx->createShaderModule({codeFS, lvk::Stage_Frag, "Shader Module: main (frag)"});
    lvk::Holder<lvk::ShaderModuleHandle> vertTriangle_ =
        ctx->createShaderModule({codeTriangleVS, lvk::Stage_Vert, "Shader Module: triangle (vert)"});
    lvk::Holder<lvk::ShaderModuleHandle> fragTriangle_ =
        ctx->createShaderModule({codeTriangleFS, lvk::Stage_Frag, "Shader Module: triangle (frag)"});
#endif // defined(LVK_DEMO_WITH_SLANG)

    lvk::Holder<lvk::RenderPipelineHandle> renderPipelineState_Mesh_ = ctx->createRenderPipeline({
        .smVert = vert_,
        .smFrag = frag_,
        .color = {{.format = ctx->getSwapchainFormat()}},
        .cullMode = lvk::CullMode_Back,
        .frontFace = lvk::WindingMode_CW,
        .debugName = "Pipeline: mesh",
    });
    lvk::Holder<lvk::RenderPipelineHandle> renderPipelineState_Triangle_ = ctx->createRenderPipeline({
        .smVert = vertTriangle_,
        .smFrag = fragTriangle_,
        .color = {{.format = ctx->getFormat(texture_)},
                  {.format = ctx->getFormat(texture_)},
                  {.format = ctx->getFormat(texture_)},
                  {.format = ctx->getFormat(texture_)},
                  {.format = ctx->getFormat(texture_)},
                  {.format = ctx->getFormat(texture_)}},
        .debugName = "Pipeline: triangle",
    });

    // Main loop
    app.run([&](uint32_t width, uint32_t height, float aspectRatio, float deltaSeconds) {
      LVK_PROFILER_FUNCTION();

      const float fov = float(45.0f * (M_PI / 180.0f));
      const mat4 proj = glm::perspectiveLH(fov, aspectRatio, 0.1f, 500.0f);
      const mat4 view = glm::translate(mat4(1.0f), vec3(0.0f, 0.0f, 5.0f));
      const mat4 model = glm::rotate(mat4(1.0f), (float)glfwGetTime(), glm::normalize(vec3(1.0f, 1.0f, 1.0f)));

      // Command buffers (1-N per thread): create, submit and forget
      lvk::ICommandBuffer& buffer = ctx->acquireCommandBuffer();

      buffer.cmdPushDebugGroupLabel("Render to Cube Map", 0xff0000ff);
      buffer.cmdBeginRendering(
          {.color =
               {
                   {.loadOp = lvk::LoadOp_Clear, .storeOp = lvk::StoreOp_Store, .layer = 0, .clearColor = {0.3f, 0.1f, 0.1f, 1.0f}},
                   {.loadOp = lvk::LoadOp_Clear, .storeOp = lvk::StoreOp_Store, .layer = 1, .clearColor = {0.1f, 0.3f, 0.1f, 1.0f}},
                   {.loadOp = lvk::LoadOp_Clear, .storeOp = lvk::StoreOp_Store, .layer = 2, .clearColor = {0.1f, 0.1f, 0.3f, 1.0f}},
                   {.loadOp = lvk::LoadOp_Clear, .storeOp = lvk::StoreOp_Store, .layer = 3, .clearColor = {0.3f, 0.1f, 0.3f, 1.0f}},
                   {.loadOp = lvk::LoadOp_Clear, .storeOp = lvk::StoreOp_Store, .layer = 4, .clearColor = {0.3f, 0.3f, 0.1f, 1.0f}},
                   {.loadOp = lvk::LoadOp_Clear, .storeOp = lvk::StoreOp_Store, .layer = 5, .clearColor = {0.1f, 0.3f, 0.3f, 1.0f}},
               }},
          {.color = {
               {.texture = texture_},
               {.texture = texture_},
               {.texture = texture_},
               {.texture = texture_},
               {.texture = texture_},
               {.texture = texture_},
           }});
      buffer.cmdBindRenderPipeline(renderPipelineState_Triangle_);
      buffer.cmdPushConstants(float(10.0 * glfwGetTime()));
      buffer.cmdDraw(3);
      buffer.cmdEndRendering();
      buffer.cmdPopDebugGroupLabel();

      buffer.cmdBeginRendering({.color = {{
                                    .loadOp = lvk::LoadOp_Clear,
                                    .storeOp = lvk::StoreOp_Store,
                                    .clearColor = {1.0f, 1.0f, 1.0f, 1.0f},
                                }}},
                               {.color = {{.texture = ctx->getCurrentSwapchainTexture()}}},
                               {.textures = {lvk::TextureHandle(texture_)}});
      {
        buffer.cmdBindRenderPipeline(renderPipelineState_Mesh_);
        buffer.cmdBindViewport({0.0f, 0.0f, (float)width, (float)height, 0.0f, +1.0f});
        buffer.cmdBindScissorRect({0, 0, (uint32_t)width, (uint32_t)height});
        buffer.cmdPushDebugGroupLabel("Render Mesh", 0xff0000ff);
        buffer.cmdBindDepthState({});
        buffer.cmdBindIndexBuffer(ib0_, lvk::IndexFormat_UI16);
        struct {
          mat4 mvp;
          uint32_t texture;
        } bindings = {
            .mvp = proj * view * model,
            .texture = texture_.index(),
        };
        buffer.cmdPushConstants(bindings);
        buffer.cmdDrawIndexed(3 * 6 * 2);
        buffer.cmdPopDebugGroupLabel();
      }
      buffer.cmdEndRendering();

      ctx->submit(buffer, ctx->getCurrentSwapchainTexture());
    });
  }

  VULKAN_APP_EXIT();
}

```

`samples/004_YUV.cpp`:

```cpp
/*
 * LightweightVK
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#include "VulkanApp.h"
#include <ldrutils/lutils/ScopeExit.h>

#include <filesystem>

const char* codeSlang = R"(
struct VertexOutput {
  float4 sv_Position : SV_Position;
  float2 uv          : TEXCOORD0;
};

static const float2 pos[4] = {
  float2(-1.0, -1.0),
  float2(-1.0, +1.0),
  float2(+1.0, -1.0),
  float2(+1.0, +1.0)
};

[[vk::constant_id(0)]] const uint textureId = 0;

[shader("vertex")]
VertexOutput vertexMain(uint vertexID : SV_VertexID) {
  VertexOutput out;
  out.sv_Position = float4(pos[vertexID], 0.0, 1.0);
  out.uv = pos[vertexID] * 0.5 + 0.5;
  out.uv.y = 1.0 - out.uv.y;
  return out;
}

[shader("fragment")]
float4 fragmentMain(VertexOutput input) : SV_Target0 {
  return kSamplersYUV[textureId].Sample(input.uv);
}
)";

const char* codeVS = R"(
#version 460
layout (location=0) out vec2 uv;
const vec2 pos[4] = vec2[4](
  vec2(-1.0, -1.0),
  vec2(-1.0, +1.0),
  vec2(+1.0, -1.0),
  vec2(+1.0, +1.0)
);
void main() {
  gl_Position = vec4(pos[gl_VertexIndex], 0.0, 1.0);
  uv = pos[gl_VertexIndex] * 0.5 + 0.5;
    uv.y = 1.0-uv.y;
}
)";

const char* codeFS = R"(
layout (location=0) in vec2 uv;
layout (location=0) out vec4 out_FragColor;

layout (constant_id = 0) const uint textureId = 0;

void main() {
  out_FragColor = texture(kSamplersYUV[textureId], uv);
}
)";

size_t currentDemo_ = 0;

// demonstrate different YUV formats
struct YUVFormatDemo {
  const char* name;
  lvk::Format format;
  lvk::Holder<lvk::TextureHandle> texture;
  lvk::Holder<lvk::RenderPipelineHandle> renderPipelineState;
};

struct Resources {
  lvk::Holder<lvk::ShaderModuleHandle> vert;
  lvk::Holder<lvk::ShaderModuleHandle> frag;
  std::vector<YUVFormatDemo> demos;
};

Resources res_;

void createDemo(lvk::IContext* ctx, const char* contentFolder, const char* name, lvk::Format format, const char* fileName) {
  using namespace std::filesystem;
  path dir(contentFolder);
  int32_t texWidth = 1920;
  int32_t texHeight = 1080;
  FILE* file = fopen((dir / "src" / path(fileName)).string().c_str(), "rb");
  SCOPE_EXIT {
    if (file) {
      fclose(file);
    }
  };
  fseek(file, 0, SEEK_END);
  const uint32_t length = ftell(file);
  fseek(file, 0, SEEK_SET);

  LVK_ASSERT_MSG(file && length, "Cannot load textures. Run `deploy_content.py`/`deploy_content_android.py` before running this app.");
  if (!file || !length) {
    printf("Cannot load textures. Run `deploy_content.py`/`deploy_content_android.py` before running this app.");
    std::terminate();
  }

  LVK_ASSERT(length == texWidth * texHeight * 3 / 2);

  std::vector<uint8_t> pixels(length);
  fread(pixels.data(), 1, length, file);

  lvk::Holder<lvk::TextureHandle> texture = ctx->createTexture({
      .type = lvk::TextureType_2D,
      .format = format,
      .dimensions = {(uint32_t)texWidth, (uint32_t)texHeight},
      .usage = lvk::TextureUsageBits_Sampled,
      .data = pixels.data(),
      .debugName = name,
  });

  const uint32_t textureId = texture.index();

  res_.demos.push_back({
      .name = name,
      .format = format,
      .texture = std::move(texture),
      .renderPipelineState = ctx->createRenderPipeline({
          .topology = lvk::Topology_TriangleStrip,
          .smVert = res_.vert,
          .smFrag = res_.frag,
          .specInfo = {.entries = {{.constantId = 0, .size = sizeof(uint32_t)}}, .data = &textureId, .dataSize = sizeof(textureId)},
          .color = {{.format = ctx->getSwapchainFormat()}},
          .debugName = name,
      }),
  });
}

VULKAN_APP_MAIN {
  const VulkanAppConfig cfg{
      .width = 0,
      .height = 0,
  };
  VULKAN_APP_DECLARE(app, cfg);

  lvk::IContext* ctx = app.ctx_.get();

#if defined(LVK_DEMO_WITH_SLANG)
  res_.vert = ctx->createShaderModule({codeSlang, lvk::Stage_Vert, "Shader Module: main (vert)"});
  res_.frag = ctx->createShaderModule({codeSlang, lvk::Stage_Frag, "Shader Module: main (frag)"});
#else
  res_.vert = ctx->createShaderModule({codeVS, lvk::Stage_Vert, "Shader Module: main (vert)"});
  res_.frag = ctx->createShaderModule({codeFS, lvk::Stage_Frag, "Shader Module: main (frag)"});
#endif // defined(LVK_DEMO_WITH_SLANG)

  createDemo(ctx, app.folderContentRoot_.c_str(), "YUV NV12", lvk::Format_YUV_NV12, "igl-samples/output_frame_900.nv12.yuv");
  createDemo(ctx, app.folderContentRoot_.c_str(), "YUV 420p", lvk::Format_YUV_420p, "igl-samples/output_frame_900.420p.yuv");

#if !defined(ANDROID)
  app.addMouseButtonCallback([](auto* window, int button, int action, int mods) {
    if (action == GLFW_PRESS && !res_.demos.empty()) {
      currentDemo_ = (currentDemo_ + 1) % res_.demos.size();
    }
  });
  app.addKeyCallback([](GLFWwindow* window, int key, int, int action, int) {
    if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS) {
      glfwSetWindowShouldClose(window, GLFW_TRUE);
    } else if (key == GLFW_KEY_T && action == GLFW_PRESS) {
      currentDemo_ = 0;
      if (!res_.demos.empty())
        res_.demos.pop_back();
    } else if (action == GLFW_PRESS && !res_.demos.empty()) {
      currentDemo_ = (currentDemo_ + 1) % res_.demos.size();
    }
  });
#endif // !ANDROID

  app.run([&](uint32_t width, uint32_t height, float aspectRatio, float deltaSeconds) {
    const lvk::Framebuffer framebuffer = {
        .color = {{.texture = ctx->getCurrentSwapchainTexture()}},
    };

    lvk::ICommandBuffer& buffer = ctx->acquireCommandBuffer();

    buffer.cmdBeginRendering({.color = {{.loadOp = lvk::LoadOp_DontCare}}}, framebuffer);

    if (!res_.demos.empty()) {
      const YUVFormatDemo& demo = res_.demos[currentDemo_];
      buffer.cmdBindRenderPipeline(demo.renderPipelineState);
      buffer.cmdDraw(4);
      {
        app.imgui_->beginFrame(framebuffer);
        const ImGuiWindowFlags flags = ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_AlwaysAutoResize |
                                       ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoNav |
                                       ImGuiWindowFlags_NoMove;
        ImGui::SetNextWindowPos({15.0f, 15.0f});
        ImGui::SetNextWindowBgAlpha(0.30f);
        ImGui::Begin("##FormatYUV", nullptr, flags);
        ImGui::Text("%s", demo.name);
        ImGui::Text("Press any key to change");
        ImGui::End();
        app.drawFPS();
        app.imgui_->endFrame(buffer);
      }
    }

    buffer.cmdEndRendering();

    ctx->submit(buffer, ctx->getCurrentSwapchainTexture());
  });

  // destroy all the Vulkan stuff before closing the window
  res_ = {};

  VULKAN_APP_EXIT();
}

```

`samples/005_MeshShaders.cpp`:

```cpp
/*
 * LightweightVK
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#include "VulkanApp.h"

// we are going to use raw Vulkan here to initialize VK_EXT_mesh_shader
#include <lvk/vulkan/VulkanUtils.h>

const char* codeSlang = R"(
struct VertexOutput {
  float4 sv_Position : SV_Position;
  float3 color       : COLOR0;
};

struct PrimitiveOutput {
  bool sv_CullPrimitive : SV_CullPrimitive;
};

struct MeshPayload {
  uint unused;
};

[shader("amplification")]
[numthreads(1, 1, 1)]
void taskMain() {
  MeshPayload p;
  DispatchMesh(1, 1, 1, p); // Slang requires the payload arg
}

[shader("mesh")]
[numthreads(1, 1, 1)]
[outputtopology("triangle")]
void meshMain(
  in payload MeshPayload meshPayload,
  OutputVertices<VertexOutput, 3> verts,
  OutputIndices<uint3, 1> triangles,
  OutputPrimitives<PrimitiveOutput, 1> primitives)
{
  const float2 pos[3] = {
    float2(-0.6, -0.4),
    float2( 0.6, -0.4),
    float2( 0.0,  0.6)
  };

  const float3 col[3] = {
    float3(1.0, 0.0, 0.0),
    float3(0.0, 1.0, 0.0),
    float3(0.0, 0.0, 1.0)
  };

  SetMeshOutputCounts(3, 1);

  for (uint i = 0; i < 3; i++) {
    verts[i].sv_Position = float4(pos[i], 0.0, 1.0);
    verts[i].color = col[i];
  }

  primitives[0].sv_CullPrimitive = false;
  triangles[0] = uint3(0, 1, 2);
}

[shader("fragment")]
float4 fragmentMain(VertexOutput input) : SV_Target {
  return float4(input.color, 1.0);
}
)";

const char* codeTask = R"(
layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

void main() {
  EmitMeshTasksEXT(1, 1, 1);
}
)";

const char* codeMesh = R"(
layout(triangles, max_vertices = 3, max_primitives = 1) out;

layout (location=0) out vec3 color[3];

const vec2 pos[3] = vec2[3](
  vec2(-0.6, -0.4),
  vec2( 0.6, -0.4),
  vec2( 0.0,  0.6)
);
const vec3 col[3] = vec3[3](
  vec3(1.0, 0.0, 0.0),
  vec3(0.0, 1.0, 0.0),
  vec3(0.0, 0.0, 1.0)
);
void main() {
  SetMeshOutputsEXT(3, 1);

  for (uint i = 0; i != 3; i++) {
    gl_MeshVerticesEXT[i].gl_Position = vec4(pos[i], 0.0, 1.0);
    color[i] = col[i];
  }

  gl_MeshPrimitivesEXT[0].gl_CullPrimitiveEXT = false;
  gl_PrimitiveTriangleIndicesEXT[0] = uvec3(0, 1, 2);
}
)";

const char* codeFrag = R"(
#version 460
layout (location=0) in vec3 color;
layout (location=0) out vec4 out_FragColor;

void main() {
  out_FragColor = vec4(color, 1.0);
};
)";

struct {
  lvk::Holder<lvk::RenderPipelineHandle> renderPipelineState_Triangle_;
  lvk::Holder<lvk::ShaderModuleHandle> task_;
  lvk::Holder<lvk::ShaderModuleHandle> mesh_;
  lvk::Holder<lvk::ShaderModuleHandle> frag_;
} res;

VULKAN_APP_MAIN {
  const VulkanAppConfig cfg{
      .width = 800,
      .height = 600,
      .resizable = true,
  };
  VULKAN_APP_DECLARE(app, cfg);

  lvk::IContext* ctx = app.ctx_.get();

#if defined(LVK_DEMO_WITH_SLANG)
  res.task_ = ctx->createShaderModule({codeSlang, lvk::Stage_Task, "Shader Module: main (task)"});
  res.mesh_ = ctx->createShaderModule({codeSlang, lvk::Stage_Mesh, "Shader Module: main (mesh)"});
  res.frag_ = ctx->createShaderModule({codeSlang, lvk::Stage_Frag, "Shader Module: main (frag)"});
#else
  res.task_ = ctx->createShaderModule({codeTask, lvk::Stage_Task, "Shader Module: main (task)"});
  res.mesh_ = ctx->createShaderModule({codeMesh, lvk::Stage_Mesh, "Shader Module: main (mesh)"});
  res.frag_ = ctx->createShaderModule({codeFrag, lvk::Stage_Frag, "Shader Module: main (frag)"});
#endif // defined(LVK_DEMO_WITH_SLANG)

  res.renderPipelineState_Triangle_ = ctx->createRenderPipeline(
      {
          .smTask = res.task_,
          .smMesh = res.mesh_,
          .smFrag = res.frag_,
          .color = {{.format = ctx->getSwapchainFormat()}},
      },
      nullptr);

  LVK_ASSERT(res.renderPipelineState_Triangle_.valid());

  app.run([&](uint32_t width, uint32_t height, float aspectRatio, float deltaSeconds) {
    lvk::ICommandBuffer& buffer = ctx->acquireCommandBuffer();

    // This will clear the framebuffer
    buffer.cmdBeginRendering({.color = {{.loadOp = lvk::LoadOp_Clear, .clearColor = {1.0f, 1.0f, 1.0f, 1.0f}}}},
                             {.color = {{.texture = ctx->getCurrentSwapchainTexture()}}});
    buffer.cmdBindRenderPipeline(res.renderPipelineState_Triangle_);
    buffer.cmdPushDebugGroupLabel("Render Triangle", 0xff0000ff);
    buffer.cmdDrawMeshTasks({1, 1, 1});

    buffer.cmdPopDebugGroupLabel();
    buffer.cmdEndRendering();
    ctx->submit(buffer, ctx->getCurrentSwapchainTexture());
  });

  // destroy all the Vulkan stuff before closing the window
  res = {};

  VULKAN_APP_EXIT();
}

```

`samples/006_SwapchainHDR.cpp`:

```cpp
/*
 * LightweightVK
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#include "VulkanApp.h"

const char* codeSlang = R"(
struct PushConstants {
  float3 col[3];
};

[[vk::push_constant]] PushConstants pc;

struct VSOutput {
  float4 sv_Position : SV_Position;
  float3 color : COLOR0;
};

[shader("vertex")]
VSOutput vertexMain(uint vertexID : SV_VertexID) {
  const float2 pos[3] = {
    float2(-0.6, -0.4),
    float2( 0.6, -0.4),
    float2( 0.0,  0.6)
  };

  VSOutput out;
  out.sv_Position = float4(pos[vertexID], 0.0, 1.0);
  out.color = pc.col[vertexID];

  return out;
}

[shader("fragment")]
float4 fragmentMain(float3 color : COLOR0) : SV_Target0 {
  return float4(color, 1.0);
}
)";

const char* codeVS = R"(
#version 460
#extension GL_EXT_scalar_block_layout : require
layout (location=0) out vec3 color;
const vec2 pos[3] = vec2[3](
	vec2(-0.6, -0.4),
	vec2( 0.6, -0.4),
	vec2( 0.0,  0.6)
);
layout(scalar, push_constant) uniform constants {
   vec3 col[3];
};

void main() {
	gl_Position = vec4(pos[gl_VertexIndex], 0.0, 1.0);
	color = col[gl_VertexIndex];
}
)";

const char* codeFS = R"(
#version 460
layout (location=0) in vec3 color;
layout (location=0) out vec4 out_FragColor;

void main() {
	out_FragColor = vec4(color, 1.0);
};
)";

VULKAN_APP_MAIN {
  const VulkanAppConfig cfg{
      .width = -80,
      .height = -80,
      .contextConfig =
          {
              .swapchainRequestedColorSpace = lvk::ColorSpace_HDR10,
              //.swapchainRequestedColorSpace = lvk::ColorSpace_SRGB_EXTENDED_LINEAR,
          },
  };
  VULKAN_APP_DECLARE(app, cfg);

  lvk::IContext* ctx = app.ctx_.get();

  LLOGL("Swapchain format     : %u\n", ctx->getSwapchainFormat());
  LLOGL("Swapchain color space: %u\n", ctx->getSwapchainColorSpace());

  {
#if defined(LVK_DEMO_WITH_SLANG)
    lvk::Holder<lvk::ShaderModuleHandle> vert_ = ctx->createShaderModule({codeSlang, lvk::Stage_Vert, "Shader Module: main (vert)"});
    lvk::Holder<lvk::ShaderModuleHandle> frag_ = ctx->createShaderModule({codeSlang, lvk::Stage_Frag, "Shader Module: main (frag)"});
#else
    lvk::Holder<lvk::ShaderModuleHandle> vert_ = ctx->createShaderModule({codeVS, lvk::Stage_Vert, "Shader Module: main (vert)"});
    lvk::Holder<lvk::ShaderModuleHandle> frag_ = ctx->createShaderModule({codeFS, lvk::Stage_Frag, "Shader Module: main (frag)"});
#endif // defined(LVK_DEMO_WITH_SLANG)

    lvk::Holder<lvk::RenderPipelineHandle> renderPipelineState_Triangle_ = ctx->createRenderPipeline(
        {
            .smVert = vert_,
            .smFrag = frag_,
            .color = {{.format = ctx->getSwapchainFormat()}},
        },
        nullptr);

    LVK_ASSERT(renderPipelineState_Triangle_.valid());

    struct {
      vec3 rgb0;
      vec3 rgb1;
      vec3 rgb2;
    } pc = {
        .rgb0 = {1, 0, 0},
        .rgb1 = {0, 1, 0},
        .rgb2 = {0, 0, 1},
    };

    app.run([&](uint32_t width, uint32_t height, float aspectRatio, float deltaSeconds) {
      lvk::ICommandBuffer& buffer = ctx->acquireCommandBuffer();
      const lvk::Framebuffer fb = {
          .color = {{.texture = ctx->getCurrentSwapchainTexture()}},
      };
      buffer.cmdBeginRendering({.color = {{.loadOp = lvk::LoadOp_Clear, .clearColor = {1.0f, 1.0f, 1.0f, 1.0f}}}}, fb);
      buffer.cmdBindRenderPipeline(renderPipelineState_Triangle_);
      buffer.cmdPushConstants(pc);
      buffer.cmdDraw(3);
      app.imgui_->beginFrame(fb);
      ImGui::Begin("Colors", nullptr, ImGuiWindowFlags_AlwaysAutoResize);
      ImGui::SliderFloat3("Color #0", glm::value_ptr(pc.rgb0), 0.0f, 1.0f);
      ImGui::SliderFloat3("Color #1", glm::value_ptr(pc.rgb1), 0.0f, 1.0f);
      ImGui::SliderFloat3("Color #2", glm::value_ptr(pc.rgb2), 0.0f, 1.0f);
      ImGui::End();
      app.imgui_->endFrame(buffer);
      buffer.cmdEndRendering();
      ctx->submit(buffer, ctx->getCurrentSwapchainTexture());
    });
  }

  VULKAN_APP_EXIT();
}

```

`samples/007_DynamicRenderingLocalRead.cpp`:

```cpp
/*
 * LightweightVK
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#include "VulkanApp.h"

#include <filesystem>

#include <ldrutils/lutils/ScopeExit.h>
#include <stb/stb_image.h>

// disable for better perf & benchmarking (ImGui does not use input attachments)
#define ENABLE_IMGUI_DEBUG_OVERLAY 1

// Bilingual: GLSL (default) and Slang. Define the macro LVK_DEMO_WITH_SLANG to switch to Slang.

const char* codeSlangDeferred = R"(
struct PerFrame {
  float4x4 mvp;
  float4x4 model;
  uint texture0;
};

struct PushConstants {
  PerFrame* perFrame;
};

[[vk::push_constant]] PushConstants pc;

static const float3 positions[24] = {
  float3(-1.0, -1.0,  1.0), float3( 1.0, -1.0,  1.0), float3( 1.0,  1.0,  1.0), float3(-1.0,  1.0,  1.0), // +Z
  float3( 1.0, -1.0, -1.0), float3(-1.0, -1.0, -1.0), float3(-1.0,  1.0, -1.0), float3( 1.0,  1.0, -1.0), // -Z
  float3( 1.0, -1.0,  1.0), float3( 1.0, -1.0, -1.0), float3( 1.0,  1.0, -1.0), float3( 1.0,  1.0,  1.0), // +X
  float3(-1.0, -1.0, -1.0), float3(-1.0, -1.0,  1.0), float3(-1.0,  1.0,  1.0), float3(-1.0,  1.0, -1.0), // -X
  float3(-1.0,  1.0,  1.0), float3( 1.0,  1.0,  1.0), float3( 1.0,  1.0, -1.0), float3(-1.0,  1.0, -1.0), // +Y
  float3(-1.0, -1.0, -1.0), float3( 1.0, -1.0, -1.0), float3( 1.0, -1.0,  1.0), float3(-1.0, -1.0,  1.0)  // -Y
};

static const float3 normals[24] = {
  float3( 0.0,  0.0,  1.0), float3( 0.0,  0.0,  1.0), float3( 0.0,  0.0,  1.0), float3( 0.0,  0.0,  1.0), // +Z
  float3( 0.0,  0.0, -1.0), float3( 0.0,  0.0, -1.0), float3( 0.0,  0.0, -1.0), float3( 0.0,  0.0, -1.0), // -Z
  float3( 1.0,  0.0,  0.0), float3( 1.0,  0.0,  0.0), float3( 1.0,  0.0,  0.0), float3( 1.0,  0.0,  0.0), // +X
  float3(-1.0,  0.0,  0.0), float3(-1.0,  0.0,  0.0), float3(-1.0,  0.0,  0.0), float3(-1.0,  0.0,  0.0), // -X
  float3( 0.0,  1.0,  0.0), float3( 0.0,  1.0,  0.0), float3( 0.0,  1.0,  0.0), float3( 0.0,  1.0,  0.0), // +Y
  float3( 0.0, -1.0,  0.0), float3( 0.0, -1.0,  0.0), float3( 0.0, -1.0,  0.0), float3( 0.0, -1.0,  0.0)  // -Y
};

static const float2 uvs[24] = {
  float2(0.0, 1.0), float2(1.0, 1.0), float2(1.0, 0.0), float2(0.0, 0.0), // +Z
  float2(0.0, 1.0), float2(1.0, 1.0), float2(1.0, 0.0), float2(0.0, 0.0), // -Z
  float2(0.0, 1.0), float2(1.0, 1.0), float2(1.0, 0.0), float2(0.0, 0.0), // +X
  float2(0.0, 1.0), float2(1.0, 1.0), float2(1.0, 0.0), float2(0.0, 0.0), // -X
  float2(0.0, 1.0), float2(1.0, 1.0), float2(1.0, 0.0), float2(0.0, 0.0), // +Y
  float2(0.0, 1.0), float2(1.0, 1.0), float2(1.0, 0.0), float2(0.0, 0.0)  // -Y
};

float3x3 toFloat3x3(float4x4 m) {
  return float3x3(m[0].xyz, m[1].xyz, m[2].xyz);
}

struct DeferredVSOutput {
  float4 pos      : SV_Position;
  float2 uv       : TEXCOORD0;
  float3 normal   : NORMAL;
  float3 worldPos : TEXCOORD1;
  uint textureId  : TEXCOORD2;
};

[shader("vertex")]
DeferredVSOutput vertexMain(uint vertexId : SV_VertexID) {
  DeferredVSOutput out;
  
  float3 pos = positions[vertexId];
  
  out.pos = pc.perFrame->mvp * float4(pos, 1.0);
  out.uv  = uvs[vertexId];
  out.normal    = toFloat3x3(pc.perFrame->model) * normals[vertexId];
  out.worldPos  = (pc.perFrame->model * float4(pos, 1.0)).xyz;
  out.textureId = pc.perFrame->texture0;
  
  return out;
}

struct DeferredFSOutput {
  float4 fragColor : SV_Target0; // unused
  float4 albedo    : SV_Target1;
  float4 normal    : SV_Target2;
  float4 worldPos  : SV_Target3;
};

[shader("fragment")]
DeferredFSOutput fragmentMain(DeferredVSOutput input) {
  DeferredFSOutput out;
  
  out.fragColor = float4(0, 0, 0, 1);
  out.albedo   = 2.0 * textureBindless2D(input.textureId, 0, input.uv);
  out.normal   = float4(normalize(input.normal) * 0.5 + 0.5, 1.0);
  out.worldPos = float4(input.worldPos, 1.0);
  
  return out;
}
)";

const char* codeSlangCompose = R"(
struct ComposeVSOutput {
  float4 pos : SV_Position;
  float2 uv  : TEXCOORD0;
};

[shader("vertex")]
ComposeVSOutput vertexMain(uint vertexId : SV_VertexID) {
  ComposeVSOutput out;

  out.uv  = float2((vertexId << 1) & 2, vertexId & 2);
  out.pos = float4(out.uv * float2(2, -2) + float2(-1, 1), 0.0, 1.0);

  return out;
}

[[vk::input_attachment_index(0)]] [[vk::binding(0, 4)]] SubpassInput inputAlbedo;
[[vk::input_attachment_index(1)]] [[vk::binding(1, 4)]] SubpassInput inputNormal;
[[vk::input_attachment_index(2)]] [[vk::binding(2, 4)]] SubpassInput inputWorldPos;

[shader("fragment")]
float4 fragmentMain(ComposeVSOutput input) : SV_Target0 {
  // sample G-buffer via input attachments (reads at current fragment position)
  float4 albedo   = inputAlbedo.SubpassLoad();
  float3 normal   = inputNormal.SubpassLoad().xyz * 2.0 - 1.0;
  float3 worldPos = inputWorldPos.SubpassLoad().xyz;

  float3 lightDir = normalize(float3(1, 1, -1) - worldPos);

  float NdotL = clamp(dot(normal, lightDir), 0.3, 1.0);

  return float4(NdotL * albedo.rgb, 1.0);
}
)";

const char* codeDeferredVS = R"(
layout (location=0) out vec2 out_UV;
layout (location=1) out vec3 out_Normal;
layout (location=2) out vec3 out_WorldPos;
layout (location=3) out flat uint out_TextureId;

const vec3 positions[24] = vec3[24](
  vec3(-1.0, -1.0,  1.0), vec3( 1.0, -1.0,  1.0), vec3( 1.0,  1.0,  1.0), vec3(-1.0,  1.0,  1.0), // +Z
  vec3( 1.0, -1.0, -1.0), vec3(-1.0, -1.0, -1.0), vec3(-1.0,  1.0, -1.0), vec3( 1.0,  1.0, -1.0), // -Z
  vec3( 1.0, -1.0,  1.0), vec3( 1.0, -1.0, -1.0), vec3( 1.0,  1.0, -1.0), vec3( 1.0,  1.0,  1.0), // +X
  vec3(-1.0, -1.0, -1.0), vec3(-1.0, -1.0,  1.0), vec3(-1.0,  1.0,  1.0), vec3(-1.0,  1.0, -1.0), // -X
  vec3(-1.0,  1.0,  1.0), vec3( 1.0,  1.0,  1.0), vec3( 1.0,  1.0, -1.0), vec3(-1.0,  1.0, -1.0), // +Y
  vec3(-1.0, -1.0, -1.0), vec3( 1.0, -1.0, -1.0), vec3( 1.0, -1.0,  1.0), vec3(-1.0, -1.0,  1.0)  // -Y
);

const vec3 normals[24] = vec3[24](
  vec3( 0.0,  0.0,  1.0), vec3( 0.0,  0.0,  1.0), vec3( 0.0,  0.0,  1.0), vec3( 0.0,  0.0,  1.0), // +Z
  vec3( 0.0,  0.0, -1.0), vec3( 0.0,  0.0, -1.0), vec3( 0.0,  0.0, -1.0), vec3( 0.0,  0.0, -1.0), // -Z
  vec3( 1.0,  0.0,  0.0), vec3( 1.0,  0.0,  0.0), vec3( 1.0,  0.0,  0.0), vec3( 1.0,  0.0,  0.0), // +X
  vec3(-1.0,  0.0,  0.0), vec3(-1.0,  0.0,  0.0), vec3(-1.0,  0.0,  0.0), vec3(-1.0,  0.0,  0.0), // -X
  vec3( 0.0,  1.0,  0.0), vec3( 0.0,  1.0,  0.0), vec3( 0.0,  1.0,  0.0), vec3( 0.0,  1.0,  0.0), // +Y
  vec3( 0.0, -1.0,  0.0), vec3( 0.0, -1.0,  0.0), vec3( 0.0, -1.0,  0.0), vec3( 0.0, -1.0,  0.0)  // -Y
);

const vec2 uvs[24] = vec2[24](
  vec2(0.0, 1.0), vec2(1.0, 1.0), vec2(1.0, 0.0), vec2(0.0, 0.0), // +Z
  vec2(0.0, 1.0), vec2(1.0, 1.0), vec2(1.0, 0.0), vec2(0.0, 0.0), // -Z
  vec2(0.0, 1.0), vec2(1.0, 1.0), vec2(1.0, 0.0), vec2(0.0, 0.0), // +X
  vec2(0.0, 1.0), vec2(1.0, 1.0), vec2(1.0, 0.0), vec2(0.0, 0.0), // -X
  vec2(0.0, 1.0), vec2(1.0, 1.0), vec2(1.0, 0.0), vec2(0.0, 0.0), // +Y
  vec2(0.0, 1.0), vec2(1.0, 1.0), vec2(1.0, 0.0), vec2(0.0, 0.0)  // -Y
);

layout(std430, buffer_reference) readonly buffer PerFrame {
  mat4 mvp;
  mat4 model;
  uint texture0;
};

layout(push_constant) uniform constants {
  PerFrame pc;
};

void main() {
  vec3 pos = positions[gl_VertexIndex];
  
  gl_Position = pc.mvp * vec4(pos, 1.0);
  
  out_UV = uvs[gl_VertexIndex];
  out_Normal = mat3(pc.model) * normals[gl_VertexIndex];
  out_WorldPos = (pc.model * vec4(pos, 1.0)).xyz;
  out_TextureId = pc.texture0;
}
)";

const char* codeDeferredFS = R"(
layout (location=0) in vec2 in_UV;
layout (location=1) in vec3 in_Normal;
layout (location=2) in vec3 in_WorldPos;
layout (location=3) in flat uint in_TextureId;

layout (location=0) out vec4 out_FragColor; // unused
layout (location=1) out vec4 out_Albedo;
layout (location=2) out vec4 out_Normal;
layout (location=3) out vec4 out_WorldPos;

void main() {
  out_Albedo   = 2.0 * textureBindless2D(in_TextureId, 0, in_UV);
  out_Normal   = vec4(normalize(in_Normal) * 0.5 + 0.5, 1.0);
  out_WorldPos = vec4(in_WorldPos, 1.0);
}
)";

const char* codeComposeVS = R"(
layout (location=0) out vec2 uv;

void main() {
  uv = vec2((gl_VertexIndex << 1) & 2, gl_VertexIndex & 2);
  gl_Position = vec4(uv * vec2(2, -2) + vec2(-1, 1), 0.0, 1.0);
}
)";

const char* codeComposeFS = R"(
#if defined(has_EXT_shader_tile_image)
  #extension GL_EXT_shader_tile_image : require
  layout (location=1) tileImageEXT highp attachmentEXT inputAlbedo;
  layout (location=2) tileImageEXT highp attachmentEXT inputNormal;
  layout (location=3) tileImageEXT highp attachmentEXT inputWorldPos;
#else
  layout (input_attachment_index=0, set=4, binding=0) uniform subpassInput inputAlbedo;
  layout (input_attachment_index=1, set=4, binding=1) uniform subpassInput inputNormal;
  layout (input_attachment_index=2, set=4, binding=2) uniform subpassInput inputWorldPos;
#endif // defined(has_EXT_shader_tile_image)

layout (location=0) in vec2 in_UV;

layout (location=0) out vec4 out_FragColor;

void main() {
  // sample G-buffer via input attachments (reads at current fragment position)
#if defined(has_EXT_shader_tile_image)
  vec4 albedo   = colorAttachmentReadEXT(inputAlbedo);
  vec3 normal   = colorAttachmentReadEXT(inputNormal).xyz * 2.0 - 1.0;
  vec3 worldPos = colorAttachmentReadEXT(inputWorldPos).xyz;
#else
  vec4 albedo   = subpassLoad(inputAlbedo);
  vec3 normal   = subpassLoad(inputNormal).xyz * 2.0 - 1.0; // from [0,1] to [-1,1]
  vec3 worldPos = subpassLoad(inputWorldPos).xyz;
#endif // defined(has_EXT_shader_tile_image)

  vec3 lightDir = normalize(vec3(1, 1, -1) - worldPos);

  float NdotL = clamp(dot(normal, lightDir), 0.3, 1.0);

  out_FragColor = vec4(NdotL * albedo.rgb, 1.0);
}
)";

VULKAN_APP_MAIN {
  const VulkanAppConfig cfg{
      .width = 0,
      .height = 0,
  };
  VULKAN_APP_DECLARE(app, cfg);

  lvk::IContext* ctx = app.ctx_.get();

  {
    const uint16_t indexData[36] = {0,  1,  2,  2,  3,  0,  4,  5,  6,  6,  7,  4,  8,  9,  10, 10, 11, 8,
                                    12, 13, 14, 14, 15, 12, 16, 17, 18, 18, 19, 16, 20, 21, 22, 22, 23, 20};

    lvk::Holder<lvk::BufferHandle> ib0_ = ctx->createBuffer({
        .usage = lvk::BufferUsageBits_Index,
        .storage = lvk::StorageType_Device,
        .size = sizeof(indexData),
        .data = indexData,
        .debugName = "Buffer: index",
    });

    const lvk::Dimensions dim = ctx->getDimensions(ctx->getCurrentSwapchainTexture());

    lvk::Holder<lvk::TextureHandle> texAlbedo = ctx->createTexture({
        .type = lvk::TextureType_2D,
        .format = lvk::Format_BGRA_UN8,
        .dimensions = dim,
        .usage = lvk::TextureUsageBits_Sampled | lvk::TextureUsageBits_Attachment | lvk::TextureUsageBits_InputAttachment,
        .debugName = "Albedo",
    });

    lvk::Holder<lvk::TextureHandle> texNormal = ctx->createTexture({
        .type = lvk::TextureType_2D,
        .format = lvk::Format_A2B10G10R10_UN,
        .dimensions = dim,
        .usage = lvk::TextureUsageBits_Sampled | lvk::TextureUsageBits_Attachment | lvk::TextureUsageBits_InputAttachment,
        .debugName = "Normals",
    });

    lvk::Holder<lvk::TextureHandle> texWorldPos = ctx->createTexture({
        .type = lvk::TextureType_2D,
        .format = lvk::Format_BGRA_UN8,
        .dimensions = dim,
        .usage = lvk::TextureUsageBits_Sampled | lvk::TextureUsageBits_Attachment | lvk::TextureUsageBits_InputAttachment,
        .debugName = "WorldPositions",
    });

    lvk::Holder<lvk::TextureHandle> texture;

    {
      using namespace std::filesystem;
      path dir = app.folderContentRoot_;
      int32_t texWidth = 0;
      int32_t texHeight = 0;
      int32_t channels = 0;
      uint8_t* pixels = stbi_load(
          (dir / path("src/bistro/BuildingTextures/wood_polished_01_diff.png")).string().c_str(), &texWidth, &texHeight, &channels, 4);
      SCOPE_EXIT {
        stbi_image_free(pixels);
      };
      if (!pixels) {
        LVK_ASSERT_MSG(false, "Cannot load textures. Run `deploy_content.py`/`deploy_content_android.py` before running this app.");
        LLOGW("Cannot load textures. Run `deploy_content.py`/`deploy_content_android.py` before running this app.");
        std::terminate();
      }
      texture = ctx->createTexture({
          .type = lvk::TextureType_2D,
          .format = lvk::Format_RGBA_UN8,
          .dimensions = {(uint32_t)texWidth, (uint32_t)texHeight},
          .usage = lvk::TextureUsageBits_Sampled,
          .data = pixels,
          .debugName = "wood_polished_01_diff.png",
      });
    }

#if defined(LVK_DEMO_WITH_SLANG)
    const bool has_EXT_shader_tile_image = false; // not implemented in Slang
    lvk::Holder<lvk::ShaderModuleHandle> vertDeferred =
        ctx->createShaderModule({codeSlangDeferred, lvk::Stage_Vert, "Shader Module: deferred (vert)"});
    lvk::Holder<lvk::ShaderModuleHandle> fragDeferred =
        ctx->createShaderModule({codeSlangDeferred, lvk::Stage_Frag, "Shader Module: deferred (frag)"});
    lvk::Holder<lvk::ShaderModuleHandle> vertCompose =
        ctx->createShaderModule({codeSlangCompose, lvk::Stage_Vert, "Shader Module: compose (vert)"});
    lvk::Holder<lvk::ShaderModuleHandle> fragCompose =
        ctx->createShaderModule({codeSlangCompose, lvk::Stage_Frag, "Shader Module: compose (frag)"});
#else
    const bool has_EXT_shader_tile_image = ctx->isExtensionEnabled("VK_EXT_shader_tile_image");
    lvk::Holder<lvk::ShaderModuleHandle> vertDeferred =
        ctx->createShaderModule({codeDeferredVS, lvk::Stage_Vert, "Shader Module: deferred (vert)"});
    lvk::Holder<lvk::ShaderModuleHandle> fragDeferred =
        ctx->createShaderModule({codeDeferredFS, lvk::Stage_Frag, "Shader Module: deferred (frag)"});
    lvk::Holder<lvk::ShaderModuleHandle> vertCompose =
        ctx->createShaderModule({codeComposeVS, lvk::Stage_Vert, "Shader Module: compose (vert)"});
    lvk::Holder<lvk::ShaderModuleHandle> fragCompose = ctx->createShaderModule(
        {(has_EXT_shader_tile_image ? std::string("#define has_EXT_shader_tile_image 1\n") + codeComposeFS : codeComposeFS).c_str(),
         lvk::Stage_Frag,
         "Shader Module: compose (frag)"});
#endif // defined(LVK_DEMO_WITH_SLANG)

    lvk::Holder<lvk::RenderPipelineHandle> renderPipelineState_Deferred = ctx->createRenderPipeline({
        .smVert = vertDeferred,
        .smFrag = fragDeferred,
        .color =
            {
                {.format = ctx->getSwapchainFormat()},
                {.format = ctx->getFormat(texAlbedo)},
                {.format = ctx->getFormat(texNormal)},
                {.format = ctx->getFormat(texWorldPos)},
            },
        .cullMode = lvk::CullMode_Back,
        .frontFace = lvk::WindingMode_CW,
        .debugName = "Pipeline: deferred",
    });
    lvk::Holder<lvk::RenderPipelineHandle> renderPipelineState_Compose = ctx->createRenderPipeline({
        .smVert = vertCompose,
        .smFrag = fragCompose,
        .color =
            {
                {.format = ctx->getSwapchainFormat()},
                {.format = ctx->getFormat(texAlbedo)},
                {.format = ctx->getFormat(texNormal)},
                {.format = ctx->getFormat(texWorldPos)},
            },
        .debugName = "Pipeline: compose",
    });

    struct PerFrame {
      mat4 mvp;
      mat4 model;
      uint32_t texture;
    };

    lvk::Holder<lvk::BufferHandle> perFrameBuffer = ctx->createBuffer({
        .usage = lvk::BufferUsageBits_Uniform,
        .storage = lvk::StorageType_Device,
        .size = sizeof(PerFrame),
        .debugName = "Buffer: perFrame",
    });

    // main loop
    app.run([&](uint32_t width, uint32_t height, float aspectRatio, float deltaSeconds) {
      LVK_PROFILER_FUNCTION();

      const float fov = float(45.0f * (M_PI / 180.0f));
      const mat4 proj = glm::perspectiveLH(fov, aspectRatio, 0.1f, 500.0f);
      const mat4 view = glm::translate(mat4(1.0f), vec3(0.0f, 0.0f, 5.0f));
      const mat4 model = glm::rotate(mat4(1.0f), (float)glfwGetTime(), glm::normalize(vec3(1.0f, 1.0f, 1.0f)));
      const PerFrame bindingsDeferred = {
          .mvp = proj * view * model,
          .model = model,
          .texture = texture.index(),
      };
      const lvk::Framebuffer framebuffer = {
          .color = {{.texture = ctx->getCurrentSwapchainTexture()},
                    {.texture = texAlbedo},
                    {.texture = texNormal},
                    {.texture = texWorldPos}},
      };

      lvk::ICommandBuffer& buffer = ctx->acquireCommandBuffer();

      buffer.cmdUpdateBuffer(perFrameBuffer, 0, sizeof(bindingsDeferred), &bindingsDeferred);
      buffer.cmdBeginRendering(
          {.color =
               {
                   {.loadOp = lvk::LoadOp_DontCare, .storeOp = lvk::StoreOp_Store},
                   {.loadOp = lvk::LoadOp_Clear, .storeOp = lvk::StoreOp_Store, .clearColor = {0.0f, 0.0f, 0.0f, 1.0f}},
                   {.loadOp = lvk::LoadOp_Clear, .storeOp = lvk::StoreOp_Store, .clearColor = {0.0f, 0.0f, 0.0f, 1.0f}},
                   {.loadOp = lvk::LoadOp_Clear, .storeOp = lvk::StoreOp_Store, .clearColor = {0.0f, 0.0f, 0.0f, 1.0f}},
               }},
          framebuffer,
          {.inputAttachments = {lvk::TextureHandle(texAlbedo), lvk::TextureHandle(texNormal), lvk::TextureHandle(texWorldPos)}});
      buffer.cmdPushDebugGroupLabel("Render deferred", 0xff0000ff);
      buffer.cmdBindRenderPipeline(renderPipelineState_Deferred);
      buffer.cmdPushConstants(ctx->gpuAddress(perFrameBuffer));
      buffer.cmdBindIndexBuffer(ib0_, lvk::IndexFormat_UI16);
      buffer.cmdDrawIndexed(36);
      buffer.cmdPopDebugGroupLabel();

      if (!has_EXT_shader_tile_image) {
        buffer.cmdNextSubpass();
      }

      buffer.cmdPushDebugGroupLabel("Compose", 0xff0000ff);
      buffer.cmdBindRenderPipeline(renderPipelineState_Compose);
      buffer.cmdBindIndexBuffer(ib0_, lvk::IndexFormat_UI16);
      buffer.cmdDraw(3);
      buffer.cmdPopDebugGroupLabel();

#if ENABLE_IMGUI_DEBUG_OVERLAY
      // ImGui textures do not use input attachments
      buffer.cmdEndRendering();
      const lvk::Framebuffer framebufferGUI = {
          .color = {{.texture = ctx->getCurrentSwapchainTexture()}},
      };
      buffer.cmdBeginRendering(
          {.color = {{.loadOp = lvk::LoadOp_Load, .storeOp = lvk::StoreOp_Store}}},
          framebufferGUI,
          {.textures = {lvk::TextureHandle(texAlbedo), lvk::TextureHandle(texNormal), lvk::TextureHandle(texWorldPos)}});
      app.imgui_->beginFrame(framebufferGUI);
      const ImGuiViewport* v = ImGui::GetMainViewport();
      const float size = 0.175f * v->WorkSize.x;
      ImGui::SetNextWindowPos({0, 15}, ImGuiCond_Always);
      ImGui::Begin("Texture Viewer", nullptr, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoMove);
      ImGui::Text("Albedo:");
      ImGui::Image(texAlbedo.index(), ImVec2(size, size / aspectRatio));
      ImGui::Text("Normals:");
      ImGui::Image(texNormal.index(), ImVec2(size, size / aspectRatio));
      ImGui::Text("World positions:");
      ImGui::Image(texWorldPos.index(), ImVec2(size, size / aspectRatio));
      ImGui::End();
#else
      app.imgui_->beginFrame(framebuffer);
#endif // ENABLE_IMGUI_DEBUG_OVERLAY
      app.drawFPS();
      app.imgui_->endFrame(buffer);
      buffer.cmdEndRendering();
      ctx->submit(buffer, ctx->getCurrentSwapchainTexture());
    });
  }

  VULKAN_APP_EXIT();
}

```

`samples/008_MeshShaderFireworks.cpp`:

```cpp
/*
 * LightweightVK
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// Bilingual: GLSL (default) and Slang. Define the macro LVK_DEMO_WITH_SLANG to switch to Slang.

#include "VulkanApp.h"

// we are going to use raw Vulkan here to initialize VK_EXT_mesh_shader
#include <lvk/vulkan/VulkanUtils.h>

const char* codeSlang = R"(
struct Vertex {
  float3 position;
  float3 color;
  float flare;
};

struct PerFrame {
  float4x4 proj;
  float4x4 view;
  uint texture;
};

struct PushConstants {
  PerFrame* perFrame;
  Vertex* vb;
};

[[vk::push_constant]] PushConstants pc;

struct VertexOutput {
  float3 color : COLOR0;
  float2 uv    : TEXCOORD0;
};

static const float2 offs[4] = {
  float2(-1.0, -1.0),
  float2(+1.0, -1.0),
  float2(-1.0, +1.0),
  float2(+1.0, +1.0)
};

struct MeshOutput {
  float4 position : SV_Position;
  float3 color : COLOR0;
  float2 uv    : TEXCOORD0;
};

[shader("mesh")]
[numthreads(1, 1, 1)]
[outputtopology("triangle")]
void meshMain(
  uint3 groupID : SV_GroupID,
  out vertices MeshOutput verts[4],
  out indices uint3 triangles[2]
) {
  SetMeshOutputCounts(4, 2);
  
  float4x4 proj = pc.perFrame->proj;
  float4x4 view = pc.perFrame->view;
  Vertex v = pc.vb[groupID.x];
  float4 center = view * float4(v.position, 1.0);
  
  float2 size  = v.flare > 0.5 ? float2(0.08, 0.4) : float2(0.2, 0.2);
  float3 color = v.flare > 0.5 ? 0.5 * v.color : v.color;
  
  for (uint i = 0; i < 4; i++) {
    float4 offset = float4(size * offs[i], 0, 0);
    verts[i].position = proj * (center + offset);
    verts[i].color = color;
    verts[i].uv = (offs[i] + 1.0) * 0.5; // convert from [-1, 1] to [0, 1]
  }
  
  triangles[0] = uint3(0, 1, 2);
  triangles[1] = uint3(2, 1, 3);
}

[shader("fragment")]
float4 fragmentMain(VertexOutput input : VertexOutput) : SV_Target
{
  float alpha = textureBindless2D(pc.perFrame->texture, 0, input.uv).r;
  return float4(input.color, alpha);
}
)";

const char* codeMesh = R"(
layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout(triangles, max_vertices = 4, max_primitives = 2) out;

struct Vertex {
  float x, y, z;
  float r, g, b, flare;
};

layout(std430, buffer_reference) readonly buffer VertexBuffer {
  Vertex vertices[];
};

layout(std430, buffer_reference) readonly buffer PerFrame {
  mat4 proj;
  mat4 view;
  uint texture;
};

layout(push_constant) uniform constants {
  PerFrame perFrame;
  VertexBuffer vb;
} pc;

layout (location=0) out vec3 colors[4];
layout (location=1) out vec2 uvs[4];

const vec2 offs[4] = vec2[4](
  vec2(-1.0, -1.0),
  vec2(+1.0, -1.0),
  vec2(-1.0, +1.0),
  vec2(+1.0, +1.0)
);

void main() {
  SetMeshOutputsEXT(4, 2);

  mat4 proj = pc.perFrame.proj;
  mat4 view = pc.perFrame.view;
  Vertex v = pc.vb.vertices[gl_WorkGroupID.x];
  vec4 center = view * vec4(v.x, v.y, v.z, 1.0);

  vec2 size  = v.flare > 0.5 ? vec2(0.08, 0.4) : vec2(0.2, 0.2);
  vec3 color = v.flare > 0.5 ? 0.5 * vec3(v.r, v.g, v.b) : vec3(v.r, v.g, v.b);

  for (uint i = 0; i != 4; i++) {
    vec4 offset = vec4(size * offs[i], 0, 0);
    gl_MeshVerticesEXT[i].gl_Position = proj * (center + offset);
    colors[i] = color;    
    uvs[i] = (offs[i] + 1.0) * 0.5; // convert from [-1, 1] to [0, 1]
  }

  // two triangles forming a quad
  gl_MeshPrimitivesEXT[0].gl_CullPrimitiveEXT = false;
  gl_MeshPrimitivesEXT[1].gl_CullPrimitiveEXT = false;
  gl_PrimitiveTriangleIndicesEXT[0] = uvec3(0, 1, 2);
  gl_PrimitiveTriangleIndicesEXT[1] = uvec3(2, 1, 3);
}
)";

const char* codeFS = R"(
layout (location=0) in vec3 color;
layout (location=1) in vec2 uv;
layout (location=0) out vec4 out_FragColor;

layout(std430, buffer_reference) readonly buffer PerFrame {
  mat4 proj;
  mat4 view;
  uint texture;
};

layout(push_constant) uniform constants {
	PerFrame perFrame;
} pc;

void main() {
  float alpha = textureBindless2D(pc.perFrame.texture, 0, uv).r;
  out_FragColor = vec4(color, alpha);
};
)";

float random(float x) {
  return glm::linearRand(0.0f, x);
}

const int kMaxParticles = 50000;
const int kStackSize = 50000;

vec3 g_Gravity = {0, -0.001, 0};
bool g_Pause = false;

enum ParticleStateMessage {
  PSM_None = 0,
  PSM_Kill = 1,
  PSM_Emission = 2,
};

struct Particle {
  vec3 pos = vec3(0.0f);
  vec3 velocity = vec3(0.0f);
  vec3 baseColor = vec3(0.0f);
  vec3 currentColor = vec3(0.0f);

  // lifetime tracking
  int TTL = 0;
  int initialLT = 1;

  // state flags
  bool alive = false;
  bool flare = false;
  bool spawnExplosion = false;

  // visual properties
  bool fadingOut = false;
  bool emission = false;

  Particle() = default;

  Particle(vec3 pos, vec3 vel, vec3 color, int ttl, bool fadingOut = false)
  : pos(pos)
  , velocity(vel)
  , baseColor(color)
  , currentColor(color)
  , TTL(ttl)
  , initialLT(ttl)
  , alive(true)
  , fadingOut(fadingOut) {}

  ParticleStateMessage update() {
    pos += velocity;
    velocity += g_Gravity;
    TTL--;

    if (fadingOut) {
      const float t = static_cast<float>(TTL) / initialLT;
      currentColor = baseColor * t;
    }

    if (TTL < 0)
      return PSM_Kill;

    return emission ? PSM_Emission : PSM_None;
  }
};

struct ParticleSystem {
  Particle particles[kMaxParticles];
  Particle particlesStack[kStackSize];
  int totalParticles = 0;
  int queuedParticles = 0;

  void nextFrame() {
    int processedParticles = 0;

    for (int i = 0; i < kMaxParticles; i++) {
      if (particles[i].alive) {
        processedParticles++;

        switch (particles[i].update()) {
        case PSM_None:
          break;
        case PSM_Kill:
          if (particles[i].spawnExplosion)
            addExplosion(particles[i].pos);
          particles[i].alive = false;
          totalParticles--;
          break;
        case PSM_Emission:
          addParticle(Particle(particles[i].pos,
                               particles[i].velocity * (random(10) / 10.0f),
                               particles[i].currentColor * 0.9f,
                               particles[i].TTL >> 2,
                               true));
          break;
        }
      } else if (queuedParticles > 0) {
        particles[i] = particlesStack[--queuedParticles];
        totalParticles++;
      } else if (processedParticles >= totalParticles) {
        return;
      }
    }
  }

  void addParticle(const Particle& particle) {
    if (queuedParticles < kStackSize)
      particlesStack[queuedParticles++] = particle;
  }
  void addExplosion(vec3 pos) {
    const vec3 FlarePal[3] = {
        {0.2, 0.30, 0.8},
        {0.7, 0.25, 0.3},
        {0.1, 0.80, 0.2},
    };

    const int paletteIndex = static_cast<int>(random(3));

    for (int i = 0; i < 300; i++) {
      float radius = random(1) / 10;
      float angle = random(M_PI * 2.0f);
      vec3 velocity(radius * cosf(angle), radius * sinf(angle), (random(100) - 50) / 5000.0f);
      vec3 color = FlarePal[paletteIndex] + vec3(random(1) / 5, random(1) / 5, random(1) / 5);

      Particle particle(pos, velocity, color, 90 + random(20), true);
      particle.emission = true;

      addParticle(particle);
    }
  }
};

ParticleSystem g_Points;

struct Vertex {
  vec3 pos;
  vec4 color;
};

struct PerFrame {
  mat4 proj;
  mat4 view;
  uint32_t texture;
};

void generateParticleTexture(uint8_t* image, int size) {
  const float center = 0.5f * (size - 1);
  const float maxDist = center;

  for (int y = 0; y < size; y++) {
    for (int x = 0; x < size; x++) {
      const float dx = x - center;
      const float dy = y - center;
      const float dist = sqrtf(dx * dx + dy * dy);

      const float normalizedDist = dist < maxDist ? dist / maxDist : 1.0f;

      // steep falloff with a soft center
      const float falloff = 1.0f - normalizedDist;

      // use cubic falloff and scale to match the max brightness 255 at the center
      const float value = falloff * falloff * falloff * 255.0f;

      image[y * size + x] = static_cast<uint8_t>(fminf(255.0f, fmaxf(0.0f, value)));
    }
  }
}

VULKAN_APP_MAIN {
  const VulkanAppConfig cfg{
      .width = -90,
      .height = -90,
      .resizable = true,
  };
  VULKAN_APP_DECLARE(app, cfg);

  lvk::IContext* ctx = app.ctx_.get();

  lvk::Holder<lvk::BufferHandle> vb0_[3];
  for (auto& vb : vb0_) {
    vb = ctx->createBuffer({
        .usage = lvk::BufferUsageBits_Storage,
        .storage = lvk::StorageType_Device,
        .size = sizeof(Vertex) * kMaxParticles,
        .debugName = "Buffer: vertices",
    });
  }

  lvk::Holder<lvk::BufferHandle> bufPerFrame = ctx->createBuffer({
      .usage = lvk::BufferUsageBits_Storage,
      .storage = lvk::StorageType_HostVisible,
      .size = sizeof(PerFrame),
      .debugName = "Buffer: per frame",
  });

  lvk::Holder<lvk::SamplerHandle> sampler_ = ctx->createSampler({.debugName = "Sampler: linear"}, nullptr);

  uint8_t particleTextureData[64 * 64];
  generateParticleTexture(particleTextureData, 64);

  lvk::Holder<lvk::TextureHandle> texture_ = ctx->createTexture({
      .type = lvk::TextureType_2D,
      .format = lvk::Format_R_UN8,
      .dimensions = {64, 64},
      .usage = lvk::TextureUsageBits_Sampled,
      .data = particleTextureData,
      .debugName = "Particle",
  });

#if defined(LVK_DEMO_WITH_SLANG)
  lvk::Holder<lvk::ShaderModuleHandle> mesh_ = ctx->createShaderModule({codeSlang, lvk::Stage_Mesh, "Shader Module: main (mesh)"});
  lvk::Holder<lvk::ShaderModuleHandle> frag_ = ctx->createShaderModule({codeSlang, lvk::Stage_Frag, "Shader Module: main (frag)"});
#else
  lvk::Holder<lvk::ShaderModuleHandle> mesh_ = ctx->createShaderModule({codeMesh, lvk::Stage_Mesh, "Shader Module: main (mesh)"});
  lvk::Holder<lvk::ShaderModuleHandle> frag_ = ctx->createShaderModule({codeFS, lvk::Stage_Frag, "Shader Module: main (frag)"});
#endif // defined(LVK_DEMO_WITH_SLANG)

  lvk::Holder<lvk::RenderPipelineHandle> renderPipelineState_Mesh_ = ctx->createRenderPipeline({
      .smMesh = mesh_,
      .smFrag = frag_,
      .color = {{
          .format = ctx->getSwapchainFormat(),
          .blendEnabled = true,
          .rgbBlendOp = lvk::BlendOp_Add,
          .alphaBlendOp = lvk::BlendOp_Add,
          .srcRGBBlendFactor = lvk::BlendFactor_SrcAlpha,
          .srcAlphaBlendFactor = lvk::BlendFactor_SrcAlpha,
          .dstRGBBlendFactor = lvk::BlendFactor_One,
          .dstAlphaBlendFactor = lvk::BlendFactor_One,
      }},
      .cullMode = lvk::CullMode_None,
      .debugName = "Pipeline: mesh",
  });

#if !defined(ANDROID)
  app.addKeyCallback([](GLFWwindow* window, int key, int, int action, int) {
    if (key == GLFW_KEY_1 && action == GLFW_PRESS) {
      g_Gravity.x += 0.001f;
    }
    if (key == GLFW_KEY_2 && action == GLFW_PRESS) {
      g_Gravity.x -= 0.001f;
    }
    if (key == GLFW_KEY_SPACE && action == GLFW_PRESS) {
      g_Pause = !g_Pause;
    }
  });
#endif // !ANDROID

  std::vector<Vertex> vertices;
  vertices.reserve(kMaxParticles);

  const float kTimeQuantum = 0.02f;
  double accTime = 0;
  uint32_t bufferIndex = 0;

  app.run([&](uint32_t width, uint32_t height, float aspectRatio, float deltaSeconds) {
    LVK_PROFILER_FUNCTION();

    if (!g_Pause)
      accTime += deltaSeconds;

    if (accTime >= kTimeQuantum) {
      accTime -= kTimeQuantum;
      g_Points.nextFrame();
      if (random(50) <= 1) {
        // shoot a new firework
        const vec3 position((random(100) - 50) / 10, -5, 0);
        const vec3 velocity((random(100) - 50) / 500.0f, 0.25f + (random(200)) / 500.0f, (random(100) - 50) / 500.0f);
        const vec3 color(0.5f, 0.8f, 0.9f);
        Particle flare(position, velocity, color, 20);
        flare.flare = true;
        flare.spawnExplosion = true;
        g_Points.addParticle(flare);
      }
      vertices.clear();
      for (int i = 0; i != kMaxParticles; i++) {
        if (g_Points.particles[i].alive) {
          const Particle& p = g_Points.particles[i];
          vertices.push_back(Vertex{
              .pos = p.pos,
              .color = vec4(p.currentColor, p.flare ? 1.0f : 0.0f),
          });
        }
      }
      if (!vertices.empty()) {
        bufferIndex = (bufferIndex + 1) % LVK_ARRAY_NUM_ELEMENTS(vb0_);
        ctx->upload(vb0_[bufferIndex], vertices.data(), sizeof(Vertex) * vertices.size());
      }
    }

    const PerFrame perFrame = {
        .proj = glm::perspective(glm::radians(90.0f), aspectRatio, 0.1f, 100.0f),
        .view = glm::translate(mat4(1.0f), vec3(0.0f, 0.0f, -8.0f)),
        .texture = texture_.index(),
    };

    lvk::ICommandBuffer& buffer = ctx->acquireCommandBuffer();

    buffer.cmdUpdateBuffer(bufPerFrame, perFrame);

    const lvk::Framebuffer framebuffer = {
        .color = {{.texture = ctx->getCurrentSwapchainTexture()}},
    };
    buffer.cmdBeginRendering(
        lvk::RenderPass{
            .color = {{.loadOp = lvk::LoadOp_Clear, .storeOp = lvk::StoreOp_Store, .clearColor = {0.0f, 0.0f, 0.0f, 0.0f}}},
        },
        framebuffer);
    {
      buffer.cmdBindRenderPipeline(renderPipelineState_Mesh_);
      buffer.cmdBindViewport({0.0f, 0.0f, (float)width, (float)height, 0.0f, +1.0f});
      buffer.cmdBindScissorRect({0, 0, (uint32_t)width, (uint32_t)height});
      buffer.cmdPushDebugGroupLabel("Render Mesh", 0xff0000ff);
      buffer.cmdBindDepthState({.compareOp = lvk::CompareOp_AlwaysPass, .isDepthWriteEnabled = false});
      const struct {
        uint64_t perFrame;
        uint64_t vb;
      } bindings = {
          .perFrame = ctx->gpuAddress(bufPerFrame),
          .vb = ctx->gpuAddress(vb0_[bufferIndex]),
      };
      buffer.cmdPushConstants(bindings);
      if (!vertices.empty()) {
        buffer.cmdDrawMeshTasks({(uint32_t)vertices.size(), 1, 1});
      }
      buffer.cmdPopDebugGroupLabel();
    }
    app.imgui_->beginFrame(framebuffer);
    ImGui::SetNextWindowPos({0, 0});
    ImGui::Begin("Info", nullptr, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoNavInputs);
    ImGui::Text("Particles: %i", g_Points.totalParticles);
    ImGui::End();
    app.drawFPS();
    app.imgui_->endFrame(buffer);
    buffer.cmdEndRendering();

    ctx->submit(buffer, ctx->getCurrentSwapchainTexture());
  });

  VULKAN_APP_EXIT();
}

```

`samples/009_TriplanarMapping.cpp`:

```cpp
/*
 * LightweightVK
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#include "VulkanApp.h"

#include "lvk/vulkan/VulkanClasses.h"

#include <filesystem>

#include <ldrutils/lutils/ScopeExit.h>
#include <stb/stb_image.h>

constexpr uint32_t kNumObjects = 16;

// Bilingual: GLSL (default) and Slang. Define the macro LVK_DEMO_WITH_SLANG to switch to Slang.

const char* codeSlang = R"(
struct Vertex {
  float x, y, z;
  float r, g, b;
};

struct PerFrame {
  float4x4 proj;
  float4x4 view;
  uint texture0;
  uint texture1;
  uint sampler0;
};

struct PerObject {
  float4x4 model[];
};

struct VertexBuffer {
  Vertex vertices[];
};

struct PushConstants {
  PerFrame* perFrame;
  PerObject* perObject;
  VertexBuffer* vb;
};

[[vk::push_constant]] PushConstants pc;

struct VertexStageOutput {
  float4 sv_Position : SV_Position;
  float3 color;
  float3 normal;
};

[shader("vertex")]
VertexStageOutput vertexMain(uint vertexID   : SV_VertexID,
                             uint instanceID : SV_InstanceID)
{
  float4x4 proj = pc.perFrame->proj;
  float4x4 view = pc.perFrame->view;
  float4x4 model = pc.perObject->model[instanceID];

  Vertex v = pc.vb->vertices[vertexID];

  VertexStageOutput out;

  out.sv_Position = proj * view * model * float4(v.x, v.y, v.z, 1.0);
  out.color = float3(v.r, v.g, v.b);
  out.normal = normalize(float3(v.x, v.y, v.z)); // object space normal

  return out;
}

float4 triplanar(uint tex, float3 worldPos, float3 normal) {
  // generate weights, show texture on both sides of the object (positive and negative)
  float3 weights = abs(normal);
  // make the transition sharper
  weights = pow(weights, float3(8.0, 8.0, 8.0));
  // make sure the sum of all components is 1
  weights = weights / (weights.x + weights.y + weights.z);

  // sample the texture for 3 different projections
  float4 cXY = textureBindless2D(tex, pc.perFrame->sampler0, worldPos.xy);
  float4 cZY = textureBindless2D(tex, pc.perFrame->sampler0, worldPos.zy);
  float4 cXZ = textureBindless2D(tex, pc.perFrame->sampler0, worldPos.xz);

  // combine the projected colors
  return cXY * weights.z + cZY * weights.x + cXZ * weights.y;
}

[shader("fragment")]
float4 fragmentMain(VertexStageOutput input) : SV_Target
{
  // triplanar mapping in object-space; for our icosahedron, object-space position and normal vectors are the same
  float4 t0 = triplanar(pc.perFrame->texture0, input.normal, input.normal);
  float4 t1 = triplanar(pc.perFrame->texture1, input.normal, input.normal);

  return float4(input.color * (t0.rgb + t1.rgb), 1.0);
}
)";

const char* codeVS = R"(
layout (location=0) out vec3 color;
layout (location=1) out vec3 normal;

struct Vertex {
  float x, y, z;
  float r, g, b;
};

layout(std430, buffer_reference) readonly buffer VertexBuffer {
  Vertex vertices[];
};

layout(std430, buffer_reference) readonly buffer PerFrame {
  mat4 proj;
  mat4 view;
  uint texture0;
  uint texture1;
  uint sampler0;
};

layout(std430, buffer_reference) readonly buffer PerObject {
  mat4 model[];
};

layout(push_constant) uniform constants {
  PerFrame perFrame;
  PerObject perObject;
  VertexBuffer vb;
} pc;

void main() {
  mat4 proj = pc.perFrame.proj;
  mat4 view = pc.perFrame.view;
  mat4 model = pc.perObject.model[gl_InstanceIndex];
  Vertex v = pc.vb.vertices[gl_VertexIndex];
  gl_Position = proj * view * model * vec4(v.x, v.y, v.z, 1.0);
  color = vec3(v.r, v.g, v.b);
  normal = normalize(vec3(v.x, v.y, v.z)); // object space normal
}
)";

const char* codeFS = R"(
layout (location=0) in vec3 color;
layout (location=1) in vec3 normal;
layout (location=0) out vec4 out_FragColor;

layout(std430, buffer_reference) readonly buffer PerFrame {
  mat4 proj;
  mat4 view;
  uint texture0;
  uint texture1;
  uint sampler0;
};

layout(push_constant) uniform constants {
	PerFrame perFrame;
} pc;

vec4 triplanar(uint tex, vec3 worldPos, vec3 normal) {
  // generate weights, show texture on both sides of the object (positive and negative)
  vec3 weights = abs(normal);
  // make the transition sharper
  weights = pow(weights, vec3(8.0));
  // make sure the sum of all components is 1
  weights = weights / (weights.x + weights.y + weights.z);

  // sample the texture for 3 different projections
  vec4 cXY = textureBindless2D(tex, pc.perFrame.sampler0, worldPos.xy);
  vec4 cZY = textureBindless2D(tex, pc.perFrame.sampler0, worldPos.zy);
  vec4 cXZ = textureBindless2D(tex, pc.perFrame.sampler0, worldPos.xz);

  // combine the projected colors
  return cXY * weights.z + cZY * weights.x + cXZ * weights.y;
}

void main() {
  // triplanar mapping in object-space; for our icosahedron, object-space position and normal vectors are the same
  vec4 t0 = triplanar(pc.perFrame.texture0, normal, normal);
  vec4 t1 = triplanar(pc.perFrame.texture1, normal, normal);
  out_FragColor = vec4(color * (t0.rgb + t1.rgb), 1.0);
};
)";

struct VertexPosUvw {
  vec3 pos;
  vec3 color;
};

struct PerFrame {
  mat4 proj;
  mat4 view;
  uint32_t texture0;
  uint32_t texture1;
  uint32_t sampler;
};

lvk::Holder<lvk::TextureHandle> texture0_;
lvk::Holder<lvk::TextureHandle> texture1_;

VULKAN_APP_MAIN {
  const VulkanAppConfig cfg{
      .width = 1280,
      .height = 1024,
      .resizable = true,
      // register present modes at swapchain creation so all supported modes can be runtime-switched via setCurrentPresentMode()
      .contextConfig =
          {
              .presentModes =
                  {
                      lvk::PresentMode_Mailbox,
                      lvk::PresentMode_Immediate,
                      lvk::PresentMode_FIFO_Relaxed,
                      lvk::PresentMode_FIFO_Latest_Ready,
                      lvk::PresentMode_FIFO,
                  },
          },
  };
  VULKAN_APP_DECLARE(app, cfg);

  lvk::IContext* ctx = app.ctx_.get();

  // clang-format off
  // icosahedron
  const float t = (1.0f + sqrtf(5.0f)) / 2.0f;
  const VertexPosUvw vertexData[] = {
    {{-1,  t, 0}, {0, 1, 0}},
    {{ 1,  t, 0}, {1, 1, 0}},
    {{-1, -t, 0}, {0, 1, 0}},
    {{ 1, -t, 0}, {1, 1, 0}},

    {{0, -1,  t}, {0, 0, 1}},
    {{0,  1,  t}, {0, 1, 1}},
    {{0, -1, -t}, {0, 0, 1}},
    {{0,  1, -t}, {0, 1, 1}},

    {{ t, 0, -1}, {1, 0, 0}},
    {{ t, 0,  1}, {1, 0, 1}},
    {{-t, 0, -1}, {1, 0, 0}},
    {{-t, 0,  1}, {1, 0, 1}},
  };
  // clang-format on

  lvk::Holder<lvk::BufferHandle> vb0_ = ctx->createBuffer({
      .usage = lvk::BufferUsageBits_Storage,
      .storage = lvk::StorageType_Device,
      .size = sizeof(vertexData),
      .data = vertexData,
      .debugName = "Buffer: vertices",
  });

  const uint16_t indexData[] = {0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4,  11, 10, 2,  10, 7, 6, 7, 1, 8,
                                3, 9,  4, 3, 4, 2, 3, 2, 6, 3, 6, 8,  3, 8,  9,  4, 9, 5, 2, 4,  11, 6,  2,  10, 8,  6, 7, 9, 8, 1};

  lvk::Holder<lvk::BufferHandle> ib0_ = ctx->createBuffer({
      .usage = lvk::BufferUsageBits_Index,
      .storage = lvk::StorageType_Device,
      .size = sizeof(indexData),
      .data = indexData,
      .debugName = "Buffer: indices",
  });

  lvk::Holder<lvk::BufferHandle> bufPerFrame = ctx->createBuffer({
      .usage = lvk::BufferUsageBits_Storage,
      .storage = lvk::StorageType_HostVisible,
      .size = sizeof(PerFrame),
      .debugName = "Buffer: per frame",
  });
  lvk::Holder<lvk::BufferHandle> bufModelMatrices = ctx->createBuffer({
      .usage = lvk::BufferUsageBits_Storage,
      .storage = lvk::StorageType_HostVisible,
      .size = kNumObjects * sizeof(mat4),
      .debugName = "Buffer: model matrices",
  });

  lvk::Holder<lvk::SamplerHandle> sampler_ = ctx->createSampler({.debugName = "Sampler: linear"}, nullptr);

  // texture 0
  {
    const uint32_t texWidth = 256;
    const uint32_t texHeight = 256;
    std::vector<uint32_t> pixels(texWidth * texHeight);
    for (uint32_t y = 0; y != texHeight; y++) {
      for (uint32_t x = 0; x != texWidth; x++) {
        // create a XOR pattern
        pixels[y * texWidth + x] = 0xFF000000 + ((x ^ y) << 16) + ((x ^ y) << 8) + (x ^ y);
      }
    }
    texture0_ = ctx->createTexture({
        .type = lvk::TextureType_2D,
        .format = lvk::Format_BGRA_UN8,
        .dimensions = {texWidth, texHeight},
        .usage = lvk::TextureUsageBits_Sampled,
        .data = pixels.data(),
        .debugName = "XOR pattern",
    });
  }

  // texture 1
  {
    using namespace std::filesystem;
    path dir = app.folderContentRoot_;
    int32_t texWidth = 0;
    int32_t texHeight = 0;
    int32_t channels = 0;
    uint8_t* pixels = stbi_load(
        (dir / path("src/bistro/BuildingTextures/wood_polished_01_diff.png")).string().c_str(), &texWidth, &texHeight, &channels, 4);
    SCOPE_EXIT {
      stbi_image_free(pixels);
    };
    if (!pixels) {
      LVK_ASSERT_MSG(false, "Cannot load textures. Run `deploy_content.py`/`deploy_content_android.py` before running this app.");
      LLOGW("Cannot load textures. Run `deploy_content.py`/`deploy_content_android.py` before running this app.");
      std::terminate();
    }
    texture1_ = ctx->createTexture({
        .type = lvk::TextureType_2D,
        .format = lvk::Format_RGBA_UN8,
        .dimensions = {(uint32_t)texWidth, (uint32_t)texHeight},
        .usage = lvk::TextureUsageBits_Sampled,
        .data = pixels,
        .debugName = "wood_polished_01_diff.png",
    });
  }

  vec3 axis_[kNumObjects]; // uninitialized

  // generate random rotation axes
  for (vec3& v : axis_) {
    v = glm::sphericalRand(1.0f);
  }

  auto presentModeToString = [](lvk::PresentMode mode) {
    switch (mode) {
    case lvk::PresentMode_FIFO:
      return "FIFO (V-Sync)";
    case lvk::PresentMode_FIFO_Relaxed:
      return "FIFO Relaxed";
    case lvk::PresentMode_FIFO_Latest_Ready:
      return "FIFO Latest Ready";
    case lvk::PresentMode_Mailbox:
      return "Mailbox";
    case lvk::PresentMode_Immediate:
      return "Immediate (No V-Sync)";
    default:
      return "Unknown";
    }
  };

  // get available present modes
  std::vector<lvk::PresentMode> availableModes;
  lvk::VulkanContext& vulkanContext = static_cast<lvk::VulkanContext&>(*ctx);
  for (uint32_t i = 0; i != vulkanContext.swapchain_->numRegisteredPresentModes_; i++) {
    availableModes.push_back(lvk::vkPresentModeToPresentMode(vulkanContext.swapchain_->registeredPresentModes_[i]));
  };
  int currentPresentModeIdx = 0;
  if (!availableModes.empty()) {
    (void)ctx->setCurrentPresentMode(availableModes[0]);
  }

#if defined(LVK_DEMO_WITH_SLANG)
  lvk::Holder<lvk::ShaderModuleHandle> vert_ = ctx->createShaderModule({codeSlang, lvk::Stage_Vert, "Shader Module: main (vert)"});
  lvk::Holder<lvk::ShaderModuleHandle> frag_ = ctx->createShaderModule({codeSlang, lvk::Stage_Frag, "Shader Module: main (frag)"});
#else
  lvk::Holder<lvk::ShaderModuleHandle> vert_ = ctx->createShaderModule({codeVS, lvk::Stage_Vert, "Shader Module: main (vert)"});
  lvk::Holder<lvk::ShaderModuleHandle> frag_ = ctx->createShaderModule({codeFS, lvk::Stage_Frag, "Shader Module: main (frag)"});
#endif // defined(LVK_DEMO_WITH_SLANG)

  lvk::Holder<lvk::RenderPipelineHandle> renderPipelineState_Mesh_ = ctx->createRenderPipeline({
      .smVert = vert_,
      .smFrag = frag_,
      .color = {{.format = ctx->getSwapchainFormat()}},
      .depthFormat = app.getDepthFormat(),
      .cullMode = lvk::CullMode_Back,
      .frontFace = lvk::WindingMode_CW,
      .debugName = "Pipeline: mesh",
  });

#if !defined(ANDROID)
  app.addKeyCallback([](GLFWwindow* window, int key, int, int action, int) {
    if (key == GLFW_KEY_T && action == GLFW_PRESS) {
      texture1_.reset();
    }
  });
#endif // !ANDROID

  app.run([&](uint32_t width, uint32_t height, float aspectRatio, float deltaSeconds) {
    LVK_PROFILER_FUNCTION();

    const float fov = float(45.0f * (M_PI / 180.0f));
    const PerFrame perFrame = {
        .proj = glm::perspectiveLH(fov, aspectRatio, 0.1f, 100.0f),
        // place the "camera" behind the objects, the distance depends on the total number of objects
        .view = glm::translate(mat4(1.0f), vec3(0.0f, 0.0f, sqrtf(kNumObjects / 16) * 14.0f * t)),
        .texture0 = texture0_.index(),
        .texture1 = texture1_.index(),
        .sampler = sampler_.index(),
    };

    mat4 modelMatrices[kNumObjects]; // uninitialized

    // rotate objects around random axes
    for (uint32_t i = 0; i != kNumObjects; i++) {
      const float direction = powf(-1, (float)(i + 1));
      const uint32_t cubesInLine = (uint32_t)sqrt(kNumObjects);
      const vec3 offset =
          vec3(-1.5f * sqrt(kNumObjects) + 4.0f * (i % cubesInLine), -1.5f * sqrt(kNumObjects) + 4.0f * (i / cubesInLine), 0);
      modelMatrices[i] = glm::rotate(glm::translate(mat4(1.0f), offset), float(direction * glfwGetTime()), axis_[i]);
    }

    lvk::ICommandBuffer& buffer = ctx->acquireCommandBuffer();

    buffer.cmdUpdateBuffer(bufPerFrame, perFrame);
    buffer.cmdUpdateBuffer(bufModelMatrices, modelMatrices);

    lvk::Framebuffer framebuffer = {
        .color = {{.texture = ctx->getCurrentSwapchainTexture()}},
        .depthStencil = {app.getDepthTexture()},
    };
    buffer.cmdBeginRendering(
        lvk::RenderPass{.color = {{.loadOp = lvk::LoadOp_Clear, .storeOp = lvk::StoreOp_Store, .clearColor = {1.0f, 1.0f, 1.0f, 1.0f}}},
                        .depth = {.loadOp = lvk::LoadOp_Clear, .clearDepth = 1.0}},
        framebuffer);
    {
      buffer.cmdBindRenderPipeline(renderPipelineState_Mesh_);
      buffer.cmdBindViewport({0.0f, 0.0f, (float)width, (float)height, 0.0f, +1.0f});
      buffer.cmdBindScissorRect({0, 0, (uint32_t)width, (uint32_t)height});
      buffer.cmdPushDebugGroupLabel("Render Mesh", 0xff0000ff);
      buffer.cmdBindDepthState({.compareOp = lvk::CompareOp_Less, .isDepthWriteEnabled = true});
      buffer.cmdBindIndexBuffer(ib0_, lvk::IndexFormat_UI16);
      const struct {
        uint64_t perFrame;
        uint64_t perObject;
        uint64_t vb;
      } bindings = {
          .perFrame = ctx->gpuAddress(bufPerFrame),
          .perObject = ctx->gpuAddress(bufModelMatrices),
          .vb = ctx->gpuAddress(vb0_),
      };
      buffer.cmdPushConstants(bindings);
      buffer.cmdDrawIndexed(LVK_ARRAY_NUM_ELEMENTS(indexData), kNumObjects);
      buffer.cmdPopDebugGroupLabel();
    }
    app.imgui_->beginFrame(framebuffer);
    ImGui::SetNextWindowPos({0, 0});
    ImGui::SetNextWindowCollapsed(true, ImGuiCond_Once);
    ImGui::Begin("Texture Viewer", nullptr, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoNavInputs);
    ImGui::Image(texture1_.index(), ImVec2(512, 512));
    if (texture1_.valid())
      ImGui::Text("Press T to unload texture");
    ImGui::End();
    ImGui::SetNextWindowPos({0, 30}, ImGuiCond_Once);
    ImGui::Begin("Present Mode", nullptr, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoNavInputs);
    if (availableModes.size() > 1) {
      for (int i = 0; i != (int)availableModes.size(); i++) {
        if (ImGui::RadioButton(presentModeToString(availableModes[i]), &currentPresentModeIdx, i)) {
          (void)ctx->setCurrentPresentMode(availableModes[i]);
        }
      }
    } else {
      ImGui::TextDisabled("Runtime switching unavailable");
      ImGui::Text("%s", presentModeToString(ctx->getCurrentPresentMode()));
    }
    ImGui::End();
    app.drawFPS();
    app.imgui_->endFrame(buffer);
    buffer.cmdEndRendering();

    ctx->submit(buffer, ctx->getCurrentSwapchainTexture());
  });

  // destroy all the Vulkan stuff before closing the window
  texture0_.reset();
  texture1_.reset();

  VULKAN_APP_EXIT();
}

```

`samples/010_OmniShadows.cpp`:

```cpp
/*
 * LightweightVK
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#include "VulkanApp.h"

#include "lmath/GeometryShapes.h"

// Bilingual: GLSL (default) and Slang. Define the macro LVK_DEMO_WITH_SLANG to switch to Slang.

const char* codeShadowSlang = R"(
struct Vertex {
  float x, y, z;
  float u, v;
  float r, g, b;
};

struct PerFrame {
  float4x4 proj[6];
  float4x4 view[6];
};

struct PerObject {
  float4x4 model[];
};

struct PerLight {
  float4 lightPos;
  float shadowNear;
  float shadowFar;
  uint shadowMap;
};

struct VertexBuffer {
  Vertex vertices[];
};

struct PushConstants {
  PerFrame* perFrame;
  PerObject* perObject;
  VertexBuffer* vb;
  PerLight* perLight;
};

[[vk::push_constant]] PushConstants pc;

struct VertexStageOutput {
  float4 sv_Position : SV_Position;
  float4 worldPos;
};

[shader("vertex")]
VertexStageOutput vertexMain(uint vertexID   : SV_VertexID,
                             uint instanceID : SV_InstanceID,
                             uint viewIndex  : SV_ViewID)
{
  float4x4 proj = pc.perFrame->proj[viewIndex];
  float4x4 view = pc.perFrame->view[viewIndex];
  float4x4 model = pc.perObject->model[instanceID];

  Vertex v = pc.vb->vertices[vertexID];

  VertexStageOutput out;

  out.worldPos = model * float4(v.x, v.y, v.z, 1.0);
  out.sv_Position = proj * view * out.worldPos;

  return out;
}

[shader("fragment")]
float fragmentMain(VertexStageOutput input) : SV_Depth
{
  // get distance between fragment and light source
  float lightDistance = length(input.worldPos.xyz - pc.perLight.lightPos.xyz);
    
  // remap to [0...1]
  lightDistance = lightDistance / pc.perLight->shadowFar;

  return lightDistance;
}
)";

const char* codeSlang = R"(
struct Vertex {
  float x, y, z;
  float u, v;
  float nx, ny, nz;
};

struct PerFrame {
  float4x4 proj;
  float4x4 view;
};

struct PerObject {
  float4x4 model[];
};

struct PerLight {
  float4 lightPos;
  float shadowNear;
  float shadowFar;
  uint shadowMap;
};

struct VertexBuffer {
  Vertex vertices[];
};

struct PushConstants {
  PerFrame* perFrame;
  PerObject* perObject;
  VertexBuffer* vb;
  PerLight* perLight;
};

[[vk::push_constant]] PushConstants pc;

struct VertexStageOutput {
  float4 sv_Position : SV_Position;
  float4 worldPos;
  float3 color;
  float3 normal;
};

[shader("vertex")]
VertexStageOutput vertexMain(uint vertexID   : SV_VertexID,
                             uint instanceID : SV_InstanceID)
{
  float4x4 proj = pc.perFrame->proj;
  float4x4 view = pc.perFrame->view;
  float4x4 model = pc.perObject->model[instanceID];

  Vertex v = pc.vb->vertices[vertexID];

  VertexStageOutput out;

  out.worldPos = model * float4(v.x, v.y, v.z, 1.0);
  out.sv_Position = proj * view * out.worldPos;
  out.color = out.worldPos.xyz * 0.03 + float3(0.6);
  out.normal = normalize(float3(v.nx, v.ny, v.nz)); // object space normal as we have an identity model matrix  

  return out;
}

float shadowFactor(float3 fragToLight) {
  // our Y axis is inverted
  fragToLight.y = -fragToLight.y;
  
  // sample from the depth cube map and re-transform back to original value
  float closestDepth = pc.perLight->shadowFar * textureBindlessCube(pc.perLight->shadowMap, 0, fragToLight).r;

  // get current linear depth as the length between the fragment and light position
  float currentDepth = length(fragToLight);

  // now test for shadows
  float bias = 0.1;

  return currentDepth - bias > closestDepth ? 0.0 : 1.0;
}

float shadowFactorPCF3x3x3(float3 fragToLight) {
  float factor = shadowFactor(fragToLight);
  float k = length(fragToLight) * 0.0015;

  for (int x = -1; x != 2; x++)
    for (int y = -1; y != 2; y++)
      for (int z = -1; z != 2; z++)
        factor += shadowFactor(fragToLight + k * float3(x, y, z));

  return factor / 28.0;
}

float attenuation(float distToLight, float radius) {
  float I = distToLight / radius;
  return max(1.0 - I * I, 0.0);
}

[shader("fragment")]
float4 fragmentMain(VertexStageOutput input) : SV_Target {
  float3 fragToLight = input.worldPos.xyz - pc.perLight->lightPos.xyz;
  float NdotL = max(dot(normalize(input.normal), normalize(-fragToLight)), 0.0);
  
  float3 finalColor = input.color * NdotL * shadowFactorPCF3x3x3(fragToLight) * attenuation(length(fragToLight), 50.0);
  
  // add ambient so shadows are not completely black
  return float4(max(finalColor, input.color * 0.3), 1.0);
}
)";

const char* codeShadowVS = R"(
#extension GL_EXT_multiview : enable

layout (location=0) out vec4 v_WorldPos;

struct Vertex {
  float x, y, z;
  float u, v;
  float nx, ny, nz;
};

layout(std430, buffer_reference) readonly buffer VertexBuffer {
  Vertex vertices[];
};

layout(std430, buffer_reference) readonly buffer PerFrame {
  mat4 proj[6];
  mat4 view[6];
};

layout(std430, buffer_reference) readonly buffer PerObject {
  mat4 model[];
};

layout(push_constant) uniform constants {
  PerFrame perFrame;
  PerObject perObject;
  VertexBuffer vb;
} pc;

void main() {
  mat4 proj = pc.perFrame.proj[gl_ViewIndex];
  mat4 view = pc.perFrame.view[gl_ViewIndex];
  mat4 model = pc.perObject.model[gl_InstanceIndex];
  Vertex v = pc.vb.vertices[gl_VertexIndex];
  v_WorldPos = model * vec4(v.x, v.y, v.z, 1.0);
  gl_Position = proj * view * v_WorldPos;
}
)";

const char* codeShadowFS = R"(
layout (location=0) in vec4 v_WorldPos;

layout(std430, buffer_reference) readonly buffer PerLight {
  vec4 lightPos;
  float shadowNear;
  float shadowFar;
  uint shadowMap;
};

layout(push_constant) uniform constants {
  vec2 perFrame;
  vec2 perObject;
  vec2 vb;  
  PerLight perLight;
} pc;

void main() {
  // get distance between fragment and light source
  float lightDistance = length(v_WorldPos.xyz - pc.perLight.lightPos.xyz);
    
  // remap to [0...1]
  lightDistance = lightDistance / pc.perLight.shadowFar;
    
  gl_FragDepth = lightDistance;
}
)";

const char* codeVS = R"(
layout (location=0) out vec3 v_Color;
layout (location=1) out vec3 v_Normal;
layout (location=2) out vec4 v_WorldPos;

struct Vertex {
  float x, y, z;
  float u, v;
  float nx, ny, nz;
};

layout(std430, buffer_reference) readonly buffer VertexBuffer {
  Vertex vertices[];
};

layout(std430, buffer_reference) readonly buffer PerFrame {
  mat4 proj;
  mat4 view;  
};

layout(std430, buffer_reference) readonly buffer PerObject {
  mat4 model[];
};

layout(std430, buffer_reference) readonly buffer PerLight {
  vec4 lightPos;
  float shadowNear;
  float shadowFar;
  uint shadowMap;
};

layout(push_constant) uniform constants {
  PerFrame perFrame;
  PerObject perObject;
  VertexBuffer vb;
  PerLight perLight;
} pc;

void main() {
  mat4 proj = pc.perFrame.proj;
  mat4 view = pc.perFrame.view;
  mat4 model = pc.perObject.model[gl_InstanceIndex];
  Vertex v = pc.vb.vertices[gl_VertexIndex];
  v_WorldPos = model * vec4(v.x, v.y, v.z, 1.0);
  gl_Position = proj * view * v_WorldPos;
 
  v_Color = v_WorldPos.xyz * 0.03 + vec3(0.6);
  v_Normal = normalize(vec3(v.nx, v.ny, v.nz)); // object space normal as we have an identity model matrix  
}
)";

const char* codeFS = R"(
layout (location=0) in vec3 v_Color;
layout (location=1) in vec3 v_Normal;
layout (location=2) in vec4 v_WorldPos;
layout (location=0) out vec4 out_FragColor;

layout(std430, buffer_reference) readonly buffer PerFrame {
  mat4 proj;
  mat4 view;
};

layout(std430, buffer_reference) readonly buffer PerLight {
  vec4 lightPos;
  float shadowNear;
  float shadowFar;
  uint shadowMap;
};

layout(push_constant) uniform constants {
	PerFrame perFrame;
   vec2 perObject;
   vec2 vb;      
   PerLight perLight;
} pc;

float shadowFactor(vec3 fragToLight) {
  // our Y axis is inverted
  fragToLight.y = -fragToLight.y;
  
  // sample from the depth cube map and re-transform back to original value
  float closestDepth = pc.perLight.shadowFar * textureBindlessCube(pc.perLight.shadowMap, 0, fragToLight).r;

  // get current linear depth as the length between the fragment and light position
  float currentDepth = length(fragToLight);

  // now test for shadows
  float bias = 0.1;

  return currentDepth - bias > closestDepth ? 0.0 : 1.0;
}

float shadowFactorPCF3x3x3(vec3 fragToLight) {
  float factor = shadowFactor(fragToLight);
  float k = length(fragToLight) * 0.0015;

  for (int x = -1; x != 2; x++)
    for (int y = -1; y != 2; y++)
      for (int z = -1; z != 2; z++)
        factor += shadowFactor(fragToLight + k * vec3(x, y, z));

  return factor / 28.0;
}

float attenuation(float distToLight, float radius) {
  float I = distToLight / radius;
  return max(1.0 - I * I, 0.0);
}

void main() {
  vec3 fragToLight = v_WorldPos.xyz - pc.perLight.lightPos.xyz;
  float NdotL = max(dot(normalize(v_Normal), normalize(-fragToLight)), 0.0);
  
  vec3 finalColor = v_Color * NdotL * shadowFactorPCF3x3x3(fragToLight) * attenuation(length(fragToLight), 50.0);
  
  // add ambient so shadows are not completely black
  out_FragColor = vec4(max(finalColor, v_Color * 0.3), 1.0);
};
)";

struct PerFrame {
  mat4 proj;
  mat4 view;
};

struct PerFrameShadow {
  mat4 proj[6];
  mat4 view[6];
};

struct PerLight {
  vec4 lightPos;
  float shadowNear;
  float shadowFar;
  uint32_t shadowMap;
};

VULKAN_APP_MAIN {
  const VulkanAppConfig cfg{
      .width = -90,
      .height = -90,
      .resizable = true,
      .initialCameraPos = vec3(-12, 10, 10),
      .initialCameraTarget = vec3(0, 0, 0),
      .initialCameraUpVector = vec3(0, 0, 1),
  };
  VULKAN_APP_DECLARE(app, cfg);

  lvk::IContext* ctx = app.ctx_.get();

  std::vector<GeometryShapes::Vertex> vertexData;

  // pillars
  const int sizeX = 4;
  const int sizeY = 4;
  const float sx = 0.5f;
  const float sy = 0.5f;
  const float h = 3.0f;
  const float spacing = 4.0f;
  for (int x = 0; x != sizeX; x++) {
    for (int y = 0; y != sizeY; y++) {
      GeometryShapes::addAxisAlignedBox(
          vertexData, vec3(spacing * (x - (sizeX - 1) / 2.0f), spacing * (y - (sizeY - 1) / 2.0f), 0.0f), vec3(sx, sy, h));
    }
  }
  // walls
  GeometryShapes::addAxisAlignedBox(vertexData, vec3(-sizeX * spacing, 0, 0), vec3(sx / 2, 2 * sizeY * spacing * sx, 2 * h));
  GeometryShapes::addAxisAlignedBox(vertexData, vec3(+sizeX * spacing, 0, 0), vec3(sx / 2, 2 * sizeY * spacing * sx, 2 * h));
  GeometryShapes::addAxisAlignedBox(vertexData, vec3(0, -sizeY * spacing, 0), vec3(2 * sizeX * spacing * sx, sy / 2, h));
  GeometryShapes::addAxisAlignedBox(vertexData, vec3(0, +sizeY * spacing, 0), vec3(2 * sizeX * spacing * sx, sy / 2, h));
  GeometryShapes::addAxisAlignedBox(vertexData, vec3(0, 0, -h), vec3(2 * sizeX * spacing * sx, 2 * sizeY * spacing * sx, (sx + sy) / 4));

  lvk::Holder<lvk::BufferHandle> vb0_ = ctx->createBuffer({
      .usage = lvk::BufferUsageBits_Storage,
      .storage = lvk::StorageType_Device,
      .size = sizeof(GeometryShapes::Vertex) * vertexData.size(),
      .data = vertexData.data(),
      .debugName = "Buffer: vertices",
  });

  lvk::Holder<lvk::BufferHandle> bufPerFrame = ctx->createBuffer({
      .usage = lvk::BufferUsageBits_Storage,
      .storage = lvk::StorageType_HostVisible,
      .size = sizeof(PerFrame),
      .debugName = "Buffer: per frame",
  });
  lvk::Holder<lvk::BufferHandle> bufPerFrameShadow = ctx->createBuffer({
      .usage = lvk::BufferUsageBits_Storage,
      .storage = lvk::StorageType_HostVisible,
      .size = sizeof(PerFrameShadow),
      .debugName = "Buffer: per frame (shadow)",
  });
  lvk::Holder<lvk::BufferHandle> bufPerLight = ctx->createBuffer({
      .usage = lvk::BufferUsageBits_Storage,
      .storage = lvk::StorageType_HostVisible,
      .size = sizeof(PerLight),
      .debugName = "Buffer: per light",
  });

  std::vector<mat4> modelMatrices(1);

  lvk::Holder<lvk::BufferHandle> bufPerObject = ctx->createBuffer({
      .usage = lvk::BufferUsageBits_Storage,
      .storage = lvk::StorageType_HostVisible,
      .size = sizeof(mat4) * modelMatrices.size(),
      .debugName = "Buffer: model matrices",
  });

#if defined(LVK_DEMO_WITH_SLANG)
  lvk::Holder<lvk::ShaderModuleHandle> vert_ = ctx->createShaderModule({codeSlang, lvk::Stage_Vert, "Shader Module: main (vert)"});
  lvk::Holder<lvk::ShaderModuleHandle> frag_ = ctx->createShaderModule({codeSlang, lvk::Stage_Frag, "Shader Module: main (frag)"});
  lvk::Holder<lvk::ShaderModuleHandle> vertShadow_ =
      ctx->createShaderModule({codeShadowSlang, lvk::Stage_Vert, "Shader Module: main (vert)"});
  lvk::Holder<lvk::ShaderModuleHandle> fragShadow_ =
      ctx->createShaderModule({codeShadowSlang, lvk::Stage_Frag, "Shader Module: main (frag)"});
#else
  lvk::Holder<lvk::ShaderModuleHandle> vert_ = ctx->createShaderModule({codeVS, lvk::Stage_Vert, "Shader Module: main (vert)"});
  lvk::Holder<lvk::ShaderModuleHandle> frag_ = ctx->createShaderModule({codeFS, lvk::Stage_Frag, "Shader Module: main (frag)"});
  lvk::Holder<lvk::ShaderModuleHandle> vertShadow_ =
      ctx->createShaderModule({codeShadowVS, lvk::Stage_Vert, "Shader Module: shadow (vert)"});
  lvk::Holder<lvk::ShaderModuleHandle> fragShadow_ =
      ctx->createShaderModule({codeShadowFS, lvk::Stage_Frag, "Shader Module: shadow (frag)"});
#endif // defined(LVK_DEMO_WITH_SLANG)

  lvk::Holder<lvk::RenderPipelineHandle> renderPipelineState_Mesh_ = ctx->createRenderPipeline({
      .smVert = vert_,
      .smFrag = frag_,
      .color = {{.format = ctx->getSwapchainFormat()}},
      .depthFormat = app.getDepthFormat(),
      .cullMode = lvk::CullMode_Back,
      .debugName = "Pipeline: mesh",
  });

  const uint32_t shadowMapSize = 1024;

  lvk::Holder<lvk::TextureHandle> shadowMap = ctx->createTexture({
      .type = lvk::TextureType_Cube,
      .format = app.getDepthFormat(),
      .dimensions = {shadowMapSize, shadowMapSize},
      .usage = lvk::TextureUsageBits_Sampled | lvk::TextureUsageBits_Attachment,
      .debugName = "Texture: shadow map",
  });

  lvk::Holder<lvk::TextureHandle> layers[6];

  for (uint32_t l = 0; l != LVK_ARRAY_NUM_ELEMENTS(layers); l++) {
    layers[l] = ctx->createTextureView(shadowMap,
                                       {.layer = l,
                                        .components = {
                                            .r = lvk::Swizzle_R,
                                            .g = lvk::Swizzle_R,
                                            .b = lvk::Swizzle_R,
                                            .a = lvk::Swizzle_1,
                                        }});
  }

  lvk::Holder<lvk::RenderPipelineHandle> renderPipelineState_Shadow_ = ctx->createRenderPipeline({
      .smVert = vertShadow_,
      .smFrag = fragShadow_,
      .depthFormat = ctx->getFormat(shadowMap),
      .cullMode = lvk::CullMode_None,
      .debugName = "Pipeline: shadow",
  });

  app.run([&](uint32_t width, uint32_t height, float aspectRatio, float deltaSeconds) {
    LVK_PROFILER_FUNCTION();

    const float fov = glm::radians(45.0f);
    const float fovShadow = glm::radians(90.0f);
    const vec3 lightPos = vec3(4.5f * cosf(glfwGetTime()), 4.5f * sinf(glfwGetTime()), 5.0f);
    const PerLight perLight = {
        .lightPos = vec4(lightPos, 1.0f),
        .shadowNear = 0.1f,
        .shadowFar = 100.0f,
        .shadowMap = shadowMap.index(),
    };
    const PerFrame perFrame = {
        .proj = glm::perspective(fov, aspectRatio, 0.1f, 100.0f),
        .view = app.camera_.getViewMatrix(),
    };
    const PerFrameShadow perFrameShadow = {
        .proj = {glm::perspective(fovShadow, 1.0f, perLight.shadowNear, perLight.shadowFar),
                 glm::perspective(fovShadow, 1.0f, perLight.shadowNear, perLight.shadowFar),
                 glm::perspective(fovShadow, 1.0f, perLight.shadowNear, perLight.shadowFar),
                 glm::perspective(fovShadow, 1.0f, perLight.shadowNear, perLight.shadowFar),
                 glm::perspective(fovShadow, 1.0f, perLight.shadowNear, perLight.shadowFar),
                 glm::perspective(fovShadow, 1.0f, perLight.shadowNear, perLight.shadowFar)},
        .view = {glm::lookAt(lightPos, lightPos + vec3(+1.0, 0.0, 0.0), vec3(0.0, -1.0, 0.0)),
                 glm::lookAt(lightPos, lightPos + vec3(-1.0, 0.0, 0.0), vec3(0.0, -1.0, 0.0)),
                 glm::lookAt(lightPos, lightPos + vec3(0.0, -1.0, 0.0), vec3(0.0, 0.0, -1.0)),
                 glm::lookAt(lightPos, lightPos + vec3(0.0, +1.0, 0.0), vec3(0.0, 0.0, +1.0)),
                 glm::lookAt(lightPos, lightPos + vec3(0.0, 0.0, +1.0), vec3(0.0, -1.0, 0.0)),
                 glm::lookAt(lightPos, lightPos + vec3(0.0, 0.0, -1.0), vec3(0.0, -1.0, 0.0))},
    };

    lvk::ICommandBuffer& buffer = ctx->acquireCommandBuffer();

    auto drawMesh = [&](lvk::BufferHandle bufPerFrame) {
      const struct {
        uint64_t perFrame;
        uint64_t perObject;
        uint64_t vb;
        uint64_t perLight;
      } bindings = {
          .perFrame = ctx->gpuAddress(bufPerFrame),
          .perObject = ctx->gpuAddress(bufPerObject),
          .vb = ctx->gpuAddress(vb0_),
          .perLight = ctx->gpuAddress(bufPerLight),
      };
      buffer.cmdPushConstants(bindings);
      buffer.cmdDraw(vertexData.size());
    };

    modelMatrices[0] = mat4(1.0f);

    buffer.cmdUpdateBuffer(bufPerFrame, perFrame);
    buffer.cmdUpdateBuffer(bufPerFrameShadow, perFrameShadow);
    buffer.cmdUpdateBuffer(bufPerLight, perLight);
    buffer.cmdUpdateBuffer(bufPerObject, 0, sizeof(mat4) * modelMatrices.size(), modelMatrices.data());

    // 1. Render shadow map
    buffer.cmdBeginRendering(
        lvk::RenderPass{
            .depth = {.loadOp = lvk::LoadOp_Clear, .clearDepth = 1000.0},
            .layerCount = 6,
            .viewMask = 0b111111,
        },
        {
            .depthStencil = {shadowMap},
        });
    {
      buffer.cmdBindRenderPipeline(renderPipelineState_Shadow_);
      buffer.cmdBindViewport({0.0f, 0.0f, (float)shadowMapSize, (float)shadowMapSize, 0.0f, +1.0f});
      buffer.cmdBindScissorRect({0, 0, shadowMapSize, shadowMapSize});
      buffer.cmdPushDebugGroupLabel("Render Shadow", 0xff0000ff);
      buffer.cmdBindDepthState({.compareOp = lvk::CompareOp_Less, .isDepthWriteEnabled = true});
      drawMesh(bufPerFrameShadow);
      buffer.cmdPopDebugGroupLabel();
    }
    buffer.cmdEndRendering();
    // 2. Render scene
    const lvk::Framebuffer framebuffer = {
        .color = {{.texture = ctx->getCurrentSwapchainTexture()}},
        .depthStencil = {app.getDepthTexture()},
    };
    buffer.cmdBeginRendering(
        lvk::RenderPass{
            .color = {{.loadOp = lvk::LoadOp_Clear, .storeOp = lvk::StoreOp_Store, .clearColor = {1.0f, 1.0f, 1.0f, 1.0f}}},
            .depth = {.loadOp = lvk::LoadOp_Clear, .clearDepth = 1.0},
        },
        framebuffer,
        {
            .textures = {lvk::TextureHandle(shadowMap)},
        });
    {
      buffer.cmdBindRenderPipeline(renderPipelineState_Mesh_);
      buffer.cmdBindViewport({0.0f, 0.0f, (float)width, (float)height, 0.0f, +1.0f});
      buffer.cmdBindScissorRect({0, 0, (uint32_t)width, (uint32_t)height});
      buffer.cmdPushDebugGroupLabel("Render Mesh", 0xff0000ff);
      buffer.cmdBindDepthState({.compareOp = lvk::CompareOp_Less, .isDepthWriteEnabled = true});
      drawMesh(bufPerFrame);
      buffer.cmdPopDebugGroupLabel();
    }
    app.imgui_->beginFrame(framebuffer);
    ImGui::SetNextWindowPos({0, 0});
    ImGui::Begin("Keyboard hints:", nullptr, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoNavInputs);
    ImGui::Text("W/S/A/D - camera movement");
    ImGui::Text("1/2 - camera up/down");
    ImGui::Text("Shift - fast movement");
    const float h = ImGui::GetWindowHeight();
    const ImVec2 pos = ImGui::GetWindowPos();
    ImGui::End();
    ImGui::SetNextWindowPos({0, pos.y + h});
    ImGui::SetNextWindowCollapsed(true, ImGuiCond_Once);
    ImGui::Begin("Texture Viewer", nullptr, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoNavInputs);
    for (uint32_t l = 0; l != LVK_ARRAY_NUM_ELEMENTS(layers); l++) {
      ImGui::Image(layers[l].index(), ImVec2(256, 256));
    }
    ImGui::End();
    app.drawFPS();
    app.imgui_->endFrame(buffer);
    buffer.cmdEndRendering();

    ctx->submit(buffer, ctx->getCurrentSwapchainTexture());
  });

  VULKAN_APP_EXIT();
}

```

`samples/Bistro.h`:

```h
/*
 * LightweightVK
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/*
 Helper functions to load and cache Bistro/Sponza meshes:

   bool loadAndCache(const std::string& folderContentRoot, const char* cacheFileName, const char* modelFileName)
   bool loadFromCache(const char* cacheFileName)

 The result is stored in the global variables:

   std::vector<VertexData> vertexData_;
   std::vector<uint32_t> indexData_;
   std::vector<CachedMaterial> cachedMaterials_;
*/

#pragma once

#if !defined(_USE_MATH_DEFINES)
#define _USE_MATH_DEFINES
#endif // _USE_MATH_DEFINES
#include <cmath>

#include <filesystem>
#include <vector>

#define GLM_ENABLE_EXPERIMENTAL
#include <glm/ext.hpp>
#include <glm/glm.hpp>

#include <fast_obj.h>
#include <meshoptimizer.h>
#include <taskflow/taskflow.hpp>

#include <ldrutils/lutils/ScopeExit.h>
#include <lvk/LVK.h>

using glm::mat3;
using glm::mat4;
using glm::vec2;
using glm::vec3;
using glm::vec4;

constexpr uint32_t kMeshCacheVersion = 0xC0DE000A;

#define MAX_MATERIAL_NAME 128

struct VertexData {
  vec3 position;
  uint32_t uv; // hvec2
  uint16_t normal; // Octahedral 16-bit https://www.shadertoy.com/view/llfcRl
  uint16_t mtlIndex;
};

static_assert(sizeof(VertexData) == 5 * sizeof(uint32_t));

std::vector<VertexData> vertexData_;
std::vector<uint32_t> indexData_;

struct CachedMaterial {
  char name[MAX_MATERIAL_NAME] = {};
  vec3 ambient = vec3(0.0f);
  vec3 diffuse = vec3(0.0f);
  char ambient_texname[MAX_MATERIAL_NAME] = {};
  char diffuse_texname[MAX_MATERIAL_NAME] = {};
  char alpha_texname[MAX_MATERIAL_NAME] = {};
};

std::vector<CachedMaterial> cachedMaterials_;

vec2 msign(vec2 v) {
  return vec2(v.x >= 0.0 ? 1.0f : -1.0f, v.y >= 0.0 ? 1.0f : -1.0f);
}

// https://www.shadertoy.com/view/llfcRl
uint16_t packSnorm2x8(vec2 v) {
  glm::uvec2 d = glm::uvec2(round(127.5f + v * 127.5f));
  return d.x | (d.y << 8u);
}

// https://www.shadertoy.com/view/llfcRl
uint16_t packOctahedral16(vec3 n) {
  n /= (abs(n.x) + abs(n.y) + abs(n.z));
  return ::packSnorm2x8((n.z >= 0.0) ? vec2(n.x, n.y) : (vec2(1.0) - abs(vec2(n.y, n.x))) * msign(vec2(n)));
}

std::string normalizeTextureName(const char* n) {
  if (!n)
    return std::string();
  LVK_ASSERT(strlen(n) < MAX_MATERIAL_NAME);
  std::string name(n);
#if defined(__linux__) || defined(__APPLE__) || defined(ANDROID)
  std::replace(name.begin(), name.end(), '\\', '/');
#endif
  return name;
}

bool loadAndCache(const std::string& folderContentRoot, const char* cacheFileName, const char* modelFileName) {
  LVK_PROFILER_FUNCTION();

  // load 3D model and cache it
  LLOGL("Loading `%s`... It can take a while in debug builds...\n", modelFileName);

  fastObjMesh* mesh = fast_obj_read((folderContentRoot + modelFileName).c_str());
  SCOPE_EXIT {
    if (mesh)
      fast_obj_destroy(mesh);
  };

  if (!LVK_VERIFY(mesh)) {
    LLOGW("Failed to load '%s'", modelFileName);
    LVK_ASSERT_MSG(false, "Did you read the tutorial at the top of this file?");
    return false;
  }

  LLOGL("Loaded.\n");

  uint32_t vertexCount = 0;

  for (uint32_t i = 0; i < mesh->face_count; ++i)
    vertexCount += mesh->face_vertices[i];

  vertexData_.reserve(vertexCount);

  uint32_t vertexIndex = 0;

  for (uint32_t face = 0; face < mesh->face_count; face++) {
    for (uint32_t v = 0; v < mesh->face_vertices[face]; v++) {
      LVK_ASSERT(v < 3);
      const fastObjIndex gi = mesh->indices[vertexIndex++];

      const float* p = &mesh->positions[gi.p * 3];
      const float* n = &mesh->normals[gi.n * 3];
      const float* t = &mesh->texcoords[gi.t * 2];

      vertexData_.push_back({
          .position = vec3(p[0], p[1], p[2]),
          .uv = glm::packHalf2x16(vec2(t[0], t[1])),
          .normal = packOctahedral16(vec3(n[0], n[1], n[2])),
          .mtlIndex = (uint16_t)mesh->face_materials[face],
      });
    }
  }

  // repack the mesh as described in https://github.com/zeux/meshoptimizer
  {
    // 1. Generate an index buffer
    const size_t indexCount = vertexData_.size();
    std::vector<uint32_t> remap(indexCount);
    const size_t vertexCount =
        meshopt_generateVertexRemap(remap.data(), nullptr, indexCount, vertexData_.data(), indexCount, sizeof(VertexData));
    // 2. Remap vertices
    std::vector<VertexData> remappedVertices;
    indexData_.resize(indexCount);
    remappedVertices.resize(vertexCount);
    meshopt_remapIndexBuffer(indexData_.data(), nullptr, indexCount, &remap[0]);
    meshopt_remapVertexBuffer(remappedVertices.data(), vertexData_.data(), indexCount, sizeof(VertexData), remap.data());
    vertexData_ = remappedVertices;
    // 3. Optimize for the GPU vertex cache reuse and overdraw
    meshopt_optimizeVertexCache(indexData_.data(), indexData_.data(), indexCount, vertexCount);
    meshopt_optimizeOverdraw(
        indexData_.data(), indexData_.data(), indexCount, &vertexData_[0].position.x, vertexCount, sizeof(VertexData), 1.05f);
    meshopt_optimizeVertexFetch(vertexData_.data(), indexData_.data(), indexCount, vertexData_.data(), vertexCount, sizeof(VertexData));
  }

  // loop over materials
  for (uint32_t mtlIdx = 0; mtlIdx != mesh->material_count; mtlIdx++) {
    const fastObjMaterial& m = mesh->materials[mtlIdx];
    CachedMaterial mtl;
    mtl.ambient = vec3(m.Ka[0], m.Ka[1], m.Ka[2]);
    mtl.diffuse = vec3(m.Kd[0], m.Kd[1], m.Kd[2]);
    LVK_ASSERT(strlen(m.name) < MAX_MATERIAL_NAME);
    strcat(mtl.name, m.name);
    strcat(mtl.ambient_texname, normalizeTextureName(mesh->textures[m.map_Ka].name).c_str());
    strcat(mtl.diffuse_texname, normalizeTextureName(mesh->textures[m.map_Kd].name).c_str());
    strcat(mtl.alpha_texname, normalizeTextureName(mesh->textures[m.map_d].name).c_str());
    cachedMaterials_.push_back(mtl);
  }

  LLOGL("Caching mesh...\n");

  FILE* cacheFile = fopen(cacheFileName, "wb");
  if (!cacheFile) {
    return false;
  }
  const uint32_t numMaterials = (uint32_t)cachedMaterials_.size();
  const uint32_t numVertices = (uint32_t)vertexData_.size();
  const uint32_t numIndices = (uint32_t)indexData_.size();
  fwrite(&kMeshCacheVersion, sizeof(kMeshCacheVersion), 1, cacheFile);
  fwrite(&numMaterials, sizeof(numMaterials), 1, cacheFile);
  fwrite(&numVertices, sizeof(numVertices), 1, cacheFile);
  fwrite(&numIndices, sizeof(numIndices), 1, cacheFile);
  fwrite(cachedMaterials_.data(), sizeof(CachedMaterial), numMaterials, cacheFile);
  fwrite(vertexData_.data(), sizeof(VertexData), numVertices, cacheFile);
  fwrite(indexData_.data(), sizeof(uint32_t), numIndices, cacheFile);
  return fclose(cacheFile) == 0;
}

bool loadFromCache(const char* cacheFileName) {
  FILE* cacheFile = fopen(cacheFileName, "rb");
  SCOPE_EXIT {
    if (cacheFile) {
      fclose(cacheFile);
    }
  };
  if (!cacheFile) {
    return false;
  }
#define CHECK_READ(expected, read) \
  if ((read) != (expected)) {      \
    return false;                  \
  }
  uint32_t versionProbe = 0;
  CHECK_READ(1, fread(&versionProbe, sizeof(versionProbe), 1, cacheFile));
  if (versionProbe != kMeshCacheVersion) {
    LLOGL("Cache file has wrong version id\n");
    return false;
  }
  uint32_t numMaterials = 0;
  uint32_t numVertices = 0;
  uint32_t numIndices = 0;
  CHECK_READ(1, fread(&numMaterials, sizeof(numMaterials), 1, cacheFile));
  CHECK_READ(1, fread(&numVertices, sizeof(numVertices), 1, cacheFile));
  CHECK_READ(1, fread(&numIndices, sizeof(numIndices), 1, cacheFile));
  cachedMaterials_.resize(numMaterials);
  vertexData_.resize(numVertices);
  indexData_.resize(numIndices);
  CHECK_READ(numMaterials, fread(cachedMaterials_.data(), sizeof(CachedMaterial), numMaterials, cacheFile));
  CHECK_READ(numVertices, fread(vertexData_.data(), sizeof(VertexData), numVertices, cacheFile));
  CHECK_READ(numIndices, fread(indexData_.data(), sizeof(uint32_t), numIndices, cacheFile));
#undef CHECK_READ
  return true;
}

```

`samples/CMakeLists.txt`:

```txt
# Copyright (c) Meta Platforms, Inc. and affiliates.
#
# This source code is licensed under the MIT license found in the
# LICENSE file in the root directory of this source tree.

cmake_minimum_required(VERSION 3.22)

set(PROJECT_NAME "LVK Samples")

if(MSVC)
  add_definitions(-D_CONSOLE)
else()
  add_compile_options(-Wno-deprecated-volatile)
endif()

if(WIN32)
  add_definitions("-DVK_USE_PLATFORM_WIN32_KHR=1")
  add_definitions("-DNOMINMAX")
endif()

if(ANDROID)
  if(DEFINED ENV{ANDROID_NDK})
    cmake_path(SET NDK_PATH $ENV{ANDROID_NDK})
  else()
    cmake_path(SET NDK_PATH $ENV{NDK_ROOT})
  endif()
endif()

add_library(LVKVulkanApp
  VulkanApp.cpp
  VulkanApp.h
  "${LVK_ROOT_DIR}/third-party/deps/src/3D-Graphics-Rendering-Cookbook/shared/UtilsCubemap.cpp"
  "${LVK_ROOT_DIR}/third-party/deps/src/imgui/imgui_demo.cpp"
)
lvk_set_cxxstd(LVKVulkanApp 20)
lvk_set_folder(LVKVulkanApp "LVK")
target_link_libraries(LVKVulkanApp PUBLIC LVKLibrary)
target_link_libraries(LVKVulkanApp PUBLIC LVKstb)
target_link_libraries(LVKVulkanApp PUBLIC LUtils)
target_link_libraries(LVKVulkanApp PUBLIC ktx)
if(ANDROID)
  target_include_directories(LVKVulkanApp PUBLIC "${NDK_PATH}/sources/android/native_app_glue")
  target_link_libraries(LVKVulkanApp PUBLIC android)
endif()

macro(ADD_DEMO app) # optional arg `demo_has_slang`
  if(NOT ANDROID)
    add_executable(${app} "${app}.cpp")
    lvk_set_cxxstd(${app} 20)
    lvk_set_folder(${app} ${PROJECT_NAME})
    target_link_libraries(${app} PRIVATE LVKLibrary)
    target_link_libraries(${app} PRIVATE meshoptimizer)
    target_link_libraries(${app} PRIVATE fast_obj_lib)
    target_link_libraries(${app} PRIVATE LVKVulkanApp)

    # default value for the optional arg
    set(demo_has_slang FALSE)

    # check if a second arg was provided
    if(${ARGC} GREATER 1)
        set(demo_has_slang ${ARGV1})
    endif()

    if(LVK_WITH_SLANG AND demo_has_slang)
      add_executable(${app}_Slang "${app}.cpp")
      lvk_set_cxxstd(${app}_Slang 20)
      lvk_set_folder(${app}_Slang ${PROJECT_NAME})
      target_link_libraries(${app}_Slang PRIVATE LVKLibrary)
      target_link_libraries(${app}_Slang PRIVATE meshoptimizer)
      target_link_libraries(${app}_Slang PRIVATE fast_obj_lib)
      target_link_libraries(${app}_Slang PRIVATE LVKVulkanApp)
      target_compile_definitions(${app}_Slang PRIVATE "LVK_DEMO_WITH_SLANG=1")
    endif()
  endif()

  # Android
  if(LVK_WITH_SAMPLES_ANDROID)
    if((NOT DEFINED ENV{ANDROID_NDK}) AND (NOT DEFINED ENV{NDK_ROOT}))
      message(FATAL_ERROR "ANDROID_NDK (or NDK_ROOT) environment variable is not set")
    endif()

    # One CMakeLists file is used for generation Android Project and for building native library.
    # The native library is built only if ANDROID is defined, otherwise Android project is generated.
    if(NOT ANDROID)
      file(COPY "${LVK_ROOT_DIR}/android/build.gradle"
           DESTINATION "${CMAKE_BINARY_DIR}/android/${app}")
      file(COPY "${LVK_ROOT_DIR}/android/gradle.properties"
           DESTINATION "${CMAKE_BINARY_DIR}/android/${app}")
      file(COPY "${LVK_ROOT_DIR}/android/gradlew"
           DESTINATION "${CMAKE_BINARY_DIR}/android/${app}")
      file(COPY "${LVK_ROOT_DIR}/android/gradlew.bat"
           DESTINATION "${CMAKE_BINARY_DIR}/android/${app}")
      file(COPY "${LVK_ROOT_DIR}/android/gradle/wrapper/gradle-wrapper.jar"
           DESTINATION "${CMAKE_BINARY_DIR}/android/${app}/gradle/wrapper")
      file(COPY "${LVK_ROOT_DIR}/android/gradle/wrapper/gradle-wrapper.properties"
           DESTINATION "${CMAKE_BINARY_DIR}/android/${app}/gradle/wrapper")

      set(APP_NAME ${app})

      set(ABI_STRING "")
      foreach(str ${LVK_ANDROID_ABI})
        if(NOT ${ABI_STRING} STRLESS "")
          set(ABI_STRING "${ABI_STRING}, ")
        endif()
        set(ABI_STRING "${ABI_STRING}'${str}'")
      endforeach()
      set(ANDROID_ABI_FILTERS ${ABI_STRING})

      configure_file("${LVK_ROOT_DIR}/android/settings.gradle.in"
                     "${CMAKE_BINARY_DIR}/android/${app}/settings.gradle")
      configure_file("${LVK_ROOT_DIR}/android/app/build.gradle.in"
                     "${CMAKE_BINARY_DIR}/android/${app}/app/build.gradle")
      configure_file("${LVK_ROOT_DIR}/android/app/AndroidManifest.xml.in"
                     "${CMAKE_BINARY_DIR}/android/${app}/app/src/main/AndroidManifest.xml")
      configure_file("${LVK_ROOT_DIR}/android/app/data_extraction_rules.xml.in"
                     "${CMAKE_BINARY_DIR}/android/${app}/app/src/main/res/xml/data_extraction_rules.xml")
      configure_file("${LVK_ROOT_DIR}/android/app/MainActivity.java.in"
                     "${CMAKE_BINARY_DIR}/android/${app}/app/src/main/java/org/lvk/samples/MainActivity.java")

      if(LVK_WITH_ANDROID_VALIDATION)
        list(APPEND abdroid_abi arm64-v8a armeabi-v7a x86 x86_64)
        foreach(abi ${abdroid_abi})
          string(FIND ${ABI_STRING} "${abi}" abi_substr_index)
          if(abi_substr_index GREATER -1)
            file(COPY "${LVK_ROOT_DIR}/third-party/deps/src/android-validation-layers/${abi}/libVkLayer_khronos_validation.so"
                 DESTINATION "${CMAKE_BINARY_DIR}/android/${app}/app/src/main/jniLibs/${abi}")
          endif()
        endforeach()
      endif()
    endif()

    if(ANDROID)
      add_library(lvk_android_native_${app} SHARED
                  "${app}.cpp"
                  "${NDK_PATH}/sources/android/native_app_glue/android_native_app_glue.c")
      lvk_set_cxxstd(lvk_android_native_${app} 20)
      target_link_libraries(lvk_android_native_${app} PUBLIC
                            LVKVulkanApp LVKLibrary LVKVulkan LVKstb meshoptimizer fast_obj_lib)
    endif()
  endif()
endmacro()

macro(ADD_DEMO_SOURCES app srcs)
  if(ANDROID)
    target_sources(lvk_android_native_${app} PRIVATE ${srcs})
  else()
    target_sources(${app} PRIVATE ${srcs})
  endif()
endmacro()

macro(ADD_DEMO_LINK_LIBRARIES app libs)
  if(ANDROID)
    target_link_libraries(lvk_android_native_${app} PRIVATE ${libs})
  else()
    target_link_libraries(${app} PRIVATE ${libs})
  endif()
endmacro()

ADD_DEMO("001_HelloTriangle" LVK_WITH_SLANG)
ADD_DEMO("002_RenderToCubeMap" LVK_WITH_SLANG)
ADD_DEMO("003_RenderToCubeMapSinglePass" LVK_WITH_SLANG)
ADD_DEMO("004_YUV" LVK_WITH_SLANG)
if(WIN32 OR UNIX AND NOT (APPLE))
  # Windows and Linux
  ADD_DEMO("005_MeshShaders" LVK_WITH_SLANG)
  ADD_DEMO("008_MeshShaderFireworks" LVK_WITH_SLANG)
endif()
ADD_DEMO("006_SwapchainHDR" LVK_WITH_SLANG)
ADD_DEMO("007_DynamicRenderingLocalRead" LVK_WITH_SLANG)
ADD_DEMO("009_TriplanarMapping" LVK_WITH_SLANG)
ADD_DEMO("010_OmniShadows" LVK_WITH_SLANG)
if((WIN32 OR UNIX AND NOT (APPLE)) OR LVK_WITH_SAMPLES_ANDROID)
  # Windows, Linux and Android
  ADD_DEMO("RTX_001_Hello" LVK_WITH_SLANG)
  ADD_DEMO("RTX_002_AO" LVK_WITH_SLANG)
  ADD_DEMO("RTX_003_Pipeline" LVK_WITH_SLANG)
  ADD_DEMO("RTX_004_Textures" LVK_WITH_SLANG)
endif()

ADD_DEMO("DEMO_001_SolarSystem")
ADD_DEMO("Tiny_MeshLarge" LVK_WITH_SLANG)

```

`samples/DEMO_001_SolarSystem.cpp`:

```cpp
/*
 * LightweightVK
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#include <filesystem>

#include "VulkanApp.h"

#include "lvk/vulkan/VulkanUtils.h"

#include "ldrutils/lmath/GeometryShapes.h"
#include <ldrutils/lutils/ScopeExit.h>

#include <shared/UtilsCubemap.h>

#include <fast_obj.h>
#include <stb_image.h>

#include <ktx-software/lib/src/gl_format.h>
#include <ktx-software/lib/src/vkformat_enum.h>
#include <ktx.h>

const size_t numAsteroidsInner = 1500;
const size_t numAsteroidsOuter = 500;

bool g_Paused = false;
bool g_Wireframe = false;
bool g_DrawPlanetOrbits = true;
bool g_MultiViewStereo = false;
bool g_UseTrackball = false;

float IoD = 0.01f; // adjustable interocular distance

VirtualTrackball g_Trackball;

struct Planet {
  float radius;
  float orbitalRadius;
  float globalOrbitalSpeed;
  float localOrbitalSpeed;
  float axialTilt;
  float orbitalInclination;
  const char* textureName;
};

// overall scale of the planetary system
const float g_Scale = 0.001f;

const std::vector<Planet> planets = {
    {1.5f * g_Scale * 110.f, g_Scale * 000, 0.000f, 0.000f, 0.00f, 0.00f, "2k_sun.jpg"},
    {1.5f * g_Scale * 34.5f, g_Scale * 250, 0.650f, 0.650f, 0.03f, 7.01f, "2k_mercury.jpg"},
    {1.5f * g_Scale * 54.3f, g_Scale * 420, 1.969f, 1.969f, 2.64f, 3.39f, "2k_venus_surface.jpg"},
    {1.5f * g_Scale * 44.5f, g_Scale * 600, 0.881f, 0.881f, 23.44f, 0.00f, "2k_earth_daymap.jpg"},
    {1.5f * g_Scale * 36.5f, g_Scale * 800, 1.543f, 1.543f, 25.19f, 1.85f, "2k_mars.jpg"},
    {1.5f * g_Scale * 67.3f, g_Scale * 1350, 2.978f, 2.978f, 3.13f, 1.31f, "2k_jupiter.jpg"},
    {1.5f * g_Scale * 56.1f, g_Scale * 1650, 0.800f, 0.800f, 26.73f, 2.49f, "2k_saturn.jpg"},
    {1.5f * g_Scale * 55.3f, g_Scale * 2000, 0.607f, 0.607f, 82.23f, 0.77f, "2k_uranus.jpg"},
    {1.5f * g_Scale * 54.4f, g_Scale * 2200, 1.700f, 1.700f, 28.32f, 1.77f, "2k_neptune.jpg"},
    {2.0f * g_Scale * 12.5f, g_Scale * 100.0f, 2.843f, 2.843f * 10.0f, 6.68f, 0.0f, "2k_moon.jpg"},
};

enum { Sun, Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune, Moon, TotalPlanets };

const char* codeDefaultVS = R"(
#extension GL_EXT_multiview : enable

layout (location=0) in vec4 in_Vertex;
layout (location=1) in vec2 in_TexCoord;
layout (location=2) in vec3 in_Normal;

layout(std430, buffer_reference) readonly buffer PerFrame {
  mat4 proj[2];
  mat4 view[2];
};

layout(std430, buffer_reference) readonly buffer Matrices {
  mat4 m[];
};

struct DrawData {
  uint idMatrix;
  uint idMaterial;
};

layout(std430, buffer_reference) readonly buffer BufDrawData {
  DrawData dd[];
};

layout(push_constant) uniform constants {
  Matrices      bufModelMatrices;
  Matrices      bufNormalMatrices;
  PerFrame      bufPerFrame;
  BufDrawData   bufDrawData;
};

layout (location=0) out vec2 v_TexCoord;
layout (location=1) out vec3 v_WorldPos;
layout (location=2) out vec3 v_WorldNormal;
layout (location=3) flat out uint v_MaterialIndex;

void main() {
  mat4 model  = bufModelMatrices .m[bufDrawData.dd[gl_InstanceIndex].idMatrix];
  mat4 normal = bufNormalMatrices.m[bufDrawData.dd[gl_InstanceIndex].idMatrix];

  v_WorldPos = (model * in_Vertex).xyz;
  v_WorldNormal = mat3(normal) * in_Normal;

  gl_Position = bufPerFrame.proj[gl_ViewIndex] *
                bufPerFrame.view[gl_ViewIndex] *
                model * in_Vertex;

  v_TexCoord  = in_TexCoord;
  v_MaterialIndex = bufDrawData.dd[gl_InstanceIndex].idMaterial;
}
)";

const char* codeDefaultFS = R"(
layout (location=0) in vec2 v_TexCoord;
layout (location=1) in vec3 v_WorldPos;
layout (location=2) in vec3 v_WorldNormal;
layout (location=3) flat in uint v_MaterialIndex;

struct Material {
  vec4 emissive;
  vec4 diffuse; // w - two-sided
  uint texEmissive;
  uint texDiffuse;
  uint padding[2];
};

layout(std430, buffer_reference) readonly buffer Materials {
  Material m[];
};

layout(push_constant) uniform constants {
  vec2      bufModelMatrices;
  vec2      bufNormalMatrices;
  vec2      bufPerFrame;
  vec2      bufDrawData;
  Materials bufMaterials;
};

layout (location=0) out vec4 out_FragColor;

float getDiffuseFactor(vec3 toLight, vec3 normal) {
  float d = dot(toLight, normal);

  bool twoSided = bufMaterials.m[v_MaterialIndex].diffuse.w > 0.5;

  return clamp( twoSided ? max(d, -d) : d, 0.0, 1.0);
}

float pointLight(vec3 lightPos, float lightRadius) {
  vec3 toLight = lightPos - v_WorldPos.xyz;

  float distanceToLight = length(toLight);
  // inspired by https://lisyarus.github.io/blog/posts/point-light-attenuation.html
  float s = distanceToLight / lightRadius;
  float attenuation = max(1.0 - s*s, 0.0);

  return attenuation * getDiffuseFactor(normalize(toLight), normalize(v_WorldNormal));
}

void main() {
  Material m = bufMaterials.m[v_MaterialIndex];

  vec4 Ke = m.emissive * textureBindless2D(m.texEmissive, 0, v_TexCoord);
  vec4 Kd = m.diffuse  * textureBindless2D(m.texDiffuse,  0, v_TexCoord);

  const vec3  lightPos    = vec3(0.0);
  const vec4  lightColor  = vec4(1.0);
  const float lightRadius = 10.0;

  out_FragColor = Ke + Kd * lightColor * pointLight(lightPos, lightRadius);
  out_FragColor.a = Ke.a;
}
)";

const char* codeOrbitVS = R"(
#extension GL_EXT_multiview : enable

layout (location=0) in vec4 in_Vertex;

layout(std430, buffer_reference) readonly buffer PerFrame {
  mat4 proj[2];
  mat4 view[2];
};

layout(std430, buffer_reference) readonly buffer Matrices {
  mat4 m[];
};

struct DrawData {
  uint idMatrix;
  uint idMaterial;
};

layout(std430, buffer_reference) readonly buffer BufDrawData {
  DrawData dd[];
};

layout(push_constant) uniform constants {
  Matrices      bufModelMatrices;
  Matrices      bufNormalMatrices;
  PerFrame      bufPerFrame;
  BufDrawData   bufDrawData;
};

void main() {
  gl_Position = bufPerFrame.proj[gl_ViewIndex] *
                bufPerFrame.view[gl_ViewIndex] *
                bufModelMatrices.m[bufDrawData.dd[gl_InstanceIndex].idMatrix] * in_Vertex;
}
)";

const char* codeOrbitFS = R"(
layout (location=0) out vec4 out_FragColor;

void main() {
  out_FragColor = vec4(1.0, 1.0, 1.0, 0.2);
}
)";

const char* codeSunVS = R"(
#extension GL_EXT_multiview : enable

layout (location=0) in vec4 in_Vertex;
layout (location=1) in vec2 in_TexCoord;
layout (location=2) in vec3 in_Normal;

layout(std430, buffer_reference) readonly buffer PerFrame {
  mat4 proj[2];
  mat4 view[2];
  float u_Time;
};

struct Material {
  vec4 emissive;
  vec4 diffuse; // w - two-sided
  uint texEmissive;
  uint texDiffuse;
  uint padding[2];
};

layout(std430, buffer_reference) readonly buffer Materials {
  Material m[];
};

layout(std430, buffer_reference) readonly buffer Matrices {
  mat4 m[];
};

struct DrawData {
  uint idMatrix;
  uint idMaterial;
};

layout(std430, buffer_reference) readonly buffer BufDrawData {
  DrawData dd[];
};

layout(push_constant) uniform constants {
  Matrices      bufModelMatrices;
  Matrices      bufNormalMatrices;
  PerFrame      bufPerFrame;
  BufDrawData   bufDrawData;
  Materials     bufMaterials;
};

layout (location=0) out vec2 v_TexCoord;
layout (location=1) out float v_Time;
layout (location=2) flat out uint v_Texture0;
layout (location=3) flat out uint v_Texture1;

void main() {
  gl_Position = bufPerFrame.proj[gl_ViewIndex] *
                bufPerFrame.view[gl_ViewIndex] *
                bufModelMatrices.m[bufDrawData.dd[gl_InstanceIndex].idMatrix] * in_Vertex;

  v_TexCoord = in_TexCoord;
  v_Time     = bufPerFrame.u_Time;
  v_Texture0 = bufMaterials.m[bufDrawData.dd[gl_InstanceIndex].idMatrix].texEmissive;
  v_Texture1 = bufMaterials.m[bufDrawData.dd[gl_InstanceIndex].idMatrix].texDiffuse;
}
)";

const char* codeSunFS = R"(
layout (location=0) in vec2  v_TexCoord;
layout (location=1) in float v_Time;
layout (location=2) flat in uint v_Texture0;
layout (location=3) flat in uint v_Texture1;

layout (location=0) out vec4 out_FragColor;

void main() {
  vec2 t = cos(0.05 * vec2(v_Time));

  vec3 K1 = textureBindless2D(v_Texture0, 0, sin(v_TexCoord + t)).rgb;
  vec3 K2 = textureBindless2D(v_Texture1, 0, v_TexCoord - 2.0 * t).rgb;

  out_FragColor = vec4(K1*K2, 1.0);
}
)";

const char* codeSunCoronaVS = R"(
#extension GL_EXT_multiview : enable

layout (location=0) in vec4 in_Vertex;
layout (location=1) in vec2 in_TexCoord;
layout (location=2) in vec3 in_Normal;

layout(std430, buffer_reference) readonly buffer PerFrame {
  mat4 proj[2];
  mat4 view[2];
};

struct Material {
  vec4 emissive;
  vec4 diffuse; // w - two-sided
  uint texEmissive;
  uint texDiffuse;
  uint padding[2];
};

layout(std430, buffer_reference) readonly buffer Materials {
  Material m[];
};

layout(std430, buffer_reference) readonly buffer Matrices {
  mat4 m[];
};

struct DrawData {
  uint idMatrix;
  uint idMaterial;
};

layout(std430, buffer_reference) readonly buffer BufDrawData {
  DrawData dd[];
};

layout(push_constant) uniform constants {
  Matrices      bufModelMatrices;
  Matrices      bufNormalMatrices;
  PerFrame      bufPerFrame;
  BufDrawData   bufDrawData;
  Materials     bufMaterials;
};

layout (location=0) out vec2 v_TexCoord;
layout (location=1) flat out uint v_Texture0;

vec3 getBillboardOffset(mat4 mv, vec2 uv, vec2 sizeXY) {
  // check out http://www.geeks3d.com/20140807/billboarding-vertex-shader-glsl/
  vec3 x = vec3(mv[0][0], mv[1][0], mv[2][0]);
  vec3 y = vec3(mv[0][1], mv[1][1], mv[2][1]);

  vec2 coef = vec2(2.0) * (uv - vec2(0.5)) * sizeXY;

  return coef.x * x + coef.y * y;
}

void main() {
  mat4 mv = bufPerFrame.view[gl_ViewIndex] *
            bufModelMatrices.m[bufDrawData.dd[gl_InstanceIndex].idMatrix];
  vec3 v  = getBillboardOffset(mv, in_TexCoord, vec2(0.28, 0.28));

  gl_Position = bufPerFrame.proj[gl_ViewIndex] * mv * vec4(v, 1.0);

  v_TexCoord = in_TexCoord;
  v_Texture0 = bufMaterials.m[bufDrawData.dd[gl_InstanceIndex].idMatrix].texEmissive;
}
)";

const char* codeSunCoronaFS = R"(
layout (location=0) in vec2 v_TexCoord;
layout (location=1) flat in uint v_Texture0;

layout (location=0) out vec4 out_FragColor;

void main() {
  vec4 K1 = textureBindless2D(v_Texture0, 0, v_TexCoord);

  K1.a = dot( K1.xyz, vec3(0.333, 0.333, 0.333) );

  out_FragColor = K1;
}
)";

const char* codeSkyBoxVS = R"(
#extension GL_EXT_multiview : enable

layout(std430, buffer_reference) readonly buffer PerFrame {
  mat4 proj[2];
  mat4 view[2];
};

layout(push_constant) uniform PushConstants {
  PerFrame bufPerFrame;
  uint texSkyBox;
};

layout (location=0) out vec3 v_Dir;
layout (location=1) flat out uint v_TextureSkybox;

const vec3 pos[8] = vec3[8](
  vec3(-1.0,-1.0, 1.0),
  vec3( 1.0,-1.0, 1.0),
  vec3( 1.0, 1.0, 1.0),
  vec3(-1.0, 1.0, 1.0),

  vec3(-1.0,-1.0,-1.0),
  vec3( 1.0,-1.0,-1.0),
  vec3( 1.0, 1.0,-1.0),
  vec3(-1.0, 1.0,-1.0)
);

const int indices[36] = int[36](
  0, 1, 2, 2, 3, 0,	// front
  1, 5, 6, 6, 2, 1,	// right
  7, 6, 5, 5, 4, 7,	// back
  4, 0, 3, 3, 7, 4,	// left
  4, 5, 1, 1, 0, 4,	// bottom
  3, 2, 6, 6, 7, 3	// top
);

void main() {
  int idx = indices[gl_VertexIndex];
  gl_Position = bufPerFrame.proj[gl_ViewIndex] *
                mat4(mat3(bufPerFrame.view[gl_ViewIndex])) * vec4(50.0 * pos[idx], 1.0);
  v_Dir = pos[idx].zxy; // rotate the sky box
  v_TextureSkybox = texSkyBox;
}
)";

const char* codeSkyBoxFS = R"(
layout (location=0) in vec3 v_Dir;
layout (location=1) flat in uint v_TextureSkybox;

layout (location=0) out vec4 out_FragColor;

void main() {
  out_FragColor = pow(textureBindlessCube(v_TextureSkybox, 0, v_Dir), vec4(1.5));
};
)";

struct SceneNode final {
  SceneNode* parent = nullptr;
  mat4 local = mat4(1.0f);
  mat4 global = mat4(1.0f);
  int materialIdx = -1;
  std::vector<std::shared_ptr<SceneNode>> childNodes_;

  int getMaterialIndexOrParent() const {
    if (materialIdx >= 0)
      return materialIdx;
    assert(parent);
    return parent ? parent->getMaterialIndexOrParent() : -1;
  }

  SceneNode* createNode(const mat4& m = mat4(1)) {
    childNodes_.push_back(std::make_shared<SceneNode>(SceneNode{this, m}));
    return childNodes_.back().get();
  }

  void updateGlobalFromLocal(const mat4& parentTransform) {
    global = parentTransform * local;

    for (auto& i : childNodes_)
      i->updateGlobalFromLocal(global);
  }
};

struct OrbitAnimator final {
  OrbitAnimator(const vec3& axis, const float angle, const float speed, float radius = 0.0f)
  : rotationAxis(axis)
  , normalizedRotationAxis(glm::normalize(axis))
  , orbitalRadius(radius)
  , rotationSpeed(speed)
  , rotationAngle(angle) {}

  void update(float deltaSeconds) {
    rotationAngle = fmodf(rotationAngle + rotationSpeed * deltaSeconds, 360.0f);
    transform = glm::rotate(mat4(1.0f), glm::radians(rotationAngle), normalizedRotationAxis);
  }

  const vec3 rotationAxis = vec3(0.0f);
  const vec3 normalizedRotationAxis = glm::normalize(vec3(1.0f));
  const float orbitalRadius = 0.0f;
  const float rotationSpeed = 0.0f;
  float rotationAngle = 0.0f;
  mat4 transform = mat4(1.0f);
};

struct OrbitAnimationGroup final {
  SceneNode* targetNode = nullptr;
  std::vector<OrbitAnimator> animationGroup_;

  void update(float deltaSeconds) {
    mat4 transform = mat4(1.0f);

    for (OrbitAnimator& anim : animationGroup_) {
      anim.update(deltaSeconds);
      const bool applyTranslation = (anim.orbitalRadius != 0.0f) ? true : false;
      const mat4 translation = applyTranslation ? glm::translate(mat4(1.0f), vec3(0.0f, anim.orbitalRadius, 0.0f)) : mat4(1.0f);
      transform = translation * anim.transform * transform;
    }

    targetNode->local = transform;
  }
};

// shared mesh
struct Mesh final {
  std::vector<GeometryShapes::Vertex> vertices;
  int firstVertex = -1; // the first vertex in the global vertex buffer
};

// unique mesh instance
struct MeshComponent final {
  SceneNode* sceneNode = nullptr;
  std::shared_ptr<Mesh> mesh;
};

struct PerFrameBuffer final {
  mat4 proj[2] = {};
  mat4 view[2] = {};
  float time = 0.0f;
};

struct Material final {
  vec4 emissive = vec4(0.2f, 0.2f, 0.2f, 1.0f);
  vec4 diffuse = vec4(0.8f, 0.8f, 0.8f, 1.0f);
  lvk::TextureHandle texEmissive;
  lvk::TextureHandle texDiffuse;
  bool isTransparent = false;
  bool twoSided = false;
  lvk::RenderPipelineHandle pipeline;
  lvk::RenderPipelineHandle pipelineW;
};

struct Scene final {
  Scene() = default;
  Scene(Scene&) = delete;
  Scene(Scene&&) = default;
  Scene& operator=(Scene&) = delete;
  Scene& operator=(Scene&&) = default;

  std::vector<MeshComponent> meshes;
  std::vector<Material> materials;
  std::vector<OrbitAnimationGroup> animators;
  SceneNode root = SceneNode{nullptr, mat4(1.0f)};

  void updateAnimations(float deltaSeconds) {
    for (OrbitAnimationGroup& animator : animators) {
      animator.update(deltaSeconds);
    }
  }

  void createMesh(SceneNode* node, const std::shared_ptr<Mesh> mesh) {
    meshes.push_back(MeshComponent{node, mesh});
  }

  void createMaterial(SceneNode* node, const Material& mat) {
    materials.emplace_back(mat);
    node->materialIdx = (int)materials.size() - 1;
  }
};

struct ShaderModules final {
  lvk::ShaderModuleHandle vert;
  lvk::ShaderModuleHandle frag;
};

struct DrawData final {
  uint32_t idMatrix = 0;
  uint32_t idMaterial = 0;
};

struct VulkanState final {
  std::unordered_map<std::string, lvk::Holder<lvk::TextureHandle>> textures;
  std::vector<lvk::Holder<lvk::ShaderModuleHandle>> shaderModules;
  lvk::Holder<lvk::BufferHandle> bufPerFrame;
  std::vector<lvk::Holder<lvk::BufferHandle>> bufModelMatrices;
  std::vector<lvk::Holder<lvk::BufferHandle>> bufNormalMatrices;
  lvk::Holder<lvk::BufferHandle> bufMaterials;
  lvk::Holder<lvk::BufferHandle> bufVertices; // one large vertex buffer for everything
  lvk::Holder<lvk::BufferHandle> bufDrawData;
  lvk::Holder<lvk::RenderPipelineHandle> materialDefault;
  lvk::Holder<lvk::RenderPipelineHandle> materialDefaultW;
  lvk::Holder<lvk::RenderPipelineHandle> materialSaturnRings;
  lvk::Holder<lvk::RenderPipelineHandle> materialOrbit;
  lvk::Holder<lvk::RenderPipelineHandle> materialSun;
  lvk::Holder<lvk::RenderPipelineHandle> materialSunW;
  lvk::Holder<lvk::RenderPipelineHandle> materialSunCorona;
  lvk::Holder<lvk::RenderPipelineHandle> materialSkyBox;
  std::vector<lvk::Holder<lvk::TextureHandle>> texColor;
  lvk::Holder<lvk::TextureHandle> texDepth;
  lvk::Holder<lvk::TextureHandle> texSkyBox;
} vulkanState;

void convertEquirectangularMapToKTX(const std::string& inFilename, const std::string& outFilename) {
  int sourceWidth, sourceHeight;
  uint8_t* pixels = stbi_load(inFilename.c_str(), &sourceWidth, &sourceHeight, nullptr, 4);
  SCOPE_EXIT {
    if (pixels) {
      stbi_image_free(pixels);
    }
  };

  if (!pixels) {
    LVK_ASSERT_MSG(pixels, "Failed to load texture `%s`\n", inFilename.c_str());
    return;
  }

  Bitmap bmp = convertEquirectangularMapToCubeMapFaces(Bitmap(sourceWidth, sourceHeight, 4, eBitmapFormat_UnsignedByte, pixels));

  const uint32_t w = static_cast<uint32_t>(bmp.w_);
  const uint32_t h = static_cast<uint32_t>(bmp.h_);

  const ktxTextureCreateInfo createInfo = {
      .glInternalformat = GL_RGBA8,
      .vkFormat = VK_FORMAT_R8G8B8A8_UNORM,
      .baseWidth = w,
      .baseHeight = h,
      .baseDepth = 1u,
      .numDimensions = 2u,
      .numLevels = 1u,
      .numLayers = 1u,
      .numFaces = 6u,
      .generateMipmaps = KTX_FALSE,
  };

  ktxTexture1* cube = nullptr;
  (void)LVK_VERIFY(ktxTexture1_Create(&createInfo, KTX_TEXTURE_CREATE_ALLOC_STORAGE, &cube) == KTX_SUCCESS);

  const uint32_t faceSizeBytes = w * h * sizeof(uint32_t);

  for (size_t face = 0; face != 6; face++) {
    size_t offset = 0;
    (void)LVK_VERIFY(ktxTexture_GetImageOffset(ktxTexture(cube), 0, 0, face, &offset) == KTX_SUCCESS);
    memcpy(cube->pData + offset, bmp.data_.data() + face * faceSizeBytes, faceSizeBytes);
  }

  ktxTexture_WriteToNamedFile(ktxTexture(cube), outFilename.c_str());
  ktxTexture_Destroy(ktxTexture(cube));
}

lvk::Holder<lvk::TextureHandle> loadTextureCubeFromFile(VulkanApp& app, const std::string& fileName) {
  const std::string name = (std::filesystem::path(app.folderContentRoot_) / "src/solarsystem" / fileName).string();
  const std::string fileNameKTX = name + ".ktx";

  if (!std::filesystem::exists(fileNameKTX)) {
    LLOGL("KTX cube map format not found.\nExtracting from `%s`...\n", name.c_str());
    convertEquirectangularMapToKTX(name.c_str(), fileNameKTX);
  }

  ktxTexture1* texture = nullptr;
  (void)LVK_VERIFY(ktxTexture1_CreateFromNamedFile(fileNameKTX.c_str(), KTX_TEXTURE_CREATE_LOAD_IMAGE_DATA_BIT, &texture) == KTX_SUCCESS);
  SCOPE_EXIT {
    ktxTexture_Destroy(ktxTexture(texture));
  };

  if (!LVK_VERIFY(texture->glInternalformat == GL_RGBA8)) {
    LVK_ASSERT_MSG(false, "Texture format not supported");
    return {};
  }

  const uint32_t width = texture->baseWidth;
  const uint32_t height = texture->baseHeight;

  lvk::Holder<lvk::TextureHandle> tex = app.ctx_->createTexture({
      .type = lvk::TextureType_Cube,
      .format = lvk::Format_RGBA_UN8,
      .dimensions = {width, height},
      .usage = lvk::TextureUsageBits_Sampled,
      .numMipLevels = lvk::calcNumMipLevels(width, height),
      .data = texture->pData,
      .generateMipmaps = true,
      .debugName = fileName.c_str(),
  });

  return std::move(tex);
}

lvk::TextureHandle loadTextureFromFile(VulkanApp& app, const std::string& fileName) {
  auto it = vulkanState.textures.find(fileName);

  if (it != vulkanState.textures.end()) {
    return it->second;
  }

  const std::string name = (std::filesystem::path(app.folderContentRoot_) / "src/solarsystem" / fileName).string();

  int w = 0;
  int h = 0;
  int numComponents = 0;

  stbi_set_flip_vertically_on_load(0);
  void* pixels = stbi_load(name.c_str(), &w, &h, &numComponents, 4);

  if (!pixels) {
    LLOGL("Failed to load texture `%s`\n", name.c_str());
    assert(pixels);
    return {};
  }

  SCOPE_EXIT {
    stbi_image_free(pixels);
  };

  lvk::Holder<lvk::TextureHandle> tex = app.ctx_->createTexture({
      .type = lvk::TextureType_2D,
      .format = lvk::Format_RGBA_UN8,
      .dimensions = {uint32_t(w), uint32_t(h)},
      .usage = lvk::TextureUsageBits_Sampled,
      .data = pixels,
      .debugName = fileName.c_str(),
  });

  lvk::TextureHandle handle = tex;

  // ownership
  vulkanState.textures[fileName] = std::move(tex);

  return handle;
}

ShaderModules loadShaderProgram(lvk::IContext* ctx, const char* codeVS, const char* codeFS) {
  lvk::Holder<lvk::ShaderModuleHandle> vert = ctx->createShaderModule({codeVS, lvk::Stage_Vert, "Shader Module: vert"});
  lvk::Holder<lvk::ShaderModuleHandle> frag = ctx->createShaderModule({codeFS, lvk::Stage_Frag, "Shader Module: frag"});

  const ShaderModules sm = {vert, frag};

  // ownership
  vulkanState.shaderModules.emplace_back(std::move(vert));
  vulkanState.shaderModules.emplace_back(std::move(frag));

  return sm;
}

std::vector<GeometryShapes::Vertex> loadMeshFromFile(VulkanApp& app, const char* fileName) {
  fastObjMesh* mesh = fast_obj_read((std::filesystem::path(app.folderContentRoot_) / "src/solarsystem" / fileName).string().c_str());

  SCOPE_EXIT {
    if (mesh)
      fast_obj_destroy(mesh);
  };

  uint32_t vertexCount = 0;

  for (uint32_t i = 0; i < mesh->face_count; ++i)
    vertexCount += mesh->face_vertices[i];

  std::vector<GeometryShapes::Vertex> result;
  result.reserve(vertexCount);

  uint32_t vertexIndex = 0;

  for (uint32_t face = 0; face < mesh->face_count; face++) {
    for (uint32_t v = 0; v < mesh->face_vertices[face]; v++) {
      const fastObjIndex gi = mesh->indices[vertexIndex++];

      const float* p = &mesh->positions[gi.p * 3];
      const float* n = &mesh->normals[gi.n * 3];
      const float* t = &mesh->texcoords[gi.t * 2];

      result.emplace_back(GeometryShapes::Vertex{
          .pos = vec3(p[0], p[1], p[2]),
          .uv = vec2(t[0], t[1]),
          .normal = vec3(n[0], n[1], n[2]),
      });
    }
  }

  return result;
}

Scene createSolarSystemScene(VulkanApp& app) {
  const vec3 X = vec3(1.0f, 0.0f, 0.0f);
  const vec3 Z = vec3(0.0f, 0.0f, 1.0f);

  lvk::IContext* ctx = app.ctx_.get();

#if !defined(ANDROID)
  app.addKeyCallback([](GLFWwindow* window, int key, int, int action, int) {
    if (key == GLFW_KEY_X && action == GLFW_PRESS) {
      g_Wireframe = !g_Wireframe;
    } else if (key == GLFW_KEY_P && action == GLFW_PRESS) {
      g_Paused = !g_Paused;
    }
  });
#endif // !ANDROID

  Scene scene;

  SceneNode* allPlanets[TotalPlanets];

  // attach the Sun to the root node
  allPlanets[Sun] = scene.root.createNode();

  // create all planets
  for (size_t i = 0; i < planets.size(); i++) {
    const Material planetMaterial = {
        .emissive = vec4(.5f, .5f, .5f, 1.0f),
        .diffuse = vec4(0.8f),
        .texEmissive = loadTextureFromFile(app, planets[i].textureName),
        .texDiffuse = loadTextureFromFile(app, planets[i].textureName),
        .pipeline = vulkanState.materialDefault,
        .pipelineW = vulkanState.materialDefaultW,
    };
    const bool isSun = strstr(planets[i].textureName, "_sun") != nullptr;
    const bool isMoon = strstr(planets[i].textureName, "_moon") != nullptr;
    if (isSun) {
      Material sunMaterial = planetMaterial;
      sunMaterial.twoSided = true;
      sunMaterial.pipeline = vulkanState.materialSun;
      sunMaterial.pipelineW = vulkanState.materialSunW;
      allPlanets[i] = allPlanets[Sun];
      scene.createMaterial(allPlanets[i], sunMaterial);
      scene.createMesh(allPlanets[i], std::make_shared<Mesh>(Mesh{GeometryShapes::createIcoSphere(vec3(0), planets[i].radius, 4)}));
      auto sunCorona = allPlanets[i]->createNode(glm::rotate(mat4(1.0f), glm::radians(90.0f), vec3(1.0f, 0.0f, 0.0f)));
      scene.createMesh(sunCorona, std::make_shared<Mesh>(Mesh{GeometryShapes::createQuad2D(vec2(-0.8f), vec2(+0.8f), 0.0f)}));
      scene.createMaterial(sunCorona,
                           Material{
                               .texEmissive = loadTextureFromFile(app, "768_sun_corona.jpg"),
                               .isTransparent = true,
                               .pipeline = vulkanState.materialSunCorona,
                           });
    } else if (isMoon) {
      // attach the Moon to the Earth
      allPlanets[i] = allPlanets[Earth]->createNode();
      scene.animators.push_back(OrbitAnimationGroup{allPlanets[i],
                                                    std::vector<OrbitAnimator>{
                                                        {Z, 0.0f, planets[i].globalOrbitalSpeed, planets[i].orbitalRadius},
                                                        {Z, 0.0f, planets[i].localOrbitalSpeed, 0.0f},
                                                        {X, planets[i].axialTilt, 0.0f, 0.0f},
                                                        {X, planets[i].orbitalInclination, 0.0f, 0.0f},
                                                    }});
      scene.createMesh(allPlanets[i], std::make_shared<Mesh>(Mesh{GeometryShapes::createIcoSphere(vec3(0), planets[i].radius, 3)}));
      scene.createMaterial(allPlanets[i], planetMaterial);
    } else {
      // all other planets
      allPlanets[i] = allPlanets[Sun]->createNode(glm::translate(mat4(1.0f), vec3(0.0f, planets[i].orbitalRadius, 0.0f)));
      scene.animators.push_back(OrbitAnimationGroup{allPlanets[i],
                                                    std::vector<OrbitAnimator>{
                                                        {Z, 0.0f, planets[i].localOrbitalSpeed, 0.0f},
                                                        {X, planets[i].axialTilt, 0.0f, planets[i].orbitalRadius},
                                                        {Z, 0.0f, planets[i].globalOrbitalSpeed, 0.0f},
                                                        {X, planets[i].orbitalInclination, 0.0f, 0.0f},
                                                    }});
      scene.createMaterial(allPlanets[i], planetMaterial);
      scene.createMesh(allPlanets[i], std::make_shared<Mesh>(Mesh{GeometryShapes::createIcoSphere(vec3(0), planets[i].radius, 3)}));
    }
  }

  // create orbits
  if (g_DrawPlanetOrbits) {
    const Material orbitMaterial = {
        .isTransparent = true,
        .pipeline = vulkanState.materialOrbit,
    };
    for (size_t i = 0; i < planets.size(); i++) {
      SceneNode* orbit = allPlanets[Sun]->createNode(glm::rotate(mat4(1.0f), glm::radians(planets[i].orbitalInclination), X));
      scene.createMaterial(orbit, orbitMaterial);
      scene.createMesh(orbit, std::make_shared<Mesh>(Mesh{GeometryShapes::createOrbit(planets[i].orbitalRadius, 128)}));
    }

    // create orbit for the Moon
    SceneNode* orbit = allPlanets[Earth]->createNode();
    scene.createMaterial(orbit, orbitMaterial);
    scene.createMesh(orbit, std::make_shared<Mesh>(Mesh{GeometryShapes::createOrbit(planets[Moon].orbitalRadius, 64)}));
  }

  // attach the Saturn disk
  {
    const Material diskMaterial = {
        .emissive = vec4(0.7f, 0.7f, 0.7f, 0.3f),
        .diffuse = vec4(1.0f, 1.0f, 1.0f, 0.3f),
        .texEmissive = loadTextureFromFile(app, "1k_saturn_rings.jpg"),
        .texDiffuse = loadTextureFromFile(app, "1k_saturn_rings.jpg"),
        .isTransparent = true,
        .pipeline = vulkanState.materialSaturnRings,
    };
    SceneNode* disk = allPlanets[Saturn]->createNode();
    scene.createMaterial(disk, diskMaterial);
    scene.createMesh(disk, std::make_shared<Mesh>(Mesh{GeometryShapes::createDisk(1.5f * g_Scale * 70.0f, 1.5f * g_Scale * 130.0f, 100)}));
  }

  // create inner and outer asteroid belts
  {
    const Material asteroidMat1 = {
        .emissive = vec4(0.3, 0.3, 0.3, 1.0),
        .diffuse = vec4(0.5, 0.5, 0.5, 1.0),
        .texEmissive = loadTextureFromFile(app, "2k_makemake_fictional.jpg"),
        .texDiffuse = loadTextureFromFile(app, "2k_makemake_fictional.jpg"),
        .pipeline = vulkanState.materialDefault,
        .pipelineW = vulkanState.materialDefaultW,
    };
    const Material asteroidMat2 = {
        .emissive = vec4(0.4, 0.3, 0.3, 1.0),
        .diffuse = vec4(0.45, 0.45, 0.55, 1.0),
        .texEmissive = loadTextureFromFile(app, "2k_makemake_fictional.jpg"),
        .texDiffuse = loadTextureFromFile(app, "2k_makemake_fictional.jpg"),
        .pipeline = vulkanState.materialDefault,
        .pipelineW = vulkanState.materialDefaultW,
    };
    SceneNode* g_ParentAsteroid = allPlanets[Sun]->createNode();

    const std::shared_ptr<Mesh> asteroidMesh = std::make_shared<Mesh>(Mesh{loadMeshFromFile(app, "deimos.obj")});

    assert(asteroidMesh);

    for (size_t i = 0; i < numAsteroidsInner; i++) {
      const float radius = randomFloat(g_Scale * 900.0f, g_Scale * 1250.0f);
      const float globalSpeed = randomFloat(0.5f, 2.5f);
      const float localSpeed = randomFloat(1.0f, 5.5f);
      const float gRotAngle = randomFloat(0.0f, 360.0f);
      const float lRotAngle = randomFloat(0.0f, 360.0f);
      const vec3 randomRotAxis = glm::normalize(randomVec(vec3(0), vec3(1)));

      SceneNode* node = g_ParentAsteroid->createNode();
      scene.animators.push_back(OrbitAnimationGroup{node,
                                                    std::vector<OrbitAnimator>{
                                                        {randomRotAxis, lRotAngle, 20.0f * localSpeed, 0.0f},
                                                        {Z, 0.0f, 0.0f, radius},
                                                        {Z, gRotAngle, globalSpeed, 0.0f},
                                                        {Z, 0.0f, 0.0f, 0.0f},
                                                    }});
      SceneNode* subNode = node->createNode(glm::scale(mat4(1.0f), g_Scale * glm::vec3(randomFloat(0.05f, 0.15f))));
      scene.createMesh(subNode, asteroidMesh);
      scene.createMaterial(subNode, randomFloat(0, 1) < 0.75f ? asteroidMat1 : asteroidMat2);
    }

    for (size_t i = 0; i < numAsteroidsOuter; i++) {
      const float radius = randomFloat(g_Scale * 1700.0f, g_Scale * 1900.0f);
      const float globalSpeed = randomFloat(0.7f, 3.4f);
      const float localSpeed = randomFloat(0.5f, 2.5f);
      const float gRotAngle = randomFloat(0.0f, 360.0f);
      const float lRotAngle = randomFloat(0.0f, 360.0f);
      const vec3 randomRotAxis = glm::normalize(randomVec(vec3(0), vec3(1)));

      SceneNode* node = g_ParentAsteroid->createNode();
      scene.animators.push_back(OrbitAnimationGroup{node,
                                                    std::vector<OrbitAnimator>{
                                                        {randomRotAxis, lRotAngle, 10.0f * localSpeed, 0.0f},
                                                        {Z, 0.0f, 0.0f, radius},
                                                        {Z, gRotAngle, globalSpeed, 0.0f},
                                                        {Z, 0.0f, 0.0f, 0.0f},
                                                    }});
      SceneNode* subNode = node->createNode(glm::scale(mat4(1.0f), g_Scale * glm::vec3(randomFloat(0.1f, 0.3f))));
      scene.createMesh(subNode, asteroidMesh);
      scene.createMaterial(subNode, randomFloat(0, 1) < 0.25f ? asteroidMat1 : asteroidMat2);
    }
  }

  // adjust initial position
  scene.updateAnimations(150.0);

  return scene;
}

struct RenderView final {
  mat4 proj;
  mat4 view;
  lvk::Viewport viewport;
};

struct RenderOp final {
  lvk::RenderPipelineHandle pipeline;
  lvk::RenderPipelineHandle pipelineW;
  uint32_t firstVertex = 0;
  uint32_t numVertices = 0;
  uint32_t numInstances = 1;
  DrawData drawData = {};
  uint32_t idDrawData = 0;
};

VULKAN_APP_MAIN {
  const VulkanAppConfig cfg{
      .width = -80,
      .height = -80,
      .initialCameraPos = vec3(0.8, -1.6, 0.6),
      .initialCameraTarget = vec3(-1.5, 1.2, -0.6),
      .initialCameraUpVector = vec3(0, 0, 1),
  };
  VULKAN_APP_DECLARE(app, cfg);

  app.positioner_.maxSpeed_ = 0.1f;

  lvk::IContext* ctx = app.ctx_.get();

  ShaderModules smDefault = loadShaderProgram(ctx, codeDefaultVS, codeDefaultFS);
  ShaderModules smOrbit = loadShaderProgram(ctx, codeOrbitVS, codeOrbitFS);
  ShaderModules smSun = loadShaderProgram(ctx, codeSunVS, codeSunFS);
  ShaderModules smSunCorona = loadShaderProgram(ctx, codeSunCoronaVS, codeSunCoronaFS);
  ShaderModules smSkyBox = loadShaderProgram(ctx, codeSkyBoxVS, codeSkyBoxFS);

  const lvk::VertexInput vinput = {
      .attributes = {{.location = 0, .format = lvk::VertexFormat::Float3, .offset = offsetof(GeometryShapes::Vertex, pos)},
                     {.location = 1, .format = lvk::VertexFormat::Float2, .offset = offsetof(GeometryShapes::Vertex, uv)},
                     {.location = 2, .format = lvk::VertexFormat::Float3, .offset = offsetof(GeometryShapes::Vertex, normal)}},
      .inputBindings = {{.stride = sizeof(GeometryShapes::Vertex)}},
  };

  auto createPipelines = [ctx](lvk::Holder<lvk::RenderPipelineHandle>& solid,
                               lvk::Holder<lvk::RenderPipelineHandle>& wireframe,
                               lvk::RenderPipelineDesc desc) {
    solid = ctx->createRenderPipeline(desc);
    desc.polygonMode = lvk::PolygonMode_Line;
    wireframe = ctx->createRenderPipeline(desc);
  };

  createPipelines(vulkanState.materialDefault,
                  vulkanState.materialDefaultW,
                  {
                      .vertexInput = vinput,
                      .smVert = smDefault.vert,
                      .smFrag = smDefault.frag,
                      .color = {{.format = ctx->getSwapchainFormat()}},
                      .depthFormat = app.getDepthFormat(),
                      .cullMode = lvk::CullMode_Back,
                      .debugName = "Pipeline: default",
                  });
  vulkanState.materialSaturnRings = ctx->createRenderPipeline({
      .topology = lvk::Topology::Topology_TriangleStrip,
      .vertexInput = vinput,
      .smVert = smDefault.vert,
      .smFrag = smDefault.frag,
      .color = {{.format = ctx->getSwapchainFormat(),
                 .blendEnabled = true,
                 .srcRGBBlendFactor = lvk::BlendFactor_SrcAlpha,
                 .dstRGBBlendFactor = lvk::BlendFactor_OneMinusSrcAlpha}},
      .depthFormat = app.getDepthFormat(),
      .cullMode = lvk::CullMode_None,
      .debugName = "Pipeline: Saturn rings",
  });
  vulkanState.materialOrbit = ctx->createRenderPipeline({
      .topology = lvk::Topology_LineStrip,
      .vertexInput =
          {
              .attributes = {{.location = 0, .format = lvk::VertexFormat::Float3, .offset = offsetof(GeometryShapes::Vertex, pos)}},
              .inputBindings = {{.stride = sizeof(GeometryShapes::Vertex)}},
          },
      .smVert = smOrbit.vert,
      .smFrag = smOrbit.frag,
      .color = {{.format = ctx->getSwapchainFormat(),
                 .blendEnabled = true,
                 .srcRGBBlendFactor = lvk::BlendFactor_SrcAlpha,
                 .dstRGBBlendFactor = lvk::BlendFactor_OneMinusSrcAlpha}},
      .depthFormat = app.getDepthFormat(),
      .cullMode = lvk::CullMode_None,
      .debugName = "Pipeline: orbit",
  });
  createPipelines(vulkanState.materialSun,
                  vulkanState.materialSunW,
                  {
                      .vertexInput = vinput,
                      .smVert = smSun.vert,
                      .smFrag = smSun.frag,
                      .color = {{.format = ctx->getSwapchainFormat()}},
                      .depthFormat = app.getDepthFormat(),
                      .cullMode = lvk::CullMode_Back,
                      .debugName = "Pipeline: Sun",
                  });
  vulkanState.materialSunCorona = ctx->createRenderPipeline({
      .topology = lvk::Topology_TriangleStrip,
      .vertexInput = vinput,
      .smVert = smSunCorona.vert,
      .smFrag = smSunCorona.frag,
      .color = {{.format = ctx->getSwapchainFormat(),
                 .blendEnabled = true,
                 .srcRGBBlendFactor = lvk::BlendFactor_SrcAlpha,
                 .dstRGBBlendFactor = lvk::BlendFactor_OneMinusSrcAlpha}},
      .depthFormat = app.getDepthFormat(),
      .debugName = "Pipeline: Sun corona",
  });
  vulkanState.materialSkyBox = ctx->createRenderPipeline({
      .smVert = smSkyBox.vert,
      .smFrag = smSkyBox.frag,
      .color = {{.format = ctx->getSwapchainFormat()}},
      .depthFormat = app.getDepthFormat(),
      .debugName = "Pipeline: sky box",
  });

  vulkanState.texSkyBox = loadTextureCubeFromFile(app, "starmap_4k.jpg");

  vulkanState.bufPerFrame = ctx->createBuffer({
      .usage = lvk::BufferUsageBits_Uniform,
      .storage = lvk::StorageType_Device,
      .size = sizeof(PerFrameBuffer),
      .debugName = "Buffer: bufPerFrame",
  });

  Scene scene = createSolarSystemScene(app);

  for (uint32_t i = 0; i != ctx->getNumSwapchainImages(); i++) {
    char debugName[256] = {0};
    snprintf(debugName, sizeof(debugName) - 1, "Buffer: bufModelMatrices #%u", i);
    vulkanState.bufModelMatrices.emplace_back(ctx->createBuffer({
        .usage = lvk::BufferUsageBits_Storage,
        .storage = lvk::StorageType_HostVisible,
        .size = sizeof(mat4) * scene.meshes.size(),
        .debugName = debugName,
    }));
    snprintf(debugName, sizeof(debugName) - 1, "Buffer: bufNormalMatrices #%u", i);
    vulkanState.bufNormalMatrices.emplace_back(ctx->createBuffer({
        .usage = lvk::BufferUsageBits_Storage,
        .storage = lvk::StorageType_HostVisible,
        .size = sizeof(mat4) * scene.meshes.size(),
        .debugName = debugName,
    }));
  }
  // all materials are static - upload them once
  {
    struct MaterialBuffer {
      vec4 emissive;
      vec4 diffuse; // w - two-sided
      uint32_t texEmissive;
      uint32_t texDiffuse;
      uint32_t padding[2] = {};
    };
    std::vector<MaterialBuffer> materials;
    for (const Material& m : scene.materials) {
      materials.push_back({
          .emissive = m.emissive,
          .diffuse = vec4(vec3(m.diffuse), m.twoSided ? 1.0f : 0.0f),
          .texEmissive = m.texEmissive.index(),
          .texDiffuse = m.texDiffuse.index(),
      });
    }
    vulkanState.bufMaterials = ctx->createBuffer({
        .usage = lvk::BufferUsageBits_Storage,
        .storage = lvk::StorageType_Device,
        .size = sizeof(MaterialBuffer) * materials.size(),
        .data = materials.data(),
        .debugName = "Buffer: bufMaterials",
    });
  }

  std::vector<RenderOp> flatRenderQueue;
  flatRenderQueue.reserve(scene.meshes.size());

  std::vector<GeometryShapes::Vertex> allVertices;

  // collect all render ops - the structure of our scene is immutable
  for (size_t i = 0; i != scene.meshes.size(); i++) {
    MeshComponent& mesh = scene.meshes[i];
    assert(mesh.mesh);
    const int materialIdx = mesh.sceneNode->getMaterialIndexOrParent();
    assert(materialIdx >= 0);

    if (mesh.mesh->firstVertex == -1) {
      // pack all different mesh objects into one giant vertex buffer
      mesh.mesh->firstVertex = (int)allVertices.size();
      allVertices.reserve(allVertices.size() + mesh.mesh->vertices.size());
      allVertices.insert(allVertices.end(), mesh.mesh->vertices.begin(), mesh.mesh->vertices.end());
    }

    const Material& m = scene.materials[materialIdx];

    flatRenderQueue.push_back(RenderOp{
        .pipeline = m.pipeline,
        .pipelineW = m.pipelineW ? m.pipelineW : m.pipeline,
        .firstVertex = (uint32_t)mesh.mesh->firstVertex,
        .numVertices = (uint32_t)mesh.mesh->vertices.size(),
        .drawData =
            {
                .idMatrix = (uint32_t)i,
                .idMaterial = (uint32_t)materialIdx,
            },
    });
  }

  vulkanState.bufVertices = ctx->createBuffer({
      .usage = lvk::BufferUsageBits_Vertex,
      .storage = lvk::StorageType_Device,
      .size = sizeof(GeometryShapes::Vertex) * allVertices.size(),
      .data = allVertices.data(),
      .debugName = "Buffer: vertex",
  });

  // we need multi-layered framebuffer textures for multiview rendering
  for (uint32_t i = 0; i != ctx->getNumSwapchainImages(); i++) {
    char debugName[256] = {0};
    snprintf(debugName, sizeof(debugName) - 1, "Offscreen (color #%u)", i);
    vulkanState.texColor.emplace_back(app.ctx_->createTexture({
        .type = lvk::TextureType_2D,
        .format = ctx->getSwapchainFormat(),
        .dimensions = {uint32_t(app.width_) / 2, uint32_t(app.height_)},
        .numLayers = 2,
        .usage = lvk::TextureUsageBits_Attachment,
        .debugName = debugName,
    }));
  }
  vulkanState.texDepth = app.ctx_->createTexture({
      .type = lvk::TextureType_2D,
      .format = app.getDepthFormat(),
      .dimensions = {uint32_t(app.width_) / 2, uint32_t(app.height_)},
      .numLayers = 2,
      .usage = lvk::TextureUsageBits_Attachment,
      .debugName = "Offscreen (depth)",
  });

  auto selectROPs = [](const std::vector<RenderOp>& ROPs, const std::function<bool(const RenderOp&)>& pred) -> std::vector<RenderOp> {
    std::vector<RenderOp> outROPs;
    outROPs.reserve(ROPs.size());
    for (const RenderOp& i : ROPs)
      if (pred(i))
        outROPs.push_back(i);
    return outROPs;
  };

  // sort ROPs by pipeline and transparency
  std::sort(flatRenderQueue.begin(), flatRenderQueue.end(), [&mm = scene.materials](const auto& a, const auto& b) {
    if (mm[a.drawData.idMaterial].isTransparent != mm[b.drawData.idMaterial].isTransparent) {
      return mm[a.drawData.idMaterial].isTransparent > mm[b.drawData.idMaterial].isTransparent;
    }
    return a.pipeline.index() < b.pipeline.index();
  });

  std::vector<RenderOp> renderQueueOpaque =
      selectROPs(flatRenderQueue, [&scene](const RenderOp& ROP) { return !scene.materials[ROP.drawData.idMaterial].isTransparent; });
  std::vector<RenderOp> renderQueueTransparent =
      selectROPs(flatRenderQueue, [&scene](const RenderOp& ROP) { return scene.materials[ROP.drawData.idMaterial].isTransparent; });

  // as the render queues are static now, we can create immutable DrawData
  {
    std::vector<DrawData> drawData;

    for (RenderOp& ROP : renderQueueOpaque) {
      ROP.idDrawData = (uint32_t)drawData.size();
      drawData.push_back(ROP.drawData);
    }
    for (RenderOp& ROP : renderQueueTransparent) {
      ROP.idDrawData = (uint32_t)drawData.size();
      drawData.push_back(ROP.drawData);
    }
    vulkanState.bufDrawData = ctx->createBuffer({
        .usage = lvk::BufferUsageBits_Storage,
        .storage = lvk::StorageType_Device,
        .size = sizeof(DrawData) * drawData.size(),
        .data = drawData.data(),
        .debugName = "Buffer: drawData",
    });
  }

  auto createBatches = [](const std::vector<RenderOp>& ROPs) -> std::vector<RenderOp> {
    const size_t size = ROPs.size();

    if (size < 2)
      return ROPs;

    std::vector<RenderOp> batchedROPs;
    batchedROPs.reserve(size);

    // always store the 1st ROP
    batchedROPs.emplace_back(ROPs[0]);

    const RenderOp* prevROP = &ROPs[0];
    const RenderOp* ROP = &ROPs[1];

    for (size_t i = 1; i != size; i++, ROP++, prevROP++) {
      const bool samePipeline = prevROP->pipeline == ROP->pipeline;
      const bool sameMesh = prevROP->firstVertex == ROP->firstVertex;
      const bool sequentialDrawData = prevROP->idDrawData + 1 == ROP->idDrawData;
      if (samePipeline && sameMesh && sequentialDrawData) {
        batchedROPs.back().numInstances++;
      } else {
        batchedROPs.emplace_back(*ROP);
      }
    }

    LLOGL("Batched ROPs: %u -> %u\n", ROPs.size(), batchedROPs.size());

    return batchedROPs;
  };

  renderQueueOpaque = createBatches(renderQueueOpaque);
  renderQueueTransparent = createBatches(renderQueueTransparent);

  struct DrawIndirectCommand {
    uint32_t vertexCount;
    uint32_t instanceCount;
    uint32_t firstVertex;
    uint32_t firstInstance;
  };

  auto updateIndirectBuffer = [](const std::vector<RenderOp>& ROPs) -> std::vector<DrawIndirectCommand> {
    for (const RenderOp& ROP : ROPs) {
    }
    return {};
  };

  std::vector<mat4> modelMatrices;
  std::vector<mat4> normalMatrices;
  modelMatrices.resize(scene.meshes.size());
  normalMatrices.resize(scene.meshes.size());

  app.run([&](uint32_t width, uint32_t height, float aspectRatio, float deltaSeconds) {
    LVK_PROFILER_FUNCTION();

    scene.updateAnimations(g_Paused ? 0.0 : deltaSeconds);
    scene.root.updateGlobalFromLocal(mat4(1.0f));

    // update model matrices
    for (size_t i = 0; i != scene.meshes.size(); i++) {
      modelMatrices[i] = scene.meshes[i].sceneNode->global;
      normalMatrices[i] = glm::transpose(glm::inverse(modelMatrices[i]));
    }
    ctx->upload(
        vulkanState.bufModelMatrices[ctx->getSwapchainCurrentImageIndex()], modelMatrices.data(), sizeof(mat4) * modelMatrices.size());
    ctx->upload(
        vulkanState.bufNormalMatrices[ctx->getSwapchainCurrentImageIndex()], normalMatrices.data(), sizeof(mat4) * normalMatrices.size());

    const mat4 view = [&app, mouse = app.mouseState_]() -> mat4 {
      if (g_UseTrackball) {
        if (!ImGui::GetIO().WantCaptureMouse) {
          g_Trackball.dragTo(vec2(1.0f - mouse.pos.x, mouse.pos.y), 10.0f, mouse.pressedLeft);
        }
        return glm::lookAt(vec3(0.0f, 0.0f, 4.0f), vec3(0.0f, 0.0f, 0.0f), vec3(0.0f, -1.0f, 0.0f)) * g_Trackball.getRotationMatrix();
      } else {
        return app.camera_.getViewMatrix();
      }
    }();

    const std::vector<RenderView> views = [](int w, int h, float aspectRatio, const mat4& view) -> std::vector<RenderView> {
      const float fov = glm::radians(45.0f);
      const float nearPlane = 0.01f;
      const float farPlane = 100.0f;
      if (g_MultiViewStereo) {
        // asymmetric frustum - stereoscopic
        // https://paulbourke.net/stereographics/stereorender/
        const float focalLength = 0.5f;
        const float aspect = aspectRatio * 0.5f;
        const float wd2 = nearPlane * tan(fov / 2.0f);
        const float D = 0.5f * IoD * nearPlane / focalLength;
        const mat4 proj0 = glm::frustum(-aspect * wd2 - D, aspect * wd2 - D, -wd2, wd2, nearPlane, farPlane); // left
        const mat4 proj1 = glm::frustum(-aspect * wd2 + D, aspect * wd2 + D, -wd2, wd2, nearPlane, farPlane); // right
        const mat4 T0 = glm::translate(glm::mat4(1.0f), vec3(+1, 0, 0) * IoD * 0.5f);
        const mat4 T1 = glm::translate(glm::mat4(1.0f), vec3(-1, 0, 0) * IoD * 0.5f);
        const float halfW = float(w) / 2.0f;
        return {
            {proj0, view * T0, lvk::Viewport{0, 0, halfW, float(h)}},
            {proj1, view * T1, lvk::Viewport{0, 0, halfW, float(h)}},
        };
      }
      const mat4 proj = glm::perspective(fov, aspectRatio, nearPlane, farPlane);
      return {{proj, view, lvk::Viewport{0, 0, float(w), float(h)}}};
    }(app.width_, app.height_, aspectRatio, view);

    lvk::ICommandBuffer& buf = ctx->acquireCommandBuffer();
    const lvk::Framebuffer fb = {
        .color = {{.texture = g_MultiViewStereo ? vulkanState.texColor[ctx->getSwapchainCurrentImageIndex()]
                                                : ctx->getCurrentSwapchainTexture()}},
        .depthStencil = {.texture = g_MultiViewStereo ? vulkanState.texDepth : app.getDepthTexture()},
    };
    // render scene
    {
      const struct {
        uint64_t bufModelMatrices;
        uint64_t bufNormalMatrices;
        uint64_t bufPerFrame;
        uint64_t bufDrawData;
        uint64_t bufMaterials;
      } pc = {
          .bufModelMatrices = ctx->gpuAddress(vulkanState.bufModelMatrices[ctx->getSwapchainCurrentImageIndex()]),
          .bufNormalMatrices = ctx->gpuAddress(vulkanState.bufNormalMatrices[ctx->getSwapchainCurrentImageIndex()]),
          .bufPerFrame = ctx->gpuAddress(vulkanState.bufPerFrame),
          .bufDrawData = ctx->gpuAddress(vulkanState.bufDrawData),
          .bufMaterials = ctx->gpuAddress(vulkanState.bufMaterials),
      };
      // update per-frame buffers for all render views - we should do it outside of a render pass
      const PerFrameBuffer perFrame =
          g_MultiViewStereo
              ? PerFrameBuffer{.proj = {views[0].proj, views[1].proj}, .view = {views[0].view, views[1].view}, .time = (float)glfwGetTime()}
              : PerFrameBuffer{.proj = {views[0].proj}, .view = {views[0].view}, .time = (float)glfwGetTime()};
      buf.cmdUpdateBuffer(vulkanState.bufPerFrame, perFrame);
      buf.cmdBindVertexBuffer(0, vulkanState.bufVertices, 0);

      buf.cmdBeginRendering({.color = {{.loadOp = lvk::LoadOp_Clear, .clearColor = {0.0f, 0.0f, 0.0f, 1.0f}}},
                             .depth = {.loadOp = lvk::LoadOp_Clear, .clearDepth = 1.0f},
                             .layerCount = (uint32_t)views.size(),
                             .viewMask = g_MultiViewStereo ? 0b11 : 0u},
                            fb);
      for (const RenderView& v : views) {
        buf.cmdBindViewport(v.viewport);
        buf.cmdBindScissorRect({(uint32_t)v.viewport.x, (uint32_t)v.viewport.y, (uint32_t)v.viewport.width, (uint32_t)v.viewport.height});

        // all opaque/transparent pipelines share the same push constants - bind them up front
        buf.cmdBindRenderPipeline(renderQueueOpaque[0].pipeline);
        buf.cmdPushConstants(pc);

        // 1. Render opaque objects
        buf.cmdBindDepthState({.compareOp = lvk::CompareOp_Less, .isDepthWriteEnabled = true});
        for (const RenderOp& ROP : renderQueueOpaque) {
          buf.cmdBindRenderPipeline(g_Wireframe ? ROP.pipelineW : ROP.pipeline);
          buf.cmdDraw(ROP.numVertices, ROP.numInstances, ROP.firstVertex, ROP.idDrawData);
        }

        // 2. Render the sky box
        buf.cmdBindRenderPipeline(vulkanState.materialSkyBox);
        const struct {
          uint64_t bufPerFrame;
          uint32_t texCube;
        } pcSkyBox = {
            .bufPerFrame = ctx->gpuAddress(vulkanState.bufPerFrame),
            .texCube = vulkanState.texSkyBox.index(),
        };
        buf.cmdPushConstants(pcSkyBox);
        buf.cmdBindDepthState({.compareOp = lvk::CompareOp_Less, .isDepthWriteEnabled = false});
        buf.cmdDraw(36);

        // 3. Render transparent objects
        buf.cmdBindRenderPipeline(renderQueueTransparent[0].pipeline);
        buf.cmdPushConstants(pc);
        buf.cmdBindDepthState({.compareOp = lvk::CompareOp_Less, .isDepthWriteEnabled = false});
        for (const RenderOp& ROP : renderQueueTransparent) {
          buf.cmdBindRenderPipeline(g_Wireframe ? ROP.pipelineW : ROP.pipeline);
          buf.cmdDraw(ROP.numVertices, ROP.numInstances, ROP.firstVertex, ROP.idDrawData);
        }
      }
    }
    buf.cmdEndRendering();
    if (g_MultiViewStereo) {
      // combine 2 layers from our offscreen image into a single swapchain image, displayed side by side
      buf.cmdCopyImage(fb.color[0].texture,
                       ctx->getCurrentSwapchainTexture(),
                       ctx->getDimensions(fb.color[0].texture),
                       {},
                       {},
                       lvk::TextureLayers{.layer = 0},
                       lvk::TextureLayers{.layer = 0});
      buf.cmdCopyImage(fb.color[0].texture,
                       ctx->getCurrentSwapchainTexture(),
                       ctx->getDimensions(fb.color[0].texture),
                       {},
                       {.x = app.width_ / 2},
                       lvk::TextureLayers{.layer = 1},
                       lvk::TextureLayers{.layer = 0});
    }
    // ImGui pass
    const lvk::Framebuffer fbImGui = {
        .color = {{.texture = ctx->getCurrentSwapchainTexture()}},
    };
    buf.cmdBeginRendering(lvk::RenderPass{.color = {{.loadOp = lvk::LoadOp_Load}}}, fbImGui);
    app.imgui_->beginFrame(fbImGui);
    auto imGuiPushFlagsAndStyles = [](bool value) {
      ImGui::BeginDisabled(!value);
      ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * (value ? 1.0f : 0.3f));
    };
    auto imGuiPopFlagsAndStyles = []() {
      ImGui::PopStyleVar();
      ImGui::EndDisabled();
    };
    const float indentSize = 16.0f;
    ImGui::Begin("Keyboard hints:", nullptr, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoNavInputs);
#if !defined(ANDROID)
    ImGui::Text("W/S/A/D - camera movement");
    ImGui::Text("1/2 - camera up/down");
    ImGui::Text("Shift - fast movement");
    ImGui::Text("Space - reset camera");
    ImGui::Separator();
#endif
    ImGui::Checkbox("Pause animation (P)", &g_Paused);
    ImGui::Checkbox("Wireframe (X)", &g_Wireframe);
    ImGui::Checkbox("Use trackball navigation", &g_UseTrackball);
    ImGui::Checkbox("Multiview", &g_MultiViewStereo);
    imGuiPushFlagsAndStyles(g_MultiViewStereo);
    ImGui::SliderFloat("IoD", &IoD, 0, 0.1f);
    imGuiPopFlagsAndStyles();
    ImGui::End();
    app.drawFPS();
    app.imgui_->endFrame(buf);
    buf.cmdEndRendering();
    ctx->submit(buf, ctx->getCurrentSwapchainTexture());
  });

  vulkanState = {};

  VULKAN_APP_EXIT();
}

```

`samples/DEMO_002_Bistro.cpp`:

```cpp
/*
 * LightweightVK
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

const char* codeComputeTestSlang = R"(
struct PushConstants {
  uint tex;
  uint width;
  uint height;
};

[[vk::push_constant]] PushConstants pc;

[[vk::binding(2, 0)]] RWTexture2D<float4> kTextures2DInOut[];

[shader("compute")]
[numthreads(16, 16, 1)]
void computeMain(uint3 globalID : SV_DispatchThreadID) {
  int2 pos = int2(globalID.xy);
  if (pos.x < pc.width && pos.y < pc.height) {
    float4 pixel = kTextures2DInOut[pc.tex][pos];
    float luminance = dot(pixel, float4(0.299, 0.587, 0.114, 0.0)); // https://www.w3.org/TR/AERT/#color-contrast
    kTextures2DInOut[pc.tex][pos] = float4(luminance.xxx, 1.0);
  }
}
)";

const char* codeFullscreenSlang = R"(
struct PushConstants {
  uint tex;
};

struct VSOutput {
  float4 sv_Position : SV_Position;
  float2 uv          : TEXCOORD0;
};

[[vk::push_constant]] PushConstants pc;

[shader("vertex")]
VSOutput vertexMain(uint vertexID : SV_VertexID) {
  VSOutput out;
  
  // generate a triangle covering the entire screen
  out.uv = float2((vertexID << 1) & 2, vertexID & 2);
  out.sv_Position = float4(out.uv * float2(2, -2) + float2(-1, 1), 0.0, 1.0);

  return out;
}

[shader("fragment")]
float4 fragmentMain(VSOutput input) : SV_Target0 {
  return textureBindless2D(pc.tex, 0, input.uv);
}
)";

const char* codeSlang = R"(
struct Material {
  float4 ambient;
  float4 diffuse;
  int texAmbient;
  int texDiffuse;
  int texAlpha;
  int padding;
};

struct PerFrame {
  float4x4 proj;
  float4x4 view;
  float4x4 light;
  uint texSkyboxRadiance;
  uint texSkyboxIrradiance;
  uint texShadow;
  uint sampler0;
  uint samplerShadow0;
};

struct PerObject {
  float4x4 model;
  float4x4 normal;
};

struct Materials {
  Material mtl[];
};

struct PushConstants {
  PerFrame* perFrame;
  PerObject* perObject;
  Materials* materials;
};

struct PerVertex {
  float3 normal : NORMAL;
  float2 uv : TEXCOORD0;
  float4 shadowCoords : TEXCOORD1;
};

struct VSOutput {
  PerVertex vtx;
  Material mtl : MATERIAL;
  float4 position : SV_Position;
};

[[vk::push_constant]] PushConstants pc;

[[vk::constant_id(0)]] const bool bDrawNormals = false;

// https://www.shadertoy.com/view/llfcRl
float2 unpackSnorm2x8(uint d) {
  return float2(uint2(d, d >> 8) & 255u) / 127.5 - 1.0;
}

float3 unpackOctahedral16(uint data) {
  float2 v = unpackSnorm2x8(data);
  // https://x.com/Stubbesaurus/status/937994790553227264
  float3 n = float3(v, 1.0 - abs(v.x) - abs(v.y));
  float t = max(-n.z, 0.0);
  n.x += (n.x > 0.0) ? -t : t;
  n.y += (n.y > 0.0) ? -t : t;
  return normalize(n);
}

[shader("vertex")]
VSOutput vertexMain(
  float3 pos : POSITION,
  float2 uv : TEXCOORD0,
  uint normal : NORMAL,
  uint mtlIndex : MATERIAL_INDEX
) {
  float4x4 proj = pc.perFrame->proj;
  float4x4 view = pc.perFrame->view;
  float4x4 model = pc.perObject->model;
  float4x4 light = pc.perFrame->light;

  VSOutput out;
  
  out.mtl = pc.materials->mtl[mtlIndex];
  out.position = proj * view * model * float4(pos, 1.0);
  
  // compute the normal in world-space
  out.vtx.normal = normalize(float3x3(pc.perObject->normal) * unpackOctahedral16(normal));
  out.vtx.uv = uv;
  out.vtx.shadowCoords = light * model * float4(pos, 1.0);
  
  return out;
}

float PCF3(float3 uvw) {
  float size = 1.0 / textureBindlessSize2D(pc.perFrame->texShadow).x;
  float shadow = 0.0;
  for (int v = -1; v <= +1; v++)
    for (int u = -1; u <= +1; u++)
      shadow += textureBindless2DShadow(pc.perFrame->texShadow, pc.perFrame->samplerShadow0, uvw + size * float3(u, v, 0));
  return shadow / 9;
}

float shadow(float4 s) {
  s = s / s.w;
  if (s.z > -1.0 && s.z < 1.0) {
    float depthBias = -0.00005;
    float shadowSample = PCF3(float3(s.x, 1.0 - s.y, s.z + depthBias));
    return lerp(0.3, 1.0, shadowSample);
  }
  return 1.0;
}

[shader("fragment")]
float4 fragmentMain(VSOutput input) : SV_Target0 {
  float4 alpha = textureBindless2D(input.mtl.texAlpha, pc.perFrame->sampler0, input.vtx.uv);
  if (input.mtl.texAlpha > 0 && alpha.r < 0.5)
    discard;
  
  float4 Ka = input.mtl.ambient * textureBindless2D(input.mtl.texAmbient, pc.perFrame->sampler0, input.vtx.uv);
  float4 Kd = input.mtl.diffuse * textureBindless2D(input.mtl.texDiffuse, pc.perFrame->sampler0, input.vtx.uv);
  
  if (Kd.a < 0.5)
    discard;
  
  float3 n = normalize(input.vtx.normal);
  float NdotL1 = clamp(dot(n, normalize(float3(-1, 1, +1))), 0.0, 1.0);
  float NdotL2 = clamp(dot(n, normalize(float3(-1, 1, -1))), 0.0, 1.0);
  float NdotL = 0.5 * (NdotL1 + NdotL2);
  
  // IBL diffuse
  const float4 f0 = float4(0.04, 0.04, 0.04, 0.04);
  float4 diffuse = textureBindlessCube(pc.perFrame->texSkyboxIrradiance, pc.perFrame->sampler0, n) * Kd * (float4(1.0, 1.0, 1.0, 1.0) - f0);
  
  return bDrawNormals ?
    float4(0.5 * (n + float3(1.0, 1.0, 1.0)), 1.0) :
    Ka + diffuse * shadow(input.vtx.shadowCoords);
}
)";

const char* codeWireframeSlang = R"(
struct PerFrame {
  float4x4 proj;
  float4x4 view;
};

struct PerObject {
  float4x4 model;
};

struct PushConstants {
  PerFrame* perFrame;
  PerObject* perObject;
};

[[vk::push_constant]] PushConstants pc;

[shader("vertex")]
float4 vertexMain(float3 pos : POSITION) : SV_Position
{
  float4x4 proj = pc.perFrame->proj;
  float4x4 view = pc.perFrame->view;
  float4x4 model = pc.perObject->model;
  
  return proj * view * model * float4(pos, 1.0);
}

[shader("fragment")]
float4 fragmentMain() : SV_Target0 {
  return float4(1.0);
}
)";

const char* codeShadowSlang = R"(
struct PerFrame {
  float4x4 proj;
  float4x4 view;
  float4x4 light;
  uint texSkyboxRadiance;
  uint texSkyboxIrradiance;
  uint texShadow;
  uint sampler0;
  uint samplerShadow0;
};

struct PerObject {
  float4x4 model;
};

struct PushConstants {
  PerFrame* perFrame;
  PerObject* perObject;
};

[[vk::push_constant]] PushConstants pc;

[shader("vertex")]
float4 vertexMain(float3 pos : POSITION) : SV_Position {
  float4x4 proj = pc.perFrame->proj;
  float4x4 view = pc.perFrame->view;
  float4x4 model = pc.perObject->model;

  return proj * view * model * float4(pos, 1.0);
}

[shader("fragment")]
void fragmentMain() {
}
)";

const char* codeSkyboxSlang = R"(
struct PerFrame {
  float4x4 proj;
  float4x4 view;
  float4x4 light;
  uint texSkyboxRadiance;
  uint texSkyboxIrradiance;
  uint texShadow;
  uint sampler0;
  uint samplerShadow0;
};

struct PushConstants {
  PerFrame* perFrame;
};

struct VSOutput {
  float4 sv_Position : SV_Position;
  float3 dir         : TEXCOORD0;
};

[[vk::push_constant]] PushConstants pc;

static const float3 positions[8] = {
  float3(-1.0, -1.0,  1.0), float3( 1.0, -1.0,  1.0), float3( 1.0,  1.0,  1.0), float3(-1.0,  1.0,  1.0),
  float3(-1.0, -1.0, -1.0), float3( 1.0, -1.0, -1.0), float3( 1.0,  1.0, -1.0), float3(-1.0,  1.0, -1.0)
};

static const int indices[36] = {
  0, 1, 2, 2, 3, 0, 1, 5, 6, 6, 2, 1, 7, 6, 5, 5, 4, 7, 4, 0, 3, 3, 7, 4, 4, 5, 1, 1, 0, 4, 3, 2, 6, 6, 7, 3
};

[shader("vertex")]
VSOutput vertexMain(uint vertexID : SV_VertexID) {
  float4x4 proj = pc.perFrame->proj;
  float4x4 view = pc.perFrame->view;

  view[3] = float4(0, 0, 0, 1); // discard translation

  float3 pos = positions[indices[vertexID]];

  VSOutput out;

  out.sv_Position = (proj * view * float4(pos, 1.0)).xyww;
  out.dir = pos; // skybox
  
  return out;
}

[shader("fragment")]
float4 fragmentMain(float3 dir : TEXCOORD0) : SV_Target0 {
  return textureBindlessCube(pc.perFrame->texSkyboxRadiance, pc.perFrame->sampler0, dir);
}
)";

```

`samples/README.md`:

```md
# LightweightVK Samples

## 001_HelloTriangle

![lvk_android](../.github/samples/001_HelloTriangle.jpg)

## 002_RenderToCubeMap

![lvk_android](../.github/samples/002_RenderToCubeMap.jpg)

## 003_RenderToCubeMapSinglePass

![lvk_android](../.github/samples/003_RenderToCubeMapSinglePass.jpg)

## 004_YUV

![lvk_android](../.github/samples/004_YUV.jpg)

## 005_MeshShaders

![lvk_android](../.github/samples/005_MeshShaders.jpg)

## 007_DynamicRenderingLocalRead

![lvk_android](../.github/samples/007_DynamicRenderingLocalRead.jpg)

## 008_MeshShaderFireworks

![lvk_android](../.github/samples/008_MeshShaderFireworks.jpg)

## 009_TriplanarMapping

![lvk_android](../.github/samples/009_TriplanarMapping.jpg)

## 010_OmniShadows

![lvk_android](../.github/samples/010_OmniShadows.jpg)

## DEMO_001_SolarSystem

![lvk_android](../.github/screenshot02.jpg)

## RTX_001_Hello

![lvk_android](../.github/samples/006_RayTracingHello.jpg)

## RTX_002_AO

![lvk_android](../.github/samples/007_RayTracingAO.jpg)

## RTX_003_Pipeline

![lvk_android](../.github/samples/RTX_003_Pipeline.jpg)

## RTX_004_Textures

![lvk_android](../.github/samples/RTX_004_Textures.jpg)

## Tiny_MeshLarge

![lvk_android](../.github/samples/Tiny_MeshLarge.jpg)

### Performance measurements on Android

![lvk_android](../.github/samples/tiny_mesh_large_android.jpg)

|Device|GPU|Resolution|MSAA|Texture quality|Frame time|
|---|---|---|---|---|---|
|Xiaomi 13T Pro|Immortalis-G715|2712x1220|8x|High (2048x2048)|26ms|
|Xiaomi 13T Pro|Immortalis-G715|2712x1220|None|High (2048x2048)|16ms|
|Xiaomi 13T Pro|Immortalis-G715|2712x1220|None|Low (256x256)|**14ms**|
|Google Pixel 7 Pro|Mali-G710|3120x1440|8x|High (2048x2048)|85ms|
|Google Pixel 7 Pro|Mali-G710|3120x1440|None|High (2048x2048)|62ms|
|Google Pixel 7 Pro|Mali-G710|3120x1440|None|Low (256x256)|57ms|
|Google Pixel 7 Pro|Mali-G710|2712x1220|8x|High (2048x2048)|80ms|
|Google Pixel 7 Pro|Mali-G710|2712x1220|None|Low (256x256)|**54ms**|

```

`samples/RTX_001_Hello.cpp`:

```cpp
/*
 * LightweightVK
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#include "VulkanApp.h"

const char* codeSlang = R"(
[[vk::binding(2, 0)]] RWTexture2D<float4> kTextures2DInOut[];

struct Camera {
  float4x4 viewInverse;
  float4x4 projInverse;
};

struct PushConstants {
  Camera* cam;
  uint outTexture;
  uint tlas;
  float time;
};

[[vk::push_constant]] PushConstants pc;

struct RayPayload {
  float3 color;
};

[shader("raygeneration")]
void rayGenMain() {
  uint3 launchID = DispatchRaysIndex();
  uint3 launchSize = DispatchRaysDimensions();

  float2 pixelCenter = float2(launchID.xy) + float2(0.5, 0.5);
  float2 d = 2.0 * (pixelCenter / float2(launchSize.xy)) - 1.0;

  float4 origin    = pc.cam->viewInverse * float4(0, 0, 0, 1);
  float4 target    = pc.cam->projInverse * float4(d, 1, 1);
  float4 direction = pc.cam->viewInverse * float4(normalize(target.xyz), 0);

  RayDesc ray;
  ray.Origin = origin.xyz;
  ray.Direction = direction.xyz;
  ray.TMin = 0.1;
  ray.TMax = 500.0;

  RayPayload payload = { float3(0.0, 0.0, 0.0) };

  TraceRay(
    kTLAS[NonUniformResourceIndex(pc.tlas)],
    RAY_FLAG_FORCE_OPAQUE,
    0xff,
    0,
    0,
    0,
    ray,
    payload
  );

  kTextures2DInOut[NonUniformResourceIndex(pc.outTexture)][launchID.xy] = float4(payload.color, 1.0);
}

float2 rotate(float2 v, float angle) {
  float2x2 r = float2x2(cos(angle), -sin(angle),
                        sin(angle),  cos(angle));
  return r * (v-0.5*DispatchRaysDimensions().xy);
}

// helper function for GLSL-style mod() that works with negative numbers
float mod(float x, float y) {
  return x - y * floor(x / y);
}

[shader("miss")]
void missMain(inout RayPayload payload) {
  float2 uv = rotate(DispatchRaysIndex().xy, 0.2 * pc.time);
  float2 pos = floor(uv / 64.0);
  payload.color = float3(mod(pos.x + mod(pos.y, 2.0), 2.0));
}

[shader("closesthit")]
void closestHitMain(inout RayPayload payload, in BuiltInTriangleIntersectionAttributes attribs) {
  float3 baryCoords = float3(
    1.0f - attribs.barycentrics.x - attribs.barycentrics.y,
    attribs.barycentrics.x,
    attribs.barycentrics.y
  );
  payload.color = baryCoords;
}
)";

const char* codeRayGen = R"(
#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_nonuniform_qualifier : require

layout (set = 0, binding = 2, rgba8) uniform image2D kTextures2DInOut[];
layout (set = 0, binding = 4) uniform accelerationStructureEXT kTLAS[];

layout(std430, buffer_reference) readonly buffer Camera {
  mat4 viewInverse;
  mat4 projInverse;
};

layout(push_constant) uniform constants {
  Camera cam;
  uint outTexture;
  uint tlas;
  float time;
};

layout(location = 0) rayPayloadEXT vec3 payload;

const float tmin = 0.1;
const float tmax = 500.0;

void main() {
  vec2 pixelCenter = gl_LaunchIDEXT.xy + vec2(0.5);
  vec2 d = 2.0 * (pixelCenter / gl_LaunchSizeEXT.xy) - 1.0;

  vec4 origin    = cam.viewInverse * vec4(0,0,0,1);
  vec4 target    = cam.projInverse * vec4(d, 1, 1);
  vec4 direction = cam.viewInverse * vec4(normalize(target.xyz), 0);

  payload = vec3(0.0);

  traceRayEXT(kTLAS[tlas], gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin.xyz, tmin, direction.xyz, tmax, 0);

  imageStore(kTextures2DInOut[outTexture], ivec2(gl_LaunchIDEXT.xy), vec4(payload, 1.0));
}
)";

const char* codeMiss = R"(
#version 460
#extension GL_EXT_ray_tracing : require

layout(location = 0) rayPayloadInEXT vec3 payload;

layout(push_constant) uniform constants {
  vec2 cam; // just an opaque buffer reference - no access required
  uint outTexture;
  uint tlas;
  float time;
};

vec2 rotate(vec2 v, float angle) {
  mat2 r = mat2(cos(angle), -sin(angle),
                sin(angle),  cos(angle));
  return r * (v-0.5*gl_LaunchSizeEXT.xy);
}

void main() {
  vec2 uv = rotate(gl_LaunchIDEXT.xy, 0.2 * time);
  vec2 pos = floor(uv / 64.0);
  payload = vec3(mod(pos.x + mod(pos.y, 2.0), 2.0));
})";

const char* codeClosestHit = R"(
#version 460
#extension GL_EXT_ray_tracing : require

layout(location = 0) rayPayloadInEXT vec3 payload;
hitAttributeEXT vec2 attribs;

void main() {
  const vec3 baryCoords = vec3(1.0f - attribs.x - attribs.y, attribs.x, attribs.y);
  payload = baryCoords;
}
)";

lvk::IContext* ctx_ = nullptr;

struct Resources {
  lvk::Holder<lvk::AccelStructHandle> BLAS;
  lvk::Holder<lvk::AccelStructHandle> TLAS;

  lvk::Holder<lvk::BufferHandle> vertexBuffer;
  lvk::Holder<lvk::BufferHandle> indexBuffer;
  lvk::Holder<lvk::BufferHandle> instancesBuffer;

  lvk::Holder<lvk::TextureHandle> storageImage;

  lvk::Holder<lvk::ShaderModuleHandle> raygen_;
  lvk::Holder<lvk::ShaderModuleHandle> miss_;
  lvk::Holder<lvk::ShaderModuleHandle> hit_;

  lvk::Holder<lvk::BufferHandle> ubo;

  lvk::Holder<lvk::RayTracingPipelineHandle> pipeline;
} res;

void createBottomLevelAccelerationStructure() {
  struct Vertex {
    float pos[3];
  };
  const float t = (1.0f + sqrtf(5.0f)) / 2.0f;
  const Vertex vertices[] = {
      {-1, t, 0},
      {1, t, 0},
      {-1, -t, 0},
      {1, -t, 0},

      {0, -1, t},
      {0, 1, t},
      {0, -1, -t},
      {0, 1, -t},

      {t, 0, -1},
      {t, 0, 1},
      {-t, 0, -1},
      {-t, 0, 1},
  };

  const uint32_t indices[] = {0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4,  11, 10, 2,  10, 7, 6, 7, 1, 8,
                              3, 9,  4, 3, 4, 2, 3, 2, 6, 3, 6, 8,  3, 8,  9,  4, 9, 5, 2, 4,  11, 6,  2,  10, 8,  6, 7, 9, 8, 1};

  const glm::mat3x4 transformMatrix(1.0f);

  res.vertexBuffer = ctx_->createBuffer({
      .usage = lvk::BufferUsageBits_AccelStructBuildInputReadOnly,
      .storage = lvk::StorageType_HostVisible,
      .size = sizeof(vertices),
      .data = vertices,
  });
  res.indexBuffer = ctx_->createBuffer({
      .usage = lvk::BufferUsageBits_AccelStructBuildInputReadOnly,
      .storage = lvk::StorageType_HostVisible,
      .size = sizeof(indices),
      .data = indices,
  });
  lvk::Holder<lvk::BufferHandle> transformBuffer = ctx_->createBuffer({
      .usage = lvk::BufferUsageBits_AccelStructBuildInputReadOnly,
      .storage = lvk::StorageType_HostVisible,
      .size = sizeof(glm::mat3x4),
      .data = &transformMatrix,
  });

  res.BLAS = ctx_->createAccelerationStructure({
      .type = lvk::AccelStructType_BLAS,
      .geometryType = lvk::AccelStructGeomType_Triangles,
      .vertexFormat = lvk::VertexFormat::Float3,
      .vertexBuffer = res.vertexBuffer,
      .numVertices = (uint32_t)LVK_ARRAY_NUM_ELEMENTS(vertices),
      .indexFormat = lvk::IndexFormat_UI32,
      .indexBuffer = res.indexBuffer,
      .transformBuffer = transformBuffer,
      .buildRange = {.primitiveCount = (uint32_t)LVK_ARRAY_NUM_ELEMENTS(indices) / 3},
      .debugName = "BLAS",
  });
}

void createTopLevelAccelerationStructure() {
  const lvk::AccelStructInstance instance{
      // clang-format off
      .transform = {.matrix = {1.0f, 0.0f, 0.0f, 0.0f,
                               0.0f, 1.0f, 0.0f, 0.0f,
                               0.0f, 0.0f, 1.0f, 0.0f}},
      // clang-format on
      .instanceCustomIndex = 0,
      .mask = 0xff,
      .instanceShaderBindingTableRecordOffset = 0,
      .flags = lvk::AccelStructInstanceFlagBits_TriangleFacingCullDisable,
      .accelerationStructureReference = ctx_->gpuAddress(res.BLAS),
  };

  // Buffer for instance data
  res.instancesBuffer = ctx_->createBuffer(lvk::BufferDesc{
      .usage = lvk::BufferUsageBits_AccelStructBuildInputReadOnly,
      .storage = lvk::StorageType_HostVisible,
      .size = sizeof(lvk::AccelStructInstance),
      .data = &instance,
      .debugName = "instanceBuffer",
  });

  res.TLAS = ctx_->createAccelerationStructure({
      .type = lvk::AccelStructType_TLAS,
      .geometryType = lvk::AccelStructGeomType_Instances,
      .instancesBuffer = res.instancesBuffer,
      .buildRange = {.primitiveCount = 1},
      .buildFlags = lvk::AccelStructBuildFlagBits_PreferFastTrace | lvk::AccelStructBuildFlagBits_AllowUpdate,
  });
}

VULKAN_APP_MAIN {
  const VulkanAppConfig cfg{
      .width = -80,
      .height = -80,
      .resizable = true,
  };
  VULKAN_APP_DECLARE(app, cfg);

  ctx_ = app.ctx_.get();

  createBottomLevelAccelerationStructure();
  createTopLevelAccelerationStructure();

  const struct UniformData {
    glm::mat4 viewInverse;
    glm::mat4 projInverse;
  } uniformData = {
      .viewInverse = glm::inverse(glm::translate(glm::mat4(1.0f), glm::vec3(0, 0, -5.0f))),
      .projInverse = glm::inverse(glm::perspective(glm::radians(60.0f), (float)app.width_ / (float)app.height_, 0.1f, 1000.0f)),
  };

  res.ubo = ctx_->createBuffer(lvk::BufferDesc{
      .usage = lvk::BufferUsageBits_Storage,
      .storage = lvk::StorageType_Device,
      .size = sizeof(uniformData),
      .data = &uniformData,
      .debugName = "cameraBuffer",
  });

  res.storageImage = ctx_->createTexture(
      lvk::TextureDesc{
          .type = lvk::TextureType_2D,
          .format = lvk::Format_BGRA_UN8,
          .dimensions = {(uint32_t)app.width_, (uint32_t)app.height_, 1u},
          .numLayers = 1,
          .numSamples = 1,
          .usage = lvk::TextureUsageBits_Storage,
      },
      "storageImage");

#if defined(LVK_DEMO_WITH_SLANG)
  res.raygen_ = ctx_->createShaderModule({codeSlang, lvk::Stage_RayGen, "Shader Module: main (raygen)"});
  res.miss_ = ctx_->createShaderModule({codeSlang, lvk::Stage_Miss, "Shader Module: main (miss)"});
  res.hit_ = ctx_->createShaderModule({codeSlang, lvk::Stage_ClosestHit, "Shader Module: main (closesthit)"});
#else
  res.raygen_ = ctx_->createShaderModule({codeRayGen, lvk::Stage_RayGen, "Shader Module: main (raygen)"});
  res.miss_ = ctx_->createShaderModule({codeMiss, lvk::Stage_Miss, "Shader Module: main (miss)"});
  res.hit_ = ctx_->createShaderModule({codeClosestHit, lvk::Stage_ClosestHit, "Shader Module: main (closesthit)"});
#endif // defined(LVK_DEMO_WITH_SLANG)

  res.pipeline = ctx_->createRayTracingPipeline(lvk::RayTracingPipelineDesc{
      .smRayGen = {lvk::ShaderModuleHandle(res.raygen_)},
      .smMiss = {lvk::ShaderModuleHandle(res.miss_)},
      .hitGroups = {{.smClosestHit = res.hit_}},
  });

  app.run([&](uint32_t width, uint32_t height, float aspectRatio, float deltaSeconds) {
    lvk::ICommandBuffer& buffer = ctx_->acquireCommandBuffer();

    const glm::mat3x4 transformMatrix = glm::rotate(glm::mat4(1.0f), (float)glfwGetTime(), glm::vec3(1, 1, 1));
    ctx_->upload(res.instancesBuffer, &transformMatrix, sizeof(transformMatrix), offsetof(lvk::AccelStructInstance, transform));

    struct {
      uint64_t camBuffer;
      uint32_t outTexture;
      uint32_t tlas;
      float time;
    } pc = {
        .camBuffer = ctx_->gpuAddress(res.ubo),
        .outTexture = res.storageImage.index(),
        .tlas = res.TLAS.index(),
        .time = (float)glfwGetTime(),
    };

    buffer.cmdUpdateTLAS(res.TLAS, res.instancesBuffer);
    buffer.cmdBindRayTracingPipeline(res.pipeline);
    buffer.cmdPushConstants(pc);
    buffer.cmdTraceRays(width, height, 1, {.textures = {lvk::TextureHandle(res.storageImage)}});
    buffer.cmdCopyImage(res.storageImage, ctx_->getCurrentSwapchainTexture(), ctx_->getDimensions(ctx_->getCurrentSwapchainTexture()));

    ctx_->submit(buffer, ctx_->getCurrentSwapchainTexture());
  });

  // destroy all the Vulkan stuff before closing the window
  res = {};

  VULKAN_APP_EXIT();
}

```

`samples/RTX_002_AO.cpp`:

```cpp
/*
 * LightweightVK
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#include "Bistro.h"
#include "VulkanApp.h"

// scene navigation
#define USE_SPONZA 0

#if USE_SPONZA
#define MODEL_PATH "src/Sponza/sponza.obj"
#define CACHE_FILE_NAME "cache3.data"
vec3 lightDir_ = normalize(vec3(-0.5f, 0.85f, -0.05f));
#else
#define MODEL_PATH "src/bistro/Exterior/exterior.obj"
#define CACHE_FILE_NAME "cache2.data"
vec3 lightDir_ = normalize(vec3(0.032f, 0.835f, 0.549f));
#endif

#if defined(ANDROID)
constexpr int kNumSamplesMSAA = 1;
constexpr int kFramebufferScalar = 2;
#else
constexpr int kNumSamplesMSAA = 4;
constexpr int kFramebufferScalar = 1;
#endif // ANDROID

const char* codeFullscreenSlang = R"(
struct PushConstants {
  uint tex;
  uint denoise;
  float sigma;
  float ksigma;
  float threshold;
};

[[vk::push_constant]] PushConstants pc;

struct VSOutput {
  float2 uv : TEXCOORD0;
  float4 position : SV_Position;
};

#define INV_SQRT_OF_2PI 0.39894228040143267793994605993439  // 1.0/SQRT_OF_2PI
#define INV_PI 0.31830988618379067153776752674503

// https://github.com/BrutPitt/glslSmartDeNoise
/*
//  Copyright (c) 2018-2024 Michele Morrone
//  All rights reserved.
//  https://michelemorrone.eu - https://brutpitt.com
//  X: https://x.com/BrutPitt - GitHub: https://github.com/BrutPitt
//  direct mail: brutpitt(at)gmail.com - me(at)michelemorrone.eu
//  This software is distributed under the terms of the BSD 2-Clause license
*/
float4 smartDeNoise(uint tex, float2 uv, float sigma, float kSigma, float threshold) {
  float radius = round(kSigma * sigma);
  float radQ = radius * radius;
  float invSigmaQx2 = 0.5 / (sigma * sigma);      // 1.0 / (sigma^2 * 2.0)
  float invSigmaQx2PI = INV_PI * invSigmaQx2;     // 1/(2 * PI * sigma^2)
  float invThresholdSqx2 = 0.5 / (threshold * threshold);     // 1.0 / (sigma^2 * 2.0)
  float invThresholdSqrt2PI = INV_SQRT_OF_2PI / threshold;   // 1.0 / (sqrt(2*PI) * sigma^2)

  float4 centrPx = textureBindless2D(tex, 0, uv);
  float zBuff = 0.0;
  float4 aBuff = float4(0.0, 0.0, 0.0, 0.0);
  float2 size = float2(textureBindlessSize2D(tex));

  float2 d;
  for (d.x = -radius; d.x <= radius; d.x++) {
    float pt = sqrt(radQ - d.x * d.x);       // pt = yRadius: have circular trend
    for (d.y = -pt; d.y <= pt; d.y++) {
      float blurFactor = exp(-dot(d, d) * invSigmaQx2) * invSigmaQx2PI;
      float4 walkPx = textureBindless2D(tex, 0, uv + d / size);
      float4 dC = walkPx - centrPx;
      float deltaFactor = exp(-dot(dC, dC) * invThresholdSqx2) * invThresholdSqrt2PI * blurFactor;
      zBuff += deltaFactor;
      aBuff += deltaFactor * walkPx;
    }
  }
  return aBuff / zBuff;
}

[shader("vertex")]
VSOutput vertexMain(uint vertexID : SV_VertexID) {
  VSOutput out;
  // generate a triangle covering the entire screen
  out.uv = float2((vertexID << 1) & 2, vertexID & 2);
  out.position = float4(out.uv * float2(2.0, -2.0) + float2(-1.0, 1.0), 0.0, 1.0);
  return out;
}

[shader("fragment")]
float4 fragmentMain(VSOutput input) : SV_Target {
  return pc.denoise > 0 ?
      smartDeNoise(pc.tex, input.uv, pc.sigma, pc.ksigma, pc.threshold) :
      textureBindless2D(pc.tex, 0, input.uv);
}
)";

const char* codeZPrepassSlang = R"(
struct PerFrame {
  float4x4 proj;
  float4x4 view;
};

struct PerObject {
  float4x4 model;
  float4x4 normal;
};

struct PushConstants {
  PerFrame* perFrame;
  PerObject* perObject;
  uint64_t padding; // materials
};

[[vk::push_constant]] PushConstants pc;

[shader("vertex")]
float4 vertexMain(float3 pos : POSITION) : SV_Position {
  float4x4 proj = pc.perFrame->proj;
  float4x4 view = pc.perFrame->view;
  float4x4 model = pc.perObject->model;

  return proj * view * model * float4(pos, 1.0);
}

[shader("fragment")]
void fragmentMain() {
  // empty fragment shader for Z-prepass
}
)";

const char* codeSlang = R"(
struct Material {
  float4 ambient;
  float4 diffuse;
};

struct PerFrame {
  float4x4 proj;
  float4x4 view;
  float4x4 light;
};

struct PerObject {
  float4x4 model;
  float4x4 normal;
};

struct Materials {
  Material mtl[];
};

struct PushConstants {
  float4 lightDir;
  PerFrame* perFrame;
  PerObject* perObject;
  Materials* materials;
  uint tlas;
  bool enableShadows;
  bool enableAO;
  bool aoDistanceBased;
  int aoSamples;
  float aoRadius;
  float aoPower;
  uint frameId;
};

[[vk::push_constant]] PushConstants pc;

struct PerVertex {
  float3 worldPos;
  float3 normal;
  float2 uv;
  float4 Ka;
  float4 Kd;
};

struct VSOutput {
  PerVertex vtx : TEXCOORD0;
  float4 position : SV_Position;
};

//
// https://www.shadertoy.com/view/llfcRl
float2 unpackSnorm2x8(uint d) {
  return float2(uint2(d, d >> 8) & 255u) / 127.5 - 1.0;
}

float3 unpackOctahedral16(uint data) {
  float2 v = unpackSnorm2x8(data);
  // https://x.com/Stubbesaurus/status/937994790553227264
  float3 n = float3(v, 1.0 - abs(v.x) - abs(v.y));
  float t = max(-n.z, 0.0);
  n.x += (n.x > 0.0) ? -t : t;
  n.y += (n.y > 0.0) ? -t : t;
  return normalize(n);
}

[shader("vertex")]
VSOutput vertexMain(
  float3 pos : POSITION,
  float2 uv : TEXCOORD0,
  uint normal : TEXCOORD1,
  uint mtlIndex : TEXCOORD2
) {
  VSOutput out;

  float4x4 proj = pc.perFrame->proj;
  float4x4 view = pc.perFrame->view;
  float4x4 model = pc.perObject->model;

  out.position = proj * view * model * float4(pos, 1.0);

  // compute the normal in world-space
  out.vtx.worldPos = (model * float4(pos, 1.0)).xyz;
  out.vtx.normal = normalize((float3x3)pc.perObject->normal * unpackOctahedral16(normal));
  out.vtx.uv = uv;
  out.vtx.Ka = pc.materials->mtl[mtlIndex].ambient;
  out.vtx.Kd = pc.materials->mtl[mtlIndex].diffuse;

  return out;
}

void computeTBN(in float3 n, out float3 x, out float3 y) {
  float yz = -n.y * n.z;
  y = normalize(((abs(n.z) > 0.9999) ? float3(-n.x * n.y, 1.0 - n.y * n.y, yz) :
                                       float3(-n.x * n.z, yz, 1.0 - n.z * n.z)));
  x = cross(y, n);
}

float traceAO(inout RayQuery<RAY_FLAG_NONE> rq, float3 origin, float3 dir) {
  RayDesc ray;
  ray.Origin = origin;
  ray.Direction = dir;
  ray.TMin = 0.0f;
  ray.TMax = pc.aoRadius;

  uint flags = pc.aoDistanceBased ? RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH : RAY_FLAG_NONE;
  rq.TraceRayInline(kTLAS[NonUniformResourceIndex(pc.tlas)], flags, 0xFF, ray);

  while (rq.Proceed()) {}

  if (rq.CommittedStatus() != COMMITTED_NOTHING) {
    if (pc.aoDistanceBased) return 1;
    float length = 1.0 - (rq.CommittedRayT() / pc.aoRadius);
    return length;
  }
  return 0;
}

// generate a random unsigned int in [0, 2^24) given the previous RNG state using the Numerical Recipes LCG
uint lcg(inout uint prev) {
  uint LCG_A = 1664525u;
  uint LCG_C = 1013904223u;
  prev = (LCG_A * prev + LCG_C);
  return prev & 0x00FFFFFF;
}

// Generate a random float in [0, 1) given the previous RNG state
float rnd(inout uint seed) {
  return (float(lcg(seed)) / float(0x01000000));
}

// Generate a random unsigned int from two unsigned int values, using 16 pairs of rounds of the Tiny Encryption Algorithm
uint tea(uint val0, uint val1) {
  uint v0 = val0;
  uint v1 = val1;
  uint s0 = 0;
  for(uint n = 0; n < 16; n++) {
    s0 += 0x9e3779b9;
    v0 += ((v1 << 4) + 0xa341316c) ^ (v1 + s0) ^ ((v1 >> 5) + 0xc8013ea4);
    v1 += ((v0 << 4) + 0xad90777d) ^ (v0 + s0) ^ ((v0 >> 5) + 0x7e95761e);
  }
  return v0;
}

[shader("fragment")]
float4 fragmentMain(VSOutput input, float4 fragCoord : SV_Position) : SV_Target {
  PerVertex vtx = input.vtx;
  float3 n = normalize(vtx.normal);
  float occlusion = 1.0;

  // ambient occlusion
  if (pc.enableAO) {
    float3 origin = vtx.worldPos + n * 0.001; // avoid self-occlusion
    float3 tangent, bitangent;
    computeTBN(n, tangent, bitangent);
    uint seed = tea(uint(fragCoord.y * 4003.0 + fragCoord.x), pc.frameId); // prime
    float occl = 0.0;
    for(int i = 0; i < pc.aoSamples; i++) {
      float r1 = rnd(seed);
      float r2 = rnd(seed);
      float sq = sqrt(1.0 - r2);
      float phi = 2 * 3.141592653589 * r1;
      float3 direction = float3(cos(phi) * sq, sin(phi) * sq, sqrt(r2));
      direction = direction.x * tangent + direction.y * bitangent + direction.z * n;
      RayQuery<RAY_FLAG_NONE> rayQuery;
      occl += traceAO(rayQuery, origin, direction);
    }
    occlusion = 1 - (occl / pc.aoSamples);
    occlusion = pow(clamp(occlusion, 0, 1), pc.aoPower);
  }

  // directional shadow
  if (pc.enableShadows) {
    RayDesc ray;
    ray.Origin = vtx.worldPos;
    ray.Direction = pc.lightDir.xyz;
    ray.TMin = 0.01;
    ray.TMax = 1000.0;

    RayQuery<RAY_FLAG_NONE> rq;
    rq.TraceRayInline(kTLAS[NonUniformResourceIndex(pc.tlas)], RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH, 0xff, ray);

    while (rq.Proceed()) {}

    if (rq.CommittedStatus() != COMMITTED_NOTHING) occlusion *= 0.5;
  }

  float NdotL1 = clamp(dot(n, normalize(float3(-1, 1, 1))), 0.0, 1.0);
  float NdotL2 = clamp(dot(n, normalize(float3(-1, 1, -1))), 0.0, 1.0);
  float NdotL = 1.0 * (NdotL1 + NdotL2); // just make a bit brighter

  return vtx.Ka + vtx.Kd * NdotL * occlusion;
}
)";

const char* kCodeFullscreenVS = R"(
layout (location=0) out vec2 uv;
void main() {
  // generate a triangle covering the entire screen
  uv = vec2((gl_VertexIndex << 1) & 2, gl_VertexIndex & 2);
  gl_Position = vec4(uv * vec2(2, -2) + vec2(-1, 1), 0.0, 1.0);
}
)";

const char* kCodeFullscreenFS = R"(
layout (location=0) in vec2 uv;
layout (location=0) out vec4 out_FragColor;

layout(push_constant) uniform constants {
   uint tex;
   uint denoise;
   float sigma;
   float ksigma;
   float threshold;
} pc;

#define INV_SQRT_OF_2PI 0.39894228040143267793994605993439  // 1.0/SQRT_OF_2PI
#define INV_PI 0.31830988618379067153776752674503

// https://github.com/BrutPitt/glslSmartDeNoise
/*
//  Copyright (c) 2018-2024 Michele Morrone
//  All rights reserved.
//  https://michelemorrone.eu - https://brutpitt.com
//  X: https://x.com/BrutPitt - GitHub: https://github.com/BrutPitt
//  direct mail: brutpitt(at)gmail.com - me(at)michelemorrone.eu
//  This software is distributed under the terms of the BSD 2-Clause license
*/
vec4 smartDeNoise(uint tex, vec2 uv, float sigma, float kSigma, float threshold) {
  float radius = round(kSigma*sigma);
  float radQ   = radius * radius;

  float invSigmaQx2   = .5 / (sigma * sigma);      // 1.0 / (sigma^2 * 2.0)
  float invSigmaQx2PI = INV_PI * invSigmaQx2;    // 1/(2 * PI * sigma^2)

  float invThresholdSqx2    = .5 / (threshold * threshold);     // 1.0 / (sigma^2 * 2.0)
  float invThresholdSqrt2PI = INV_SQRT_OF_2PI / threshold;   // 1.0 / (sqrt(2*PI) * sigma^2)

  vec4 centrPx = textureBindless2D(tex, 0, uv);

  float zBuff = 0.0;
  vec4 aBuff  = vec4(0.0);
  vec2 size   = vec2(textureBindlessSize2D(tex));

  vec2 d;
  for (d.x=-radius; d.x <= radius; d.x++) {
    float pt = sqrt(radQ-d.x*d.x);       // pt = yRadius: have circular trend
    for (d.y=-pt; d.y <= pt; d.y++) {
      float blurFactor = exp( -dot(d , d) * invSigmaQx2 ) * invSigmaQx2PI;

      vec4 walkPx = textureBindless2D(tex, 0, uv+d/size);
      vec4 dC = walkPx-centrPx;
      float deltaFactor = exp( -dot(dC, dC) * invThresholdSqx2) * invThresholdSqrt2PI * blurFactor;

      zBuff += deltaFactor;
      aBuff += deltaFactor*walkPx;
    }
  }
  return aBuff/zBuff;
}

void main() {
  out_FragColor = pc.denoise > 0 ?
      smartDeNoise(pc.tex, uv, pc.sigma, pc.ksigma, pc.threshold) :
      textureBindless2D(pc.tex, 0, uv);
}
)";

const char* kCodeZPrepassVS = R"(
layout (location=0) in vec3 pos;

layout(std430, buffer_reference) readonly buffer PerFrame {
  mat4 proj;
  mat4 view;
};

layout(std430, buffer_reference) readonly buffer PerObject {
  mat4 model;
  mat4 normal;
};

layout(push_constant) uniform constants {
  PerFrame perFrame;
  PerObject perObject;
  vec2 padding; // materials
} pc;

void main() {
  mat4 proj = pc.perFrame.proj;
  mat4 view = pc.perFrame.view;
  mat4 model = pc.perObject.model;
  gl_Position = proj * view * model * vec4(pos, 1.0);
}
)";

const char* kCodeZPrepassFS = R"(
#version 460

void main() {
  // empty fragment shader for Z-prepass
};
)";

const char* kCodeVS = R"(
layout (location=0) in vec3 pos;
layout (location=1) in vec2 uv;
layout (location=2) in uint normal; // Octahedral 16-bit https://www.shadertoy.com/view/llfcRl
layout (location=3) in uint mtlIndex;

struct Material {
   vec4 ambient;
   vec4 diffuse;
};

layout(std430, buffer_reference) readonly buffer PerFrame {
  mat4 proj;
  mat4 view;
};

layout(std430, buffer_reference) readonly buffer PerObject {
  mat4 model;
  mat4 normal;
};

layout(std430, buffer_reference) readonly buffer Materials {
  Material mtl[];
};

layout(push_constant) uniform constants {
  vec4 lightDir;
  PerFrame perFrame;
  PerObject perObject;
  Materials materials;
  uint tlas;
} pc;

// output
struct PerVertex {
  vec3 worldPos;
  vec3 normal;
  vec2 uv;
  vec4 Ka;
  vec4 Kd;
};
layout (location=0) out PerVertex vtx;
//

// https://www.shadertoy.com/view/llfcRl
vec2 unpackSnorm2x8(uint d) {
  return vec2(uvec2(d, d >> 8) & 255u) / 127.5 - 1.0;
}
vec3 unpackOctahedral16(uint data) {
  vec2 v = unpackSnorm2x8(data);
  // https://x.com/Stubbesaurus/status/937994790553227264
  vec3 n = vec3(v, 1.0 - abs(v.x) - abs(v.y));
  float t = max(-n.z, 0.0);
  n.x += (n.x > 0.0) ? -t : t;
  n.y += (n.y > 0.0) ? -t : t;
  return normalize(n);
}
//

void main() {
  mat4 proj = pc.perFrame.proj;
  mat4 view = pc.perFrame.view;
  mat4 model = pc.perObject.model;
  gl_Position = proj * view * model * vec4(pos, 1.0);
  // compute the normal in world-space
  vtx.worldPos = (model * vec4(pos, 1.0)).xyz;
  vtx.normal = normalize(mat3(pc.perObject.normal) * unpackOctahedral16(normal));
  vtx.uv = uv;
  vtx.Ka = pc.materials.mtl[mtlIndex].ambient;
  vtx.Kd = pc.materials.mtl[mtlIndex].diffuse;
}
)";

const char* kCodeFS = R"(
#version 460
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_samplerless_texture_functions : require
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_ray_query : require

layout(set = 0, binding = 0) uniform texture2D kTextures2D[];
layout(set = 0, binding = 4) uniform accelerationStructureEXT kTLAS[];

layout(std430, buffer_reference) readonly buffer PerFrame {
  mat4 proj;
  mat4 view;
  mat4 light;
};

struct PerVertex {
  vec3 worldPos;
  vec3 normal;
  vec2 uv;
  vec4 Ka;
  vec4 Kd;
};

layout(push_constant) uniform constants {
  vec4 lightDir;
  PerFrame perFrame;
  uvec2 dummy0;
  uvec2 dummy1;
  uint tlas;
  bool enableShadows;
  bool enableAO;
  bool aoDistanceBased;
  int aoSamples;
  float aoRadius;
  float aoPower;
  uint frameId;
} pc;

layout (location=0) in PerVertex vtx;

layout (location=0) out vec4 out_FragColor;

void computeTBN(in vec3 n, out vec3 x, out vec3 y) {
  float yz = -n.y * n.z;
  y = normalize(((abs(n.z) > 0.9999) ? vec3(-n.x * n.y, 1.0 - n.y * n.y, yz) : vec3(-n.x * n.z, yz, 1.0 - n.z * n.z)));
  x = cross(y, n);
}

float traceAO(rayQueryEXT rq, vec3 origin, vec3 dir) {
  uint flags = pc.aoDistanceBased ? gl_RayFlagsTerminateOnFirstHitEXT : gl_RayFlagsNoneEXT;

  rayQueryInitializeEXT(rq, kTLAS[pc.tlas], flags, 0xFF, origin, 0.0f, dir, pc.aoRadius);

  while (rayQueryProceedEXT(rq)) {}

  if (rayQueryGetIntersectionTypeEXT(rq, true) != gl_RayQueryCommittedIntersectionNoneEXT) {
    if (pc.aoDistanceBased) return 1;
    float length = 1.0 - (rayQueryGetIntersectionTEXT(rq, true) / pc.aoRadius);
    return length;
  }

  return 0;
}

// generate a random unsigned int in [0, 2^24) given the previous RNG state using the Numerical Recipes LCG
uint lcg(inout uint prev) {
  uint LCG_A = 1664525u;
  uint LCG_C = 1013904223u;
  prev       = (LCG_A * prev + LCG_C);
  return prev & 0x00FFFFFF;
}

// Generate a random float in [0, 1) given the previous RNG state
float rnd(inout uint seed) {
  return (float(lcg(seed)) / float(0x01000000));
}

// Generate a random unsigned int from two unsigned int values, using 16 pairs of rounds of the Tiny Encryption Algorithm. See Zafar, Olano, and Curtis,
// "GPU Random Numbers via the Tiny Encryption Algorithm"
uint tea(uint val0, uint val1) {
  uint v0 = val0;
  uint v1 = val1;
  uint s0 = 0;

  for(uint n = 0; n < 16; n++) {
    s0 += 0x9e3779b9;
    v0 += ((v1 << 4) + 0xa341316c) ^ (v1 + s0) ^ ((v1 >> 5) + 0xc8013ea4);
    v1 += ((v0 << 4) + 0xad90777d) ^ (v0 + s0) ^ ((v0 >> 5) + 0x7e95761e);
  }

  return v0;
}

void main() {
  vec3 n = normalize(vtx.normal);

  float occlusion = 1.0;

  // ambient occlusion
  if (pc.enableAO)
  {
    vec3 origin = vtx.worldPos + n * 0.001; // avoid self-occlusion

    vec3 tangent, bitangent;
    computeTBN(n, tangent, bitangent);

    uint seed = tea(uint(gl_FragCoord.y * 4003.0 + gl_FragCoord.x), pc.frameId); // prime

    float occl = 0.0;

    for(int i = 0; i < pc.aoSamples; i++) {
      float r1        = rnd(seed);
      float r2        = rnd(seed);
      float sq        = sqrt(1.0 - r2);
      float phi       = 2 * 3.141592653589 * r1;
      vec3  direction = vec3(cos(phi) * sq, sin(phi) * sq, sqrt(r2));
      direction       = direction.x * tangent + direction.y * bitangent + direction.z * n;
      rayQueryEXT rayQuery;
      occl += traceAO(rayQuery, origin, direction);
    }
    occlusion = 1 - (occl / pc.aoSamples);
    occlusion = pow(clamp(occlusion, 0, 1), pc.aoPower);
  }
  // directional shadow
  if (pc.enableShadows) {
    rayQueryEXT rq;
    rayQueryInitializeEXT(rq, kTLAS[pc.tlas], gl_RayFlagsTerminateOnFirstHitEXT, 0xff, vtx.worldPos, 0.01, pc.lightDir.xyz, +1000.0);
    while (rayQueryProceedEXT(rq)) {}
    if (rayQueryGetIntersectionTypeEXT(rq, true) != gl_RayQueryCommittedIntersectionNoneEXT) occlusion *= 0.5;
  }

  float NdotL1 = clamp(dot(n, normalize(vec3(-1, 1, 1))),  0.0, 1.0);
  float NdotL2 = clamp(dot(n, normalize(vec3(-1, 1, -1))), 0.0, 1.0);
  float NdotL = 1.0 * (NdotL1 + NdotL2); // just make a bit brighter

  out_FragColor = vtx.Ka + vtx.Kd * NdotL * occlusion;
};
)";

lvk::IContext* ctx_ = nullptr;

struct {
  lvk::Holder<lvk::TextureHandle> fbOffscreenColor_;
  lvk::Holder<lvk::TextureHandle> fbOffscreenDepth_;
  lvk::Holder<lvk::TextureHandle> fbOffscreenResolve_;
  lvk::Holder<lvk::ShaderModuleHandle> smMeshVert_;
  lvk::Holder<lvk::ShaderModuleHandle> smMeshFrag_;
  lvk::Holder<lvk::ShaderModuleHandle> smMeshVertZPrepass_;
  lvk::Holder<lvk::ShaderModuleHandle> smMeshFragZPrepass_;
  lvk::Holder<lvk::ShaderModuleHandle> smFullscreenVert_;
  lvk::Holder<lvk::ShaderModuleHandle> smFullscreenFrag_;
  lvk::Holder<lvk::RenderPipelineHandle> renderPipelineState_Mesh_;
  lvk::Holder<lvk::RenderPipelineHandle> renderPipelineState_MeshZPrepass_;
  lvk::Holder<lvk::RenderPipelineHandle> renderPipelineState_Fullscreen_;
  lvk::Holder<lvk::BufferHandle> vb0_, ib0_; // buffers for vertices and indices
  lvk::Holder<lvk::BufferHandle> sbMaterials_; // storage buffer for materials
  lvk::Holder<lvk::BufferHandle> sbInstances_; // storage buffer for TLAS instances
  lvk::Holder<lvk::BufferHandle> ubPerFrame_;
  lvk::Holder<lvk::BufferHandle> ubPerObject_;
  std::vector<lvk::Holder<lvk::AccelStructHandle>> BLAS;
  lvk::Holder<lvk::AccelStructHandle> TLAS;
} res;

bool enableShadows_ = true;
bool enableAO_ = true;

float denoiseSigma_ = 1.2f;
float denoiseKSigma_ = 6.0f;
float denoiseThreshold_ = 0.43f;
bool enableDenoise_ = false;

int aoSamples_ = 2;
bool aoDistanceBased_ = true;

float aoRadius_ = 16.0f;
float aoPower_ = 2.0f;
bool timeVaryingNoise = true;

uint32_t frameId = 0;

struct UniformsPerFrame {
  mat4 proj;
  mat4 view;
};

struct UniformsPerObject {
  mat4 model;
  mat4 normal;
};

// this goes into our GLSL shaders
struct GPUMaterial {
  vec4 ambient = vec4(0.0f);
  vec4 diffuse = vec4(0.0f);
};

static_assert(sizeof(GPUMaterial) % 16 == 0);

std::vector<GPUMaterial> materials_;

bool initModel(const std::string& folderContentRoot) {
  const std::string cacheFileName = folderContentRoot + CACHE_FILE_NAME;

  if (!loadFromCache(cacheFileName.c_str())) {
    if (!LVK_VERIFY(loadAndCache(folderContentRoot, cacheFileName.c_str(), MODEL_PATH))) {
      LVK_ASSERT_MSG(false, "Cannot load 3D model");
      return false;
    }
  }

  for (const auto& mtl : cachedMaterials_) {
    materials_.push_back(GPUMaterial{vec4(mtl.ambient, 1.0f), vec4(mtl.diffuse, 1.0f)});
  }
  res.sbMaterials_ = ctx_->createBuffer({
      .usage = lvk::BufferUsageBits_Storage,
      .storage = lvk::StorageType_Device,
      .size = sizeof(GPUMaterial) * materials_.size(),
      .data = materials_.data(),
      .debugName = "Buffer: materials",
  });

  res.vb0_ = ctx_->createBuffer({
      .usage = lvk::BufferUsageBits_Vertex | lvk::BufferUsageBits_AccelStructBuildInputReadOnly,
      .storage = lvk::StorageType_Device,
      .size = sizeof(VertexData) * vertexData_.size(),
      .data = vertexData_.data(),
      .debugName = "Buffer: vertex",
  });
  res.ib0_ = ctx_->createBuffer({
      .usage = lvk::BufferUsageBits_Index | lvk::BufferUsageBits_AccelStructBuildInputReadOnly,
      .storage = lvk::StorageType_Device,
      .size = sizeof(uint32_t) * indexData_.size(),
      .data = indexData_.data(),
      .debugName = "Buffer: index",
  });

  const glm::mat3x4 transformMatrix(1.0f);

  lvk::Holder<lvk::BufferHandle> transformBuffer = ctx_->createBuffer({
      .usage = lvk::BufferUsageBits_AccelStructBuildInputReadOnly,
      .storage = lvk::StorageType_HostVisible,
      .size = sizeof(glm::mat3x4),
      .data = &transformMatrix,
  });

  const uint32_t totalPrimitiveCount = (uint32_t)indexData_.size() / 3;
  lvk::AccelStructDesc blasDesc{
      .type = lvk::AccelStructType_BLAS,
      .geometryType = lvk::AccelStructGeomType_Triangles,
      .vertexFormat = lvk::VertexFormat::Float3,
      .vertexBuffer = res.vb0_,
      .vertexStride = sizeof(VertexData),
      .numVertices = (uint32_t)vertexData_.size(),
      .indexFormat = lvk::IndexFormat_UI32,
      .indexBuffer = res.ib0_,
      .transformBuffer = transformBuffer,
      .buildRange = {.primitiveCount = totalPrimitiveCount},
      .buildFlags = lvk::AccelStructBuildFlagBits_PreferFastTrace,
      .debugName = "BLAS",
  };
  const lvk::AccelStructSizes blasSizes = ctx_->getAccelStructSizes(blasDesc);
  LLOGL("Full model BLAS sizes (bytes):\n   buildScratchSize = %llu,\n   accelerationStructureSize = %llu\n",
        blasSizes.buildScratchSize,
        blasSizes.accelerationStructureSize);
  const uint32_t maxStorageBufferSize = ctx_->getMaxStorageBufferRange();

  // Calculate number of BLAS
  const uint32_t requiredBlasCount = [&blasSizes, maxStorageBufferSize]() {
    const uint32_t count1 = blasSizes.buildScratchSize / maxStorageBufferSize;
    const uint32_t count2 = blasSizes.accelerationStructureSize / maxStorageBufferSize;
    return 1 + (count1 > count2 ? count1 : count2);
  }();
  blasDesc.buildRange.primitiveCount = totalPrimitiveCount / requiredBlasCount;

  LVK_ASSERT(requiredBlasCount > 0);
  LLOGL("maxStorageBufferSize = %u bytes\nNumber of BLAS = %u\n", maxStorageBufferSize, requiredBlasCount);

  const glm::mat3x4 transform(glm::scale(mat4(1.0f), vec3(0.05f)));
  res.BLAS.reserve(requiredBlasCount);

  std::vector<lvk::AccelStructInstance> instances;
  instances.reserve(requiredBlasCount);
  const uint32_t primitiveCount = blasDesc.buildRange.primitiveCount;
  for (uint32_t i = 0; i < totalPrimitiveCount; i += primitiveCount) {
    const int rest = (int)totalPrimitiveCount - i;
    blasDesc.buildRange.primitiveOffset = i * 3 * sizeof(uint32_t);
    blasDesc.buildRange.primitiveCount = (primitiveCount < rest) ? primitiveCount : rest;
    res.BLAS.emplace_back(ctx_->createAccelerationStructure(blasDesc));
    instances.emplace_back(lvk::AccelStructInstance{
        .transform = (const lvk::mat3x4&)transform,
        .instanceCustomIndex = 0,
        .mask = 0xff,
        .instanceShaderBindingTableRecordOffset = 0,
        .flags = lvk::AccelStructInstanceFlagBits_TriangleFacingCullDisable,
        .accelerationStructureReference = ctx_->gpuAddress(res.BLAS.back()),
    });
  }

  // Buffer for instance data
  res.sbInstances_ = ctx_->createBuffer(lvk::BufferDesc{
      .usage = lvk::BufferUsageBits_AccelStructBuildInputReadOnly,
      .storage = lvk::StorageType_HostVisible,
      .size = sizeof(lvk::AccelStructInstance) * instances.size(),
      .data = instances.data(),
      .debugName = "sbInstances_",
  });

  res.TLAS = ctx_->createAccelerationStructure({
      .type = lvk::AccelStructType_TLAS,
      .geometryType = lvk::AccelStructGeomType_Instances,
      .instancesBuffer = res.sbInstances_,
      .buildRange = {.primitiveCount = (uint32_t)instances.size()},
      .buildFlags = lvk::AccelStructBuildFlagBits_PreferFastTrace,
  });

  return true;
}

[[nodiscard]] lvk::Framebuffer createOffscreenFramebuffer(uint32_t w, uint32_t h) {
  lvk::TextureDesc descDepth = {
      .type = lvk::TextureType_2D,
      .format = lvk::Format_Z_UN24,
      .dimensions = {w, h},
      .usage = lvk::TextureUsageBits_Attachment | lvk::TextureUsageBits_Sampled,
      .numMipLevels = lvk::calcNumMipLevels(w, h),
      .debugName = "Offscreen framebuffer (d)",
  };
  if (kNumSamplesMSAA > 1) {
    descDepth.usage = lvk::TextureUsageBits_Attachment;
    descDepth.numSamples = kNumSamplesMSAA;
    descDepth.numMipLevels = 1;
  }

  const uint8_t usage = lvk::TextureUsageBits_Attachment | lvk::TextureUsageBits_Sampled | lvk::TextureUsageBits_Storage;
  const lvk::Format format = lvk::Format_RGBA_UN8;

  lvk::TextureDesc descColor = {
      .type = lvk::TextureType_2D,
      .format = format,
      .dimensions = {w, h},
      .usage = usage,
      .numMipLevels = lvk::calcNumMipLevels(w, h),
      .debugName = "Offscreen framebuffer (color)",
  };
  if (kNumSamplesMSAA > 1) {
    descColor.usage = lvk::TextureUsageBits_Attachment;
    descColor.numSamples = kNumSamplesMSAA;
    descColor.numMipLevels = 1;
  }

  res.fbOffscreenColor_ = ctx_->createTexture(descColor);
  res.fbOffscreenDepth_ = ctx_->createTexture(descDepth);
  lvk::Framebuffer fb = {
      .color = {{.texture = res.fbOffscreenColor_}},
      .depthStencil = {.texture = res.fbOffscreenDepth_},
  };

  if (kNumSamplesMSAA > 1) {
    res.fbOffscreenResolve_ = ctx_->createTexture({.type = lvk::TextureType_2D,
                                                   .format = format,
                                                   .dimensions = {w, h},
                                                   .usage = usage,
                                                   .debugName = "Offscreen framebuffer (color resolve)"});
    fb.color[0].resolveTexture = res.fbOffscreenResolve_;
  }

  return fb;
}

VULKAN_APP_MAIN {
  const VulkanAppConfig cfg{
      .width = 0,
      .height = 0,
#if USE_SPONZA
      .initialCameraPos = vec3(-25, 10, -1),
      .initialCameraTarget = vec3(10, 10, 0),
#else
      .initialCameraPos = vec3(-100, 40, -47),
      .initialCameraTarget = vec3(0, 35, 0),
#endif
  };
  VULKAN_APP_DECLARE(app, cfg);

  ctx_ = app.ctx_.get();

  res.ubPerFrame_ = ctx_->createBuffer({
      .usage = lvk::BufferUsageBits_Storage,
      .storage = lvk::StorageType_HostVisible,
      .size = sizeof(UniformsPerFrame),
      .debugName = "Buffer: uniforms (per frame)",
  });

  res.ubPerObject_ = ctx_->createBuffer({
      .usage = lvk::BufferUsageBits_Storage,
      .storage = lvk::StorageType_HostVisible,
      .size = sizeof(UniformsPerObject),
      .debugName = "Buffer: uniforms (per object)",
  });

  lvk::RenderPass renderPassZPrepass_ = {.color = {{
                                             .loadOp = lvk::LoadOp_Clear,
                                             .storeOp = kNumSamplesMSAA > 1 ? lvk::StoreOp_MsaaResolve : lvk::StoreOp_Store,
                                             .clearColor = {0.0f, 0.0f, 0.0f, 1.0f},
                                         }},
                                         .depth = {
                                             .loadOp = lvk::LoadOp_Clear,
                                             .storeOp = lvk::StoreOp_Store,
                                             .clearDepth = 1.0f,
                                         }};

  lvk::RenderPass renderPassOffscreen_ = {.color = {{
                                              .loadOp = lvk::LoadOp_Clear,
                                              .storeOp = kNumSamplesMSAA > 1 ? lvk::StoreOp_MsaaResolve : lvk::StoreOp_Store,
                                              .clearColor = {0.0f, 0.0f, 0.0f, 1.0f},
                                          }},
                                          .depth = {
                                              .loadOp = lvk::LoadOp_Load,
                                              .storeOp = lvk::StoreOp_DontCare,
                                          }};

#if defined(LVK_DEMO_WITH_SLANG)
  res.smMeshVert_ = ctx_->createShaderModule({codeSlang, lvk::Stage_Vert, "Shader Module: main (vert)"});
  res.smMeshFrag_ = ctx_->createShaderModule({codeSlang, lvk::Stage_Frag, "Shader Module: main (frag)"});
  res.smMeshVertZPrepass_ = ctx_->createShaderModule({codeZPrepassSlang, lvk::Stage_Vert, "Shader Module: main zprepass (vert)"});
  res.smMeshFragZPrepass_ = ctx_->createShaderModule({codeZPrepassSlang, lvk::Stage_Frag, "Shader Module: main zprepass (frag)"});
  res.smFullscreenVert_ = ctx_->createShaderModule({codeFullscreenSlang, lvk::Stage_Vert, "Shader Module: fullscreen (vert)"});
  res.smFullscreenFrag_ = ctx_->createShaderModule({codeFullscreenSlang, lvk::Stage_Frag, "Shader Module: fullscreen (frag)"});
#else
  res.smMeshVert_ = ctx_->createShaderModule({kCodeVS, lvk::Stage_Vert, "Shader Module: main (vert)"});
  res.smMeshFrag_ = ctx_->createShaderModule({kCodeFS, lvk::Stage_Frag, "Shader Module: main (frag)"});
  res.smMeshVertZPrepass_ = ctx_->createShaderModule({kCodeZPrepassVS, lvk::Stage_Vert, "Shader Module: main zprepass (vert)"});
  res.smMeshFragZPrepass_ = ctx_->createShaderModule({kCodeZPrepassFS, lvk::Stage_Frag, "Shader Module: main zprepass (frag)"});
  res.smFullscreenVert_ = ctx_->createShaderModule({kCodeFullscreenVS, lvk::Stage_Vert, "Shader Module: fullscreen (vert)"});
  res.smFullscreenFrag_ = ctx_->createShaderModule({kCodeFullscreenFS, lvk::Stage_Frag, "Shader Module: fullscreen (frag)"});
#endif // defined(LVK_DEMO_WITH_SLANG)

  lvk::Framebuffer fbOffscreen = createOffscreenFramebuffer(app.width_, app.height_);

  res.renderPipelineState_Mesh_ = ctx_->createRenderPipeline(lvk::RenderPipelineDesc{
      .vertexInput =
          {
              .attributes =
                  {
                      {.location = 0, .format = lvk::VertexFormat::Float3, .offset = offsetof(VertexData, position)},
                      {.location = 1, .format = lvk::VertexFormat::HalfFloat2, .offset = offsetof(VertexData, uv)},
                      {.location = 2, .format = lvk::VertexFormat::UShort1, .offset = offsetof(VertexData, normal)},
                      {.location = 3, .format = lvk::VertexFormat::UShort1, .offset = offsetof(VertexData, mtlIndex)},
                  },
              .inputBindings = {{.stride = sizeof(VertexData)}},
          },
      .smVert = res.smMeshVert_,
      .smFrag = res.smMeshFrag_,
      .color = {{.format = ctx_->getFormat(fbOffscreen.color[0].texture)}},
      .depthFormat = ctx_->getFormat(fbOffscreen.depthStencil.texture),
      .cullMode = lvk::CullMode_Back,
      .frontFace = lvk::WindingMode_CCW,
      .samplesCount = kNumSamplesMSAA,
      .debugName = "Pipeline: mesh",
  });

  res.renderPipelineState_MeshZPrepass_ = ctx_->createRenderPipeline(lvk::RenderPipelineDesc{
      .vertexInput =
          {
              .attributes =
                  {
                      {.location = 0, .format = lvk::VertexFormat::Float3, .offset = offsetof(VertexData, position)},
                  },
              .inputBindings = {{.stride = sizeof(VertexData)}},
          },
      .smVert = res.smMeshVertZPrepass_,
      .smFrag = res.smMeshFragZPrepass_,
      .color = {{.format = ctx_->getFormat(fbOffscreen.color[0].texture)}},
      .depthFormat = ctx_->getFormat(fbOffscreen.depthStencil.texture),
      .cullMode = lvk::CullMode_Back,
      .frontFace = lvk::WindingMode_CCW,
      .samplesCount = kNumSamplesMSAA,
      .debugName = "Pipeline: mesh z-prepass",
  });

  // fullscreen
  res.renderPipelineState_Fullscreen_ = ctx_->createRenderPipeline(lvk::RenderPipelineDesc{
      .smVert = res.smFullscreenVert_,
      .smFrag = res.smFullscreenFrag_,
      .color = {{.format = app.ctx_->getSwapchainFormat()}},
      .cullMode = lvk::CullMode_None,
      .debugName = "Pipeline: fullscreen",
  });

  if (!initModel(app.folderContentRoot_)) {
    VULKAN_APP_EXIT();
  }

  const mat4 modelMatrix = glm::scale(mat4(1.0f), vec3(0.05f));

  const UniformsPerObject perObject = {
      .model = modelMatrix,
      .normal = glm::transpose(glm::inverse(modelMatrix)),
  };

  app.run([&](uint32_t width, uint32_t height, float aspectRatio, float deltaSeconds) {
    LVK_PROFILER_FUNCTION();

    lvk::ICommandBuffer& buffer = ctx_->acquireCommandBuffer();

    buffer.cmdUpdateBuffer(res.ubPerFrame_,
                           UniformsPerFrame{
                               .proj = glm::perspective(float(45.0f * (M_PI / 180.0f)), aspectRatio, 0.5f, 500.0f),
                               .view = app.camera_.getViewMatrix(),
                           });
    buffer.cmdUpdateBuffer(res.ubPerObject_, 0, sizeof(perObject), &perObject);
    buffer.cmdBindVertexBuffer(0, res.vb0_, 0);
    buffer.cmdBindIndexBuffer(res.ib0_, lvk::IndexFormat_UI32);

    // Pass 1: mesh Z-prepass
    {
      buffer.cmdBeginRendering(renderPassZPrepass_, fbOffscreen);
      buffer.cmdPushDebugGroupLabel("Render Mesh ZPrepass", 0xff0000ff);
      buffer.cmdBindRenderPipeline(res.renderPipelineState_MeshZPrepass_);
      struct {
        uint64_t perFrame;
        uint64_t perObject;
        uint64_t materials;
      } pc = {
          .perFrame = ctx_->gpuAddress(res.ubPerFrame_),
          .perObject = ctx_->gpuAddress(res.ubPerObject_),
          .materials = ctx_->gpuAddress(res.sbMaterials_),
      };
      buffer.cmdPushConstants(pc);
      buffer.cmdBindDepthState({.compareOp = lvk::CompareOp_Less, .isDepthWriteEnabled = true});
      buffer.cmdDrawIndexed(static_cast<uint32_t>(indexData_.size()));
      buffer.cmdPopDebugGroupLabel();
      buffer.cmdEndRendering();
    }
    // Pass 2: mesh with RTX
    {
      buffer.cmdBeginRendering(renderPassOffscreen_, fbOffscreen);
      buffer.cmdPushDebugGroupLabel("Render Mesh", 0xff0000ff);
      buffer.cmdBindRenderPipeline(res.renderPipelineState_Mesh_);
      struct {
        vec4 lightDir;
        uint64_t perFrame;
        uint64_t perObject;
        uint64_t materials;
        uint32_t tlas;
        int enableShadows;
        int enableAO;
        int aoDistanceBased;
        int aoSamples;
        float aoRadius;
        float aoPower;
        uint32_t frameId;
      } pc = {
          .lightDir = vec4(lightDir_, 1.0),
          .perFrame = ctx_->gpuAddress(res.ubPerFrame_),
          .perObject = ctx_->gpuAddress(res.ubPerObject_),
          .materials = ctx_->gpuAddress(res.sbMaterials_),
          .tlas = res.TLAS.index(),
          .enableShadows = enableShadows_ ? 1 : 0,
          .enableAO = enableAO_ ? 1 : 0,
          .aoDistanceBased = aoDistanceBased_ ? 1 : 0,
          .aoSamples = aoSamples_,
          .aoRadius = aoRadius_,
          .aoPower = aoPower_,
          .frameId = timeVaryingNoise ? frameId++ : 0,
      };
      buffer.cmdPushConstants(pc);
      buffer.cmdBindDepthState({.compareOp = lvk::CompareOp_Equal, .isDepthWriteEnabled = false});
      buffer.cmdDrawIndexed(static_cast<uint32_t>(indexData_.size()));
      buffer.cmdPopDebugGroupLabel();
      buffer.cmdEndRendering();
    }

    // Pass 3: render into the swapchain image
    {
      lvk::TextureHandle tex = kNumSamplesMSAA > 1 ? fbOffscreen.color[0].resolveTexture : fbOffscreen.color[0].texture;

      const lvk::Framebuffer fbMain_ = {
          .color = {{.texture = ctx_->getCurrentSwapchainTexture()}},
      };

      buffer.cmdBeginRendering(
          lvk::RenderPass{
              .color = {{.loadOp = lvk::LoadOp_Clear, .storeOp = lvk::StoreOp_Store, .clearColor = {0.0f, 0.0f, 0.0f, 1.0f}}},
          },
          fbMain_,
          {.textures = {tex, fbOffscreen.color[0].texture}});
      {
        buffer.cmdBindRenderPipeline(res.renderPipelineState_Fullscreen_);
        buffer.cmdPushDebugGroupLabel("Swapchain Output", 0xff0000ff);
        buffer.cmdBindDepthState({});
        struct {
          uint32_t texture;
          uint32_t denoise;
          float denoiseSigma = 2.0f;
          float denoiseKSigma = 2.0f;
          float denoiseThreshold = 0.5f;
        } bindings = {
            .texture = tex.index(),
            .denoise = enableDenoise_ ? 1u : 0u,
            .denoiseSigma = denoiseSigma_,
            .denoiseKSigma = denoiseKSigma_,
            .denoiseThreshold = denoiseThreshold_,
        };
        buffer.cmdPushConstants(bindings);
        buffer.cmdDraw(3);
        buffer.cmdPopDebugGroupLabel();
        // imGui
        {
          app.imgui_->beginFrame(fbMain_);

          auto imGuiPushFlagsAndStyles = [](bool value) {
            ImGui::BeginDisabled(!value);
            ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * (value ? 1.0f : 0.3f));
          };
          auto imGuiPopFlagsAndStyles = []() {
            ImGui::PopStyleVar();
            ImGui::EndDisabled();
          };
#if !defined(ANDROID)
          const float indentSize = 16.0f;
          ImGui::Begin("Keyboard hints:", nullptr, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoNavInputs);
          ImGui::Text("W/S/A/D - camera movement");
          ImGui::Text("1/2 - camera up/down");
          ImGui::Text("Shift - fast movement");
          ImGui::Separator();
          ImGui::Checkbox("Time-varying noise", &timeVaryingNoise);
          ImGui::Checkbox("Ray traced shadows", &enableShadows_);
          ImGui::Indent(indentSize);
          imGuiPushFlagsAndStyles(enableShadows_);
          ImGui::SliderFloat3("Light dir", glm::value_ptr(lightDir_), -1, 1);
          imGuiPopFlagsAndStyles();
          lightDir_ = glm::normalize(lightDir_);
          ImGui::Unindent(indentSize);
          ImGui::Checkbox("Denoise:", &enableDenoise_);
          ImGui::Indent(indentSize);
          imGuiPushFlagsAndStyles(enableDenoise_);
          ImGui::SliderFloat("Sigma", &denoiseSigma_, 0.001f, 3.0f);
          ImGui::SliderFloat("kSigma", &denoiseKSigma_, 0.001f, 9.0f);
          ImGui::SliderFloat("Threshold", &denoiseThreshold_, 0.001f, 1.0f);
          ImGui::Unindent(indentSize);
          imGuiPopFlagsAndStyles();
          ImGui::Checkbox("Ray traced AO:", &enableAO_);
          ImGui::Indent(indentSize);
          imGuiPushFlagsAndStyles(enableAO_);
          ImGui::Checkbox("Distance based AO", &aoDistanceBased_);
          ImGui::SliderFloat("AO radius", &aoRadius_, 0.5f, 16.0f);
          ImGui::SliderFloat("AO power", &aoPower_, 1.0f, 2.0f);
          ImGui::SliderInt("AO samples", &aoSamples_, 1, 32);
          ImGui::Unindent(indentSize);
          imGuiPopFlagsAndStyles();
          ImGui::End();
#endif // !defined(ANDROID)
        }
        app.drawFPS();
        app.imgui_->endFrame(buffer);
      }
      buffer.cmdEndRendering();

      ctx_->submit(buffer, fbMain_.color[0].texture);
    }
  });

  // destroy all the Vulkan stuff before closing the window
  res = {};

  VULKAN_APP_EXIT();
}

```

`samples/RTX_003_Pipeline.cpp`:

```cpp
/*
 * LightweightVK
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#include "Bistro.h"
#include "VulkanApp.h"

// scene navigation
#define USE_SPONZA 0

#if USE_SPONZA
#define MODEL_PATH "src/Sponza/sponza.obj"
#define CACHE_FILE_NAME "cache3.data"
vec3 lightDir_ = normalize(vec3(0.05f, 1.0f, 0.01f));
#else
#define MODEL_PATH "src/bistro/Exterior/exterior.obj"
#define CACHE_FILE_NAME "cache2.data"
vec3 lightDir_ = normalize(vec3(0.032f, 0.835f, 0.549f));
#endif
bool enableShadows_ = true;

const char* codeSlang = R"(
struct Material {
  float4 ambient;
  float4 diffuse;
};

struct Vertex {
  float x, y, z;
  uint uv;
  uint16_t normal;  // Octahedral 16-bit encoding
  uint16_t mtlIndex;
};

// Buffer reference types (Slang structured buffers)
struct Materials {
  Material mtl[];
};

struct Vertices {
  Vertex vtx[];
};

struct Indices {
  uint idx[];
};

struct PerFrame {
  float4x4 viewInverse;
  float4x4 projInverse;
};

struct PushConstants {
  float4 lightDir;
  PerFrame* perFrame;
  Materials* materials;
  Indices* indices;
  Vertices* vertices;
  uint outTexture;
  uint tlas;
  bool enableShadows;
};

[[vk::push_constant]] PushConstants pc;

[[vk::binding(2, 0)]] RWTexture2D<float4> kTextures2DInOut[];

struct RayPayload {
  float4 color;
};

struct ShadowPayload {
  bool isShadowed;
};

float2 unpackSnorm2x8(uint d) {
  return float2(uint2(d, d >> 8) & 255u) / 127.5 - 1.0;
}

float3 unpackOctahedral16(uint data) {
  float2 v = unpackSnorm2x8(data);
  // Octahedral normal unpacking
  float3 n = float3(v, 1.0 - abs(v.x) - abs(v.y));
  float t = max(-n.z, 0.0);
  n.x += (n.x > 0.0) ? -t : t;
  n.y += (n.y > 0.0) ? -t : t;
  return normalize(n);
}

[shader("raygeneration")]
void rayGenMain() {
  uint3 launchID = DispatchRaysIndex();
  uint3 launchSize = DispatchRaysDimensions();

  float2 pixelCenter = float2(launchID.xy) + float2(0.5, 0.5);
  float2 d = 2.0 * (pixelCenter / float2(launchSize.xy)) - 1.0;

  float4 origin    = pc.perFrame->viewInverse * float4(0, 0, 0, 1);
  float4 target    = pc.perFrame->projInverse * float4(d, 1, 1);
  float4 direction = pc.perFrame->viewInverse * float4(normalize(target.xyz), 0);

  RayDesc ray;
  ray.Origin = origin.xyz;
  ray.Direction = direction.xyz;
  ray.TMin = 0.01;
  ray.TMax = 1000.0;

  RayPayload payload;
  payload.color = float4(0.0, 0.0, 0.0, 1.0);

  TraceRay(
    kTLAS[pc.tlas],
    RAY_FLAG_FORCE_OPAQUE,
    0xff,       // instance mask
    0,          // ray contribution to hit group index
    0,          // multiplier for geometry contribution
    0,          // miss shader index
    ray,
    payload
  );

  kTextures2DInOut[pc.outTexture][launchID.xy] = payload.color;
}

// miss shader (primary ray)
[shader("miss")]
void missMain(inout RayPayload payload) {
  payload.color = float4(0.1, 0.1, 1.0, 1.0);
}

// miss shader (shadow ray)
[shader("miss")]
void missMainShadow(inout ShadowPayload payload) {
  payload.isShadowed = false;
}

[shader("closesthit")]
void closestHitMain(
  inout RayPayload payload,
  in BuiltInTriangleIntersectionAttributes attribs
) {
  // Compute barycentric coordinates
  float3 baryCoords = float3(
    1.0 - attribs.barycentrics.x - attribs.barycentrics.y,
    attribs.barycentrics.x,
    attribs.barycentrics.y
  );

  // Get triangle indices
  uint index = 3 * PrimitiveIndex();
  int3 triangleIndex = int3(
    pc.indices->idx[index + 0],
    pc.indices->idx[index + 1],
    pc.indices->idx[index + 2]
  );

  // Unpack and interpolate normals
  float3 nrm0 = unpackOctahedral16(uint(pc.vertices->vtx[triangleIndex.x].normal));
  float3 nrm1 = unpackOctahedral16(uint(pc.vertices->vtx[triangleIndex.y].normal));
  float3 nrm2 = unpackOctahedral16(uint(pc.vertices->vtx[triangleIndex.z].normal));
  float3 normal = normalize(
    nrm0 * baryCoords.x +
    nrm1 * baryCoords.y +
    nrm2 * baryCoords.z);

  // transform normal to world space
  float3 worldNormal = normalize((float3x3)WorldToObject() * normal);

  Material mat = pc.materials.mtl[uint(pc.vertices->vtx[triangleIndex.x].mtlIndex)];

  bool isShadowed = pc.enableShadows;
  if (pc.enableShadows) {
    float3 hitPoint = WorldRayOrigin() + WorldRayDirection() * RayTCurrent();

    RayDesc shadowRay;
    shadowRay.Origin = hitPoint;
    shadowRay.Direction = pc.lightDir.xyz;
    shadowRay.TMin = 0.01;
    shadowRay.TMax = 1000.0;

    ShadowPayload shadowPayload;
    shadowPayload.isShadowed = true;

    TraceRay(
      kTLAS[pc.tlas],
      RAY_FLAG_FORCE_OPAQUE |
      RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH |
      RAY_FLAG_SKIP_CLOSEST_HIT_SHADER,
      0xff,       // instance mask
      0,          // ray contribution to hit group index
      0,          // multiplier for geometry contribution
      1,          // miss shader index (shadow miss, index 1 in the miss SBT region)
      shadowRay,
      shadowPayload
    );

    isShadowed = shadowPayload.isShadowed;
  }

  float occlusion = isShadowed ? 0.5 : 1.0;
  float NdotL1 = clamp(dot(worldNormal, normalize(float3(-1, 1, 1))), 0.0, 1.0);
  float NdotL2 = clamp(dot(worldNormal, normalize(float3(-1, 1, -1))), 0.0, 1.0);
  float NdotL = 0.5 * (NdotL1 + NdotL2);

  payload.color = float4(
    mat.diffuse.rgb * occlusion * max(NdotL, 0.0),
    mat.diffuse.a
  );
})";

const char* codeFullscreenSlang = R"(
struct PushConstants {
  uint tex;
};

struct VSOutput {
  float4 sv_Position : SV_Position;
  float2 uv          : TEXCOORD0;
};

[[vk::push_constant]] PushConstants pc;

[shader("vertex")]
VSOutput vertexMain(uint vertexID : SV_VertexID) {
  VSOutput out;

  // generate a triangle covering the entire screen
  out.uv = float2((vertexID << 1) & 2, vertexID & 2);
  out.sv_Position = float4(out.uv * float2(2, 2) + float2(-1, -1), 0.0, 1.0);

  return out;
}

[shader("fragment")]
float4 fragmentMain(VSOutput input) : SV_Target0 {
  return textureBindless2D(pc.tex, 0, input.uv);
}
)";

#define UBOS_AND_PUSH_CONSTANTS \
  R"(
struct Material {
  vec4 ambient;
  vec4 diffuse;
};

layout(std430, buffer_reference) readonly buffer Materials {
  Material mtl[];
};

struct Vertex {
  float x, y, z;
  uint uv;
  uint16_t normal; // Octahedral 16-bit https://www.shadertoy.com/view/llfcRl
  uint16_t mtlIndex;
};

layout(std430, buffer_reference) readonly buffer Vertices {
  Vertex vtx[];
};

layout(std430, buffer_reference) readonly buffer Indices {
  uint idx[];
};

layout(std430, buffer_reference) readonly buffer PerFrame {
  mat4 viewInverse;
  mat4 projInverse;
};

layout(push_constant) uniform constants {
  vec4 lightDir;
  PerFrame perFrame;
  Materials materials;
  Indices indices;
  Vertices vertices;
  uint outTexture;
  uint tlas;
  bool enableShadows;
} pc;
)"

const char* codeRayGen = R"(
#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_shader_16bit_storage : require

layout (set = 0, binding = 2, rgba8) uniform image2D kTextures2DInOut[];
layout (set = 0, binding = 4) uniform accelerationStructureEXT kTLAS[];
)" UBOS_AND_PUSH_CONSTANTS
                         R"(
layout(location = 0) rayPayloadEXT vec4 payload;

const float tmin = 0.01;
const float tmax = 1000.0;

void main() {
  vec2 pixelCenter = gl_LaunchIDEXT.xy + vec2(0.5);
  vec2 d = 2.0 * (pixelCenter / gl_LaunchSizeEXT.xy) - 1.0;

  vec4 origin = pc.perFrame.viewInverse * vec4(0,0,0,1);
  vec4 target = pc.perFrame.projInverse * vec4(d, 1, 1);
  vec4 direction = pc.perFrame.viewInverse * vec4(normalize(target.xyz), 0);

  payload = vec4(0.0, 0.0, 0.0, 1.0);

  traceRayEXT(kTLAS[pc.tlas], gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin.xyz, tmin, direction.xyz, tmax, 0);

  imageStore(kTextures2DInOut[pc.outTexture], ivec2(gl_LaunchIDEXT.xy), payload);
}
)";

const char* codeMiss = R"(
#version 460
#extension GL_EXT_ray_tracing : require

layout(location = 0) rayPayloadInEXT vec4 payload;

void main() {
  payload = vec4(0.1, 0.1, 1.0, 1.0);
})";

const char* codeMissShadow = R"(
#version 460
#extension GL_EXT_ray_tracing : require

layout(location = 1) rayPayloadInEXT bool isShadowed;

void main() {
  isShadowed = false;
})";

const char* codeClosestHit = R"(
#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_ray_query : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_shader_16bit_storage : require

const float tmin = 0.001;
const float tmax = 500.0;

layout (set = 0, binding = 4) uniform accelerationStructureEXT kTLAS[];

layout(location = 0) rayPayloadInEXT vec4 payload;
layout(location = 1) rayPayloadEXT bool isShadowed;

hitAttributeEXT vec2 attribs;
)" UBOS_AND_PUSH_CONSTANTS
                             R"(

// https://www.shadertoy.com/view/llfcRl
vec2 unpackSnorm2x8(uint d) {
  return vec2(uvec2(d, d >> 8) & 255u) / 127.5 - 1.0;
}
vec3 unpackOctahedral16(uint data) {
  vec2 v = unpackSnorm2x8(data);
  // https://x.com/Stubbesaurus/status/937994790553227264
  vec3 n = vec3(v, 1.0 - abs(v.x) - abs(v.y));
  float t = max(-n.z, 0.0);
  n.x += (n.x > 0.0) ? -t : t;
  n.y += (n.y > 0.0) ? -t : t;
  return normalize(n);
}
//

void main() {
  const vec3 baryCoords = vec3(1.0f - attribs.x - attribs.y, attribs.x, attribs.y);

  uint index = 3 * gl_PrimitiveID;
  ivec3 triangleIndex = ivec3(pc.indices.idx[index + 0],
                              pc.indices.idx[index + 1],
                              pc.indices.idx[index + 2]);

  vec3 nrm0 = unpackOctahedral16(uint(pc.vertices.vtx[triangleIndex.x].normal));
  vec3 nrm1 = unpackOctahedral16(uint(pc.vertices.vtx[triangleIndex.y].normal));
  vec3 nrm2 = unpackOctahedral16(uint(pc.vertices.vtx[triangleIndex.z].normal));
  vec3 normal = normalize(nrm0 * baryCoords.x + nrm1 * baryCoords.y + nrm2 * baryCoords.z);
  vec3 worldNormal = normalize(vec3(normal * gl_WorldToObjectEXT));

  Material mat = pc.materials.mtl[uint(pc.vertices.vtx[triangleIndex.x].mtlIndex)];

  const float tmin = 0.01;
  const float tmax = 1000.0;

  isShadowed = pc.enableShadows;

  if (pc.enableShadows) {
    vec3 hitPoint = gl_WorldRayOriginEXT + gl_WorldRayDirectionEXT * gl_HitTEXT;

    traceRayEXT(
      kTLAS[pc.tlas],
      gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT,
      0xff,             // cull mask
      0,                // sbtRecordOffset
      0,                // sbtRecordStride
      1,                // missIndex (shadow miss, index 1 in the miss SBT region)
      hitPoint,         // ray origin
      tmin,
      pc.lightDir.xyz,  // ray direction
      tmax,
      1                 // payload location
    );
  }
  float occlusion = isShadowed ? 0.5 : 1.0;

  float NdotL1 = clamp(dot(worldNormal, normalize(vec3(-1, 1,+1))), 0.0, 1.0);
  float NdotL2 = clamp(dot(worldNormal, normalize(vec3(-1, 1,-1))), 0.0, 1.0);
  float NdotL = 0.5 * (NdotL1 + NdotL2);

  payload = vec4(mat.diffuse.rgb * occlusion * max(NdotL, 0.0), mat.diffuse.a);
}
)";

const char* kCodeFullscreenVS = R"(
layout (location=0) out vec2 uv;
void main() {
  // generate a triangle covering the entire screen
  uv = vec2((gl_VertexIndex << 1) & 2, gl_VertexIndex & 2);
  gl_Position = vec4(uv * vec2(2, -2) + vec2(-1, 1), 0.0, 1.0);
}
)";

const char* kCodeFullscreenFS = R"(
layout (location=0) in vec2 uv;
layout (location=0) out vec4 out_FragColor;

layout(push_constant) uniform constants {
	uint tex;
} pc;

void main() {
  out_FragColor = textureBindless2D(pc.tex, 0, vec2(uv.x, 1.0 - uv.y));
}
)";

lvk::IContext* ctx_ = nullptr;

struct {
  lvk::Holder<lvk::ShaderModuleHandle> smFullscreenVert_;
  lvk::Holder<lvk::ShaderModuleHandle> smFullscreenFrag_;
  lvk::Holder<lvk::ShaderModuleHandle> smRaygen_;
  lvk::Holder<lvk::ShaderModuleHandle> smMiss_;
  lvk::Holder<lvk::ShaderModuleHandle> smMissShadow_;
  lvk::Holder<lvk::ShaderModuleHandle> smHit_;
  lvk::Holder<lvk::RenderPipelineHandle> renderPipelineState_Fullscreen_;
  lvk::Holder<lvk::BufferHandle> vb0_, ib0_; // buffers for vertices and indices
  lvk::Holder<lvk::BufferHandle> sbMaterials_; // storage buffer for materials
  lvk::Holder<lvk::BufferHandle> sbInstances_; // storage buffer for TLAS instances
  lvk::Holder<lvk::BufferHandle> ubPerFrame_;
  std::vector<lvk::Holder<lvk::AccelStructHandle>> BLAS_;
  lvk::Holder<lvk::AccelStructHandle> TLAS_;
  lvk::Holder<lvk::TextureHandle> rayTracingOutputImage_;
  lvk::Holder<lvk::RayTracingPipelineHandle> rayTracingPipeline_;
} res;

struct UniformsPerFrame {
  mat4 viewInverse;
  mat4 projInverse;
} perFrame_;

// this goes into our GLSL shaders
struct GPUMaterial {
  vec4 ambient = vec4(0.0f);
  vec4 diffuse = vec4(0.0f);
};

static_assert(sizeof(GPUMaterial) % 16 == 0);

std::vector<GPUMaterial> materials_;

void createPipelines();

bool initModel(const std::string& folderContentRoot) {
  const std::string cacheFileName = folderContentRoot + CACHE_FILE_NAME;

  if (!loadFromCache(cacheFileName.c_str())) {
    if (!LVK_VERIFY(loadAndCache(folderContentRoot, cacheFileName.c_str(), MODEL_PATH))) {
      LVK_ASSERT_MSG(false, "Cannot load 3D model");
      return false;
    }
  }

  for (const auto& mtl : cachedMaterials_) {
    materials_.push_back(GPUMaterial{vec4(mtl.ambient, 1.0f), vec4(mtl.diffuse, 1.0f)});
  }
  res.sbMaterials_ = ctx_->createBuffer({.usage = lvk::BufferUsageBits_Storage,
                                         .storage = lvk::StorageType_Device,
                                         .size = sizeof(GPUMaterial) * materials_.size(),
                                         .data = materials_.data(),
                                         .debugName = "Buffer: materials"},
                                        nullptr);

  res.vb0_ = ctx_->createBuffer({.usage = lvk::BufferUsageBits_Storage | lvk::BufferUsageBits_AccelStructBuildInputReadOnly,
                                 .storage = lvk::StorageType_Device,
                                 .size = sizeof(VertexData) * vertexData_.size(),
                                 .data = vertexData_.data(),
                                 .debugName = "Buffer: vertex"},
                                nullptr);
  res.ib0_ = ctx_->createBuffer({.usage = lvk::BufferUsageBits_Storage | lvk::BufferUsageBits_AccelStructBuildInputReadOnly,
                                 .storage = lvk::StorageType_Device,
                                 .size = sizeof(uint32_t) * indexData_.size(),
                                 .data = indexData_.data(),
                                 .debugName = "Buffer: index"},
                                nullptr);

  const glm::mat3x4 transformMatrix(1.0f);

  lvk::Holder<lvk::BufferHandle> transformBuffer = ctx_->createBuffer({
      .usage = lvk::BufferUsageBits_AccelStructBuildInputReadOnly,
      .storage = lvk::StorageType_HostVisible,
      .size = sizeof(glm::mat3x4),
      .data = &transformMatrix,
  });

  const auto totalPrimitiveCount = (uint32_t)indexData_.size() / 3;
  lvk::AccelStructDesc blasDesc{
      .type = lvk::AccelStructType_BLAS,
      .geometryType = lvk::AccelStructGeomType_Triangles,
      .vertexFormat = lvk::VertexFormat::Float3,
      .vertexBuffer = res.vb0_,
      .vertexStride = sizeof(VertexData),
      .numVertices = (uint32_t)vertexData_.size(),
      .indexFormat = lvk::IndexFormat_UI32,
      .indexBuffer = res.ib0_,
      .transformBuffer = transformBuffer,
      .buildRange = {.primitiveCount = totalPrimitiveCount},
      .buildFlags = lvk::AccelStructBuildFlagBits_PreferFastTrace,
      .debugName = "BLAS",
  };
  const lvk::AccelStructSizes blasSizes = ctx_->getAccelStructSizes(blasDesc);
  LLOGL("Full model BLAS sizes (byts):\n   buildScratchSize = %llu,\n   accelerationStructureSize = %llu\n",
        blasSizes.buildScratchSize,
        blasSizes.accelerationStructureSize);
  const uint32_t maxStorageBufferSize = ctx_->getMaxStorageBufferRange();

  // Calculate number of BLAS
  const uint32_t requiredBlasCount = [&blasSizes, maxStorageBufferSize]() {
    const uint32_t count1 = blasSizes.buildScratchSize / maxStorageBufferSize;
    const uint32_t count2 = blasSizes.accelerationStructureSize / maxStorageBufferSize;
    return 1 + (count1 > count2 ? count1 : count2);
  }();
  blasDesc.buildRange.primitiveCount = totalPrimitiveCount / requiredBlasCount;

  LVK_ASSERT(requiredBlasCount > 0);
  LLOGL("maxStorageBufferSize = %u bytes\nNumber of BLAS = %u\n", maxStorageBufferSize, requiredBlasCount);

  const glm::mat3x4 transform(glm::scale(mat4(1.0f), vec3(0.05f)));
  res.BLAS_.reserve(requiredBlasCount);

  std::vector<lvk::AccelStructInstance> instances;
  instances.reserve(requiredBlasCount);
  const auto primitiveCount = blasDesc.buildRange.primitiveCount;
  for (int i = 0; i < totalPrimitiveCount; i += (int)primitiveCount) {
    const auto rest = (int)totalPrimitiveCount - i;
    blasDesc.buildRange.primitiveOffset = (uint32_t)i * 3 * sizeof(uint32_t);
    blasDesc.buildRange.primitiveCount = (primitiveCount < rest) ? primitiveCount : rest;
    res.BLAS_.emplace_back(ctx_->createAccelerationStructure(blasDesc));
    instances.emplace_back(lvk::AccelStructInstance{
        .transform = (const lvk::mat3x4&)transform,
        .instanceCustomIndex = 0,
        .mask = 0xff,
        .instanceShaderBindingTableRecordOffset = 0,
        .flags = lvk::AccelStructInstanceFlagBits_TriangleFacingCullDisable,
        .accelerationStructureReference = ctx_->gpuAddress(res.BLAS_.back()),
    });
  }

  // Buffer for instance data
  res.sbInstances_ = ctx_->createBuffer(lvk::BufferDesc{
      .usage = lvk::BufferUsageBits_AccelStructBuildInputReadOnly,
      .storage = lvk::StorageType_HostVisible,
      .size = sizeof(lvk::AccelStructInstance) * instances.size(),
      .data = instances.data(),
      .debugName = "sbInstances_",
  });

  res.TLAS_ = ctx_->createAccelerationStructure({
      .type = lvk::AccelStructType_TLAS,
      .geometryType = lvk::AccelStructGeomType_Instances,
      .instancesBuffer = res.sbInstances_,
      .buildRange = {.primitiveCount = (uint32_t)instances.size()},
      .buildFlags = lvk::AccelStructBuildFlagBits_PreferFastTrace,
  });

  return true;
}

VULKAN_APP_MAIN {
  const VulkanAppConfig cfg{
      .width = 0,
      .height = 0,
#if USE_SPONZA
      .initialCameraPos = vec3(-25, 10, -1),
      .initialCameraTarget = vec3(10, 10, 0),
#else
      .initialCameraPos = vec3(-100, 40, -47),
      .initialCameraTarget = vec3(0, 35, 0),
#endif
  };
  VULKAN_APP_DECLARE(app, cfg);

  ctx_ = app.ctx_.get();

  res.ubPerFrame_ = ctx_->createBuffer({
      .usage = lvk::BufferUsageBits_Storage,
      .storage = lvk::StorageType_HostVisible,
      .size = sizeof(UniformsPerFrame),
      .debugName = "Buffer: uniforms (per frame)",
  });

  res.rayTracingOutputImage_ = ctx_->createTexture(lvk::TextureDesc{
      .type = lvk::TextureType_2D,
      .format = lvk::Format_BGRA_UN8,
      .dimensions = {(uint32_t)app.width_, (uint32_t)app.height_},
      .usage = lvk::TextureUsageBits_Sampled | lvk::TextureUsageBits_Storage,
      .debugName = "Ray-Tracing Output Image",
  });

#if defined(LVK_DEMO_WITH_SLANG)
  res.smRaygen_ = ctx_->createShaderModule({codeSlang, lvk::Stage_RayGen, "Shader Module: main (raygen)"});
  res.smMiss_ = ctx_->createShaderModule({codeSlang, lvk::Stage_Miss, "Shader Module: main (miss)"});
  res.smMissShadow_ = ctx_->createShaderModule({codeSlang, "missMainShadow", lvk::Stage_Miss, "Shader Module: main (miss shadow)"});
  res.smHit_ = ctx_->createShaderModule({codeSlang, lvk::Stage_ClosestHit, "Shader Module: main (closesthit)"});
  res.smFullscreenVert_ = ctx_->createShaderModule({codeFullscreenSlang, lvk::Stage_Vert, "Shader Module: fullscreen (vert)"});
  res.smFullscreenFrag_ = ctx_->createShaderModule({codeFullscreenSlang, lvk::Stage_Frag, "Shader Module: fullscreen (frag)"});
#else
  res.smRaygen_ = ctx_->createShaderModule({codeRayGen, lvk::Stage_RayGen, "Shader Module: main (raygen)"});
  res.smMiss_ = ctx_->createShaderModule({codeMiss, lvk::Stage_Miss, "Shader Module: main (miss)"});
  res.smMissShadow_ = ctx_->createShaderModule({codeMissShadow, lvk::Stage_Miss, "Shader Module: main (miss shadow)"});
  res.smHit_ = ctx_->createShaderModule({codeClosestHit, lvk::Stage_ClosestHit, "Shader Module: main (closesthit)"});
  res.smFullscreenVert_ = ctx_->createShaderModule({kCodeFullscreenVS, lvk::Stage_Vert, "Shader Module: fullscreen (vert)"});
  res.smFullscreenFrag_ = ctx_->createShaderModule({kCodeFullscreenFS, lvk::Stage_Frag, "Shader Module: fullscreen (frag)"});
#endif // defined(LVK_DEMO_WITH_SLANG)

  res.rayTracingPipeline_ = ctx_->createRayTracingPipeline(lvk::RayTracingPipelineDesc{
      .smRayGen = {lvk::ShaderModuleHandle(res.smRaygen_)},
      .smMiss =
          {
              lvk::ShaderModuleHandle(res.smMiss_),
              lvk::ShaderModuleHandle(res.smMissShadow_),
          },
      .hitGroups = {{.smClosestHit = res.smHit_}},
  });

  res.renderPipelineState_Fullscreen_ = ctx_->createRenderPipeline(lvk::RenderPipelineDesc{
      .smVert = res.smFullscreenVert_,
      .smFrag = res.smFullscreenFrag_,
      .color = {{.format = app.ctx_->getSwapchainFormat()}},
      .cullMode = lvk::CullMode_None,
      .debugName = "Pipeline: fullscreen",
  });

  if (!initModel(app.folderContentRoot_)) {
    VULKAN_APP_EXIT();
  }

  app.run([&](uint32_t width, uint32_t height, float aspectRatio, float deltaSeconds) {
    LVK_PROFILER_FUNCTION();

    lvk::ICommandBuffer& buffer = ctx_->acquireCommandBuffer();

    buffer.cmdUpdateBuffer(res.ubPerFrame_,
                           UniformsPerFrame{
                               .viewInverse = glm::inverse(app.camera_.getViewMatrix()),
                               .projInverse = glm::inverse(glm::perspective(float(45.0f * (M_PI / 180.0f)), aspectRatio, 0.5f, 500.0f)),
                           });

    // Pass 1: ray-trace the scene
    {
      struct {
        vec4 lightDir;
        uint64_t perFrame;
        uint64_t materials;
        uint64_t indices;
        uint64_t vertices;
        uint32_t outTexture;
        uint32_t tlas;
        uint32_t enableShadows;
      } pc = {
          .lightDir = vec4(lightDir_, 0.0f),
          .perFrame = ctx_->gpuAddress(res.ubPerFrame_),
          .materials = ctx_->gpuAddress(res.sbMaterials_),
          .indices = ctx_->gpuAddress(res.ib0_),
          .vertices = ctx_->gpuAddress(res.vb0_),
          .outTexture = res.rayTracingOutputImage_.index(),
          .tlas = res.TLAS_.index(),
          .enableShadows = enableShadows_ ? 1u : 0u,
      };

      buffer.cmdBindRayTracingPipeline(res.rayTracingPipeline_);
      buffer.cmdPushConstants(pc);
      buffer.cmdTraceRays(width, height, 1, {.textures = {lvk::TextureHandle(res.rayTracingOutputImage_)}});
    }

    // Pass 2: render into the swapchain image
    {
      const lvk::RenderPass renderPassMain = {
          .color = {{.loadOp = lvk::LoadOp_Clear, .storeOp = lvk::StoreOp_Store, .clearColor = {0.0f, 0.0f, 0.0f, 1.0f}}},
      };
      const lvk::Framebuffer fbMain = {
          .color = {{.texture = ctx_->getCurrentSwapchainTexture()}},
      };
      buffer.cmdBeginRendering(renderPassMain, fbMain, {.textures = {lvk::TextureHandle(res.rayTracingOutputImage_)}});
      {
        buffer.cmdBindRenderPipeline(res.renderPipelineState_Fullscreen_);
        buffer.cmdPushDebugGroupLabel("Swapchain Output", 0xff0000ff);
        buffer.cmdBindDepthState({});
        struct {
          uint32_t texture;
        } bindings = {
            .texture = res.rayTracingOutputImage_.index(),
        };
        buffer.cmdPushConstants(bindings);
        buffer.cmdDraw(3);
        buffer.cmdPopDebugGroupLabel();

        // ImGui
        {
          app.imgui_->beginFrame(fbMain);
          auto imGuiPushFlagsAndStyles = [](bool value) {
            ImGui::BeginDisabled(!value);
            ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * (value ? 1.0f : 0.3f));
          };
          auto imGuiPopFlagsAndStyles = []() {
            ImGui::PopStyleVar();
            ImGui::EndDisabled();
          };
#if !defined(ANDROID)
          const float indentSize = 16.0f;
          ImGui::Begin("Keyboard hints:", nullptr, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoNavInputs);
          ImGui::Text("W/S/A/D - camera movement");
          ImGui::Text("1/2 - camera up/down");
          ImGui::Text("Shift - fast movement");
          ImGui::Separator();
          ImGui::Checkbox("Ray traced shadows", &enableShadows_);
          ImGui::Indent(indentSize);
          imGuiPushFlagsAndStyles(enableShadows_);
          ImGui::SliderFloat3("Light dir", glm::value_ptr(lightDir_), -1, 1);
          imGuiPopFlagsAndStyles();
          lightDir_ = glm::normalize(lightDir_);
          ImGui::Unindent(indentSize);
          ImGui::End();
#endif // !defined(ANDROID)
          app.drawFPS();
          app.imgui_->endFrame(buffer);
        }
      }
      buffer.cmdEndRendering();
    }
    ctx_->submit(buffer, app.ctx_->getCurrentSwapchainTexture());
  });

  // destroy all the Vulkan stuff before closing the window
  res = {};

  VULKAN_APP_EXIT();
}

```

`samples/RTX_004_Textures.cpp`:

```cpp
/*
 * LightweightVK
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#include "VulkanApp.h"

#include <filesystem>

#include <ldrutils/lutils/ScopeExit.h>
#include <stb/stb_image.h>

// we are going to use raw Vulkan here to initialize VK_KHR_ray_tracing_position_fetch
#include <lvk/vulkan/VulkanUtils.h>

const char* codeSlang = R"(
[[vk::binding(2, 0)]] RWTexture2D<float4> kTextures2DInOut[];

struct Camera {
  float4x4 viewInverse;
  float4x4 projInverse;
};

struct PushConstants {
  Camera* cam;
  float2 dim;
  uint outTexture;
  uint texBackground;
  uint texObject;
  uint tlas;
  float time;
};
[[vk::push_constant]] PushConstants pc;

struct RayPayload {
  float3 color;
};

[shader("raygeneration")]
void rayGenMain() {
  uint3 launchID = DispatchRaysIndex();
  uint3 launchSize = DispatchRaysDimensions();

  float2 pixelCenter = float2(launchID.xy) + float2(0.5, 0.5);
  float2 d = 2.0 * (pixelCenter / float2(launchSize.xy)) - 1.0;

  float4 origin    = pc.cam->viewInverse * float4(0, 0, 0, 1);
  float4 target    = pc.cam->projInverse * float4(d, 1, 1);
  float4 direction = pc.cam->viewInverse * float4(normalize(target.xyz), 0);

  RayDesc ray;
  ray.Origin = origin.xyz;
  ray.Direction = direction.xyz;
  ray.TMin = 0.1;
  ray.TMax = 500.0;

  RayPayload payload = { float3(0.0, 0.0, 0.0) };

  TraceRay(
    kTLAS[NonUniformResourceIndex(pc.tlas)],
    RAY_FLAG_FORCE_OPAQUE,
    0xff,
    0,
    0,
    0,
    ray,
    payload
  );

  kTextures2DInOut[NonUniformResourceIndex(pc.outTexture)][launchID.xy] = float4(payload.color, 1.0);
}

[shader("miss")]
void missMain(inout RayPayload payload) {
  float2 uv = float2(DispatchRaysIndex().xy) / pc.dim;
  payload.color = textureBindless2DLod(pc.texBackground, 0, uv, 0).rgb;
}

float4 triplanar(uint tex, float3 worldPos, float3 normal) {
  // generate weights, show texture on both sides of the object (positive and negative)
  float3 weights = abs(normal);
  // make the transition sharper
  weights = pow(weights, float3(8.0, 8.0, 8.0));
  // make sure the sum of all components is 1
  weights = weights / (weights.x + weights.y + weights.z);

  // sample the texture for 3 different projections
  float4 cXY = textureBindless2DLod(tex, 0, worldPos.xy, 0);
  float4 cZY = textureBindless2DLod(tex, 0, worldPos.zy, 0);
  float4 cXZ = textureBindless2DLod(tex, 0, worldPos.xz, 0);

  // combine the projected colors
  return cXY * weights.z + cZY * weights.x + cXZ * weights.y;
}

// 1st hit group (index 0)
[shader("closesthit")]
void closestHitMain0(inout RayPayload payload, in BuiltInTriangleIntersectionAttributes attribs) {
  float3 pos0 = HitTriangleVertexPosition(0);
  float3 pos1 = HitTriangleVertexPosition(1);
  float3 pos2 = HitTriangleVertexPosition(2);

  float3 baryCoords = float3(1.0 - attribs.barycentrics.x - attribs.barycentrics.y,
                             attribs.barycentrics.x,
                             attribs.barycentrics.y);
  float3 pos = pos0 * baryCoords.x + pos1 * baryCoords.y + pos2 * baryCoords.z;

  // triplanar mapping in object-space; for our icosahedron, object-space position and normal vectors are the same
  payload.color = triplanar(pc.texObject, pos, normalize(pos)).rgb;
}

// 2nd hit group (index 1)
[shader("closesthit")]
void closestHitMain1(inout RayPayload payload, in BuiltInTriangleIntersectionAttributes attribs) {
  float3 baryCoords = float3(
    1.0f - attribs.barycentrics.x - attribs.barycentrics.y,
    attribs.barycentrics.x,
    attribs.barycentrics.y
  );
  payload.color = baryCoords;
}
)";

const char* codeRayGen = R"(
#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_nonuniform_qualifier : require

layout (set = 0, binding = 2, rgba8) uniform image2D kTextures2DInOut[];
layout (set = 0, binding = 4) uniform accelerationStructureEXT kTLAS[];

layout(std430, buffer_reference) readonly buffer Camera {
  mat4 viewInverse;
  mat4 projInverse;
};

layout(push_constant) uniform constants {
  Camera cam;
  vec2 dim;
  uint outTexture;
  uint texBackground;
  uint texObject;
  uint tlas;
  float time;
};

layout(location = 0) rayPayloadEXT vec3 payload;

const float tmin = 0.1;
const float tmax = 500.0;

void main() {
  vec2 pixelCenter = gl_LaunchIDEXT.xy + vec2(0.5);
  vec2 d = 2.0 * (pixelCenter / gl_LaunchSizeEXT.xy) - 1.0;

  vec4 origin = cam.viewInverse * vec4(0,0,0,1);
  vec4 target = cam.projInverse * vec4(d, 1, 1);
  vec4 direction = cam.viewInverse * vec4(normalize(target.xyz), 0);

  payload = vec3(0.0);

  traceRayEXT(kTLAS[tlas], gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin.xyz, tmin, direction.xyz, tmax, 0);

  imageStore(kTextures2DInOut[outTexture], ivec2(gl_LaunchIDEXT.xy), vec4(payload, 1.0));
}
)";

const char* codeMiss = R"(
#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : require

layout (set = 0, binding = 0) uniform texture2D kTextures2D[];
layout (set = 0, binding = 1) uniform sampler kSamplers[];

vec4 textureBindless2D(uint textureid, uint samplerid, vec2 uv) {
  return texture(nonuniformEXT(sampler2D(kTextures2D[textureid], kSamplers[samplerid])), uv);
}

layout(location = 0) rayPayloadInEXT vec3 payload;

layout(push_constant) uniform constants {
  vec2 cam; // just an opaque buffer reference - no access required
  vec2 dim;
  uint outTexture;
  uint texBackground;
  uint texObject;
  uint tlas;
  float time;
};

void main() {
  vec2 uv = gl_LaunchIDEXT.xy / dim;
  payload = textureBindless2D(texBackground, 0, uv).rgb;
})";

const char* codeClosestHit0 = R"(
#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_ray_tracing_position_fetch : require

layout (set = 0, binding = 0) uniform texture2D kTextures2D[];
layout (set = 0, binding = 1) uniform sampler kSamplers[];

vec4 textureBindless2D(uint textureid, uint samplerid, vec2 uv) {
  return texture(nonuniformEXT(sampler2D(kTextures2D[textureid], kSamplers[samplerid])), uv);
}

layout(location = 0) rayPayloadInEXT vec3 payload;
hitAttributeEXT vec2 attribs;

layout(push_constant) uniform constants {
  vec2 cam; // just an opaque buffer reference - no access required
  vec2 dim;
  uint outTexture;
  uint texBackground;
  uint texObject;
  uint tlas;
  float time;
};

vec4 triplanar(uint tex, vec3 worldPos, vec3 normal) {
  // generate weights, show texture on both sides of the object (positive and negative)
  vec3 weights = abs(normal);
  // make the transition sharper
  weights = pow(weights, vec3(8.0));
  // make sure the sum of all components is 1
  weights = weights / (weights.x + weights.y + weights.z);

  // sample the texture for 3 different projections
  vec4 cXY = textureBindless2D(tex, 0, worldPos.xy);
  vec4 cZY = textureBindless2D(tex, 0, worldPos.zy);
  vec4 cXZ = textureBindless2D(tex, 0, worldPos.xz);

  // combine the projected colors
  return cXY * weights.z + cZY * weights.x + cXZ * weights.y;
}

void main() {
  vec3 pos0 = gl_HitTriangleVertexPositionsEXT[0];
  vec3 pos1 = gl_HitTriangleVertexPositionsEXT[1];
  vec3 pos2 = gl_HitTriangleVertexPositionsEXT[2];

  vec3 baryCoords = vec3(1.0f - attribs.x - attribs.y, attribs.x, attribs.y);
  vec3 pos = pos0 * baryCoords.x + pos1 * baryCoords.y + pos2 * baryCoords.z;

  // triplanar mapping in object-space; for our icosahedron, object-space position and normal vectors are the same
  payload = triplanar(texObject, pos, normalize(pos)).rgb;
}
)";

const char* codeClosestHit1 = R"(
#version 460
#extension GL_EXT_ray_tracing : require

layout(location = 0) rayPayloadInEXT vec3 payload;
hitAttributeEXT vec2 attribs;

void main() {
  const vec3 baryCoords = vec3(1.0f - attribs.x - attribs.y, attribs.x, attribs.y);
  payload = baryCoords;
}
)";

lvk::IContext* ctx_ = nullptr;

struct Resources {
  lvk::Holder<lvk::AccelStructHandle> BLAS;
  lvk::Holder<lvk::AccelStructHandle> TLAS;

  lvk::Holder<lvk::BufferHandle> vertexBuffer;
  lvk::Holder<lvk::BufferHandle> indexBuffer;
  lvk::Holder<lvk::BufferHandle> instancesBuffer;

  lvk::Holder<lvk::TextureHandle> storageImage;
  lvk::Holder<lvk::TextureHandle> texBackground;
  lvk::Holder<lvk::TextureHandle> texObject;

  lvk::Holder<lvk::ShaderModuleHandle> raygen_;
  lvk::Holder<lvk::ShaderModuleHandle> miss_;
  lvk::Holder<lvk::ShaderModuleHandle> hit0_;
  lvk::Holder<lvk::ShaderModuleHandle> hit1_;

  lvk::Holder<lvk::BufferHandle> ubo;

  lvk::Holder<lvk::RayTracingPipelineHandle> pipeline;
} res;

void createBottomLevelAccelerationStructure() {
  struct Vertex {
    float pos[3];
  };
  const float t = (1.0f + sqrtf(5.0f)) / 2.0f;
  const Vertex vertices[] = {
      {-1, t, 0},
      {1, t, 0},
      {-1, -t, 0},
      {1, -t, 0},

      {0, -1, t},
      {0, 1, t},
      {0, -1, -t},
      {0, 1, -t},

      {t, 0, -1},
      {t, 0, 1},
      {-t, 0, -1},
      {-t, 0, 1},
  };

  const uint32_t indices[] = {0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4,  11, 10, 2,  10, 7, 6, 7, 1, 8,
                              3, 9,  4, 3, 4, 2, 3, 2, 6, 3, 6, 8,  3, 8,  9,  4, 9, 5, 2, 4,  11, 6,  2,  10, 8,  6, 7, 9, 8, 1};

  const glm::mat3x4 transformMatrix(1.0f);

  res.vertexBuffer = ctx_->createBuffer({
      .usage = lvk::BufferUsageBits_AccelStructBuildInputReadOnly,
      .storage = lvk::StorageType_HostVisible,
      .size = sizeof(vertices),
      .data = vertices,
  });
  res.indexBuffer = ctx_->createBuffer({
      .usage = lvk::BufferUsageBits_AccelStructBuildInputReadOnly,
      .storage = lvk::StorageType_HostVisible,
      .size = sizeof(indices),
      .data = indices,
  });
  lvk::Holder<lvk::BufferHandle> transformBuffer = ctx_->createBuffer({
      .usage = lvk::BufferUsageBits_AccelStructBuildInputReadOnly,
      .storage = lvk::StorageType_HostVisible,
      .size = sizeof(glm::mat3x4),
      .data = &transformMatrix,
  });

  res.BLAS = ctx_->createAccelerationStructure({
      .type = lvk::AccelStructType_BLAS,
      .geometryType = lvk::AccelStructGeomType_Triangles,
      .vertexFormat = lvk::VertexFormat::Float3,
      .vertexBuffer = res.vertexBuffer,
      .numVertices = (uint32_t)LVK_ARRAY_NUM_ELEMENTS(vertices),
      .indexFormat = lvk::IndexFormat_UI32,
      .indexBuffer = res.indexBuffer,
      .transformBuffer = transformBuffer,
      .buildRange = {.primitiveCount = (uint32_t)LVK_ARRAY_NUM_ELEMENTS(indices) / 3},
      .debugName = "BLAS",
  });
}

void createTopLevelAccelerationStructure() {
  const lvk::AccelStructInstance instances[2] = {
      {
          // clang-format off
          .transform = {.matrix = {1.0f, 0.0f, 0.0f, -2.0f,
                                   0.0f, 1.0f, 0.0f,  0.0f,
                                   0.0f, 0.0f, 1.0f,  0.0f}},
          // clang-format on
          .instanceCustomIndex = 0,
          .mask = 0xff,
          .instanceShaderBindingTableRecordOffset = 0, // hit group 0
          .flags = lvk::AccelStructInstanceFlagBits_TriangleFacingCullDisable,
          .accelerationStructureReference = ctx_->gpuAddress(res.BLAS),
      },
      {
          // clang-format off
          .transform = {.matrix = {1.0f, 0.0f, 0.0f, +2.0f,
                                   0.0f, 1.0f, 0.0f,  0.0f,
                                   0.0f, 0.0f, 1.0f,  0.0f}},
          // clang-format on
          .instanceCustomIndex = 0,
          .mask = 0xff,
          .instanceShaderBindingTableRecordOffset = 1, // hit group 1
          .flags = lvk::AccelStructInstanceFlagBits_TriangleFacingCullDisable,
          .accelerationStructureReference = ctx_->gpuAddress(res.BLAS),
      },
  };

  // Buffer for instance data
  res.instancesBuffer = ctx_->createBuffer(lvk::BufferDesc{
      .usage = lvk::BufferUsageBits_AccelStructBuildInputReadOnly,
      .storage = lvk::StorageType_Device,
      .size = sizeof(instances),
      .data = &instances,
      .debugName = "instanceBuffer",
  });

  res.TLAS = ctx_->createAccelerationStructure({
      .type = lvk::AccelStructType_TLAS,
      .geometryType = lvk::AccelStructGeomType_Instances,
      .instancesBuffer = res.instancesBuffer,
      .buildRange = {.primitiveCount = 2},
      .buildFlags = lvk::AccelStructBuildFlagBits_PreferFastTrace | lvk::AccelStructBuildFlagBits_AllowUpdate,
  });
}

lvk::Holder<lvk::TextureHandle> createTextureFromFile(VulkanApp& app, const char* fileName) {
  using namespace std::filesystem;
  path dir = app.folderContentRoot_;
  int32_t texWidth = 0;
  int32_t texHeight = 0;
  int32_t channels = 0;
  uint8_t* pixels = stbi_load((dir / path(fileName)).string().c_str(), &texWidth, &texHeight, &channels, 4);
  SCOPE_EXIT {
    stbi_image_free(pixels);
  };
  if (!pixels) {
    LVK_ASSERT_MSG(false, "Cannot load textures. Run `deploy_content.py`/`deploy_content_android.py` before running this app.");
    LLOGW("Cannot load textures. Run `deploy_content.py`/`deploy_content_android.py` before running this app.");
    std::terminate();
  }
  return ctx_->createTexture({
      .type = lvk::TextureType_2D,
      .format = lvk::Format_RGBA_UN8,
      .dimensions = {(uint32_t)texWidth, (uint32_t)texHeight},
      .usage = lvk::TextureUsageBits_Sampled,
      .data = pixels,
      .debugName = fileName,
  });
}

VULKAN_APP_MAIN {
  VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR positionFetchFeatures = {
      .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR,
      .rayTracingPositionFetch = VK_TRUE,
  };
  const VulkanAppConfig cfg{
      .width = -80,
      .height = -80,
      .resizable = true,
      .contextConfig =
          {
              .extensionsDevice = {"VK_KHR_ray_tracing_position_fetch"},
              .extensionsDeviceFeatures = &positionFetchFeatures,
          },
  };
  VULKAN_APP_DECLARE(app, cfg);

  ctx_ = app.ctx_.get();

  createBottomLevelAccelerationStructure();
  createTopLevelAccelerationStructure();

  const struct UniformData {
    glm::mat4 viewInverse;
    glm::mat4 projInverse;
  } uniformData = {
      .viewInverse = glm::inverse(glm::translate(glm::mat4(1.0f), glm::vec3(0, 0, -8.0f))),
      .projInverse = glm::inverse(glm::perspective(glm::radians(40.0f), (float)app.width_ / (float)app.height_, 0.1f, 1000.0f)),
  };

  res.ubo = ctx_->createBuffer(lvk::BufferDesc{
      .usage = lvk::BufferUsageBits_Storage,
      .storage = lvk::StorageType_Device,
      .size = sizeof(uniformData),
      .data = &uniformData,
      .debugName = "cameraBuffer",
  });

  res.storageImage = ctx_->createTexture(
      lvk::TextureDesc{
          .type = lvk::TextureType_2D,
          .format = lvk::Format_BGRA_UN8,
          .dimensions = {(uint32_t)app.width_, (uint32_t)app.height_, 1u},
          .numLayers = 1,
          .numSamples = 1,
          .usage = lvk::TextureUsageBits_Storage,
      },
      "storageImage");

  res.texBackground = createTextureFromFile(app, "src/bistro/BuildingTextures/wood_polished_01_diff.png");
  res.texObject = createTextureFromFile(app, "src/bistro/BuildingTextures/Cobble_02B_Diff.png");

#if defined(LVK_DEMO_WITH_SLANG)
  res.raygen_ = ctx_->createShaderModule({codeSlang, lvk::Stage_RayGen, "Shader Module: main (raygen)"});
  res.miss_ = ctx_->createShaderModule({codeSlang, lvk::Stage_Miss, "Shader Module: main (miss)"});
  res.hit0_ = ctx_->createShaderModule({codeSlang, "closestHitMain0", lvk::Stage_ClosestHit, "Shader Module: main (closesthit0)"});
  res.hit1_ = ctx_->createShaderModule({codeSlang, "closestHitMain1", lvk::Stage_ClosestHit, "Shader Module: main (closesthit1)"});
#else
  res.raygen_ = ctx_->createShaderModule({codeRayGen, lvk::Stage_RayGen, "Shader Module: main (raygen)"});
  res.miss_ = ctx_->createShaderModule({codeMiss, lvk::Stage_Miss, "Shader Module: main (miss)"});
  res.hit0_ = ctx_->createShaderModule({codeClosestHit0, lvk::Stage_ClosestHit, "Shader Module: main (closesthit0)"});
  res.hit1_ = ctx_->createShaderModule({codeClosestHit1, lvk::Stage_ClosestHit, "Shader Module: main (closesthit1)"});
#endif // defined(LVK_DEMO_WITH_SLANG)

  res.pipeline = ctx_->createRayTracingPipeline(lvk::RayTracingPipelineDesc{
      .smRayGen = {lvk::ShaderModuleHandle(res.raygen_)},
      .smMiss = {lvk::ShaderModuleHandle(res.miss_)},
      .hitGroups =
          {
              {.smClosestHit = res.hit0_},
              {.smClosestHit = res.hit1_},
          },
  });

  app.run([&](uint32_t width, uint32_t height, float aspectRatio, float deltaSeconds) {
    lvk::ICommandBuffer& buffer = ctx_->acquireCommandBuffer();

    const glm::mat3x4 transformMatrix = glm::rotate(glm::mat4(1.0f), (float)glfwGetTime(), glm::vec3(1, 1, 1));

    glm::mat3x4 transforms[2] = {
        glm::rotate(glm::mat4(1.0f), +(float)glfwGetTime(), glm::vec3(1, 1, 1)),
        glm::rotate(glm::mat4(1.0f), -(float)glfwGetTime(), glm::vec3(1, 1, 1)),
    };
    // set translation directly in the 3x4 matrices
    transforms[0][0][3] = -2.0f;
    transforms[1][0][3] = +2.0f;
    for (int i = 0; i != 2; i++) {
      buffer.cmdUpdateBuffer(res.instancesBuffer,
                             i * sizeof(lvk::AccelStructInstance) + offsetof(lvk::AccelStructInstance, transform),
                             sizeof(glm::mat3x4),
                             &transforms[i]);
    }

    struct {
      uint64_t camBuffer;
      vec2 dim;
      uint32_t outTexture;
      uint32_t texBackground;
      uint32_t texObject;
      uint32_t tlas;
      float time;
    } pc = {
        .camBuffer = ctx_->gpuAddress(res.ubo),
        .dim = vec2(width, height),
        .outTexture = res.storageImage.index(),
        .texBackground = res.texBackground.index(),
        .texObject = res.texObject.index(),
        .tlas = res.TLAS.index(),
        .time = (float)glfwGetTime(),
    };

    buffer.cmdUpdateTLAS(res.TLAS, res.instancesBuffer);
    buffer.cmdBindRayTracingPipeline(res.pipeline);
    buffer.cmdPushConstants(pc);
    buffer.cmdTraceRays(width, height, 1, {.textures = {lvk::TextureHandle(res.storageImage)}});
    buffer.cmdCopyImage(res.storageImage, ctx_->getCurrentSwapchainTexture(), ctx_->getDimensions(ctx_->getCurrentSwapchainTexture()));
    lvk::Framebuffer framebuffer = {
        .color = {{.texture = ctx_->getCurrentSwapchainTexture()}},
    };
    buffer.cmdBeginRendering(lvk::RenderPass{.color = {{.loadOp = lvk::LoadOp_Load, .storeOp = lvk::StoreOp_Store}}}, framebuffer);
    app.imgui_->beginFrame(framebuffer);
    app.drawFPS();
    app.imgui_->endFrame(buffer);
    buffer.cmdEndRendering();
    ctx_->submit(buffer, ctx_->getCurrentSwapchainTexture());
  });

  // destroy all the Vulkan stuff before closing the window
  res = {};

  VULKAN_APP_EXIT();
}

```

`samples/Tiny_MeshLarge.cpp`:

```cpp
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/*
 * A brief tutorial how to run this beast:
 *
 * 1) Run the script "deploy_deps.py" from the LightweightVK root folder.
 * 2) Run the script "deploy_content.py" from the LightweightVK root folder.
 *    NOTE: In case of Android, script is "deploy_content_android.py", see README.md
 * 3) Run this app.
 *
 */

#if !defined(_USE_MATH_DEFINES)
#define _USE_MATH_DEFINES
#endif // _USE_MATH_DEFINES
#include <cassert>
#include <cmath>
#include <cstddef>
#include <filesystem>
#include <mutex>
#include <stdio.h>
#include <thread>

#define GLM_ENABLE_EXPERIMENTAL
#include <glm/ext.hpp>
#include <glm/glm.hpp>
#include <glm/gtc/random.hpp>

#include <ktx-software/lib/src/gl_format.h>
#include <ktx-software/lib/src/vkformat_enum.h>
#include <ktx.h>
#include <ldrutils/lmath/Colors.h>
#include <ldrutils/lutils/ScopeExit.h>

#include <fast_obj.h>
#include <meshoptimizer.h>
#include <shared/Camera.h>
#include <shared/UtilsCubemap.h>
#include <shared/UtilsFPS.h>
#include <stb/stb_image.h>
#include <stb/stb_image_resize2.h>
#include <taskflow/taskflow.hpp>

#include <implot/implot.h>
#include <lvk/HelpersImGui.h>
#include <lvk/LVK.h>

#if defined(ANDROID)
#include <android_native_app_glue.h>
#include <jni.h>
#include <time.h>
#else
#include <GLFW/glfw3.h>
#endif

#include "DEMO_002_Bistro.cpp" // temporary

constexpr uint32_t kMeshCacheVersion = 0xC0DE000A;
#if !defined(__APPLE__)
constexpr int kNumSamplesMSAA = 8;
#else
constexpr int kNumSamplesMSAA = 4;
#endif
#if defined(__APPLE__) || defined(ANDROID)
constexpr bool kEnableCompression = false;
#else
constexpr bool kEnableCompression = true;
#endif
constexpr bool kPreferIntegratedGPU = false;
#if defined(NDEBUG)
constexpr bool kEnableValidationLayers = false;
#else
constexpr bool kEnableValidationLayers = true;
#endif // NDEBUG

std::string folderThirdParty;
std::string folderContentRoot;

std::unique_ptr<lvk::ImGuiRenderer> imgui_;

enum GPUTimestamp {
  GPUTimestamp_BeginSceneRendering = 0,
  GPUTimestamp_EndSceneRendering,

  GPUTimestamp_BeginComputePass,
  GPUTimestamp_EndComputePass,

  GPUTimestamp_BeginPresent,
  GPUTimestamp_EndPresent,

  GPUTimestamp_NUM_TIMESTAMPS
};
lvk::Holder<lvk::QueryPoolHandle> queryPoolTimestamps_;
uint64_t pipelineTimestamps[GPUTimestamp_NUM_TIMESTAMPS] = {};
double timestampBeginRendering = 0;
double timestampEndRendering = 0;

// https://github.com/KhronosGroup/MoltenVK/issues/2106
// TODO: After fix, use the only shader with binding = 2 to be compatible with Vulkan image layout on other platforms.
#ifdef __APPLE__
const char* kCodeComputeTest = R"(
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout (set = 0, binding = 0, rgba8) uniform image2D kTextures2DInOut[];

layout(push_constant) uniform constants {
   uint tex;
   uint width;
   uint height;
} pc;

void main() {
   ivec2 pos = ivec2(gl_GlobalInvocationID.xy);

   if (pos.x < pc.width && pos.y < pc.height) {
     vec4 pixel = imageLoad(kTextures2DInOut[pc.tex], pos);
     float luminance = dot(pixel, vec4(0.299, 0.587, 0.114, 0.0)); // https://www.w3.org/TR/AERT/#color-contrast
     imageStore(kTextures2DInOut[pc.tex], pos, vec4(vec3(luminance), 1.0));
   }
}
)";
#else
const char* kCodeComputeTest = R"(
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout (set = 0, binding = 2, rgba8) uniform image2D kTextures2DInOut[];

layout(push_constant) uniform constants {
   uint tex;
   uint width;
   uint height;
} pc;

void main() {
   ivec2 pos = ivec2(gl_GlobalInvocationID.xy);

   if (pos.x < pc.width && pos.y < pc.height) {
     vec4 pixel = imageLoad(kTextures2DInOut[pc.tex], pos);
     float luminance = dot(pixel, vec4(0.299, 0.587, 0.114, 0.0)); // https://www.w3.org/TR/AERT/#color-contrast
     imageStore(kTextures2DInOut[pc.tex], pos, vec4(vec3(luminance), 1.0));
   }
}
)";
#endif

const char* kCodeFullscreenVS = R"(
layout (location=0) out vec2 uv;
void main() {
  // generate a triangle covering the entire screen
  uv = vec2((gl_VertexIndex << 1) & 2, gl_VertexIndex & 2);
  gl_Position = vec4(uv * vec2(2, -2) + vec2(-1, 1), 0.0, 1.0);
}
)";

const char* kCodeFullscreenFS = R"(
layout (location=0) in vec2 uv;
layout (location=0) out vec4 out_FragColor;

layout(push_constant) uniform constants {
	uint tex;
} pc;

void main() {
  out_FragColor = textureBindless2D(pc.tex, 0, uv);
}
)";

const char* kCodeVS = R"(
layout (location=0) in vec3 pos;
layout (location=1) in vec2 uv;
layout (location=2) in uint normal; // Octahedral 16-bit https://www.shadertoy.com/view/llfcRl
layout (location=3) in uint mtlIndex;

struct Material {
   vec4 ambient;
   vec4 diffuse;
   int texAmbient;
   int texDiffuse;
   int texAlpha;
   int padding;
};

layout(std430, buffer_reference) readonly buffer PerFrame {
  mat4 proj;
  mat4 view;
  mat4 light;
  uint texSkyboxRadiance;
  uint texSkyboxIrradiance;
  uint texShadow;
  uint sampler0;
  uint samplerShadow0;
};

layout(std430, buffer_reference) readonly buffer PerObject {
  mat4 model;
  mat4 normal;
};

layout(std430, buffer_reference) readonly buffer Materials {
  Material mtl[];
};

layout(push_constant) uniform constants {
  PerFrame perFrame;
  PerObject perObject;
  Materials materials;
} pc;

// output
struct PerVertex {
  vec3 normal;
  vec2 uv;
  vec4 shadowCoords;
};
layout (location=0) out PerVertex vtx;
layout (location=5) flat out Material mtl;
//

// https://www.shadertoy.com/view/llfcRl
vec2 unpackSnorm2x8(uint d) {
  return vec2(uvec2(d, d >> 8) & 255u) / 127.5 - 1.0;
}
vec3 unpackOctahedral16(uint data) {
  vec2 v = unpackSnorm2x8(data);
  // https://x.com/Stubbesaurus/status/937994790553227264
  vec3 n = vec3(v, 1.0 - abs(v.x) - abs(v.y));
  float t = max(-n.z, 0.0);
  n.x += (n.x > 0.0) ? -t : t;
  n.y += (n.y > 0.0) ? -t : t;
  return normalize(n);
}
//

void main() {
  mat4 proj = pc.perFrame.proj;
  mat4 view = pc.perFrame.view;
  mat4 model = pc.perObject.model;
  mat4 light = pc.perFrame.light;
  mtl = pc.materials.mtl[mtlIndex];
  gl_Position = proj * view * model * vec4(pos, 1.0);

  // compute the normal in world-space
  vtx.normal = normalize(mat3(pc.perObject.normal) * unpackOctahedral16(normal));
  vtx.uv = uv;
  vtx.shadowCoords = light * model * vec4(pos, 1.0);
}
)";

const char* kCodeVS_Wireframe = R"(
layout (location=0) in vec3 pos;

layout(std430, buffer_reference) readonly buffer PerFrame {
  mat4 proj;
  mat4 view;
};

layout(std430, buffer_reference) readonly buffer PerObject {
  mat4 model;
};

layout(push_constant) uniform constants
{
	PerFrame perFrame;
   PerObject perObject;
} pc;

void main() {
  mat4 proj = pc.perFrame.proj;
  mat4 view = pc.perFrame.view;
  mat4 model = pc.perObject.model;
  gl_Position = proj * view * model * vec4(pos, 1.0);
}
)";

const char* kCodeFS_Wireframe = R"(
layout (location=0) out vec4 out_FragColor;

void main() {
  out_FragColor = vec4(1.0);
};
)";

const char* kCodeFS = R"(

layout(std430, buffer_reference) readonly buffer PerFrame {
  mat4 proj;
  mat4 view;
  mat4 light;
  uint texSkyboxRadiance;
  uint texSkyboxIrradiance;
  uint texShadow;
  uint sampler0;
  uint samplerShadow0;
};

struct Material {
  vec4 ambient;
  vec4 diffuse;
  int texAmbient;
  int texDiffuse;
  int texAlpha;
  int padding;
};

struct PerVertex {
  vec3 normal;
  vec2 uv;
  vec4 shadowCoords;
};

layout(push_constant) uniform constants {
  PerFrame perFrame;
} pc;

layout (location=0) in PerVertex vtx;
layout (location=5) flat in Material mtl;

layout (location=0) out vec4 out_FragColor;

layout (constant_id = 0) const bool bDrawNormals = false;

float PCF3(vec3 uvw) {
  float size = 1.0 / textureBindlessSize2D(pc.perFrame.texShadow).x;
  float shadow = 0.0;
  for (int v=-1; v<=+1; v++)
    for (int u=-1; u<=+1; u++)
      shadow += textureBindless2DShadow(pc.perFrame.texShadow, pc.perFrame.samplerShadow0, uvw + size * vec3(u, v, 0));
  return shadow / 9;
}

float shadow(vec4 s) {
  s = s / s.w;
  if (s.z > -1.0 && s.z < 1.0) {
    float depthBias = -0.00005;
    float shadowSample = PCF3(vec3(s.x, 1.0 - s.y, s.z + depthBias));
    return mix(0.3, 1.0, shadowSample);
  }
  return 1.0;
}

void main() {
  vec4 alpha = textureBindless2D(mtl.texAlpha, pc.perFrame.sampler0, vtx.uv);
  if (mtl.texAlpha > 0 && alpha.r < 0.5)
    discard;
  vec4 Ka = mtl.ambient * textureBindless2D(mtl.texAmbient, pc.perFrame.sampler0, vtx.uv);
  vec4 Kd = mtl.diffuse * textureBindless2D(mtl.texDiffuse, pc.perFrame.sampler0, vtx.uv);
  if (Kd.a < 0.5)
    discard;
  vec3 n = normalize(vtx.normal);
  float NdotL1 = clamp(dot(n, normalize(vec3(-1, 1,+1))), 0.0, 1.0);
  float NdotL2 = clamp(dot(n, normalize(vec3(-1, 1,-1))), 0.0, 1.0);
  float NdotL = 0.5 * (NdotL1+NdotL2);
  // IBL diffuse
  const vec4 f0 = vec4(0.04);
  vec4 diffuse = textureBindlessCube(pc.perFrame.texSkyboxIrradiance, pc.perFrame.sampler0, n) * Kd * (vec4(1.0) - f0);
  out_FragColor = bDrawNormals ?
    vec4(0.5 * (n+vec3(1.0)), 1.0) :
    Ka + diffuse * shadow(vtx.shadowCoords);
};
)";

const char* kShadowVS = R"(
layout (location=0) in vec3 pos;

layout(std430, buffer_reference) readonly buffer PerFrame {
  mat4 proj;
  mat4 view;
  mat4 light;
  uint texSkyboxRadiance;
  uint texSkyboxIrradiance;
  uint texShadow;
  uint sampler0;
  uint samplerShadow0;
};

layout(std430, buffer_reference) readonly buffer PerObject {
  mat4 model;
};

layout(push_constant) uniform constants {
  PerFrame perFrame;
  PerObject perObject;
} pc;

void main() {
  mat4 proj = pc.perFrame.proj;
  mat4 view = pc.perFrame.view;
  mat4 model = pc.perObject.model;
  gl_Position = proj * view * model * vec4(pos, 1.0);
}
)";

const char* kShadowFS = R"(
void main() {
};
)";

const char* kSkyboxVS = R"(
layout (location=0) out vec3 textureCoords;

const vec3 positions[8] = vec3[8](
	vec3(-1.0,-1.0, 1.0), vec3( 1.0,-1.0, 1.0), vec3( 1.0, 1.0, 1.0), vec3(-1.0, 1.0, 1.0),
	vec3(-1.0,-1.0,-1.0), vec3( 1.0,-1.0,-1.0), vec3( 1.0, 1.0,-1.0), vec3(-1.0, 1.0,-1.0)
);

const int indices[36] = int[36](
	0, 1, 2, 2, 3, 0, 1, 5, 6, 6, 2, 1, 7, 6, 5, 5, 4, 7, 4, 0, 3, 3, 7, 4, 4, 5, 1, 1, 0, 4, 3, 2, 6, 6, 7, 3
);

layout(std430, buffer_reference) readonly buffer PerFrame {
  mat4 proj;
  mat4 view;
  mat4 light;
  uint texSkyboxRadiance;
  uint texSkyboxIrradiance;
  uint texShadow;
  uint sampler0;
  uint samplerShadow0;
};

layout(push_constant) uniform constants
{
	PerFrame perFrame;
} pc;

void main() {
  mat4 proj = pc.perFrame.proj;
  mat4 view = pc.perFrame.view;
  // discard translation
  view = mat4(view[0], view[1], view[2], vec4(0, 0, 0, 1));
  mat4 transform = proj * view;
  vec3 pos = positions[indices[gl_VertexIndex]];
  gl_Position = (transform * vec4(pos, 1.0)).xyww;

  // skybox
  textureCoords = pos;
}

)";
const char* kSkyboxFS = R"(
layout (location=0) in vec3 textureCoords;
layout (location=0) out vec4 out_FragColor;

layout(std430, buffer_reference) readonly buffer PerFrame {
  mat4 proj;
  mat4 view;
  mat4 light;
  uint texSkyboxRadiance;
  uint texSkyboxIrradiance;
  uint texShadow;
  uint sampler0;
  uint samplerShadow0;
};

layout(push_constant) uniform constants {
  PerFrame perFrame;
} pc;

void main() {
  out_FragColor = textureBindlessCube(pc.perFrame.texSkyboxRadiance, pc.perFrame.sampler0, textureCoords);
}
)";

using glm::mat4;
using glm::vec2;
using glm::vec3;
using glm::vec4;

int width_ = 0;
int height_ = 0;
FramesPerSecondCounter fps_;

std::unique_ptr<lvk::IContext> ctx_;
lvk::Framebuffer fbMain_; // swapchain
lvk::Framebuffer fbOffscreen_;
lvk::Holder<lvk::TextureHandle> fbOffscreenColor_;
lvk::Holder<lvk::TextureHandle> fbOffscreenDepth_;
lvk::Holder<lvk::TextureHandle> fbOffscreenResolve_;
lvk::Framebuffer fbShadowMap_;
lvk::Holder<lvk::ShaderModuleHandle> smMeshVert_;
lvk::Holder<lvk::ShaderModuleHandle> smMeshFrag_;
lvk::Holder<lvk::ShaderModuleHandle> smMeshWireframeVert_;
lvk::Holder<lvk::ShaderModuleHandle> smMeshWireframeFrag_;
lvk::Holder<lvk::ShaderModuleHandle> smShadowVert_;
lvk::Holder<lvk::ShaderModuleHandle> smShadowFrag_;
lvk::Holder<lvk::ShaderModuleHandle> smFullscreenVert_;
lvk::Holder<lvk::ShaderModuleHandle> smFullscreenFrag_;
lvk::Holder<lvk::ShaderModuleHandle> smSkyboxVert_;
lvk::Holder<lvk::ShaderModuleHandle> smSkyboxFrag_;
lvk::Holder<lvk::ShaderModuleHandle> smGrayscaleComp_;
lvk::Holder<lvk::ComputePipelineHandle> computePipelineState_Grayscale_;
lvk::Holder<lvk::RenderPipelineHandle> renderPipelineState_Mesh_;
lvk::Holder<lvk::RenderPipelineHandle> renderPipelineState_MeshNormals_;
lvk::Holder<lvk::RenderPipelineHandle> renderPipelineState_MeshWireframe_;
lvk::Holder<lvk::RenderPipelineHandle> renderPipelineState_Shadow_;
lvk::Holder<lvk::RenderPipelineHandle> renderPipelineState_Skybox_;
lvk::Holder<lvk::RenderPipelineHandle> renderPipelineState_Fullscreen_;
lvk::Holder<lvk::BufferHandle> vb0_, ib0_; // buffers for vertices and indices
lvk::Holder<lvk::BufferHandle> sbMaterials_; // storage buffer for materials
lvk::Holder<lvk::BufferHandle> ubPerFrame_, ubPerFrameShadow_, ubPerObject_;
lvk::Holder<lvk::SamplerHandle> sampler_;
lvk::Holder<lvk::SamplerHandle> samplerShadow_;
lvk::Holder<lvk::TextureHandle> textureDummyWhite_;
lvk::Holder<lvk::TextureHandle> skyboxTextureReference_;
lvk::Holder<lvk::TextureHandle> skyboxTextureIrradiance_;
lvk::RenderPass renderPassOffscreen_;
lvk::RenderPass renderPassMain_;
lvk::RenderPass renderPassShadow_;
lvk::DepthState depthState_;
lvk::DepthState depthStateLEqual_;

// scene navigation
CameraPositioner_FirstPerson positioner_(vec3(-100, 40, -47), vec3(0, 35, 0), vec3(0, 1, 0));
Camera camera_(positioner_);
glm::vec2 mousePos_ = glm::vec2(0.0f);
bool mousePressed_ = false;
bool enableComputePass_ = false;
bool enableWireframe_ = false;
bool showPerfStats_ = false;
bool drawNormals_ = false;

bool isShadowMapDirty_ = true;

struct VertexData {
  vec3 position;
  uint32_t uv; // hvec2
  uint16_t normal; // Octahedral 16-bit https://www.shadertoy.com/view/llfcRl
  uint16_t mtlIndex;
};

static_assert(sizeof(VertexData) == 5 * sizeof(uint32_t));

vec2 msign(vec2 v) {
  return vec2(v.x >= 0.0 ? 1.0f : -1.0f, v.y >= 0.0 ? 1.0f : -1.0f);
}

// https://www.shadertoy.com/view/llfcRl
uint16_t packSnorm2x8(vec2 v) {
  glm::uvec2 d = glm::uvec2(round(127.5f + v * 127.5f));
  return d.x | (d.y << 8u);
}

// https://www.shadertoy.com/view/llfcRl
uint16_t packOctahedral16(vec3 n) {
  n /= (abs(n.x) + abs(n.y) + abs(n.z));
  return ::packSnorm2x8((n.z >= 0.0) ? vec2(n.x, n.y) : (vec2(1.0) - abs(vec2(n.y, n.x))) * msign(vec2(n)));
}

std::vector<VertexData> vertexData_;
std::vector<uint32_t> indexData_;

struct UniformsPerFrame {
  mat4 proj;
  mat4 view;
  mat4 light;
  uint32_t texSkyboxRadiance = 0;
  uint32_t texSkyboxIrradiance = 0;
  uint32_t texShadow = 0;
  uint32_t sampler = 0;
  uint32_t samplerShadow = 0;
} perFrame_;

struct UniformsPerObject {
  mat4 model;
  mat4 normal;
};
#define MAX_MATERIAL_NAME 128

struct CachedMaterial {
  char name[MAX_MATERIAL_NAME] = {};
  vec3 ambient = vec3(0.0f);
  vec3 diffuse = vec3(0.0f);
  char ambient_texname[MAX_MATERIAL_NAME] = {};
  char diffuse_texname[MAX_MATERIAL_NAME] = {};
  char alpha_texname[MAX_MATERIAL_NAME] = {};
};

// this goes into our GLSL shaders
struct GPUMaterial {
  vec4 ambient = vec4(0.0f);
  vec4 diffuse = vec4(0.0f);
  uint32_t texAmbient = 0;
  uint32_t texDiffuse = 0;
  uint32_t texAlpha = 0;
  uint32_t padding[1];
};

static_assert(sizeof(GPUMaterial) % 16 == 0);

std::vector<CachedMaterial> cachedMaterials_;
std::vector<GPUMaterial> materials_;

struct MaterialTextures {
  lvk::TextureHandle ambient;
  lvk::TextureHandle diffuse;
  lvk::TextureHandle alpha;
};

std::vector<MaterialTextures> textures_; // same indexing as in materials_

struct LoadedImage {
  uint32_t w = 0;
  uint32_t h = 0;
  uint32_t channels = 0;
  uint8_t* pixels = nullptr;
  std::string debugName;
  std::string compressedFileName;
};

struct LoadedMaterial {
  size_t idx = 0;
  LoadedImage ambient;
  LoadedImage diffuse;
  LoadedImage alpha;
};

// file name -> LoadedImage
std::mutex imagesCacheMutex_;
std::unordered_map<std::string, LoadedImage> imagesCache_; // accessible only from the loader pool (multiple threads)
std::unordered_map<std::string, lvk::Holder<lvk::TextureHandle>> texturesCache_; // accessible the main thread
std::vector<LoadedMaterial> loadedMaterials_;
std::mutex loadedMaterialsMutex_;
std::atomic<bool> loaderShouldExit_ = false;
std::atomic<uint32_t> remainingMaterialsToLoad_ = 0;
std::unique_ptr<tf::Executor> loaderPool_ = std::make_unique<tf::Executor>(std::max(2u, std::thread::hardware_concurrency() / 2));

static bool endsWith(const std::string& str, const std::string& suffix) {
  return str.size() >= suffix.size() && 0 == str.compare(str.size() - suffix.size(), suffix.size(), suffix);
}

static std::string convertFileName(std::string fileName) {
  // generate compressed filename
  const std::string compressedPathPrefix = folderContentRoot;

  if (fileName.find(compressedPathPrefix) == 0) {
    // remove leading path
    fileName = fileName.substr(compressedPathPrefix.length());
  }

  std::replace(fileName.begin(), fileName.end(), ':', '_');
  std::replace(fileName.begin(), fileName.end(), '.', '_');
  std::replace(fileName.begin(), fileName.end(), '/', '_');
  std::replace(fileName.begin(), fileName.end(), '\\', '_');

  // return absolute compressed filename
  return compressedPathPrefix + fileName + ".ktx";
}
static void stringReplaceAll(std::string& s, const std::string& searchString, const std::string& replaceString) {
  size_t pos = 0;
  while ((pos = s.find(searchString, pos)) != std::string::npos) {
    s.replace(pos, searchString.length(), replaceString);
  }
}

bool initModel();
void loadSkyboxTexture();
void loadMaterials();
void createPipelines();
void createShadowMap();
void createOffscreenFramebuffer();

bool init(lvk::LVKwindow* window) {
  {
    const uint32_t pixel = 0xFFFFFFFF;
    textureDummyWhite_ = ctx_->createTexture(
        {
            .type = lvk::TextureType_2D,
            .format = lvk::Format_R_UN8,
            .dimensions = {1, 1},
            .usage = lvk::TextureUsageBits_Sampled,
            .components = {lvk::Swizzle_1, lvk::Swizzle_1, lvk::Swizzle_1, lvk::Swizzle_1},
            .data = &pixel,
            .debugName = "dummy 1x1 (white)",
        },
        nullptr);
  }

  ubPerFrame_ = ctx_->createBuffer({
      .usage = lvk::BufferUsageBits_Uniform,
      .storage = lvk::StorageType_HostVisible,
      .size = sizeof(UniformsPerFrame),
      .debugName = "Buffer: uniforms (per frame)",
  });
  ubPerFrameShadow_ = ctx_->createBuffer({
      .usage = lvk::BufferUsageBits_Uniform,
      .storage = lvk::StorageType_HostVisible,
      .size = sizeof(UniformsPerFrame),
      .debugName = "Buffer: uniforms (per frame shadow)",
  });
  ubPerObject_ = ctx_->createBuffer({
      .usage = lvk::BufferUsageBits_Uniform,
      .storage = lvk::StorageType_HostVisible,
      .size = sizeof(UniformsPerObject),
      .debugName = "Buffer: uniforms (per object)",
  });

  depthState_ = {.compareOp = lvk::CompareOp_Less, .isDepthWriteEnabled = true};
  depthStateLEqual_ = {.compareOp = lvk::CompareOp_LessEqual, .isDepthWriteEnabled = true};

  sampler_ = ctx_->createSampler({
      .mipMap = lvk::SamplerMip_Linear,
      .wrapU = lvk::SamplerWrap_Repeat,
      .wrapV = lvk::SamplerWrap_Repeat,
      .debugName = "Sampler: linear",
  });
  samplerShadow_ = ctx_->createSampler({
      .wrapU = lvk::SamplerWrap_Clamp,
      .wrapV = lvk::SamplerWrap_Clamp,
      .depthCompareOp = lvk::CompareOp_LessEqual,
      .depthCompareEnabled = true,
      .debugName = "Sampler: shadow",
  });

  renderPassOffscreen_ = {.color = {{
                              .loadOp = lvk::LoadOp_Clear,
                              .storeOp = kNumSamplesMSAA > 1 ? lvk::StoreOp_MsaaResolve : lvk::StoreOp_Store,
                              .clearColor = {0.0f, 0.0f, 0.0f, 1.0f},
                          }},
                          .depth = {
                              .loadOp = lvk::LoadOp_Clear,
                              .storeOp = lvk::StoreOp_Store,
                              .clearDepth = 1.0f,
                          }};

  renderPassMain_ = {
      .color = {{.loadOp = lvk::LoadOp_Clear, .storeOp = lvk::StoreOp_Store, .clearColor = {0.0f, 0.0f, 0.0f, 1.0f}}},
  };
  renderPassShadow_ = {
      .color = {},
      .depth = {.loadOp = lvk::LoadOp_Clear, .storeOp = lvk::StoreOp_Store, .clearDepth = 1.0f},
  };

  fbMain_ = {
      .color = {{.texture = ctx_->getCurrentSwapchainTexture()}},
  };

  createShadowMap();
  createOffscreenFramebuffer();
  createPipelines();

  imgui_ = std::make_unique<lvk::ImGuiRenderer>(
      *ctx_, window, (folderThirdParty + "3D-Graphics-Rendering-Cookbook/data/OpenSans-Light.ttf").c_str(), float(height_) / 70.0f);

  queryPoolTimestamps_ = ctx_->createQueryPool(GPUTimestamp_NUM_TIMESTAMPS, "queryPoolTimestamps_");

  if (!initModel()) {
    return false;
  }

  loadSkyboxTexture();
  loadMaterials();

  return true;
}

void destroy() {
  imgui_ = nullptr;

  vb0_ = nullptr;
  ib0_ = nullptr;
  sbMaterials_ = nullptr;
  ubPerFrame_ = nullptr;
  ubPerFrameShadow_ = nullptr;
  ubPerObject_ = nullptr;
  smMeshVert_ = nullptr;
  smMeshFrag_ = nullptr;
  smMeshWireframeVert_ = nullptr;
  smMeshWireframeFrag_ = nullptr;
  smShadowVert_ = nullptr;
  smShadowFrag_ = nullptr;
  smFullscreenVert_ = nullptr;
  smFullscreenFrag_ = nullptr;
  smSkyboxVert_ = nullptr;
  smSkyboxFrag_ = nullptr;
  smGrayscaleComp_ = nullptr;
  renderPipelineState_Mesh_ = nullptr;
  renderPipelineState_MeshNormals_ = nullptr;
  renderPipelineState_MeshWireframe_ = nullptr;
  renderPipelineState_Shadow_ = nullptr;
  renderPipelineState_Skybox_ = nullptr;
  renderPipelineState_Fullscreen_ = nullptr;
  computePipelineState_Grayscale_ = nullptr;
  textureDummyWhite_ = nullptr;
  skyboxTextureReference_ = nullptr;
  skyboxTextureIrradiance_ = nullptr;
  textures_.clear();
  texturesCache_.clear();
  sampler_ = nullptr;
  samplerShadow_ = nullptr;
  ctx_->destroy(fbMain_);
  ctx_->destroy(fbShadowMap_);
  fbOffscreenColor_ = nullptr;
  fbOffscreenDepth_ = nullptr;
  fbOffscreenResolve_ = nullptr;
  queryPoolTimestamps_ = nullptr;
  ctx_ = nullptr;

  printf("Waiting for the loader thread to exit...\n");

  loaderPool_ = nullptr;
}

std::string normalizeTextureName(const char* n) {
  if (!n)
    return std::string();
  LVK_ASSERT(strlen(n) < MAX_MATERIAL_NAME);
  std::string name(n);
#if defined(__linux__) || defined(__APPLE__) || defined(ANDROID)
  std::replace(name.begin(), name.end(), '\\', '/');
#endif
  return name;
}

bool loadAndCache(const char* cacheFileName) {
  LVK_PROFILER_FUNCTION();

  // load 3D model and cache it
  LLOGL("Loading `exterior.obj`... It can take a while in debug builds...\n");

  fastObjMesh* mesh = fast_obj_read((folderContentRoot + "src/bistro/Exterior/exterior.obj").c_str());
  SCOPE_EXIT {
    if (mesh)
      fast_obj_destroy(mesh);
  };

  if (!LVK_VERIFY(mesh)) {
    LVK_ASSERT_MSG(false, "Did you read the tutorial at the top of this file?");
    return false;
  }

  uint32_t vertexCount = 0;

  for (uint32_t i = 0; i < mesh->face_count; ++i)
    vertexCount += mesh->face_vertices[i];

  vertexData_.reserve(vertexCount);

  uint32_t vertexIndex = 0;

  for (uint32_t face = 0; face < mesh->face_count; face++) {
    for (uint32_t v = 0; v < mesh->face_vertices[face]; v++) {
      LVK_ASSERT(v < 3);
      const fastObjIndex gi = mesh->indices[vertexIndex++];

      const float* p = &mesh->positions[gi.p * 3];
      const float* n = &mesh->normals[gi.n * 3];
      const float* t = &mesh->texcoords[gi.t * 2];

      vertexData_.push_back({
          .position = vec3(p[0], p[1], p[2]),
          .uv = glm::packHalf2x16(vec2(t[0], t[1])),
          .normal = packOctahedral16(vec3(n[0], n[1], n[2])),
          .mtlIndex = (uint16_t)mesh->face_materials[face],
      });
    }
  }

  // repack the mesh as described in https://github.com/zeux/meshoptimizer
  {
    // 1. Generate an index buffer
    const size_t indexCount = vertexData_.size();
    std::vector<uint32_t> remap(indexCount);
    const size_t vertexCount =
        meshopt_generateVertexRemap(remap.data(), nullptr, indexCount, vertexData_.data(), indexCount, sizeof(VertexData));
    // 2. Remap vertices
    std::vector<VertexData> remappedVertices;
    indexData_.resize(indexCount);
    remappedVertices.resize(vertexCount);
    meshopt_remapIndexBuffer(indexData_.data(), nullptr, indexCount, &remap[0]);
    meshopt_remapVertexBuffer(remappedVertices.data(), vertexData_.data(), indexCount, sizeof(VertexData), remap.data());
    vertexData_ = remappedVertices;
    // 3. Optimize for the GPU vertex cache reuse and overdraw
    meshopt_optimizeVertexCache(indexData_.data(), indexData_.data(), indexCount, vertexCount);
    meshopt_optimizeOverdraw(
        indexData_.data(), indexData_.data(), indexCount, &vertexData_[0].position.x, vertexCount, sizeof(VertexData), 1.05f);
    meshopt_optimizeVertexFetch(vertexData_.data(), indexData_.data(), indexCount, vertexData_.data(), vertexCount, sizeof(VertexData));
  }

  // loop over materials
  for (uint32_t mtlIdx = 0; mtlIdx != mesh->material_count; mtlIdx++) {
    const fastObjMaterial& m = mesh->materials[mtlIdx];
    CachedMaterial mtl;
    mtl.ambient = vec3(m.Ka[0], m.Ka[1], m.Ka[2]);
    mtl.diffuse = vec3(m.Kd[0], m.Kd[1], m.Kd[2]);
    LVK_ASSERT(strlen(m.name) < MAX_MATERIAL_NAME);
    strcat(mtl.name, m.name);
    strcat(mtl.ambient_texname, normalizeTextureName(mesh->textures[m.map_Ka].name).c_str());
    strcat(mtl.diffuse_texname, normalizeTextureName(mesh->textures[m.map_Kd].name).c_str());
    strcat(mtl.alpha_texname, normalizeTextureName(mesh->textures[m.map_d].name).c_str());
    cachedMaterials_.push_back(mtl);
  }

  LLOGL("Caching mesh...\n");

  FILE* cacheFile = fopen(cacheFileName, "wb");
  if (!cacheFile) {
    return false;
  }
  const uint32_t numMaterials = (uint32_t)cachedMaterials_.size();
  const uint32_t numVertices = (uint32_t)vertexData_.size();
  const uint32_t numIndices = (uint32_t)indexData_.size();
  fwrite(&kMeshCacheVersion, sizeof(kMeshCacheVersion), 1, cacheFile);
  fwrite(&numMaterials, sizeof(numMaterials), 1, cacheFile);
  fwrite(&numVertices, sizeof(numVertices), 1, cacheFile);
  fwrite(&numIndices, sizeof(numIndices), 1, cacheFile);
  fwrite(cachedMaterials_.data(), sizeof(CachedMaterial), numMaterials, cacheFile);
  fwrite(vertexData_.data(), sizeof(VertexData), numVertices, cacheFile);
  fwrite(indexData_.data(), sizeof(uint32_t), numIndices, cacheFile);
  return fclose(cacheFile) == 0;
}

bool loadFromCache(const char* cacheFileName) {
  FILE* cacheFile = fopen(cacheFileName, "rb");
  SCOPE_EXIT {
    if (cacheFile) {
      fclose(cacheFile);
    }
  };
  if (!cacheFile) {
    return false;
  }
#define CHECK_READ(expected, read) \
  if ((read) != (expected)) {      \
    return false;                  \
  }
  uint32_t versionProbe = 0;
  CHECK_READ(1, fread(&versionProbe, sizeof(versionProbe), 1, cacheFile));
  if (versionProbe != kMeshCacheVersion) {
    LLOGL("Cache file has wrong version id\n");
    return false;
  }
  uint32_t numMaterials = 0;
  uint32_t numVertices = 0;
  uint32_t numIndices = 0;
  CHECK_READ(1, fread(&numMaterials, sizeof(numMaterials), 1, cacheFile));
  CHECK_READ(1, fread(&numVertices, sizeof(numVertices), 1, cacheFile));
  CHECK_READ(1, fread(&numIndices, sizeof(numIndices), 1, cacheFile));
  cachedMaterials_.resize(numMaterials);
  vertexData_.resize(numVertices);
  indexData_.resize(numIndices);
  CHECK_READ(numMaterials, fread(cachedMaterials_.data(), sizeof(CachedMaterial), numMaterials, cacheFile));
  CHECK_READ(numVertices, fread(vertexData_.data(), sizeof(VertexData), numVertices, cacheFile));
  CHECK_READ(numIndices, fread(indexData_.data(), sizeof(uint32_t), numIndices, cacheFile));
#undef CHECK_READ
  return true;
}

bool initModel() {
  const std::string cacheFileName = folderContentRoot + "cache.data";

  if (!loadFromCache(cacheFileName.c_str())) {
    if (!LVK_VERIFY(loadAndCache(cacheFileName.c_str()))) {
      LVK_ASSERT_MSG(false, "Cannot load 3D model");
      return false;
    }
  }

  for (const auto& mtl : cachedMaterials_) {
    materials_.push_back(
        GPUMaterial{vec4(mtl.ambient, 1.0f), vec4(mtl.diffuse, 1.0f), textureDummyWhite_.index(), textureDummyWhite_.index()});
  }

  sbMaterials_ = ctx_->createBuffer({.usage = lvk::BufferUsageBits_Storage,
                                     .storage = lvk::StorageType_Device,
                                     .size = sizeof(GPUMaterial) * materials_.size(),
                                     .data = materials_.data(),
                                     .debugName = "Buffer: materials"},
                                    nullptr);

  vb0_ = ctx_->createBuffer({.usage = lvk::BufferUsageBits_Vertex,
                             .storage = lvk::StorageType_Device,
                             .size = sizeof(VertexData) * vertexData_.size(),
                             .data = vertexData_.data(),
                             .debugName = "Buffer: vertex"},
                            nullptr);
  ib0_ = ctx_->createBuffer({.usage = lvk::BufferUsageBits_Index,
                             .storage = lvk::StorageType_Device,
                             .size = sizeof(uint32_t) * indexData_.size(),
                             .data = indexData_.data(),
                             .debugName = "Buffer: index"},
                            nullptr);
  return true;
}

void createPipelines() {
  if (renderPipelineState_Mesh_.valid()) {
    return;
  }

  const lvk::VertexInput vdesc = {
      .attributes =
          {
              {.location = 0, .format = lvk::VertexFormat::Float3, .offset = offsetof(VertexData, position)},
              {.location = 1, .format = lvk::VertexFormat::HalfFloat2, .offset = offsetof(VertexData, uv)},
              {.location = 2, .format = lvk::VertexFormat::UShort1, .offset = offsetof(VertexData, normal)},
              {.location = 3, .format = lvk::VertexFormat::UShort1, .offset = offsetof(VertexData, mtlIndex)},
          },
      .inputBindings = {{.stride = sizeof(VertexData)}},
  };

  // shadow
  const lvk::VertexInput vdescs = {
      .attributes = {{.format = lvk::VertexFormat::Float3, .offset = offsetof(VertexData, position)}},
      .inputBindings = {{.stride = sizeof(VertexData)}},
  };

#if defined(LVK_DEMO_WITH_SLANG)
  smMeshVert_ = ctx_->createShaderModule({codeSlang, lvk::Stage_Vert, "Shader Module: main (vert)"});
  smMeshFrag_ = ctx_->createShaderModule({codeSlang, lvk::Stage_Frag, "Shader Module: main (frag)"});
  smMeshWireframeVert_ = ctx_->createShaderModule({codeWireframeSlang, lvk::Stage_Vert, "Shader Module: main wireframe (vert)"});
  smMeshWireframeFrag_ = ctx_->createShaderModule({codeWireframeSlang, lvk::Stage_Frag, "Shader Module: main wireframe (frag)"});
  smShadowVert_ = ctx_->createShaderModule({codeShadowSlang, lvk::Stage_Vert, "Shader Module: shadow (vert)"});
  smShadowFrag_ = ctx_->createShaderModule({codeShadowSlang, lvk::Stage_Frag, "Shader Module: shadow (frag)"});
  smFullscreenVert_ = ctx_->createShaderModule({codeFullscreenSlang, lvk::Stage_Vert, "Shader Module: fullscreen (vert)"});
  smFullscreenFrag_ = ctx_->createShaderModule({codeFullscreenSlang, lvk::Stage_Frag, "Shader Module: fullscreen (frag)"});
  smSkyboxVert_ = ctx_->createShaderModule({codeSkyboxSlang, lvk::Stage_Vert, "Shader Module: skybox (vert)"});
  smSkyboxFrag_ = ctx_->createShaderModule({codeSkyboxSlang, lvk::Stage_Frag, "Shader Module: skybox (frag)"});
#else
  smMeshVert_ = ctx_->createShaderModule({kCodeVS, lvk::Stage_Vert, "Shader Module: main (vert)"});
  smMeshFrag_ = ctx_->createShaderModule({kCodeFS, lvk::Stage_Frag, "Shader Module: main (frag)"});
  smMeshWireframeVert_ = ctx_->createShaderModule({kCodeVS_Wireframe, lvk::Stage_Vert, "Shader Module: main wireframe (vert)"});
  smMeshWireframeFrag_ = ctx_->createShaderModule({kCodeFS_Wireframe, lvk::Stage_Frag, "Shader Module: main wireframe (frag)"});
  smShadowVert_ = ctx_->createShaderModule({kShadowVS, lvk::Stage_Vert, "Shader Module: shadow (vert)"});
  smShadowFrag_ = ctx_->createShaderModule({kShadowFS, lvk::Stage_Frag, "Shader Module: shadow (frag)"});
  smFullscreenVert_ = ctx_->createShaderModule({kCodeFullscreenVS, lvk::Stage_Vert, "Shader Module: fullscreen (vert)"});
  smFullscreenFrag_ = ctx_->createShaderModule({kCodeFullscreenFS, lvk::Stage_Frag, "Shader Module: fullscreen (frag)"});
  smSkyboxVert_ = ctx_->createShaderModule({kSkyboxVS, lvk::Stage_Vert, "Shader Module: skybox (vert)"});
  smSkyboxFrag_ = ctx_->createShaderModule({kSkyboxFS, lvk::Stage_Frag, "Shader Module: skybox (frag)"});
#endif // defined(LVK_DEMO_WITH_SLANG)

  {
    lvk::RenderPipelineDesc desc = {
        .vertexInput = vdesc,
        .smVert = smMeshVert_,
        .smFrag = smMeshFrag_,
        .color = {{.format = ctx_->getFormat(fbOffscreen_.color[0].texture)}},
        .depthFormat = ctx_->getFormat(fbOffscreen_.depthStencil.texture),
        .cullMode = lvk::CullMode_Back,
        .frontFace = lvk::WindingMode_CCW,
        .samplesCount = kNumSamplesMSAA,
        .debugName = "Pipeline: mesh",
    };

    renderPipelineState_Mesh_ = ctx_->createRenderPipeline(desc, nullptr);

    const uint32_t drawNormals = 1;

    desc.specInfo = {.entries = {{.constantId = 0, .size = sizeof(uint32_t)}}, .data = &drawNormals, .dataSize = sizeof(drawNormals)},

    renderPipelineState_MeshNormals_ = ctx_->createRenderPipeline(desc, nullptr);

    desc.polygonMode = lvk::PolygonMode_Line;
    desc.vertexInput = vdescs; // positions-only
    desc.smVert = smMeshWireframeVert_;
    desc.smFrag = smMeshWireframeFrag_;
    desc.debugName = "Pipeline: mesh (wireframe)";
    renderPipelineState_MeshWireframe_ = ctx_->createRenderPipeline(desc, nullptr);
  }

  // shadow
  renderPipelineState_Shadow_ = ctx_->createRenderPipeline(
      lvk::RenderPipelineDesc{
          .vertexInput = vdescs,
          .smVert = smShadowVert_,
          .smFrag = smShadowFrag_,
          .depthFormat = ctx_->getFormat(fbShadowMap_.depthStencil.texture),
          .cullMode = lvk::CullMode_None,
          .debugName = "Pipeline: shadow",
      },
      nullptr);

  // fullscreen
  {
    const lvk::RenderPipelineDesc desc = {
        .smVert = smFullscreenVert_,
        .smFrag = smFullscreenFrag_,
        .color = {{.format = ctx_->getFormat(fbMain_.color[0].texture)}},
        .depthFormat = ctx_->getFormat(fbMain_.depthStencil.texture),
        .cullMode = lvk::CullMode_None,
        .debugName = "Pipeline: fullscreen",
    };
    renderPipelineState_Fullscreen_ = ctx_->createRenderPipeline(desc, nullptr);
  }

  // skybox
  {
    const lvk::RenderPipelineDesc desc = {
        .smVert = smSkyboxVert_,
        .smFrag = smSkyboxFrag_,
        .color = {{
            .format = ctx_->getFormat(fbOffscreen_.color[0].texture),
        }},
        .depthFormat = ctx_->getFormat(fbOffscreen_.depthStencil.texture),
        .cullMode = lvk::CullMode_Front,
        .frontFace = lvk::WindingMode_CCW,
        .samplesCount = kNumSamplesMSAA,
        .debugName = "Pipeline: skybox",
    };

    renderPipelineState_Skybox_ = ctx_->createRenderPipeline(desc, nullptr);
  }

#if defined(LVK_DEMO_WITH_SLANG)
  smGrayscaleComp_ = ctx_->createShaderModule({codeComputeTestSlang, lvk::Stage_Comp, "Shader Module: grayscale (comp)"});
#else
  smGrayscaleComp_ = ctx_->createShaderModule({kCodeComputeTest, lvk::Stage_Comp, "Shader Module: grayscale (comp)"});
#endif // defined(LVK_DEMO_WITH_SLANG)

  computePipelineState_Grayscale_ = ctx_->createComputePipeline({.smComp = smGrayscaleComp_}, nullptr);
}

void createShadowMap() {
  const uint32_t w = 4096;
  const uint32_t h = 4096;
  const lvk::TextureDesc desc = {
      .type = lvk::TextureType_2D,
      .format = lvk::Format_Z_UN16,
      .dimensions = {w, h},
      .usage = lvk::TextureUsageBits_Attachment | lvk::TextureUsageBits_Sampled,
      .numMipLevels = lvk::calcNumMipLevels(w, h),
      .debugName = "Shadow map",
  };
  fbShadowMap_ = {
      .depthStencil = {.texture = ctx_->createTexture(desc).release()},
  };
}

void createOffscreenFramebuffer() {
  const uint32_t w = width_;
  const uint32_t h = height_;
  lvk::TextureDesc descDepth = {
      .type = lvk::TextureType_2D,
      .format = lvk::Format_Z_UN24,
      .dimensions = {w, h},
      .usage = lvk::TextureUsageBits_Attachment | lvk::TextureUsageBits_Sampled,
      .numMipLevels = lvk::calcNumMipLevels(w, h),
      .debugName = "Offscreen framebuffer (d)",
  };
  if (kNumSamplesMSAA > 1) {
    descDepth.usage = lvk::TextureUsageBits_Attachment;
    descDepth.numSamples = kNumSamplesMSAA;
    descDepth.numMipLevels = 1;
  }

  const uint8_t usage = lvk::TextureUsageBits_Attachment | lvk::TextureUsageBits_Sampled | lvk::TextureUsageBits_Storage;
  const lvk::Format format = lvk::Format_RGBA_UN8;

  lvk::TextureDesc descColor = {
      .type = lvk::TextureType_2D,
      .format = format,
      .dimensions = {w, h},
      .usage = usage,
      .numMipLevels = lvk::calcNumMipLevels(w, h),
      .debugName = "Offscreen framebuffer (color)",
  };
  if (kNumSamplesMSAA > 1) {
    descColor.usage = lvk::TextureUsageBits_Attachment;
    descColor.numSamples = kNumSamplesMSAA;
    descColor.numMipLevels = 1;
  }

  fbOffscreenColor_ = ctx_->createTexture(descColor);
  fbOffscreenDepth_ = ctx_->createTexture(descDepth);
  lvk::Framebuffer fb = {
      .color = {{.texture = fbOffscreenColor_}},
      .depthStencil = {.texture = fbOffscreenDepth_},
  };

  if (kNumSamplesMSAA > 1) {
    fbOffscreenResolve_ = ctx_->createTexture({.type = lvk::TextureType_2D,
                                               .format = format,
                                               .dimensions = {w, h},
                                               .usage = usage,
                                               .debugName = "Offscreen framebuffer (color resolve)"});
    fb.color[0].resolveTexture = fbOffscreenResolve_;
  }

  fbOffscreen_ = fb;
}

void resize() {
  if (!width_ || !height_) {
    return;
  }
  ctx_->recreateSwapchain(width_, height_);
  createOffscreenFramebuffer();
}

void showTimeGPU();
double getCurrentTimestamp();
void processLoadedMaterials(lvk::ICommandBuffer& buffer);

void render(double delta) {
  LVK_PROFILER_FUNCTION();

  if (!width_ && !height_)
    return;

  lvk::TextureHandle nativeDrawable = ctx_->getCurrentSwapchainTexture();
  fbMain_.color[0].texture = nativeDrawable;

  // imGui
  {
    imgui_->beginFrame(fbMain_);
    ImGui::ShowDemoWindow();

    ImGui::Begin("Keyboard hints:", nullptr, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoNavInputs);
    ImGui::Text("W/S/A/D - camera movement");
    ImGui::Text("1/2 - camera up/down");
    ImGui::Text("Shift - fast movement");
    ImGui::Text("C - toggle compute shader postprocessing");
    ImGui::Text("N - toggle normals");
    ImGui::Text("T - toggle wireframe");
    ImGui::Text("P - show perf stats");
    ImGui::End();

    if (!textures_[1].diffuse.empty()) {
      ImGui::Begin("Texture Viewer", nullptr, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoNavInputs);
      ImGui::Image(textures_[1].diffuse.index(), ImVec2(256, 256));
      ImGui::End();
    }

    if (uint32_t num = remainingMaterialsToLoad_.load(std::memory_order_acquire)) {
      ImGui::SetNextWindowPos(ImVec2(0, 0));
      ImGui::Begin("Loading...", nullptr, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_NoNavInputs);
      ImGui::ProgressBar(1.0f - float(num) / cachedMaterials_.size(), ImVec2(ImGui::GetIO().DisplaySize.x, 32));
      ImGui::End();
    }
    // a nice FPS counter
    {
      const ImGuiWindowFlags flags = ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings |
                                     ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoNav | ImGuiWindowFlags_NoNavInputs |
                                     ImGuiWindowFlags_NoMove;
      const ImGuiViewport* v = ImGui::GetMainViewport();
      LVK_ASSERT(v);
      ImGui::SetNextWindowPos(
          {
              v->WorkPos.x + v->WorkSize.x - 15.0f,
              v->WorkPos.y + 15.0f,
          },
          ImGuiCond_Always,
          {1.0f, 0.0f});
      ImGui::SetNextWindowBgAlpha(0.30f);
      ImGui::SetNextWindowSize(ImVec2(ImGui::CalcTextSize("FPS : _______").x, 0));
      if (ImGui::Begin("##FPS", nullptr, flags)) {
        ImGui::Text("FPS : %i", (int)fps_.getFPS());
        ImGui::Text("Ms  : %.1f", 1000.0 / fps_.getFPS());
      }
      ImGui::End();
    }

    if (showPerfStats_)
      showTimeGPU();
  }

  positioner_.update(delta, mousePos_, mousePressed_);

  timestampBeginRendering = getCurrentTimestamp();

  const float fov = float(45.0f * (M_PI / 180.0f));
  const float aspectRatio = (float)width_ / (float)height_;

  const mat4 shadowProj = glm::perspective(float(60.0f * (M_PI / 180.0f)), 1.0f, 10.0f, 4000.0f);
  const mat4 shadowView = mat4(vec4(0.772608519f, 0.532385886f, -0.345892131f, 0),
                               vec4(0, 0.544812560f, 0.838557839f, 0),
                               vec4(0.634882748f, -0.647876859f, 0.420926809f, 0),
                               vec4(-58.9244843f, -30.4530792f, -508.410126f, 1.0f));
  const mat4 scaleBias = mat4(0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.5, 0.5, 0.0, 1.0);

  perFrame_ = UniformsPerFrame{
      .proj = glm::perspective(fov, aspectRatio, 0.5f, 500.0f),
      .view = camera_.getViewMatrix(),
      .light = scaleBias * shadowProj * shadowView,
      .texSkyboxRadiance = skyboxTextureReference_.index(),
      .texSkyboxIrradiance = skyboxTextureIrradiance_.index(),
      .texShadow = fbShadowMap_.depthStencil.texture.index(),
      .sampler = sampler_.index(),
      .samplerShadow = samplerShadow_.index(),
  };

  const mat4 modelMatrix = glm::scale(mat4(1.0f), vec3(0.05f));

  const UniformsPerObject perObject = {
      .model = modelMatrix,
      .normal = glm::transpose(glm::inverse(modelMatrix)),
  };

  lvk::ICommandBuffer& buffer = ctx_->acquireCommandBuffer();

  processLoadedMaterials(buffer);

  buffer.cmdUpdateBuffer(ubPerFrame_, 0, sizeof(perFrame_), &perFrame_);
  buffer.cmdUpdateBuffer(ubPerObject_, 0, sizeof(perObject), &perObject);

  // Pass 1: shadows
  if (isShadowMapDirty_) {
    const UniformsPerFrame perFrameShadow{
        .proj = shadowProj,
        .view = shadowView,
    };
    buffer.cmdUpdateBuffer(ubPerFrameShadow_, 0, sizeof(perFrameShadow), &perFrameShadow);
    buffer.cmdBeginRendering(renderPassShadow_, fbShadowMap_);
    {
      buffer.cmdBindRenderPipeline(renderPipelineState_Shadow_);
      buffer.cmdPushDebugGroupLabel("Render Shadows", 0xff0000ff);
      buffer.cmdBindDepthState(depthState_);
      buffer.cmdBindVertexBuffer(0, vb0_, 0);
      struct {
        uint64_t perFrame;
        uint64_t perObject;
      } bindings = {
          .perFrame = ctx_->gpuAddress(ubPerFrameShadow_),
          .perObject = ctx_->gpuAddress(ubPerObject_),
      };
      buffer.cmdPushConstants(bindings);
      buffer.cmdBindIndexBuffer(ib0_, lvk::IndexFormat_UI32);
      buffer.cmdDrawIndexed(static_cast<uint32_t>(indexData_.size()));
      buffer.cmdPopDebugGroupLabel();
    }
    buffer.cmdEndRendering();
    buffer.transitionToShaderReadOnly(fbShadowMap_.depthStencil.texture);
    buffer.cmdGenerateMipmap(fbShadowMap_.depthStencil.texture);
    isShadowMapDirty_ = false;
  }

#define GPU_TIMESTAMP(timestamp) buffer.cmdWriteTimestamp(queryPoolTimestamps_, timestamp);

  // Pass 2: mesh
  {
    buffer.cmdResetQueryPool(queryPoolTimestamps_, 0, GPUTimestamp_NUM_TIMESTAMPS);

    GPU_TIMESTAMP(GPUTimestamp_BeginSceneRendering);

    // This will clear the framebuffer
    buffer.cmdBeginRendering(renderPassOffscreen_, fbOffscreen_);
    {
      // Scene
      buffer.cmdBindRenderPipeline(drawNormals_ ? renderPipelineState_MeshNormals_ : renderPipelineState_Mesh_);
      buffer.cmdPushDebugGroupLabel("Render Mesh", 0xff0000ff);
      buffer.cmdBindDepthState(depthState_);
      buffer.cmdBindVertexBuffer(0, vb0_, 0);

      struct {
        uint64_t perFrame;
        uint64_t perObject;
        uint64_t materials;
      } bindings = {
          .perFrame = ctx_->gpuAddress(ubPerFrame_),
          .perObject = ctx_->gpuAddress(ubPerObject_),
          .materials = ctx_->gpuAddress(sbMaterials_),
      };
      buffer.cmdPushConstants(bindings);
      buffer.cmdBindIndexBuffer(ib0_, lvk::IndexFormat_UI32);
      buffer.cmdDrawIndexed(static_cast<uint32_t>(indexData_.size()));
      if (enableWireframe_) {
        buffer.cmdBindRenderPipeline(renderPipelineState_MeshWireframe_);
        buffer.cmdDrawIndexed(static_cast<uint32_t>(indexData_.size()));
      }
      buffer.cmdPopDebugGroupLabel();

      // Skybox
      buffer.cmdBindRenderPipeline(renderPipelineState_Skybox_);
      buffer.cmdPushDebugGroupLabel("Render Skybox", 0x00ff00ff);
      buffer.cmdBindDepthState(depthStateLEqual_);
      buffer.cmdDraw(3 * 6 * 2);
      buffer.cmdPopDebugGroupLabel();
    }
    buffer.cmdEndRendering();

    GPU_TIMESTAMP(GPUTimestamp_EndSceneRendering);
  }

  // Pass 3: compute shader post-processing
  {
    GPU_TIMESTAMP(GPUTimestamp_BeginComputePass);

    if (enableComputePass_) {
      lvk::TextureHandle tex = kNumSamplesMSAA > 1 ? fbOffscreen_.color[0].resolveTexture : fbOffscreen_.color[0].texture;

      buffer.cmdBindComputePipeline(computePipelineState_Grayscale_);

      struct {
        uint32_t texture;
        uint32_t width;
        uint32_t height;
      } bindings = {
          .texture = tex.index(),
          .width = (uint32_t)width_,
          .height = (uint32_t)height_,
      };
      buffer.cmdPushConstants(bindings);
      buffer.cmdDispatchThreadGroups(
          {
              .width = 1 + (uint32_t)width_ / 16,
              .height = 1 + (uint32_t)height_ / 16,
              .depth = 1u,
          },
          {
              .textures = {tex},
          });
    }
    GPU_TIMESTAMP(GPUTimestamp_EndComputePass);
  }

  // Pass 4: render into the swapchain image
  {
    GPU_TIMESTAMP(GPUTimestamp_BeginPresent);

    lvk::TextureHandle tex = kNumSamplesMSAA > 1 ? fbOffscreen_.color[0].resolveTexture : fbOffscreen_.color[0].texture;

    // This will clear the framebuffer
    buffer.cmdBeginRendering(renderPassMain_, fbMain_, {.textures = {tex}});
    {
      buffer.cmdBindRenderPipeline(renderPipelineState_Fullscreen_);
      buffer.cmdPushDebugGroupLabel("Swapchain Output", 0xff0000ff);
      buffer.cmdBindDepthState(depthState_);
      struct {
        uint32_t texture;
      } bindings = {
          .texture = tex.index(),
      };
      buffer.cmdPushConstants(bindings);
      buffer.cmdDraw(3);
      buffer.cmdPopDebugGroupLabel();

      imgui_->endFrame(buffer);
    }
    buffer.cmdEndRendering();

    GPU_TIMESTAMP(GPUTimestamp_EndPresent);
  }

  ctx_->submit(buffer, fbMain_.color[0].texture);

  timestampEndRendering = getCurrentTimestamp();

  // timestamp stats
  if (showPerfStats_) {
    ctx_->getQueryPoolResults(queryPoolTimestamps_,
                              0,
                              LVK_ARRAY_NUM_ELEMENTS(pipelineTimestamps),
                              sizeof(pipelineTimestamps),
                              pipelineTimestamps,
                              sizeof(pipelineTimestamps[0]));
  }
}

void generateCompressedTexture(LoadedImage img) {
  LVK_PROFILER_FUNCTION();

  if (loaderShouldExit_.load(std::memory_order_acquire)) {
    return;
  }

  printf("...compressing texture to %s\n", img.compressedFileName.c_str());

  const uint32_t mipmapLevelCount = lvk::calcNumMipLevels(img.w, img.h);

  // create a KTX2 texture for RGBA data
  ktxTextureCreateInfo createInfoKTX2 = {
      .glInternalformat = GL_RGBA8,
      .vkFormat = VK_FORMAT_R8G8B8A8_UNORM,
      .baseWidth = img.w,
      .baseHeight = img.h,
      .baseDepth = 1u,
      .numDimensions = 2u,
      .numLevels = mipmapLevelCount,
      .numLayers = 1u,
      .numFaces = 1u,
      .generateMipmaps = KTX_FALSE,
  };
  ktxTexture2* textureKTX2 = nullptr;
  (void)LVK_VERIFY(ktxTexture2_Create(&createInfoKTX2, KTX_TEXTURE_CREATE_ALLOC_STORAGE, &textureKTX2) == KTX_SUCCESS);

  SCOPE_EXIT {
    ktxTexture_Destroy(ktxTexture(textureKTX2));
  };

  uint32_t w = img.w;
  uint32_t h = img.h;

  // generate custom mip-pyramid
  for (uint32_t i = 0; i != mipmapLevelCount; ++i) {
    size_t offset = 0;
    ktxTexture_GetImageOffset(ktxTexture(textureKTX2), i, 0, 0, &offset);

    stbir_resize_uint8_linear((const unsigned char*)img.pixels,
                              (int)img.w,
                              (int)img.h,
                              0,
                              ktxTexture_GetData(ktxTexture(textureKTX2)) + offset,
                              w,
                              h,
                              0,
                              STBIR_RGBA);

    h = h > 1 ? h >> 1 : 1;
    w = w > 1 ? w >> 1 : 1;
  }

  if (loaderShouldExit_.load(std::memory_order_acquire)) {
    return;
  }

  // compress to Basis and transcode to BC7
  ktxBasisParams params = {
      .structSize = sizeof(params),
      .threadCount = 8,
      .compressionLevel = KTX_ETC1S_DEFAULT_COMPRESSION_LEVEL,
      .qualityLevel = 255,
  };
  (void)LVK_VERIFY(ktxTexture2_CompressBasisEx(textureKTX2, &params) == KTX_SUCCESS);
  (void)LVK_VERIFY(ktxTexture2_TranscodeBasis(textureKTX2, KTX_TTF_BC7_RGBA, 0) == KTX_SUCCESS);

  // convert to KTX1
  ktxTextureCreateInfo createInfoKTX1 = {
      .glInternalformat = GL_COMPRESSED_RGBA_BPTC_UNORM,
      .vkFormat = VK_FORMAT_BC7_UNORM_BLOCK,
      .baseWidth = img.w,
      .baseHeight = img.h,
      .baseDepth = 1u,
      .numDimensions = 2u,
      .numLevels = mipmapLevelCount,
      .numLayers = 1u,
      .numFaces = 1u,
      .generateMipmaps = KTX_FALSE,
  };
  ktxTexture1* textureKTX1 = nullptr;
  (void)LVK_VERIFY(ktxTexture1_Create(&createInfoKTX1, KTX_TEXTURE_CREATE_ALLOC_STORAGE, &textureKTX1) == KTX_SUCCESS);

  for (uint32_t i = 0; i != mipmapLevelCount; ++i) {
    size_t offset1 = 0;
    (void)LVK_VERIFY(ktxTexture_GetImageOffset(ktxTexture(textureKTX1), i, 0, 0, &offset1) == KTX_SUCCESS);
    size_t offset2 = 0;
    (void)LVK_VERIFY(ktxTexture_GetImageOffset(ktxTexture(textureKTX2), i, 0, 0, &offset2) == KTX_SUCCESS);
    memcpy(ktxTexture_GetData(ktxTexture(textureKTX1)) + offset1,
           ktxTexture_GetData(ktxTexture(textureKTX2)) + offset2,
           ktxTexture_GetImageSize(ktxTexture(textureKTX1), i));
  }

  ktxTexture_WriteToNamedFile(ktxTexture(textureKTX1), img.compressedFileName.c_str());
}

LoadedImage loadImage(const char* fileName, int channels) {
  LVK_PROFILER_FUNCTION();

  if (!fileName || !*fileName) {
    return LoadedImage();
  }

  char debugStr[512] = {0};

  snprintf(debugStr, sizeof(debugStr) - 1, "%s (%i)", fileName, channels);

  const std::string debugName(debugStr);

  {
    std::lock_guard lock(imagesCacheMutex_);

    const auto it = imagesCache_.find(debugName);

    if (it != imagesCache_.end()) {
      LVK_ASSERT(channels == it->second.channels);
      return it->second;
    }
  }

  int w, h;
  uint8_t* pixels = stbi_load(fileName, &w, &h, nullptr, channels);

  const LoadedImage img = {
      .w = (uint32_t)w,
      .h = (uint32_t)h,
      .channels = (uint32_t)channels,
      .pixels = pixels,
      .debugName = debugName,
      .compressedFileName = convertFileName(fileName),
  };

  if (img.pixels && kEnableCompression && (channels != 1) && !std::filesystem::exists(img.compressedFileName.c_str())) {
    generateCompressedTexture(img);
  }

  std::lock_guard lock(imagesCacheMutex_);

  imagesCache_[fileName] = img;

  return img;
}

void loadMaterial(size_t i) {
  LVK_PROFILER_FUNCTION();

  static const std::string pathPrefix = folderContentRoot + "src/bistro/Exterior/";

  SCOPE_EXIT {
    remainingMaterialsToLoad_.fetch_sub(1u, std::memory_order_release);
  };

#define LOAD_TEX(result, tex, channels)                                                                                                   \
  const LoadedImage result =                                                                                                              \
      std::string(cachedMaterials_[i].tex).empty() ? LoadedImage() : loadImage((pathPrefix + cachedMaterials_[i].tex).c_str(), channels); \
  if (loaderShouldExit_.load(std::memory_order_acquire)) {                                                                                \
    return;                                                                                                                               \
  }

  LOAD_TEX(ambient, ambient_texname, 4);
  LOAD_TEX(diffuse, diffuse_texname, 4);
  LOAD_TEX(alpha, alpha_texname, 1);

#undef LOAD_TEX

  const LoadedMaterial mtl{i, ambient, diffuse, alpha};

  if (!mtl.ambient.pixels && !mtl.diffuse.pixels) {
    // skip missing textures
    materials_[i].texDiffuse = 0;
  } else {
    std::lock_guard guard(loadedMaterialsMutex_);
    loadedMaterials_.push_back(mtl);
    remainingMaterialsToLoad_.fetch_add(1u, std::memory_order_release);
  }
}

void loadMaterials() {
  stbi_set_flip_vertically_on_load(1);

  remainingMaterialsToLoad_ = (uint32_t)cachedMaterials_.size();

  textures_.resize(cachedMaterials_.size());
  for (size_t i = 0; i != cachedMaterials_.size(); i++) {
    loaderPool_->silent_async([i]() { loadMaterial(i); });
  }
}

lvk::Format ktx2iglTextureFormat(ktx_uint32_t format) {
  switch (format) {
  case GL_RGBA32F:
    return lvk::Format_RGBA_F32;
  case GL_RG16F:
    return lvk::Format_RG_F16;
  default:;
  }
  LVK_ASSERT_MSG(false, "Code should NOT be reached");
  return lvk::Format_RGBA_UN8;
}

void loadCubemapTexture(const std::string& fileNameKTX, lvk::Holder<lvk::TextureHandle>& tex) {
  LVK_PROFILER_FUNCTION();

  ktxTexture1* texture = nullptr;
  (void)LVK_VERIFY(ktxTexture1_CreateFromNamedFile(fileNameKTX.c_str(), KTX_TEXTURE_CREATE_LOAD_IMAGE_DATA_BIT, &texture) == KTX_SUCCESS);
  SCOPE_EXIT {
    ktxTexture_Destroy(ktxTexture(texture));
  };

  if (!LVK_VERIFY(texture->glInternalformat == GL_RGBA32F)) {
    LVK_ASSERT_MSG(false, "Texture format not supported");
    return;
  }

  const uint32_t width = texture->baseWidth;
  const uint32_t height = texture->baseHeight;

  if (tex.empty()) {
    tex = ctx_->createTexture({
        .type = lvk::TextureType_Cube,
        .format = ktx2iglTextureFormat(texture->glInternalformat),
        .dimensions = {width, height},
        .usage = lvk::TextureUsageBits_Sampled,
        .numMipLevels = lvk::calcNumMipLevels(width, height),
        .data = texture->pData,
        // if compression is enabled, upload all mip-levels
        .dataNumMipLevels = kEnableCompression ? lvk::calcNumMipLevels(width, height) : 1u,
        .generateMipmaps = !kEnableCompression,
        .debugName = fileNameKTX.c_str(),
    });
  }
}

ktxTexture1* bitmapToCube(Bitmap& bmp) {
  LVK_ASSERT(bmp.comp_ == 3); // RGB
  LVK_ASSERT(bmp.type_ == eBitmapType_Cube);
  LVK_ASSERT(bmp.fmt_ == eBitmapFormat_Float);

  const int w = bmp.w_;
  const int h = bmp.h_;

  const uint32_t mipLevels = lvk::calcNumMipLevels(w, h);

  ktxTextureCreateInfo createInfo = {
      .glInternalformat = GL_RGBA32F,
      .vkFormat = VK_FORMAT_R32G32B32A32_SFLOAT,
      .baseWidth = static_cast<uint32_t>(w),
      .baseHeight = static_cast<uint32_t>(h),
      .baseDepth = 1u,
      .numDimensions = 2u,
      .numLevels = mipLevels,
      .numLayers = 1u,
      .numFaces = 6u,
      .generateMipmaps = KTX_FALSE,
  };

  ktxTexture1* texture = nullptr;
  (void)LVK_VERIFY(ktxTexture1_Create(&createInfo, KTX_TEXTURE_CREATE_ALLOC_STORAGE, &texture) == KTX_SUCCESS);

  const int numFacePixels = w * h;

  for (size_t face = 0; face != 6; face++) {
    const vec3* src = reinterpret_cast<vec3*>(bmp.data_.data()) + face * numFacePixels;
    size_t offset = 0;
    (void)LVK_VERIFY(ktxTexture_GetImageOffset(ktxTexture(texture), 0, 0, face, &offset) == KTX_SUCCESS);
    float* dst = (float*)(texture->pData + offset);
    for (int y = 0; y != h; y++) {
      for (int x = 0; x != w; x++) {
        const vec4 rgba = vec4(src[x + y * w], 1.0f);
        memcpy(dst, &rgba, sizeof(rgba));
        dst += 4;
      }
    }
  }

  return texture;
}

void generateMipmaps(const std::string& outFilename, ktxTexture1* cubemap) {
  LVK_PROFILER_FUNCTION();

  LLOGL("Generating mipmaps");

  LVK_ASSERT(cubemap);

  uint32_t prevWidth = cubemap->baseWidth;
  uint32_t prevHeight = cubemap->baseHeight;

  for (uint32_t face = 0; face != 6; face++) {
    LLOGL(".");
    for (uint32_t miplevel = 1; miplevel < cubemap->numLevels; miplevel++) {
      LLOGL(":");
      const uint32_t width = prevWidth > 1 ? prevWidth >> 1 : 1;
      const uint32_t height = prevHeight > 1 ? prevWidth >> 1 : 1;

      size_t prevOffset = 0;
      (void)LVK_VERIFY(ktxTexture_GetImageOffset(ktxTexture(cubemap), miplevel - 1, 0, face, &prevOffset) == KTX_SUCCESS);
      size_t offset = 0;
      (void)LVK_VERIFY(ktxTexture_GetImageOffset(ktxTexture(cubemap), miplevel, 0, face, &offset) == KTX_SUCCESS);

      stbir_resize_float_linear(reinterpret_cast<const float*>(cubemap->pData + prevOffset),
                                prevWidth,
                                prevHeight,
                                0,
                                reinterpret_cast<float*>(cubemap->pData + offset),
                                width,
                                height,
                                0,
                                STBIR_RGBA);

      prevWidth = width;
      prevHeight = height;
    }
    prevWidth = cubemap->baseWidth;
    prevHeight = cubemap->baseHeight;
  }

  LLOGL("\n");
  ktxTexture_WriteToNamedFile(ktxTexture(cubemap), outFilename.c_str());
}

void processCubemap(const std::string& inFilename, const std::string& outFilenameEnv, const std::string& outFilenameIrr) {
  LVK_PROFILER_FUNCTION();

  int sourceWidth, sourceHeight;
  float* pxs = stbi_loadf(inFilename.c_str(), &sourceWidth, &sourceHeight, nullptr, 3);
  SCOPE_EXIT {
    if (pxs) {
      stbi_image_free(pxs);
    }
  };

  if (!LVK_VERIFY(pxs != nullptr)) {
    LVK_ASSERT_MSG(false, "Did you read the tutorial at the top of Tiny_MeshLarge.cpp?");
    return;
  }

  // Environment map
  {
    Bitmap bmp = convertEquirectangularMapToCubeMapFaces(Bitmap(sourceWidth, sourceHeight, 3, eBitmapFormat_Float, pxs));
    ktxTexture1* cube = bitmapToCube(bmp);
    generateMipmaps(outFilenameEnv, cube);
    ktxTexture_Destroy(ktxTexture(cube));
  }

  // Irradiance map
  {
    constexpr int dstW = 256;
    constexpr int dstH = 128;

    std::vector<vec3> out(dstW * dstH);
    convolveDiffuse((vec3*)pxs, sourceWidth, sourceHeight, dstW, dstH, out.data(), 1024);

    Bitmap bmp = convertEquirectangularMapToCubeMapFaces(Bitmap(dstW, dstH, 3, eBitmapFormat_Float, out.data()));
    ktxTexture1* cube = bitmapToCube(bmp);
    generateMipmaps(outFilenameIrr, cube);
    ktxTexture_Destroy(ktxTexture(cube));
  }
}

void loadSkyboxTexture() {
  LVK_PROFILER_FUNCTION();

  const std::string skyboxFileName{"immenstadter_horn_2k"};
  const std::string skyboxSubdir{"src/skybox_hdr/"};

  const std::string fileNameRefKTX = folderContentRoot + skyboxFileName + "_ReferenceMap.ktx";
  const std::string fileNameIrrKTX = folderContentRoot + skyboxFileName + "_IrradianceMap.ktx";

  if (!std::filesystem::exists(fileNameRefKTX) || !std::filesystem::exists(fileNameIrrKTX)) {
    const std::string inFilename = folderContentRoot + skyboxSubdir + skyboxFileName + ".hdr";
    LLOGL("Cubemap in KTX format not found. Extracting from HDR file `%s`...\n", inFilename.c_str());

    processCubemap(inFilename, fileNameRefKTX, fileNameIrrKTX);
  }

  loadCubemapTexture(fileNameRefKTX, skyboxTextureReference_);
  loadCubemapTexture(fileNameIrrKTX, skyboxTextureIrradiance_);
}

lvk::Format formatFromChannels(uint32_t channels) {
  if (channels == 1) {
    return lvk::Format_R_UN8;
  }

  if (channels == 4) {
    return kEnableCompression ? lvk::Format_BC7_RGBA : lvk::Format_RGBA_UN8;
  }

  return lvk::Format_Invalid;
}

lvk::TextureHandle createTexture(const LoadedImage& img) {
  if (!img.pixels) {
    return {};
  }

  const auto it = texturesCache_.find(img.debugName);

  if (it != texturesCache_.end()) {
    return it->second;
  }

  const bool hasCompressedTexture = kEnableCompression && img.channels == 4 && std::filesystem::exists(img.compressedFileName.c_str());

  const void* initialData = img.pixels;
  uint32_t initialDataNumMipLevels = 1u;

  ktxTexture* texture = nullptr;

  if (hasCompressedTexture) {
    // uploading the texture
    if (!LVK_VERIFY(ktxTexture_CreateFromNamedFile(img.compressedFileName.c_str(), KTX_TEXTURE_CREATE_LOAD_IMAGE_DATA_BIT, &texture) ==
                    KTX_SUCCESS)) {
      printf("Failed to load %s\n", img.compressedFileName.c_str());
      assert(0);
    }
    initialData = texture->pData;
    initialDataNumMipLevels = lvk::calcNumMipLevels(img.w, img.h);
  }
  SCOPE_EXIT {
    if (texture)
      ktxTexture_Destroy(ktxTexture(texture));
  };

  // No mip-maps come from files on Apple and Android platforms, we need to generate them.
#if defined(__APPLE__) || defined(ANDROID)
  const bool generateMipmaps = true;
#else
  const bool generateMipmaps = !hasCompressedTexture;
#endif

  lvk::Holder<lvk::TextureHandle> tex = ctx_->createTexture({
      .type = lvk::TextureType_2D,
      .format = formatFromChannels(img.channels),
      .dimensions = {img.w, img.h},
      .usage = lvk::TextureUsageBits_Sampled,
      .numMipLevels = lvk::calcNumMipLevels(img.w, img.h),
      .components = (img.channels == 1) ? lvk::ComponentMapping{lvk::Swizzle_R, lvk::Swizzle_R, lvk::Swizzle_R, lvk::Swizzle_R}
                                        : lvk::ComponentMapping{},
      .data = initialData,
      .dataNumMipLevels = initialDataNumMipLevels,
      .generateMipmaps = generateMipmaps,
      .debugName = img.debugName.c_str(),
  });

  lvk::TextureHandle handle = tex;

  texturesCache_[img.debugName] = std::move(tex);

  return handle;
}

void processLoadedMaterials(lvk::ICommandBuffer& buffer) {
  LoadedMaterial mtl;

  {
    std::lock_guard guard(loadedMaterialsMutex_);
    if (loadedMaterials_.empty()) {
      return;
    } else {
      mtl = loadedMaterials_.back();
      loadedMaterials_.pop_back();
      remainingMaterialsToLoad_.fetch_sub(1u, std::memory_order_release);
    }
  }

  {
    MaterialTextures tex;

    tex.ambient = createTexture(mtl.ambient);
    tex.diffuse = createTexture(mtl.diffuse);
    tex.alpha = createTexture(mtl.alpha);

    // update GPU materials
    materials_[mtl.idx].texAmbient = tex.ambient.index();
    materials_[mtl.idx].texDiffuse = tex.diffuse.index();
    materials_[mtl.idx].texAlpha = tex.alpha.index();
    textures_[mtl.idx] = std::move(tex);
  }
  LVK_ASSERT(materials_[mtl.idx].texAmbient >= 0);
  LVK_ASSERT(materials_[mtl.idx].texDiffuse >= 0);
  LVK_ASSERT(materials_[mtl.idx].texAlpha >= 0);
  buffer.cmdUpdateBuffer(sbMaterials_, 0, sizeof(GPUMaterial) * materials_.size(), materials_.data());
}

inline ImVec4 toVec4(const vec4& c) {
  return ImVec4(c.x, c.y, c.z, c.w);
}

void showTimeGPU() {
#if defined(LVK_WITH_IMPLOT)
  const double toMS = ctx_->getTimestampPeriodToMs();
  auto getTimespan = [toMS](GPUTimestamp begin) -> double {
    return double(pipelineTimestamps[begin + 1] - pipelineTimestamps[begin]) * toMS;
  };
  struct sTimeStats {
    enum size { kNumTimelines = 5 };
    struct MinMax {
      float vmin = FLT_MAX;
      float vmax = 0.0f;
    };
    double add(uint32_t pass, const char* name, double value) {
      LVK_ASSERT(pass < kNumTimelines);
      names[pass] = name;
      const float prev = timelines[pass].empty() ? (float)value : timelines[pass].back();
      timelines[pass].push_back(0.9 * prev + 0.1 * value);
      if (timelines[pass].size() > 128)
        timelines[pass].erase(timelines[pass].begin());
      avg[pass] = value;
      return (float)value;
    }
    void updateMinMax() {
      for (uint32_t i = 0; i != kNumTimelines; i++) {
        float minT = FLT_MAX;
        float maxT = 0.0f;
        for (float v : timelines[i]) {
          if (v < minT)
            minT = v;
          if (v > maxT)
            maxT = v;
        }
        minmax[i] = {minT, maxT};
      }
    }
    std::vector<float> timelines[kNumTimelines] = {};
    MinMax minmax[kNumTimelines] = {};
    float avg[kNumTimelines] = {};
    const char* names[kNumTimelines] = {};
    const vec4 colors[kNumTimelines] = {LC_Red, LC_Green, LC_Green, LC_LightBlue, LC_Red};
  };
  static sTimeStats stats;

  const double timeScene = stats.add(1, " Scene", getTimespan(GPUTimestamp_BeginSceneRendering));
  const double timeCompute = stats.add(2, " Compute", getTimespan(GPUTimestamp_BeginComputePass));
  const double timePresent = stats.add(3, " Present", getTimespan(GPUTimestamp_BeginPresent));

  const double timeGPU = timeScene + timeCompute + timePresent;
  stats.add(0, "GPU", timeGPU);
  const double timeCPU = stats.add(4, "CPU", (timestampEndRendering - timestampBeginRendering) * 1000);
  stats.updateMinMax();

  char text[128];
  snprintf(text,
           sizeof(text),
           "GPU: %6.02f ms   (Scene: %.02f   Compute: %.02f   Present: %.02f)",
           timeGPU,
           timeScene,
           timeCompute,
           timePresent);

  const ImGuiWindowFlags flags = ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings |
                                 ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoNav;
  ImGui::SetNextWindowBgAlpha(0.8f);
  ImGui::SetNextWindowPos({20, height_ * 0.8f}, ImGuiCond_Appearing);
  ImGui::SetNextWindowSize({width_ * 0.4f, 0});
  ImGui::Begin("GPU Stats", nullptr, flags);
  ImGui::Text("%s", text);

  auto Sparkline = [](const char* id, const float* values, int count, float min_v, float max_v, const ImVec4& col, const ImVec2& size) {
    ImPlot::PushStyleVar(ImPlotStyleVar_PlotPadding, ImVec2(0, 0));
    ImPlot::SetNextAxesLimits(0, count - 1, min_v, max_v, ImGuiCond_Always);
    if (ImPlot::BeginPlot(id, size, ImPlotFlags_CanvasOnly)) {
      ImPlot::SetupAxes(nullptr, nullptr, ImPlotAxisFlags_NoDecorations, ImPlotAxisFlags_NoDecorations);
      ImPlot::PushStyleColor(ImPlotCol_Line, col);
      ImPlot::PlotLine(id, values, count, 1, 0);
      ImPlot::PushStyleVar(ImPlotStyleVar_FillAlpha, 0.25f);
      ImPlot::PlotShaded(id, values, count, 0, 1, 0);
      ImPlot::PopStyleVar();
      ImPlot::PopStyleColor();
      ImPlot::EndPlot();
    }
    ImPlot::PopStyleVar();
  };

  auto RowLeadIn = [](const char* stage, float value, const ImVec4& color) {
    ImGui::TableSetColumnIndex(0);
    ImGui::TextColored(color, "%s", stage);
    ImGui::TableSetColumnIndex(1);
    ImGui::TextColored(color, "%6.02f", value);
    ImGui::TableSetColumnIndex(2);
  };

  if (ImGui::BeginTable("##table", 3, ImGuiTableFlags_None, ImVec2(-1, 0))) {
    const ImGuiTableColumnFlags flags = ImGuiTableColumnFlags_NoSort;
    ImGui::TableSetupColumn("Stage", flags);
    ImGui::TableSetupColumn("Time (ms)", flags);
    ImGui::TableSetupColumn("Graph", flags | ImGuiTableColumnFlags_WidthStretch);
    ImGui::TableHeadersRow();
    for (uint32_t i = 0; i != sTimeStats::kNumTimelines; i++) {
      ImGui::TableNextRow();
      const ImVec4 color = toVec4(stats.colors[i]);
      RowLeadIn(stats.names[i], stats.avg[i], color);
      if (stats.avg[i] > 0.01) {
        ImGui::PushID(i);
        Sparkline("##spark",
                  stats.timelines[i].data(),
                  stats.timelines[i].size(),
                  stats.minmax[i].vmin * 0.8f,
                  stats.minmax[i].vmax * 1.2f,
                  color,
                  ImVec2(-1, 30));
        ImGui::PopID();
      }
    }
    ImGui::EndTable();
  }

  ImGui::End();
#endif // LVK_WITH_IMPLOT
}

#if !defined(ANDROID)
double getCurrentTimestamp() {
  return glfwGetTime();
}

GLFWkeyfun g_PrevKeyCallback = nullptr;
GLFWmousebuttonfun g_PrevMouseButtonCallback = nullptr;

int main(int argc, char* argv[]) {
  minilog::initialize(nullptr, {.threadNames = false});

  // find the content folder
  {
    using namespace std::filesystem;
    path subdir("third-party/content/");
    path dir = current_path();
    // find the content somewhere above our current build directory
    while (dir != current_path().root_path() && !exists(dir / subdir)) {
      dir = dir.parent_path();
    }
    if (!exists(dir / subdir)) {
      printf("Cannot find the content directory. Run `deploy_content.py` before running this app.");
      LVK_ASSERT(false);
      return EXIT_FAILURE;
    }
    folderThirdParty = (dir / path("third-party/deps/src/")).string();
    folderContentRoot = (dir / subdir).string();
  }

  lvk::LVKwindow* window = lvk::initWindow("Vulkan Bistro", width_, height_);
  ctx_ = lvk::createVulkanContextWithSwapchain(window,
                                               width_,
                                               height_,
                                               {
                                                   .enableValidation = kEnableValidationLayers,
                                               },
                                               kPreferIntegratedGPU ? lvk::HWDeviceType_Integrated : lvk::HWDeviceType_Discrete);
  if (!ctx_) {
    return EXIT_FAILURE;
  }

  if (kEnableCompression) {
    printf("Compressing textures... It can take a while in debug builds...(needs to be done once)\n");
  }

  if (!init(window)) {
    return EXIT_FAILURE;
  }

  glfwSetFramebufferSizeCallback(window, [](GLFWwindow*, int width, int height) {
    width_ = width;
    height_ = height;
    resize();
  });

  glfwSetCursorPosCallback(window, [](auto* window, double x, double y) {
    int width, height;
    glfwGetFramebufferSize(window, &width, &height);
    if (width && height) {
      mousePos_ = vec2(x / width, 1.0f - y / height);
      ImGui::GetIO().MousePos = ImVec2(x, y);
    }
  });

  g_PrevMouseButtonCallback = glfwSetMouseButtonCallback(window, [](auto* window, int button, int action, int mods) {
    if (!ImGui::GetIO().WantCaptureMouse) {
      if (button == GLFW_MOUSE_BUTTON_LEFT) {
        mousePressed_ = (action == GLFW_PRESS);
      }
    } else {
      // release the mouse
      mousePressed_ = false;
    }
    // call the previous installed callback
    if (g_PrevMouseButtonCallback)
      g_PrevMouseButtonCallback(window, button, action, mods);
  });

  g_PrevKeyCallback = glfwSetKeyCallback(window, [](GLFWwindow* window, int key, int scancode, int action, int mods) {
    const bool pressed = action != GLFW_RELEASE && !ImGui::GetIO().WantCaptureKeyboard;
    if (key == GLFW_KEY_ESCAPE && pressed) {
      loaderShouldExit_.store(true, std::memory_order_release);
      glfwSetWindowShouldClose(window, GLFW_TRUE);
    }
    if (key == GLFW_KEY_N && pressed) {
      drawNormals_ = !drawNormals_;
    }
    if (key == GLFW_KEY_C && pressed) {
      enableComputePass_ = !enableComputePass_;
    }
    if (key == GLFW_KEY_T && pressed) {
      enableWireframe_ = !enableWireframe_;
    }
    if (key == GLFW_KEY_P && pressed) {
      showPerfStats_ = !showPerfStats_;
    }
    if (key == GLFW_KEY_ESCAPE && pressed)
      glfwSetWindowShouldClose(window, GLFW_TRUE);
    if (key == GLFW_KEY_W) {
      positioner_.movement_.forward_ = pressed;
    }
    if (key == GLFW_KEY_S) {
      positioner_.movement_.backward_ = pressed;
    }
    if (key == GLFW_KEY_A) {
      positioner_.movement_.left_ = pressed;
    }
    if (key == GLFW_KEY_D) {
      positioner_.movement_.right_ = pressed;
    }
    if (key == GLFW_KEY_1) {
      positioner_.movement_.up_ = pressed;
    }
    if (key == GLFW_KEY_2) {
      positioner_.movement_.down_ = pressed;
    }
    if (mods & GLFW_MOD_SHIFT) {
      positioner_.movement_.fastSpeed_ = pressed;
    }
    if (key == GLFW_KEY_LEFT_SHIFT || key == GLFW_KEY_RIGHT_SHIFT) {
      positioner_.movement_.fastSpeed_ = pressed;
    }
    if (key == GLFW_KEY_SPACE) {
      positioner_.setUpVector(vec3(0.0f, 1.0f, 0.0f));
    }
    if (key == GLFW_KEY_F9 && action == GLFW_PRESS) {
      ktxTextureCreateInfo createInfo = {
          .glInternalformat = GL_RGBA8,
          .vkFormat = VK_FORMAT_B8G8R8A8_UNORM,
          .baseWidth = static_cast<uint32_t>(width_),
          .baseHeight = static_cast<uint32_t>(height_),
          .baseDepth = 1u,
          .numDimensions = 2u,
          .numLevels = 1u,
          .numLayers = 1u,
          .numFaces = 1u,
          .generateMipmaps = KTX_FALSE,
      };

      ktxTexture1* texture = nullptr;
      (void)LVK_VERIFY(ktxTexture1_Create(&createInfo, KTX_TEXTURE_CREATE_ALLOC_STORAGE, &texture) == KTX_SUCCESS);
      ctx_->download(ctx_->getCurrentSwapchainTexture(), {.dimensions = {(uint32_t)width_, (uint32_t)height_}}, texture->pData);
      ktxTexture_WriteToNamedFile(ktxTexture(texture), "screenshot.ktx");
      ktxTexture_Destroy(ktxTexture(texture));
    }
    // call the previous installed callback
    if (g_PrevKeyCallback)
      g_PrevKeyCallback(window, key, scancode, action, mods);
  });

  double prevTime = getCurrentTimestamp();

  // Main loop
  while (!glfwWindowShouldClose(window)) {
    glfwPollEvents();

    const double newTime = getCurrentTimestamp();
    const double delta = newTime - prevTime;
    prevTime = newTime;

    if (!width_ || !height_)
      continue;

    fps_.tick(delta);

    render(delta);
  }

  // destroy all the Vulkan stuff before closing the window
  destroy();

  glfwDestroyWindow(window);
  glfwTerminate();

  return 0;
}
#else
double getCurrentTimestamp() {
  timespec t = {0, 0};
  clock_gettime(CLOCK_MONOTONIC, &t);
  return (double)t.tv_sec + 1.0e-9 * t.tv_nsec;
}

extern "C" {
void handle_cmd(android_app* app, int32_t cmd) {
  switch (cmd) {
  case APP_CMD_INIT_WINDOW:
    if (app->window != nullptr) {
      width_ = ANativeWindow_getWidth(app->window);
      height_ = ANativeWindow_getHeight(app->window);
      ctx_ = lvk::createVulkanContextWithSwapchain(app->window,
                                                   width_,
                                                   height_,
                                                   {
                                                       .enableValidation = kEnableValidationLayers,
                                                   },
                                                   kPreferIntegratedGPU ? lvk::HWDeviceType_Integrated : lvk::HWDeviceType_Discrete);
      if (!init(nullptr)) {
        LLOGW("Failed to initialize the app\n");
        std::terminate();
      }
    }
    break;
  case APP_CMD_TERM_WINDOW:
    destroy();
    break;
  }
}

void resize_callback(ANativeActivity* activity, ANativeWindow* window) {
  int w = ANativeWindow_getWidth(window);
  int h = ANativeWindow_getHeight(window);
  if (width_ != w || height_ != h) {
    width_ = w;
    height_ = h;
    if (ctx_) {
      resize();
    }
  }
}

void android_main(android_app* app) {
  minilog::initialize(nullptr, {.threadNames = false});
  app->onAppCmd = handle_cmd;
  app->activity->callbacks->onNativeWindowResized = resize_callback;

  // find the content folder
  {
    using namespace std::filesystem;
    if (const char* externalStorage = std::getenv("EXTERNAL_STORAGE")) {
      folderThirdParty = (std::filesystem::path(externalStorage) / "LVK" / "deps" / "src").string() + "/";
      folderContentRoot = (std::filesystem::path(externalStorage) / "LVK" / "content").string() + "/";
      if (!exists(folderThirdParty) || !exists(folderContentRoot)) {
        LLOGW("Cannot find the content directory. Run `deploy_content_android.py` before running this app.\n");
        LVK_ASSERT(false);
        std::terminate();
      }
    } else {
      LLOGW("Cannot find EXTERNAL_STORAGE.\n");
      LVK_ASSERT(false);
      std::terminate();
    }
  }

  fps_.printFPS_ = false;

  double prevTime = getCurrentTimestamp();

  int events = 0;
  android_poll_source* source = nullptr;
  do {
    double newTime = getCurrentTimestamp();
    double delta = newTime - prevTime;
    if (fps_.tick(delta)) {
      LLOGL("FPS: %.1f\n", fps_.getFPS());
    }
    prevTime = newTime;
    if (ctx_) {
      render(delta);
    }
    if (ALooper_pollOnce(0, nullptr, &events, (void**)&source) >= 0) {
      if (source) {
        source->process(app, source);
      }
    }
  } while (!app->destroyRequested);
}
} // extern "C"
#endif

```

`samples/VulkanApp.cpp`:

```cpp
/*
 * LightweightVK
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// Based on https://github.com/PacktPublishing/3D-Graphics-Rendering-Cookbook-Second-Edition/blob/main/shared/VulkanApp.cpp

#include "VulkanApp.h"

#include <filesystem>
#include <vector>

#include <stb/stb_image.h>
#include <stb/stb_image_write.h>

#if defined(ANDROID)
#include <android/asset_manager_jni.h>
#include <android/native_window_jni.h>
#include <time.h>

double glfwGetTime() {
  timespec t = {0, 0};
  clock_gettime(CLOCK_MONOTONIC, &t);
  return (double)t.tv_sec + 1.0e-9 * t.tv_nsec;
}

static const char* cmdToString(int32_t cmd) {
#define CMD(cmd) \
  case cmd:      \
    return #cmd
  switch (cmd) {
    CMD(APP_CMD_INPUT_CHANGED);
    CMD(APP_CMD_INIT_WINDOW);
    CMD(APP_CMD_TERM_WINDOW);
    CMD(APP_CMD_WINDOW_RESIZED);
    CMD(APP_CMD_WINDOW_REDRAW_NEEDED);
    CMD(APP_CMD_CONTENT_RECT_CHANGED);
    CMD(APP_CMD_GAINED_FOCUS);
    CMD(APP_CMD_LOST_FOCUS);
    CMD(APP_CMD_CONFIG_CHANGED);
    CMD(APP_CMD_LOW_MEMORY);
    CMD(APP_CMD_START);
    CMD(APP_CMD_RESUME);
    CMD(APP_CMD_SAVE_STATE);
    CMD(APP_CMD_PAUSE);
    CMD(APP_CMD_STOP);
    CMD(APP_CMD_DESTROY);
  }
#undef CMD
  return "";
}

extern "C" {

static void handle_cmd(android_app* androidApp, int32_t cmd) {
  VulkanApp* app = (VulkanApp*)androidApp->userData;

  LLOGD("handle_cmd(%s)", cmdToString(cmd));

  switch (cmd) {
  case APP_CMD_INIT_WINDOW:
    if (androidApp->window) {
      app->width_ = ANativeWindow_getWidth(androidApp->window) / app->cfg_.framebufferScalar;
      app->height_ = ANativeWindow_getHeight(androidApp->window) / app->cfg_.framebufferScalar;
      if (!app->ctx_)
        app->ctx_ = lvk::createVulkanContextWithSwapchain(androidApp->window, app->width_, app->height_, app->cfg_.contextConfig);
    }
    return;
  case APP_CMD_TERM_WINDOW:
    app->ctx_ = nullptr;
    return;
  }
}

static int32_t handle_input(android_app* androidApp, AInputEvent* event) {
  VulkanApp* app = (VulkanApp*)androidApp->userData;

  if (AInputEvent_getType(event) == AINPUT_EVENT_TYPE_MOTION) {
    int32_t action = AMotionEvent_getAction(event);
    int32_t actionMasked = action & AMOTION_EVENT_ACTION_MASK;

    float x = AMotionEvent_getX(event, 0);
    float y = AMotionEvent_getY(event, 0);

    // Store both normalized [0,1] and pixel coordinates
    float normalizedX = x / (app->width_ * app->cfg_.framebufferScalar);
    float normalizedY = 1.0f - (y / (app->height_ * app->cfg_.framebufferScalar));

    // Update ImGui
    ImGuiIO& io = ImGui::GetIO();

    switch (actionMasked) {
    case AMOTION_EVENT_ACTION_DOWN:
      // Update position BEFORE setting mouse down for proper hit testing
      io.MousePos = ImVec2(x / app->cfg_.framebufferScalar, y / app->cfg_.framebufferScalar);
      io.MouseDown[0] = true;

      // Always update position
      app->mouseState_.pos.x = normalizedX;
      app->mouseState_.pos.y = normalizedY;

      // Check if touch started on ImGui window AFTER updating both position and down state
      app->imguiCapturedTouch_ = io.WantCaptureMouse;

      // Set pressedLeft immediately if not captured
      if (!app->imguiCapturedTouch_) {
        app->mouseState_.pressedLeft = true;
      }

      LLOGD("Touch down: %.2f, %.2f (ImGui captured: %d)", x, y, app->imguiCapturedTouch_);
      return 1;

    case AMOTION_EVENT_ACTION_MOVE:
      io.MousePos = ImVec2(x / app->cfg_.framebufferScalar, y / app->cfg_.framebufferScalar);
      app->mouseState_.pos.x = normalizedX;
      app->mouseState_.pos.y = normalizedY;
      return 1;

    case AMOTION_EVENT_ACTION_UP:
    case AMOTION_EVENT_ACTION_CANCEL:
      // Keep position valid for the up event so ImGui can process the click
      io.MousePos = ImVec2(x / app->cfg_.framebufferScalar, y / app->cfg_.framebufferScalar);
      io.MouseDown[0] = false;

      app->mouseState_.pressedLeft = false;
      app->imguiCapturedTouch_ = false;
      LLOGD("Touch up: %.2f, %.2f", x, y);
      return 1;
    }
  }

  return 0;
}

static void resize_callback(ANativeActivity* activity, ANativeWindow* window) {
  LLOGD("resize_callback()");

  VulkanApp* app = (VulkanApp*)activity->instance;
  const int w = ANativeWindow_getWidth(window) / app->cfg_.framebufferScalar;
  const int h = ANativeWindow_getHeight(window) / app->cfg_.framebufferScalar;
  if (app->width_ != w || app->height_ != h) {
    app->width_ = w;
    app->height_ = h;
    if (app->ctx_) {
      app->ctx_->recreateSwapchain(w, h);
      app->depthTexture_.reset();
      LLOGD("Swapchain recreated");
    }
  }

  LLOGD("resize_callback()<-");
}

} // extern "C"
#endif // ANDROID

#if defined(ANDROID)
VulkanApp::VulkanApp(android_app* androidApp, const VulkanAppConfig& cfg) : androidApp_(androidApp), cfg_(cfg) {
  const char* logFileName = nullptr;
#else
VulkanApp::VulkanApp(int argc, char* argv[], const VulkanAppConfig& cfg) : cfg_(cfg) {
  const char* logFileName = nullptr;
  for (int i = 1; i < argc; i++) {
    if (!strcmp(argv[i], "--headless")) {
      cfg_.contextConfig.enableHeadlessSurface = true;
    } else if (!strcmp(argv[i], "--log-file")) {
      if (i + 1 < argc) {
        logFileName = argv[++i];
      } else {
        LLOGW("Specify a file name for `--log-file <filename>`");
      }
    } else if (!strcmp(argv[i], "--screenshot-frame")) {
      if (i + 1 < argc) {
        cfg_.screenshotFrameNumber = strtoull(argv[++i], nullptr, 10);
      } else {
        LLOGW("Specify a frame number for `--screenshot-frame <framenumber>`");
      }
    } else if (!strcmp(argv[i], "--screenshot-file")) {
      if (i + 1 < argc) {
        cfg_.screenshotFileName = argv[++i];
      } else {
        LLOGW("Specify a file name for `--screenshot-file <filename>`");
      }
    }
  }
#endif // ANDROID
  minilog::initialize(logFileName,
                      {
                          .logLevelPrintToConsole = cfg_.contextConfig.enableHeadlessSurface ? minilog::Debug : minilog::Log,
                          .threadNames = false,
                      });

  // we use minilog
  fpsCounter_.printFPS_ = false;

  // find the content folder
  {
    using namespace std::filesystem;
#if defined(ANDROID)
    if (const char* externalStorage = std::getenv("EXTERNAL_STORAGE")) {
      folderThirdParty_ = (path(externalStorage) / "LVK" / "deps" / "src").string() + "/";
      folderContentRoot_ = (path(externalStorage) / "LVK" / "content").string() + "/";
    }
#else
    path subdir("third-party/content/");
    path dir = current_path();
    // find the content somewhere above our current build directory
    while (dir != current_path().root_path() && !exists(dir / subdir)) {
      dir = dir.parent_path();
    }
    if (!exists(dir / subdir)) {
      LLOGW("Cannot find the content directory. Run `deploy_content.py` before running this app.");
      LVK_ASSERT(false);
    }
    folderThirdParty_ = (dir / path("third-party/deps/src/")).string();
    folderContentRoot_ = (dir / subdir).string();
#endif // ANDROID
  }

#if defined(ANDROID)
  androidApp_->userData = this;
  androidApp_->onAppCmd = handle_cmd;
  androidApp_->onInputEvent = handle_input;

  int events = 0;
  android_poll_source* source = nullptr;

  LLOGD("Waiting for an Android window...");

  while (!androidApp_->destroyRequested && !ctx_) {
    // poll until a Window is created
    if (ALooper_pollOnce(1, nullptr, &events, (void**)&source) >= 0) {
      if (source)
        source->process(androidApp_, source);
    }
  }

  LLOGD("...Android window ready!");

  if (!ctx_)
    return;

  androidApp_->activity->instance = this;
  androidApp_->activity->callbacks->onNativeWindowResized = resize_callback;
#else
  width_ = cfg_.width;
  height_ = cfg_.height;

  window_ = lvk::initWindow("Simple example", width_, height_, cfg_.resizable, cfg_.contextConfig.enableHeadlessSurface);

  ctx_ = lvk::createVulkanContextWithSwapchain(window_, width_, height_, cfg_.contextConfig);
#endif // ANDROID

#if !defined(ANDROID)
  if (window_) {
    glfwSetWindowUserPointer(window_, this);

    glfwSetFramebufferSizeCallback(window_, [](GLFWwindow* window, int width, int height) {
      VulkanApp* app = (VulkanApp*)glfwGetWindowUserPointer(window);
      if (app->width_ == width && app->height_ == height)
        return;
      app->width_ = width;
      app->height_ = height;
      app->ctx_->recreateSwapchain(width, height);
      app->depthTexture_.reset();
    });
    glfwSetMouseButtonCallback(window_, [](GLFWwindow* window, int button, int action, int mods) {
      VulkanApp* app = (VulkanApp*)glfwGetWindowUserPointer(window);
      if (button == GLFW_MOUSE_BUTTON_LEFT) {
        app->mouseState_.pressedLeft = action == GLFW_PRESS;
      }
      for (auto& cb : app->callbacksMouseButton) {
        cb(window, button, action, mods);
      }
    });
    glfwSetCursorPosCallback(window_, [](GLFWwindow* window, double x, double y) {
      VulkanApp* app = (VulkanApp*)glfwGetWindowUserPointer(window);
      const ImVec2 size = ImGui::GetIO().DisplaySize;
      app->mouseState_.pos.x = static_cast<float>(x / size.x);
      app->mouseState_.pos.y = 1.0f - static_cast<float>(y / size.y);
    });
    glfwSetKeyCallback(window_, [](GLFWwindow* window, int key, int scancode, int action, int mods) {
      VulkanApp* app = (VulkanApp*)glfwGetWindowUserPointer(window);
      const bool pressed = action != GLFW_RELEASE && !ImGui::GetIO().WantCaptureKeyboard;
      if (key == GLFW_KEY_ESCAPE && pressed)
        glfwSetWindowShouldClose(window, GLFW_TRUE);
      if (key == GLFW_KEY_W)
        app->positioner_.movement_.forward_ = pressed;
      if (key == GLFW_KEY_S)
        app->positioner_.movement_.backward_ = pressed;
      if (key == GLFW_KEY_A)
        app->positioner_.movement_.left_ = pressed;
      if (key == GLFW_KEY_D)
        app->positioner_.movement_.right_ = pressed;
      if (key == GLFW_KEY_1)
        app->positioner_.movement_.up_ = pressed;
      if (key == GLFW_KEY_2)
        app->positioner_.movement_.down_ = pressed;

      app->positioner_.movement_.fastSpeed_ = (mods & GLFW_MOD_SHIFT) != 0;

      if (key == GLFW_KEY_SPACE) {
        app->positioner_.lookAt(app->cfg_.initialCameraPos, app->cfg_.initialCameraTarget, app->cfg_.initialCameraUpVector);
      }
      for (auto& cb : app->callbacksKey) {
        cb(window, key, scancode, action, mods);
      }
    });
  }
#endif // !ANDROID

  // initialize ImGUi after GLFW callbacks have been installed
  imgui_ = std::make_unique<lvk::ImGuiRenderer>(
      *ctx_, window_, (folderThirdParty_ + "3D-Graphics-Rendering-Cookbook/data/OpenSans-Light.ttf").c_str(), 30.0f);
}

VulkanApp::~VulkanApp() {
  imgui_ = nullptr;
  depthTexture_ = nullptr;
  ctx_ = nullptr;
#if !defined(ANDROID)
  glfwDestroyWindow(window_);
  glfwTerminate();
#endif // !ANDROID
}

lvk::Format VulkanApp::getDepthFormat() const {
  return ctx_->getFormat(getDepthTexture());
}

lvk::TextureHandle VulkanApp::getDepthTexture() const {
  if (depthTexture_.empty()) {
    depthTexture_ = ctx_->createTexture({
        .type = lvk::TextureType_2D,
        .format = lvk::Format_Z_F32,
        .dimensions = {(uint32_t)width_, (uint32_t)height_},
        .usage = lvk::TextureUsageBits_Attachment,
        .debugName = "Depth buffer",
    });
  }

  return depthTexture_;
}

void VulkanApp::run(DrawFrameFunc drawFrame) {
  double timeStamp = glfwGetTime();
  float deltaSeconds = 0.0f;

#if defined(ANDROID)
  int events = 0;
  android_poll_source* source = nullptr;
  do {
    const double newTimeStamp = glfwGetTime();
    deltaSeconds = static_cast<float>(newTimeStamp - timeStamp);
    if (fpsCounter_.tick(deltaSeconds)) {
      LLOGL("FPS: %.1f\n", fpsCounter_.getFPS());
    }
    timeStamp = newTimeStamp;
    if (ctx_) {
      const float ratio = width_ / (float)height_;

      const bool justPressed = mouseState_.pressedLeft && !imguiLastPressedLeft_;

      positioner_.update(
          deltaSeconds, mouseState_.pos, ImGui::GetIO().WantCaptureMouse ? false : (mouseState_.pressedLeft && !justPressed));

      // clear ImGui hover state one frame after touch ends
      if (imguiClearMouseNextFrame_) {
        ImGui::GetIO().MousePos = ImVec2(-FLT_MAX, -FLT_MAX);
        imguiClearMouseNextFrame_ = false;
      }

      imguiClearMouseNextFrame_ = !mouseState_.pressedLeft && imguiLastPressedLeft_;
      imguiLastPressedLeft_ = mouseState_.pressedLeft;

      drawFrame((uint32_t)width_, (uint32_t)height_, ratio, deltaSeconds);
    }
    if (ALooper_pollOnce(0, nullptr, &events, (void**)&source) >= 0) {
      if (source) {
        source->process(androidApp_, source);
      }
    }
  } while (!androidApp_->destroyRequested);
#else
  while (cfg_.contextConfig.enableHeadlessSurface || !glfwWindowShouldClose(window_)) {
    const double newTimeStamp = glfwGetTime();
    deltaSeconds = static_cast<float>(newTimeStamp - timeStamp);
    if (fpsCounter_.tick(deltaSeconds)) {
      LLOGL("FPS: %.1f\n", fpsCounter_.getFPS());
    }
    timeStamp = newTimeStamp;

    if (window_) {
#if defined(__APPLE__)
      // a hacky workaround for retina displays
      glfwGetWindowSize(window_, &width_, &height_);
#else
      glfwGetFramebufferSize(window_, &width_, &height_);
#endif // __APPLE__

      glfwPollEvents();
    }

    if (!ctx_ || !width_ || !height_)
      continue;
    const float ratio = width_ / (float)height_;

    positioner_.update(deltaSeconds, mouseState_.pos, ImGui::GetIO().WantCaptureMouse ? false : mouseState_.pressedLeft);

    lvk::TextureHandle tex = ctx_->getCurrentSwapchainTexture();

    drawFrame((uint32_t)width_, (uint32_t)height_, ratio, deltaSeconds);

    if (cfg_.screenshotFrameNumber == ++frameCount_) {
      ctx_->wait({});
      const lvk::Dimensions dim = ctx_->getDimensions(tex);
      const lvk::Format format = ctx_->getFormat(tex);
      LLOGL("Saving screenshot...%ux%u\n", dim.width, dim.height);
      if (format != lvk::Format_BGRA_UN8 && format != lvk::Format_BGRA_SRGB8 && format != lvk::Format_RGBA_UN8 &&
          format != lvk::Format_RGBA_SRGB8) {
        LLOGW("Unsupported pixel format %u\n", (uint32_t)format);
        break;
      }
      std::vector<uint8_t> pixelsRGBA(dim.width * dim.height * 4);
      std::vector<uint8_t> pixelsRGB(dim.width * dim.height * 3);
      ctx_->download(tex, {.dimensions = {dim.width, dim.height}}, pixelsRGBA.data());
      if (format == lvk::Format_BGRA_UN8 || format == lvk::Format_BGRA_SRGB8) {
        // swap R-B
        for (uint32_t i = 0; i < pixelsRGBA.size(); i += 4) {
          std::swap(pixelsRGBA[i + 0], pixelsRGBA[i + 2]);
        }
      }
      // convert to RGB
      for (uint32_t i = 0; i < pixelsRGB.size() / 3; i++) {
        pixelsRGB[3 * i + 0] = pixelsRGBA[4 * i + 0];
        pixelsRGB[3 * i + 1] = pixelsRGBA[4 * i + 1];
        pixelsRGB[3 * i + 2] = pixelsRGBA[4 * i + 2];
      }
      stbi_write_png(cfg_.screenshotFileName, (int)dim.width, (int)dim.height, 3, pixelsRGB.data(), 0);
      break;
    }
  }
#endif // ANDROID

  LLOGD("Terminating app...");
}

void VulkanApp::drawFPS() {
  if (const ImGuiViewport* v = ImGui::GetMainViewport()) {
    ImGui::SetNextWindowPos({v->WorkPos.x + v->WorkSize.x - 15.0f, v->WorkPos.y + 15.0f}, ImGuiCond_Always, {1.0f, 0.0f});
  }
  ImGui::SetNextWindowBgAlpha(0.30f);
  ImGui::SetNextWindowSize(ImVec2(ImGui::CalcTextSize("FPS : _______").x, 0));
  if (ImGui::Begin("##FPS",
                   nullptr,
                   ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings |
                       ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_NoMove)) {
    ImGui::Text("FPS : %i", (int)fpsCounter_.getFPS());
    ImGui::Text("Ms  : %.1f", fpsCounter_.getFPS() > 0 ? 1000.0 / fpsCounter_.getFPS() : 0);
  }
  ImGui::End();
}

```

`samples/VulkanApp.h`:

```h
/*
 * LightweightVK
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// Based on https://github.com/PacktPublishing/3D-Graphics-Rendering-Cookbook-Second-Edition/blob/main/shared/VulkanApp.h

#pragma once

#if !defined(_USE_MATH_DEFINES)
#define _USE_MATH_DEFINES
#endif // _USE_MATH_DEFINES
#include <cmath>

#include <functional>

#include <lvk/HelpersImGui.h>
#include <lvk/LVK.h>

// clang-format off
#if defined(ANDROID)
#  include <android_native_app_glue.h>
#  include <jni.h>
double glfwGetTime();
#else
#  include <GLFW/glfw3.h>
#endif
// clang-format on

#define GLM_ENABLE_EXPERIMENTAL
#include <glm/ext.hpp>
#include <glm/glm.hpp>
#include <shared/Camera.h>
#include <shared/UtilsFPS.h>

// clang-format off
#if defined(ANDROID)
#  define VULKAN_APP_MAIN void android_main(android_app* androidApp)
#  define VULKAN_APP_DECLARE(app, config) VulkanApp app(androidApp, config)
#  define VULKAN_APP_EXIT() return
#else
#  define VULKAN_APP_MAIN int main(int argc, char* argv[])
#  define VULKAN_APP_DECLARE(app, config) VulkanApp app(argc, argv, config)
#  define VULKAN_APP_EXIT() return 0
#endif
// clang-format on

using glm::mat3;
using glm::mat4;
using glm::vec2;
using glm::vec3;
using glm::vec4;

using DrawFrameFunc = std::function<void(uint32_t width, uint32_t height, float aspectRatio, float deltaSeconds)>;

struct VulkanAppConfig {
  int width = -95; // 95% horizontally
  int height = -90; // 90% vertically
#if defined(ANDROID)
  int framebufferScalar = 2;
#else
  int framebufferScalar = 1;
#endif // ANDROID
  bool resizable = false;
  vec3 initialCameraPos = vec3(0.0f, 0.0f, -2.5f);
  vec3 initialCameraTarget = vec3(0.0f, 0.0f, 0.0f);
  vec3 initialCameraUpVector = vec3(0.0f, 1.0f, 0.0f);
  uint64_t screenshotFrameNumber = 0; // frames start from 1
  const char* screenshotFileName = "screenshot.png";
  lvk::ContextConfig contextConfig;
};

class VulkanApp {
 public:
#if defined(ANDROID)
  explicit VulkanApp(android_app* androidApp, const VulkanAppConfig& cfg = {});
#else
  explicit VulkanApp(int argc, char* argv[], const VulkanAppConfig& cfg = {});
#endif // ANDROID
  virtual ~VulkanApp();

  virtual void run(DrawFrameFunc drawFrame);
  virtual void drawFPS();

  lvk::Format getDepthFormat() const;
  lvk::TextureHandle getDepthTexture() const;
#if !defined(ANDROID)
  void addMouseButtonCallback(GLFWmousebuttonfun cb) {
    callbacksMouseButton.push_back(cb);
  }
  void addKeyCallback(GLFWkeyfun cb) {
    callbacksKey.push_back(cb);
  }
#endif // ANDROID
 public:
  std::string folderThirdParty_;
  std::string folderContentRoot_;
  int width_ = 0;
  int height_ = 0;
#if defined(ANDROID)
  android_app* androidApp_ = nullptr;
  bool imguiCapturedTouch_ = false;
  bool imguiLastPressedLeft_ = false;
  bool imguiClearMouseNextFrame_ = false;
#endif // ANDROID
  std::unique_ptr<lvk::IContext> ctx_;
  mutable lvk::Holder<lvk::TextureHandle> depthTexture_;
  FramesPerSecondCounter fpsCounter_ = FramesPerSecondCounter(0.5f);
  std::unique_ptr<lvk::ImGuiRenderer> imgui_;

  lvk::LVKwindow* window_ = nullptr; // when declared before imgui_, Vivo X200 Pro crashes...

  VulkanAppConfig cfg_ = {};

  CameraPositioner_FirstPerson positioner_ = {cfg_.initialCameraPos, cfg_.initialCameraTarget, cfg_.initialCameraUpVector};
  Camera camera_ = Camera(positioner_);

  struct MouseState {
    vec2 pos = vec2(0.0f);
    bool pressedLeft = false;
  } mouseState_;

 protected:
#if !defined(ANDROID)
  std::vector<GLFWmousebuttonfun> callbacksMouseButton;
  std::vector<GLFWkeyfun> callbacksKey;
#endif // ANDROID

  uint64_t frameCount_ = 0;
};

```

`third-party/bootstrap-content.json`:

```json
[
{
    "name": "bistro/PropTextures",
    "source": {
        "type": "archive",
        "url": "https://casual-effects.com/g3d/data10/research/model/bistro/PropTextures",
        "user-agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.116 Safari/537.36"
    }
},
{
    "name": "bistro/OtherTextures",
    "source": {
        "type": "archive",
        "url": "https://casual-effects.com/g3d/data10/research/model/bistro/OtherTextures",
        "user-agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.116 Safari/537.36"
    }
},
{
    "name": "bistro/BuildingTextures",
    "source": {
        "type": "archive",
        "url": "https://casual-effects.com/g3d/data10/research/model/bistro/BuildingTextures",
        "user-agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.116 Safari/537.36"
    }
},
{
    "name": "bistro/Interior",
    "source": {
        "type": "archive",
        "url": "https://casual-effects.com/g3d/data10/research/model/bistro/Interior.zip",
        "user-agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.116 Safari/537.36"
    }
},
{
    "name": "bistro/Exterior",
    "source": {
        "type": "archive",
        "url": "https://casual-effects.com/g3d/data10/research/model/bistro/Exterior.zip",
        "user-agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.116 Safari/537.36"
    }
},
{
    "name": "skybox_hdr",
    "source": {
        "type": "sourcefile",
        "url": "https://github.com/PacktPublishing/3D-Graphics-Rendering-Cookbook/raw/master/data/immenstadter_horn_2k.hdr",
        "user-agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.116 Safari/537.36"
    }
},
{
    "name": "glTF-Sample-Models",
    "source": {
        "type": "git",
        "url": "https://github.com/KhronosGroup/glTF-Sample-Models.git",
        "revision": "db9ff67c1116cfe28eb36320916bccd8c4127cc1"
    }
},
{
    "name": "igl-samples",
    "source": {
        "type": "sourcefile",
        "url": "https://github.com/facebook/igl/raw/4e066d19b3461c05417542c14fa8ea5f64a70964/shell/resources/images/output_frame_900.420p.yuv",
        "sha1": "8f5648ed4b1503d17ff4a6b6713464e0bfdb7386"
    }
},
{
    "name": "igl-samples",
    "source": {
        "type": "sourcefile",
        "url": "https://github.com/facebook/igl/raw/4e066d19b3461c05417542c14fa8ea5f64a70964/shell/resources/images/output_frame_900.nv12.yuv",
        "sha1": "afef6f0aa6a5b7e12fd79f87b0ae940113623fd6"
    }
},
{
    "name": "sponza",
    "source": {
        "type": "git",
        "url": "https://github.com/jimmiebergmann/Sponza.git",
        "revision": "222338979d32f4f4818466291bdbc29f192b86ba"
    }
},
{
    "name": "solarsystem",
    "source": {
        "type": "sourcefile",
        "url": "https://www.solarsystemscope.com/textures/download/2k_mercury.jpg",
        "sha1": "6f832f061a9c5689a0bd5bd68ff29f49ffc65d29"
    }
},
{
    "name": "solarsystem",
    "source": {
        "type": "sourcefile",
        "url": "https://www.solarsystemscope.com/textures/download/2k_venus_surface.jpg",
        "sha1": "1549a36da4bb9bb6c99430dc1a8e7cc7ba07df96"
    }
},
{
    "name": "solarsystem",
    "source": {
        "type": "sourcefile",
        "url": "https://www.solarsystemscope.com/textures/download/2k_mars.jpg",
        "sha1": "4dbaccfc147c10b70b9905683498fcd24a11af8e"
    }
},
{
    "name": "solarsystem",
    "source": {
        "type": "sourcefile",
        "url": "https://www.solarsystemscope.com/textures/download/2k_jupiter.jpg",
        "sha1": "11ebb1d50e85505005cd5f13309c0bd6ee16b268"
    }
},
{
    "name": "solarsystem",
    "source": {
        "type": "sourcefile",
        "url": "https://www.solarsystemscope.com/textures/download/2k_saturn.jpg",
        "sha1": "26b1ded029fabdd7e98dc607ecc17abcc96dd03e"
    }
},
{
    "name": "solarsystem",
    "source": {
        "type": "sourcefile",
        "url": "https://images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com/i/c1827fcd-9fde-48eb-8da3-489166bd8542/d6xt63j-169c5f5a-9033-417c-a48a-496ec8d05f77.jpg",
        "sha1": "b5f95fa2480822a5b7058ae30b08d532d4374825"
    },
    "postprocess": {
       "type": "script",
       "file": "saturn_rings.py"
    }
},
{
    "name": "solarsystem",
    "source": {
        "type": "sourcefile",
        "url": "https://www.solarsystemscope.com/textures/download/2k_uranus.jpg",
        "sha1": "39fba155ca70e51da9224b9653cbc598b0c41be1"
    }
},
{
    "name": "solarsystem",
    "source": {
        "type": "sourcefile",
        "url": "https://www.solarsystemscope.com/textures/download/2k_neptune.jpg",
        "sha1": "4ff333c5cccc045dca033bdf1ae24719b26f053b"
    }
},
{
    "name": "solarsystem",
    "source": {
        "type": "sourcefile",
        "url": "https://www.solarsystemscope.com/textures/download/2k_earth_daymap.jpg",
        "sha1": "67397b2a33b1c6673ea50af3bfda4244b078b820"
    }
},
{
    "name": "solarsystem",
    "source": {
        "type": "sourcefile",
        "url": "https://www.solarsystemscope.com/textures/download/2k_sun.jpg",
        "sha1": "0833ed7cb52d4e0e3d7174e1d26f73d21fcb8a10"
    }
},
{
    "name": "solarsystem",
    "source": {
        "type": "sourcefile",
        "url": "https://corporate.dukehealth.org/sites/default/files/api/images/aspect:1.0-width:768-position:center/ThinkstockPhotos-517462556.web_.jpg",
        "sha1": "68ae86dbbe76700d863591b60d222fc603cd8cf1",
        "user-agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.116 Safari/537.36"
    },
    "postprocess": {
       "type": "script",
       "file": "sun_corona.py"
    }
},
{
    "name": "solarsystem",
    "source": {
        "type": "sourcefile",
        "url": "https://www.solarsystemscope.com/textures/download/2k_moon.jpg",
        "sha1": "456ef7331c9230955de3b7c22346af6c613f7d3a"
    }
},
{
    "name": "solarsystem",
    "source": {
        "type": "sourcefile",
        "url": "https://www.solarsystemscope.com/textures/download/2k_makemake_fictional.jpg",
        "sha1": "5e931975712dedb8ed394dbea3adde2491d03a9b"
    }
},
{
    "name": "solarsystem",
    "source": {
        "type": "sourcefile",
        "url": "https://raw.githubusercontent.com/corporateshark/Mastering-Android-NDK/refs/heads/master/Chapter10/1_Asteroids/assets/deimos.obj",
        "sha1": "872aa578ec8a922da7bad31867394eea02516fcc"
    }
},
{
    "name": "solarsystem",
    "source": {
        "type": "sourcefile",
        "url": "https://svs.gsfc.nasa.gov/vis/a000000/a003800/a003895/starmap_4k.jpg",
        "sha1": "2fb7d68ecd93d5dd1f69d8339e007f3b5886e33e"
    }
}
]

```

`third-party/bootstrap-deps.json`:

```json
[
{
    "name": "meshoptimizer",
    "source": {
        "type": "git",
        "url": "https://github.com/zeux/meshoptimizer.git",
        "revision": "v1.0"
    }
},
{
    "name": "glslang",
    "source": {
        "type": "git",
        "url": "https://github.com/KhronosGroup/glslang.git",
        "revision": "16.2.0"
    }
},
{
    "name": "SPIRV-Reflect",
    "source": {
        "type": "git",
        "url": "https://github.com/KhronosGroup/SPIRV-Reflect.git",
        "revision": "ef913b3ab3da1becca3cf46b15a10667c67bebe5"
    }
},
{
    "name": "fast_obj",
    "source": {
        "type": "git",
        "url": "https://github.com/thisistherk/fast_obj.git",
        "revision": "d620667f10a548dee94dbc8c144bb22f79162176"
    }
},
{
    "name": "glfw",
    "source": {
        "type": "git",
        "url": "https://github.com/glfw/glfw.git",
        "revision": "3.4"
    }
},
{
    "name": "SDL",
    "source": {
        "type": "git",
        "url": "https://github.com/libsdl-org/SDL",
        "revision": "release-3.2.28"
    }
},
{
    "name": "stb",
    "source": {
        "type": "git",
        "url": "https://github.com/nothings/stb.git",
        "revision": "f1c79c02822848a9bed4315b12c8c8f3761e1296"
    }
},
{
    "name": "3D-Graphics-Rendering-Cookbook/data",
    "source": {
        "type": "sourcefile",
        "url": "https://raw.githubusercontent.com/PacktPublishing/3D-Graphics-Rendering-Cookbook/e8bf80a2f4f2f9fafc49860f4d5b201101d42af8/data/OpenSans-Light.ttf",
        "sha1": "40442c189568184b6e6c27a25d69f14d91b65039"
    }
},
{
    "name": "3D-Graphics-Rendering-Cookbook/shared",
    "source": {
        "type": "sourcefile",
        "url": "https://raw.githubusercontent.com/PacktPublishing/3D-Graphics-Rendering-Cookbook/e8bf80a2f4f2f9fafc49860f4d5b201101d42af8/shared/UtilsFPS.h",
        "sha1": "cf19e032be65f471e12274d15dcc2989e8c2e469"
    }
},
{
    "name": "3D-Graphics-Rendering-Cookbook/shared",
    "source": {
        "type": "sourcefile",
        "url": "https://raw.githubusercontent.com/PacktPublishing/3D-Graphics-Rendering-Cookbook/e8bf80a2f4f2f9fafc49860f4d5b201101d42af8/shared/Trackball.h",
        "sha1": "da9a729862ba4df957e89984c1655186d2ec74f0"
    }
},
{
    "name": "3D-Graphics-Rendering-Cookbook/shared",
    "source": {
        "type": "sourcefile",
        "url": "https://raw.githubusercontent.com/PacktPublishing/3D-Graphics-Rendering-Cookbook/e8bf80a2f4f2f9fafc49860f4d5b201101d42af8/shared/Camera.h",
        "sha1": "d0fa491b2a075689ed5bf3f802269b546f267815"
    }
},
{
    "name": "3D-Graphics-Rendering-Cookbook/shared",
    "source": {
        "type": "sourcefile",
        "url": "https://raw.githubusercontent.com/PacktPublishing/3D-Graphics-Rendering-Cookbook/e8bf80a2f4f2f9fafc49860f4d5b201101d42af8/shared/UtilsMath.h",
        "sha1": "e50eb2ecfe9342ad66423493cd127ff00c1053b2"
    }
},
{
    "name": "3D-Graphics-Rendering-Cookbook/shared",
    "source": {
        "type": "sourcefile",
        "url": "https://raw.githubusercontent.com/PacktPublishing/3D-Graphics-Rendering-Cookbook/e8bf80a2f4f2f9fafc49860f4d5b201101d42af8/shared/UtilsCubemap.h",
        "sha1": "ddcfd57f144982bb2b2a43f0f47780be933a50df"
    }
},
{
    "name": "3D-Graphics-Rendering-Cookbook/shared",
    "source": {
        "type": "sourcefile",
        "url": "https://raw.githubusercontent.com/PacktPublishing/3D-Graphics-Rendering-Cookbook/e8bf80a2f4f2f9fafc49860f4d5b201101d42af8/shared/UtilsCubemap.cpp",
        "sha1": "37093b74ee4a3f9b5073e8c777511cba53793a2a"
    }
},
{
    "name": "3D-Graphics-Rendering-Cookbook/shared",
    "source": {
        "type": "sourcefile",
        "url": "https://raw.githubusercontent.com/PacktPublishing/3D-Graphics-Rendering-Cookbook/e8bf80a2f4f2f9fafc49860f4d5b201101d42af8/shared/Bitmap.h",
        "sha1": "3c13995fb713547357ed6858018ed389ef76718b"
    }
},
{
    "name": "openxr-sdk",
    "source": {
        "type": "git",
        "url": "https://github.com/KhronosGroup/OpenXR-SDK.git",
        "sha1": "release-1.1.54"
    }
},
{
    "name": "glm",
    "source": {
        "type": "git",
        "url": "https://github.com/g-truc/glm.git",
        "revision": "1.0.0"
    }
},
{
    "name": "taskflow",
    "source": {
        "type": "git",
        "url": "https://github.com/taskflow/taskflow.git",
        "revision": "v4.0.0"
    }
},
{
    "name": "imgui",
    "source": {
        "type": "git",
        "url": "https://github.com/ocornut/imgui.git",
        "revision": "v1.92.6"
    }
},
{
    "name": "implot",
    "source": {
        "type": "git",
        "url": "https://github.com/epezent/implot",
        "revision": "285df95318a4af7c2fe2da265572bdf1020ade49"
    }
},
{
    "name": "volk",
    "source": {
        "type": "git",
        "url": "https://github.com/zeux/volk",
        "revision": "04a46e2e522e91da0e9d4c146097501afb5d7c83"
    }
},
{
    "name": "vulkan-headers",
    "source": {
        "type": "git",
        "url": "https://github.com/KhronosGroup/Vulkan-Headers.git",
        "revision": "vulkan-sdk-1.4.341.0"
    }
},
{
    "name": "vma",
    "source": {
        "type": "git",
        "url": "https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator.git",
        "revision": "v3.3.0"
    }
},
{
    "name": "tracy",
    "source": {
        "type": "git",
        "url": "https://github.com/wolfpld/tracy.git",
        "revision": "v0.13.1"
    }
},
{
    "name": "minilog",
    "source": {
        "type": "git",
        "url": "https://github.com/corporateshark/minilog",
        "revision": "b3e9e454176aa6bd034cdaf4eee918e8e4346f6a"
    }
},
{
    "name": "ldrutils",
    "source": {
        "type": "git",
        "url": "https://github.com/corporateshark/ldrutils",
        "revision": "c38e2673e182a2396e8e7f5c09e03f60dd0df8ee"
    }
},
{
    "name": "cmake-wayland",
    "source": {
        "type": "sourcefile",
        "url": "https://raw.githubusercontent.com/LunarG/VulkanSamples/master/cmake/FindWayland.cmake",
        "sha1": "c2f6e9245c257e6eff91a53602844175e12a6ecc"
    }
},
{
    "name": "android-validation-layers",
    "source": {
        "type": "archive",
        "url": "https://github.com/KhronosGroup/Vulkan-ValidationLayers/releases/download/vulkan-sdk-1.4.335.0/android-binaries-1.4.335.0.zip",
        "user-agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.116 Safari/537.36"
    }
},
{
    "name": "ktx-software",
    "source": {
        "type": "git",
        "url": "https://github.com/KhronosGroup/KTX-Software.git",
        "revision": "5a07bc6f8eb95b6ea5b636903b335947d4684cef",
        "recursive": false
    }
}
]

```

`third-party/bootstrap.py`:

```py
#!/usr/bin/python3

#
# https://github.com/corporateshark/bootstrapping.git
# sk@linderdaum.com
#
# The MIT License (MIT)
# Copyright (c) 2016-2025, Sergey Kosarevsky
#
# ---
# Based on https://bitbucket.org/blippar/bootstrapping-external-libs
#
# The MIT License (MIT)
# Copyright (c) 2016 Blippar.com Ltd
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

from __future__ import print_function
import platform
import os
import sys
import io
import shutil
import subprocess
import zipfile
import tarfile
import hashlib
import json
import getopt
import traceback
import urllib
import ssl
import ctypes

ssl._create_default_https_context = ssl._create_unverified_context

try:
    from urllib.request import urlparse
    from urllib.request import urlunparse
    from urllib.request import quote
except ImportError:
    from urlparse import urlparse
    from urlparse import urlunparse
    from urllib import URLopener
    from urllib import quote

try:
    import paramiko
    import scp
    scp_available = True
except:
    scp_available = False
    print("WARNING: Please install the Python packages [paramiko, scp] for full script operation.")

try:
    import lzma
    lzma_available = True
except:
    print("WARNING: Python lzma library not available; extraction of .tar.xz files may not be supported.")
    print("Installation on Ubuntu:")
    print("> apt-get install python-lzma")
    print("Installation on Mac OS X:")
    print("> brew install xz")
    print("> pip install pyliblzma")
    lzma_available = False

BOOTSTRAP_VERSION = "1.0.7 (2025)"

class Colors:
    GREEN = '\033[92m'
    WARNING = '\033[91m'
    NORMAL = '\033[0m'

SRC_DIR_BASE = "src"
ARCHIVE_DIR_BASE = "archives"
SNAPSHOT_DIR_BASE = "snapshots"

BASE_DIR = os.getcwd()
SRC_DIR = os.path.join(BASE_DIR, SRC_DIR_BASE)
ARCHIVE_DIR = os.path.join(BASE_DIR, ARCHIVE_DIR_BASE)
SNAPSHOT_DIR = os.path.join(BASE_DIR, SNAPSHOT_DIR_BASE)

DEFAULT_PNUM = 3
DEBUG_OUTPUT = False
FALLBACK_URL = ""

USE_TAR = False
USE_UNZIP = False

TOOL_COMMAND_PYTHON = sys.executable if not " " in sys.executable else '"{}"'.format(sys.executable)
TOOL_COMMAND_GIT = "git"
TOOL_COMMAND_HG = "hg"
TOOL_COMMAND_SVN = "svn"
TOOL_COMMAND_PATCH = "patch"
TOOL_COMMAND_TAR = "tar"
TOOL_COMMAND_UNZIP = "unzip"

ansi_console = True

if platform.system() == "Windows":
    os.environ['CYGWIN'] = "nodosfilewarning"
    ansi_console = False
    if sys.getwindowsversion().major >= 10:
        ansi_console = True
        kernel32 = ctypes.windll.kernel32
        handle = kernel32.GetStdHandle(-11)
        mode = ctypes.c_uint32()
        kernel32.GetConsoleMode(handle, ctypes.byref(mode))
        kernel32.SetConsoleMode(handle, mode.value | 0x0004)

if not sys.version_info[0] >= 3:
    raise ValueError("I require Python 3.0 or a later version")

def log(string):
    print("--- " + string)

def warning(string):
    if ansi_console:
      print(Colors.WARNING, "--- " + string, Colors.NORMAL)
    else:
      print("--- " + string)

def dlog(string):
    if DEBUG_OUTPUT:
        print("*** " + string)

def executeCommand(command, printCommand = False, quiet = False):

    printCommand = printCommand or DEBUG_OUTPUT
    out = None
    err = None

    if quiet:
        out = open(os.devnull, 'w')
        err = subprocess.STDOUT

    if printCommand:
        if DEBUG_OUTPUT:
            dlog(">>> " + command)
        else:
            log(">>> " + command)

    return subprocess.call(command, shell = True, stdout=out, stderr=err);


def dieIfNonZero(res):
    if res != 0:
        raise ValueError("Command returned non-zero status: " + str(res));

def escapifyPath(path):
    if path.find(" ") == -1:
        return path
    if platform.system() == "Windows":
        return "\"" + path + "\""
    return path.replace("\\ ", " ")

def cloneRepository(type, url, target_name, revision, try_only_local_operations = False, recursive = True):
    target_dir = escapifyPath(os.path.join(SRC_DIR, target_name))
    target_dir_exists = os.path.exists(target_dir)
    log("Cloning " + url + " to " + target_dir)

    if type == "hg":
        repo_exists = os.path.exists(os.path.join(target_dir, ".hg"))

        if not repo_exists:
            if try_only_local_operations:
                raise RuntimeError("Repository for " + target_name + " not found; cannot execute local operations only")
            if target_dir_exists:
                dlog("Removing directory " + target_dir + " before cloning")
                shutil.rmtree(target_dir)
            dieIfNonZero(executeCommand(TOOL_COMMAND_HG + " clone " + url + " " + target_dir))
        elif not try_only_local_operations:
            log("Repository " + target_dir + " already exists; pulling instead of cloning")
            dieIfNonZero(executeCommand(TOOL_COMMAND_HG + " pull -R " + target_dir))

        if revision is None:
            revision = ""
        dieIfNonZero(executeCommand(TOOL_COMMAND_HG + " update -R " + target_dir + " -C " + revision))
        dieIfNonZero(executeCommand(TOOL_COMMAND_HG + " purge -R " + target_dir + " --config extensions.purge="))

    elif type == "git":
        repo_exists = os.path.exists(os.path.join(target_dir, ".git"))

        if not repo_exists:
            if try_only_local_operations:
                raise RuntimeError("Repository for " + target_name + " not found; cannot execute local operations only")
            if target_dir_exists:
                dlog("Removing directory " + target_dir + " before cloning")
                shutil.rmtree(target_dir)
            if recursive:
                dieIfNonZero(executeCommand(TOOL_COMMAND_GIT + " clone --recursive " + url + " " + target_dir))
            else:
                dieIfNonZero(executeCommand(TOOL_COMMAND_GIT + " clone " + url + " " + target_dir))
        elif not try_only_local_operations:
            log("Repository " + target_dir + " already exists; fetching instead of cloning")
            if recursive:
                dieIfNonZero(executeCommand(TOOL_COMMAND_GIT + " -C " + target_dir + " fetch --recurse-submodules"))
            else:
                dieIfNonZero(executeCommand(TOOL_COMMAND_GIT + " -C " + target_dir + " fetch"))

        if revision is None:
            revision = "HEAD"
        dieIfNonZero(executeCommand(TOOL_COMMAND_GIT + " -C " + target_dir + " reset --hard " + revision))
        dieIfNonZero(executeCommand(TOOL_COMMAND_GIT + " -C " + target_dir + " clean -fxd"))

    elif type == "svn":
        if not try_only_local_operations: # we can't do much without a server connection when dealing with SVN
            if target_dir_exists:
                dlog("Removing directory " + target_dir + " before cloning")
                shutil.rmtree(target_dir)
            dieIfNonZero(executeCommand(TOOL_COMMAND_SVN + " checkout " + url + " " + target_dir))

        if revision is not None and revision != "":
            raise RuntimeError("Updating to revision not implemented for SVN.")

    else:
        raise ValueError("Cloning " + type + " repositories not implemented.")


def decompressTarXZFile(src_filename, dst_filename):
    if not lzma_available:
        raise RuntimeError("lzma extraction not available; please install package lzma (pyliblzma) and try again")

    try:
        fs = open(src_filename, "rb")
        if not fs:
            raise RuntimeError("Opening file " + src_filename + " failed")
        fd = open(dst_filename, "wb")
        if not fd:
            raise RuntimeError("Opening file " + dst_filename + " failed")

        decompressed = lzma.decompress(fs.read())
        fd.write(decompressed)
    finally:
        fs.close()
        fd.close()



def extractFile(filename, target_dir):
    if os.path.exists(target_dir):
        shutil.rmtree(target_dir)

    log("Extracting file " + filename)
    stem, extension = os.path.splitext(os.path.basename(filename))

    if extension == ".zip" or extension == "":
        zfile = None
        try:
            zfile = zipfile.ZipFile(filename)
        except zipfile.BadZipFile:
            warning("WARNING: Invalid ZIP file '" + filename + "'")
            if os.path.exists(filename) and os.path.getsize(filename) == 0:
                warning("WARNING: Zero-sized file was deleted. Run the script again.")
                os.remove(filename)
            else:
                warning("WARNING: Try deleting the cached file and run the script again.")
            raise RuntimeError("Invalid ZIP file '" + filename + "'") from None
        extract_dir = os.path.commonprefix(zfile.namelist())
        hasFolder = False
        for fname in zfile.namelist():
            if fname.find('/') != -1:
                hasFolder = True
        extract_dir_local = ""
        if not hasFolder: # special case, there are no folders in the archive
            extract_dir = ""
        if extract_dir == "":  # deal with stupid zip files that don't contain a base directory
            extract_dir, extension2 = os.path.splitext(os.path.basename(filename))
            extract_dir_local = extract_dir
        extract_dir_abs = os.path.join(SRC_DIR, extract_dir_local)

        try:
            os.mkdirs(extract_dir_abs)
        except:
            pass

        if not USE_UNZIP:
            zfile.extractall(extract_dir_abs)
            zfile.close()
        else:
            zfile.close()
            dieIfNonZero(executeCommand(TOOL_COMMAND_UNZIP + " " + filename + " -d " + extract_dir_abs))

    elif extension == ".tar" or extension == ".gz" or extension == ".bz2" or extension == ".xz":

        if extension == ".xz":# and not lzma_available:
            stem2, extension2 = os.path.splitext(os.path.basename(stem))
            if extension2 == ".tar":
                # we extract the .tar.xz file to a .tar file before we uncompress that
                tar_filename = os.path.join(os.path.dirname(filename), stem)
                decompressTarXZFile(filename, tar_filename)
                filename = tar_filename
            else:
                raise RuntimeError("Unable to extract .xz file that is not a .tar.xz file.")

        tfile = tarfile.open(filename)
        extract_dir = os.path.commonprefix(tfile.getnames())
        extract_dir_local = ""
        if extract_dir == "":  # deal with stupid tar files that don't contain a base directory
            extract_dir, extension2 = os.path.splitext(os.path.basename(filename))
            extract_dir_local = extract_dir
        extract_dir_abs = os.path.join(SRC_DIR, extract_dir_local)

        try:
            os.mkdirs(extract_dir_abs)
        except:
            pass

        if not USE_TAR:
            tfile.extractall(extract_dir_abs)
            tfile.close()
        else:
            tfile.close()
            dieIfNonZero(executeCommand(TOOL_COMMAND_TAR + " -x -f " + filename + " -C " + extract_dir_abs))

    else:
        raise RuntimeError("Unknown compressed file format " + extension)

    if platform.system() == "Windows":
        extract_dir = extract_dir.replace( '/', '\\' )
        target_dir = target_dir.replace( '/', '\\' )
        if extract_dir[-1::] == '\\':
            extract_dir = extract_dir[:-1]

    # rename extracted folder to target_dir
    extract_dir_abs = os.path.join(SRC_DIR, extract_dir)

    needRename = True

    if platform.system() == "Windows":
       needRename = extract_dir_abs.lower() != target_dir.lower()

    if needRename: os.rename(extract_dir_abs, target_dir)


def createArchiveFromDirectory(src_dir_name, archive_name, delete_existing_archive = False):
    if delete_existing_archive and os.path.exists(archive_name):
        dlog("Removing snapshot file " + archive_name + " before creating new one")
        os.remove(archive_name)

    archive_dir = os.path.dirname(archive_name)
    if not os.path.isdir(archive_dir):
        os.mkdir(archive_dir)

    with tarfile.open(archive_name, "w:gz") as tar:
        tar.add(src_dir_name, arcname = os.path.basename(src_dir_name))


def downloadSCP(hostname, username, path, target_dir):
    if not scp_available:
        warning("ERROR: missing Python packages [paramiko, scp]; cannot continue.")
        raise RuntimeError("Missing Python packages [paramiko, scp]; cannot continue.")
    ssh = paramiko.SSHClient()
    ssh.load_system_host_keys()
    ssh.connect(hostname = hostname, username = username)
    scpc = scp.SCPClient(ssh.get_transport())
    scpc.get(path, local_path = target_dir);

def downloadProgress(cur_size, total_size):
    percent = int((cur_size / total_size)*100)
    print("[", end = "")
    for i in range(int(percent/2)):
        print("*", end = "")
    for i in range(int(percent/2), 50):
        print(".", end = "")
    print("] " + str(percent) + "% --- ", end = "")
    print("%.2f" % (cur_size / (1024*1024)), "Mb", end = "\r")

def computeFileHash(filename):
    blocksize = 65536
    hasher = hashlib.sha1()
    with open(filename, 'rb') as afile:
        buf = afile.read(blocksize)
        while len(buf) > 0:
            hasher.update(buf)
            buf = afile.read(blocksize)
    return hasher.hexdigest()

def downloadFile(url, download_dir, target_dir_name, sha1_hash = None, force_download = False, user_agent = None):
    if not os.path.isdir(download_dir):
        os.mkdir(download_dir)

    p = urlparse(url)
    url = urlunparse([p[0], p[1], quote(p[2]), p[3], p[4], p[5]]) # replace special characters in the URL path

    filename_rel = os.path.split(p.path)[1] # get original filename
    target_filename = os.path.join(download_dir, filename_rel)

    # check SHA1 hash, if file already exists
    if os.path.exists(target_filename) and sha1_hash is not None and sha1_hash != "":
        hash_file = computeFileHash(target_filename)
        if hash_file != sha1_hash:
            log("Hash of " + target_filename + " (" + hash_file + ") does not match expected hash (" + sha1_hash + "); forcing download")
            force_download = True

    # download file
    if (not os.path.exists(target_filename)) or force_download:
        log("Downloading " + url + " to " + target_filename)
        if p.scheme == "ssh":
            downloadSCP(p.hostname, p.username, p.path, download_dir)
        else:
            opener = urllib.request.build_opener()
            if user_agent is not None:
                opener.addheaders = [('User-agent', user_agent)]
            f = open(target_filename, 'wb')
            with opener.open(url) as response:
                Length = response.getheader('content-length')
                BlockSize = 128*1024 # default value
                if Length:
                    Length = int(Length)
                    BlockSize = max(BlockSize, Length // 1000)
                    Size = 0
                    while True:
                        Buffer = response.read(BlockSize)
                        if not Buffer:
                            break
                        f.write(Buffer)
                        Size += len(Buffer)
                        downloadProgress(Size, Length)
                    print();
                else:
                    f.write(response.read())
            f.close()
    else:
        log("Skipping download of " + url + "; already downloaded")

    # check SHA1 hash
    if sha1_hash is not None and sha1_hash != "":
        hash_file = computeFileHash(target_filename)
        if hash_file != sha1_hash:
            errorStr = "Hash of " + target_filename + " (" + hash_file + ") differs from expected hash (" + sha1_hash + ")"
            log(errorStr)
            raise RuntimeError(errorStr)

    return target_filename


def downloadAndExtractFile(url, download_dir, target_dir_name, sha1_hash = None, force_download = False, user_agent = None):
    target_filename = downloadFile(url, download_dir, target_dir_name, sha1_hash, force_download, user_agent)
    extractFile(target_filename, os.path.join(SRC_DIR, target_dir_name))


def applyPatchFile(patch_name, dir_name, pnum):
    # we're assuming the patch was applied like in this example:
    # diff --exclude=".git" --exclude=".hg" -rupN ./src/AGAST/ ./src/AGAST_patched/ > ./patches/agast.patch
    # where the first given location is the unpatched directory, and the second location is the patched directory.
    log("Applying patch to " + dir_name)
    patch_dir = os.path.join(BASE_DIR, "patches")
    arguments = "-d " + os.path.join(SRC_DIR, dir_name) + " -p" + str(pnum) + " < " + os.path.join(patch_dir, patch_name)
    argumentsBinary = "-d " + os.path.join(SRC_DIR, dir_name) + " -p" + str(pnum) + " --binary < " + os.path.join(patch_dir, patch_name)
    res = executeCommand(TOOL_COMMAND_PATCH + " --dry-run " + arguments, quiet = True)
    if res != 0:
        arguments = argumentsBinary
        res = executeCommand(TOOL_COMMAND_PATCH + " --dry-run " + arguments, quiet = True)
    if res != 0:
        warning("ERROR: patch application failure; has this patch already been applied?")
        executeCommand(TOOL_COMMAND_PATCH + " --dry-run " + arguments, printCommand = True)
        exit(255)
    else:
        dieIfNonZero(executeCommand(TOOL_COMMAND_PATCH + " " + arguments, quiet = True))


def runPythonScript(script_name):
    log("Running Python script " + script_name)
    patch_dir = os.path.join(BASE_DIR, "patches")
    filename = os.path.join(patch_dir, script_name)
    dieIfNonZero(executeCommand(TOOL_COMMAND_PYTHON + " " + escapifyPath(filename), False));


def findToolCommand(command, paths_to_search, required = False):
    command_res = command
    found = False

    for path in paths_to_search:
        command_abs = os.path.join(path, command)
        if os.path.exists(command_abs):
            command_res = command_abs
            found = True
            break;

    if required and not found:
        warning("WARNING: command " + command + " not found, but required by script")

    dlog("Found '" + command + "' as " + command_res)
    return command_res


def readJSONData(filename):
    try:
        json_data = open(filename).read()
    except:
        warning("ERROR: Could not read JSON file: " + filename)
        return None

    try:
        data = json.loads(json_data)
    except json.JSONDecodeError as e:
        warning("ERROR: Could not parse JSON document: {}\n    {} (line {}:{})\n".format(filename, e.msg, e.lineno, e.colno))
        return None
    except:
        warning("ERROR: Could not parse JSON document: " + filename)
        return None

    return data


def writeJSONData(data, filename):
    with open(filename, 'w') as outfile:
        json.dump(data, outfile)


def listLibraries(data):
    for library in data:
        name = library.get('name', None)
        if name is not None:
            print(name)


def printOptions():
        print("--------------------------------------------------------------------------------")
        print(BOOTSTRAP_VERSION)
        print("--------------------------------------------------------------------------------")
        print("Downloads external libraries, and applies patches or scripts if necessary.")
        print("If the --name argument is not provided, all available libraries will be")
        print("downloaded.")
        print("")
        print("Options:")
        print("  --list, -l              List all available libraries")
        print("  --name, -n              Specifies the name of a single library to be")
        print("                          downloaded")
        print("  --name-file, -N         Specifies a file that contains a (sub)set of libraries")
        print("                          to be downloaded. One library name per line; lines")
        print("                          starting with '#' are considered comments.")
        print("  --skip                  Specifies a name of a single library to be skipped")
        print("  --clean, -c             Remove library directory before obtaining library")
        print("  --clean-all, -C         Implies --clean, and also forces re-download of cached")
        print("                          archive files")
        print("  --base-dir, -b          Base directory, if script is called from outside of")
        print("                          its directory")
        print("  --bootstrap-file        Specifies the file containing the canonical bootstrap")
        print("                          JSON data (default: bootstrap.json)")
        print("  --local-bootstrap-file  Specifies the file containing local bootstrap JSON")
        print("                          data (e.g. for a particular project). The data in this")
        print("                          file will have higher precedence than the data from")
        print("                          the canonical bootstrap file.")
        print("  --use-tar               Use 'tar' command instead of Python standard library")
        print("                          to extract tar archives")
        print("  --use-unzip             Use 'unzip' command instead of Python standard library")
        print("                          to extract zip archives")
        print("  --repo-snapshots        Create a snapshot archive of a repository when its")
        print("                          state changes, e.g. on a fallback location")
        print("  --fallback-url          Fallback URL that points to an existing and already")
        print("                          bootstrapped `external` repository that may be used to")
        print("                          retrieve otherwise unobtainable archives or")
        print("                          repositories. The --repo-snapshots option must be")
        print("                          active on the fallback server. Allowed URL schemes are")
        print("                          file://, ssh://, http://, https://, ftp://.")
        print("  --force-fallback        Force using the fallback URL instead of the original")
        print("                          sources")
        print("  --debug-output          Enables extra debugging output")
        print("  --break-on-first-error  Terminate script once the first error is encountered")
        print("  --version               Print the script version")
        print("--------------------------------------------------------------------------------")


def main(argv):
    global BASE_DIR, SRC_DIR, ARCHIVE_DIR, DEBUG_OUTPUT, FALLBACK_URL, USE_TAR, USE_UNZIP
    global TOOL_COMMAND_PYTHON, TOOL_COMMAND_GIT, TOOL_COMMAND_HG, TOOL_COMMAND_SVN, TOOL_COMMAND_PATCH, TOOL_COMMAND_TAR, TOOL_COMMAND_UNZIP

    try:
        opts, args = getopt.getopt(
            argv,
            "ln:N:cCb:h",
            ["list", "name=", "name-file=", "skip=", "clean", "clean-all", "base-dir", "bootstrap-file=",
             "local-bootstrap-file=", "use-tar", "use-unzip", "repo-snapshots", "fallback-url=",
             "force-fallback", "debug-output", "help", "break-on-first-error", "version"])
    except getopt.GetoptError:
        printOptions()
        return 0

    opt_names = []
    name_files = []
    skip_libs = []
    opt_clean = False
    opt_clean_archives = False
    list_libraries = False

    default_bootstrap_filename = "bootstrap.json"
    bootstrap_filename = os.path.abspath(os.path.join(BASE_DIR, default_bootstrap_filename))
    local_bootstrap_filename = ""
    create_repo_snapshots = False
    force_fallback = False
    break_on_first_error = False

    base_dir_path = ""

    for opt, arg in opts:
        if opt in ("-h", "--help"):
            printOptions()
            return 0
        if opt in ("--version"):
            print(BOOTSTRAP_VERSION)
            return 0
        if opt in ("-l", "--list"):
            list_libraries = True
        if opt in ("-n", "--name"):
            opt_names.append(arg)
        if opt in ("-N", "--name-file"):
            name_files.append(os.path.abspath(arg))
        if opt in ("--skip",):
            skip_libs.append(arg)
        if opt in ("-c", "--clean"):
            opt_clean = True
        if opt in ("-C", "--clean-all"):
            opt_clean = True
            opt_clean_archives = True
        if opt in ("-b", "--base-dir"):
            base_dir_path = os.path.abspath(arg)
            BASE_DIR = base_dir_path
            SRC_DIR = os.path.join(BASE_DIR, SRC_DIR_BASE)
            ARCHIVE_DIR = os.path.join(BASE_DIR, ARCHIVE_DIR_BASE)
            bootstrap_filename = os.path.join(BASE_DIR, default_bootstrap_filename)
            log("Using " + arg + " as base directory")
        if opt in ("--bootstrap-file",):
            bootstrap_filename = os.path.abspath(arg)
            log("Using main bootstrap file " + bootstrap_filename)
        if opt in ("--local-bootstrap-file",):
            local_bootstrap_filename = os.path.abspath(arg)
            log("Using local bootstrap file " + local_bootstrap_filename)
        if opt in ("--use-tar",):
            USE_TAR = True
        if opt in ("--use-unzip",):
            USE_UNZIP = True
        if opt in ("--repo-snapshots",):
            create_repo_snapshots = True
            log("Will create repository snapshots")
        if opt in ("--fallback-url",):
            FALLBACK_URL = arg
        if opt in ("--force-fallback",):
            force_fallback = True
            log("Using fallback URL to fetch all libraries")
        if opt in ("--break-on-first-error",):
            break_on_first_error = True
        if opt in ("--debug-output",):
            DEBUG_OUTPUT = True

    if platform.system() != "Windows":
        # Unfortunately some IDEs do not have a proper PATH environment variable set,
        # so we search manually for the required tools in some obvious locations.
        paths_to_search = os.environ["PATH"].split(":") + ["/usr/local/bin", "/opt/local/bin", "/usr/bin"]
        TOOL_COMMAND_PYTHON = findToolCommand(TOOL_COMMAND_PYTHON, paths_to_search, required = True)
        TOOL_COMMAND_GIT = findToolCommand(TOOL_COMMAND_GIT, paths_to_search, required = True)
        TOOL_COMMAND_HG = findToolCommand(TOOL_COMMAND_HG, paths_to_search, required = True)
        TOOL_COMMAND_SVN = findToolCommand(TOOL_COMMAND_SVN, paths_to_search, required = True)
        TOOL_COMMAND_PATCH = findToolCommand(TOOL_COMMAND_PATCH, paths_to_search, required = True)
        TOOL_COMMAND_TAR = findToolCommand(TOOL_COMMAND_TAR, paths_to_search, required = USE_TAR)
        TOOL_COMMAND_UNZIP = findToolCommand(TOOL_COMMAND_UNZIP, paths_to_search, required = USE_UNZIP)

    if base_dir_path:
        os.chdir(base_dir_path)

    if name_files:
        for name_file in name_files:
            try:
                with open(name_file) as f:
                    opt_names_local = [l for l in (line.strip() for line in f) if l]
                    opt_names_local = [l for l in opt_names_local if l[0] != '#']
                    opt_names += opt_names_local
                    dlog("Name file contains: " + ", ".join(opt_names_local))
            except:
                warning("ERROR: cannot parse name file '" + name_file + "'")
                return -1

    if force_fallback and not FALLBACK_URL:
        warning("Error: cannot force usage of the fallback location without specifying a fallback URL")
        return -1;

    state_filename = os.path.join(os.path.dirname(os.path.splitext(bootstrap_filename)[0]), \
                                  "." + os.path.basename(os.path.splitext(bootstrap_filename)[0])) \
                     + os.path.splitext(bootstrap_filename)[1]

    dlog("bootstrap_filename = " + bootstrap_filename)
    dlog("state_filename     = " + state_filename)

    # read canonical libraries data
    data = readJSONData(bootstrap_filename)
    if data is None:
        return -1;

    # some sanity checking
    for library in data:
        if library.get('name', None) is None:
            warning("ERROR: Invalid schema: library object does not have a 'name'")
            return -1

    # read local libraries data, if available
    local_data = None
    if local_bootstrap_filename:
        local_data = readJSONData(local_bootstrap_filename)

        if local_data is None:
            return -1;

        # some sanity checking
        for local_library in local_data:
            if local_library.get('name', None) is None:
                warning("ERROR: Invalid schema: local library object does not have a 'name'")
                return -1

    # merge canonical and local library data, if applicable; local libraries take precedence
    if local_data is not None:
        for local_library in local_data:
            local_name = local_library.get('name', None)
            found_canonical_library = False
            for n, library in enumerate(data):
                name = library.get('name', None)
                if local_name == name:
                    data[n] = local_library # overwrite library
                    found_canonical_library = True
            if not found_canonical_library:
                data.append(local_library)

    if list_libraries:
        listLibraries(data)
        return 0

    sdata = []
    if os.path.exists(state_filename):
        sdata = readJSONData(state_filename)

    # create source directory
    if not os.path.isdir(SRC_DIR):
        log("Creating directory " + SRC_DIR)
        os.mkdir(SRC_DIR)

    # create archive files directory
    if not os.path.isdir(ARCHIVE_DIR):
        log("Creating directory " + ARCHIVE_DIR)
        os.mkdir(ARCHIVE_DIR)

    failed_libraries = []

    for library in data:
        name = library.get('name', None)
        source = library.get('source', None)
        post = library.get('postprocess', None)
        predicate = library.get('predicate', None)

        if (skip_libs) and (name in skip_libs):
            continue

        if (opt_names) and (not name in opt_names):
            continue

        if predicate is not None:
            log("Running predicate code for '" + name + "'")
            if eval(predicate) is not True:
                log("Predicate is not True for '" + name + "'; skipping library")
                continue

        lib_dir = os.path.join(SRC_DIR, name)
        lib_dir = lib_dir.replace(os.path.sep, '/')

        dlog("********** LIBRARY " + name + " **********")
        dlog("lib_dir = " + lib_dir + ")")

        # compare against cached state
        cached_state_ok = False
        if not opt_clean:
            for slibrary in sdata:
                sname = slibrary.get('name', None)
                if sname is not None and sname == name and slibrary == library and os.path.exists(lib_dir):
                    cached_state_ok = True
                    break

        if cached_state_ok:
            log("Cached state for '" + name + "' equals expected state; skipping library")
            continue
        else:
            # remove cached state for library
            sdata[:] = [s for s in sdata if not (lambda s, name : s.get('name', None) is not None and s['name'] == name)(s, name)]

        # create library directory, if necessary
        if opt_clean:
            log("Cleaning directory for " + name)
            if os.path.exists(lib_dir):
                shutil.rmtree(lib_dir)
        if not os.path.exists(lib_dir):
            os.makedirs(lib_dir)

        try:
            # download source
            if source is not None:
                if 'type' not in source:
                    warning("ERROR: Invalid schema for '" + name + "': 'source' object must have a 'type'")
                    return -1
                if 'url' not in source:
                    warning("ERROR: Invalid schema for '" + name + "': 'source' object must have a 'url'")
                    return -1
                src_type = source['type']
                src_url = source['url']

                if src_type == "sourcefile":
                    sha1 = source.get('sha1', None)
                    user_agent = source.get('user-agent', None)
                    try:
                        if force_fallback:
                            raise RuntimeError
                        downloadFile(src_url, ARCHIVE_DIR, name, sha1, force_download = opt_clean_archives, user_agent = user_agent)
                        filename_rel = os.path.basename(src_url)
                        shutil.copyfile( os.path.join(ARCHIVE_DIR, filename_rel), os.path.join(lib_dir, filename_rel) )
                    except:
                        if FALLBACK_URL:
                            if not force_fallback:
                                log("WARNING: Downloading of file " + src_url + " failed; trying fallback")

                            p = urlparse(src_url)
                            filename_rel = os.path.split(p.path)[1] # get original filename
                            p = urlparse(FALLBACK_URL)
                            fallback_src_url = urlunparse([p[0], p[1], p[2] + "/" + ARCHIVE_DIR_BASE + "/" + filename_rel, p[3], p[4], p[5]])
                            downloadFile(fallback_src_url, ARCHIVE_DIR, name, sha1, force_download = True)
                            shutil.copyfile( os.path.join(ARCHIVE_DIR, filename_rel), os.path.join(lib_dir, filename_rel) )
                        else:
                            shutil.rmtree(lib_dir)
                            raise
                elif src_type == "archive":
                    sha1 = source.get('sha1', None)
                    user_agent = source.get('user-agent', None)
                    try:
                        if force_fallback:
                            raise RuntimeError
                        downloadAndExtractFile(src_url, ARCHIVE_DIR, name, sha1, force_download = opt_clean_archives, user_agent = user_agent)
                    except:
                        if FALLBACK_URL:
                            if not force_fallback:
                                log("WARNING: Downloading of file " + src_url + " failed; trying fallback")

                            p = urlparse(src_url)
                            filename_rel = os.path.split(p.path)[1] # get original filename
                            p = urlparse(FALLBACK_URL)
                            fallback_src_url = urlunparse([p[0], p[1], p[2] + "/" + ARCHIVE_DIR_BASE + "/" + filename_rel, p[3], p[4], p[5]])
                            downloadAndExtractFile(fallback_src_url, ARCHIVE_DIR, name, sha1, force_download = True)
                        else:
                            raise

                else:
                    revision = source.get('revision', None)
                    recursive = source.get('recursive', True)

                    archive_name = name + ".tar.gz" # for reading or writing of snapshot archives
                    if revision is not None:
                        archive_name = name + "_" + revision + ".tar.gz"

                    try:
                        if force_fallback:
                            raise RuntimeError
                        cloneRepository(src_type, src_url, name, revision, False, recursive)

                        if create_repo_snapshots:
                            log("Creating snapshot of library repository '" + name + "'")
                            repo_dir = os.path.join(SRC_DIR, name)
                            archive_filename = os.path.join(SNAPSHOT_DIR, archive_name)

                            dlog("Snapshot will be saved as " + archive_filename)
                            createArchiveFromDirectory(repo_dir, archive_filename, revision is None)

                    except:
                        if FALLBACK_URL:
                            if not force_fallback:
                                log("WARNING: Cloning of repository " + src_url + " failed; trying fallback")

                            # copy archived snapshot from fallback location
                            p = urlparse(FALLBACK_URL)
                            fallback_src_url = urlunparse([p[0], p[1], p[2] + "/" + SNAPSHOT_DIR_BASE + "/" + archive_name, p[3], p[4], p[5]])
                            dlog("Looking for snapshot " + fallback_src_url + " of library repository " + name)

                            # create snapshots files directory
                            downloadAndExtractFile(fallback_src_url, SNAPSHOT_DIR, name, force_download = True)

                            # reset repository state to particular revision (only using local operations inside the function)
                            cloneRepository(src_type, src_url, name, revision, True, True)
                        else:
                            raise
            else:
                # set up clean directory for potential patch application
                shutil.rmtree(lib_dir)
                os.mkdir(lib_dir)

            # post-processing
            if post is not None:
                if 'type' not in post:
                    warning("ERROR: Invalid schema for '" + name + "': 'postprocess' object must have a 'type'")
                    return -1
                if 'file' not in post:
                    warning("ERROR: Invalid schema for '" + name + "': 'postprocess' object must have a 'file'")
                    return -1
                post_type = post['type']
                post_file = post['file']

                if post_type == "patch":
                    applyPatchFile(post_file, name, post.get('pnum', DEFAULT_PNUM))
                elif post_type == "script":
                    runPythonScript(post_file)
                else:
                    warning("ERROR: Unknown post-processing type '" + post_type + "' for " + name)
                    return -1

            # add to cached state
            sdata.append(library)

            # write out cached state
            writeJSONData(sdata, state_filename)
        except urllib.error.URLError as e:
            warning("ERROR: Failure to bootstrap library '" + name + "' (urllib.error.URLError: reason " + str(e.reason) + ")")
            if break_on_first_error:
                exit(-1)
            traceback.print_exc()
            failed_libraries.append(name)
        except:
            warning("ERROR: Failure to bootstrap library '" + name + "' (reason: " + str(sys.exc_info()[0]) + ")")
            if break_on_first_error:
                exit(-1)
            traceback.print_exc()
            failed_libraries.append(name)

    if failed_libraries:
        warning("***************************************")
        warning("FAILURE to bootstrap the following libraries:")
        warning(', '.join(failed_libraries))
        warning("***************************************")
        return -1

    log("Finished")

    # touch the state cache file
    os.utime(state_filename, None);

    return 0

if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))

```