Project Path: arc_sevaa_dwex_8t5xj8wi

Source Tree:

```txt
arc_sevaa_dwex_8t5xj8wi
├── LICENSE
├── README.md
├── docs
│   └── expressions.md
├── dwex
│   ├── __init__.py
│   ├── __main__.py
│   ├── aftercrash.py
│   ├── aranges.py
│   ├── cookie.py
│   ├── crash.py
│   ├── details.py
│   ├── die.py
│   ├── dwarfone.py
│   ├── dwarfutil.py
│   ├── exprdlg.py
│   ├── exprutil.py
│   ├── filebytes
│   │   ├── __init__.py
│   │   ├── binary.py
│   │   ├── ctypes_helper.py
│   │   ├── enum.py
│   │   ├── mach_o.py
│   │   └── pe.py
│   ├── formats.py
│   ├── frames.py
│   ├── funcmap.py
│   ├── fx.py
│   ├── locals.py
│   ├── locs.py
│   ├── machounwind.py
│   ├── patch.py
│   ├── ranges.py
│   ├── scriptdlg.py
│   ├── tree.py
│   ├── treedlg.py
│   ├── ui.py
│   └── unwind.py
├── dwex.psp
├── dwex.py
├── make.cmd
├── msi
│   └── make.cmd
├── refresh.cmd
├── setup.cfg
├── setup.py
└── test
    ├── intest.py
    └── testall.py

```

`LICENSE`:

```
Copyright 2020-2025 Seva Alekseyev

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`README.md`:

```md
DWARF Explorer
==============

A cross-platform GUI utility for visualizing the DWARF
debugging information in executable files, built on top of [pyelftools](https://github.com/eliben/pyelftools) and [filebytes](https://github.com/sashs/filebytes). Runs on Windows, MacOS X, and Linux. Supports parsing the following file types for DWARF data:
 - ELF (Linux, Android)
 - Mach-O (MacOS X, iOS)
 - PE (Windows, Cygwin)
 - WASM (aka WebAssembly)
 - ar (.a files, Linux/Unix/MacOS X static libraries)

This project came from my desire to see and navigate the DWARF tree of compiled Android and iOS binaries. Seeing the DIEs is easy enough with utilities like `readelf` or `dwarfdump`. However, chasing inter-DIE references back and forth is not straightforward with those.

The utility might be of use for anyone who is building DWARF parsers for one or another reason, especially if their preferred parsing library is `pyelftools`.

Note that regular Windows executables (EXE/DLL files) are PE files but don't, as a rule, contain DWARF information. The Microsoft toolchains (Visual Studio and the like) produce debugging information in Microsoft's own format, Program Database (PDB). There are, though, a couple of toolchains that produce PE files with DWARF debug info in them - notably GCC under Cygwin. DWARF Explorer is compatible with those.

The pyelftools library that dwex is based on supports DWARF versions 2-5, and so does dwex. DWARFv5 support might be unstable. DWARF v1 is supported experimentally, in ELF files only.

There is a known issue with incorrect parsing of DWARF in .o files and static libraries that contain them. See [eliben/pyelftools#564](https://github.com/eliben/pyelftools/issues/564).

Requirements and Dependencies
------------
 - Python 3.6.1+
 - PyQt6
 - filebytes 0.10.1+
 - pyelftools 0.30+

Installation
-------------

If necessary, install [the latest Python](https://www.python.org/downloads/) in the way that's appropriate for your OS. Run `pip install dwex` from the command line, under `sudo` or elevated command line if necessary.

On Windows, if `pip` and/or Python is not in PATH, use `c:\Python39\python -m pip install dwex`, substituting your own path to Python 3.

Alternatively, get the dwex source tree from Github, and run `python setup.py install` in the root folder of the package. In this scenario, you'd have to install the dependencies separately - with `pip install pyqt6 filebytes pyelftools`.

On Linux, sometimes the `python` command defaults to Python 2 while Python 3 is installed side by side. In this case, use `python3` and `pip3`, respectively. Use `python -V` to check.

Once you install it, there will be a `dwex` command. On Windows, there will be a `dwex.exe` in the `Scripts` folder under the Python folder, and also a start menu item "DWARF Explorer". On Linux, there
will be a "DWARF Explorer" in the app menu (tested under GNOME). On MacOS X, there will be "DWARF Explorer" in the Applications
folder, or in the user's Applications folder if the systemwide one is off limits.

In January 2022, the utility was migrated from PyQt5 to PyQt6, and the major version was bumped to 2. That cut off support for Python 3.5. The 1.x version that is compatible with Python 3.5 is still out in the repository, and pip should resolve it. 
If it does not, install by running `pip install "dwex<2"`.

Usage
-----

Click Open in the File menu, choose your executable, and eyeball the DWARF tree. Alternatively, drag and drop an executable onto the main window. You can open by dropping a dSYM bundle folder, too.

On the most basic level, the debug information in a compiled file is an array of *compilation units* (CUs). Each CU contains a tree of data items called *Debugging Information Entries* (DIEs). Each DIE has a title called *tag*, and contains a name-value dictionary called *attributes*. Each CU has exactly one root DIE, and the rest of the DIEs are in its subtree.

The UI of DWARF Explorer was meant for eyeballing that data structure:

![image](https://github.com/user-attachments/assets/2c2f426a-be59-437d-98bb-1520231641f5)

The left hand tree displays the DIEs, with CU root DIEs on the top level. Expand the tree and click on DIEs to see their attributes. DIE attributes that have a substructure or point at larger data structures are clickable.

DIEs generally correspond to source level entities in the program - variables, functions, classes, members, methods, etc. The DIE tag tells you which one is it. The exact way the compiler builds a DIE tree to describe the program varies between source languages, compiler versions, target platforms and architectures. The official home of the DWARF spec is at [dwarfstd.org](http://dwarfstd.org/), but there's considerable leeway for implementations to improvise upon. On top of that, the DWARF spec contains explicit extension points for compiler vendors to tap into.

DIE attribute values are relatively small scalars - integers, strings, sometimes short byte arrays. However, they sometimes refer at larger data structures. Physically, it's an integer, but logically, it's a pointer to some data elsewhere. Also, DIE attribute values may contain references to other DIEs - for example, a DIE for a variable would contain a reference to a DIE that describes its datatype. DIE attributes that contain references to other DIEs are rendered in blue; the link can be followed by a double-click or a Ctrl+Enter. To come back to the original DIE, use Navigate/Back, the Back mouse button, or an appropriate keyboard shortcut (Alt-Left on Windows and Linux, Ctrl-[ on Mac).

In DWARF, tag and attribute names are prefixed with `DW_TAG_` and `DW_AT_`, respectively. DWARF Explorer elides those by default to reduce visual clutter. Use `View/DWARF prefix` in the menu to bring them back.

Help DWEX get better
--------------------

Compilers and toolchains out there are a diverse bunch, compiled binaries even more so. **If you see DWARF Explorer crash, or misbehave, or complain about parsing errors - please don't hesitate to submit tickets at [github.com/sevaa/dwex/issues](https://github.com/sevaa/dwex/issues).** Ideally, attach the offending binary.


Disclaimer
----------

This project is unrelated to [ragundo/DwarfExplorer](https://github.com/ragundo/DwarfExplorer). That one deals with a different kind of dwarves. Although, interestingly enough, they also use the Qt library for their GUI.

Prior art
---------

There is also a GUI DWARF visualizer at [simark/dwarftree](https://github.com/simark/dwarftree). Also based on pyelftools,
with gtk based UI. It's been inactive since 2015. I didn't know about it when I started.

Pairs well with
---------------

For a free general purpose GUI ELF file visualizer, see [horsicq/XELFViewer](https://github.com/horsicq/XELFViewer). They also have a viewer for [Mach-O](https://github.com/horsicq/XMachOViewer) and [PE](https://github.com/horsicq/XPEViewer) binaries.

```

`docs/expressions.md`:

```md
# About Python expressions in DWEX

The "search by condition" and "highlight by condition" features of DWEX invite the user
to provide a Python expression to search or highlight the DIEs in the tree.
The expression has to be written in the Python 3, and **it should evaluate to some kind of an object**. Python distinguishes between expressions and statements. The `return` in the expression is not allowed - that would make it a statement. The result of the expression will be interpreted as a boolean according to the Python rules - if it evaluates to `True`, the respective DIE will be found or highlighted. If the expression raises an error, that is interpreted as a `False`, and the respective DIE won't be found or highlighted.

# Expression execution environment

During search or checking for highlighting, the exression is evaluated against every DIE in the tree. During execution, the expression receives a set of current DIE's properties to examine as global scope variables.

The `tag` object contains the DIE tag's name as a string, with the `DW_TAG_` prefix removed (regardless of the "DWARF Prefix" setting), in lowercase, e. g. `variable` or `subprogram`.

Each DIE attribute is provided as a separate object, their names being attribute names with the `DW_AT_` prefix removed (regardless of the "DWARF Prefix" setting), in lowercase, e. g. `name` or `type`,
and their values are attribute values, somewhat translated by pyelftools for usability. DIE attribute values that are logically strings are stored as `bytes` objects, not as proper Python strings. One may use `.decode('utf-8')` to convert them to strings, or compare them to `bytes` literals, e. g. `b'foo'`. Enum-type attributes such as `DW_AT_language` are provided as `int`s.

For deeper examination, DWEX also provides a dictionary of all attributes in an object called `attr`,
and the DIE itself as the `die` object. You can use `die` to get to the parent/child/sibling DIEs, you can get to the containing CU and to other CUs. This guide is not meant to be a complete reference, especially considering that it's someone else's API; refer to the [pyelftools](https:/github.com/eliben/pyelftools/) docs and/or sources for more.
 
The expression can use Python's built-ins in the default global scope, but can't import modules.
```

`dwex.py`:

```py
# For running interactively from the sources
from dwex.__main__ import main
main()
```

`dwex/__main__.py`:

```py
from bisect import bisect_left
import sys, os
from PyQt6.QtCore import Qt, QModelIndex, QSettings, QUrl, QEvent
from PyQt6.QtGui import QFontMetrics, QDesktopServices, QWindow
from PyQt6.QtWidgets import *

from .die import DIETableModel, on_details_row_dclick
from .formats import read_dwarf, get_debug_sections, load_companion_executable, FormatError, section_bytes, write_to_file
from .dwarfutil import get_code_location, get_di_frames, has_code_location, ip_in_range, quote_filename, subprogram_name
from .tree import DWARFTreeModel, cu_sort_key
from .scriptdlg import ScriptDlg, make_execution_environment
from .ui import setup_explorer, setup_ui
from .locals import LocalsDlg, LoadedModuleDlgBase
from .aranges import ArangesDlg
from .frames import FramesDlg
from .unwind import UnwindDlg
from .funcmap import FuncMapDlg, GatherFuncsThread
from .fx import WaitCursor, ArrowCursor
from .treedlg import TreeDlg

# Sync with version in setup.py
version = (4, 60)
the_app = None

# TODO:
# On MacOS, start without a main window, instead show the Open dialog

#-----------------------------------------------------------------
# The one and only main window class
# Pretty much DWARF unaware, all the DWARF visualization logic is in tree.py and die.py
#-----------------------------------------------------------------

# "Opened, could not parse"
class DWARFParseError(Exception):
    def __init__(self, exc, di):
        Exception.__init__(self, "DWARF parsing error: " + format(exc))
        self.dwarfinfo = di

class TheWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.sett = None
        self.in_tree_nav = False
        self.font_metrics = QFontMetrics(QApplication.font())

        self.load_settings()
        setup_ui(self)
        self.setAcceptDrops(True)

        # The data model placeholders - to be populated once we read a file
        self.dwarfinfo = None
        self.tree_model = None # Recreated between files
        self.die_model = None # Reused between DIEs

        self.findcondition = None
        self.findcucondition = None

        self.show()

        # Command line: if can't open, print the error to console
        # On Mac/Linux, the user will see it. On Windows, they won't.
        if len(sys.argv) > 1:
            try:
                if self.open_file(sys.argv[1]) is None:
                    print("The file contains no DWARF information, or it is in an unsupported format.")
            except Exception as exc:
                print(format(exc))
        elif os.environ.get("DWEX_LOADLAST") is not None and len(self.mru) > 0:
            fa = self.mru[0]
            if os.path.exists(fa[0]):
                self.open_file(fa[0], fa[1:])


    def load_settings(self):
        self.sett = sett = QSettings('Seva', 'DWARFExplorer')
        self.prefix = sett.value('General/Prefix', False, type=bool)
        self.lowlevel = sett.value('General/LowLevel', False, type=bool)
        self.hex = sett.value('General/Hex', False, type=bool)
        self.sortcus = sett.value('General/SortCUs', True, type=bool)
        self.sortdies = sett.value('General/SortDIEs', False, type=bool)
        self.dwarfregnames = sett.value('General/DWARFRegNames', False, type=bool)
        self.mru = []
        for i in range(0, 10):
            f = sett.value("General/MRU%d" % i, False)
            if f:
                arch = sett.value("General/MRUArch%d" % i, None)
                fn = sett.value("General/MRUArchA%d" % i, None)
                fa = (f,) if arch is None else (f, arch) if fn is None else (f, arch, fn)
                self.mru.append(fa)
        theme = sett.value("General/Theme", None, type=str)
        if theme and theme in QStyleFactory.keys():
            QApplication.setStyle(QStyleFactory.create(theme))

    ###################################################################
    # Done with init, now file stuff
    ###################################################################

    # Callback for the Mach-O fat binary opening logic
    # Taking a cue from Hopper or IDA, we parse only one slice at a time
    # arches is a list of strings in the simple case,
    # list of strings and tuples in the tree case (Mach-O fat library)
    def resolve_arch(self, arches, title, message):
        with ArrowCursor():
            if any(not isinstance(a, str) for a in arches):
                dlg = TreeDlg(self, title, arches)
                if dlg.exec() == QDialog.DialogCode.Accepted:
                    mi = dlg.selection
                    return mi[0] if len(mi) == 1 else mi
            else:
                r = QInputDialog.getItem(self, title, message, arches, 0, False, Qt.WindowType.Dialog)
                return arches.index(r[0]) if r[1] else None
    
    # Can throw an exception
    # Returns None if it doesn't seem to contain DWARF
    # False if the user cancelled
    # True if the DWARF tree was loaded
    def open_file(self, filename, slice = None):
        with WaitCursor():
            def recall_slice(slices, title, text):
                if len(slice) == 1:
                    return slices.index(slice[0])
                else: # arch is a tuple, assuming no more than two levels
                    (arch, fn) = slice
                    (i, a) = next(ia for ia in enumerate(slices) if ia[1][0] == arch)
                    j = a[1].index(fn)
                    return (i, j)
            di = read_dwarf(filename, self.resolve_arch if slice is None else recall_slice)
            if not di: # Covers both False and None
                return di
            
            return self.load_dwarfinfo(di, filename)

    # May throw if parsing fails
    def load_dwarfinfo(self, di, filename):
        # Some degree of graceful handling of wrong format
        # File name in case of Mach-O bundles refers to the bundle path, not to the binary path within
        try:
            #TODO, slice
            slice_code = di._slice_code if hasattr(di, '_slice_code') else None
            # Some cached top level stuff
            # Notably, iter_CUs doesn't cache (TODO, check that in the next version)
            di._ranges = None # Loaded on first use
            di._aranges = None
            di._frames = None # Loaded on first use, False means missing
            def decorate_cu(cu, i):
                cu._i = i
                cu._lineprogram = None
                cu._exprparser = None
                return cu
            di._unsorted_CUs = [decorate_cu(cu, i) for (i, cu) in enumerate(di.iter_CUs())] # We'll need them first thing, might as well load here

            # For quick CU search by offset within the info section, regardless of sorting
            di._CU_offsets = [cu.cu_offset for cu in di._unsorted_CUs]
            di._CUs = list(di._unsorted_CUs)

            if self.sortcus:
                di._CUs.sort(key = cu_sort_key)
                for (i, cu) in enumerate(di._CUs):
                    cu._i = i
            di._locparser = None # Created on first use - but see #1683

            if self.dwarfinfo is None:
                setup_explorer(self)
            self.dwarfinfo = di
            self.filename = filename
            has_CUs = bool(len(di._unsorted_CUs))
            if has_CUs:
                self.tree_model = DWARFTreeModel(di, self.prefix, self.sortcus, self.sortdies)
                self.the_tree.setModel(self.tree_model)
                self.the_tree.selectionModel().currentChanged.connect(self.on_tree_selection)
            else: # Loading a binary with no CUs - possible
                self.tree_model = None
                self.the_tree.setModel(None)
                self.die_table.setModel(None)
                self.details_table.setModel(None)
            s = os.path.basename(filename)
            if slice_code is not None:
                s += ' (' + ':'.join(slice_code) + ')'
            self.setWindowTitle("DWARF Explorer - " + s)
            # TODO: unite "enable on file load" into a collection
            self.savesection_menuitem.setEnabled(True)
            self.switchslice_menuitem.setEnabled(slice_code is not None)
            self.loadexec_menuitem.setEnabled(di._format in (1, 5))
            self.back_menuitem.setEnabled(False)
            self.back_tbitem.setEnabled(False)
            self.forward_menuitem.setEnabled(False)
            self.forward_tbitem.setEnabled(False)
            self.followref_menuitem.setEnabled(False)
            self.followref_tbitem.setEnabled(False)
            self.highlightcode_menuitem.setEnabled(has_CUs)
            self.highlightsubstring_menuitem.setEnabled(has_CUs)
            self.highlightcondition_menuitem.setEnabled(has_CUs)
            self.highlightnothing_menuitem.setEnabled(has_CUs)
            self.copy_menuitem.setEnabled(False)
            self.copy_tbitem.setEnabled(False)
            self.copyline_menuitem.setEnabled(False)
            self.copytable_menuitem.setEnabled(False)
            self.findbycondition_menuitem.setEnabled(has_CUs)
            self.find_menuitem.setEnabled(has_CUs)
            self.find_tbitem.setEnabled(has_CUs)
            self.findip_menuitem.setEnabled(has_CUs)
            self.byoffset_menuitem.setEnabled(has_CUs)
            self.byoffset_tbitem.setEnabled(has_CUs)
            self.localsat_menuitem.setEnabled(has_CUs)
            self.funcmap_menuitem.setEnabled(has_CUs)
            self.aranges_menuitem.setEnabled(has_CUs)
            self.frames_menuitem.setEnabled(True)
            self.unwind_menuitem.setEnabled(di._format in (1, 5))
            self.on_highlight_nothing()
            # Navigation stack - empty
            self.navhistory = []
            self.navpos = -1
            self.save_filename_in_mru(filename, slice_code)
            LoadedModuleDlgBase.reset(di)
            LocalsDlg.reset()
            from .crash import set_binary_desc
            set_binary_desc(("ELF", "MachO", "PE", "WASM", "ELFinA", "MachOinA", "MachOinAinFat")[di._format] + " " + di.config.machine_arch)
            return True
        except AssertionError as ass: # Covers exeptions during parsing
            raise DWARFParseError(ass, di)        

    def save_mru(self):
        for i, fa in enumerate(self.mru):
            self.sett.setValue("General/MRU%d" % i, fa[0])    

            if len(fa) > 2:
                self.sett.setValue("General/MRUArchA%d" % i, fa[2])
            else:
                self.sett.remove("General/MRUArchA%d" % i)

            if len(fa) > 1:
                self.sett.setValue("General/MRUArch%d" % i, fa[1])
            else:
                self.sett.remove("General/MRUArch%d" % i)

        for i in range(len(self.mru), 10):
            self.sett.remove("General/MRU%d" % i)
            self.sett.remove("General/MRUArch%d" % i)
            self.sett.remove("General/MRUArchA%d" % i)

    # Open a file, display an error if failure
    # Called from menu/File/Open, toolbar/Open, File/MRU, and the drop handler. MRU provides the arch
    def open_file_interactive(self, filename, arch = None):
        try:
            if self.open_file(filename, arch) is None:
                if os.path.isdir(filename):
                    s = "The directory (bundle) could not be resolved to a DWARF containing file, or the file contains no DWARF information. Try navigating inside and open the executable file directly."
                else:
                    s = "The file contains no DWARF information, or it is in an unsupported format."
                self.show_warning(s)
        except FormatError as ferr:
            self.show_warning(str(ferr))
        except DWARFParseError as dperr:
            mb = QMessageBox(QMessageBox.Icon.Critical, "DWARF Explorer",
                "Error parsing the DWARF information in this file. Would you like to save the debug section contents for manual analysis?",
                QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.No, self)
            mb.setEscapeButton(QMessageBox.StandardButton.No)
            r = mb.exec()
            if r == QMessageBox.StandardButton.Yes:
                self.save_sections(filename, dperr.dwarfinfo)
        except Exception as exc:
            QMessageBox(QMessageBox.Icon.Critical, "DWARF Explorer",
                "Error opening the file:\n\n" + format(exc),
                QMessageBox.StandardButton.Ok, self).show()
            
    def save_sections(self, filename, di):
        dir = QFileDialog.getExistingDirectory(self, "Choose a save location", os.path.dirname(filename))
        if dir:
            sections = get_debug_sections(di)
            basename = os.path.basename(filename)
            overwrite_all = False
            for (name, section) in sections.items():
                try:
                    section_file = os.path.join(dir, basename + '.' + name)
                    skip = False
                    if os.path.exists(section_file) and not overwrite_all:
                        mb = QMessageBox(QMessageBox.Icon.Question, "DWARF Explorer",
                            "File %s exists, overwrite?" % section_file,
                            QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.YesAll|QMessageBox.StandardButton.No|QMessageBox.StandardButton.Cancel, self)
                        mb.setEscapeButton(QMessageBox.StandardButton.Cancel)
                        r = mb.exec()
                        if r == QMessageBox.StandardButton.Cancel:
                            return
                        elif r == QMessageBox.StandardButton.YesAll:
                            overwrite_all = True
                        elif r == QMessageBox.StandardButton.No:
                            skip = True
                    if not skip:
                        write_to_file(section_file, section_bytes(section))
                except:
                    pass

    # TODO: list the extensions for the open file dialog?
    def on_open(self):
        dir = os.path.dirname(self.mru[0][0]) if len(self.mru) > 0 else ''
        filename = QFileDialog.getOpenFileName(self, None, dir)
        if filename[0]:
            self.open_file_interactive(os.path.normpath(filename[0]))

    def on_loadexec(self):
        dir = os.path.dirname(self.mru[0][0]) if len(self.mru) > 0 else ''
        filename = QFileDialog.getOpenFileName(self, None, dir)
        if filename[0]:
            try:
                load_companion_executable(filename[0], self.dwarfinfo)
            except FormatError as exc:
                self.show_warning(str(exc))

    def populate_mru_menu(self):
        class MRUHandler(object):
            def __init__(self, fn, sc, win):
                object.__init__(self)
                self.fn = fn
                self.sc = sc
                self.win = win
            def __call__(self):
                if os.path.exists(self.fn):
                    self.win.open_file_interactive(self.fn, self.sc)
                else:
                    mb =  QMessageBox(QMessageBox.Icon.Critical, "DWARF Explorer",
                        f"The file or bundle {self.fn} does not exist or is not accessible. Shall we remove it from the recent file menu?",
                        QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.No, self.win)
                    mb.setEscapeButton(QMessageBox.StandardButton.No)
                    r = mb.exec()
                    if r == QMessageBox.StandardButton.Yes:
                        self.win.delete_from_mru((self.fn,) if self.sc is None else (self.fn,) + self.sc)

        for i, fnsc in enumerate(self.mru):
            s = fn = fnsc[0]
            if len(fnsc) > 1:
                slice_code = fnsc[1:]
                s += ' (' + ':'.join(slice_code) + ')'
            else:
                slice_code = None
            self.mru_menu.addAction(s).triggered.connect(MRUHandler(fn, slice_code, self))

    # slice_code is a tuple
    def save_filename_in_mru(self, filename, slice_code = None):
        mru_record = (filename,) if slice_code is None else (filename,) + slice_code
        try:
            i = self.mru.index(mru_record)
        except ValueError:
            i = -1
        if i != 0:
            if i > 0:
                self.mru.pop(i)
            self.mru.insert(0, mru_record)
            if len(self.mru) > 10:
                self.mru = self.mru[0:10]
            self.save_mru()
            self.mru_menu.setEnabled(True)
            self.mru_menu.clear()
            self.populate_mru_menu()

    def delete_from_mru(self, mru_record):
        try:
            self.mru.remove(mru_record) # ValueError if not found
            self.save_mru()
            self.mru_menu.setEnabled(len(self.mru) > 0)
            self.mru_menu.clear()
            self.populate_mru_menu()
        except ValueError:
            pass

    # File drag/drop handling - equivalent to open
    def dragEnterEvent(self, evt):
        if evt.mimeData() and evt.mimeData().hasUrls() and len(evt.mimeData().urls()) == 1:
            evt.accept()

    def dropEvent(self, evt):
        self.open_file_interactive(os.path.normpath(evt.mimeData().urls()[0].toLocalFile()))

    # Save sections as
    def on_savesection(self):
        di = self.dwarfinfo
        # Maps display name to field name in DWARFInfo
        sections = get_debug_sections(di)
        
        names = sections.keys()
        r = QInputDialog.getItem(self, 'Save a Section', 'Choose a section:', names, 0, False, Qt.WindowType.Dialog)
        if r[1]:
            section_name = r[0]
            r = QFileDialog.getSaveFileName(self, "Save a section", self.filename + '.' + section_name)
            if r[0]:
                try:
                    write_to_file(r[0], section_bytes(sections[section_name]))
                except Exception as exc:
                    QMessageBox(QMessageBox.Icon.Critical, "DWARF Explorer",
                        "Error saving the section data:\n\n" + format(exc),
                        QMessageBox.StandardButton.Ok, self).show()
    
    # Just present the slice dialog again
    # TODO: do this in a more elegant way, without reopening and rereading
    def on_switchslice(self):
        self.open_file(self.filename, None)

    #############################################################
    # Done with file stuff, now tree navigation
    #############################################################     

    # Index is a tree index - the DIE is the data object within
    def display_die(self, index):
        if self.details_table and self.die_table: # Short out for #1753
            die = index.internalPointer()
            die_table = self.die_table
            if not self.die_model:
                self.die_model = DIETableModel(die, self.prefix, self.lowlevel, self.hex, self.dwarfregnames)
                die_table.setModel(self.die_model)
                die_table.selectionModel().currentChanged.connect(self.on_attribute_selection)
            else:
                self.die_model.display_DIE(die)
            self.die_table.resizeColumnsToContents()
            self.details_table.setModel(None)
            self.followref_menuitem.setEnabled(False)
            self.followref_tbitem.setEnabled(False)
            self.cuproperties_menuitem.setEnabled(True)
            self.die_table.setCurrentIndex(QModelIndex()) # Will cause on_attribute_selection

            #TODO: resize the attribute table vertically dynamically
            #attr_count = self.die_model.rowCount(None)
            #die_table.resize(die_table.size().width(),
            #    die_table.rowViewportPosition(attr_count-1) + 
            #        die_table.rowHeight(attr_count-1) +
            #        die_table.horizontalHeader().size().height() + 1 + attr_count)
            #self.rpane_layout.update()

    # Invoked for tree clicks and keyboard navigation, ref follow, back-forward
    def on_tree_selection(self, index, prev = None):
        if not self.in_tree_nav: # Short out the history population logic for back-forward clicks
            navitem = self.tree_model.get_navitem(index)
            if navitem: # Weird, should never happen - yet #1473
                self.navhistory[0:self.navpos] = [navitem]
                self.navpos = 0
                self.back_menuitem.setEnabled(len(self.navhistory) > 1)
                self.back_tbitem.setEnabled(len(self.navhistory) > 1)
                self.forward_menuitem.setEnabled(False)
                self.forward_tbitem.setEnabled(False)
        self.display_die(index) # Will clear the selection in the attribute table

    # Selection changed in the DIE table - either user or program
    def on_attribute_selection(self, index, prev = None):
        if index.isValid():
            details_model = self.die_model.get_attribute_details(index)
            self.details_table.setModel(details_model)
            if details_model is not None:
                self.details_table.resizeColumnsToContents()
                has_warning = hasattr(details_model, 'warning') and details_model.warning is not None
                self.details_warning.setVisible(has_warning)
                if has_warning:
                    self.details_warning.setText(details_model.warning)
            else:
                self.details_warning.setVisible(False)
            self.followref_menuitem.setEnabled(self.die_model.ref_target(index) is not None)
            self.followref_tbitem.setEnabled(self.die_model.ref_target(index) is not None)
            self.copy_menuitem.setEnabled(True)
            self.copy_tbitem.setEnabled(True)
            self.copyline_menuitem.setEnabled(True)
            self.copytable_menuitem.setEnabled(True)
        else: # Selected nothing
            self.details_table.setModel(None)
            self.copy_menuitem.setEnabled(False)
            self.copy_tbitem.setEnabled(False)
            self.copyline_menuitem.setEnabled(False)
            self.copytable_menuitem.setEnabled(False)            
            self.followref_menuitem.setEnabled(False)
            self.followref_tbitem.setEnabled(False)


    def on_attribute_dclick(self, index):
        self.followref(index)

    # For both back and forward, delta=1 for back, -1 for forward
    # Checked because back-forward buttons can't be disabled
    def on_nav(self, delta):
        if self.tree_model: # Maybe fix for #1461? Short out nav if no file loaded
            np = self.navpos + delta
            if np < 0 or np >= len(self.navhistory):
                return
            self.navpos = np
            navitem = self.navhistory[np]
            tree_index = self.tree_model.index_for_navitem(navitem)
            self.in_tree_nav = True
            self.the_tree.setCurrentIndex(tree_index) # Causes on_tree_selection internally
            self.in_tree_nav = False
            self.back_menuitem.setEnabled(np < len(self.navhistory) - 1)
            self.back_tbitem.setEnabled(np < len(self.navhistory) - 1)
            self.forward_menuitem.setEnabled(np > 0)
            self.forward_tbitem.setEnabled(np > 0)

    def followref(self, index = None):
        with WaitCursor():
            # TODO: only show the wait cursor if it's indeed time consuming
            if index is None:
                index = self.die_table.currentIndex()
            navitem = self.die_model.ref_target(index)  # Retrieve the ref target from the DIE model...
            if navitem:
                target_tree_index = self.tree_model.index_for_navitem(navitem) # ...and feed it to the tree model.
                if target_tree_index:
                    self.the_tree.setCurrentIndex(target_tree_index) # Calls on_tree_selection internally

    # Called for double-click on a reference type attribute, and via the menu
    def on_followref(self):
        self.followref()

    def on_details_dclick(self, index):
        if index.isValid():
            on_details_row_dclick(index, index.internalPointer(), self)

    ##########################################################################
    # Find/Find next stuff
    ##########################################################################

    def findbytext(self, die, s):
        for k in die.attributes.keys():
            attr = die.attributes[k]
            v = attr.value
            f = attr.form
            all = "\n".join((str(v), str(k), f, hex(v) if isinstance(v, int) else '')).lower()
            if all.find(s) >= 0:
                return True
        return False

    # Exception means false
    def eval_user_condition(self, cond, die):
        try:
            env = make_execution_environment(die)
        except Exception as exc: # Our error
            from .crash import report_crash
            from inspect import currentframe
            report_crash(exc, exc.__traceback__, version, currentframe())
            return False
        try:
            return eval(cond, env)
        except Exception as exc: # Error in condition or it assumes a different DIE structure 
            print("Error in user condition: %s" % format(exc))
            return False

    def on_find(self):
        r = QInputDialog.getText(self, 'Find', 'Find what:')
        if r[1] and r[0]:
            s = r[0].lower()
            self.findcondition = lambda die: self.findbytext(die, s)
            self.findcucondision = None
            self.findnext_menuitem.setEnabled(True)
            self.on_findnext()

    def on_findip(self):
        start_address = hex(self.dwarfinfo._start_address) if not self.dwarfinfo._start_address is None else "its preferred address"
        r = QInputDialog.getText(self, "Find code address", "Code address (hex), assuming the module is loaded at %s:" % start_address)
        if r[1] and r[0]:
            try:
                ip = r[0]
                if r[0].startswith("0x"):
                    ip = ip[2:]
                ip = int(ip, 16)
                self.findcondition = lambda die: ip_in_range(die, ip)
                self.findcucondition = lambda cu: ip_in_range(cu.get_top_DIE(), ip)
                self.findnext_menuitem.setEnabled(True)
                self.on_findnext()            
            except ValueError:
                pass

    def on_byoffset(self):
        r = QInputDialog.getText(self, "Find DIE by offset", "DIE offset (hex), relative to the section start:")
        if r[1] and r[0]:
            try:
                offset = int(r[0], 16)
                index = self.tree_model.find_offset(offset)
                if index:
                    self.the_tree.setCurrentIndex(index)
                else:
                    self.show_warning("The specified offset was not found. It could be beyond the section size, or fall into a CU header area.")
            except ValueError:
                pass

    def sample_die(self):
        return self.the_tree.currentIndex().internalPointer() or self.dwarfinfo._CUs[0].get_top_DIE()

    def on_findbycondition(self):
        dlg = ScriptDlg(self, self.sample_die())
        if dlg.exec() == QDialog.DialogCode.Accepted:
            cond = dlg.cond
            self.findcondition = lambda die: self.eval_user_condition(cond, die)
            self.findcucondition = None
            self.findnext_menuitem.setEnabled(True)
            self.on_findnext()

    def on_findnext(self):
        index = self.tree_model.find(self.the_tree.currentIndex(), self.findcondition, self.findcucondition)
        if index:
            self.the_tree.setCurrentIndex(index)

    def on_changetheme(self):
        themes = ["Default",] + QStyleFactory.keys()
        theme = self.sett.value('General/Theme', None, type=str)
        theme_no = themes.index(theme) if theme and theme in themes else 0
        r = QInputDialog.getItem(self, "Theme", "Please select the visual theme:", themes, theme_no, False, Qt.WindowType.Dialog)
        if r[1]:
            new_theme_no = themes.index(r[0])
            if new_theme_no == 0 and theme:
                self.sett.remove('General/Theme')
            elif new_theme_no > 0:
                self.sett.setValue('General/Theme', themes[new_theme_no])

            if new_theme_no > 0:
                QApplication.setStyle(QStyleFactory.create(themes[new_theme_no]))
            else:
                QApplication.setStyle(None)
    
    ##########################################################################
    ##########################################################################

    def on_about(self):
        QMessageBox(QMessageBox.Icon.Information, "About...", "DWARF Explorer v." + '.'.join(str(v) for v in version) + "\n\nSeva Alekseyev, 2020-2024\nsevaa@sprynet.com\n\ngithub.com/sevaa/dwex",
            QMessageBox.StandardButton.Ok, self).show()

    def on_updatecheck(self):
        from urllib.request import urlopen
        import json
        try:
            releases = False
            with WaitCursor():
                resp = urlopen('https://api.github.com/repos/sevaa/dwex/releases')
                if resp.getcode() == 200:
                    releases = json.loads(resp.read())
            if releases and len(releases) > 0:
                max_ver = max(tuple(int(v) for v in r['tag_name'].split('.')) for r in releases)
                max_tag = '.'.join(str(i) for i in max_ver)
                if max_ver > version:
                    s = "DWARF Explorer v." + max_tag + " is out. Use \"pip install --upgrade dwex\" to update."
                    # TODO: not only pip
                else: 
                    s = "You have the latest version."
                QMessageBox(QMessageBox.Icon.Information, "DWARF Explorer", s, QMessageBox.StandardButton.Ok, self).show()
        except:
            pass

    def on_exit(self):
        self.destroy()
        QApplication.quit()

    # Checkmark toggling is handled by the framework
    def on_view_prefix(self, checked):
        self.prefix = checked
        self.sett.setValue('General/Prefix', self.prefix)
        if self.tree_model:
            self.tree_model.set_prefix(checked)

        if self.die_model:
            self.die_model.set_prefix(checked)
            self.refresh_details()

    # Checkmark toggling is handled by the framework
    def on_view_lowlevel(self, checked):   
        self.lowlevel = checked
        self.sett.setValue('General/LowLevel', self.lowlevel)
        if self.die_model:
            new_sel = self.die_model.set_lowlevel(checked, self.die_table.currentIndex())
            if new_sel:
                self.die_table.setCurrentIndex(new_sel)

    def on_view_hex(self, checked):        
        self.hex = checked
        self.sett.setValue('General/Hex', self.hex)
        if self.die_model:
            self.die_model.set_hex(checked)
            self.refresh_details()

    def on_view_regnames(self, checked):        
        self.dwarfregnames = checked
        self.sett.setValue('General/DWARFRegNames', self.dwarfregnames)
        if self.die_model:
            self.die_model.set_regnames(checked)
            self.refresh_details()            

    def on_sortcus(self, checked):
        self.sortcus = checked
        self.sett.setValue('General/SortCUs', self.sortcus)
        if self.tree_model:
            sel = self.the_tree.currentIndex()
            sel = self.tree_model.set_sortcus(checked, sel) # This will reload the tree
            if sel:
                self.the_tree.setCurrentIndex(sel)

    def on_sortdies(self, checked):
        self.sortdies = checked
        self.sett.setValue('General/SortDIEs', self.sortdies)
        if self.tree_model:
            #Throw away everything we had cached so far
            sel = self.tree_model.set_sortdies(checked)
            #This invalidates the navigation
            self.back_menuitem.setEnabled(False)
            self.back_tbitem.setEnabled(False)
            self.forward_menuitem.setEnabled(False)
            self.forward_tbitem.setEnabled(False)
            self.followref_menuitem.setEnabled(False)
            self.followref_tbitem.setEnabled(False)
            # Navigation stack - empty
            self.navhistory = []
            self.navpos = -1
            if sel:
                self.the_tree.setCurrentIndex(sel)

    # Tree highlighting business

    def manage_hlnavigation(self, b = None):
        if b is None:
            b = self.tree_model.has_any_highlights()
        self.prevhl_menuitem.setEnabled(b)
        self.nexthl_menuitem.setEnabled(b)
        self.prevhl_tbitem.setEnabled(b)
        self.nexthl_tbitem.setEnabled(b)

    def highlight_off(self, key):
        self.tree_model.remove_highlight(key)
        self.manage_hlnavigation()

    def on_highlight_code(self):
        if self.tree_model.has_highlight(1):
            self.highlight_off(1)
        else:
            self.tree_model.add_highlight(1, has_code_location)        
            self.manage_hlnavigation(True)

    def on_highlight_substring(self):
        if self.tree_model.has_highlight(2):
            self.highlight_off(2)
        else:
            r = QInputDialog.getText(self, 'Highlight', 'Highlight DIEs with substring:')
            if r[1] and r[0]:
                s = r[0].lower()
                self.tree_model.add_highlight(2, lambda die:self.findbytext(die, s))
                self.manage_hlnavigation(True)
            else:
                self.highlightsubstring_menuitem.setChecked(False)

    def on_highlight_condition(self):
        if self.tree_model.has_highlight(3):
            self.highlight_off(3)
        else:
            dlg = ScriptDlg(self, self.sample_die())
            if dlg.exec() == QDialog.DialogCode.Accepted:
                cond = dlg.cond
                self.tree_model.add_highlight(3, lambda die: self.eval_user_condition(cond, die))
                self.manage_hlnavigation(True)
            else:
                self.highlightcondition_menuitem.setChecked(False)
            # Accepted with blank or bogus expression is not supported

    def on_highlight_nothing(self):
        self.highlightcode_menuitem.setChecked(False)
        self.highlightsubstring_menuitem.setChecked(False)
        self.highlightcondition_menuitem.setChecked(False)
        self.manage_hlnavigation(False)
        if self.tree_model:
            self.tree_model.clear_highlight()

    def on_nexthl(self):
        index = self.tree_model.find(self.the_tree.currentIndex(), self.tree_model.is_highlighted, False)
        if index:
            self.the_tree.setCurrentIndex(index)

    def on_prevhl(self):
        index = self.tree_model.find_back(self.the_tree.currentIndex(), self.tree_model.is_highlighted, False)
        if index:
            self.the_tree.setCurrentIndex(index)

    def on_cuproperties(self):
        die = self.the_tree.currentIndex().internalPointer()
        if die:
            cu = die.cu
            ver = cu['version']
            if ver > 1:
                props = (ver, cu['unit_length'], cu['debug_abbrev_offset'], cu['address_size'])
                s = "DWARF version:\t%d\nLength:\t%d\nAbbrev table offset: 0x%x\nAddress size:\t%d" % props
            else:
                props = (ver, cu['address_size'])
                s = "DWARF version:\t%d\nAddress size:\t%d" % props
            t = "CU at 0x%x" % cu.cu_offset
            QMessageBox(QMessageBox.Icon.Information, t, s, QMessageBox.StandardButton.Ok, self).show()

    def on_copy(self, v):
        cb = QApplication.clipboard()
        cb.clear()
        cb.setText(v)

    def on_copyvalue(self):
        t = self.details_table if self.details_table.hasFocus() and self.details_table.model() else self.die_table
        m = t.model()
        self.on_copy(m.data(t.currentIndex(), Qt.ItemDataRole.DisplayRole) or "")

    def on_copyline(self):
        t = self.details_table if self.details_table.hasFocus() else self.die_table
        m = t.model()
        row = t.currentIndex().row()
        line = "\t".join(str(m.data(m.index(row, c, QModelIndex()), Qt.ItemDataRole.DisplayRole) or "")
            for c in range(0, m.columnCount(QModelIndex())))
        self.on_copy(line)

    def on_copytable(self):
        t = self.details_table if self.details_table.hasFocus() else self.die_table
        m = t.model()
        table_text = "\n".join(
                "\t".join(str(m.data(m.index(r, c, QModelIndex()), Qt.ItemDataRole.DisplayRole)  or "")
                for c in range(0, m.columnCount(QModelIndex())))
            for r in range(0, m.rowCount(QModelIndex())))
        self.on_copy(table_text)

    ##################################################################

    def on_localsat(self):
        dlg = LocalsDlg(self, self.dwarfinfo, self.prefix, self.dwarfregnames, self.hex)
        if dlg.exec() == QDialog.DialogCode.Accepted and dlg.selected_die:
             self.the_tree.setCurrentIndex(self.tree_model.index_for_die(dlg.selected_die))

    def on_funcmap(self):
        th = GatherFuncsThread(self, self.dwarfinfo)
        def done():
            if not pd.wasCanceled():
                pd.close()

            if th.funcs:
                dlg = FuncMapDlg(self, self.hex, th.funcs)
                if dlg.exec() == QDialog.DialogCode.Accepted and dlg.selected_die:
                    self.the_tree.setCurrentIndex(self.tree_model.index_for_die(dlg.selected_die))
            elif th.exc:
                print(th.exc)

        last_CU = self.dwarfinfo._unsorted_CUs[-1]
        pd = QProgressDialog("Gathering functions...", "Cancel", 0, last_CU.cu_offset + last_CU.size, self, Qt.WindowType.Dialog)
        pd.canceled.connect(th.cancel)
        pd.show()
        th.progress.connect(pd.setValue)
        th.finished.connect(done)
        th.start() # Will continue in done

    def on_aranges(self):
        from elftools.common.exceptions import ELFParseError
        try:
            ara = self.dwarfinfo.get_aranges()
        except ELFParseError: # Catching the IAR < 9.30 aranges misalignment issue
            self.show_warning("The aranges section in this binary is corrupt.")
            return

        if ara:
            dlg = ArangesDlg(self, ara, self.dwarfinfo, self.hex)
            if dlg.exec() == QDialog.DialogCode.Accepted and dlg.selected_cu_offset is not None:
                di = self.dwarfinfo
                i = bisect_left(di._CU_offsets, dlg.selected_cu_offset)
                if i < len(di._CU_offsets) and di._CU_offsets[i] == dlg.selected_cu_offset:
                    die = di._unsorted_CUs[i].get_top_DIE()
                    self.the_tree.setCurrentIndex(self.tree_model.index_for_die(die))
        else:
            self.show_warning("This binary does not have an aranges section.")
            
    def on_frames(self):
        try:
            entries = get_di_frames(self.dwarfinfo)
            if entries:
                FramesDlg(self, entries, self.dwarfinfo, self.dwarfregnames, self.hex).exec()
                # TODO: navigate to function
            else:
                self.show_warning("This binary does not have neither an eh_frames section nor a debug_frames section.")
        except KeyError: # 1761
            self.show_warning("Error parsing the frames section in this binary. Please report to the tech support: menu/Help/Report an issue.")

            
    def on_unwind(self):
        if self.dwarfinfo._unwind_sec:
            UnwindDlg(self, self.dwarfinfo._unwind_sec, self.dwarfinfo, self.dwarfregnames, self.hex).exec()
            # TODO: navigate to function
        elif self.dwarfinfo._has_exec:
            self.show_warning("Neither this binary/slice nor the companion executable has an unwind_info section.")
        else: # TODO: distinguish .o files where the section is named differently
            self.show_warning("This binary/slice does not have an unwind_info section, but the corresponding executable might. Use File/Load companion... to find and load one.")

    # If the details pane has data - reload that
    def refresh_details(self):
        index = self.die_table.currentIndex()
        if index.isValid():
            details_model = self.die_model.get_attribute_details(index)
            if details_model:
                self.details_table.setModel(details_model)
                self.details_table.resizeColumnsToContents()
        self.die_table.resizeColumnsToContents()

    def on_issue(self):
        QDesktopServices.openUrl(QUrl('https://github.com/sevaa/dwex/issues/new'))

    def on_homepage(self):
        QDesktopServices.openUrl(QUrl('https://github.com/sevaa/dwex'))

    # All purpose debug hook
    def on_debug(self):
        pass

    def show_warning(self, s):
        QMessageBox(QMessageBox.Icon.Warning, "DWARF Explorer", s, QMessageBox.StandardButton.Ok, self).show()

    def expr_formatter(self):
        return self.die_model.expr_formatter

def on_exception(exctype, exc, tb):
    if isinstance(exc, MemoryError):
        app = QApplication.instance()
        app.win.destroy()
        app.win = None
        QMessageBox(QMessageBox.Icon.Critical, "DWARF Explorer", "Out of memory. DWARF Explorer will now close. Sorry.",
            QMessageBox.StandardButton.Ok, None).show()
        sys.exit(1)
    elif isinstance(exc, Exception):
        from .crash import report_crash
        report_crash(exc, exc.__traceback__, version)
        try:
            global the_app
            if the_app and the_app.win and the_app.win.sett:
                the_app.win.sett.setValue("Crashed", True)
        except Exception:
            pass
        sys.excepthook = on_exception.prev_exchook
        sys.exit(1)
    elif on_exception.prev_exchook:
        on_exception.prev_exchook(exctype, exc, tb)

class TheApp(QApplication):
    def __init__(self):
        super().__init__([])
        self.win = None

    def notify(self, o, evt):
        if evt.type() == QEvent.Type.MouseButtonPress and isinstance(o, QWindow) and hasattr(evt, "button"):
            b = evt.button()
            if b == Qt.MouseButton.BackButton:
                self.win.on_nav(1)
            elif b == Qt.MouseButton.ForwardButton:
                self.win.on_nav(-1)
        return QApplication.notify(self, o, evt)
    
    def start(self):
        self.win = TheWindow()
        self.exec()

def main():
    under_debugger = hasattr(sys, 'gettrace') and sys.gettrace() or hasattr(sys, 'monitoring') and sys.monitoring.get_tool(sys.monitoring.DEBUGGER_ID) # Lame way to detect a debugger
    if not under_debugger and os.environ.get("DWEX_NOEXCHOOK") is None: 
        on_exception.prev_exchook = sys.excepthook
        sys.excepthook = on_exception

    from .patch import monkeypatch
    monkeypatch()

    global the_app
    the_app = TheApp()
    the_app.start()

# For running via "python -m dwex"
# Running this file directly won't work, it relies on being in a module
if __name__ == "__main__":
    main()
```

`dwex/aranges.py`:

```py
from PyQt6.QtCore import Qt, QAbstractTableModel
from PyQt6.QtWidgets import *

from .details import GenericTableModel
from .dwarfutil import top_die_file_name

# TODO: low level view?
# TODO: sort by header click

class ArangesDlg(QDialog):
    def __init__(self, win, ara, di, use_hex):
        QDialog.__init__(self, win, Qt.WindowType.Dialog)
        self.selected_cu_offset = False
        self.resize(650, 500)

        lines = [(hex(entry.begin_addr),
                    hex(entry.begin_addr + entry.length - 1),
                    hex(entry.length) if use_hex else str(entry.length),
                    hex(entry.info_offset),
                    top_die_file_name(di.get_CU_at(entry.info_offset).get_top_DIE()),
                    entry.info_offset)
                    for entry in ara.entries]
        model = GenericTableModel(("Start address", "End address", "Length", 'CU offset', 'Source name'), lines)

        ly = QVBoxLayout()

        self.the_table = QTableView()
        self.the_table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
        self.the_table.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)
        self.the_table.setModel(model)
        self.the_table.selectionModel().currentChanged.connect(self.on_sel)
        self.the_table.doubleClicked.connect(self.navigate_to_index)
        self.the_table.horizontalHeader().setSectionResizeMode(4, QHeaderView.ResizeMode.ResizeToContents)
        ly.addWidget(self.the_table)

        buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Close, Qt.Orientation.Horizontal, self)
        self.nav_bu = QPushButton("Navigate", self)
        self.nav_bu.clicked.connect(lambda: self.navigate_to_index(self.the_table.currentIndex()))
        self.nav_bu.setEnabled(False)
        buttons.addButton(self.nav_bu, QDialogButtonBox.ButtonRole.ApplyRole)
        buttons.accepted.connect(self.reject)
        buttons.rejected.connect(self.reject)
        ly.addWidget(buttons)

        self.setWindowTitle('Aranges')
        self.setLayout(ly)

    def on_sel(self, index, prev = None):
        self.nav_bu.setEnabled(index.isValid())

    def navigate_to_index(self, index):
        row = index.row()
        self.selected_cu_offset = self.the_table.model().values[row][-1]
        self.done(QDialog.DialogCode.Accepted)

```

`dwex/cookie.py`:

```py
cookie=False 

```

`dwex/crash.py`:

```py
import hashlib, urllib, random, string, traceback, sys, os, platform
from urllib.request import urlopen
# No dependencies on the rest of the app, and keep it that way

_binary_desc = None

def set_binary_desc(s):
    global _binary_desc
    _binary_desc = s

def submit_report(subj, body):
    try:
        secret = "jkaweliop3jka;lswmn12"
        chars = string.ascii_letters + string.digits
        id = ''.join(random.choice(chars) for x in range(50))
        h = hashlib.sha1()
        h.update((id + secret).encode('utf-8'))
        reqdata = {'to': "support@yarxi.ru",
		        'from': "\"DWEX\"<support@yarxi.ru>",
		        'subj': subj,
		        'body': body,
		        'id': id,
		        'hash': h.digest().hex()}
        reqdata = urllib.parse.urlencode(reqdata).encode('utf-8')
        urlopen('http://yarxi.ru/mobile/mail.php', reqdata).info()
    except Exception as exc:
        pass

def get_crash_die(locals):
    if "self" in locals and hasattr(locals['self'], 'die'):
        return locals['self'].die
    elif "die" in locals:
        return locals['die']
    else:
        return False

def get_crash_die_context(locals, ctxt = None):
    s = ''
    try:
        crash_die = get_crash_die(locals)
        if not crash_die and ctxt:
            crash_die = get_crash_die(ctxt)
        if crash_die:
            top = crash_die.cu.get_top_DIE()
            if top:
                if 'DW_AT_language' in top.attributes:
                    s += "Source language: 0x%x\n" % (top.attributes['DW_AT_language'].value,)
                if 'DW_AT_producer' in top.attributes:
                    s += "Producer: %s\n" % (top.attributes['DW_AT_producer'].value.decode('utf-8', errors='ignore'),)
    except:
        pass
    return s

def make_exc_report(exc, tb, version, catchpoint, ctxt=None):
    global _binary_desc
    tracebacks = []
    while tb.tb_next:
        tracebacks.insert(0, tb) # Innermost in the beginning of the list
        tb = tb.tb_next
    ss = traceback.extract_tb(tb)
    innermost_stack = traceback.extract_stack(tb.tb_frame)
    crashpoint = ss[0]
    locals = tb.tb_frame.f_locals

    report = type(exc).__name__ + ' at ' + os.path.basename(crashpoint.filename) + ':' + str(crashpoint.lineno) + "\n"
    if catchpoint:
        from inspect import getframeinfo
        fi = getframeinfo(catchpoint)
        report += "Caught %s@%s:%d\n" % (fi.function, os.path.basename(fi.filename), fi.lineno)
    report += "DWEX " + '.'.join(str(v) for v in version) + "\n"
    report += "Python " + sys.version + "\n"
    report += "System: " + platform.platform() + "\n"
    try:
        import elftools
        if hasattr(elftools, '__version__'):
            report += "Pyelftools: " + elftools.__version__ + "\n"
    except ImportError:
        pass
    if _binary_desc:
        report += "Binary: " + _binary_desc + "\n"
    try:
        from .cookie import cookie
    except ImportError:
        cookie = False
    if cookie:
        report += "Cookie: " + cookie + "\n"
    report += get_crash_die_context(locals, ctxt=ctxt)
    report += "".join(traceback.format_exception_only(type(exc), exc)) + "\n"

    report += "PyStack_v3:\n"
    def module_prefix(se):
        p = os.path.dirname(se.filename).split(os.path.sep)
        if 'elftools' in p:
            return 'pyelftools/'
        elif 'dwex' in p:
            return 'dwex/'
        return ''
    def make_stackline(se):
        return se.name + '@' + module_prefix(se) + os.path.basename(se.filename) + ':' + str(se.lineno) + "\n"
    def make_stack_dump(stack):
        return [make_stackline(se) for se in stack[::-1]]
    def make_traceback_dump(tb):
        return "-\n"+"".join(make_stack_dump(traceback.extract_stack(tb.tb_frame)))

    report += "".join(make_stack_dump(innermost_stack))
    # More tracebacks
    report += "".join(make_traceback_dump(tb) for tb in tracebacks[1:])
    report += "\n"

    report += "PyLocals:\n" + ''.join(k + ": " + str(locals[k]) + "\n" for k in locals).replace("\n\n","\n")

    if ctxt:
        report += "\nPyContext:\n" + ''.join(k + ": " + str(ctxt[k]) + "\n" for k in ctxt).replace("\n\n","\n")

    return report

def report_crash(exc, tb, version, catchpoint = None, ctxt=None):
    try:
        subj = '[python][dwex][pyexception]'
        if not catchpoint:
            subj += '[crash]'
        submit_report(subj, make_exc_report(exc, tb, version, catchpoint, ctxt=ctxt))
    except Exception:
        pass

if __name__ == "__main__":
    try:
        def bar():
            i=0
            a=1
            a /=i

        def foo():
            bar()

        foo()
    except Exception as exc:
        from inspect import currentframe
        report_crash(exc, exc.__traceback__, (0, 50), currentframe())

```

`dwex/details.py`:

```py
from PyQt6.QtCore import Qt, QAbstractTableModel
from .fx import fixed_font

class GenericTableModel(QAbstractTableModel):
    """ The index internal object is the row
        The column count is driven by headers - OK to piggyback extra data in values' rows
    """
    def __init__(self, headers, values, warning = None, get_tooltip = None):
        QAbstractTableModel.__init__(self)
        self.headers = headers
        self.values = tuple(values)
        self.warning = warning
        self.get_tooltip = get_tooltip

    def headerData(self, section, ori, role):
        if ori == Qt.Orientation.Horizontal and role == Qt.ItemDataRole.DisplayRole:
            return self.headers[section]

    def rowCount(self, parent):
        return len(self.values)

    def columnCount(self, parent):
        return len(self.headers)
    
    def index(self, row, col, parent):
        return self.createIndex(row, col, self.values[row])

    def data(self, index, role):
        if role == Qt.ItemDataRole.DisplayRole:
            return index.internalPointer()[index.column()]
        elif role == Qt.ItemDataRole.ToolTipRole:
            if self.get_tooltip:
                return self.get_tooltip(index.row(), index.column(), index.internalPointer())

class FixedWidthTableModel(GenericTableModel):
    def __init__(self, headers, values):
        super().__init__(headers, values)

    def data(self, index, role):
        if role == Qt.ItemDataRole.FontRole:
            return fixed_font()
        else:
            return super().data(index, role)
```

`dwex/die.py`:

```py
from bisect import bisect_right
from collections.abc import Sequence
from PyQt6.QtCore import Qt, QAbstractTableModel, QModelIndex
from elftools.dwarf.locationlists import LocationParser, LocationExpr
from elftools.dwarf.dwarf_expr import DWARFExprParser, DWARFExprOp
from elftools.dwarf.descriptions import _DESCR_DW_LANG, _DESCR_DW_ATE, _DESCR_DW_ACCESS, _DESCR_DW_INL, _DESCR_DW_CC
from elftools.common.exceptions import ELFParseError

from .exprutil import ExprFormatter, is_parsed_expression
from .dwarfone import DWARFExprParserV1
from .dwarfutil import *
from .details import GenericTableModel, FixedWidthTableModel
from .exprdlg import ExpressionTableModel, ExpressionDlg, op_has_nested_expression
from .fx import blue_brush, ltgrey_brush

MAX_INLINE_BYTEARRAY_LEN = 32

def is_long_blob(attr):
    val = attr.value
    return ((isinstance(val, bytes) and attr.form not in ('DW_FORM_strp', 'DW_FORM_string')) or is_int_list(val)) and len(val) > MAX_INLINE_BYTEARRAY_LEN

class ExprParseError(Exception):
    expr = None
    opcode = None

#------------------------------------------------
# DIE formatter
#------------------------------------------------

_ll_headers = ("Attribute", "Offset", "Form", "Raw", "Value")
_noll_headers = ("Attribute", "Form", "Value")
_meta_desc = ('DIE offset', 'DIE size', 'Abbrev code', 'Has children') # Anything else?
_meta_count = 4 # Extra rows if low level detail showing is set

class DIETableModel(QAbstractTableModel):
    def __init__(self, die, prefix, lowlevel, hex, regnames):
        QAbstractTableModel.__init__(self)
        self.prefix = prefix
        self.lowlevel = lowlevel
        self.hex = hex
        self.regnames = regnames
        self.die = die
        self.attributes = die.attributes
        self.keys = list(die.attributes.keys())
        self.headers = _ll_headers if self.lowlevel else _noll_headers
        self.meta_count = _meta_count if lowlevel else 0
        self.expr_formatter = ExprFormatter(regnames, prefix, die.dwarfinfo.config.machine_arch, die.cu['version'], hex)
        self.expr_formatter.cfa_resolver = self.resolve_cfa

    from .ranges import show_ranges
    from .locs import parse_location, show_location, show_loclist, resolve_cfa

    def headerData(self, section, ori, role):
        if ori == Qt.Orientation.Horizontal and role == Qt.ItemDataRole.DisplayRole:
            return self.headers[section]

    def rowCount(self, parent):
        return len(self.keys) + self.meta_count

    def columnCount(self, parent):
        return len(self.headers)

    def data(self, index, role):
        row = index.row()
        return self.attr_data(index, role) if row >= self.meta_count else self.meta_data(index, role)
    
    # End of Qt callbacks

    # Flavors of data() - attribute and metadata

    def attr_data(self, index, role):
        irow = index.row()
        meta_count = self.meta_count
        self_keys_len = len(self.keys)
        self_die_keys_len = len(self.die.attributes.keys())

        if irow >= meta_count + self_keys_len: # Shorting out 1530
            return None
                
        row = index.row() - self.meta_count
        key = self.keys[row]
        attr = self.attributes[key]
        if role == Qt.ItemDataRole.DisplayRole:
            col = index.column()
            if col == 0:
                # Unknown keys come across as ints
                return self.format_attr_name(key)
            elif col == 1:
                return hex(attr.offset) if self.lowlevel else self.format_form(attr.form)
            elif col == 2:
                return self.format_form(attr.form) if self.lowlevel else self.format_value(attr)
            elif col == 3:
                return self.format_raw(attr) if self.lowlevel else self.format_value(attr)
            elif col == 4:
                return self.format_value(attr)
        elif role == Qt.ItemDataRole.ToolTipRole:
            tip = ''
            if attr.form in ('DW_FORM_ref', 'DW_FORM_ref1', 'DW_FORM_ref2', 'DW_FORM_ref4', 'DW_FORM_ref8', 'DW_FORM_ref_addr'):
                rt = self.ref_target_from_attr(attr)
                if rt: 
                    (target_cu, target_offset) = rt
                    target = target_cu.get_DIE_from_refaddr(target_offset)
                    if target and not target.is_null():
                        tip = self.format_tag(target.tag) + ' ' + safe_DIE_name(target, '(unknown)') + '\n'
                tip += "Double-click to follow"
            elif attr.form in ('DW_FORM_ref_sig8', 'DW_FORM_ref_sup4', 'DW_FORM_ref_sup8'):
                tip += "Unsupported reference format"
            elif is_long_blob(attr):
                tip += "Click to see it all"
            return tip
        elif role == Qt.ItemDataRole.ForegroundRole:
            if attr.form in ('DW_FORM_ref', 'DW_FORM_ref1', 'DW_FORM_ref2', 'DW_FORM_ref4', 'DW_FORM_ref8', 'DW_FORM_ref_addr'):
                return blue_brush
        elif role == Qt.ItemDataRole.BackgroundRole:
            if self.lowlevel and index.column() == 3 and attr.raw_value == attr.value:
                return ltgrey_brush                

    # Data for the metadata lines - ones that are not attributes
    def meta_data(self, index, role):
        row = index.row()
        if role == Qt.ItemDataRole.DisplayRole:
            col = index.column()
            if col == 0:
                return _meta_desc[row]
            elif col == (4 if self.lowlevel else 2):
                if row == 0:
                    return hex(self.die.offset)
                if row == 1: # Should this be always hex? Not sure...
                    return hex(self.die.size) if self.hex else str(self.die.size)
                elif row == 2: # Hex makes no sense here
                    return str(self.die.abbrev_code)                    
                elif row == 3:
                    return str(self.die.has_children)
        elif role == Qt.ItemDataRole.BackgroundRole:
            return ltgrey_brush
        
    def parse_expr(self, expr):
        """expr is a blob
        """
        if self.die.cu._exprparser is None:
            self.die.cu._exprparser = DWARFExprParser(self.die.cu.structs) if self.die.cu['version'] > 1 else DWARFExprParserV1(self.die.cu.structs)
        try:
            return self.die.cu._exprparser.parse_expr(expr)
        except KeyError as ke:
            pe = ExprParseError()
            pe.expr = expr
            pe.opcode = ke.args[0]
            raise pe
    
    def format_op(self, op):
        return self.expr_formatter.format_op(*op)
    
    def format_expr(self, expr, len_cutoff = None):
        """expr is a list of parsed operations
        """
        if len_cutoff is not None and len(expr) > len_cutoff:
            return '; '.join(self.format_op(op) for op in expr[:len_cutoff]) + f'...+{len(expr)-len_cutoff} more'
        else:
            return '; '.join(self.format_op(op) for op in expr)

    # Expr is an expression blob
    # Returns a list of strings for ops
    # Format: op arg, arg...
    def dump_expr(self, expr, len_cutoff = None):
        """expr is a blob"""
        # Challenge: for nested expressions, args is a list with a list of commands
        # For those, the format is: op {op arg, arg; op arg, arg}
        # Can't just check for iterable, str is iterable too
        return self.format_expr(self.parse_expr(expr), len_cutoff)
    
    # Big DIE attribute value interpreter for the top right table
    def format_value(self, attr):
        try:
            die = self.die
            cu = self.die.cu
            header = self.die.cu.header
            dwarf_version = self.die.cu.header.version

            key = attr.name
            val = attr.value
            form = attr.form
            if form == 'DW_FORM_addr' and isinstance(val, int):
                return hex(val)
            elif form == 'DW_FORM_flag_present':
                return 'True'
            elif form in ('DW_FORM_ref0', 'DW_FORM_ref1', 'DW_FORM_ref2', 'DW_FORM_ref4', 'DW_FORM_ref8', 'DW_FORM_ref_addr'):
                return "Ref: 0x%x" % val # There are several other reference forms in the spec
            elif form == 'DW_FORM_flag':
                return str(bool(val))
            elif LocationParser.attribute_has_location(attr, self.die.cu['version']):
                ll = self.parse_location(attr)
                if ll is None:
                    return "(parse error - please report at github.com/sevaa/dwex)"
                elif isinstance(ll, LocationExpr):
                    return self.dump_expr(ll.loc_expr)
                else:
                    return "Loc list: 0x%x" % attr.value
            elif key == 'DW_AT_language':
                return "%d %s" % (val, _DESCR_DW_LANG[val]) if val in _DESCR_DW_LANG else val
            elif key == 'DW_AT_encoding':
                return "%d %s" % (val, _DESCR_DW_ATE[val]) if val in _DESCR_DW_ATE else val
            elif key == 'DW_AT_accessibility':
                return "%d %s" % (val, _DESCR_DW_ACCESS[val]) if val in _DESCR_DW_ACCESS else val
            elif key == 'DW_AT_inline':
                return "%d %s" % (val, _DESCR_DW_INL[val]) if val in _DESCR_DW_INL else val
            elif key == 'DW_AT_calling_convention':
                return "%d %s" % (val, _DESCR_DW_CC[val]) if val in _DESCR_DW_CC else val
            elif key in ('DW_AT_decl_file', 'DW_AT_call_file'):
                cu = self.die.cu
                if cu._lineprogram is None:
                    cu._lineprogram = self.die.dwarfinfo.line_program_for_CU(cu)
                if cu._lineprogram:
                    if cu._lineprogram.header.version >= 5:
                        filename = cu._lineprogram.header.file_entry[val].name.decode('utf-8', errors='ignore') if cu._lineprogram and val >= 0 and val < len(cu._lineprogram.header.file_entry) else '(N/A)'
                    else:
                        if val == 0:
                            filename = safe_DIE_name(cu.get_top_DIE(), 'N/A')
                        else:
                            filename = cu._lineprogram.header.file_entry[val-1].name.decode('utf-8', errors='ignore') if cu._lineprogram and val > 0 and val <= len(cu._lineprogram.header.file_entry) else '(N/A)'
                    return "%d: %s" % (val,  filename)
                else: # Lineprogram not found in the top DIE - how's that possible?
                    return "%d (no lineprogram found)" % (val,)
            elif key == 'DW_AT_stmt_list':
                return 'LNP at 0x%x' % val
            elif key in ('DW_AT_upper_bound', 'DW_AT_lower_bound') and is_block(form):
                return self.dump_expr(val)
            elif isinstance(val, bytes):
                if form in ('DW_FORM_strp', 'DW_FORM_string', 'DW_FORM_line_strp', 'DW_FORM_strp_sup',
                    'DW_FORM_strx', 'DW_FORM_strx1', 'DW_FORM_strx2', 'DW_FORM_strx3', 'DW_FORM_strx4'):
                    return val.decode('utf-8', errors='ignore')
                elif val == b'': # What's a good value for a blank blob?
                    return '[]'
                elif len(val) > MAX_INLINE_BYTEARRAY_LEN:
                    return ' '.join("%02x" % b for b in val[0:MAX_INLINE_BYTEARRAY_LEN]) + ("...(%s bytes)" % (('0x%x' if self.hex else '%d') % len(val)))
                else:
                    return ' '.join("%02x" % b for b in val) # Something like "01 ff 33 55"
            elif isinstance(val, list): # block1 comes across as this
                if val == []:
                    return '[]'
                elif isinstance(val[0], int): # Assuming it's a byte array diguised as int array
                    if len(val) > MAX_INLINE_BYTEARRAY_LEN:
                        return ' '.join("%02x" % b for b in val[0:MAX_INLINE_BYTEARRAY_LEN]) + ("...(%s bytes)" % (('0x%x' if self.hex else '%d') % len(val)))
                    else:
                        return ' '.join("%02x" % b for b in val)
                else: # List of something else
                    return str(val)
            else:
                return hex(val) if self.hex and isinstance(val, int) else str(val)
        # except BaseException as exc:
        except ExprParseError as exc: # Shorting out #1740
            from .__main__ import version
            from .crash import report_crash
            from inspect import currentframe
            ctxt = {'attr': attr,
                        'die': die,
                        'dwarf_version': dwarf_version,
                        'opcode': exc.opcode,
                        'expr': ' '.join(f'{b:02X}' for b in exc.expr)}
            report_crash(exc, exc.__traceback__, version, currentframe(), ctxt)
            return f"(unknown expression opcode 0x{exc.opcode:02X})"
        except ELFParseError as exc:
            import sys
            if not sys.gettrace():
                from .__main__ import version
                from .crash import report_crash
                from inspect import currentframe
                tb = exc.__traceback__
                di = die.cu.dwarfinfo
                file_addr_size = di.config.default_address_size
                loc_section = di.debug_loclists_sec if dwarf_version >= 5 else di.debug_loc_sec
                loc_sec_len = len(loc_section.stream.getbuffer()) if loc_section else None
                ctxt = {'attr': attr,
                        'die': die,
                        'cu_header': header,
                        'file_addr_size': file_addr_size,
                        'dwarf_version': dwarf_version,
                        'sec_size': loc_sec_len}
                report_crash(exc, tb, version, currentframe(), ctxt)
            return "(parse error - please report at github.com/sevaa/dwex)"

    def format_form(self, form):
        return form if self.prefix or not str(form).startswith('DW_FORM_') else form[8:]

    def format_raw(self, attr):
        val = attr.raw_value
        if val == attr.value:
            return "(same)"
        elif isinstance(val, int):
            return hex(val) if self.hex else str(val)
        elif isinstance(val, bytes) or (isinstance(val, list) and len(val) > 0 and isinstance(val[0], int)):
            return ' '.join("%02x" % b for b in val) if len(val) > 0 else '[]'
        else:
            return str(val)

    def display_DIE(self, die):
        rows_was = len(self.keys) + self.meta_count
        self.die = die
        self.attributes = die.attributes
        self.keys = list(die.attributes.keys())
        # Should not be ever possible, but this code is here
        self.expr_formatter.set_arch(die.dwarfinfo.config.machine_arch)
        self.expr_formatter.dwarf_version = die.cu['version']
        rows_now = self.meta_count + len(self.keys)
        if rows_was < rows_now:
            self.rowsInserted.emit(QModelIndex(), rows_was, rows_now-1)
        elif rows_was > rows_now:
            self.rowsRemoved.emit(QModelIndex(), rows_now, rows_was-1)
        self.dataChanged.emit(self.createIndex(0, 0), self.createIndex(rows_now - 1, len(self.headers)-1))

    def set_prefix(self, prefix):
        if prefix != self.prefix:
            self.prefix = prefix
            self.expr_formatter.prefix = prefix
            self.refresh_values()

    # Index is the current selected index
    # Returns the new selected index, if there was one
    def set_lowlevel(self, lowlevel, index):
        if lowlevel != self.lowlevel:
            self.lowlevel = lowlevel
            self.headers = _ll_headers if self.lowlevel else _noll_headers
            new_index = None
            if lowlevel:
                self.beginInsertColumns(QModelIndex(), 2, 3)
                self.endInsertColumns()
                self.meta_count = _meta_count
                self.rowsInserted.emit(QModelIndex(), 0, self.meta_count - 1)
                if index.isValid(): # Shift the selection two down
                    new_index = self.createIndex(index.row() + self.meta_count, 0)
            else:
                meta_count_was = self.meta_count # Allows for meta_count to be dependent on DIE
                self.beginRemoveColumns(QModelIndex(), 2, 3)
                self.endRemoveColumns()
                self.meta_count = 0
                self.rowsRemoved.emit(QModelIndex(), 0, meta_count_was - 1)
                if index.isValid() and index.row() >= meta_count_was: # Shift the selection down
                    new_index = self.createIndex(index.row() - meta_count_was, 0)
                else:
                    new_index = QModelIndex() # Select none
        return new_index

    # Force a reload of values on the whole table without row/column count change
    def refresh_values(self):
        self.dataChanged.emit(self.createIndex(0, 0), self.createIndex(self.meta_count + len(self.keys)-1, len(self.headers)-1))

    def set_hex(self, hex):
        if hex != self.hex:
            self.hex = hex
            self.refresh_values()

    def set_regnames(self, regnames):
        if regnames != self.regnames:
            self.regnames = regnames
            self.expr_formatter.regnames = regnames
            self.refresh_values()

    # Returns a table model for the attribute details table
    # For attributes that refer to larger data structures (ranges, locations), makes sense to spell it out into a table
    # Row is metadata unaware
    def get_attribute_details(self, index):
        row = index.row()
        if row >= self.meta_count:
            row -= self.meta_count
            key = self.keys[row]
            attr = self.attributes[key]
            form = attr.form
            if key == "DW_AT_ranges":
                return self.show_ranges(attr)
            elif LocationParser.attribute_has_location(attr, self.die.cu['version']):
                return self.show_location(attr)
            elif key == 'DW_AT_stmt_list':
                if self.die.cu._lineprogram is None:
                    self.die.cu._lineprogram = self.die.dwarfinfo.line_program_for_CU(self.die.cu)
                lpe = self.die.cu._lineprogram.get_entries()
                files = self.die.cu._lineprogram.header.file_entry
                ver5 = self.die.cu._lineprogram.header.version >= 5
                def_file = safe_DIE_name(self.die.cu.get_top_DIE(), 'N/A')
                def format_state(state):
                    filename = 'N/A'
                    if ver5:
                        if state.file >= 0 and state.file < len(files):
                            filename = files[state.file].name.decode('utf-8', errors='ignore')
                    else:
                        if state.file == 0:
                            filename = def_file
                        elif state.file >= 1 and state.file <= len(files):
                            filename = files[state.file-1].name.decode('utf-8', errors='ignore')
                    return (hex(state.address),
                        filename,
                        state.line,
                        'Y' if state.is_stmt  else '',
                        'Y' if state.basic_block else '',
                        'Y' if state.end_sequence else '',
                        'Y' if state.prologue_end else '',
                        'Y' if state.epilogue_begin else '')
                states = [format_state(e.state) for e in lpe if e.state]
                # TODO: low level flavor with extra details
                # TODO: commands vs states
                return GenericTableModel(('Address', 'File', 'Line', 'Stmt', 'Basic block', 'End seq', 'End prologue', 'Begin epilogue'), states)
            elif key in ('DW_AT_upper_bound', 'DW_AT_lower_bound') and is_block(form):
                return ExpressionTableModel(self.parse_expr(attr.value), self.expr_formatter)
            elif is_long_blob(attr):
                val = attr.value
                def format_line(off):
                    offs = ("0x%x" if self.hex else "%d") % off
                    return (offs, ' '.join("%02x" % b for b in val[off:off+MAX_INLINE_BYTEARRAY_LEN]))
                lines = [format_line(off) for off in range(0, len(val), MAX_INLINE_BYTEARRAY_LEN)]
                return FixedWidthTableModel(('Offset (%s)' % ('hex' if self.hex else 'dec'), 'Bytes'), lines)
        return None
    
    def ref_target_from_attr(self, attr):
        val = attr.value
        form = attr.form
        if form in ('DW_FORM_ref1', 'DW_FORM_ref2', 'DW_FORM_ref4', 'DW_FORM_ref8'):
            return (self.die.cu, attr.value + self.die.cu.cu_offset)
        elif form in ('DW_FORM_ref_addr', 'DW_FORM_ref'):
            cualen = len(self.die.cu.dwarfinfo._unsorted_CUs)
            i = bisect_right(self.die.cu.dwarfinfo._CU_offsets, val) - 1
            cu = self.die.cu.dwarfinfo._unsorted_CUs[i]
            return (cu, attr.value)

    # Returns (cu, die_offset) or None if not a navigable
    def ref_target(self, index):
        try:  # Any chance for "not found"? Probably bug #1450, #1450
            row = index.row()
            if row >= self.meta_count:
                attr_name = self.keys[row - self.meta_count]
                attr = self.attributes[attr_name]
                return self.ref_target_from_attr(attr)
        except IndexError as exc:
            from .__main__ import version
            from .crash import report_crash
            from inspect import currentframe
            tb = exc.__traceback__
            report_crash(exc, tb, version, currentframe())
            return None
        
    def format_attr_name(self, key):
        return key if self.prefix or not str(key).startswith('DW_AT_') else key[6:]
    
    def format_tag(self, tag):
        return tag if self.prefix or not str(tag).startswith('DW_TAG_') else tag[7:]

def on_details_row_dclick(index, o, win):
    # For now, used for drilling into DWARF expressions
    if isinstance(o, DWARFExprOp) and op_has_nested_expression(o):
        ExpressionDlg(win, 'Nested expression', o.args[0], win.expr_formatter()).exec()
    elif isinstance(o, Sequence) and is_parsed_expression(o[-1]):
        ExpressionDlg(win, 'Expression', o[-1], win.expr_formatter()).exec()



```

`dwex/dwarfone.py`:

```py
# Support for DWARF v1.1 in a way that will be more or less compatible with pyelftools

from io import BytesIO
from collections import OrderedDict, namedtuple
from bisect import bisect_left
from elftools.dwarf.dwarfinfo import DwarfConfig, DebugSectionDescriptor
from elftools.dwarf.die import AttributeValue
from elftools.dwarf.structs import DWARFStructs
from elftools.common.utils import struct_parse, bytelist2string
from elftools.dwarf.enums import ENUM_DW_TAG, ENUM_DW_AT, ENUM_DW_FORM
from elftools.construct import CString
from elftools.dwarf.lineprogram import LineProgramEntry, LineState
from elftools.dwarf.dwarf_expr import DWARFExprOp

LineTableHeader = namedtuple('LineTableHeader', 'version file_entry')
CUv1Header = namedtuple('CUv1Header', 'version unit_length debug_abbrev_offset address_size')

TAG_reverse = dict((v, k) for k, v in ENUM_DW_TAG.items())
ATTR_reverse = dict((v, k) for k, v in ENUM_DW_AT.items())
FORM_reverse = dict((v, k) for k, v in ENUM_DW_FORM.items())

DW_OP_name2opcode = dict(
    DW_OP_reg = 0x01,
    DW_OP_basereg = 0x02,
    DW_OP_addr = 0x03,
    DW_OP_const = 0x04,
    DW_OP_deref2 = 0x05,
    DW_OP_deref = 0x06,
    DW_OP_deref4 = 0x06,
    DW_OP_add = 0x07,
    DW_OP_user_0x80 = 0x80 #Extension op, not sure what's the deal with that
)

DW_OP_opcode2name = dict((v, k) for k, v in DW_OP_name2opcode.items())

class DIEV1(object):
    def __init__(self, stm, cu, di):
        self.cu = cu
        self.dwarfinfo = di
        self.stream = stm
        self.offset = stm.tell()
        self.attributes = OrderedDict()
        self.tag = None
        self.has_children = None
        self.abbrev_code = None
        self.size = 0
        # Null DIE terminator. It can be used to obtain offset range occupied
        # by this DIE including its whole subtree.
        self._terminator = None
        self._parent = None

        structs = self.dwarfinfo.structs
        self.size = struct_parse(structs.Dwarf_uint32(''), stm)
        # Size 8+  can be padding if the tag is 0. No attributes in those.
        # DW_TAG_null and DW_TAG_padding are both code zero
        if self.size < 8:
            self.tag = 'DW_TAG_null' # Null terminates the sibling chain
            self.has_children = False
        else:
            tag_code = struct_parse(structs.Dwarf_uint16(''), stm)
            # Do what pyelftools does, leave tag as int if unknown
            self.tag = TAG_reverse[tag_code] if tag_code in TAG_reverse else tag_code 
            if self.tag == 'DW_TAG_null': # TAG_padding in DWARF1 spec
                self.tag == 'DW_TAG_padding' #Doesn't count for is_null
                # No attributes, just advance the stream
                stm.seek(self.size-6, 1)
                self.has_children = False
            else:
                while stm.tell() < self.offset + self.size:
                    attr_offset = self.stream.tell()
                    attr = struct_parse(structs.Dwarf_uint16(''), stm)
                    form = FORM_reverse[attr & 0xf]
                    attr >>= 4
                    if attr in ATTR_reverse:
                        name = ATTR_reverse[attr]
                    elif 0x200 <= attr <= 0x3ff: #DW_AT_MIPS represented as 0x204???
                        name = 'DW_AT_user_0x%x' % attr
                    else: # Do what pyelftools does, leave tag as int if unknown
                        name = attr

                    raw_value = struct_parse(structs.Dwarf_dw_form[form], stm)
                    value = raw_value

                    self.attributes[name] = AttributeValue(
                        name=name,
                        form=form,
                        value=value,
                        raw_value=raw_value,
                        offset=attr_offset,
                        indirection_length = 0)
                self.has_children = self.attributes['DW_AT_sibling'].value >= self.offset + self.size + 8

    def get_parent(self):
        return self._parent

    def is_null(self):
        return self.tag == 'DW_TAG_null'

    def iter_children(self):
        return self.cu.iter_children(self)

    def sibling(self):
        return self.attributes['DW_AT_sibling'].value

class CompileUnitV1(object):
    def __init__(self, di, top_die):
        self.dwarfinfo = di
        self.structs = di.structs
        end_offset = top_die.attributes['DW_AT_sibling'].value
        self.header = CUv1Header(version = 1, unit_length = end_offset - top_die.offset, debug_abbrev_offset = None, address_size = 4)
        self._dielist = [top_die]
        self._diemap = [top_die.offset]
        # For compatibility with v2+ CU
        self.cu_offset = top_die.offset
        self.cu_die_offset = top_die.offset

    def get_top_DIE(self):
        return self._dielist[0]

    def __getitem__(self, name):
        return self.header._asdict()[name]
    
    @property
    def size(self):
        return self.header.unit_length # No CU header here

    # Caches
    def DIE_at_offset(self, offset):
        i = bisect_left(self._diemap, offset)
        if i < len(self._diemap) and offset == self._diemap[i]:
            die = self._dielist[i]
        else:
            die = self.dwarfinfo.DIE_at_offset(offset, self)
            self._dielist.insert(i, die)
            self._diemap.insert(i, offset)
        return die

    # pyelftools' iter_DIEs sets parent on discovered DIEs, we should too
    def iter_DIEs(self):
        offset = self.cu_offset
        parent = None
        parent_stack = list()
        end_offset = self.get_top_DIE().attributes['DW_AT_sibling'].value
        # Dump the whole section into locals to catch 1610
        if end_offset - offset <= 4096:
            stm = self.dwarfinfo.stm
            stm.seek(offset, 0)
            import base64
            section_dump = base64.encodebytes(stm.read(end_offset - offset)).decode('ASCII')
        while offset < end_offset:
            die = self.DIE_at_offset(offset)

            if die._parent is None:
                die._parent = parent

            if not die.is_null():
                yield die
                offset += die.size
                if offset != die.sibling(): # Start of a subtree
                    parent_stack.append(parent)
                    parent = die
            else: # null - end of a sibling chain
                # Catching 1610
                size = die.size
                tag = die.tag
                parent = parent_stack.pop() # Throws IndexError
                offset += die.size
            prev_die_tag = die.tag

    def iter_children(self, parent_die):
        offset = parent_die.offset + parent_die.size
        parent_sibling_offset = parent_die.attributes['DW_AT_sibling'].value if 'DW_AT_sibling' in parent_die.attributes else None
        section_size = self.dwarfinfo.section_size
        while offset < section_size:
            die = self.DIE_at_offset(offset)

            if die._parent is None:
                die._parent = parent_die
            if not die.is_null():
                yield die
                # Troubleshooting #1497
                
                tag = die.tag
                attr = die.attributes
                off = die.offset
                size = die.size
                has_children = die.has_children
                offset = die.attributes['DW_AT_sibling'].value # will throw KeyError if none
                prev_die = die
                #offset = die.sibling()
            else:
                break
            
    def iter_DIE_children(self, die):
        if not die.has_children:
            return
        
        # `cur_offset` tracks the stream offset of the next DIE to yield
        # as we iterate over our children,
        cur_offset = die.offset + die.size

        while True:
            child = self.DIE_at_offset(cur_offset)

            if child._parent is None:
                child._parent = die

            if child.is_null():
                die._terminator = child
                return

            yield child

            if not child.has_children:
                cur_offset += child.size
            elif "DW_AT_sibling" in child.attributes:
                sibling = child.attributes["DW_AT_sibling"]
                if sibling.form == 'DW_FORM_ref':
                    cur_offset = sibling.value
                else:
                    raise NotImplementedError('sibling in form %s' % sibling.form)
            else:
                # If no DW_AT_sibling attribute is provided by the producer
                # then the whole child subtree must be parsed to find its next
                # sibling. There is one zero byte representing null DIE
                # terminating children list. It is used to locate child subtree
                # bounds.

                # If children are not parsed yet, this instruction will manage
                # to recursive call of this function which will result in
                # setting of `_terminator` attribute of the `child`.
                if child._terminator is None:
                    for _ in self.iter_DIE_children(child):
                        pass

                cur_offset = child._terminator.offset + child._terminator.size

    def get_DIE_from_refaddr(self, refaddr):
        return self.DIE_at_offset(refaddr)

class LineTableV1(object):
    def __init__(self, stm, structs, len, pc):
        self.stm = stm
        self.structs = structs
        self.len = len
        self.pc = pc
        self._decoded_entries = None
        self.header = LineTableHeader(1, (None))

    def get_entries(self):
        if self._decoded_entries is None:
            stm = self.stm
            offset = stm.tell()
            end_offset = offset + self.len
            structs = self.structs
            entries = []
            pc = self.pc
            while offset < end_offset:
                line = struct_parse(structs.Dwarf_uint32(''), stm)
                col = struct_parse(structs.Dwarf_uint16(''), stm)
                pc_delta = struct_parse(structs.Dwarf_uint32(''), stm)
                if line == 0:
                    break
                state = LineState(True)
                state.file = 0
                state.line = line
                state.column = col if col != 0xffff else None
                state.address = pc
                entries.append(LineProgramEntry(0, False, [], state))
                pc += pc_delta
            self._decoded_entries = entries
        return self._decoded_entries
    
    def __getitem__(self, name):
        return self.header[name]

class DWARFExprParserV1(object):
    def __init__(self, structs):
        self.structs = structs
        
    def parse_expr(self, expr):
        stm = BytesIO(bytelist2string(expr))
        parsed = []

        while True:
            # Get the next opcode from the stream. If nothing is left in the
            # stream, we're done.
            byte = stm.read(1)
            if len(byte) == 0:
                break

            # Decode the opcode and its name.
            op = ord(byte)
            op_name = DW_OP_opcode2name.get(op, 'OP:0x%x' % op)

            if op <= 4 or op == 0x80:
                args = [struct_parse(self.structs.Dwarf_target_addr(''), stm),]
            else:
                args = []

            parsed.append(DWARFExprOp(op=op, op_name=op_name, args=args, offset=stm.tell()))

        return parsed

class DWARFInfoV1(object):
    def __init__(self, elffile):
        section = elffile.get_section_by_name(".debug")
        section_data = section.data()
        # TODO: relocation? Compression?
        self.section_size = len(section_data)
        self.stm = BytesIO(section_data)

        lsection = elffile.get_section_by_name(".line")
        if lsection:
            self.linestream = BytesIO(lsection.data())
        # Sections .debug_pubnames, .debug_aranges also in the spec -
        # those are indices into info, we ignore them

        self.config = DwarfConfig(
            little_endian = elffile.little_endian,
            default_address_size = elffile.elfclass // 8,
            machine_arch = elffile.get_machine_arch()
        )

        self.structs = DWARFStructs(
            little_endian = self.config.little_endian,
            dwarf_format = 32,
            address_size = self.config.default_address_size)

    def iter_CUs(self):
        offset = 0
        while offset < self.section_size:
            die = self.DIE_at_offset(offset, None)
            if not die.is_null():
                if die.cu is None:
                    die.cu = cu = CompileUnitV1(self, die)
                    cu.cu_offset = offset
                yield die.cu
                offset = die.attributes['DW_AT_sibling'].value
            else:
                break

    # Does not cache
    def DIE_at_offset(self, offset, cu):
        self.stm.seek(offset, 0)
        return DIEV1(self.stm, cu, self)

    def location_lists(self):
        return None

    def line_program_for_CU(self, cu):
        top_DIE = cu.get_top_DIE()
        if 'DW_AT_stmt_list' in top_DIE.attributes:
            stm = self.linestream
            stm.seek(top_DIE.attributes['DW_AT_stmt_list'].value, 0)
            structs = self.structs
            len = struct_parse(structs.Dwarf_uint32(''), stm)
            pc = struct_parse(structs.Dwarf_target_addr(''), stm)
            return LineTableV1(stm, structs, len, pc)
        else:
            return None
        
    def range_lists(self):
        return None
    
    def get_aranges(self):
        return None
    
    def has_CFI(self):
        return False
    
    def has_CFI(self):
        return False
    
    def has_EH_CFI(self):
        return False

def parse_dwarf1(elffile):
    return DWARFInfoV1(elffile)

```

`dwex/dwarfutil.py`:

```py
from bisect import bisect_left
from elftools.dwarf.ranges import BaseAddressEntry as RangeBaseAddressEntry, RangeEntry
from elftools.dwarf.locationlists import LocationExpr
from elftools.dwarf.dwarf_expr import DWARFExprParser
from elftools.dwarf.callframe import FDE

from dwex.dwarfone import DWARFExprParserV1

class NoBaseError(Exception):
    pass

def has_code_location(die):
    attr = die.attributes
    return 'DW_AT_ranges' in attr or ('DW_AT_low_pc' in attr and 'DW_AT_high_pc' in attr)

class CodeLocationSimple:
    def __init__(self, attr):
        self.low = attr['DW_AT_low_pc'].value
        self.hi = attr['DW_AT_high_pc'].value
        if not attr['DW_AT_high_pc'].form == 'DW_FORM_addr':
            self.hi += self.low

    def start_address(self):
        return self.low
    
    def in_range(self, ip):
        return self.low <= ip < self.hi

    def intersects_fde(self, fde):
        fde_begin = fde.header.initial_location
        fde_end = fde_begin + fde.header.address_range
        return fde_begin < self.hi and self.low < fde_end

class CodeLocationRanges:
    def __init__(self, die):
        cu_base = None
        rl = get_die_ranges(die)
        l = []
        for r in rl:
            if isinstance(r, RangeEntry):
                if not r.is_absolute and cu_base is None:
                    cu_base = get_cu_base(die) # This may throw
                if r.is_absolute:
                    r = (r.begin_offset, r.end_offset)
                else:
                    r = (cu_base + r.begin_offset, cu_base + r.end_offset)
                l.append(r)
            else: # Base entry
                cu_base = r.base_address
        self.ranges = l

    def start_address(self):
        return min(*(low for (low, hi) in self.ranges))
    
    def in_range(self, ip):
        return any(1 for (low, hi) in self.ranges if low <= ip < hi)

    def intersects_fde(self, fde):
        fde_begin = fde.header.initial_location
        fde_end = fde_begin + fde.header.address_range        
        return any(1 for (low, hi) in self.ranges if fde_begin < hi and low < fde_end)

# Returns a code location object - range or ranges
# May throw a NoBaseError
def get_code_location(die):
    attr = die.attributes
    if 'DW_AT_ranges' in attr:
        return CodeLocationRanges(die)
    else:
        return CodeLocationSimple(attr)

# Respects caching. None if no ranges section. Returns the raw ranges
def get_die_ranges(die):
    di = die.dwarfinfo
    if not di._ranges:
        di._ranges = di.range_lists()
    if not di._ranges:
        return None
    return di._ranges.get_range_list_at_offset(die.attributes['DW_AT_ranges'].value, cu=die.cu)

# Doesn't return None, returns False if not found
def get_di_frames(di):
    if di._frames is None:
        has_cfi = di.has_CFI()
        if di.has_EH_CFI():
            if has_cfi:
                di._frames = di.EH_CFI_entries() + di.CFI_entries()
            else:
                di._frames = di.EH_CFI_entries()
        elif has_cfi:
            di._frames = di.CFI_entries()
        else:
            di._frames = False
    return di._frames

def get_frame_rules_for_die(die):
    """
       Returns a list of dictionaries with 'pc', 'cfa' and other registers, as found in DecodedCallFrameTable.table
       for the FDE entries that overlap with the range or ranges of the provided DIE.
    """
    frames = get_di_frames(die.dwarfinfo)
    if not frames:
        return None
    try:
        code_loc = get_code_location(die)
    except NoBaseError:
        return None
    entries = [f for f in frames if isinstance(f, FDE) and code_loc.intersects_fde(f)]
    return [de for e in entries for de in e.get_decoded().table]    

def is_inline(func):
    return 'DW_AT_inline' in func.attributes and func.attributes['DW_AT_inline'].value != 0

def DIE_type(die):
    return die.get_DIE_from_attribute("DW_AT_type")

def is_int_list(val):
    return isinstance(val, list) and len(val) > 0 and isinstance(val[0], int)

def is_block(form):
    return form in ('DW_FORM_block', 'DW_FORM_block1', 'DW_FORM_block2', 'DW_FORM_block4')

def DIE_name(die):
    return die.attributes['DW_AT_name'].value.decode('utf-8', errors='ignore')

# Supports both / and \ - current system separator might not match the system the file came from
# so os.path.basename won't do
def strip_path(filename):
    p = filename.rfind("/")
    pbsl = filename.rfind("\\")
    if pbsl >= 0 and (p < 0 or pbsl > p):
        p = pbsl
    return filename[p+1:] if p >= 0 else filename

def top_die_file_name(die, Default = 'N/A'):
    if DIE_has_name(die):
        source_name = DIE_name(die)
        return strip_path(source_name)
    elif 'DW_AT_decl_file' in die.attributes:
        val = die.attributes['DW_AT_decl_file'].value
        if val > 0:
            if die.cu._lineprogram is None:
                die.cu._lineprogram = die.dwarfinfo.line_program_for_CU(die.cu)
            if die.cu._lineprogram: # No lineprogram is effectively corruption
                delta = 1 if die.cu.header.version < 5 else 0
                return strip_path(die.cu._lineprogram.header.file_entry[val-delta].name.decode('utf-8', errors='ignore'))
            else:
                return "(unknown)"
    return Default

 # See #1742
def DIE_has_name(die):
    """DIE object has a name attribute and the name is bytes or compatible
    """
    return 'DW_AT_name' in die.attributes and die.attributes['DW_AT_name'].value is not None and hasattr(die.attributes['DW_AT_name'].value, 'decode')

def safe_DIE_name(die, default = ''):
    return die.attributes['DW_AT_name'].value.decode('utf-8', errors='ignore') if 'DW_AT_name' in die.attributes and die.attributes['DW_AT_name'].value is not None and hasattr(die.attributes['DW_AT_name'].value, 'decode') else default

def follow_ref_if_present(die, attr_name):
    return die.get_DIE_from_attribute(attr_name) if attr_name in die.attributes else die

def subprogram_name(die, default=''):
    """
        Gets name of a DIE. If not available, drills back to abstract_origin, then specification
    """
    if 'DW_AT_name' in die.attributes:
        return die.attributes['DW_AT_name'].value.decode('UTF-8')
    die = follow_ref_if_present(die, 'DW_AT_abstract_origin')
    if 'DW_AT_name' in die.attributes:
        return die.attributes['DW_AT_name'].value.decode('UTF-8')
    die = follow_ref_if_present(die, 'DW_AT_specification')
    if 'DW_AT_name' in die.attributes:
        return die.attributes['DW_AT_name'].value.decode('UTF-8')
    return default

def DIE_is_ptr_to_member_struct(type_die):
    if type_die.tag == 'DW_TAG_structure_type':
        members = tuple(die for die in type_die.iter_children() if die.tag == "DW_TAG_member")
        return len(members) == 2 and safe_DIE_name(members[0]) == "__pfn" and safe_DIE_name(members[1]) == "__delta"
    return False

class ClassDesc(object):
    def __init__(self):
        self.scopes = ()
        self.const_member = False

class TypeDesc(object):
    def __init__(self):
        self.name = None
        self.modifiers = () # Reads left to right
        self.scopes = () # Reads left to right
        self.tag = None   

# Address is relative to the preferred loading address
# Not generally applicable for pyelftools clients - relies on CU caching by dwex
def find_cu_by_address(di, address):
    if di._aranges:
        cuoffset = di._aranges.cu_offset_at_addr(address)
        if cuoffset is not None:
            cu = di._unsorted_CUs[bisect_left(di._CU_offsets, cuoffset)]
            if cu.cu_offset == cuoffset:
                return cu
    return next((cu for cu in di._unsorted_CUs if ip_in_range(cu.get_top_DIE(), address)), None)

# May return None or raise NoBaseError
def get_cu_base(die):
    top_die = die.cu.get_top_DIE()
    if 'DW_AT_low_pc' in top_die.attributes:
        return top_die.attributes['DW_AT_low_pc'].value
    elif 'DW_AT_entry_pc' in top_die.attributes:
        return top_die.attributes['DW_AT_entry_pc'].value
    elif 'DW_AT_ranges' in top_die.attributes:
        rl = get_die_ranges(top_die)
        if rl is None:
            raise NoBaseError()
        base = None
        for r in rl:
            if isinstance(r, RangeEntry) and r.is_absolute and (base is None or r.begin_offset < base):
                base = r.begin_offset
            elif isinstance(r, RangeBaseAddressEntry) and (base is None or r.base_address < base):
                base = r.base_address
        if base is None:
            raise NoBaseError()
        return base
    else:
        raise NoBaseError()

# Returns a list of DIEs objects for top level functions that contain the address
# Inlines analyzed later
# TODO: namespaces
def find_funcs_at_address(cu, address):
    funcs = []
    top_die = cu.get_top_DIE()
    di = cu.dwarfinfo
    first_die = next(top_die.iter_children())
    if first_die is None:
        return []
        
    has_siblings = "DW_AT_sibling" in first_die.attributes 
    if has_siblings:
        die_list = (die for die in cu.iter_DIE_children(top_die))
    else:
        die_list = (die for die in cu.iter_DIEs())

    for die in die_list:
        if die.tag in ('DW_TAG_subprogram', 'DW_TAG_global_subroutine') and has_code_location(die):
            if 'DW_AT_range' in die.attributes:
                cu_base = top_die.attributes['DW_AT_low_pc'].value
                rl = di._ranges.get_range_list_at_offset(die.attributes['DW_AT_ranges'].value, cu = die.cu)
                for r in rl:
                    if r.begin_offset <= address - cu_base < r.end_offset:
                        funcs.append(die)
            else:
                l = die.attributes['DW_AT_low_pc'].value
                h = die.attributes['DW_AT_high_pc'].value
                if not die.attributes['DW_AT_high_pc'].form == 'DW_FORM_addr':
                    h += l
                if address >= l and address < h:
                    funcs.append(die)
    return funcs

# Find helper:
# Returns true if the specified IP is in [low_pc, high_pc)
# Or in ranges
# TODO: rewrite with CodeLocation objects
def ip_in_range(die, ip):
    if 'DW_AT_ranges' in die.attributes:
        di = die.dwarfinfo
        if not di._ranges:
            di._ranges = di.range_lists()
        if not di._ranges: # Absent in the DWARF file
            return False
        # TODO: handle base addresses. Never seen those so far...
        cu_base = None
        rl = di._ranges.get_range_list_at_offset(die.attributes['DW_AT_ranges'].value, cu = die.cu)
        for r in rl:
            if isinstance(r, RangeBaseAddressEntry):
                cu_base = r.base_address
            else: # r is RangeEntry, which in DWARF5 can be absolute
                if not r.is_absolute and cu_base is None:
                    cu_base = get_cu_base(die)
                if r.begin_offset <= ip - (0 if r.is_absolute else cu_base) < r.end_offset:
                    return True
    if 'DW_AT_low_pc' in die.attributes and 'DW_AT_high_pc' in die.attributes:
        l = die.attributes['DW_AT_low_pc'].value
        h = die.attributes['DW_AT_high_pc'].value
        if die.attributes['DW_AT_high_pc'].form != 'DW_FORM_addr':
            h += l
        if l <= ip < h:
            return True
    return False

# returns (origin, spec)
def follow_function_spec(func_die):
    origin = func_die.get_DIE_from_attribute('DW_AT_abstract_origin') if 'DW_AT_abstract_origin' in func_die.attributes else func_die
    spec = origin.get_DIE_from_attribute('DW_AT_specification') if 'DW_AT_specification' in origin.attributes else origin
    return (origin, spec)

# Line program navigation - A2L core
# DWEX aware caching
def get_source_line(die, address):
    cu = die.cu
    if cu._lineprogram is None:
        cu._lineprogram = die.dwarfinfo.line_program_for_CU(cu)
    lp = cu._lineprogram
    v5 = cu.header.version >= 5
    file_and_line = None
    prevstate = None
    for entry in lp.get_entries():
        state = entry.state
        # We're interested in those entries where a new state is assigned
        if state is None:
            continue

        # Looking for a range of addresses in two consecutive states that
        # contain the required address.
        if prevstate and prevstate.address <= address < state.address and not file_and_line:
            file = (die.cu.get_top_DIE().attributes['DW_AT_name'].value if not v5 and prevstate.file == 0 else lp['file_entry'][prevstate.file + (0 if v5 else -1)].name).decode('UTF-8')
            line = prevstate.line
            file_and_line = (file, line)

        if state.end_sequence:
            prevstate = None
        else:
            prevstate = state
    return file_and_line

# Resolves source file number in an attribute to a file name
# None if no such attribute or no such file
# DWEX caching aware
def get_source_file_name_from_attr(die, attr_name):
    cu = die.cu
    if cu._lineprogram is None:
        cu._lineprogram = die.dwarfinfo.line_program_for_CU(cu)
    lp = cu._lineprogram
    if attr_name in die.attributes:
        file_no = die.attributes[attr_name].value
        if cu.header.version < 5:
            file_no -= 1
        file_entries = lp['file_entry']
        if file_no >= 0 and file_no < len(file_entries):
            return file_entries[file_no].name.decode('UTF-8')

# Returns (name, mangled_name)
def retrieve_function_names(func_spec, the_func):
    attr = func_spec.attributes
    func_name = DIE_name(func_spec)
    module = the_func.cu.get_top_DIE()
    lang = module.attributes['DW_AT_language'].value if 'DW_AT_language' in module.attributes else None
    if 'DW_AT_MIPS_linkage_name' in attr:
        mangled_func_name = func_spec.attributes['DW_AT_MIPS_linkage_name'].value.decode('UTF-8', errors='ignore')
    elif 'DW_AT_linkage_name' in attr:
        mangled_func_name = func_spec.attributes['DW_AT_linkage_name'].value.decode('UTF-8', errors='ignore')
    else: # Could be a plain-C function...
        mangled_func_name = func_name
        if lang in (0x1, 0x2, 0xc, 0x1d) or (has_code_location(func_spec) and "DW_AT_external" in attr) or "DW_AT_external" in the_func.attributes:
            return (func_name, func_name)
    # Sometimes addr2line spits without even (). Extern "C" maybe? 

    # TODO: augment func name with arguments for ones where it's relevant. External? cdecl?
    if lang in (0x4, 0x19,0x1a, 0x21): # C++
        func_name = generate_full_function_name(func_spec, the_func) 
    # TODO: Pascal, ObjC
    return (func_name, mangled_func_name)

def generate_full_function_name(func_spec, the_func):
    func_name = DIE_name(func_spec)

    spec_params = tuple(ps for ps in func_spec.iter_children() if ps.tag in ("DW_TAG_formal_parameter", "DW_TAG_unspecified_parameters") and 'DW_AT_artificial' not in ps.attributes)
    func_params = tuple(p for p in the_func.iter_children() if p.tag in ("DW_TAG_formal_parameter", "DW_TAG_unspecified_parameters") and 'DW_AT_artificial' not in p.attributes)
    params = tuple(format_function_param(*pp) for pp in zip(spec_params, func_params))
    class_spec = get_class_spec_if_member(func_spec, the_func)
    class_prefix = "::".join(class_spec.scopes) + "::" if class_spec and class_spec.scopes else ""
    class_postfix = " const" if class_spec and class_spec.const_member else ""
    # I've seen const marker on the this parameter that wasn't const in the source
    return class_prefix + func_name + "(" + ", ".join(params) + ")" + class_postfix

def format_function_param(param_spec, param):
    if param_spec.tag == 'DW_TAG_formal_parameter':
        if 'DW_AT_name' in param.attributes:
            name = DIE_name(param)
        elif 'DW_AT_name' in param_spec.attributes:
            name = DIE_name(param_spec)
        else:
            name = None
        type = parse_datatype(param_spec)
        type_name = type.name
        if type.scopes:
            scopes = "::".join(type.scopes) # Are there any case where namespace and class scopes vary?
            type_name = f"{scopes}::{type_name}"

        mods = type.modifiers
        cpp_symbols = {"pointer": "*", "reference" : "&", "const" : " const"}
        #Ad-hoc fixes
        if mods and len(mods) >= 2 and mods[-1] == "const": # const-ref-const to const-ref # mods[0] == "const" and 
            mods = mods[0:-1]
        # TODO: check if typedef matters            
        return type_name + "".join(cpp_symbols[mod] for mod in mods)
 
    else: #unspecified_parameters AKA variadic
        return "..."

# Follows the modifier chain
# Returns an object:
def parse_datatype(var):
    t = TypeDesc()
    if not 'DW_AT_type' in var.attributes:
        t.tag = ''
        return t

    type_die = var.get_DIE_from_attribute('DW_AT_type')

    mods = []
    last_typedef = None
    while type_die.tag in ('DW_TAG_typedef', 'DW_TAG_array_type', 'DW_TAG_const_type', 'DW_TAG_pointer_type', 'DW_TAG_reference_type'):
        if type_die.tag != 'DW_TAG_typedef':
            mods.insert(0, type_die.tag[7:-5])
            if not 'DW_AT_type' in type_die.attributes and "pointer" in mods:
                t.name = "void"
                t.modifiers = tuple(mods)
                t.tag = None
                return t
        else: # typedef
            last_typedef = DIE_name(type_die)
        type_die = type_die.get_DIE_from_attribute('DW_AT_type')
    t.modifiers = tuple(mods)

    if type_die.tag in ('DW_TAG_ptr_to_member_type', 'DW_TAG_subroutine_type'):
        t.tag = type_die.tag[7:-5]
        if t.tag == 'ptr_to_member':
            ptr_prefix = DIE_name(type_die.get_DIE_from_attribute('DW_AT_containing_type')) + "::"
            type_die = type_die.get_DIE_from_attribute('DW_AT_type')
        elif "DW_AT_object_pointer" in type_die.attributes: # Older compiler... Subroutine, but with an object pointer
            ptr_prefix = DIE_name(DIE_type(DIE_type(type_die.get_DIE_from_attribute('DW_AT_object_pointer')))) + "::"
        else: # Function pointer. Expect a pointer as the final modifier
            mods.pop()
            t.modifiers = tuple(mods)
            ptr_prefix = ''

        if t.tag == 'subroutine':
            params = tuple(format_function_param(p, p) for p in type_die.iter_children() if p.tag in ("DW_TAG_formal_parameter", "DW_TAG_unspecified_parameters") and 'DW_AT_artificial' not in p.attributes)
            params = ", ".join(params)
            if 'DW_AT_type' in type_die.attributes:
                retval_type = parse_datatype(type_die)
                retval_type = retval_type.name # TODO: modifiers...
            else:
                retval_type = "void"
            #class_spec = get_class_spec_if_member(func_spec, the_func)
            #class_prefix = class_spec.name + "::" if class_spec else ""
            #class_postfix = " const" if class_spec and class_spec.const_member else ""
            t.name = f"{retval_type} ({ptr_prefix}*)({params})"
            return t
    elif DIE_is_ptr_to_member_struct(type_die):
        dt =  parse_datatype(next(type_die.iter_children())) # The first element is pfn, a function pointer with a this
        dt.modifiers = tuple(dt.modifiers[:-1]) # Pop the extra pointer
        dt.tag = "ptr_to_member_type" # Not a function pointer per se
        return dt

    type_name = safe_DIE_name(type_die, last_typedef)
    
    # This only for compatibility with addr2line. Debugged on ARM64/Android, might have different encodings on different arches
    if type_die.tag == 'DW_TAG_base_type':
        if type_name.endswith(" int") and type_name != "unsigned int":
            type_name = type_name[:-4]
        if type_name.endswith(" unsigned"):
            type_name = "unsigned " + type_name[:-9]
    t.name = type_name

    # Check the nesting
    parent = type_die.get_parent()
    scopes = list()
    while parent.tag in ('DW_TAG_class_type', 'DW_TAG_structure_type', 'DW_TAG_namespace'):
        scopes.insert(0, DIE_name(parent))
        parent = parent.get_parent()
    t.scopes = tuple(scopes)
    
    return t

def get_class_spec_if_member(func_spec, the_func):
    if 'DW_AT_object_pointer' in the_func.attributes:
        this_param = the_func.get_DIE_from_attribute('DW_AT_object_pointer')
        this_type = parse_datatype(this_param)
        class_spec = ClassDesc()
        class_spec.scopes = this_type.scopes + (this_type.name,)
        class_spec.const_member = any(("const", "pointer") == this_type.modifiers[i:i+2]
            for i in range(len(this_type.modifiers))) # const -> pointer -> const for this arg of const 
        return class_spec

    # Check the parent element chain - could be a class
    parent = func_spec.get_parent()

    scopes = []
    while parent.tag in ("DW_TAG_class_type", "DW_TAG_structure_type", "DW_TAG_namespace"):
        scopes.insert(0, DIE_name(parent))
        parent = parent.get_parent()
    if scopes:
        cs = ClassDesc()
        cs.scopes = tuple(scopes)
        return cs

    return None


# scope is a function DIE with a code address
# returns (locals, next_scope)
# where locals is a list of (name, location)
# and next_scope is a inlined function DIE to examine next
# For now, local datatype is not returned
# location is a list of parsed DWARF operations or an empty list
# if the var has no matching location record for the given address
def scan_scope(scope, address):
    locals = []
    next_scope = None
    if 'DW_AT_frame_base' in scope.attributes:
        locals.append(('__frame_base', parse_location(scope.attributes['DW_AT_frame_base'], scope.cu, address), scope))
        #'Type': {'name': 'void', 'modifiers' : ("pointer",), "scopes": (), "tag": None}}
    
    for die in scope.iter_children():
        if die.tag == 'DW_TAG_variable' or die.tag == 'DW_TAG_formal_parameter':
            (k, v) = resolve_local(die, address)
            locals.append((k, v, die))
        elif die.tag == 'DW_TAG_lexical_block' and ip_in_range(die, address):
            (block_locals, next_scope) = scan_scope(die, address)
            locals += block_locals
        elif die.tag ==  'DW_TAG_inlined_subroutine' and ip_in_range(die, address):
            next_scope = die
    return (locals, next_scope)

# returns (name, location_expression)
def resolve_local(p, address):
    loc = False
    if 'DW_AT_abstract_origin' in p.attributes: # Inlined sub formal param
        if 'DW_AT_location' in p.attributes:
            loc = p.attributes['DW_AT_location']
            loc_cu = p.cu
        p = p.get_DIE_from_attribute('DW_AT_abstract_origin')

    #type = parse_datatype(p)
    if not loc and 'DW_AT_location' in p.attributes:
        loc = p.attributes['DW_AT_location']
        loc_cu = p.cu

    if loc:
        expr = parse_location(loc, loc_cu, address)
    else:
        expr = False

    name = safe_DIE_name(p, "(no name attribute)")
    return (name, expr)


def parse_location(loc, cu, address):
    # TODO: check v5 loclists
    ll = cu.dwarfinfo._locparser.parse_from_attribute(loc, cu['version']) # Either a list or a LocationExpr

    # Find the expression blob
    if isinstance(ll, LocationExpr):
        loc_expr = ll.loc_expr
    else: 
        top_die = cu.get_top_DIE()
        base = top_die.attributes['DW_AT_low_pc'].value
        loc_expr = False
        for l in ll:
            if 'base_address' in l._fields:
                base = l.base_address
            elif l.begin_offset <= address - base < l.end_offset:
                loc_expr = l.loc_expr
                break
            
    # Translate to usable format
    if loc_expr:
        # TODO: cache expr parser. Make sure CUs are cached in the dwarfinfo first.
        return list((DWARFExprParser(cu.structs) if cu['version'] > 1 else DWARFExprParserV1(cu.structs)).parse_expr(loc_expr))
    else:
        return []

def quote_filename(fn):
    return f'"{fn}"' if ' ' in fn else fn
```

`dwex/exprdlg.py`:

```py
from PyQt6.QtWidgets import *
from PyQt6.QtCore import Qt, QAbstractTableModel

HEADERS = ('#', 'Offset', 'Operation')

def op_has_nested_expression(op):
    return op.op in ('DW_OP_entry_value', 'DW_OP_GNU_entry_value')

# TODO: low level maybe
# Spell out args?
# Opcode tooltips?
class ExpressionTableModel(QAbstractTableModel):
    # Expr is a list of operation objects
    # Used also for expressions in the details pane
    # Assumes double-clicks are caught by the table owner, elsewhere
    # But presents "double-click for details
    # The index data item is an operation namedtuple from DWARFExprParser
    def __init__(self, expr, formatter):
        super().__init__()
        self.expr = expr
        self.formatter = formatter

    def rowCount(self, parent):
        return len(self.expr)

    def columnCount(self, parent):
        return 3
    
    def headerData(self, col, ori, role):
        if ori == Qt.Orientation.Horizontal and role == Qt.ItemDataRole.DisplayRole:
            return HEADERS[col]
    
    def index(self, row, col, parent):
        return self.createIndex(row, col, self.expr[row])
    
    def data(self, index, role):
        col = index.column()
        op = index.internalPointer()
        if role == Qt.ItemDataRole.DisplayRole:
            if col == 0:
                return str(index.row() + 1)
            elif col == 1:
                return hex(op.offset)
            else:
                return self.formatter.format_op(*op)
        elif role == Qt.ItemDataRole.ToolTipRole:
            if col == 2 and op_has_nested_expression(op):
                return 'Double-click for details'

# TODO: a dialog with a table and a close button should be reused elsewhere
# TODO: copy
# TODO: reg names, hex, prefix toggles
# TODO: low level mode that shows bytes?
# This is a dialog for browsing DWARF expressions, not entering Python expressions
class ExpressionDlg(QDialog):
    def __init__(self, win, title, e, f):
        super().__init__(win, Qt.WindowType.Dialog)
        self.setWindowTitle(title)
        self.resize(500, 400)

        entries = self.entries = QTableView()
        entries.setModel(ExpressionTableModel(e, f))
        header = entries.horizontalHeader()
        header.setSectionResizeMode(0, QHeaderView.ResizeMode.ResizeToContents)
        header.setSectionResizeMode(1, QHeaderView.ResizeMode.ResizeToContents)
        header.setSectionResizeMode(2, QHeaderView.ResizeMode.Stretch)
        entries.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
        entries.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)
        entries.doubleClicked.connect(self.on_line_dclick)

        buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Close, Qt.Orientation.Horizontal, self)
        buttons.rejected.connect(self.reject)

        ly = QVBoxLayout()
        ly.addWidget(entries)
        ly.addWidget(buttons)
        self.setLayout(ly)

    def on_line_dclick(self, index):
        op = index.internalPointer()
        if op_has_nested_expression(op):
            title = f'Nested expression in {op.op} at 0x{op.offset:x}'
            ExpressionDlg(self, title, op.args[0], self.formatter).exec()


```

`dwex/exprutil.py`:

```py
from elftools.dwarf.descriptions import _REG_NAMES_x86, _REG_NAMES_x64, _REG_NAMES_AArch64
from elftools.dwarf.dwarf_expr import DWARFExprOp

# TODO: take from pyelftools when they publish
# Source: https://github.com/ARM-software/abi-aa/blob/main/aadwarf32/aadwarf32.rst#dwarf-register-names
_REG_NAMES_ARM = [
    'r0', 'r1', 'r2', 'r3', 'r4', 'r5', 'r6', 'r7',
    'r8', 'r9', 'r10', 'r11', 'r12', 'sp', 'lr', 'pc'
] + ['<none>']*48 + ["s%d" %(n,) for n in range(32)] + [
    'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7',
    'acc0', 'acc1', 'acc2', 'acc3', 'acc4', 'acc5', 'acc6', 'acc7', #AKA wcgr0..7
    'wr0', 'wr1', 'wr2', 'wr3', 'wr4', 'wr5', 'wr6', 'wr7',
    'wr8', 'wr9', 'wr10', 'wr11', 'wr12', 'wr13', 'wr14', 'wr15',
    'spsr', 'spsr_fiq', 'spsr_irq', 'spsr_abt', 'spsr_und', 'spsr_svc'] + ['<none>']*9 + [
    'ra_auth_code', 'r8_usr', 'r9_usr', 'r10_usr', 'r11_usr', 'r12_usr', 'r13_usr', 'r14_usr',
    'r8_fiq', 'r9_fiq', 'r10_fiq', 'r11_fiq', 'r12_fiq', 'r13_fiq', 'r14_fiq',
    'r13_irq', 'r14_irq', 'r13_abt', 'r14_abt',
    'r13_und', 'r14_und', 'r13_svc', 'r14_svc'] + ['<none>']*26 + [
    'wc0', 'wc1', 'wc2', 'wc3', 'wc4', 'wc5', 'wc6', 'wc7'] + ['<none>']*56 + [
        "d%d" %(n,) for n in range(32)] + ['<none>']*32 + [
     'tpidruro', 'tpidrurw', 'tpidpr', 'htpidpr'
]

_REG_NAMES_MIPS = [
    '$zero', '$at', '$v0', '$v1', '$a0', '$a1', '$a2', '$a3',
    '$t0', '$t1', '$t2', '$t3', '$t4', '$t5', '$t6', '$t7',
    '$s0', '$s1', '$s2', '$s3', '$s4', '$s5', '$s6', '$s7',
    '$t8', '$t9', '$k0', '$k1', '$gp', '$sp', '$fp', '$ra',
    '$ps', '$lo', '$hi', '$badvaddr', '$cause', '$pc'] + [
        '$fp%d' % n for n in range(35)] + ['<none>'] + [
        '$cp%d' % n for n in range(15)] + ['$prid']

# Source: https://github.com/riscv-non-isa/riscv-elf-psabi-doc/blob/master/riscv-dwarf.adoc
_REG_NAMES_RISCV = [
    'zero', 'ra', 'sp', 'gp', 'tp', 't0', 't1', 't2',
    'fp', 's1', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5',
    'a6', 'a7', 's2', 's3', 's4', 's5', 's6', 's7',
    's8', 's9', 's10', 's11', 't3', 't4', 't5', 't6'] + [
        'f%d' % n for n in range(32)] + ['afrc'] + ['<none>']*31 + [
        'v%d' % n for n in range(32)]

# Source for 64 bit: https://github.com/riscv-non-isa/riscv-elf-psabi-doc/blob/master/riscv-dwarf.adoc
# Source for 32 bit: http://refspecs.linux-foundation.org/elf/elfspec_ppc.pdf
# They are sufficiently similar
# There are some more kernel level registers defined in the ABI at #356 and further, not listed here
_REG_NAMES_POWERPC = ['r%d' % n for n in range(32)] +[
      'f%d' % n for n in range(32)] +[
    'cr', 'fpscr', 'msr', '<none>', '<none>', '<none>',
    'sr0', 'sr1', 'sr2', 'sr3', 'sr4', 'sr5', 'sr6', 'sr7',
    'sr8', 'sr9', 'sr10', 'sr11', 'sr12', 'sr13', 'sr14', 'sr15'] + ['<none>']*14 + [
    'mq', 'xer', '<none>', '<none>', 'rtcu', 'rtcl', '<none>', '<none>',
    'lr', 'ctr', '<none>', '<none>', '<none>', '<none>', '<none>', '<none>',
    '<none>', '<none>', 'dsisr', 'dar', '<none>', '<none>', 'dec', '<none>',
    '<none>', 'sdr1', 'srr0', 'srr1']

# More? 

# The key here is the machine_arch value in the DWARFConfig struct.
# Machine arch values are generated differently for ELF, MachO and PE
# For ELF, see the values in the architecture dict in get_machine_arch() under elftools.elf.elffile
# For PE, see IMAGE_FILE_MACHINE in filebytes.pe
# For MachO, see make_macho_arch_name() in formats.py, which derives from CpuType under filebytes.mach_o and subtypes

_REG_NAME_MAP = {
    'x86': _REG_NAMES_x86,
    'I386': _REG_NAMES_x86,
    'x64': _REG_NAMES_x64,
    'AMD64': _REG_NAMES_x64,
    'X86_64': _REG_NAMES_x64,
    'ARM': _REG_NAMES_ARM,
    'ARMV6': _REG_NAMES_ARM,
    'ARMV7': _REG_NAMES_ARM,
    'ARMV7A': _REG_NAMES_ARM,
    'ARMV7S': _REG_NAMES_ARM,
    'AArch64': _REG_NAMES_AArch64,
    'ARM64': _REG_NAMES_AArch64,
    'ARME': _REG_NAMES_AArch64,
    'MIPS': _REG_NAMES_MIPS,
    'RISC-V': _REG_NAMES_RISCV,
    'PowerPC': _REG_NAMES_POWERPC,
    '64-bit PowerPC': _REG_NAMES_POWERPC
}

class ExprFormatter:
    # Operator codes differ in DWARFv1, thus the need for version
    # regnames: False for friendly names, True for DWARF names
    # prefix: False for friendly, True for DW_OP_xxx
    # arch is for register name set selection
    # dwarf_version only matters whether it is 1 or greater
    # address_delta is the addend that will account for a custom loading address
    def __init__(self, regnames, prefix, arch, dwarf_version, hex):
        self.regnames = regnames
        self.prefix = prefix
        self.arch = arch
        self.regnamelist = _REG_NAME_MAP.get(self.arch)
        self.dwarf_version = dwarf_version # Likely to change
        self.hex = hex
        self.address_delta = 0
        self.cfa_resolver = None # no args, returns the CFA expression formatted to a string

    def set_arch(self, arch):
        if arch != self.arch:
            self.arch = arch
            self.regnamelist = _REG_NAME_MAP.get(self.arch)

    def set_address_delta(self, ad):
        self.address_delta = ad

    def decode_breg(self, regno, offset):
        if offset == 0:
            return '[%s]' % (self.regnamelist[regno],)
        elif -10 < offset < 0:
            return '[%s-%x]' % (self.regnamelist[regno], -offset)
        elif offset <= 10:
            return '[%s-0x%x]' % (self.regnamelist[regno], -offset)
        elif 0 < offset < 10:
            return '[%s+%x]' % (self.regnamelist[regno], offset)
        else:
            return '[%s+0x%x]' % (self.regnamelist[regno], offset)

    def format_op(self, op, op_name, args, offset):
        def format_arg(s):
            if isinstance(s, str):
                return s
            elif isinstance(s, int):
                # TODO: more discerning here, hex elsewhere?
                return hex(s) if (self.hex or op == 0x03) and not(-10 < s < 10) else str(s) 
            elif isinstance(s, list): # Could be a blob (list of ints), could be a subexpression
                if len(s) > 0 and isinstance(s[0], DWARFExprOp): # Subexpression
                    return '{' + '; '.join(self.format_op(*op) for op in s) + '}'
                else:
                    return bytes(s).hex() # Python 3.5+

        if not self.regnames and self.regnamelist: # Friendly register names
            if 0x50 <= op <= 0x6f and op - 0x50 < len(self.regnamelist): # reg0...reg31
                op_name = self.regnamelist[op-0x50]
            elif 0x70 <= op <= 0x8f and op - 0x70 < len(self.regnamelist) and len(args) > 0: # breg0...breg31(offset)
                op_name = self.decode_breg(op - 0x70, args[0])
                args = False
            elif (op == 0x90 or (self.dwarf_version == 1 and op == 0x1)) and len(args) > 0 and args[0] >= 0 and args[0] < len(self.regnamelist): # regx(regno)
                op_name = self.regnamelist[args[0]]
                args = False
            elif op == 0x92 and len(args) > 1 and args[0] >= 0 and args[0] < len(self.regnamelist): # bregx(regno, offset)
                op_name = self.decode_breg(args[0], args[1])
                args = False

        if op_name == 'DW_OP_call_frame_cfa' and self.cfa_resolver:
            resolved_cfa = self.cfa_resolver()
            if resolved_cfa:
               op_name += f"[{resolved_cfa}]"

        if op_name.startswith('DW_OP_') and not self.prefix:
            op_name = op_name[6:]

        if args:
            if op == 0x03: # DW_OP_addr: relocate
                args = [args[0] + self.address_delta]
            return op_name + ' ' + ', '.join(format_arg(s) for s in args)
        else:
            return op_name
        
    def regname(self, regno):
        return self.regnamelist[regno] if not self.regnames and self.regnamelist else "r%d" % (regno,)
    
    def format_regoffset(self, regno, offset):
        return self.regname(regno) + format_offset(offset)

# Hex or dec for small values
def format_offset(offset):
    if offset == 0 or offset is None:
        return ''
    elif 0 < offset < 0x10:
        return "+%d" % (offset,)
    elif -0x10 < offset < 0:
        return "-%d" % (-offset,)
    elif offset >= 0x10:
        return "+0x%x" % (offset,)
    else:
        return "-0x%x" % (-offset,)
    
def is_parsed_expression(l):
    """If the arg is a list, and the first element in the list is a DWARFExprOp
    """
    return isinstance(l, list) and len(l) and isinstance(l[0], DWARFExprOp)
```

`dwex/filebytes/__init__.py`:

```py
# coding=utf-8
# Copyright 2018 Sascha Schirra
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
# list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
# this list of conditions and the following disclaimer in the documentation
# and/or other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its contributors
# may be used to endorse or promote products derived from this software without
# specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" A ND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


__all__ = ['elf','pe','mach_o']
VERSION = '0.10.2'

```

`dwex/filebytes/binary.py`:

```py
# coding=utf-8
# Copyright 2018 Sascha Schirra
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
# list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
# this list of conditions and the following disclaimer in the documentation
# and/or other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its contributors
# may be used to endorse or promote products derived from this software without
# specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" A ND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

from .ctypes_helper import *
from struct import pack_into

from ctypes import *

class Container(object):

    def __init__(self, **args):
        setattr = super(Container, self).__setattr__
        for key, value in args.items():
            setattr(key, value)


class Binary(object):
    def __init__(self, fileName, fileContent=None):
        if fileContent:
            if type(fileContent) == bytes:
                fileContent = to_ubyte_array(fileContent)
            self._bytes = fileContent
        else:
            self._bytes = self._readFile(fileName)
        if not self.__class__.isSupportedContent(self._bytes):
            raise BinaryError('Not a suitable filetype')

        self.__fileName = fileName


    @property
    def fileName(self):
        """
        Returns the filename
        """
        return self.__fileName

    @property
    def entryPoint(self):
        return 0x0

    @property
    def imageBase(self):
        return 0x0

    @property
    def type(self):
        return 'ELF'

    def _readFile(self, fileName):
        """
        Returns the bytes of the file.
        """
        with open(fileName, 'rb') as binFile:
            b = binFile.read()
            return to_ubyte_array(b)

    def assertFileRange(self, value):
        if type(value) == c_void_p:
            value = value.value

        file_data_pointer = get_ptr(self._bytes)
        assert value >= (file_data_pointer.value) and value <= (
            file_data_pointer.value + len(self._bytes)), 'Pointer not in file range'

    @classmethod
    def isSupportedFile(cls, fileName):
        try:
            with open(fileName, 'rb') as f:
                return cls.isSupportedContent(f.read())
        except BaseException as e:
            raise BinaryError(e)

    @classmethod
    def isSupportedContent(cls, fileContent):
        return False


class BinaryError(BaseException):
    pass

```

`dwex/filebytes/ctypes_helper.py`:

```py
# coding=utf-8
# Copyright 2018 Sascha Schirra
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
# list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
# this list of conditions and the following disclaimer in the documentation
# and/or other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its contributors
# may be used to endorse or promote products derived from this software without
# specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" A ND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


from struct import pack_into
import ctypes

def get_ptr(data, offset=None, ptr_type=ctypes.c_void_p):
    """Returns a void pointer to the data"""
    ptr = ctypes.cast(ctypes.pointer(data), ctypes.c_void_p)

    if offset:
        ptr = ctypes.c_void_p(ptr.value + offset)

    if ptr_type != ctypes.c_void_p:
        ptr = ctypes.cast(ptr, ptr_type)

    return ptr

def get_str(data, offset=None):
    return get_ptr(data, offset, ctypes.c_char_p).value.decode('ASCII')

def to_ubyte_array(barray):
    """Returns a c_ubyte_array filled with the given data of a bytearray or bytes"""
    bs = (ctypes.c_ubyte * len(barray))()
    pack_into('%ds' % len(barray), bs, 0, barray)

    return bs

```

`dwex/filebytes/enum.py`:

```py
# coding=utf-8
# Copyright 2018 Sascha Schirra
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
# list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
# this list of conditions and the following disclaimer in the documentation
# and/or other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its contributors
# may be used to endorse or promote products derived from this software without
# specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" A ND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


from re import match
from sys import version_info
import types

if version_info.major > 2:
    long = int

class EnumError(BaseException):

    def __init__(self, msg):
        super(EnumError, self).__init__(msg)



class EnumElement(object):

    def __init__(self, name, value, enum):
        super(EnumElement, self).__init__()

        self.__name = name
        self.__value = value
        self.__enum = enum

    @property
    def name(self):
        return self.__name

    @property
    def value(self):
        return self.__value

    @property
    def _enum(self):
        return self.__enum

    def __str__(self):
        return self.__name

    def __index__(self):
        return self.__value

    def __hash__(self):
        return hash((self,))

    @property
    def value(self):
        return self.__value

    @property
    def name(self):
        return self.__name

class IntEnumElement(EnumElement):


    def __hash__(self):
        return hash(self.value)

    def __cmp__(self, other):
        if isinstance(other, EnumElement):
            return self.value - other.value
        elif isinstance(other, int) or isinstance(other, long):
            return self.value - other
        else:
            return 1

    def __lt__(self, other):
        return self.__cmp__(other) < 0

    def __le__(self, other):
        return self.__cmp__(other) <= 0

    def __eq__(self, other):
        return self.__cmp__(other) == 0

    def __ge__(self, other):
        return self.__cmp__(other) >= 0

    def __gt__(self, other):
        return self.__cmp__(other) > 0

    def __and__(self, other):
        if isinstance(other, int) or isinstance(other, long):
            return self.value & other
        elif isinstance(other, EnumElement):
            return self.value & other.value
        raise TypeError('This operation is not supported for type ' % type(other))

    def __rand__(self, other):
        if isinstance(other, int) or isinstance(other, long):
            return self.value & other
        elif isinstance(other, EnumElement):
            return self.value & other.value
        raise TypeError('This operation is not supported for type ' % type(other))

    def __or__(self, other):
        if isinstance(other, int) or isinstance(other, long):
            return self.value | other
        elif isinstance(other, EnumElement) :
            return self.value | other.value
        raise TypeError('This operation is not supported for type ' % type(other))

    def __ror__(self, other):
        if isinstance(other, int) or isinstance(other, long):
            return self.value | other
        elif isinstance(other, EnumElement):
            return self.value | other.value
        raise TypeError('This operation is not supported for type ' % type(other))


    def __invert__(self):
        return ~self.value

    def __int__(self):
        return self.value




class EnumIterator(object):

    def __init__(self, enumData):
        self.__enumData = enumData
        self.__index = 0

    def next(self):
        if self.__index < len(self.__enumData):
            data = self.__enumData[self.__index]
            self.__index += 1
            return data
        raise StopIteration



class EnumMeta(type):

    def __new__(cls, name, bases, dct):

        def update(key, value):
            if value in values:
                raise EnumError('No aliases allowed: '+key+' and '+str(revData[value]))
            if isinstance(value, types.FunctionType):
                dct[key] = classmethod(value)
                return
            values.append(value)
            if isinstance(value, int) or isinstance(value, long):
                element = IntEnumElement(key, value, name)
            else:
                element = EnumElement(key, value, name)
            revData[value] = element
            valueData.append(element)
            dct[key] = element

        revData = {}
        valueData = []
        values = []
        for key, value in dct.items():
            if not key.startswith('_'):
                update(key, value)

        count = 0
        if '_enum_' in dct:
            enuminit = None
            if isinstance(dct['_enum_'], str):
                enuminit = dct['_enum_'].split(' ')
            elif isinstance(dct['_enum_'], tuple) or isinstance(dct['_enum_'], list):
                enuminit = dct['_enum_']
            for key in enuminit:
                if count in revData:
                    raise EnumError('The predefined elements have to have bigger value numbers')
                update(key, count)
                count += 1

        dct['_revData'] = revData
        dct['_enumData'] = sorted(valueData, key=lambda x: x.value)

        return super(EnumMeta, cls).__new__(cls, name, bases, dct)



    def __call__(cls, name, args):
        if isinstance(args, list):
            args = ' '.join(args)
        return type(name, (cls,), {'_enum_':args})

    def __iter__(cls):
        return EnumIterator(cls._enumData)

    def __str__(cls):
        toReturn = '<'
        for elem in cls._enumData:
            toReturn += str(elem) + '|'
        toReturn = toReturn[:-1] + '>'
        return cls.__name__ + '='+toReturn

    def __contains__(cls, item):
        return item in cls._revData

    def __getitem__(cls, key):
        if isinstance(key, str):
            return cls.__search(key)
        elif isinstance(key, EnumElement):
            return cls.__search(str(key))
        elif isinstance(key, int) or isinstance(key, long):
            if key in cls._revData:
                return cls._revData[key]
            return 'Unkown'
        raise TypeError('key has to be an instance of int/long or str:' + key.__class__.__name__)

    def __search(self, key):
        for elem in self._enumData:
            if str(elem) == key:
                return elem;

    def __instancecheck__(self, instance):
        return isinstance(instance, EnumElement) and instance._enum == self.__name__

# For compatibility reason (python2 & python3)
Enum = EnumMeta('Enum', (), {})

```

`dwex/filebytes/mach_o.py`:

```py
# coding=utf-8
# Copyright 2018 Sascha Schirra
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
# list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
# this list of conditions and the following disclaimer in the documentation
# and/or other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its contributors
# may be used to endorse or promote products derived from this software without
# specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" A ND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

from struct import pack as p
from .enum import Enum
from .binary import *
from binascii import hexlify
############# MachO General ######################

class MH(Enum):
    OBJECT = 0x1
    EXECUTE = 0x2
    FVMLIB = 0x3
    CORE = 0x4
    PRELOAD = 0x5
    DYLIB = 0x6
    DYLINKER = 0x7
    BUNDLE = 0x8
    DYLIB_STUB = 0x9
    DSYM = 0xa
    KEXT_BUNDLE = 0xb

class VM_PROT(Enum):
    READ = 0x1
    WRITE = 0x2
    EXEC = 0x4

    def shortString(self, perm):
        toReturn = ''
        toReturn += 'R' if perm & int(self.READ) > 0 else ' '
        toReturn += 'W' if perm & int(self.WRITE) > 0 else ' '
        toReturn += 'E' if perm & int(self.EXEC) > 0 else ' '

        return toReturn


class TypeFlags(Enum):
    MASK = 0xff000000
    ABI64 = 0x01000000


class CpuType(Enum):
    ANY = -1
    I386 = 7
    X86_64 = I386 | TypeFlags.ABI64
    MIPS = 8
    ARM = 12
    ARM64 = ARM | TypeFlags.ABI64
    SPARC = 14
    POWERPC = 18
    POWERPC64 = POWERPC | TypeFlags.ABI64
    LC_SEGMENT = 1
    LC_SEMGENT_64 = 0x19
    S_ATTR_SOME_INSTRUCTIONS = 0x400
    S_ATTR_PURE_INSTRUCTIONS = 0x80000000

class CpuSubTypeARM(Enum):
    ALL = 0
    V4T = 5
    V6 = 6
    V5 = 7
    XSCALE = 8
    V7 = 9
    V7S = 11
    V7K = 12
    V6M = 14
    V7M = 15
    V7EM = 16

class CpuSubTypeARM64(Enum):
    ALL = 0
    V8 = 1
    E = 2    

class SubTypeFlags(Enum):
    MASK = 0xff000000
    LIB64 = 0x80000000


class CPU_SUBTYPE_X86(Enum):
    X86 = 3
    X86_64 = X86 | SubTypeFlags.LIB64
    X86_64_H = 8
    I486 = 4
    I486SX = 0x84
    I586 = 5
    PENTPRO = 0x16
    PENTII_M3 = 0x36
    PENTII_M5 = 0x56
    CELERON = 0x67
    CELERON_MOBILE = 0x77
    PENTIUM_3_M = 0x18
    PENTIUM_3_XEON = 0x28
    PENTIUM_M = 0x09
    PENTIUM_4 = 0x0a
    PENTIUM_4_M = 0x1a
    ITANIUM = 0x0b
    ITANIUM_2 = 0x1b
    XEON = 0x0c
    XEON_MP = 0x1c


class LC(Enum):
    SEGMENT = 0x00000001
    SYMTAB = 0x00000002
    SYMSEG = 0x00000003
    THREAD = 0x00000004
    UNIXTHREAD = 0x00000005
    LOADFVMLIB = 0x00000006
    IDFVMLIB = 0x00000007
    IDENT = 0x00000008
    FVMFILE = 0x00000009
    PREPAGE = 0x0000000A
    DYSYMTAB = 0x0000000B
    LOAD_DYLIB = 0x0000000C
    ID_DYLIB = 0x0000000D
    LOAD_DYLINKER = 0x0000000E
    ID_DYLINKER = 0x0000000F
    PREBOUND_DYLIB = 0x00000010
    ROUTINES = 0x00000011
    SUB_FRAMEWORK = 0x00000012
    SUB_UMBRELLA = 0x00000013
    SUB_CLIENT = 0x00000014
    SUB_LIBRARY = 0x00000015
    TWOLEVEL_HINTS = 0x00000016
    PREBIND_CKSUM = 0x00000017
    LOAD_WEAK_DYLIB = 0x80000018
    SEGMENT_64 = 0x00000019
    ROUTINES_64 = 0x0000001A
    UUID = 0x0000001B
    RPATH = 0x8000001C
    CODE_SIGNATURE = 0x0000001D
    SEGMENT_SPLIT_INFO = 0x0000001E
    REEXPORT_DYLIB = 0x8000001F
    LAZY_LOAD_DYLIB = 0x00000020
    ENCRYPTION_INFO = 0x00000021
    DYLD_INFO = 0x00000022
    DYLD_INFO_ONLY = 0x80000022
    LOAD_UPWARD_DYLIB = 0x80000023
    VERSION_MIN_MACOSX = 0x00000024
    VERSION_MIN_IPHONEOS = 0x00000025
    FUNCTION_STARTS = 0x00000026
    DYLD_ENVIRONMENT = 0x00000027
    MAIN = 0x80000028
    DATA_IN_CODE = 0x00000029
    SOURCE_VERSION = 0x0000002A
    DYLIB_CODE_SIGN_DRS = 0x0000002B
    ENCRYPTION_INFO_64 = 0x0000002C
    LINKER_OPTIONS = 0x0000002D
    LINKER_OPTIMIZATION_HINT = 0x0000002E


class S_ATTR(Enum):
    SOME_INSTRUCTIONS = 0x00000400
    PURE_INSTRUCTIONS = 0x80000000

class LcStr(Union):
    _pack_ = 4
    _fields_ = [('offset', c_uint)]

class LoadCommand(LittleEndianStructure):
    _pack_ = 4
    _fields_ = [('cmd', c_uint),
                ('cmdsize', c_uint)]


class UuidCommand(LittleEndianStructure):
    _pack_ = 4
    _fields_ = [('cmd', c_uint),
                ('cmdsize', c_uint),
                ('uuid', c_ubyte * 16)]

class TwoLevelHintsCommand(LittleEndianStructure):
    _pack_ = 4
    _fields_ = [('cmd', c_uint),
                ('cmdsize', c_uint),
                ('offset', c_uint),
                ('nhints', c_uint)]

class TwoLevelHint(LittleEndianStructure):
    _pack_ = 4
    _fields_ = [('isub_image', c_uint),
                ('itoc', c_uint)]

class Dylib(LittleEndianStructure):
    _pack_ = 4
    _fields_ = [('name', LcStr),
                ('timestamp', c_uint),
                ('current_version', c_uint),
                ('compatibility_version', c_uint),
                ]

class DylibCommand(LittleEndianStructure):
    _pack_ = 4
    _fields_ = [('cmd', c_uint),
                ('cmdsize', c_uint),
                ('dylib', Dylib),
                ]

class DylinkerCommand(LittleEndianStructure):
    _pack_ = 4
    _fields_ = [('cmd', c_uint),
                ('cmdsize', c_uint),
                ('name', LcStr)
                ]
    
# Seva patch: SYMTAB parsing - LE only, but filebytes is broken anyway in that regard
class SymtabCommand(LittleEndianStructure):
    _pack_ = 4
    _fields_ = [('cmd', c_uint),
        ('cmdsize', c_uint),
        ('symbols_offset', c_uint),
        ('nsymbols', c_uint),
        ('strings_offset', c_uint),
        ('nstrings', c_uint)]    
                

########################### 32 BIT Structures ###########################

class LSB_32_MachHeader(LittleEndianStructure):
    _pack_ = 4
    _fields_ = [('magic', c_uint),
                ('cputype', c_uint),
                ('cpusubtype', c_uint),
                ('filetype', c_uint),
                ('ncmds', c_uint),
                ('sizeofcmds', c_uint),
                ('flags', c_uint)
                ]


class LSB_32_SegmentCommand(LittleEndianStructure):
    _pack_ = 4
    _fields_ = [('cmd', c_uint),
                ('cmdsize', c_uint),
                ('segname', c_char * 16),
                ('vmaddr', c_uint),
                ('vmsize', c_uint),
                ('fileoff', c_uint),
                ('filesize', c_uint),
                ('maxprot', c_uint),
                ('initprot', c_uint),
                ('nsects', c_uint),
                ('flags', c_uint)]


class LSB_32_Section(LittleEndianStructure):
    _pack_ = 4
    _fields_ = [('sectname', c_char * 16),
                ('segname', c_char * 16),
                ('addr', c_uint),
                ('size', c_uint),
                ('offset', c_uint),
                ('align', c_uint),
                ('reloff', c_uint),
                ('nreloc', c_uint),
                ('flags', c_uint),
                ('reserved1', c_uint),
                ('reserved2', c_uint)
                ]

class LSB_32(object):
    Section = LSB_32_Section
    SegmentCommand = LSB_32_SegmentCommand
    MachHeader = LSB_32_MachHeader

########################### 64 BIT Structures ###########################

class LSB_64_MachHeader(LittleEndianStructure):
    _pack_ = 8
    _fields_ = [('magic', c_uint),
                ('cputype', c_uint),
                ('cpusubtype', c_uint),
                ('filetype', c_uint),
                ('ncmds', c_uint),
                ('sizeofcmds', c_uint),
                ('flags', c_uint),
                ('reserved', c_uint),
                ]


class LSB_64_SegmentCommand(LittleEndianStructure):
    _pack_ = 8
    _fields_ = [('cmd', c_uint),
                ('cmdsize', c_uint),
                ('segname', c_char * 16),
                ('vmaddr', c_ulonglong),
                ('vmsize', c_ulonglong),
                ('fileoff', c_ulonglong),
                ('filesize', c_ulonglong),
                ('maxprot', c_uint),
                ('initprot', c_uint),
                ('nsects', c_uint),
                ('flags', c_uint)]


class LSB_64_Section(LittleEndianStructure):
    _pack_ = 8
    _fields_ = [('sectname', c_char * 16),
                ('segname', c_char * 16),
                ('addr', c_ulonglong),
                ('size', c_ulonglong),
                ('offset', c_uint),
                ('align', c_uint),
                ('reloff', c_uint),
                ('nreloc', c_uint),
                ('flags', c_uint),
                ('reserved1', c_uint),
                ('reserved2', c_uint)
    ]

class LSB_64(object):
    Section = LSB_64_Section
    SegmentCommand = LSB_64_SegmentCommand
    MachHeader = LSB_64_MachHeader


############################# Fat/Universal ###########################

class FatHeader(BigEndianStructure):
    _pack_ = 4
    _fields_ = [('magic', c_uint),
                ('nfat_arch', c_uint)
    ]

class FatArch(BigEndianStructure):
    _pack_ = 4
    _fields_ = [('cputype', c_uint),
                ('cpusubtype', c_uint),
                ('offset', c_uint),
                ('size', c_uint),
                ('align', c_uint)
    ]

############################### Container #############################


class MachHeaderData(Container):
    """
    header = MachHeader
    """

class LoadCommandData(Container):
    """
    header = LoaderCommand
    bytes = bytes of the command bytearray
    raw = bytes of the command c_ubyte_array

    SegmentCommand
    sections = list of SectionData

    UuidCommand
    uuid = uuid (str)

    TwoLevelHintsCommand
    twoLevelHints = list of TwoLevelHintData

    DylibCommand
    name = name of dylib (str)

    DylinkerCommand
    name = name of dynamic linker
    """

class SectionData(Container):
    """
    header = Section

    """

class TwoLevelHintData(Container):
    """
    header = TwoLevelHint
    """

class MachO(Binary):

    def __init__(self, fileName, fileContent=None):
        super(MachO, self).__init__(fileName, fileContent)

        self.__fatArches = self._tryParseFat(self._bytes)
        if self.__fatArches:
            return

        self.__classes = self._getSuitableClasses(self._bytes)
        if not self.__classes:
            raise BinaryError('Bad architecture')

        self.__machHeader = self._parseMachHeader(self._bytes)
        self.__loadCommands = self._parseLoadCommands(self._bytes, self.machHeader)

    @property
    def _classes(self):
        return self.__classes

    @property
    def machHeader(self):
        assert not self.__fatArches
        return self.__machHeader

    @property
    def isFat(self):
        return self.__fatArches is not None

    @property
    def fatArches(self):
        assert self.__fatArches
        return self.__fatArches

    @property
    def loadCommands(self):
        assert not self.__fatArches
        return self.__loadCommands

    @property
    def entryPoint(self):
        return 0x0

    @property
    def imageBase(self):
        for loadCommand in self.loadCommands:
            if loadCommand.header.cmd == LC.SEGMENT or loadCommand.header.cmd == LC.SEGMENT_64:
                for section in loadCommand.sections:
                    if section.header.flags & S_ATTR.SOME_INSTRUCTIONS  or section.header.flags & S_ATTR.PURE_INSTRUCTIONS:
                        return section.header.addr - section.header.offset
        return 0x0

    @property
    def type(self):
        return 'MachO'

    def _getSuitableClasses(self, data):
        classes = None
        if data[7] == 0:
            classes = LSB_32
        elif data[7] == 1:
            classes = LSB_64

        return classes

    def _tryParseFat(self, data):
        header = FatHeader.from_buffer(data)
        if header.magic != 0xcafebabe:
            return None

        offset = sizeof(FatHeader)
        arches = []

        for i in range(header.nfat_arch):
            arch = FatArch.from_buffer(bytearray(data[offset:]))
            cputype = CpuType[arch.cputype]

            thin_data = bytearray(data[arch.offset : arch.offset+arch.size])
            thin = MachO('{}.{}'.format(self.fileName, cputype), thin_data)
            arches.append(thin)

            offset += sizeof(FatArch)

        return arches

    def _parseMachHeader(self, data):
        header = self._classes.MachHeader.from_buffer(data)

        if header.magic not in (0xfeedface, 0xfeedfacf, 0xcefaedfe, 0xcffaedfe):
            raise BinaryError('No valid MachO file')

        return MachHeaderData(header=header)

    def _parseLoadCommands(self, data, machHeader):
        offset = sizeof(self._classes.MachHeader)
        load_commands = []
        for i in range(machHeader.header.ncmds):
            command = LoadCommand.from_buffer(data, offset)
            raw = (c_ubyte * command.cmdsize).from_buffer(data, offset)

            if command.cmd == LC.SEGMENT or command.cmd == LC.SEGMENT_64:
                command = self.__parseSegmentCommand(data, offset, raw)
            elif command.cmd == LC.UUID:
                command = self.__parseUuidCommand(data, offset, raw)
            elif command.cmd == LC.TWOLEVEL_HINTS:
                command = self.__parseTwoLevelHintCommand(data, offset, raw)
            elif command.cmd in (LC.ID_DYLIB, LC.LOAD_DYLIB, LC.LOAD_WEAK_DYLIB):
                command = self.__parseDylibCommand(data, offset, raw)
            elif command.cmd in (LC.ID_DYLINKER, LC.LOAD_DYLINKER):
                command = self.__parseDylibCommand(data, offset, raw)
            # Seva patch
            elif command.cmd == LC.SYMTAB:
                uc = SymtabCommand.from_buffer(data, offset)
                command = LoadCommandData(header=uc)
            else:
                command = LoadCommandData(header=command)

            load_commands.append(command)

            offset += command.header.cmdsize

        return load_commands

    def __parseSegmentCommand(self, data, offset, raw):
        sc = self._classes.SegmentCommand.from_buffer(data, offset)
        sections = self.__parseSections(data, sc, offset+sizeof(self._classes.SegmentCommand))
        return LoadCommandData(header=sc, name=sc.segname.decode('ASCII'), sections=sections, bytes=bytearray(raw), raw=raw)

    def __parseUuidCommand(self, data, offset, raw):
        uc = UuidCommand.from_buffer(data, offset)
        return LoadCommandData(header=uc, uuid=hexlify(uc.uuid), bytes=bytearray(raw), raw=raw)

    def __parseTwoLevelHintCommand(self, data, offset, raw):
        tlhc = TwoLevelHintsCommand.from_buffer(data, offset)
        hints = self.__parseTwoLevelHints(data, tlhc)
        return LoadCommandData(header=tlhc, twoLevelHints=hints, bytes=bytearray(raw), raw=raw)

    def __parseTwoLevelHints(self, data, twoLevelHintCommand):
        offset = twoLevelHintCommand.offset
        hints = []
        for i in twoLevelHintCommand.nhints:
            tlh = TwoLevelHint.from_buffer(data, offset)
            hints.append(TwoLevelHintData(header=tlh))

        return hints

    def __parseDylibCommand(self, data, offset, raw):
        dc = DylibCommand.from_buffer(data, offset)
        name = get_str(raw, dc.dylib.name.offset)
        return LoadCommandData(header=dc, bytes=bytearray(raw), raw=raw, name=name)

    def __parseDylinkerCommand(self, data, offset, raw):
        dc = DylinkerCommand.from_buffer(data, offset)
        name = get_str(raw, dc.name.offset)
        return LoadCommandData(header=dc, bytes=bytearray(raw), raw=raw, name=name)

    def __parseSections(self, data, segment, offset):

        sections = []
        for i in range(segment.nsects):
            sec = self._classes.Section.from_buffer(data, offset)
            if self._classes.Section == LSB_64_Section:
                offset += 80
            else:
                offset += sizeof(self._classes.Section)

            if sec.offset > 0:
                raw = (c_ubyte * sec.size).from_buffer(data, sec.offset)
                bytes = bytearray(raw)
            else:
                raw = None
                bytes = None
            sections.append(SectionData(header=sec, name=sec.sectname.decode('ASCII'), bytes=bytes, raw=raw))

        return sections

    @classmethod
    def isSupportedContent(cls, fileContent):
        """Returns if the files are valid for this filetype"""
        magic = bytearray(fileContent)[:4]
        magics = (
            p('>I', 0xfeedface),
            p('>I', 0xfeedfacf),
            p('>I', 0xcafebabe),

            p('<I', 0xfeedface),
            p('<I', 0xfeedfacf),
            p('<I', 0xcafebabe),
        )
        return magic in magics

```

`dwex/filebytes/pe.py`:

```py
# coding=utf-8
# Copyright 2018 Sascha Schirra
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
# list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
# this list of conditions and the following disclaimer in the documentation
# and/or other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its contributors
# may be used to endorse or promote products derived from this software without
# specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" A ND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


from .enum import Enum
from .binary import *

###################### PE General #################

class IMAGE_FILE_MACHINE(Enum):
    UKNOWN = 0
    AM33 = 0x1d3
    AMD64 = 0x8664
    ARM = 0x1c0
    ARMV = 0x1c4
    EBC = 0xebc
    I386 = 0x14c
    IA64 = 0x200
    M32R = 0x9041
    MIPS16 = 0x266
    MIPSFPU = 0x366
    MIPSFPU16 = 0x466
    POWERPC = 0x1f0
    POWERPCFP = 0x1f1
    THUMB = 0x1c2
    WCEMIPSV2 = 0x169
    ARM64 = 0xaa64    

class IMAGE_SCN(Enum):
    TYPE_NO_PAD = 0x00000008
    CNT_CODE = 0x00000020
    CNT_INITIALIZED_DATA = 0x00000040
    CNT_UNINITIALIZED_DATA = 0x00000080
    LNK_OTHER = 0x00000100
    LNK_INFO = 0x00000200
    LNK_REMOVE = 0x00000800
    LNK_COMDAT = 0x00001000
    GPREL = 0x00008000
    MEM_PURGEABLE = 0x00020000
    MEM_LOCKED = 0x00040000
    MEM_PRELOAD = 0x00080000
    ALIGN_1BYTES = 0x00100000
    ALIGN_2BYTES = 0x00200000
    ALIGN_4BYTES = 0x00300000
    ALIGN_8BYTES = 0x00400000
    ALIGN_16BYTES = 0x00500000
    ALIGN_32BYTES = 0x00600000
    ALIGN_64BYTES = 0x00700000
    ALIGN_128BYTES = 0x00800000
    ALIGN_256BYTES = 0x00900000
    ALIGN_512BYTES = 0x00A00000
    ALIGN_1024BYTES = 0x00B00000
    ALIGN_2048BYTES = 0x00C00000
    ALIGN_4096BYTES = 0x00D00000
    ALIGN_8192BYTES = 0x00E00000
    LNK_NRELOC_OVFL = 0x01000000
    MEM_WRITE = 0x80000000
    MEM_READ = 0x4000000



class ImageDllCharacteristics(Enum):
    DYNAMIC_BASE = 0x0040
    FORCE_INTEGRITY = 0x0080
    NX_COMPAT = 0x0100
    NO_ISOLATION = 0x0200
    NO_SEH = 0x0400
    NO_BIND = 0x0800
    APP_CONTAINER = 0x1000
    WDM_DRIVER = 0x2000
    CONTROL_FLOW_GUARD = 0x4000
    TERMINAL_SERVER_AWARE = 0x8000


class ImageDirectoryEntry(Enum):
    EXPORT = 0
    IMPORT = 1
    RESOURCE = 2
    EXCEPTION = 3
    SECURITY = 4
    BASERELOC = 5
    DEBUG = 6
    COPYRIGHT = 7
    GLOBALPTR = 8
    TLS = 9
    LOAD_CONFIG = 10
    BOUND_IMPORT = 11
    IAT = 12
    DELAY_IMPORT = 13
    COM_DESCRIPTOR = 14
    NUMBER_OF_DIRECTORY_ENTRIES = 16


class IMAGE_DOS_HEADER(Structure):
    _fields_ = [('e_magic', c_char * 2),
                ('e_cblp', c_ushort),
                ('e_cp', c_ushort),
                ('e_crlc', c_ushort),
                ('e_cparhdr', c_ushort),
                ('e_minalloc', c_ushort),
                ('e_maxalloc', c_ushort),
                ('e_ss', c_ushort),
                ('e_sp', c_ushort),
                ('e_csum', c_ushort),
                ('e_ip', c_ushort),
                ('e_cs', c_ushort),
                ('e_lfarlc', c_ushort),
                ('e_ovno', c_ushort),
                ('e_res', c_ushort * 4),
                ('e_oemid', c_ushort),
                ('e_oeminfo', c_ushort),
                ('e_res2', c_ushort * 10),
                ('e_lfanew', c_uint)]       # Offset zum PE-Header


class IMAGE_FILE_HEADER(Structure):
    _fields_ = [('Machine', c_ushort),
                ('NumberOfSections', c_ushort),
                ('TimeDateStamp', c_uint),
                ('PointerToSymbolTable', c_uint),
                ('NumberOfSymbols', c_uint),
                ('SizeOfOptionalHeader', c_ushort),
                ('Characteristics', c_ushort)
                ]


class IMAGE_DATA_DIRECTORY(Structure):
    _fields_ = [('VirtualAddress', c_uint),
                ('Size', c_uint)]


class IMAGE_SECTION_HEADER(Structure):
    _fields_ = [('Name', c_char * 8),
                ('PhysicalAddress_or_VirtualSize', c_uint),
                ('VirtualAddress', c_uint),
                ('SizeOfRawData', c_uint),
                ('PointerToRawData', c_uint),
                ('PointerToRelocations', c_uint),
                ('PointerToLinenumbers', c_uint),
                ('NumberOfRelocations', c_ushort),
                ('NumberOfLinenumbers', c_ushort),
                ('Characteristics', c_uint)]


class IMAGE_IMPORT_BY_NAME(Structure):
    _fields_ = [('Hint', c_ushort),
                ('Name', c_char)]


class IMAGE_IMPORT_DESCRIPTOR(Structure):
    _fields_ = [('OriginalFirstThunk', c_uint),
                ('TimeDateStamp', c_uint),
                ('ForwarderChain', c_uint),
                ('Name', c_uint),
                ('FirstThunk', c_uint)]

class IMAGE_EXPORT_DIRECTORY(Structure):
    _fields_ = [('Characteristics',c_uint),
                ('TimeDateStamp',c_uint),
                ('MajorVersion', c_ushort),
                ('MinorVersion', c_ushort),
                ('Name',c_uint),
                ('Base',c_uint),
                ('NumberOfFunctions',c_uint),
                ('NumberOfNames',c_uint),
                ('AddressOfFunctions',c_uint),
                ('AddressOfNames',c_uint),
                ('AddressOfNameOrdinals',c_uint)
                ]

class GUARD_CFF_ENTRY(Structure):
    _fields_ = [('rva',c_uint),
                ('flag', c_byte)]

##################### PE32 ########################

class IMAGE_OPTIONAL_HEADER(Structure):
    _fields_ = [('Magic', c_ushort),
                ('MajorLinkerVersion', c_byte),
                ('MinorLinkerVersion', c_byte),
                ('SizeOfCode', c_uint),
                ('SizeOfInitializedData', c_uint),
                ('SizeOfUninitializedData', c_uint),
                ('AddressOfEntryPoint', c_uint),
                ('BaseOfCode', c_uint),
                ('BaseOfData', c_uint),
                ('ImageBase', c_uint),
                ('SectionAlignment', c_uint),
                ('FileAlignment', c_uint),
                ('MajorOperatingSystemVersion', c_ushort),
                ('MinorOperatingSystemVersion', c_ushort),
                ('MajorImageVersion', c_ushort),
                ('MinorImageVersion', c_ushort),
                ('MajorSubsystemVersion', c_ushort),
                ('MinorSubsystemVersion', c_ushort),
                ('Win32VersionValue', c_uint),
                ('SizeOfImage', c_uint),
                ('SizeOfHeaders', c_uint),
                ('CheckSum', c_uint),
                ('Subsystem', c_ushort),
                ('DllCharacteristics', c_ushort),
                ('SizeOfStackReserve', c_uint),
                ('SizeOfStackCommit', c_uint),
                ('SizeOfHeapReserve', c_uint),
                ('SizeOfHeapCommit', c_uint),
                ('LoaderFlags', c_uint),
                ('NumberOfRvaAndSizes', c_uint),
                ('DataDirectory', IMAGE_DATA_DIRECTORY * 16)]


class PE32_IMAGE_NT_HEADERS(Structure):
    _fields_ = [('Signature', c_char * 4),
                ('FileHeader', IMAGE_FILE_HEADER),
                ('OptionalHeader', IMAGE_OPTIONAL_HEADER)]
    
class PE32_IMAGE_THUNK_DATA(Union):
    _fields_ = [('ForwarderString', c_uint),
                ('Function', c_uint),
                ('Ordinal', c_uint),
                ('AddressOfData', c_uint)]

class PE32(object):
    IMAGE_NT_HEADERS = PE32_IMAGE_NT_HEADERS
    IMAGE_THUNK_DATA = PE32_IMAGE_THUNK_DATA


class IMAGE_LOAD_CONFIG_DIRECTORY32(Structure):
    _fields_ = [('Size', c_uint),
                ('TimeDateStamp', c_uint),
                ('MajorVersion', c_ushort),
                ('MinorVersion', c_ushort),
                ('GlobalFlagsClear', c_uint),
                ('GlobalFlagsSet', c_uint),
                ('CriticalSectionDefaultTimeout', c_uint),
                ('DeCommitFreeBLockThreshold', c_uint),
                ('DeCommitTotalFreeThreshold', c_uint),
                ('LockPrefixTable', c_uint),
                ('MaximumAllocationSize', c_uint),
                ('VirtualMemoryThreshold', c_uint),
                ('ProcessHeapFlags', c_uint),
                ('ProcessAffinityMask', c_uint),
                ('CSDVersion', c_ushort),
                ('Reserved1', c_ushort),
                ('EditList', c_uint),
                ('SecurityCookie', c_uint),
                ('SEHandlerTable', c_uint),
                ('SEHandlerCount', c_uint),
                ('GuardCFCheckFunctionPointer', c_uint),
                ('Reserved2', c_uint),
                ('GuardCFFunctionTable', c_uint),
                ('GuardCFFunctionCount', c_uint),
                ('GuardFlags', c_uint)]


######################### PE64 ########################

class IMAGE_OPTIONAL_HEADER_PE32_PLUS(Structure):
    _fields_ = [('Magic', c_ushort),
                ('MajorLinkerVersion', c_ubyte),
                ('MinorLinkerVersion', c_ubyte),
                ('SizeOfCode', c_uint),
                ('SizeOfInitializedData', c_uint),
                ('SizeOfUninitializedData', c_uint),
                ('AddressOfEntryPoint', c_uint),
                ('BaseOfCode', c_uint),
                ('ImageBase', c_ulonglong),
                ('SectionAlignment', c_uint),
                ('FileAlignment', c_uint),
                ('MajorOperatingSystemVersion', c_ushort),
                ('MinorOperatingSystemVersion', c_ushort),
                ('MajorImageVersion', c_ushort),
                ('MinorImageVersion', c_ushort),
                ('MajorSubsystemVersion', c_ushort),
                ('MinorSubsystemVersion', c_ushort),
                ('Win32VersionValue', c_uint),
                ('SizeOfImage', c_uint),
                ('SizeOfHeaders', c_uint),
                ('CheckSum', c_uint),
                ('Subsystem', c_ushort),
                ('DllCharacteristics', c_ushort),
                ('SizeOfStackReserve', c_ulonglong),
                ('SizeOfStackCommit', c_ulonglong),
                ('SizeOfHeapReserve', c_ulonglong),
                ('SizeOfHeapCommit', c_ulonglong),
                ('LoaderFlags', c_uint),
                ('NumberOfRvaAndSizes', c_uint),
                ('DataDirectory', IMAGE_DATA_DIRECTORY * 16)]


class PE64_IMAGE_NT_HEADERS(Structure):
    _fields_ = [('Signature', c_char * 4),
                ('FileHeader', IMAGE_FILE_HEADER),
                ('OptionalHeader', IMAGE_OPTIONAL_HEADER_PE32_PLUS)]
    
class PE64_IMAGE_THUNK_DATA(Union):
    _fields_ = [('ForwarderString', c_ulonglong),
                ('Function', c_ulonglong),
                ('Ordinal', c_ulonglong),
                ('AddressOfData', c_ulonglong)]


class PE64(object):
    IMAGE_NT_HEADERS = PE64_IMAGE_NT_HEADERS
    IMAGE_THUNK_DATA = PE64_IMAGE_THUNK_DATA


class IMAGE_LOAD_CONFIG_DIRECTORY64(Structure):
    _fields_ = [('Size', c_uint),
                ('TimeDateStamp', c_uint),
                ('MajorVersion', c_ushort),
                ('MinorVersion', c_ushort),
                ('GlobalFlagsClear', c_uint),
                ('GlobalFlagsSet', c_uint),
                ('CriticalSectionDefaultTimeout', c_uint),
                ('DeCommitFreeBLockThreshold', c_ulonglong),
                ('DeCommitTotalFreeThreshold', c_ulonglong),
                ('LockPrefixTable', c_ulonglong),
                ('MaximumAllocationSize', c_ulonglong),
                ('VirtualMemoryThreshold', c_ulonglong),
                ('ProcessAffinityMask', c_ulonglong),
                ('ProcessHeapFlags', c_uint),
                ('CSDVersion', c_ushort),
                ('Reserved1', c_ushort),
                ('EditList', c_ulonglong),
                ('SecurityCookie', c_ulonglong),
                ('SEHandlerTable', c_ulonglong),
                ('SEHandlerCount', c_ulonglong),
                ('GuardCFCheckFunctionPointer', c_ulonglong),
                ('Reserved2', c_ulonglong),
                ('GuardCFFunctionTable', c_ulonglong),
                ('GuardCFFunctionCount', c_ulonglong),
                ('GuardFlags', c_uint)]

##################### Container ###################


def to_offset(addr, section):
    return addr - section.header.VirtualAddress

def to_raw_address(addr, section):
        """Converts the addr from a rva to a pointer to raw data in the file"""
        return addr - section.header.VirtualAddress + section.header.PointerToRawData

class ImageDosHeaderData(Container):
    """
    header = IMAGE_DOS_HEADER
    """

class ImageNtHeaderData(Container):
    """
    header = IMAGE_NT_HEADERS
    """

class SectionData(Container):
    """
    header = IMAGE_SECTION_HEADER
    name = name of the section (str)
    bytes = bytes of section (bytearray)
    raw = bytes of section (c_ubyte_array)
    """

class DataDirectoryData(Container):
    """
    header = IMAGE_DATA_DIRECTORY
    """

class ImportDescriptorData(Container):
    """
    header = IMAGE_IMPORT_DESCRIPTOR
    dllName = name of dll (str)
    importNameTable = list of IMAGE_THUNK_DATA
    importAddressTable = list of IMAGE_THUNK_DATA
    """

class ImportByNameData(Container):
    """
    header = IMAGE_IMPORT_BY_NAME
    name = name of function (str)
    """


class ThunkData(Container):
    """
    header = IMAGE_THUNK_DATA
    rva = relative virtual address of thunk
    ordinal = None | Ordinal
    importByName = None| ImportByNameData
    """

class ExportDirectoryData(Container):
    """
    header = IMAGE_EXPORT_DIRECTORY
    name = name of dll (str)
    functions = list of FunctionData
    """

class LoadConfigData(Container):
    """"
    header = IMAGE_LOAD_CONFIG_DIRECTORY32/IMAGE_LOAD_CONFIG_DIRECTORY64
    cfGuardedFunctions = list of relative virtual addresses (RVA) of cfg allowed call/jmp targets. Empty if CFG not supported
    """

class FunctionData(Container):
    """
    name = name of the function (str)
    ordinal = ordinal (int)
    rva = relative virtual address of function (int)
    """

def checkOffset(offset, section):
    size = len(section.raw)
    if offset < 0 or offset > size:
        raise BinaryError('Invalid offset: {} (data size: {})'.format(offset, size))

class PE(Binary):

    def __init__(self, fileName, fileContent=None, parse_header_only=False):
        super(PE, self).__init__(fileName, fileContent)



        self.__imageDosHeader = self._parseImageDosHeader(self._bytes)
        self.__classes = self._getSuitableClasses(self._bytes, self.imageDosHeader)

        if not self.__classes:
            raise BinaryError('Bad architecture')

        self.__imageNtHeaders = self._parseImageNtHeaders(self._bytes, self.imageDosHeader)
        self.__sections = self._parseSections(self._bytes, self.imageDosHeader, self.imageNtHeaders, parse_header_only=parse_header_only)

        if parse_header_only:
            self.__dataDirectory = None
        else:
            self.__dataDirectory = self._parseDataDirectory(self._bytes, self.sections, self.imageNtHeaders)


    @property
    def _classes(self):
        return self.__classes

    @property
    def imageDosHeader(self):
        return self.__imageDosHeader

    @property
    def imageNtHeaders(self):
        return self.__imageNtHeaders

    @property
    def sections(self):
        return self.__sections

    @property
    def dataDirectory(self):
        return self.__dataDirectory


    @property
    def entryPoint(self):
        return self.imageNtHeaders.header.OptionalHeader.ImageBase + self.imageNtHeaders.header.OptionalHeader.AddressOfEntryPoint

    @property
    def imageBase(self):
        return self.imageNtHeaders.header.OptionalHeader.ImageBase

    @property
    def type(self):
        return 'PE'

    def _getSuitableClasses(self, data, imageDosHeader):
        """Returns the class which holds the suitable classes for the loaded file"""
        classes = None
        machine = IMAGE_FILE_MACHINE[c_ushort.from_buffer(data,imageDosHeader.header.e_lfanew+4).value]

        if machine in (IMAGE_FILE_MACHINE.AMD64, IMAGE_FILE_MACHINE.ARM64, IMAGE_FILE_MACHINE.IA64):
            classes = PE64
        else:
            classes = PE32

        return classes

    def _parseImageDosHeader(self, data):
        """Returns the ImageDosHeader"""
        ioh = IMAGE_DOS_HEADER.from_buffer(data)
        if ioh.e_magic != b'MZ':
            raise BinaryError('No valid PE/COFF file')

        return ImageDosHeaderData(header=ioh)

    def _parseImageNtHeaders(self, data, imageDosHeader):
        """Returns the ImageNtHeaders"""
        inth = self._classes.IMAGE_NT_HEADERS.from_buffer(data, imageDosHeader.header.e_lfanew)

        if inth.Signature != b'PE':
            raise BinaryError('No valid PE/COFF file')

        return ImageNtHeaderData(header=inth)

    def _parseSections(self, data, imageDosHeader, imageNtHeaders, parse_header_only=False):
        """Parses the sections in the memory and returns a list of them"""
        sections = []

        optional_header_offset = imageDosHeader.header.e_lfanew + 4 + sizeof(IMAGE_FILE_HEADER)
        offset = optional_header_offset + imageNtHeaders.header.FileHeader.SizeOfOptionalHeader  # start reading behind the dos- and ntheaders

        image_section_header_size = sizeof(IMAGE_SECTION_HEADER)
        IMAGE_SIZEOF_SYMBOL = 18
        strtable_offset = imageNtHeaders.header.FileHeader.PointerToSymbolTable + IMAGE_SIZEOF_SYMBOL * imageNtHeaders.header.FileHeader.NumberOfSymbols

        for sectionNo in range(imageNtHeaders.header.FileHeader.NumberOfSections):
            ishdr = IMAGE_SECTION_HEADER.from_buffer(data, offset)

            if parse_header_only:
                raw = None
                bytes_ = bytearray()
            else:
                size = ishdr.SizeOfRawData
                raw = (c_ubyte * size).from_buffer(data, ishdr.PointerToRawData)
                bytes_ = bytearray(raw)

            secname = ishdr.Name.decode('ASCII', errors='ignore')
            if secname.startswith('/'):
                name_offset = int(secname[1:]) + strtable_offset
                s = bytearray()
                while self._bytes[name_offset] != 0:
                    s.append(self._bytes[name_offset])
                    name_offset += 1
                secname = bytes(s).decode('ASCII', errors='ignore')

            sections.append(SectionData(header=ishdr, name=secname, bytes=bytes_, raw=raw))

            offset += image_section_header_size

        return sections

    def _getSectionForDataDirectoryEntry(self, data_directory_entry, sections):
        """Returns the section which contains the data of DataDirectory"""
        for section in sections:
            if data_directory_entry.VirtualAddress >= section.header.VirtualAddress and \
            data_directory_entry.VirtualAddress < section.header.VirtualAddress + section.header.SizeOfRawData :

                return section

    def _parseDataDirectory(self, data, sections, imageNtHeaders):
        # Seva:
        return None

        """Parses the entries of the DataDirectory and returns a list of the content"""
        data_directory_data_list = [None for i in range(15)]

        # parse DataDirectory[Export]
        export_data_directory = imageNtHeaders.header.OptionalHeader.DataDirectory[ImageDirectoryEntry.EXPORT]
        export_section = self._getSectionForDataDirectoryEntry(export_data_directory, sections)
        export_data_directory_data = self._parseDataDirectoryExport(data, export_data_directory, export_section)
        data_directory_data_list[ImageDirectoryEntry.EXPORT] = export_data_directory_data

        # parse DataDirectory[Import]
        import_data_directory = imageNtHeaders.header.OptionalHeader.DataDirectory[ImageDirectoryEntry.IMPORT]
        import_section = self._getSectionForDataDirectoryEntry(import_data_directory, sections)
        import_data_directory_data = self._parseDataDirectoryImport(import_data_directory, import_section)
        data_directory_data_list[ImageDirectoryEntry.IMPORT] = import_data_directory_data

        # parse DataDirectory[LOAD_CONFIG]
        loadconfig_data_directory = imageNtHeaders.header.OptionalHeader.DataDirectory[ImageDirectoryEntry.LOAD_CONFIG]
        loadconfig_section = self._getSectionForDataDirectoryEntry(loadconfig_data_directory, sections)
        loadconfig_data = self._parseLoadConfig(loadconfig_data_directory, loadconfig_section)
        data_directory_data_list[ImageDirectoryEntry.LOAD_CONFIG] = loadconfig_data

        return data_directory_data_list

    def _parseDataDirectoryExport(self, data, dataDirectoryEntry, exportSection):
        """Parses the EmportDataDirectory and returns an instance of ExportDirectoryData"""
        if not exportSection:
            return
        functions = []
        export_directory = IMAGE_EXPORT_DIRECTORY.from_buffer(exportSection.raw, to_offset(dataDirectoryEntry.VirtualAddress, exportSection))
        offset = to_offset(export_directory.Name, exportSection)

        checkOffset(offset, exportSection)
        name = get_str(exportSection.raw, offset)

        offsetOfNames = to_offset(export_directory.AddressOfNames, exportSection)
        offsetOfAddress = to_offset(export_directory.AddressOfFunctions, exportSection)
        offsetOfNameOrdinals = to_offset(export_directory.AddressOfNameOrdinals, exportSection)
        for i in range(export_directory.NumberOfNames):
            name_address = c_uint.from_buffer(exportSection.raw, offsetOfNames).value
            name_offset = to_offset(name_address, exportSection)

            checkOffset(name_offset, exportSection)
            func_name = get_str(exportSection.raw, name_offset)
            ordinal = c_ushort.from_buffer(exportSection.raw, offsetOfNameOrdinals).value
            func_addr = c_uint.from_buffer(exportSection.raw, offsetOfAddress).value

            offsetOfNames += 4
            offsetOfAddress += 4
            offsetOfNameOrdinals += 2
            functions.append(FunctionData(name=func_name, rva=func_addr, ordinal=ordinal))

        return ExportDirectoryData(header=export_directory, name=name, functions=functions)

    def _parseDataDirectoryImport(self, dataDirectoryEntry, importSection):
        """Parses the ImportDataDirectory and returns a list of ImportDescriptorData"""
        if not importSection:
            return


        raw_bytes = (c_ubyte * dataDirectoryEntry.Size).from_buffer(importSection.raw, to_offset(dataDirectoryEntry.VirtualAddress, importSection))
        offset = 0
        import_descriptors = []
        while True:
            import_descriptor = IMAGE_IMPORT_DESCRIPTOR.from_buffer(raw_bytes, offset)


            if import_descriptor.OriginalFirstThunk == 0:
                break
            else:
                nameOffset = to_offset(import_descriptor.Name, importSection)

                checkOffset(nameOffset, importSection)
                dllName = get_str(importSection.raw, nameOffset)

                import_name_table =  self.__parseThunks(import_descriptor.OriginalFirstThunk, importSection)
                import_address_table =  self.__parseThunks(import_descriptor.FirstThunk, self._getSectionByRVA(import_descriptor.FirstThunk))

                import_descriptors.append(ImportDescriptorData(header=import_descriptor, dllName=dllName, importNameTable=import_name_table, importAddressTable=import_address_table))
            offset += sizeof(IMAGE_IMPORT_DESCRIPTOR)
        return import_descriptors

    def _getSectionByRVA(self, va):
        for section in self.sections:
            address = section.header.VirtualAddress
            SizeOfRawData = section.header.SizeOfRawData
            if  address <= va and va < (address + SizeOfRawData):
                return section

        return

    def _parseLoadConfig(self, loadConfigEntry, loadconfigSection):
        if not loadconfigSection:
            return

        if self._classes == PE64:
            load_config_directory = IMAGE_LOAD_CONFIG_DIRECTORY64.from_buffer(
                loadconfigSection.raw, to_offset(loadConfigEntry.VirtualAddress, loadconfigSection))

            pass

        elif self._classes == PE32:
            load_config_directory = IMAGE_LOAD_CONFIG_DIRECTORY32.from_buffer(
                loadconfigSection.raw, to_offset(loadConfigEntry.VirtualAddress, loadconfigSection))

            pass
        else:
            pass

        guardCFTableRVA = load_config_directory.GuardCFFunctionTable - self.imageBase
        section = self._getSectionByRVA(guardCFTableRVA)
        CfGuardedFunctions = set()
        if section:
            sectionOffset = guardCFTableRVA - section.header.VirtualAddress

            # loop through the ControlFlow Guard Function table
            for i in range(0, load_config_directory.GuardCFFunctionCount):
                cffEntry = GUARD_CFF_ENTRY.from_buffer(section.raw, sectionOffset)
                CfGuardedFunctions.add(cffEntry.rva)
                sectionOffset += 5

        return LoadConfigData(header=load_config_directory, cfGuardedFunctions=CfGuardedFunctions )

    def __parseThunks(self, thunkRVA, importSection):
        """Parses the thunks and returns a list"""
        offset = to_offset(thunkRVA, importSection)
        table_offset = 0
        thunks = []
        IMAGE_THUNK_DATA = self._classes.IMAGE_THUNK_DATA
        thunkSize = sizeof(IMAGE_THUNK_DATA)
        ordinalMask = 1 << (thunkSize * 8 - 1)
        while True:
            thunk = IMAGE_THUNK_DATA.from_buffer(importSection.raw, offset)
            offset += thunkSize
            if thunk.Ordinal == 0:
                break
            thunkData = ThunkData(header=thunk, rva=table_offset+thunkRVA, ordinal=None, importByName=None)
            if thunk.Ordinal & ordinalMask != 0:
                thunkData.ordinal = thunk.header.Ordinal & 0xffff
            else:
                nameSection = self._getSectionByRVA(thunk.AddressOfData)
                nameOffset = to_offset(thunk.AddressOfData, nameSection)
                ibn = IMAGE_IMPORT_BY_NAME.from_buffer(nameSection.raw, nameOffset)

                checkOffset(nameOffset+2, nameSection)
                name = get_str(nameSection.raw, nameOffset+2)
                thunkData.importByName = ImportByNameData(header=ibn, hint=ibn.Hint, name=name)
            thunks.append(thunkData)
            table_offset += 4
        return thunks

    @classmethod
    def isSupportedContent(cls, fileContent):
        """Returns if the files are valid for this filetype"""
        return bytearray(fileContent)[:2] == b'MZ'

```

`dwex/formats.py`:

```py
from collections import namedtuple
import io, os
from os import path, listdir
from elftools.dwarf.dwarfinfo import DWARFInfo, DebugSectionDescriptor, DwarfConfig

from .fx import wait_with_events

# This doesn't depend on Qt
# The dependency on filebytes only lives here
# Format codes: 0 = ELF, 1 = MACHO, 2 = PE, 3 - WASM, 4 - ELF inside A, 5 - arch specific MachO inside A, 6 - MachO inside A inside a fat binary

class FormatError(Exception):
    def __init__(self, s):
        Exception.__init__(self, s)

def decorate_di(di, f, a, sa):
    di._format = f
    di._arch_code = a
    di._start_address = sa
    di._frames = None
    di._use_siblings = not(f in (0, 4) and a in ("EM_PPC", 'EM_PPC64'))

def read_pe(filename):
    from .filebytes.pe import PE, IMAGE_FILE_MACHINE, BinaryError
    import struct, zlib

    try:
        pefile = PE(filename)

        # Section's real size might be padded - see https://github.com/sashs/filebytes/issues/28
        sections = [(section.name if section.name[1] != 'z' else '.' + section.name[2:],
            section.name[1] == 'z',
            section,
            section.header.PhysicalAddress_or_VirtualSize,
            section.header.SizeOfRawData)
            for section in pefile.sections
            if section.name.startswith('.debug') or section.name.startswith('.zdebug')]
        
        def read_section(name, is_compressed, section, virtual_size, raw_size):
            data = section.bytes
            size = raw_size if virtual_size == 0 else min((raw_size, virtual_size))
            if is_compressed:
                if size < 12:
                    raise FormatError("Compressesed section %s is unexpectedly short." % (name,))
                if data[0:4] != b'ZLIB':
                    raise FormatError("Unsupported format in compressesed section %s, ZLIB is expected." % (name,))
                (size,) = struct.unpack_from('>Q', data, offset=4) #TODO, replace, no need to bring structs over this
                data = zlib.decompress(data[12:])
                if len(data) != size:
                    raise FormatError("Wrong uncompressed size in compressesed section %s: expected %d, got %d." % (name, size, len(data)))
            return DebugSectionDescriptor(io.BytesIO(data), name, None, size, 0)

        data = {sec[0]: read_section(*sec) for sec in sections}

        if not '.debug_info' in data:
            return None

        machine = pefile.imageNtHeaders.header.FileHeader.Machine
        is64 = machine in (IMAGE_FILE_MACHINE.AMD64, IMAGE_FILE_MACHINE.ARM64, IMAGE_FILE_MACHINE.IA64) # There are also some exotic architectures...
        di = DWARFInfo(
            config = DwarfConfig(
                little_endian = True,
                default_address_size = 8 if is64 else 4,
                machine_arch = IMAGE_FILE_MACHINE[machine].name
            ),
            debug_info_sec = data['.debug_info'],
            debug_aranges_sec = data.get('.debug_aranges'),
            debug_abbrev_sec = data.get('.debug_abbrev'),
            debug_frame_sec = data.get('.debug_frame'),
            eh_frame_sec = None, # Unwind/exceptino info is stored in PE elsewhere
            debug_str_sec = data.get('.debug_str'),
            debug_loc_sec = data.get('.debug_loc'),
            debug_ranges_sec = data.get('.debug_ranges'),
            debug_line_sec = data.get('.debug_line'),
            debug_pubtypes_sec = data.get('.debug_pubtypes'),
            debug_pubnames_sec = data.get('.debug_pubnames'),
            debug_addr_sec = data.get('.debug_addr'),
            debug_str_offsets_sec = data.get('.debug_str_offsets'),
            debug_line_str_sec = data.get('.debug_line_str'),
            debug_loclists_sec = data.get('.debug_loclists'),
            debug_rnglists_sec = data.get('.debug_rnglists'),
            debug_sup_sec = data.get('.debug_sup'),
            gnu_debugaltlink_sec = data.get('.gnu_debugaltlink'),
            debug_types_sec = data.get('.debug_types')
        )
        decorate_di(di, 2, machine, pefile.imageNtHeaders.header.OptionalHeader.ImageBase)
        di._frames = None
        return di
    except BinaryError as err:
        raise FormatError("Error parsing the binary.\n" + str(err))

########################################################################
######################### Mach-O
########################################################################

# CPU type, CPU subtupe - numeric
def make_macho_arch_name_raw(c, st):
    from .filebytes.mach_o import CpuType, CpuSubTypeARM, CpuSubTypeARM64
    flavor = ''
    if st != 0:
        if c == CpuType.ARM:
            flavor = CpuSubTypeARM[st].name
        elif c == CpuType.ARM64:
            # With ARM64E, ABI flags are in the subuppermost byte
            # They don't seem to be acknowledged by dump tools
            # https://llvm.org/doxygen/BinaryFormat_2MachO_8h.html
            flavor = CpuSubTypeARM64[st & 0xffffff].name
    return CpuType[c].name + flavor

# Arch + flavor where flavor matters
# The arg is a slice object or a MachO object
def make_macho_arch_name(macho):
    h = macho.machHeader.header
    return make_macho_arch_name_raw(h.cputype, h.cpusubtype)
        
# For debugging purposes only - dump individual debug related sections in a Mach-O file/slice as files
def macho_save_sections(filename, macho):
    from .filebytes.mach_o import LC
    arch = make_macho_arch_name(macho)
    for cmd in macho.loadCommands:
        if cmd.header.cmd in (LC.SEGMENT, LC.SEGMENT_64):
            for section in cmd.sections:
                if section.name.startswith('__debug'):
                    sec_file = ".".join((filename, arch, section.name))
                    if not path.exists(sec_file):
                        write_to_file(sec_file, section.bytes)


_MACHO_fat_header = False

# Given a file pointer past the fat signature, returns an array of slice headers
def parse_fat_header(file):
    global _MACHO_fat_header
    if not _MACHO_fat_header:
        from elftools.construct import PrefixedArray, Struct, UBInt32
        _MACHO_fat_header = PrefixedArray(
            Struct('MACHOFatSlice',
                UBInt32('cputype'),
                UBInt32('cpusubtype'),
                UBInt32('offset'),
                UBInt32('size'),
                UBInt32('align')),
            UBInt32(''))
    return _MACHO_fat_header.parse_stream(file)    

# resolve_arch takes a list of architecture descriptions, and returns
# the desired index/multiindex, or None if the user has cancelled
# file read position should be past the fat signature
# filename is a real file name, not bundle 
def read_fat_macho(file, resolve_arch):
    arches = parse_fat_header(file)
    # Fat executable binary or fat static lib?
    slice_names = list()
    libs_by_arch = dict() # Arch index to lib file list
    for (i, arch) in enumerate(arches):
        arch_name = make_macho_arch_name_raw(arch.cputype, arch.cpusubtype)
        file.seek(arch.offset, os.SEEK_SET)
        signature = file.read(8)
        if signature[:4] in (b'\xFE\xED\xFA\xCE', b'\xFE\xED\xFA\xCF', b'\xCE\xFA\xED\xFE', b'\xCF\xFA\xED\xFE'):
            slice_names.append(arch_name)
        elif signature == b'!<arch>\n':
            lib_headers = scan_staticlib(file, arch.size)
            libs_by_arch[i] = lib_headers
            slice_names.append((arch_name, tuple(h.name.decode('UTF-8') for h in lib_headers))) # TODO: encoding
        else:
            raise FormatError(f"Slice #{i+1} in this file is of unrecognized or unsupported type: {''.join('%02X' % b for b in signature)}. Let the author know")

    arch_no = resolve_arch(slice_names, 'Mach-O Fat Binary', 'Choose an architecture:')
    if arch_no is None: # User cancellation
        return False
    if isinstance(arch_no, tuple):
        (arch_no, file_no) = arch_no
        slice_code = (slice_names[arch_no][0], slice_names[arch_no][1][file_no])
    else:
        slice_code = (slice_names[arch_no],)
        file_no = None

    if file_no is not None: # Object inside lib inside fat binary
        libfile = libs_by_arch[arch_no][file_no]
        offset = libfile.data_offset
        size = libfile.size
        format = 6 # file inside lib inside fat
    else:
        slice = arches[arch_no]
        offset = slice.offset
        size = slice.size
        format = 1 # Plain Mach-O or slice inside fat

    file.seek(offset)
    data = file.read(size) # TODO: avoid copying? Hand-parse MachO maybe
    macho = open_macho('', data)
    di = get_macho_dwarf(macho, slice_code)
    if di:
        di._format = format
    return di

# Only used for nonfat, standalone macho files.    
def read_macho(filename):
    macho = open_macho(filename) # Not fat - checked upstack
    return get_macho_dwarf(macho, None)

# Given a filename and an arch code (type, subtype), returns dwarfinfo, if any
# The arch code must be given. If the target is fat, it will choose the right slice.
# No provision for fat libraries. TODO what happens if you build a fat library with DWARF in dSYM.
def read_macho_with_arch(filename, slice_code, arch_code):
    with open(filename, 'rb') as file:
        signature = file.read(4)
        if signature == b'\xCA\xFE\xBA\xBE':
            arches = parse_fat_header(file)
            arch = next(a for a in arches if arch_code == (a.cputype, a.cpusubtype))
            file.seek(arch.offset, os.SEEK_SET)
            data = file.read(arch.size)
        else:
            file.seek(arch.offset, 0)
            data = file.read()
        macho = open_macho(filename, data)
        return get_macho_dwarf(macho, slice_code)

# TODO, but debug the command line location logic first
def locate_dsym(uuid):
    try:
        from Foundation import NSMetadataQuery, NSPredicate

        su = uuid.decode('ASCII').upper()
        su = f"{su[0:8]}-{su[8:12]}-{su[12:16]}-{su[16:20]}-{su[20:]}"
        query = NSMetadataQuery.alloc().init()
        query.setPredicate_(NSPredicate.predicateWithFormat_("(com_apple_xcode_dsym_uuids == '"+su+"')"))
        #query.setSearchScopes_(["/Applications", "/Users"])
        query.startQuery()
        query.retain()
        wait_with_events(lambda: query.isGathering())
        query.stopQuery()
        res = query.results()
        query.release()
        if len(res):
            path = res[0].valueForAttribute_("kMDItemPath")
            if path:
                return path 
    except ImportError:
        pass

def macho_arch_code(macho):
    h = macho.machHeader.header
    return (h.cputype, h.cpusubtype)

def get_macho_dwarf(macho, slice_code):
    """Slice_code is (arch_name,) or (arch_name, file_name) or None"""
    from .filebytes.mach_o import TypeFlags, LC, MH
    # We proceed with macho being a arch-specific file, or a slice within a fat binary
    sections = {
        section.name: section.bytes
        for cmd in macho.loadCommands
        if cmd.header.cmd in (LC.SEGMENT, LC.SEGMENT_64)
        for section in cmd.sections
        if (section.name.startswith('__debug') or section.name in ('__eh_frame', '__unwind_info')) and section.header.offset > 0
    }

    uuid_cmd = next((cmd for cmd in macho.loadCommands if cmd.header.cmd == LC.UUID), None)
    uuid = uuid_cmd.uuid if uuid_cmd else None
    # a bytes with a hex representation of the binary GUID 

    if not '__debug_info' in sections:
        if macho.machHeader.header.filetype == MH.EXECUTE and uuid:
            # TODO: locate dSYM by UUID
            dsym_path = locate_dsym(uuid)
            if dsym_path:
                if path.isdir(dsym_path):
                    dsym_path = binary_from_bundle(dsym_path)
                # TODO: match CPU types instead of strings
                di = read_macho_with_arch(dsym_path, macho_arch_code(macho))
                if di:
                    add_macho_sections_from_executable(di, macho)
                    return di
            else:
                return None
                
                # TODO this
                symtab = next((cmd for cmd in macho.loadCommands if cmd.header.cmd == LC.SYMTAB), False)
                le = next((cmd for cmd in macho.loadCommands if cmd.header.cmd in (LC.SEGMENT, LC.SEGMENT_64) and cmd.name == '__LINKEDIT'), False)
                if symtab and le:
                    import struct
                    big_endian = False # Oh well
                    endianness = '>' if big_endian else '<'
                    is64 = (macho.machHeader.header.cputype & TypeFlags.ABI64) != 0
                    format = endianness + ("IBBHQ" if is64 else "IBBHI")
                    # Name Type Sec_no Info Address
                    stride = struct.calcsize(format)
                    ledata = le.bytes
                    sym_start = symtab.header.symbols_offset - le.header.fileoff
                    str_start = symtab.header.strings_offset - le.header.fileoff

                    def string_at(off):
                        return ledata[str_start+off:ledata.find(b'\x00', str_start+off)].decode('ASCII')
                    
                    st = (struct.unpack_from(format, ledata, sym_start+i*stride) for i in range(symtab.header.nsymbols))
                    st = [(string_at(name), type, sec, info, address) for (name, type, sec, info, address) in st]
                    pass
        return None
    
    data = {
        name: DebugSectionDescriptor(io.BytesIO(contents), name, None, len(contents), 0)
        for (name, contents)
        in sections.items()
    }
    # '__eh_frame', '__unwind_info' are not in dSYM bundles

    #macho_save_sections(friendly_filename, macho)

    cpu = macho.machHeader.header.cputype
    di = DWARFInfo(
        config = DwarfConfig(
            little_endian=True,
            default_address_size = 8 if (cpu & TypeFlags.ABI64) != 0 else 4,
            machine_arch = make_macho_arch_name(macho)
        ),
        debug_info_sec = data['__debug_info'],
        debug_aranges_sec = data.get('__debug_aranges'),
        debug_abbrev_sec = data['__debug_abbrev'],
        debug_frame_sec = data.get('__debug_frame'),
        eh_frame_sec = data.get('__eh_frame'), # __unwind_info separately, not a part of DWARF proper
        debug_str_sec = data['__debug_str'],
        debug_loc_sec = data.get('__debug_loc'),
        debug_ranges_sec = data.get('__debug_ranges'),
        debug_line_sec = data.get('__debug_line'),
        debug_pubtypes_sec = data.get('__debug_pubtypes'), #__debug_gnu_pubn?
        debug_pubnames_sec = data.get('__debug_pubtypes'), #__debug_gnu_pubt?
        debug_addr_sec = data.get('__debug_addr'),
        debug_str_offsets_sec = data.get('__debug_str_offsets'),
        debug_line_str_sec = data.get('__debug_line_str'),
        debug_loclists_sec = data.get('__debug_loclists'),
        debug_rnglists_sec = data.get('__debug_rnglists'),
        debug_sup_sec = data.get('__debug_sup'),
        gnu_debugaltlink_sec = data.get('__gnu_debugaltlink'),
        debug_types_sec = data.get('__debug_types'),
    )
    text_cmd = next((cmd for cmd in macho.loadCommands if cmd.header.cmd in (LC.SEGMENT, LC.SEGMENT_64) and cmd.name == "__TEXT"), False)
    decorate_di(di, 1, macho_arch_code(macho), text_cmd.header.vmaddr if text_cmd else 0)
    di._unwind_sec = sections.get('__unwind_info') # VERY unlikely to be None
    di._slice_code = slice_code
    di._uuid = uuid
    di._has_exec = False
    return di

def open_macho(filename, contents=None):
    """ Wrapper around the filebytes' MachO constructor
        that translates filebytes' exceptions to our own
    """
    from .filebytes.mach_o import MachO, BinaryError
    try:
        return MachO(filename, contents)
    except BinaryError as err:
        raise FormatError("Error parsing the binary.\n" + str(err))

# TODO: don't load the whole binary, load just the right slice
def load_companion_executable(filename, di):
    from .filebytes.mach_o import LC, MH
    if path.isdir(filename):
        binary = binary_from_bundle(filename)
        if not binary:
            raise FormatError("The specified bundle does not contain a Mach-O binary, or it could not be found. Try locating the binary manually.")
    else:
        binary = filename
    
    macho = open_macho(binary)
    if macho.isFat:
        macho = next((slice for slice in macho.fatArches if macho_arch_code(slice) == di._arch_code), None)
        if macho is None:
            arch = make_macho_arch_name_raw(*di._arch_code)
            raise FormatError(f"This binary does not contain a slice for {arch}.")
    elif macho_arch_code(macho) != di._arch_code:
        arch = make_macho_arch_name_raw(*di._arch_code)
        raise FormatError(f"The architecture of this binary does not match that of the curernt DWARF, which is {arch}.")
    
    ft = macho.machHeader.header.filetype
    if ft != MH.EXECUTE:
        raise FormatError(f"This binary is not an executable - type {MH[ft].name}.")

    uuid = next(cmd for cmd in macho.loadCommands if cmd.header.cmd == LC.UUID).uuid
    if uuid != di._uuid:
        raise FormatError(f"This binary is from a different build than the current DWARF - the UUIDs do not match.")
    
    # Match on arch and UUID
    add_macho_sections_from_executable(di, macho)

def add_macho_sections_from_executable(di, macho):
    from .filebytes.mach_o import LC
    sections = {
        section.name: section
        for cmd in macho.loadCommands
        if cmd.header.cmd in (LC.SEGMENT, LC.SEGMENT_64)
        for section in cmd.sections
        if section.header.offset > 0
    }

    di._text_sec = sections.get('__text').bytes

    unwind = sections.get('__unwind_info', None)
    if unwind:
        di._unwind_sec = unwind.bytes

    eh = sections.get('__eh_frame', None)
    if eh:
        di.eh_frame_sec = DebugSectionDescriptor(io.BytesIO(eh.bytes), eh.name, None, len(eh.bytes), 0)
        
    di._text_section_start = sections.get('__text').header.addr
    di._has_exec = True

def binary_from_bundle(filename):
    # Is it a dSYM bundle?
    nameparts = path.basename(filename).split('.') 
    if nameparts[-1] == 'dSYM' and path.exists(path.join(filename, 'Contents', 'Resources', 'DWARF')):
        files = listdir(path.join(filename, 'Contents', 'Resources', 'DWARF'))
        if len(files) > 0:
            # When are there multiple DWARF files in a dSYM bundle?
            # TODO: let the user choose?
            dsym_file_path = path.join(filename, 'Contents', 'Resources', 'DWARF', files[0])
            return dsym_file_path
    # Is it an app bundle? appname.app
    if len(nameparts) > 1 and nameparts[-1] in ('app', 'framework'):
        app_file = path.join(filename, '.'.join(nameparts[0:-1]))
        if path.exists(app_file):
            return app_file

        # Any other bundle formats we should be aware of?
    return None

########################################################################
######################### WASM
########################################################################

_WASM_section_header = False

def read_wasm(file):
    global _WASM_section_header
    from elftools.common.construct_utils import ULEB128, StreamOffset
    from elftools.construct import ULInt8, ULInt32, Struct, If, PascalString, Value
    if not _WASM_section_header:
        _WASM_section_header = Struct('WASMSectionHeader',
            ULInt8('id'),
            ULEB128('section_length'),
            StreamOffset('off1'),
            # Subheader on custom (id 0) sections - ULEB128 length prefixed name
            If(lambda ctx: ctx.id == 0, PascalString('name', length_field = ULEB128('length'), encoding='UTF-8')),
            StreamOffset('off2'),
            # This is effective content length - for custom sections, section size minus the name subheader
            Value('length', lambda ctxt: ctxt.section_length - ctxt.off2 + ctxt.off1)
        )
    
    file.seek(0, os.SEEK_END)
    file_size = file.tell()
    # Signature already checked, move on to file version
    file.seek(4, os.SEEK_SET)
    ver = ULInt32('').parse_stream(file)
    if ver != 1:
        raise FormatError("WASM binary format version %d is not supported." % ver)
    
    data = dict()
    dwarf_url = None
    while file.tell() < file_size:
        sh = _WASM_section_header.parse_stream(file)
        if sh.id == 0 and sh.name.startswith(".debug"):
            content = file.read(sh.length)
            data[sh.name] = DebugSectionDescriptor(io.BytesIO(content), sh.name, None, sh.length, 0)
        elif sh.id == 0 and sh.name == 'external_debug_info':
            dwarf_url = file.read(sh.length).decode('UTF-8')
        else: # Skip this section
            file.seek(sh.length, os.SEEK_CUR)

    if dwarf_url:
        raise FormatError("The debug information for this WASM file is at %s." % dwarf_url)

    # TODO: relocations, start address

    di = DWARFInfo(
        config = DwarfConfig(
            little_endian=True,
            default_address_size = 4, # Is it variable???
            machine_arch = 'WASM'
        ),
        debug_info_sec = data['.debug_info'],
        debug_aranges_sec = data.get('.debug_aranges'),
        debug_abbrev_sec = data['.debug_abbrev'],
        debug_frame_sec = data.get('.debug_frame'),
        eh_frame_sec = None, # In WASM??
        debug_str_sec = data['.debug_str'],
        debug_loc_sec = data.get('.debug_loc'),
        debug_ranges_sec = data.get('.debug_ranges'),
        debug_line_sec = data.get('.debug_line'),
        debug_pubtypes_sec = data.get('.debug_pubtypes'),
        debug_pubnames_sec = data.get('.debug_pubtypes'),
        debug_addr_sec = data.get('.debug_addr'),
        debug_str_offsets_sec = data.get('.debug_str_offsets'),
        debug_line_str_sec = data.get('.debug_line_str'),
        debug_loclists_sec = data.get('.debug_loclists'),
        debug_rnglists_sec = data.get('.debug_rnglists'),
        debug_sup_sec = None,
        gnu_debugaltlink_sec = None,
        debug_types_sec = data.get('.debug_types')
    )
    decorate_di(di, 3, None, 0)
    return di

# Filename is only needed for supplemental DWARF resolution
def read_elf(file, filename):
    from elftools.elf.elffile import ELFFile
    file.seek(0)
    # TODO: interactive supplemental DWARF resolver here...
    elffile = ELFFile(file, lambda s: open(path.join(path.dirname(filename), s.decode('UTF-8')), 'rb'))

    # Retrieve the preferred loading address
    load_segment = next((seg for seg in elffile.iter_segments() if seg.header.p_type == 'PT_LOAD'), None)
    start_address = load_segment.header.p_vaddr if load_segment else 0
    di = None
    if elffile.has_dwarf_info():
        di = elffile.get_dwarf_info() # elffile.header.e_type != 'ET_REL' - was trying to address pyelftools/#564
    elif elffile.get_section_by_name(".debug"):
        from .dwarfone import parse_dwarf1
        di = parse_dwarf1(elffile)

    if di:
        decorate_di(di, 0, elffile.header.e_machine, start_address)
    return di

###########################################################################
############################ Libraries
###########################################################################

_ar_file_header = namedtuple('ARHeader', ('header_offset', 'data_offset',
                                          'name',
                                          # Don't care for the metadata
                                          #'last_mod_date', 'user_id', 'group_id', 'mode',
                                          'size'))


def scan_staticlib(file, size):
    """Returns an array of headers.
       file read position should be past the A signature.
       size should include the A signature
       Offsets are relative to the file top, not to the position on entry
    """
    long_names = False
    def read_header():
        header_offset = file.tell()
        b = file.read(60)
        data_size = int(b[48:58])
        name = b[0:16].rstrip()
        # Resolve BSD style long names
        if name.startswith(b'#1/') and len(name) > 3:
            name_len = int(name[3:])
            name = file.read(name_len).rstrip(b'\0')
            data_size -= name_len
        # Resolve GNU style long file names
        elif name.startswith(b'/') and len(name) > 1 and ord(b'0') <= name[1] <= ord(b'9'):
            if not long_names:
                FormatError("Long file name in a static library, but no long name section was found.")
            str_offset = int(name[1:])
            end_pos = long_names.find(b'\n', str_offset)
            name = long_names[str_offset:end_pos] if end_pos >= 0 else long_names[str_offset:]
        data_offset = file.tell()
        return _ar_file_header(header_offset, data_offset, name,
                               #int(b[16:28]), int(b[28:34]),
                               #int(b[34:40]), int(b[40:48], 8),
                               data_size)
    
    # Not used. Just in case. GNU symtab only.
    def read_symtab(size, is64):
        ilen = 8 if is64 else 4
        length = int.from_bytes(file.read(ilen), 'big')
        d = file.read(length * ilen)
        offsets = [int.from_bytes(d[i*ilen:(i+1)*ilen], 'big') for i in range(length)]
        d = file.read(size - (length+1)*ilen)
        symbols = d.split(b'\0')[:-1]
        return zip(offsets, symbols)
    
    def skip_content(header):
        file.seek(((header.size + 1) // 2) * 2, os.SEEK_CUR)

    ############################
    # read_staticlib starts here

    top_offset = file.tell()-8

    # First section most likely a symtab - skip
    header = read_header() 
    if header.name == b'/' or header.name == b'/SYM64/' or header.name == b'__.SYMDEF':
        skip_content(header)
        # read_symtab(header.size, header.name == b'/SYM64/')
        # if header.size % 2 == 1:
        #    file.seek(1, os.SEEK_CUR)
    else: # Skip back
        file.seek(header.header_offset, os.SEEK_SET)

    # Probably a long file name directory - read and keep
    header = read_header() 
    if header.name == b'//':
        long_names = file.read(header.size)
        if header.size % 2 == 1:
            file.seek(1, os.SEEK_CUR)
    else: # It's a file, skip back
        file.seek(header.header_offset, os.SEEK_SET)
        
    # Read all file headers, build a list
    headers = list()
    while file.tell() - top_offset < size:
        header = read_header()
        headers.append(header)
        skip_content(header)
    return headers

# resolve_slice takes a list of files in the archive, and returns
# the desired index, or None if the user has cancelled
def read_staticlib(file, resolve_slice):
    from io import BytesIO

    file.seek(0, os.SEEK_END)
    size = file.tell()
    file.seek(8) # Past the magic signature    
    headers = scan_staticlib(file, size)

    # Present the user with slice choice
    # TODO: encoding?
    names = tuple(h.name.rstrip(b'/').decode('ASCII') for h in headers)
    slice = resolve_slice(names, 'Static Library', 'Choose an object file:')
    if slice is None:
        return False # Cancellation
    
    header = headers[slice]
    file.seek(header.data_offset)
    b = file.read(header.size)
    slice_code = (names[slice],)
    # We support ELF and MachO static libraries so far
    if b[:4] == b'\x7FELF':
        di = read_elf(BytesIO(b), None)
        if di:
            di._slice_code = slice_code
    elif b[:4] in (b'\xFE\xED\xFA\xCE', b'\xFE\xED\xFA\xCF', b'\xCE\xFA\xED\xFE', b'\xCF\xFA\xED\xFE'):
        from .filebytes.mach_o import MachO
        macho = open_macho(None, b)
        di = get_macho_dwarf(macho, slice_code)
    elif b[:4] == b'\xCA\xFE\xBA\xBE':
        raise FormatError("The selected slice of the static library is a Mach-O fat binary. Those are not supported. Let the author know.")
    else:
        raise FormatError("The selected slice of the static library is not a supported object file. Let the author know.")
    
    if di:
        di._format += 4
    return di

#########################################################################
######################## The main entry point - file in, DWARF out
#########################################################################

def read_dwarf(filename, resolve_arch):
    """ UI agnostic - resolve_arch might be interactive
        Returns slightly augmented DWARFInfo
        Or None if not a DWARF containing file (or unrecognized)
        Or False if user has cancelled
        Or throws an exception
        resolve_arch is for Mach-O fat binaries - see read_macho()
        and repurposed for .a static libraries
        Primary point of call is open_file() in main
    """
    if path.isfile(filename): # On MacOS, opening dSYM bundles as is would be right, and they are technically folders
        with open(filename, 'rb') as file:
            xsignature = file.read(8)
            signature = xsignature[:4]

            if xsignature[:2] == b'MZ': # DOS header - this might be a PE. Don't verify the PE header, just feed it to the parser
                return read_pe(filename)
            elif signature == b'\x7FELF': #It's an ELF
                return read_elf(file, filename)
            elif signature in (b'\xFE\xED\xFA\xCE', b'\xFE\xED\xFA\xCF', b'\xCE\xFA\xED\xFE', b'\xCF\xFA\xED\xFE'):
                # Mach-O 32/64-bit Mach-O in big/little-endian format, but not a fat binary
                # TODO: little endian is not supported!
                return read_macho(filename)
            elif signature == b'\xCA\xFE\xBA\xBE': 
                # Mach-O fat binary - could be executable, or a multiarch static lib.
                if int.from_bytes(xsignature[4:8], 'big') >= 0x20:
                    # Java .class files also have CAFEBABE, check the fat binary arch count
                    return None
                file.seek(4, os.SEEK_SET)
                return read_fat_macho(file, resolve_arch)
            elif signature == b'\0asm':
                return read_wasm(file)
            elif xsignature == b'!<arch>\n':
                return read_staticlib(file, resolve_arch)
    elif path.isdir(filename):
        binary_filename = binary_from_bundle(filename)
        if binary_filename:
            return read_dwarf(binary_filename, resolve_arch)
        
def get_debug_sections(di):
    section_names = {name: "debug_%s_sec" % name
            for name in 
            ('info', 'aranges', 'abbrev', 'frame',
            'str', 'loc', 'ranges', 'line', 'addr',
            'str_offsets', 'line_str', 'pubtypes',
            'pubnames', 'loclists', 'rnglists', 'sup')}
    section_names['eh_frame'] = 'eh_frame_sec'
    section_names['gnu_debugaltlink'] = 'gnu_debugaltlink'
    section_names['unwind_info'] = '_unwind_sec'
    section_names['text'] = '_text_sec'

    # Display name to section object
    return {display_name: getattr(di, field_name)
        for (display_name, field_name) in section_names.items()
        if hasattr(di, field_name)}

# Section can be a SectionDescription or a raw dump
def section_bytes(section):
    return section if isinstance(section, (bytes, bytearray, memoryview)) else section.stream.getbuffer()
    # TODO: reliance on stream being a BytesIO

def write_to_file(filename, data):
    with open(filename, 'wb') as f:
        f.write(data)

```

`dwex/frames.py`:

```py
from PyQt6.QtCore import Qt, QAbstractTableModel
from PyQt6.QtWidgets import *

from elftools.dwarf.callframe import FDE, RegisterRule, ZERO
from elftools.dwarf.dwarf_expr import DWARFExprParser

from .exprdlg import ExpressionDlg
from .fx import bold_font
from .locals import LoadedModuleDlgBase
from .exprutil import _REG_NAME_MAP, ExprFormatter, format_offset

rheaders = ('Start address', 'End address', 'Length')
eheaders = ('Type', 'CIE offset', 'Start address', 'End address', 'Length')

# TODO: more fields in entries mode? Version, augmentation, etc? Or a properties window?
# TODO: dump raw instructions in details?
class EntriesModel(QAbstractTableModel):
    def __init__(self, cfi, fdes_only, hex):
        QAbstractTableModel.__init__(self)
        self.fdes_only = fdes_only
        self.headers = rheaders if fdes_only else eheaders
        self.hex = hex
        if fdes_only:
            self.entries = [e for e in cfi if isinstance(e, FDE)]
            self.entries.sort(key=lambda e: e.header.initial_location)
        else:
            self.entries = cfi

    def headerData(self, section, ori, role):
        if ori == Qt.Orientation.Horizontal and role == Qt.ItemDataRole.DisplayRole:
            return self.headers[section]
        
    def rowCount(self, parent):
        return len(self.entries)

    def columnCount(self, parent):
        return len(self.headers)
    
    def index(self, row, col, parent):
        return self.createIndex(row, col, self.entries[row])
    
    def data(self, index, role):
        col = index.column()
        entry = index.internalPointer()
        header = entry.header if not isinstance(entry, ZERO) else None
        is_fde = isinstance(entry, FDE)
        if role == Qt.ItemDataRole.DisplayRole:
            # In entries mode, the first two columns are for all lines, the rest of columns is the FDE display
            if not self.fdes_only:
                if col == 0:
                    return ('FDE' if is_fde else 'CIE') if header else 'ZERO'
                if col == 1:
                    return (hex(entry.cie.offset if is_fde else entry.offset)) if header else ''
                    # CIE_offset in FDE header is relative in EH section, absolute in debug_frames
                else:
                    col -= 2
            if is_fde:
                if col == 0:
                    return hex(header.initial_location)
                elif col == 1:
                    return hex(header.initial_location + header.address_range - 1)
                elif col == 2:
                    return hex(header.address_range) if self.hex else str(header.address_range)
        elif role == Qt.ItemDataRole.FontRole:
            if not self.fdes_only and is_fde:
                return bold_font()

class DecodedEntryModel(QAbstractTableModel):
    def __init__(self, entry, regnamelist, p, f):
        QAbstractTableModel.__init__(self)
        self.table = entry.get_decoded() # Anything else from the entry?
        self.regnamelist = regnamelist
        self.parser = p
        self.formatter = f
        # TODO: sort them?

    def headerData(self, section, ori, role):
        if ori == Qt.Orientation.Horizontal and role == Qt.ItemDataRole.DisplayRole:
            if section == 0:
                return "Address"
            elif section == 1:
                return 'CFA'
            else:
                regno = self.table.reg_order[section-2]
                return self.regname(regno)
        
    def rowCount(self, parent):
        return len(self.table.table)

    def columnCount(self, parent):
        return len(self.table.reg_order) + 2
    
    def index(self, row, col, parent):
        return self.createIndex(row, col, self.table.table[row])
    
    def data(self, index, role):
        # Helper...
        def format_rule_expr(expr):
            if not hasattr(rule, 'expr'): # Implementation detail: rule is an open ended object
                rule.expr = self.parser.parse_expr(rule.arg)
            expr = rule.expr
            if len(expr) > 3:
                return '; '.join(self.formatter.format_op(*op) for op in expr[:3]) + f';...{len(expr)-3} more'
            else:
                return '; '.join(self.formatter.format_op(*op) for op in expr)

        col = index.column()
        line = index.internalPointer()
        if role == Qt.ItemDataRole.DisplayRole:
            if col == 0:
                return hex(line['pc'])
            elif col == 1:
                rule = line['cfa']
                if rule.expr is not None:
                    return '(expr)' # TODO!!!
                elif rule.reg is not None:
                    return self.regname(rule.reg) + format_offset(rule.offset)
                else:
                    return '(unclear)' # TODO: catch? #1743
            else:
                regno = self.table.reg_order[col-2]
                if regno in line:
                    rule = line[regno]
                    type = rule.type
                    if type == 'ARCHITECTURAL':
                        return '(arch)'
                    elif type == 'EXPRESSION':
                        return f'[{format_rule_expr(rule)}]'
                    elif type == 'OFFSET':
                        return "[CFA%s]" % (format_offset(rule.arg),)
                    elif type == 'REGISTER':
                        return self.regname(rule.arg)
                    elif type == 'SAME_VALUE':
                        return '(same)'
                    elif type == 'UNDEFINED':
                        return '(undef)'
                    elif type == 'VAL_EXPRESSION':
                        return format_rule_expr(rule)
                    elif type == 'VAL_OFFSET':
                        return "CFA%s" % (format_offset(rule.arg),)
        elif role == Qt.ItemDataRole.ToolTipRole:
            if col >= 2:
                regno = self.table.reg_order[col-2]
                if regno in line:
                    rule = line[regno]
                    if rule.type in ('EXPRESSION', 'VAL_EXPRESSION'):
                        return 'Double-click for details'
                
    def regname(self, regno):
        return self.regnamelist[regno] if self.regnamelist else "r%d" % (regno,)
    
    def get_expr_rule(self, index):
        col = index.column()
        if col >= 2:
            regno = self.table.reg_order[col-2]
            rule = index.internalPointer()[regno]
            if rule.type in ('VAL_EXPRESSION', 'EXPRESSION'):
                if not hasattr(rule, 'expr'): # Implementation detail: rule is an open ended object
                    rule.expr = self.parser.parse_expr(rule.arg)
                return rule
            
    def get_regname_by_index(self, index):
        col = index.column()
        if col >= 2:
            regno = self.table.reg_order[col-2]
            return self.regname(regno)


#########################################################

# Reused for unwind info - sans the top buttons
class FramesUIDlg(LoadedModuleDlgBase):
    def __init__(self, win):
        LoadedModuleDlgBase.__init__(self, win)

        self.resize(500, 400)

        spl = QSplitter(Qt.Orientation.Vertical)

        top_pane = QVBoxLayout()
        top_pane.setContentsMargins(0, 0, 0, 0)

        # Init ahead of time so that it may be populated in the RB handler
        entries = self.entries = QTableView()
        details = self.details = QTableView()

        self.make_top(top_pane)

        entries.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
        entries.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)
        top_pane.addWidget(entries)
        w = QWidget()
        w.setLayout(top_pane)
        spl.addWidget(w)

        details.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectItems) # Double click to zoom in on expression
        details.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)
        bottom_pane = QVBoxLayout()
        bottom_pane.setContentsMargins(0, 0, 0, 0)
        bottom_pane.addWidget(details)

        buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Close, Qt.Orientation.Horizontal, self)
        #self.nav_bu = QPushButton("Navigate", self)
        #self.nav_bu.clicked.connect(self.on_navigate)
        #self.nav_bu.setEnabled(False)
        #buttons.addButton(self.nav_bu, QDialogButtonBox.ButtonRole.ApplyRole)
        buttons.accepted.connect(self.reject)
        buttons.rejected.connect(self.reject)
        bottom_pane.addWidget(buttons)
        w = QWidget()
        w.setLayout(bottom_pane)
        spl.addWidget(w)

        spl.setStretchFactor(0, 1)
        spl.setStretchFactor(1, 0)
        ly = QVBoxLayout()
        ly.addWidget(spl)
        self.setLayout(ly)

        self.setWindowTitle('Frames')

    def make_top(self, top_pane):
        pass

class FramesDlg(FramesUIDlg):
    def __init__(self, win, cfi, di, regnames, hex):
        self.cfi = cfi
        self.dwarfinfo = di
        self.hex = hex
        arch = di.config.machine_arch
        self.regnamelist = _REG_NAME_MAP.get(arch, None) if not regnames else None
        dwarf_version = 2 # If no debug sections, can't tell if it's V1. Frames were not in V1.
        self.expr_parser = DWARFExprParser(di.structs)
        self.expr_formatter = ExprFormatter(regnames, False, arch, dwarf_version, True)

        FramesUIDlg.__init__(self, win)

        # Expression details browser
        self.details.doubleClicked.connect(self.on_rule_dclick)

    def on_entry_sel(self, index, prev = None):
        # TODO: raw mode
        self.details.setModel(DecodedEntryModel(index.internalPointer(), self.regnamelist, self.expr_parser, self.expr_formatter))

    def on_rule_dclick(self, index):
        if index and index.isValid():
            model = self.details.model()
            rule = model.get_expr_rule(index)
            if rule:
                regname = model.get_regname_by_index(index)
                pc = index.internalPointer()['pc'] # :(
                target = regname if rule.type == 'VAL_EXPRESSION' else f'address of {regname}'
                title = f'Expression for {target} at/past 0x{pc:x}'
                ExpressionDlg(self, title, rule.expr, self.expr_formatter).exec()

    def make_top(self, top_pane):
        top_pane.addWidget(make_rbutton_pair(("Ranges", "Entries"), self.set_view))        

    def set_view(self, fdes_only):
        # TODO: change the model in place
        self.entries.setModel(EntriesModel(self.cfi, fdes_only, self.hex))
        self.entries.selectionModel().currentChanged.connect(self.on_entry_sel)
        self.details.setModel(None)

def make_rbutton_pair(titles, on_toggle):
    bu_line = QHBoxLayout()
    rbus = QButtonGroup()
    rbu = QRadioButton()
    rbu.setText(titles[0])
    rbu.toggled.connect(lambda c: on_toggle(True))
    rbu.setChecked(True)
    rbus.addButton(rbu)
    bu_line.addWidget(rbu)
    rbu = QRadioButton()
    rbu.setText(titles[1])
    rbu.toggled.connect(lambda c: on_toggle(False))
    rbus.addButton(rbu)
    bu_line.addWidget(rbu)
    w = QWidget()
    w.setLayout(bu_line)
    return w
```

`dwex/funcmap.py`:

```py
from PyQt6.QtCore import Qt, QThread, pyqtSignal
from bisect import bisect_left
from PyQt6.QtWidgets import *

from .details import GenericTableModel
from .dwarfutil import get_code_location, has_code_location, subprogram_name
from .locals import LoadedModuleDlgBase, WaitCursor

# TODO: unite UI with aranges - dialog with a table and potentially a search bar
# TODO: sorting

class GatherFuncsThread(QThread):
    def __init__(self, parent, di):
        QThread.__init__(self, parent)
        self.cancelled = False
        self.funcs = None
        self.exc = None
        self.dwarfinfo = di

    progress = pyqtSignal(int)

    def cancel(self):
        self.cancelled = True

    def run(self):
        try:
            funcs = []
            for cu in self.dwarfinfo._unsorted_CUs:
                for die in cu.iter_DIEs():
                    self.yieldCurrentThread()
                    if self.cancelled:
                        return

                    if die.tag in ('DW_TAG_subprogram', 'DW_TAG_global_subroutine') and has_code_location(die):
                        self.progress.emit(die.offset)
                        IP = get_code_location(die).start_address()
                        i = bisect_left(funcs, IP, key=lambda f:f[3])
                        funcs.insert(i, (hex(IP), subprogram_name(die), die, IP))
            self.funcs = funcs
        except Exception as exc:
            self.exc = exc


class FuncMapDlg(LoadedModuleDlgBase):
    def __init__(self, win, hex, funcs):
        LoadedModuleDlgBase.__init__(self, win)
        self.selected_die = None
        model = GenericTableModel(("Start address", 'Function'), funcs)

        self.resize(500, 500)
        ly = QVBoxLayout()

        self.the_table = QTableView()
        self.the_table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
        self.the_table.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)
        self.the_table.setModel(model)
        self.the_table.selectionModel().currentChanged.connect(self.on_sel)
        self.the_table.doubleClicked.connect(self.navigate_to_index)
        self.the_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeMode.ResizeToContents)
        ly.addWidget(self.the_table)

        buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Close, Qt.Orientation.Horizontal, self)
        self.nav_bu = QPushButton("Navigate", self)
        self.nav_bu.clicked.connect(lambda: self.navigate_to_index(self.the_table.currentIndex()))
        self.nav_bu.setEnabled(False)
        buttons.addButton(self.nav_bu, QDialogButtonBox.ButtonRole.ApplyRole)
        buttons.accepted.connect(self.reject)
        buttons.rejected.connect(self.reject)
        ly.addWidget(buttons)

        self.setWindowTitle('Function map')
        self.setLayout(ly)

    def on_sel(self, index, prev = None):
        self.nav_bu.setEnabled(index.isValid())

    def navigate_to_index(self, index):
        row = index.row()
        self.selected_die = self.the_table.model().values[row][2]
        self.done(QDialog.DialogCode.Accepted)
        
```

`dwex/fx.py`:

```py
from PyQt6.QtCore import Qt, QEventLoop
from PyQt6.QtWidgets import QApplication
from PyQt6.QtGui import QFontInfo, QFont, QBrush

_bold_font = None
_fixed_font = None
blue_brush = QBrush(Qt.GlobalColor.blue)
ltgrey_brush = QBrush(Qt.GlobalColor.lightGray)

def bold_font():
    global _bold_font
    if not _bold_font:
        fi = QFontInfo(QApplication.font())
        _bold_font = QFont(fi.family(), fi.pointSize(), QFont.Weight.Bold)
    return _bold_font

def fixed_font():
    global _fixed_font
    if not _fixed_font:
        _fixed_font = QFont("Monospace")
        _fixed_font.setStyleHint(QFont.StyleHint.TypeWriter)
    return _fixed_font

# TODO: cancellation, progress indication
def wait_with_events(cond, timeout=100):
    loop = QEventLoop(QApplication.instance())
    while cond():
        loop.processEvents(QEventLoop.ProcessEventsFlag.AllEvents, timeout)

# Doesn't quite work for the delay on tree expansion :( TODO: timer checks before lighting up this
class WaitCursor():
    def __enter__(self):
        QApplication.setOverrideCursor(Qt.CursorShape.WaitCursor)

    def __exit__(self, *args):
        QApplication.restoreOverrideCursor()

class ArrowCursor():
    def __enter__(self):
        QApplication.restoreOverrideCursor()

    def __exit__(self, *args):
        QApplication.setOverrideCursor(Qt.CursorShape.WaitCursor)

```

`dwex/locals.py`:

```py
from PyQt6.QtCore import Qt, QAbstractTableModel, QSize
from PyQt6.QtWidgets import *
from elftools.dwarf.locationlists import LocationParser, LocationExpr
from elftools.dwarf.callframe import FDE, CFARule

from dwex.exprutil import ExprFormatter, format_offset
from .dwarfutil import *
from .fx import bold_font, WaitCursor

#0x25af0
#0xd864 (black)
# test: d989, n with False for expression
#0xdc6e (lxxx)
#TODO: refactor away C++, support C explicitly
#TODO: Objective C, Pascal, more?

#TODO: saved registers from unwind info

headers = ["Name", "Location"]

class SeveralFunctionsError(Exception):
    pass

#######################################################################

class LocalsModel(QAbstractTableModel):
    # Data is a list (is_scope, name, location, die)
    def __init__(self, data, expr_formatter):
        QAbstractTableModel.__init__(self)
        self.data = data
        self.expr_formatter = expr_formatter

    def headerData(self, section, ori, role):
        if ori == Qt.Orientation.Horizontal and role == Qt.ItemDataRole.DisplayRole:
            return headers[section]

    def rowCount(self, parent):
        return len(self.data)

    def columnCount(self, parent):
        return 2

    def data(self, index, role):
        (row, col) = (index.row(), index.column())
        the_row = self.data[row]
        val = the_row[col+1]
        if role == Qt.ItemDataRole.DisplayRole:
            if col == 1 and not the_row[0]: # Location on a variable
                if val is False: # No location
                    return '<N/A>'
                elif len(val) == 0: # Loclist, but not for the given address
                    return '<N/A>'
                elif len(val) > 3: # Variable
                    return "; ".join(self.expr_formatter.format_op(*op) for op in val[0:3]) + "...+%d" % (len(val)-3)
                else:
                    return "; ".join(self.expr_formatter.format_op(*op) for op in val)
            return val
        elif role == Qt.ItemDataRole.FontRole:
            if the_row[0]:
                return bold_font()
        elif role == Qt.ItemDataRole.ToolTipRole:
            if col == 1 and not the_row[0]: # On the location column of a variable
                if val is False:
                    return 'No location provided'
                elif len(val) == 0:
                    return 'The variable was optimized away at the provided address'
                elif len(val) > 3:
                    return "; ".join(self.expr_formatter.format_op(*op) for op in val)

############################################################################
class LoadedModuleDlgBase(QDialog):
    _last_start_address = 0 # Stored as int

    def __init__(self, win):
        QDialog.__init__(self, win, Qt.WindowType.Dialog)

    @classmethod
    def reset(cl, di):
        cl._last_start_address = di._start_address

#############################################################################

class LocalsDlg(LoadedModuleDlgBase):
    _last_address = '' # Stored as string to allow for blank
    
    def __init__(self, win, di, prefix, regnames, hexadecimal):
        LoadedModuleDlgBase.__init__(self, win)
        self.selected_die = False
        self.resize(500, 400)
        self.dwarfinfo = di
        if di._locparser is None:
            di._locparser = LocationParser(di.location_lists())
        if not di._ranges:
            di._ranges = di.range_lists()            
        if not di._aranges:
            di._aranges = di.get_aranges()

        self.expr_formatter = ExprFormatter(regnames, prefix, di.config.machine_arch, 2, hexadecimal) # DWARF version is unknowable for now

        ly = QVBoxLayout()
        l = QLabel(self)
        l.setText("Provide a hex code address:")
        ly.addWidget(l)
        self.address = QLineEdit(self._last_address, self)
        ly.addWidget(self.address)
        l = QLabel(self)
        l.setText("Assuming the module is loaded at:")
        ly.addWidget(l)
        self.start_address = QLineEdit(hex(self._last_start_address), self)
        ly.addWidget(self.start_address)

        buttons = QDialogButtonBox(self)
        bu = QPushButton("Check", self)
        bu.clicked.connect(self.on_check)
        buttons.addButton(bu, QDialogButtonBox.ButtonRole.ApplyRole)
        ly.addWidget(buttons)

        self.locals = QTableView()
        self.locals.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
        self.locals.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)
        self.locals.doubleClicked.connect(self.navigate_to_index)
        ly.addWidget(self.locals)

        buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Close, Qt.Orientation.Horizontal, self)
        self.nav_bu = QPushButton("Navigate", self)
        self.nav_bu.clicked.connect(lambda: self.navigate_to_index(self.locals.currentIndex()))
        self.nav_bu.setEnabled(False)
        buttons.addButton(self.nav_bu, QDialogButtonBox.ButtonRole.ApplyRole)
        buttons.accepted.connect(self.reject)
        buttons.rejected.connect(self.reject)
        ly.addWidget(buttons)
        self.setWindowTitle('Locals at address')
        self.setLayout(ly)

    def on_check(self): #TODO: relocate absolute addresses in expressions
        try: # Try of just in case
            with WaitCursor():
                self.nav_bu.setEnabled(False) # Even if error, stay disabled

                try:
                    # Hex, with or without the 0x prefix
                    address = int(self.address.text(), 16)
                    real_start_address = int(self.start_address.text(), 16)
                except ValueError:
                    return
                
                LocalsDlg._last_address = self.address.text()
                LocalsDlg._last_start_address = real_start_address

                preferred_start_address = self.dwarfinfo._start_address
                address += preferred_start_address - real_start_address # Now relative to the preferred start address
                self.expr_formatter.set_address_delta(real_start_address - preferred_start_address) # Relocate addr on the way out
                self.expr_formatter.cfa_resolver = lambda: self.resolve_cfa(address)

                # Find the CU for the address
                di = self.dwarfinfo
                funcs = False
                cu = find_cu_by_address(di, address)
                if cu is not None:
                    # Find the function(s) at the address - could be some inlines
                    funcs = find_funcs_at_address(cu, address)
                
                if not funcs: # No CUs or no functions at that IP
                    QMessageBox(QMessageBox.Icon.Information, "DWARF Explorer", 
                        "No functions were found at that code address.", QMessageBox.StandardButton.Ok, self).show()
                    return

                if len(funcs) != 1:
                    raise SeveralFunctionsError()

                func = funcs[0]
                (origin, func_desc) = follow_function_spec(func)
                # This the file:line of the IP. It points at the innermost inline
                file_and_line = get_source_line(func, address)
                (address_file, address_line) = ("(unknown)",0) if file_and_line is None else file_and_line
                (func_name, mangled_func_name) = retrieve_function_names(func_desc, func)

                frames = [] # a collection of (func_name, file, line, die, locals), innermost at the top
                while True: # Loop by function from outermost to innermost; inside the top level one there might be inlines
                    (locals, next_func) = scan_scope(func, address)
                    if next_func: # Found a nested inline function, move on to that
                        call_file = get_source_file_name_from_attr(next_func, 'DW_AT_call_file') or '?'
                        call_line = next_func.attributes['DW_AT_call_line'].value if 'DW_AT_call_line' in next_func.attributes else '?'
                        frames.insert(0, (func_name, call_file, call_line, func, locals))
                        func = next_func
                        (inline_func, inline_func_spec) = follow_function_spec(func)
                        (func_name, mangled_func_name) = retrieve_function_names(inline_func_spec, inline_func)
                    else:
                        frames.insert(0, (func_name, address_file, address_line, func, locals))
                        break

                # Now render to lines:
                grid_lines = []
                for (name, file, line, func_die, locals) in frames:
                    grid_lines.append((True, name, '%s:%d' % (file, line), func_die))
                    self.expr_formatter.dwarf_version = func_die.cu['version'] # The variable should not be in a different CU than the containing function
                    for (name, expr, die) in locals:
                        grid_lines.append((False, name,  expr, die))

                # Finally display
                self.locals.setModel(LocalsModel(grid_lines, self.expr_formatter))
                self.locals.selectionModel().currentChanged.connect(self.on_sel)
                header = self.locals.horizontalHeader()
                header.setSectionResizeMode(0, QHeaderView.ResizeMode.Stretch)
                header.setSectionResizeMode(1, QHeaderView.ResizeMode.ResizeToContents)
        except SeveralFunctionsError:
            QMessageBox(QMessageBox.Icon.Warning, "DWARF Explorer", 
                "Expected one function with that address, found %d." % (len(funcs),), QMessageBox.StandardButton.Ok, self).show()
        except NoBaseError:
            # Any user followup maybe?
            QMessageBox(QMessageBox.Icon.Warning, "DWARF Explorer", 
                "Unexpected error while analysing the debug information." % (len(funcs),), QMessageBox.StandardButton.Ok, self).show()
        except NotImplementedError as exc:
            QMessageBox(QMessageBox.Icon.Warning, "DWARF Explorer", 
                "This feature is not supported on DWARF v1 yet.", QMessageBox.StandardButton.Ok, self).show()
        except Exception as exc:
            QMessageBox(QMessageBox.Icon.Critical, "DWARF Explorer", 
                "Unexpected error while analysing the debug information.", QMessageBox.StandardButton.Ok, self).show()

    def navigate_to_index(self, index):
        row = index.row()
        self.selected_die = self.locals.model().data[row][3]
        self.done(QDialog.DialogCode.Accepted)

    def on_sel(self, index, prev = None):
        self.nav_bu.setEnabled(index.isValid())

    def resolve_cfa(self, address):
        di = self.dwarfinfo
        if di.has_CFI():
            entries = di.CFI_entries()
        elif di.has_EH_CFI():
            entries = di.EH_CFI_entries()
        else:
            return False
        
        for e in entries:
            if isinstance(e, FDE) and e.header.initial_location <= address < e.header.initial_location + e.header.address_range:
                decoded = e.get_decoded().table
                de = next(reversed([de for de in decoded if de['pc'] <= address]))
                if 'cfa' in de:
                    rule = de['cfa']
                    if isinstance(rule, CFARule):
                        if rule.expr:
                            return 'expr'
                        else:
                            return self.expr_formatter.regname(rule.reg) + format_offset(rule.offset)
                    else:
                        return 'unknown'

    @classmethod
    def reset(cl):
        cl._last_address = ''


```

`dwex/locs.py`:

```py
from elftools.dwarf.locationlists import LocationParser, LocationExpr, BaseAddressEntry
from elftools.common.exceptions import ELFParseError
from elftools.dwarf.callframe import FDE

from .exprdlg import ExpressionTableModel
from .details import GenericTableModel
from .dwarfutil import *
from .ranges import lowlevel_v5_tooltips, one_of
from .exprutil import format_offset, is_parsed_expression

def parse_location(self, attr):
    di = self.die.dwarfinfo
    if di._locparser is None:
        di._locparser = LocationParser(di.location_lists())

    # Patch for #1620: attribute is loclist pointer, but no loclists section
    if LocationParser._attribute_is_loclistptr_class(attr) and LocationParser._attribute_has_loc_list(attr, self.die.cu['version']) and not di._locparser.location_lists:
        return None
    
    try:
        return di._locparser.parse_from_attribute(attr, self.die.cu['version'], die = self.die)
    except ELFParseError as exc:
        from .__main__ import version
        from .crash import report_crash
        from inspect import currentframe

        die = self.die
        header = die.cu.header
        dwarf_version = die.cu.header.version
        di = die.cu.dwarfinfo
        ctxt = {'attr': attr,
                'die': die,
                'cu_header': header,
                'LE': di.config.little_endian,
                'dwarf_version': dwarf_version}
        try:
            if LocationParser._attribute_has_loc_list(attr, self.die.cu['version']):
                tb = exc.__traceback__
                tracebacks = []
                while tb.tb_next:
                    tracebacks.insert(0, tb) # Innermost in the beginning of the list
                    tb = tb.tb_next
                loc_section = di.debug_loclists_sec if dwarf_version >= 5 else di.debug_loc_sec
                if loc_section:
                    buf = loc_section.stream.getbuffer()
                    ctxt['loc_section_len'] = len(buf)
                    if len(tracebacks) > 1 and 'entry_offset' in tracebacks[1].tb_frame.f_locals:
                        fail_entry_offset = tracebacks[1].tb_frame.f_locals['entry_offset']
                        llend = fail_entry_offset + 8*2+2 if fail_entry_offset - attr.value <= 1024 else attr.value + 1024
                        llbytes = buf[attr.value:llend]
                        ctxt['llbytes'] = ' '.join("%02x" % b for b in llbytes)
                        for (k, v) in tracebacks[1].tb_frame.f_locals.items():
                            ctxt['_pllfs_' + k] = v
                        ctxt['llparser_addr_size'] = tracebacks[1].tb_frame.f_locals['self'].structs.address_size
        except:
            pass

        report_crash(exc, tb, version, currentframe(), ctxt)
        return None

# Returns a TableModel for the details table
# Usually a GenericTableModel
# Logically in DIETableModel class
def show_location(self, attr):
# Expression is a list of ints
# TODO: clickable expression maybe?
# TODO: truncate long expressions?
    ll = self.parse_location(attr)
    if ll is None:
        return None
    elif isinstance(ll, LocationExpr): # Location expression: spell out the commands in the details window
        if ll.loc_expr == [156] and has_code_location(self.die): # Special case of a single call_frame_cfa instruction
            def desc_CFA_rule(rule):
                if rule.expr is not None:
                    return self.dump_expr(rule.expr)
                else:
                    return self.expr_formatter.format_regoffset(rule.reg, rule.offset)

            rules = [(r['pc'], r['cfa']) for r in get_frame_rules_for_die(self.die) if 'cfa' in r]
            rules = [(pc, r) for (i, (pc, r)) in enumerate(rules) if i == 0 or rules[i-1][1] != r.reg or rules[i-1][1].offset != r.offset or rules[i-1][1].expr != r.expr]
            lines = [(f"0x{pc:x}", desc_CFA_rule(cfa_rule)) for (pc, cfa_rule) in rules]
            return GenericTableModel(("Address", "CFA expression"), lines)
        else:
            return ExpressionTableModel(self.parse_expr(ll.loc_expr), self.expr_formatter)
    else: # Loclist - location lines in the details window, double-click navigates to expression
        return self.show_loclist(ll, attr.value)
    
def show_loclist(self, ll, ll_offset):
    # Returns a table model for a loclist
    cu_base = None
    def base_for_entry(l): # May throw NoBaseException
        nonlocal cu_base
        if l.is_absolute:
            return 0
        else:
            if cu_base is None:
                cu_base = get_cu_base(self.die) # Throws here
            return cu_base

    values = list()
    lowlevel = self.lowlevel
    if lowlevel:
        ver5 = self.die.cu['version'] >= 5
        if ver5:
            headers = ("Entry offset", "Type", "Start/Index/Base", "End/Index/Length", "Start address", "End address", "Expr bytes", "Expression")
            raw_ll = self.die.dwarfinfo.location_lists().get_location_lists_at_offset_ex(ll_offset, self.die)
        else:
            headers = ("Entry offset", "Type", "Start address", "End address", "Expr bytes", "Expression")
        for (i, l) in enumerate(raw_ll if ver5 else ll):
            if ver5: #l is raw
                raw = l
                l = ll[i] # Translated entry

            if isinstance(l, BaseAddressEntry):
                cu_base = l.base_address
                if ver5:
                    (raw_base_type, raw_base) = one_of(raw, ('index','address'))
                    values.append((hex(l.entry_offset),
                        raw.entry_type if self.prefix else raw.entry_type[7:],
                        hex(raw_base) if raw_base_type == 1 else str(raw_base),
                        '',
                        hex(l.base_address),
                        '', '', ''))
                else:
                    values.append((hex(l.entry_offset), 'Base', hex(l.base_address), '', '', ''))
            else:
                try: # Catching #1609
                    expr = self.parse_expr(l.loc_expr)
                    expr_dump = self.format_expr(expr, 5)
                except KeyError as exc:
                    expr = None
                    expr_dump = "<unrecognized expression>"
                    from .__main__ import version
                    from .crash import report_crash
                    from inspect import currentframe
                    report_crash(exc, exc.__traceback__, version, currentframe())
                base = base_for_entry(l)
                if ver5:
                    is_def_loc = raw.entry_type == 'DW_LLE_default_location'
                    (raw_start_type, raw_start) = one_of(raw, ('index', 'start_index', 'start_offset', 'start_address'))
                    (raw_end_type, raw_end) = one_of(raw, ('end_index', 'length', 'end_offset', 'end_address'))
                    values.append((hex(l.entry_offset),
                        raw.entry_type if self.prefix else raw.entry_type[7:],
                        '' if is_def_loc else (hex(raw_start) if raw_start_type >= 2 else str(raw_start)),
                        '' if is_def_loc else (hex(raw_end) if raw_end_type >= 2 or (raw_end_type == 1 and self.hex) else str(raw_end)),
                        hex(base + l.begin_offset),
                        hex(base + l.end_offset),
                        ' '.join("%02x" % b for b in l.loc_expr),
                        expr_dump,
                        expr))
                else:
                    values.append((hex(l.entry_offset),
                        'Range',
                        hex(base + l.begin_offset),
                        hex(base + l.end_offset),
                        ' '.join("%02x" % b for b in l.loc_expr),
                        expr_dump,
                        expr))
    else: # Not low level
        headers = ("Start address", "End address", "Expression")
        for l in ll:
            if 'base_address' in l._fields:
                cu_base = l.base_address
            else:
                try: # Catching #1609
                    expr = self.parse_expr(l.loc_expr)
                    expr_dump = self.format_expr(expr, 5)
                except KeyError as exc:
                    expr = None
                    expr_dump = "<unrecognized expression>"
                    from .__main__ import version
                    from .crash import report_crash
                    from inspect import currentframe
                    report_crash(exc, exc.__traceback__, version, currentframe())
                base = base_for_entry(l)
                values.append((hex(base + l.begin_offset),
                    hex(base + l.end_offset),
                    expr_dump,
                    expr))
                
    def get_tooltip(row, col, entry):
        if len(entry) >= 2 and is_parsed_expression(entry[-1]):
            return 'Double-click for details'
        elif lowlevel and ver5:
            return lowlevel_v5_tooltips(raw_ll[row], col-2)

    return GenericTableModel(headers, values, get_tooltip=get_tooltip)
    
def resolve_cfa(self):
    rules = get_frame_rules_for_die(self.die)
    if not rules: # Shorting out 1747
        return None
    rules = [r['cfa'] for r in rules if 'cfa' in r]
    rules = [r for (i, r) in enumerate(rules) if i == 0 or rules[i-1].reg != r.reg or rules[i-1].offset != r.offset]
    if len(rules) == 1:
        rule = rules[0]
        if rule.expr is None:
            return self.expr_formatter.regname(rule.reg) + format_offset(rule.offset)
    return None
```

`dwex/machounwind.py`:

```py
#!/usr/bin/env python
#-------------------------------------------------------------------------------
#
# A parser for the Mach-O __unwind_info section, based on format description from:
# https://faultlore.com/blah/compact-unwinding/
# https://github.com/llvm-mirror/libunwind/blob/master/include/mach-o/compact_unwind_encoding.h
# Lehmer code implementation taken from https://github.com/mateuszchudyk/lehmer/
#
# Seva Alekseyev (sevaa@sprynet.com)
# This code is in the public domain
#-------------------------------------------------------------------------------

from bisect import bisect_left
from collections import namedtuple
from enum import Enum
from struct import unpack_from

# MachO cputype values that we care for
class CpuType(Enum):
    I386 = 7
    X86_64 = 0x01000007
    ARM = 0xc
    ARM64 = 0x0100000c

Header = namedtuple('Header', ('version', 'global_encodings_offset', 'global_encodings_length', 'personalities_offset', 'personalities_length', 'pages_offset', 'pages_length'))
PageHeader = namedtuple('PageHeader', ('first_address', 'second_level_page_offset', 'lsda_index_offset'))
Page = namedtuple('Page', ('header', 'entries'))
LSDA = namedtuple('LSDA', ('instruction_address', 'lsda_address'))
UnwindEntry = namedtuple('UnwindEntry', ('address', 'encoding', 'command', 'arg'))
PushOrderARM64 = (19, 21, 23, 25, 27, 8, 10, 12, 14) 
RegOrderx86 = (3, 1, 2, 7, 6, 5) # ebx ecx edx edi esi ebp
RegOrderx64 = (3, 12, 13, 14, 15, 6) # rbx r12 r13 r14 r15 rbp
DecodedEntry = namedtuple('DecodedEntry', ('raw', 'has_frame', 'cfa_base_register', 'cfa_offset', 'saved_registers'))
FallbackEntry = namedtuple('FallbackEntry', ('raw', 'offset'))
NopEntry = namedtuple('NopEntry', ('raw'))

# AArch64 calling convention: 19-29 callee saved, x29=fp, x30=lr, x31=sp
class UnwindCommandARM64(Enum):
    Nop = 0
    # There is code there, but the stack structure is unknown

    Frameless = 2
    # x29 untouched, LR is the return address
    # SP reduced by (arg*16)
    # I don't have a sample

    EH = 3
    # Fallback to eh_frame, arg is FDE offset in eh_frame

    Frame = 4
    # arg is a tuple of 9 booleans, if the respective reg pair was saved in the prologue
    # Register pair order in the arg tuple:
    # 19/20 21/22 23/24 25/26 27/29 8/9 10/11 12/13 14/15
    # If they are pushed, they are pushed in this order, so offsets from sp go in the opposite order
    
class UnwindCommandIntel(Enum):
    Nop = 0

    Frame = 1
    # arg is a tuple of (offset, saved_regs)
    # where saved_regs is a a tuple of 5 register numbers
    # numbers correspond to either
    # None ebx ecx edx edi esi ebp
    # Or
    # None rbx r12 r13 r14 r15 rbp

    FramelessImmediate = 2
    # arg is a tuple of (stack_size, register_count, permutation)
    
    FramelessIndirect = 3
    # arg is a tuple of (instruction_offset, stack_adjust, reg_count, permutation)

    EH = 4
    # arg is the offset of the FDE in the eh_frame section

def tranlate_encoding_arm64(address, enc):
    """
        From encoding to a parsed operation. LSDA/personality stuff ignored.
    """
    # is_start = (enc & 0x80000000) != 0
    # has_lsda = (enc & 0x40000000) != 0
    # personality_index = (enc >> 28) & 3    
    cmd = UnwindCommandARM64((enc >> 24) & 0xf)
    if cmd == UnwindCommandARM64.Nop:
        arg = None
    elif cmd == UnwindCommandARM64.Frameless:
        arg = (enc >> 12) & 0xfff # Stack size
    elif cmd == UnwindCommandARM64.EH:
        arg = enc & 0xffffff # Offset in the eh_frame section
    elif cmd == UnwindCommandARM64.Frame:
        arg = tuple((enc & (1 << i)) != 0 for i in range(9)) # Map of which register pairs were saved on the stack
    # Else enum will raise an error
    return UnwindEntry(address, enc, cmd, arg)

def translate_encoding_intel(address, enc):
    """
        From encoding to a parsed operation. LSDA/personality stuff ignored. The x86/x64 distinction is irrelevant here.
    """
    # is_start = (enc & 0x80000000) != 0
    # has_lsda = (enc & 0x40000000) != 0
    # personality_index = (enc >> 28) & 3    
    cmd = UnwindCommandIntel((enc >> 24) & 0xf)
    if cmd == UnwindCommandIntel.Nop:
        arg = None
    elif cmd == UnwindCommandIntel.Frame:
        offset = (enc >> 16) & 0xff
        regs = tuple((enc >> i) & 7 for i in range(12, -3, -3))
        arg = (offset, regs)
    elif cmd == UnwindCommandIntel.FramelessImmediate:
        size = (enc >> 16) & 0xff
        n = (enc >> 10) & 7
        p = enc & 0x3f
        arg = (size, n, p)
    elif cmd == UnwindCommandIntel.FramelessIndirect:
        offset = (enc >> 16) & 0xff
        adj = (enc >> 13) & 7
        n = (enc >> 10) & 7
        p = enc & 0x3f
        arg = (offset, adj, n, p)
    elif cmd == UnwindCommandIntel.EH:
        arg = enc & 0xffffff # Offset in the eh_frame section
    return UnwindEntry(address, enc, cmd, arg)

class MachoUnwindInfo:
    """
    Holds the parsed unwind_info section. The LSDA/personality stuff is not decoded, with some stubs in place.
    Call find_by_address() to locate the unwind entry for a particular location in code.
    """
    def __init__(self, section_data, cputype, big_endian = False, text_section = None):
        """
        section_data:
            A bytes or a Buffer-compatible object with the unwind_info section contents

        cputype:
            The machine architecture code from the MachO file or fat slice header

        big_endian:
            True for a big-endian MachO file or fat slice, False for little-endian.
            To determine, check the magic in the MachO header: 0xfeedface and 0xfeedfacf are big endian.
            All three supported architectures use little endian on Apple platforms, so this is rather irrelevant.

        text_section:
            Reserved for when Intel FramelessIndirect decoding will be supported
        """
        cputype = CpuType(cputype)
        if cputype == CpuType.ARM64:
            translate_encoding = tranlate_encoding_arm64
            self.decode_entry = self.decode_entry_arm64
        elif cputype == CpuType.I386:
            translate_encoding = translate_encoding_intel
            self.decode_entry = lambda e: self.decode_entry_intel(e, 4, RegOrderx86, 5, 4, 8)
        elif cputype == CpuType.X86_64:
            translate_encoding = translate_encoding_intel
            self.decode_entry = lambda e: self.decode_entry_intel(e, 8, RegOrderx64, 6, 7, 16)
        else:
            raise NotImplementedError("Only x86, x86_64, and ARM64 are currently supported")
        self.cputype = cputype
        self.text = text_section

        endianness = '>' if big_endian else '<'
        self.header = header = Header(*unpack_from(endianness + 'IIIIIII', section_data, 0))
        page_headers = [PageHeader(*unpack_from(endianness + 'III', section_data, header.pages_offset + i*12)) for i in range(header.pages_length)]
        global_encodings = unpack_from(endianness + 'I'*header.global_encodings_length, section_data, header.global_encodings_offset)
        #personalities = unpack_from(endianness + 'I'*rph.personalities_length, unw, rph.personalities_offset)
        #lsda_offset = rph.pages_offset + rph.pages_length*12
        
        def process_page(page_header):
            page_offset = page_header.second_level_page_offset
            if page_offset: # Zero is possible in the final guard page that stores the effective end address
                (kind,) = unpack_from(endianness + 'I', section_data, page_offset)
                if kind == 2: # Regular second level page
                    (entries_offset, entries_length) = unpack_from(endianness + 'HH', section_data,  + 4)
                    entries = [translate_encoding(*unpack_from(endianness + 'II', section_data, page_offset + entries_offset + i*8)) for i in range(entries_length)]
                elif kind == 3: # Compressed second level page
                    (entries_offset, entries_length, encodings_offset, encodings_length) = unpack_from(endianness + 'HHHH', section_data, page_offset + 4)
                    raw_entries = unpack_from(endianness + 'I'*entries_length, section_data, page_offset + entries_offset)
                    encodings = unpack_from(endianness + 'I'*encodings_length, section_data, page_offset + encodings_offset)
                    all_encodings = global_encodings + encodings # :(
                    entries = [translate_encoding(page_header.first_address + e & 0xFFFFFF, all_encodings[(e>>24) & 0xff]) for e in raw_entries]
                else:
                    raise NotImplementedError(f"Unknown second level page kind {kind}")
            else:
                entries = None
            return Page(page_header, entries)
        
        self.pages = [process_page(page_header) for page_header in page_headers]

    def decode_entry_arm64(self, entry):
        cmd = entry.command
        if cmd == UnwindCommandARM64.Nop:
            return NopEntry(entry)
        elif cmd == UnwindCommandARM64.Frameless:
            return DecodedEntry(entry, False, 31, entry.arg, {})
        elif cmd == UnwindCommandARM64.EH:
            return FallbackEntry(entry, entry.arg)
        elif cmd == UnwindCommandARM64.Frame:
            # CFA at x29+16, x30 at CFA-16 x31 at CFA-8
            regs = {30: 16, 31: 8}
            off = 32
            for (i, r) in enumerate(entry.arg):
                if r:
                    base_regno = PushOrderARM64[i]
                    regs[base_regno] = off
                    regs[base_regno+1] = off - 8
                    off += 16
            return DecodedEntry(entry, True, 29, 16, regs)

    def decode_entry_intel(self, entry, rsize, arch_regmap, bp_regno, sp_regno, ip_regno):
        cmd = entry.command
        if cmd == UnwindCommandIntel.Nop:
            return NopEntry(entry)
        elif cmd == UnwindCommandIntel.Frame:
            # CFA at Xbp + 2*rsize
            # Saved Xbp at CFA-2*rsize (Xbp)
            # Return address at CFA-rsize (Xbp+rsize)
            # Registers go from CFA-3*rsize (Xbp-rsize) and up

            # Haven't seen cases where offset is not the same as the 5 minus count of leading zeros in the saved register array
            (offset, saved_regs) = entry.arg  # len(saved_regs) is 5
            regs = {bp_regno: 2*rsize, ip_regno: rsize}
            for (i, r) in enumerate(saved_regs):
                if r and i >= 5 - offset:
                    regs[arch_regmap[r-1]] = (i-2 + offset)*rsize
            return DecodedEntry(entry, True, bp_regno, 2*rsize, regs)
        elif cmd == UnwindCommandIntel.FramelessImmediate:
            raise NotImplementedError("Intel/FramelessImmediate is not supported yet")

            # CFA at Xsp + stack_size*rsize
            # return address at CFA-rsize
            # Pushed registers above that in the permutation order
            (stack_size, reg_count, permutation) = entry.arg
            regs = {ip_regno: rsize}
            if reg_count:
                pass
                #permutation = lehmer_decode(reg_count, permutation)
                #for (i, p) in enumerate(permutation):
                #    regs[arch_regmap[p]] = (2+i)*rsize
            return DecodedEntry(entry, False, sp_regno, stack_size*rsize, regs)
        elif cmd == UnwindCommandIntel.FramelessIndirect:
            raise NotImplementedError("Intel/FramelessIndirect is not supported yet")

            # x86_64 sub rsp, imm32 goes: 48 81 ec (imm32)
            # x86 sub esp, imm32 goes: 81 ec (imm32)            
            (instruction_offset, stack_adjust, reg_count, permutation) = entry.arg
            regs = {}
            if reg_count:
                permutation = lehmer_decode(reg_count, permutation)
                regs = {}
                # TODO the rest once I get an example
            else:
                regs = {}
            return DecodedEntry(entry, False, sp_regno, stack_size*rsize, regs)
        elif cmd == UnwindCommandIntel.EH:
            return FallbackEntry(entry, entry.arg)
    
    def find_by_address_raw(self, IP):
        """
            IP is relative to the preferred start address, as seen in the load segment command for the __TEXT segment.
            Returns a DecodedEntry, or None if the IP can't be found or the entry is a null one, or False if fallback to EH is in order
        """
        # TODO: key
        i = bisect_left([p.header.first_address for p in self.pages], IP)
        if i:
            entries = self.pages[i-1].entries
            i = bisect_left([e.address for e in entries], IP) - 1 # Supposed to be sorted
            return entries[i]

    def find_by_address(self, IP):
        """
            IP is relative to the preferred start address, as seen in the load segment command for the __TEXT segment.
            Returns:
                - None if the IP can't be found (doesn't distinguish between first level and second level lookup fails)
                - DecodedEntry
                - FallbackEntry (with "offset" being offset of the FDE in the eh_frame section, but mind the address interpretation)
                - NopEntry

            DecodedEntry fields are:
             - has_frame - whether a dedicated register (r29, rbp, ebp) is used for this function's frame base
             - cfa_base_register - DWARF number of the register that the CFA is relative to
             - cfa_offset - offset from the cfa_base_register to the CFA
             - saved_registers - maps DWARF register number to the offset (negative) from CFA where it is saved
        """
        return self.decode_entry(self.find_by_address_raw(IP))
    
_fact = (1, 1, 2, 6, 24, 120, 720)
def factorial(n):
    return _fact[n]

def lehmer_decode(length, lehmer):
    """Return permutation for the given Lehmer Code and permutation length. Result permutation contains
    number from 0 to length-1.
    """
    result = [(lehmer % factorial(length - i)) // factorial(length - 1 - i) for i in range(length)]
    used = [False] * length
    for i in range(length):
        counter = 0
        for j in range(length):
            if not used[j]:
                counter += 1
            if counter == result[i] + 1:
                result[i] = j
                used[j] = True
                break
    return result

```

`dwex/patch.py`:

```py
import os
from struct import Struct
from ctypes import LittleEndianStructure, c_ubyte, c_uint, sizeof
from types import MethodType
from io import BytesIO

import elftools.dwarf.enums
import elftools.dwarf.dwarf_expr
import elftools.dwarf.locationlists
import elftools.elf.elffile
import elftools.elf.dynamic
import elftools.dwarf.dwarfinfo
#import filebytes.mach_o
#import filebytes.pe
from elftools.common.utils import struct_parse
from elftools.common.exceptions import DWARFError
from elftools.dwarf.descriptions import _DESCR_DW_CC
from elftools.dwarf.dwarfinfo import DebugSectionDescriptor
from elftools.elf.relocation import RelocationHandler
from elftools.elf.sections import Section
from elftools.elf.dynamic import Dynamic
from elftools.dwarf.locationlists import LocationLists, LocationListsPair
from elftools.construct.core import StaticField
#from filebytes.mach_o import LSB_64_Section, MH, SectionData, LoadCommand, LoadCommandData, LC

# Good reference on DWARF extensions here:
# https://sourceware.org/elfutils/DwarfExtensions

# ELF reference:
# https://refspecs.linuxfoundation.org/elf/gabi4+/ch4.sheader.html

# LLVM extensions for heterogeneous debugging
# https://llvm.org/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.html

#https://docs.hdoc.io/hdoc/llvm-project/e051F173385B23DEF.html

def monkeypatch():
    def get_location_list_at_offset(self, offset, die=None): # Fix for variable bitness in PS3
        if self.version >= 5 and die is None:
            raise DWARFError("For this binary, \"die\" needs to be provided")              
        self.stream.seek(offset, os.SEEK_SET)
        if die:
            self.structs = die.cu.structs
            self._max_addr = 2 ** (self.structs.address_size * 8) - 1
        return self._parse_location_list_from_stream_v5(die.cu) if self.version >= 5 else self._parse_location_list_from_stream()
    elftools.dwarf.locationlists.LocationLists.get_location_list_at_offset = get_location_list_at_offset

    # Raw location lists
    def get_location_list_at_offset_ex(self, offset, die=None):
        self.stream.seek(offset, os.SEEK_SET)
        if die:
            self.structs = die.cu.structs
            self._max_addr = 2 ** (self.structs.address_size * 8) - 1
        return [entry
            for entry
            in struct_parse(self.structs.Dwarf_loclists_entries, self.stream)]
    
    elftools.dwarf.locationlists.LocationLists.get_location_lists_at_offset_ex = get_location_list_at_offset_ex
    # Same for the pair object
    elftools.dwarf.locationlists.LocationListsPair.get_location_lists_at_offset_ex = lambda self, offset: self._loclists.get_location_lists_at_offset_ex(offset)

    # Fix for a corollary of 1683
    def get_range_list_at_offset(self, offset, cu=None):
        """ Get a range list at the given offset in the section.

            The cu argument is necessary if the ranges section is a
            DWARFv5 debug_rnglists one, and the target rangelist
            contains indirect encodings
        """
        if cu:
            self.structs = cu.structs
            self._max_addr = 2 ** (self.structs.address_size * 8) - 1            
        self.stream.seek(offset, os.SEEK_SET)
        return self._parse_range_list_from_stream(cu)
    def get_range_list_at_offset_ex(self, offset, cu=None):
        """Get a DWARF v5 range list, addresses and offsets unresolved,
        at the given offset in the section
        """
        if cu:
            self.structs = cu.structs
            self._max_addr = 2 ** (self.structs.address_size * 8) - 1            
        return struct_parse(self.structs.Dwarf_rnglists_entries, self.stream, offset)    
    elftools.dwarf.ranges.RangeLists.get_range_list_at_offset = get_range_list_at_offset
    elftools.dwarf.ranges.RangeLists.get_range_list_at_offset_ex = get_range_list_at_offset_ex

    # Fix for #1572, also for eliben/pyelftools#519
    def location_lists(self):
        """ Get a LocationLists object representing the .debug_loc/debug_loclists section of
            the DWARF data, or None if this section doesn't exist.
            If both sections exist, it returns a LocationListsPair.
        """
        if self.debug_loclists_sec and self.debug_loc_sec is None:
            return LocationLists(self.debug_loclists_sec.stream, self.structs, 5, self)
        elif self.debug_loc_sec and self.debug_loclists_sec is None:
            return LocationLists(self.debug_loc_sec.stream, self.structs, 4, self)
        elif self.debug_loc_sec and self.debug_loclists_sec:
            return LocationListsPair(self.debug_loc_sec.stream, self.debug_loclists_sec.stream, self.structs, self)
        else:
            return None
        
    elftools.dwarf.dwarfinfo.DWARFInfo.location_lists = location_lists

    # Fix for strtab link to NULL
    def DynamicSection_init(self, header, name, elffile):
        Section.__init__(self, header, name, elffile)
        stringtable = elffile.get_section(header['sh_link'], ('SHT_STRTAB', 'SHT_NOBITS', 'SHT_NULL'))
        Dynamic.__init__(self, self.stream, self.elffile, stringtable,
            self['sh_offset'], self['sh_type'] == 'SHT_NOBITS')
    elftools.elf.dynamic.DynamicSection.__init__ = DynamicSection_init

    # GNU opcodes - fix for #1740, except it's incompatible with the blob in the first crash
    elftools.dwarf.dwarf_expr.DW_OP_name2opcode['DW_OP_GNU_addr_index'] = 0xfb
    elftools.dwarf.dwarf_expr.DW_OP_name2opcode['DW_OP_GNU_const_index'] = 0xfc
    elftools.dwarf.dwarf_expr.DW_OP_name2opcode['DW_OP_GNU_variable_value'] = 0xfd

    elftools.dwarf.dwarf_expr.DW_OP_opcode2name[0xfb] = 'DW_OP_GNU_addr_index'
    elftools.dwarf.dwarf_expr.DW_OP_opcode2name[0xfc] = 'DW_OP_GNU_const_index'
    elftools.dwarf.dwarf_expr.DW_OP_opcode2name[0xfd] = 'DW_OP_GNU_variable_value'

    orig_init_dispatch_table = elftools.dwarf.dwarf_expr._init_dispatch_table
    def _init_dispatch_table(structs):
        dt = orig_init_dispatch_table(structs)
        f = lambda stream: [struct_parse(structs.the_Dwarf_uleb128, stream)]
        dt[0xfb] = f
        dt[0xfc] = f
        dt[0xfd] = f
        return dt
    elftools.dwarf.dwarf_expr._init_dispatch_table = _init_dispatch_table

    # Fix for 1516: ignore DW_AT_sibling for child enumeration on ELF/PPC
    def iter_DIE_children(self, die):
        """ Given a DIE, yields either its children, without null DIE list
            terminator, or nothing, if that DIE has no children.

            The null DIE terminator is saved in that DIE when iteration ended.
        """
        if not die.has_children:
            return

        # `cur_offset` tracks the stream offset of the next DIE to yield
        # as we iterate over our children,
        cur_offset = die.offset + die.size

        while True:
            child = self._get_cached_DIE(cur_offset)

            child.set_parent(die)

            if child.is_null():
                die._terminator = child
                return

            yield child

            if not child.has_children:
                cur_offset += child.size
            elif "DW_AT_sibling" in child.attributes and self.dwarfinfo._use_siblings:
                sibling = child.attributes["DW_AT_sibling"]
                if sibling.form in ('DW_FORM_ref1', 'DW_FORM_ref2',
                                    'DW_FORM_ref4', 'DW_FORM_ref8',
                                    'DW_FORM_ref', 'DW_FORM_ref_udata'):
                    cur_offset = sibling.value + self.cu_offset
                elif sibling.form == 'DW_FORM_ref_addr':
                    cur_offset = sibling.value
                else:
                    raise NotImplementedError('sibling in form %s' % sibling.form)
            else:
                # If no DW_AT_sibling attribute is provided by the producer
                # then the whole child subtree must be parsed to find its next
                # sibling. There is one zero byte representing null DIE
                # terminating children list. It is used to locate child subtree
                # bounds.

                # If children are not parsed yet, this instruction will manage
                # to recursive call of this function which will result in
                # setting of `_terminator` attribute of the `child`.
                if child._terminator is None:
                    for _ in self.iter_DIE_children(child):
                        pass

                cur_offset = child._terminator.offset + child._terminator.size
    elftools.dwarf.compileunit.CompileUnit.iter_DIE_children = iter_DIE_children

    # Fix for DW_FORM_strx
    orig_create_structs = elftools.dwarf.dwarfinfo.DWARFStructs._create_structs
    def _create_structs(self):
        orig_create_structs(self)
        self.Dwarf_dw_form['DW_FORM_strx'] = self.the_Dwarf_uleb128
    elftools.dwarf.dwarfinfo.DWARFStructs._create_structs = _create_structs

```

`dwex/ranges.py`:

```py
from .die import GenericTableModel
from elftools.dwarf.ranges import BaseAddressEntry as RangeBaseAddressEntry, RangeEntry
from .dwarfutil import get_cu_base, NoBaseError
from .details import GenericTableModel

def one_of(o, attrs):
    return next(((i, o[attr]) for (i,attr) in enumerate(attrs) if attr in o), (None, None))

def lowlevel_v5_tooltips(entry, col):
    type = entry.entry_type[7:]
    if col == 0: # Start
        if type == 'base_address':
            return 'Base address for entries below'
        elif type == 'offset_pair':
            return 'Starting offset relative to the current base'
        elif type == 'start_end' or type == 'start_length':
            return 'Starting address, absolute'
        elif type == 'base_addressx':
            return 'Index into the address table, resolving to absolute address'
        elif type == 'startx_endx' or type == 'startx_length':
            return 'Index into the address table, resolving to absolute address'
    elif col == 1: # End
        if type == 'offset_pair':
            return 'Ending offset relative to the current base'
        elif type == 'start_end':
            return 'Ending address, absolute'
        elif type == 'start_length' or type == 'startx_length':
            return 'Length of the range'
        elif type == 'startx_endx':
            return 'Index into the address table, resolving to absolute address'

# This is a method of DIETableModel
def show_ranges(self, attr):
    di = self.die.dwarfinfo
    if not di._ranges:
        di._ranges = di.range_lists()
    if not di._ranges: # Absent in the DWARF file
        return None
    v5 = self.die.cu['version'] >= 5
    ll = self.lowlevel

    if v5 and ll: # Dump untranslated v5 entries
        ranges = di._ranges.get_range_list_at_offset_ex(attr.value, cu = self.die.cu)
        has_relative_entries = next((r for r in ranges if r.entry_type == 'DW_RLE_offset_pair'), False)
    else:
        ranges = di._ranges.get_range_list_at_offset(attr.value, cu = self.die.cu)
        has_relative_entries = next((r for r in ranges if isinstance(r, RangeEntry) and not r.is_absolute), False)

    warn = None
    lines = []
    if len(ranges):
        cu_base = 0
        # Do we need the base address? We might not.
        if has_relative_entries and not isinstance(ranges[0], RangeBaseAddressEntry):
            try:
                cu_base = get_cu_base(self.die)
            except NoBaseError:
                warn = "Base address not found, assuming 0"

        for r in ranges:
            if v5 and ll: # Dump untranslated v5 entries
                # see _create_rnglists_parsers in elftools/dwarf/structs to see what can be in there
                (start_type, start) = one_of(r, ('index', 'start_index', 'start_offset', 'address', 'start_address'))
                (end_type, end) = one_of(r, ('end_index', 'length', 'end_offset', 'end_address'))
                translated = di._ranges.translate_v5_entry(r, self.die.cu)
                base = 0 if isinstance(translated, RangeEntry) and translated.is_absolute else cu_base
                lines.append((hex(r.entry_offset),
                    r.entry_type if self.prefix else r.entry_type[7:],
                    str(start) if start_type <= 1 else hex(start),
                    (str(end) if end_type == 0 or (end_type == 1 and not self.hex) else hex(end)) if end is not None else '',
                    hex(base + translated.begin_offset if isinstance(translated, RangeEntry) else translated.base_address), 
                    hex(base + translated.end_offset) if isinstance(translated, RangeEntry) else ''
                    ))
                if isinstance(translated, RangeBaseAddressEntry):
                    cu_base = translated.base_address
            else: # V4 or highlevel V5
                if isinstance(r, RangeEntry):
                    base = 0 if r.is_absolute else cu_base
                    if ll: # V4, low level
                        lines.append((hex(r.entry_offset),
                            "Range",
                            hex(r.begin_offset),
                            hex(r.end_offset),
                            hex(base + r.begin_offset),
                            hex(base + r.end_offset),
                            ))
                    else: # V4 high level or translated V5
                        lines.append((hex(base + r.begin_offset),
                                      hex(base + r.end_offset)))
                else: # Base entry
                    if ll:
                        lines.append((hex(r.entry_offset), "Base", hex(r.base_address), '', '', ''))
                    cu_base = r.base_address
    else:
        warn = "Empty range list"

    if v5 and ll:
        headers = ("Entry offset", "Type", "Start/Index/Base", "End/Index/Length", "Start address", "End address")
    elif ll: #Low level and V4
        headers = ("Entry offset", "Type", "Start offset/Base", "End offset", "Start address", "End address")
    else: 
        headers = ("Start address", "End address")
        
    return GenericTableModel(headers, lines, warn,
        get_tooltip=lambda row, col, _: lowlevel_v5_tooltips(ranges[row], col-2) if v5 and ll else None)

```

`dwex/scriptdlg.py`:

```py
from PyQt6.QtCore import Qt
from PyQt6.QtWidgets import *
from elftools.dwarf.locationlists import LocationParser

class ScriptDlg(QDialog):
    def __init__(self, win, sample_die):
        from sys import version_info
        QDialog.__init__(self, win, Qt.WindowType.Dialog)
        self.sample_die = sample_die
        ly = QVBoxLayout()
        ly.addWidget(QLabel("Provide a Python %d.%d expression for the \"die\" object:" % (version_info.major, version_info.minor), self))
        self.text = QPlainTextEdit(self)
        ly.addWidget(self.text)
        l = QLabel("<a href=\"https://github.com/sevaa/dwex/wiki/About-expressions\">See the guide</a>", self)
        l.linkActivated.connect(self.on_see_guide)
        ly.addWidget(l)
        buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok|QDialogButtonBox.StandardButton.Cancel, Qt.Orientation.Horizontal, self)
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        ly.addWidget(buttons)
        self.setWindowTitle('Condition')
        self.setLayout(ly)

    def on_see_guide(self, link):
        try:
            import webbrowser
            webbrowser.open(link, new=0, autoraise=True)
        except:
            pass

    def accept(self):
        self.py = self.text.document().toPlainText()
        if not self.py:
            QMessageBox(QMessageBox.Icon.Warning, "Error",
                "Please provide a Python expression that inspects the \"die\" object.", QMessageBox.StandardButton.Ok, self).show()
        else:
            try:
                self.cond = compile(self.py, 'inline', 'eval')
            except Exception as exc:
                QMessageBox(QMessageBox.Icon.Warning, "Python error",
                    "Python syntax error: " + format(exc), QMessageBox.StandardButton.Ok, self).show()
                return
            
            try:
                env = make_execution_environment(self.sample_die)
            except Exception: #Our error - do not surface
                QDialog.accept(self)
                return

            try:
                eval(self.cond, env)
            except Exception as exc:
                mb = QMessageBox(QMessageBox.Icon.Question, "Python error",
                    "Python execution error (%s) on a sample DIE. Use anyway?\n\n%s" % (type(exc).__name__, format(exc)),
                    QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.No, self)
                mb.setEscapeButton(QMessageBox.StandardButton.No)
                if mb.exec() == QMessageBox.StandardButton.No:
                    return
            
            QDialog.accept(self)

def make_execution_environment(die):
    def has_attribute(func):
        for k in die.attributes:
            if func(k, die.attributes[k].value, die.attributes[k].form):
                return True
            
    def has_loclist():
        ver = die.cu.header.version
        def attr_is_loclist(attr):
            return (LocationParser._attribute_is_loclistptr_class(attr) and
                LocationParser._attribute_has_loc_list(attr, ver))
        g = (a for a in die.attributes if attr_is_loclist(die.attributes[a]))
        return bool(next(g, False))
            
    d = {'die' : die,
            'tag': 'user_%X' % (die.tag,) if isinstance(die.tag, int) else die.tag[7:],
            'attr': die.attributes,
            'has_attribute' : has_attribute,
            'has_loclist' : has_loclist}
    for k, a in die.attributes.items():
        d['user_%X' % (k,) if isinstance(k, int) else k[6:]] = a.value
    return d
            


    
        

```

`dwex/tree.py`:

```py
from bisect import bisect_left, bisect_right
from typing import Union
from PyQt6.QtCore import Qt, QAbstractItemModel, QModelIndex
from PyQt6.QtWidgets import QApplication

from elftools.dwarf.die import DIE
from elftools.dwarf.compileunit import CompileUnit

from .fx import bold_font, blue_brush
from .dwarfutil import DIE_has_name, DIE_name, has_code_location, safe_DIE_name, top_die_file_name
from .dwarfone import DIEV1


def cu_sort_key(cu):
    return top_die_file_name(cu.get_top_DIE()).lower()

def die_sort_key(die):
    name = safe_DIE_name(die)
    tag = '%X' % die.tag if isinstance(die.tag, int) else die.tag
    return (tag, name, die.offset)

#------------------------------------------------
# CU tree formatter
#------------------------------------------------    

# Some additional data for every DIE
def decorate_die(die, i):
    die._i = i
    die._children = None
    return die

def load_children(parent_die: Union[DIE, DIEV1] , sort: bool): #(parent_die: Union[DIE, DIEV1] , sort: bool):
    # Load and cache child DIEs in the parent DIE, if necessary
    # Assumes the check if the DIE has children has been already performed
    if not hasattr(parent_die, "_children") or parent_die._children is None:
        # TODO: wait cursor here.
        try:
            parent_die._children = [decorate_die(die, i) for (i, die) in enumerate(parent_die.iter_children())]
            if sort:
                parent_die._children.sort(key = die_sort_key)
                for (i, die) in enumerate(parent_die._children):
                    die._i = i
        except KeyError as exc:
            # Catching #1516
            from .__main__ import version
            from .crash import report_crash
            from inspect import currentframe
            tb = exc.__traceback__
            ctxt = dict()
            try:
                cu = parent_die.cu
                ctxt['cu_offset'] = cu.cu_offset
                ctxt['dwarf_config'] = cu.dwarfinfo.config
                abbrev_codes = set(d.abbrev_code for d in cu._dielist if not d.is_null())
                at = cu.get_abbrev_table()
                format_attr_in_abbrev = lambda a: (a.name, a.form, a.value) if a.value is not None else (a.name, a.form)
                format_abbr = lambda ab: (ab.decl.tag, ab._has_children, tuple(format_attr_in_abbrev(a) for a in ab.decl.attr_spec))
                ctxt['abbrevs'] = {c: format_abbr(at.get_abbrev(c)) for c in abbrev_codes}
                stm = cu.dwarfinfo.debug_info_sec.stream
                crash_pos = ctxt['crash_pos'] = stm.tell()
                slice = stm.getbuffer()[cu.cu_offset:crash_pos+1]
                ctxt['cu_in_info'] =  ' '.join("%02x" % b for b in slice)
            except Exception:
                pass
            report_crash(exc, tb, version, currentframe(), ctxt)

            QApplication.instance().win.show_warning("This executable file is corrupt or incompatible with the current version of DWARF Explorer. Please consider creating a new issue at https://github.com/sevaa/dwex/, and share this file with the tech support.")
            parent_die._children = []

class DWARFTreeModel(QAbstractItemModel):
    def __init__(self, di, prefix, sortcus, sortdies):
        QAbstractItemModel.__init__(self)
        self.prefix = prefix
        self.top_dies = [decorate_die(CU.get_top_DIE(), i) for (i, CU) in enumerate(di._CUs)]
        self.highlight_condition = None
        self.sortcus = sortcus
        self.sortdies = sortdies

    # Qt callbacks. QTreeView supports progressive loading, as long as you feed it the "item has children" bit in advance

    def index(self, row, col, parent):
        if parent.isValid():
            parent_die = parent.internalPointer()
            # print("child of %s" % parent_die.tag)
            load_children(parent_die, self.sortdies)
            return self.createIndex(row, col, parent_die._children[row])
        else:
            return self.createIndex(row, col, self.top_dies[row])
        return QModelIndex()

    def flags(self, index):
        f = Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEnabled
        if index.isValid() and not index.internalPointer().has_children:
            f = f | Qt.ItemFlag.ItemNeverHasChildren
        return f

    def hasChildren(self, index):
        return not index.isValid() or index.internalPointer().has_children

    def rowCount(self, parent):
        if parent.isValid():
            parent_die = parent.internalPointer()
            # print('rcount of %s' % parent_die.tag)
            if not parent_die.has_children: # Legitimately nothing
                return 0
            else:
                load_children(parent_die, self.sortdies)
                return len(parent_die._children)
        else:
            return len(self.top_dies)

    def columnCount(self, parent):
        return 1

    def parent(self, index):
        if index.isValid():
            parent = index.internalPointer().get_parent()
            if parent:
                return self.createIndex(parent._i, 0, parent)
        return QModelIndex()

    def data(self, index, role):
        die = index.internalPointer()
        if role == Qt.ItemDataRole.DisplayRole:
            if die.tag == 'DW_TAG_compile_unit' or die.tag == 'DW_TAG_partial_unit': # CU/top die: return file name
                return top_die_file_name(die)
            else: # Return tag, with name if possible
                if isinstance(die.tag, int): # Happens with user tags, #1472
                    s = ('DW_TAG_user_%X' if self.prefix else 'user_%X') % die.tag
                else:
                    s = die.tag if self.prefix or not str(die.tag).startswith('DW_TAG_') else die.tag[7:]
                if DIE_has_name(die):
                    s += ": " + DIE_name(die)
                return s
        elif role == Qt.ItemDataRole.ToolTipRole:
            if die.tag == 'DW_TAG_compile_unit' or die.tag == 'DW_TAG_partial_unit':
                return safe_DIE_name(die, None)
        elif role == Qt.ItemDataRole.ForegroundRole and self.is_highlighted(die):
            return blue_brush
        elif role == Qt.ItemDataRole.FontRole and self.is_highlighted(die):
            return bold_font()

    # The rest is not Qt callbacks

    def is_highlighted(self, die):
        if not self.highlight_condition:
            return False
        return next((True for v in self.highlight_condition.values() if v(die)), False)

    def add_highlight(self, key, condition):
        if not self.highlight_condition:
            self.highlight_condition = {key:condition}
        else:
            self.highlight_condition[key] = condition
        self.dataChanged.emit(self.createIndex(0, 0, self.top_dies[0]), self.createIndex(len(self.top_dies)-1, 0, self.top_dies[-1]), (Qt.ItemDataRole.ForegroundRole, Qt.ItemDataRole.FontRole))

    def remove_highlight(self, key):
        del self.highlight_condition[key]
        self.dataChanged.emit(self.createIndex(0, 0, self.top_dies[0]), self.createIndex(len(self.top_dies)-1, 0, self.top_dies[-1]), (Qt.ItemDataRole.ForegroundRole, Qt.ItemDataRole.FontRole))

    def clear_highlight(self):
        self.highlight_condition = None
        if len(self.top_dies):
            self.dataChanged.emit(self.createIndex(0, 0, self.top_dies[0]), self.createIndex(len(self.top_dies)-1, 0, self.top_dies[-1]), (Qt.ItemDataRole.ForegroundRole, Qt.ItemDataRole.FontRole))

    def has_highlight(self, key):
        return bool(self.highlight_condition and key in self.highlight_condition)
    
    def has_any_highlights(self):
        return bool(self.highlight_condition and len(self.highlight_condition))

    def set_prefix(self, prefix):
        if prefix != self.prefix:
            self.prefix = prefix
            self.dataChanged.emit(
                self.createIndex(0, 0, self.top_dies[0]),
                self.createIndex(len(self.top_dies)-1, 0, self.top_dies[-1]))    

    # returns the model index of the selection, or None
    def set_sortcus(self, sortcus, sel):
        if sortcus != self.sortcus:
            sel_die = sel.internalPointer() if sel.isValid() else None
            self.beginResetModel()
            self.sortcus = sortcus
            #Resort the CUs, reload the top_dies
            di = self.top_dies[0].dwarfinfo
            sort_key = cu_sort_key if self.sortcus else lambda cu: cu.cu_offset
            di._CUs.sort(key = sort_key)
            for (i, cu) in enumerate(di._CUs):
                cu._i = i
                self.top_dies[i] = cu.get_top_DIE() # Already decorated, but the index is off
                self.top_dies[i]._i = i
            # Reload
            self.endResetModel()
            if sel_die:
                if sel_die.get_parent(): # Not a top level
                    return sel
                else:
                    return self.createIndex(0, sel_die._i, sel_die)

    # Returns the index of the new selection, if any
    def set_sortdies(self, sortdies):
        if sortdies != self.sortdies:
            self.sortdies = sortdies
            self.beginResetModel()
            for (i, die) in enumerate(self.top_dies):
                # Fragile! We invalidate the children in the decorated DIEs in the CU DIE cache
                # To force reloading and sorting
                for top_die in self.top_dies:
                    for die in top_die.cu._dielist:
                        die._children = None
            self.endResetModel()
            return self.createIndex(0, 0, self.top_dies[0])

    # Identifier for the current tree node that you can navigate to
    # For the back-forward logic
    # Specifically, (cu, offset within the info section)
    def get_navitem(self, index):
        die = index.internalPointer()
        return (die.cu, die.offset) if die else None # Issue # 1473, weird.

    # navitem is (CU, offset within the info section)
    # returns an index within the tree
    def index_for_navitem(self, navitem):
        target_cu, target_offset = navitem
        # Random access is a tricky proposition in the current version. Parse the whole CU.
        for _ in target_cu.iter_DIEs():
            pass

        # Abusing the structure of the per-CU DIE cache of pyelftools, it's the same in DWWARFv1
        i = bisect_left(target_cu._diemap, target_offset)
        if i >= len(target_cu._diemap) or target_cu._diemap[i] != target_offset:
            return None
        target_die = target_cu._dielist[i]
        if target_die.is_null():
            return None
        return self.index_for_die(target_die)

    # Takes a die that might not have an _i
    # Restores the _i
    # Assumes some parent DIEs of the current one are already parsed
    # and cached in the CU, so get_parent will always return a valid parent DIE
    def index_for_die(self, die):
        if hasattr(die, '_i'): # DIE already iterated over
            return self.createIndex(die._i, 0, die)
        else: # Found the DIE, but the tree was never opened this deep. Read the tree along the path to the target DIE
            index = False
            while not hasattr(die, '_i'):
                parent_die = die.get_parent()
                load_children(parent_die, self.sortdies) # This will populate the _i in all children of parent_die, including die
                if not index: # After the first iteration, the one in the direct parent of target_die, target_die will have _i
                    if die.is_null():
                        die = parent_die._children[-1] # Null is a terminator in a sequence - move to the sibling
                        # TODO: move to the closest in terms of offset, which would require going down the nearest sibling's tree
                    index = self.createIndex(die._i, 0, die)
                die = parent_die
            return index

    # Returns the index of the found item, or False
    # start_pos is the index of the current item, or an invalid one
    # cond is a condition function
    # cu_cond is the same for CUs - hook for find by IP
    def find(self, start_pos, cond, cu_cond = False):
        have_start_pos = start_pos.isValid()
        if have_start_pos: # Searching from a specific position, with wrap-around
            start_die = start_pos.internalPointer()
            start_die_offset = start_die.offset # In the current die, before the next one
            start_cu = start_die.cu
            start_cu_offset = start_cu.cu_offset
            cu = start_cu
            wrapped = False
        else:
            cu = self.top_dies[0].cu

        while True:
            cu_offset = cu.cu_offset
            # Parse all DIEs in the current CU
            if cu_cond(cu) if cu_cond else True:
                try: #1516
                    for die in cu.iter_DIEs():
                        # Quit condition with search from position - quit once we go past the starting position after the wrap
                        if have_start_pos and cu_offset >= start_cu_offset and die.offset > start_die_offset and wrapped:
                            break
                        if not die.is_null() and (not have_start_pos or cu_offset != start_cu_offset or (not wrapped and die.offset > start_die_offset)) and cond(die):
                            return self.index_for_die(die)
                except KeyError as exc: #1516
                    from .__main__ import version
                    from .crash import report_crash
                    from inspect import currentframe
                    tb = exc.__traceback__
                    ctxt = dict()
                    try:
                        ctxt['cu_offset'] = cu.cu_offset
                        ctxt['dwarf_config'] = cu.dwarfinfo.config
                        abbrev_codes = set(d.abbrev_code for d in cu._dielist if not d.is_null())
                        at = cu.get_abbrev_table()
                        format_attr_in_abbrev = lambda a: (a.name, a.form, a.value) if a.value is not None else (a.name, a.form)
                        format_abbr = lambda ab: (ab.decl.tag, ab._has_children, tuple(format_attr_in_abbrev(a) for a in ab.decl.attr_spec))
                        ctxt['abbrevs'] = {c: format_abbr(at.get_abbrev(c)) for c in abbrev_codes}
                        stm = cu.dwarfinfo.debug_info_sec.stream
                        crash_pos = ctxt['crash_pos'] = stm.tell()
                        slice = stm.getbuffer()[cu.cu_offset:crash_pos+1]
                        ctxt['cu_in_info'] =  ' '.join("%02x" % b for b in slice)
                    except Exception:
                        pass
                    report_crash(exc, tb, version, currentframe(), ctxt)

                    QApplication.instance().win.show_warning("This executable file is corrupt or incompatible with the current version of DWARF Explorer. Please consider creating a new issue at https://github.com/sevaa/dwex/issues, and share this file with the tech support.")
                    return False

            # We're at the end of the CU. What next?
            if cu._i < len(self.top_dies) - 1: # More CUs to scan
                cu = self.top_dies[cu._i + 1].cu
            elif have_start_pos and not wrapped: # Scanned the last CU, wrap around
                cu = self.top_dies[0].cu
                wrapped = True
            else:
                break

        return False

    # Search back - same idea
    def find_back(self, start_pos, cond, cu_cond = False):
        have_start_pos = start_pos.isValid()
        if have_start_pos: # Searching from a specific position, with wrap-around
            start_die = start_pos.internalPointer()
            start_die_offset = start_die.offset # In the current die, before the next one
            start_cu = start_die.cu
            start_cu_offset = start_cu.cu_offset
            cu = start_cu
            wrapped = False
        else:
            cu = self.top_dies[-1].cu

        while True:
            cu_offset = cu.cu_offset
            # Parse all DIEs in the current CU
            if cu_cond(cu) if cu_cond else True:
                for die in cu.iter_DIEs(): # Fill the DIE cache
                    pass

                # Abusing the internal cache of pyelftools - fragile!

                if have_start_pos and not wrapped and cu_offset == start_cu_offset:
                    i = bisect_left(cu._diemap, start_die_offset-1)-1
                else:
                    i = len(cu._diemap) - 1

                while i >= 0:
                    die = cu._dielist[i]
                    if not die.is_null():
                        # Quit condition with search from position - quit once we go past the starting position after the wrap
                        if have_start_pos and die.offset == start_die_offset and wrapped:
                            return False
                        if cond(die):
                            return self.index_for_die(die)
                    i -= 1

            # We're at the end of the CU. What next?
            if cu._i > 0: # More CUs to scan
                cu = self.top_dies[cu._i - 1].cu
            elif have_start_pos and not wrapped: # Scanned the last CU, wrap around
                cu = self.top_dies[-1].cu
                wrapped = True
            else:
                break

        return False            

    
    def find_offset(self, offset):
        cu = next((td.cu
            for td
            in self.top_dies
            if 0 <= offset-td.cu.cu_die_offset < td.cu.header.unit_length), False)
        if not cu:
            return None
        # On an off chance it's already parsed and the offset is precise
        i = bisect_right(cu._diemap, offset)
        if offset == cu._diemap[i - 1]:
            return self.index_for_die(cu._dielist[i - 1])
        # Now the hard way
        # It would be possible to optimize that, parse not all DIEs but just some
        # But let's not.
        for die in cu.iter_DIEs():
            pass
        i = bisect_right(cu._diemap, offset)
        return self.index_for_die(cu._dielist[i - 1])


```

`dwex/treedlg.py`:

```py
from PyQt6.QtCore import Qt, QAbstractItemModel, QModelIndex
from PyQt6.QtWidgets import *

class TreeModel(QAbstractItemModel):
    """ tree_data is a collection of nodes. A node is either a string or
        a tuple of (string, collection of nodes). Only two levels so far.
        Item's internal object is a tuple of indices
    """
    def __init__(self, tree_data):
        super().__init__()
        self.tree_data = tree_data
        # Since internalPointer doesn't retain the object, need to pregenerate objects that will be used as internal pointers
        # Presuming no more than two levels.
        self.l1indices = tuple((i,) for i in range(len(tree_data)))
        self.l2indices = {(i,): tuple((i, j) for j in range(len(o[1]))) if not isinstance(o, str) else None for (i, o) in enumerate(tree_data)}

    def item_at_index(self, index):
        # Only supports two level nesting. If multilevel trees come up, TODO
        mi = index.internalPointer()
        return self.tree_data[mi[0]] if len(mi) == 1 else self.tree_data[mi[0]][1][mi[1]]

    def index(self, row, col, parent):
        if parent.isValid(): # Second level item
            o = self.l2indices[parent.internalPointer()][row]
        else:
            o = self.l1indices[row]
        return self.createIndex(row, col, o)

    def flags(self, index):
        f = Qt.ItemFlag.ItemIsEnabled
        if index.isValid() and isinstance(self.item_at_index(index), str):
            f |= Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemNeverHasChildren
        return f

    def hasChildren(self, index):
        return not index.isValid() or not isinstance(self.item_at_index(index), str)

    def rowCount(self, parent):
        if parent.isValid():
            o = self.item_at_index(parent)
            return 0 if isinstance(o, str) else len(o[1])
        else:
            return len(self.tree_data)

    def columnCount(self, parent):
        return 1
    
    def parent(self, index):
        if index.isValid():
            mi = index.internalPointer()
            if len(mi) > 1: # Second level item
                return self.createIndex(mi[-2], 0, self.l1indices[mi[-2]])
        return QModelIndex()

    def data(self, index, role):
        if role == Qt.ItemDataRole.DisplayRole:
            o = self.item_at_index(index)
            return o if isinstance(o, str) else o[0]

class TreeDlg(QDialog):
    def __init__(self, win, title, data):
        QDialog.__init__(self, win, Qt.WindowType.Dialog)
        self.selection = None # A tuple of indices once selected

        self.resize(300, 450)
        ly = QVBoxLayout()

        tree = self.the_tree = QTreeView()
        tree.header().hide()
        tree.setUniformRowHeights(True)
        tree.setModel(TreeModel(data))
        tree.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)
        tree.selectionModel().selectionChanged.connect(self.on_sel_change)
        tree.doubleClicked.connect(lambda _: self.accept())
        ly.addWidget(tree)

        buttons = self.buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok|QDialogButtonBox.StandardButton.Cancel, Qt.Orientation.Horizontal, self)
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        buttons.button(QDialogButtonBox.StandardButton.Ok).setEnabled(False)
        ly.addWidget(buttons)
        self.setWindowTitle(title)
        self.setLayout(ly)

    def on_sel_change(self, sel, prev):
        self.buttons.button(QDialogButtonBox.StandardButton.Ok).setEnabled(len(sel.indexes()) > 0)

    def accept(self):
        sel = self.the_tree.selectedIndexes()
        if len(sel) > 0:
            self.selection = sel[0].internalPointer()
            self.done(QDialog.DialogCode.Accepted)
```

`dwex/ui.py`:

```py
import os
from PyQt6.QtCore import Qt, QRectF, QSizeF, QPointF, QByteArray
from PyQt6.QtGui import QKeySequence, QAction, QImage, QPixmap, QPainter, QIcon, QFont
from PyQt6.QtWidgets import *
from PyQt6.QtSvg import QSvgRenderer

def setup_menu(win):
    menu = win.menuBar()
    file_menu = menu.addMenu("&File")
    open_menuitem = file_menu.addAction("Open...")
    open_menuitem.setShortcut(QKeySequence.StandardKey.Open)
    open_menuitem.triggered.connect(win.on_open)
    win.switchslice_menuitem = file_menu.addAction("Switch file slice...")
    win.switchslice_menuitem.triggered.connect(win.on_switchslice)
    win.switchslice_menuitem.setEnabled(False)
    win.savesection_menuitem = file_menu.addAction("Save a section as...")
    win.savesection_menuitem.triggered.connect(win.on_savesection)
    win.savesection_menuitem.setEnabled(False)
    win.loadexec_menuitem = file_menu.addAction("Load companion executable...")
    win.loadexec_menuitem.triggered.connect(win.on_loadexec)
    win.loadexec_menuitem.setEnabled(False)
    win.mru_menu = file_menu.addMenu("Recent files")
    if len(win.mru):
        win.populate_mru_menu()
    else:
        win.mru_menu.setEnabled(False)
    exit_menuitem = file_menu.addAction("E&xit")
    exit_menuitem.setMenuRole(QAction.MenuRole.QuitRole)
    exit_menuitem.setShortcut(QKeySequence.StandardKey.Quit)
    exit_menuitem.triggered.connect(win.on_exit)
    if os.environ.get("DWEX_DEBUG") is not None:
        file_menu.addAction("Debug").triggered.connect(win.on_debug)
    #########
    view_menu = menu.addMenu("View")
    win.prefix_menuitem = view_menu.addAction("DWARF prefix")
    win.prefix_menuitem.setCheckable(True)
    win.prefix_menuitem.setChecked(win.prefix)
    win.prefix_menuitem.triggered.connect(win.on_view_prefix)
    win.lowlevel_menuitem = view_menu.addAction("Low level")
    win.lowlevel_menuitem.setCheckable(True)
    win.lowlevel_menuitem.setChecked(win.lowlevel)
    win.lowlevel_menuitem.triggered.connect(win.on_view_lowlevel)
    win.hex_menuitem = view_menu.addAction("Hexadecimal")
    win.hex_menuitem.setCheckable(True)
    win.hex_menuitem.setChecked(win.hex)
    win.hex_menuitem.triggered.connect(win.on_view_hex)
    win.regnames_menuitem = view_menu.addAction("DWARF register names")
    win.regnames_menuitem.setCheckable(True)
    win.regnames_menuitem.setChecked(win.dwarfregnames)
    win.regnames_menuitem.triggered.connect(win.on_view_regnames)
    view_menu.addSeparator()
    win.sortcus_menuitem = view_menu.addAction("Sort CUs")
    win.sortcus_menuitem.setCheckable(True)
    win.sortcus_menuitem.setChecked(win.sortcus)
    win.sortcus_menuitem.triggered.connect(win.on_sortcus)
    win.sortdies_menuitem = view_menu.addAction("Sort DIEs")
    win.sortdies_menuitem.setCheckable(True)
    win.sortdies_menuitem.setChecked(win.sortdies)
    win.sortdies_menuitem.triggered.connect(win.on_sortdies)
    view_menu.addSeparator()
    win.highlightcode_menuitem = view_menu.addAction("Highlight code")
    win.highlightcode_menuitem.setCheckable(True)
    win.highlightcode_menuitem.setEnabled(False)
    win.highlightcode_menuitem.triggered.connect(win.on_highlight_code)
    win.highlightsubstring_menuitem = view_menu.addAction("Highlight by substring...")
    win.highlightsubstring_menuitem.setCheckable(True)
    win.highlightsubstring_menuitem.setEnabled(False)
    win.highlightsubstring_menuitem.triggered.connect(win.on_highlight_substring)
    win.highlightcondition_menuitem = view_menu.addAction("Highlight by condition...")
    win.highlightcondition_menuitem.setCheckable(True)
    win.highlightcondition_menuitem.setEnabled(False)
    win.highlightcondition_menuitem.triggered.connect(win.on_highlight_condition)
    win.highlightnothing_menuitem = view_menu.addAction("Remove highlighting")
    win.highlightnothing_menuitem.setEnabled(False)
    win.highlightnothing_menuitem.triggered.connect(win.on_highlight_nothing)
    view_menu.addSeparator()
    win.cuproperties_menuitem = view_menu.addAction("CU properties...")
    win.cuproperties_menuitem.setEnabled(False)
    win.cuproperties_menuitem.triggered.connect(win.on_cuproperties)
    view_menu.addSeparator()
    theme_menuitem = view_menu.addAction("Theme...")
    theme_menuitem.triggered.connect(win.on_changetheme)
    #########
    edit_menu = menu.addMenu("Edit")
    win.copy_menuitem = edit_menu.addAction("Copy value")
    win.copy_menuitem.setShortcut(QKeySequence.StandardKey.Copy)
    win.copy_menuitem.setEnabled(False)
    win.copy_menuitem.triggered.connect(win.on_copyvalue)
    win.copyline_menuitem = edit_menu.addAction("Copy line")
    win.copyline_menuitem.setEnabled(False)
    win.copyline_menuitem.triggered.connect(win.on_copyline)        
    win.copytable_menuitem = edit_menu.addAction("Copy table")
    win.copytable_menuitem.setEnabled(False)
    win.copytable_menuitem.triggered.connect(win.on_copytable)  
    #########
    nav_menu = menu.addMenu("Navigate")
    win.back_menuitem = nav_menu.addAction("Back")
    win.back_menuitem.setShortcut(QKeySequence.StandardKey.Back)
    win.back_menuitem.setEnabled(False);
    win.back_menuitem.triggered.connect(lambda: win.on_nav(1))
    win.forward_menuitem = nav_menu.addAction("Forward")
    win.forward_menuitem.setShortcut(QKeySequence.StandardKey.Forward)
    win.forward_menuitem.setEnabled(False);
    win.forward_menuitem.triggered.connect(lambda: win.on_nav(-1))
    win.followref_menuitem = nav_menu.addAction("Follow the ref")
    win.followref_menuitem.setEnabled(False);
    win.followref_menuitem.setShortcut(QKeySequence(Qt.Modifier.CTRL | Qt.Key.Key_Return))
    win.followref_menuitem.triggered.connect(win.on_followref)
    nav_menu.addSeparator()
    win.nexthl_menuitem = nav_menu.addAction("To next highlight")
    win.nexthl_menuitem.setEnabled(False)
    win.nexthl_menuitem.triggered.connect(win.on_nexthl)
    win.prevhl_menuitem = nav_menu.addAction("To previous highlight")
    win.prevhl_menuitem.setEnabled(False)
    win.prevhl_menuitem.triggered.connect(win.on_prevhl)
    nav_menu.addSeparator()
    win.byoffset_menuitem = nav_menu.addAction("DIE by offset...")
    win.byoffset_menuitem.setEnabled(False)
    win.byoffset_menuitem.triggered.connect(win.on_byoffset)
    win.find_menuitem = nav_menu.addAction("Find...")
    win.find_menuitem.setEnabled(False)
    win.find_menuitem.setShortcut(QKeySequence.StandardKey.Find)
    win.find_menuitem.triggered.connect(win.on_find)
    win.findip_menuitem = nav_menu.addAction("Find code address...")
    win.findip_menuitem.setEnabled(False)
    win.findip_menuitem.triggered.connect(win.on_findip)
    win.findbycondition_menuitem = nav_menu.addAction("Find by condition...")
    win.findbycondition_menuitem.setEnabled(False)
    win.findbycondition_menuitem.triggered.connect(win.on_findbycondition)
    win.findnext_menuitem = nav_menu.addAction("Find next")
    win.findnext_menuitem.setEnabled(False)
    win.findnext_menuitem.setShortcut(QKeySequence.StandardKey.FindNext)
    win.findnext_menuitem.triggered.connect(win.on_findnext)
    ########
    ana_menu = menu.addMenu("Analysis")
    win.localsat_menuitem = ana_menu.addAction("Locals at address...")
    win.localsat_menuitem.setEnabled(False)
    win.localsat_menuitem.triggered.connect(win.on_localsat)
    win.funcmap_menuitem = ana_menu.addAction("Function map...")
    win.funcmap_menuitem.setEnabled(False)
    win.funcmap_menuitem.triggered.connect(win.on_funcmap)
    ana_menu.addSeparator()
    win.aranges_menuitem = ana_menu.addAction("Aranges...")
    win.aranges_menuitem.setEnabled(False)
    win.aranges_menuitem.triggered.connect(win.on_aranges)
    win.frames_menuitem = ana_menu.addAction("Frames...")
    win.frames_menuitem.setEnabled(False)
    win.frames_menuitem.triggered.connect(win.on_frames)
    win.unwind_menuitem = ana_menu.addAction("Unwind info...")
    win.unwind_menuitem.setEnabled(False)
    win.unwind_menuitem.triggered.connect(win.on_unwind)
    ########
    help_menu = menu.addMenu("Help")
    about_menuitem = help_menu.addAction("About...")
    about_menuitem.setMenuRole(QAction.MenuRole.AboutRole)
    about_menuitem.triggered.connect(win.on_about) 
    help_menu.addAction('Check for updates...').triggered.connect(win.on_updatecheck)
    help_menu.addAction('Report an issue').triggered.connect(win.on_issue)
    help_menu.addAction('Homepage').triggered.connect(win.on_homepage)

back_svg = b'<path fill="none" stroke="#000" stroke-width="5" stroke-linejoin="round" stroke-linecap="round" d="M 40 20 L 10 50 L 40 80 M 10 50 h 60"/>'
fwd_svg = b'<path fill="none" stroke="#000" stroke-width="5" stroke-linejoin="round" stroke-linecap="round" d="M 60 20 L 90 50 L 60 80 M 90 50 h -60"/>'
open_svg = b'<path fill="none" stroke="#000" stroke-width="5" d="M 10 20 v 60 h 80 v -45 h -35 l -15 -15 z"/>'
fwref_svg = b'<path fill="none" stroke="#000" stroke-width="5" stroke-linejoin="round" stroke-linecap="round" d="M20 5v90h40M20 65h40M20 35h15"/><path fill="none" stroke="#000" stroke-width="5" stroke-linecap="round" d="M70 95q30-30-20-60"/><path fill="none" stroke="#000" stroke-width="5" stroke-linejoin="butt" stroke-linecap="round" d="M54 54l-5-20 20-2"/>'
copy_svg = b'<path fill="none" stroke="#000" stroke-width="5" stroke-linejoin="round" d="M15 25h45v60H15zm20 0V15h45v60H60"/>'
byoffset_svg = b'<path fill="none" stroke="#000" stroke-width="5" stroke-linejoin="round" d="M40 5v75h40M40 25h20M40 50h30M10 5v35H5l10 10 10-10h-5V5z"/>'
find_svg = b'<path stroke="#000" fill="#000" fill-rule="evenodd" d="M40 60a25 25 0 1112-8l16 25-12 7zM15 36a15 15 0 1135 0 15 15 0 11-35 0"/>'
nexthl_svg = b'<g stroke="#000" fill="none" stroke-width="5" stroke-linecap="round"><path stroke-linejoin="round" d="M5 20h75L65 5m15 15L65 35"/><path d="M5 60h17M13.787 38.787l12.02 12.02M35 30v17M56.213 38.787l-12.02 12.02M65 60H48M56.213 81.213l-12.02-12.02M35 90V73M13.787 81.213l12.02-12.02"/></g>'
prevhl_svg = b'<g stroke="#000" fill="none" stroke-width="5" stroke-linecap="round"><path stroke-linejoin="round" d="M95 20H20L35 5M20 20l15 15"/><path d="M78 60h17M74.192 69.192l12.021 12.021M65 73v17M55.808 69.192L43.787 81.213M52 60H35M55.808 50.808L43.787 38.787M65 47V30M74.192 50.808l12.021-12.021"/></g>'

def setup_toolbar(win):
    tb = win.addToolBar("Main")
   
    sz = tb.iconSize()
    rc = QRectF(QPointF(0, 0), QSizeF(sz.width(), sz.height()))

    def make_icon(svg_body):
        img = QImage(sz, QImage.Format.Format_ARGB32)
        img.fill(0)
        svg = b'<svg width="100" height="100">' + svg_body + b'</svg>'
        renderer = QSvgRenderer(QByteArray(svg))
        pixmap = QPixmap.fromImage(img, Qt.ImageConversionFlag.NoFormatConversion)
        with QPainter(pixmap) as painter:
            renderer.render(painter, rc)
        return QIcon(pixmap)
    
    tb.setFloatable(False)
    tb.setMovable(False)

    win.back_tbitem = tb.addAction("Back")
    win.back_tbitem.triggered.connect(lambda: win.on_nav(1))
    win.back_tbitem.setEnabled(False)
    win.back_tbitem.setIcon(make_icon(back_svg))
    win.back_tbitem.setToolTip("Navigate to the previous DIE")
    win.forward_tbitem = tb.addAction("Forward")
    win.forward_tbitem.triggered.connect(lambda: win.on_nav(-1))
    win.forward_tbitem.setEnabled(False)
    win.forward_tbitem.setIcon(make_icon(fwd_svg))
    win.forward_tbitem.setToolTip("Navigate to the DIE that you went back from")
    tb.addSeparator()

    ac = tb.addAction("Open")
    ac.triggered.connect(win.on_open)
    ac.setIcon(make_icon(open_svg))
    ac.setToolTip("Open a compiled executable, object, or library file to see its debug information")
    tb.addSeparator()

    win.copy_tbitem = tb.addAction("Copy")
    win.copy_tbitem.setIcon(make_icon(copy_svg))
    win.copy_tbitem.setEnabled(False)
    win.copy_tbitem.setToolTip("Copy the current attribute's value to the clipboard")
    win.copy_tbitem.triggered.connect(win.on_copyvalue)
    tb.addSeparator()
    win.followref_tbitem = tb.addAction("Follow")
    win.followref_tbitem.setEnabled(False)
    win.followref_tbitem.setIcon(make_icon(fwref_svg))
    win.followref_tbitem.triggered.connect(win.on_followref)
    win.followref_tbitem.setToolTip("Navigate to the DIE that the current attribute is referencing")
    win.byoffset_tbitem = tb.addAction("By offset")
    win.byoffset_tbitem.setEnabled(False)
    win.byoffset_tbitem.setIcon(make_icon(byoffset_svg))
    win.byoffset_tbitem.triggered.connect(win.on_byoffset)
    win.byoffset_tbitem.setToolTip("Navigate to the DIE by the hex offset of the DIE in the info section")
    win.find_tbitem = tb.addAction("Find")
    win.find_tbitem.setEnabled(False)
    win.find_tbitem.setIcon(make_icon(find_svg))
    win.find_tbitem.triggered.connect(win.on_find)
    win.find_tbitem.setToolTip("Find the next DIE in the tree by tag/attribute/value substring")
    win.nexthl_tbitem = tb.addAction("Next highlight")
    win.nexthl_tbitem.setEnabled(False)
    win.nexthl_tbitem.setIcon(make_icon(nexthl_svg))
    win.nexthl_tbitem.triggered.connect(win.on_nexthl)
    win.nexthl_tbitem.setToolTip("Navigate to the next highlighted DIE in the tree")
    win.prevhl_tbitem = tb.addAction("Previous highlight")
    win.prevhl_tbitem.setEnabled(False)
    win.prevhl_tbitem.setIcon(make_icon(prevhl_svg))
    win.prevhl_tbitem.triggered.connect(win.on_prevhl)
    win.prevhl_tbitem.setToolTip("Navigate to the previous highlighted DIE in the tree")

def setup_explorer(win):
    # Set up the left pane and the right pane
    tree = win.the_tree = QTreeView()
    tree.header().hide()
    tree.setUniformRowHeights(True)
    
    rpane = QSplitter(Qt.Orientation.Vertical)
    die_table = win.die_table = QTableView()
    die_table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
    die_table.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)
    die_table.doubleClicked.connect(win.on_attribute_dclick)
    rpane.addWidget(die_table)
    
    rbpane = QVBoxLayout()
    rbpane.setContentsMargins(0, 0, 0, 0)
    details_warning = win.details_warning = QLabel()
    details_warning.setVisible(False)
    rbpane.addWidget(details_warning)
    details_table = win.details_table = QTableView()
    details_table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
    details_table.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)
    details_table.doubleClicked.connect(win.on_details_dclick)
    rbpane.addWidget(details_table)
    rbp = QWidget()
    rbp.setLayout(rbpane)
    rpane.addWidget(rbp)
    # All the resizing goes into the bottom pane
    rpane.setStretchFactor(0, 0)
    rpane.setStretchFactor(1, 1)

    spl = QSplitter()
    spl.addWidget(win.the_tree)
    spl.addWidget(rpane)
    # All the resizing goes into the right pane by default
    spl.setStretchFactor(0, 0)
    spl.setStretchFactor(1, 1) 
    win.setCentralWidget(spl)

def setup_splash(win):
    l = QLabel()
    l.setText("Drag\na file\nhere")
    l.setAlignment(Qt.AlignmentFlag.AlignCenter)
    f = QFont("Verdana", 50)
    f.setStyleHint(QFont.StyleHint.SansSerif)
    l.setFont(f)
    l.setEnabled(False)
    win.setCentralWidget(l)

def setup_ui(win):
    setup_menu(win)
    setup_toolbar(win)
    setup_splash(win)

    win.setWindowTitle("DWARF Explorer")
    win.resize(win.font_metrics.averageCharWidth() * 250, win.font_metrics.height() * 60)

```

`dwex/unwind.py`:

```py
from dwex.details import GenericTableModel
from PyQt6.QtWidgets import QHeaderView
from .frames import FramesUIDlg
from .machounwind import MachoUnwindInfo, UnwindCommandARM64, UnwindCommandIntel, NopEntry, FallbackEntry
from .exprutil import _REG_NAME_MAP, format_offset

def format_arg(e):
    if e.arg is None:
        return ''
    elif e.command == UnwindCommandARM64.Frame:
        return ''.join(str(int(b)) for b in e.arg)
    else:
        return str(e.arg)

class UnwindDlg(FramesUIDlg):
    def __init__(self, win, unwind_section, di, regnames, hex_):
        FramesUIDlg.__init__(self, win)
        if hasattr(di, '_unwind_info'):
            uw = di._unwind_info
        else:
            uw = di._unwind_info = MachoUnwindInfo(unwind_section, di._arch_code[0])

        self.dwarfinfo = di
        self.regnames = _REG_NAME_MAP.get(di.config.machine_arch, None) if not regnames else None

        lines = [(hex(di._start_address + e.address), hex(e.encoding), e.command.name, format_arg(e), e)
            for p in uw.pages if p.entries for e in p.entries]
        self.entries.setModel(GenericTableModel(('Address', 'Encoding', 'Command', 'Argument(s)'), lines))
        self.entries.horizontalHeader().setSectionResizeMode(3, QHeaderView.ResizeMode.ResizeToContents)
        self.entries.selectionModel().currentChanged.connect(self.on_entry_sel)

    def on_entry_sel(self, index, prev = None):
        try:
            entry = self.entries.model().values[index.row()][-1]
            de = self.dwarfinfo._unwind_info.decode_entry(entry)
            if isinstance(de, NopEntry):
                headers = ('',)
                values = (('Unknown frame structure',),)
            elif isinstance(de, FallbackEntry):
                headers = ('',)
                values = (('See under Frames',),)
            else:
                # The assumption is that if LR is not saved, it's preserved.
                # Losing LR altogether can only happen in a noreturn function, which is unlikely.
                headers = ('CFA',) + tuple(self.regname(rno) for rno in de.saved_registers.keys())
                value = (self.regname(de.cfa_base_register) + format_offset(de.cfa_offset),)
                value += tuple(f"[CFA{format_offset(-off)}]" for off in de.saved_registers.values())
                values = (value,)
        except NotImplementedError:
            headers = ('',)
            values = (('Not supported yet.',),)
        self.details.setModel(GenericTableModel(headers, values))

    def regname(self, regno):
        return self.regnames[regno] if self.regnames else f"r{regno}"

    
```

`make.cmd`:

```cmd
@echo off
git diff-index --quiet HEAD --
if errorlevel 1 echo Uncommitted changes! & pause & goto EOF

git log --pretty=format:%%H -n 1 >hash.txt
set /p HASH= <hash.txt
del hash.txt

python -c "import dwex.__main__;print('.'.join(str(x) for x in dwex.__main__.version))" >ver.txt
set /p VER= <ver.txt
del ver.txt

echo %HASH% %VER% >>archive\history.txt

del /q dist\*.*
echo cookie='%HASH%' >dwex\cookie.py
python setup.py sdist
echo cookie=False >dwex\cookie.py
twine upload dist/*
if errorlevel 1 pause 
```

`msi/make.cmd`:

```cmd
@echo off

rem MSITOOLS is expected to be C:\Program Files (x86)\Windows Kits\10\bin\10.0.22000.0\x86
rem Thumbprint.txt is supposed to exist and contain the thumbprint of the signing cert
rem TODO: sign aside from the master copy of the file

cd ..
python -c "import dwex.__main__;print('.'.join(str(x) for x in dwex.__main__.version))" >ver.txt
set /p VER= <ver.txt
del ver.txt
echo Version %VER%
cd msi
powershell MSISetProp.ps1 -Path %CD%\DWEXMin.msi -Property ProductVersion -Value %VER%

set /p THU= <Thumbprint.txt
echo Signing cert %THU%
if x%THU% == x echo No signing cert thumbprint & pause & goto EOF
"%MSITOOLS%\signtool.exe" sign /fd SHA256 /sha1 %THU%  DWEXMin.msi

set D=ftp://ftp.yarxi.ru/public_html/yarxionline/temp/dwex/%VER%
powershell MakeFTPFolder -URL %D%

set D=%D%/
powershell UpFile -Src DWEXMin.msi -Dest %D%

:EOF

```

`refresh.cmd`:

```cmd
pip install --upgrade dwex
```

`setup.cfg`:

```cfg
[metadata]
description_file = README.md

```

`setup.py`:

```py
from setuptools import setup
from setuptools.command.install import install
import platform, sys, os, site
from os import path, environ, makedirs

#------------------------------------
# Start menu item creation on Windows
#------------------------------------

def create_shortcut_under(root, exepath):
    profile = environ[root]
    linkpath = path.join(profile, "Microsoft", "Windows", "Start Menu", "Programs", "DWARF Explorer.lnk")
    try:
        from win32com.client import Dispatch
        from pywintypes import com_error
        try:
            sh = Dispatch('WScript.Shell')
            link = sh.CreateShortcut(linkpath)
            link.TargetPath = exepath
            link.Save()
            return True
        except com_error:
            return False
    except ImportError:
        import subprocess
        s = "$s=(New-Object -COM WScript.Shell).CreateShortcut('" + linkpath + "');$s.TargetPath='" + exepath + "';$s.Save()"
        return subprocess.call(['powershell', s], stdout = subprocess.DEVNULL, stderr = subprocess.DEVNULL) == 0

def create_shortcut(inst):
    try:
        exepath = path.join(path.dirname(sys.executable), "Scripts", "dwex.exe")
        if not path.exists(exepath):
            exepath = path.join(path.dirname(site.getusersitepackages()), "Scripts", "dwex.exe")

        if not create_shortcut_under('ALLUSERSPROFILE', exepath):
            create_shortcut_under('APPDATA', exepath)
    except:
        pass

#--------------------------------------    

def register_desktop_app():
    try:
        import base64, subprocess
        with open('/usr/share/applications/dwex.desktop', 'w') as f:
            f.write("[Desktop Entry]\nVersion=1.1\nType=Application\nName=DWARF Explorer\nComment=Debug information visualizer\nExec=dwex\nTerminal=false\nIcon=dwex\nCategories=Development;Debugger;\n")
        with open('/usr/share/icons/hicolor/48x48/apps/dwex.png', 'wb') as f:
            f.write(base64.b64decode("iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClLOS0AAAAKnRFWHRDcmVhdGlvbiBUaW1lANHhIDYg7e7/IDIwMjEgMTM6MDg6NDcgLTA1MDBuo0qzAAAAB3RJTUUH5QsGEQ8VL0d/PwAAAAlwSFlzAAALEgAACxIB0t1+/AAAAARnQU1BAACxjwv8YQUAAAAGUExURf///wAAAFXC034AAACkSURBVHjavdNREoUgCAXQyw5g/5sNxEoEpvc+yim0OcUoJvBRE2sAaeQRAkgB0NdBbJcPfgMNbglI8w9AAu1tDjXQv8DEUgH1gAwaDKQEu3kDWzBVIBNCReaG+Fc7oIAvGt1/g61cnsGnaM9nn0B89Rloq9UF4JDJd9VHsSILSIR7jiHTAm0qbiHNau7StlEXlCU5T0ALS65Zdh5lp+VwtvByOwCIiA5ALXz03AAAAABJRU5ErkJggg=="))
        subprocess.call('update-desktop-database')
    except:
        pass

#--------------------------------------
# App bundle on MacOS X
#--------------------------------------
def save_as_plist(d, f):
    f.write('<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"><plist version="1.0"><dict>')
    for (key, value) in d.items():
        f.write(f'<key>{key}</key>')
        if isinstance(value, str):
            f.write(f'<string>{value}</string>')
        elif isinstance(value, (tuple, list)):
            values = ''.join(f'<string>{e}</string>' for e in value)
            f.write(f'<array>{values}</array>')
    f.write('</dict></plist>')

def create_app_bundle_under(app_ver, apps):
    p = path.join(apps, 'DWARF Explorer.app')
    makedirs(p, exist_ok=True)
    p = path.join(p, 'Contents')
    makedirs(p, exist_ok=True)
    with open(path.join(p, 'Info.plist'), 'wt') as f:
        save_as_plist({
            'CFBundleDevelopmentRegion': 'English',
            'CFBundleDisplayName': 'DWARF Explorer',
            'CFBundleExecutable': 'dwex',
            'CFBundleIdentifier': 'com.dwex.dwex',
            'CFBundleInfoDictionaryVersion': '6.0',
            'CFBundleName': 'DWARF Explorer',
            'CFBundlePackageType': 'APPL',
            'CFBundleShortVersionString': app_ver,
            'CFBundleSupportedPlatforms': ('MacOSX',),
            'CFBundleVersion': app_ver,
            'LSApplicationCategoryType': 'public.app-category.utilities',
            'LSArchitecturePriority': ('arm64', 'x86_64', 'i386')}, f)
    p = path.join(p, 'MacOS')
    makedirs(p, exist_ok=True)
    p = path.join(p, 'dwex')
    with open(p, 'wt') as f:
        f.write(f'#!{sys.executable}\nfrom dwex.__main__ import main\nmain()')
    os.chmod(p, 0o755)

def create_app_bundle(inst):
    try:
        try:
            app_ver = inst.config_vars['dist_version']
            create_app_bundle_under(app_ver, '/Applications')
        except OSError:
            makedirs('~/Applications', exist_ok=True)
            create_app_bundle_under(app_ver, '~/Applications')
    except Exception as exc:
        pass

#--------------------------------------

class my_install(install):
    def run(self):
        install.run(self)
        os_name = platform.system()
        if os_name == 'Windows':
            create_shortcut(self)
        elif os_name == 'Linux':
            register_desktop_app()
        elif os_name == 'Darwin':
            create_app_bundle(self)

# Pull the long desc from the readme
try:
    with open(path.join(path.abspath(path.dirname(__file__)), 'README.md')) as f:
        long_desc = f.read()          
except:
    long_desc = "GUI viewer for DWARF debug information"

setup(
    name='dwex',
    version='4.60',  # Sync with version in __main__
    packages=['dwex'],
    url="https://github.com/sevaa/dwex/",
    entry_points={"gui_scripts": ["dwex = dwex.__main__:main"]},
    cmdclass={'install': my_install},
    keywords = ['dwarf', 'debug', 'debugging', 'symbols', 'viewer', 'view', 'browser', 'browse', 'tree'],
    license="BSD-3-Clause",
    author="Seva Alekseyev",
    author_email="sevaa@sprynet.com",
    description="GUI viewer for DWARF debug information",
    long_description=long_desc,
    long_description_content_type="text/markdown",
    python_requires=">=3.6.1",
    setup_requires=[],
    install_requires=['PyQt6', 'pyelftools>=0.32'] + (['pyobjc'] if platform.system() == 'Darwin' else []), #'filebytes>=0.10.1'
    platforms='any',
    classifiers=[
        "Development Status :: 5 - Production/Stable",
        "Intended Audience :: Developers",
        "Operating System :: OS Independent",
        "Environment :: MacOS X :: Cocoa",
        "Environment :: Win32 (MS Windows)",
        "Environment :: X11 Applications :: Qt",
        "Programming Language :: Python",
        "Programming Language :: Python :: 3.6",
        "Programming Language :: Python :: 3.7",
        "Programming Language :: Python :: 3.8",
        "Programming Language :: Python :: 3.9",
        "Programming Language :: Python :: 3.10",
        "Programming Language :: Python :: 3.11",
        "Programming Language :: Python :: 3.12",
        "Programming Language :: Python :: 3.13",
        "Programming Language :: Python :: Implementation :: CPython",
        "Topic :: Software Development :: Debuggers"
    ]
)


```

`test/intest.py`:

```py
import sys, os
sys.path.insert(1, os.getcwd()) # To make sure dwex resolves to local path
import dwex.__main__

def main(debug_crash_reporting, filename, hook_file):
    # Do we need to hook exceptions all the same
    if debug_crash_reporting:
        dwex.__main__.on_exception.prev_exchook = sys.excepthook
        sys.excepthook = dwex.__main__.on_exception

    if len(sys.argv) == 1:
        sys.argv = ['dwex', filename]

    # Monkeypatch to mess with file contents
    old_open_file = dwex.__main__.TheWindow.open_file
    def open_file(self, filename, arch = None):
        r = old_open_file(self, filename, arch)
        hook_file(self.dwarfinfo)
        return r
    
    dwex.__main__.TheWindow.open_file = open_file
    dwex.__main__.main()
```

`test/testall.py`:

```py
import os, sys
from PyQt6.QtCore import Qt, QAbstractItemModel, QAbstractTableModel, QModelIndex
sys.path.insert(1, os.getcwd()) # To make sure dwex resolves to local path
from elftools.dwarf.locationlists import LocationParser, LocationExpr
from dwex.formats import read_dwarf
from dwex.die import DIETableModel
from dwex.dwarfutil import strip_path

def test_dwarfinfo(di):
    # Some global cache setup in line with the app proper
    di._ranges = None
    di._CUs = [cu for cu in di.iter_CUs()]
    di._locparser = None

    m = False
    dummy_index = QModelIndex()
    for (i, CU) in enumerate(di._CUs):
        top_die = CU.get_top_DIE()
        print("%s" % strip_path(top_die.attributes['DW_AT_name'].value.decode('utf-8', errors='ignore')) if 'DW_AT_name' in top_die.attributes else "(no name)")
        CU._lineprogram = None
        CU._exprparser = None
        for die in CU.iter_DIEs():
            if not die.is_null():
                assert die.tag.startswith('DW_TAG_')

                if not m:
                    # With prefix, with low level data, decimal
                    m = DIETableModel(die, True, True, False, True) 
                else:
                    m.display_DIE(die)

                rc = m.rowCount(dummy_index)
                cc = m.columnCount(dummy_index)
                keys = list(die.attributes.keys())
                # Assuming rows correspond to attributes; 
                # if we introduce non-attribute metadata into the DIE table, this will break
                for r in range(m.meta_count, rc):
                    key = keys[r - m.meta_count]
                    attr = die.attributes[key]
                    form = attr.form
                    value = attr.value
                    # Check the elftools' results first

                    # Check if the key is interpreted properly
                    assert str(key).startswith('DW_AT_')
                    assert str(form).startswith('DW_FORM_')

                    # Check if attributes with locations are all found
                    if form == 'DW_FORM_exprloc':
                        assert LocationParser.attribute_has_location(attr, CU['version'])
                    # The converse is not true; on DWARF2, location expressions can have form DW_FORM_block1

                    # Now check the spell out logic
                    for c in range(0, cc):
                        m.data(m.index(r, c, dummy_index), Qt.ItemDataRole.DisplayRole)
                    # Low level details, if any
                    details = m.get_attribute_details(m.index(r, 0, dummy_index))
                    if form == 'DW_FORM_section_offset':
                        assert details is not None
                    # Check the high level spell out logic too
                    m.set_lowlevel(False, dummy_index)
                    details = m.get_attribute_details(m.index(r, 0, dummy_index))
                    m.set_lowlevel(True, dummy_index)

def test_file_for(filename, on_di):    
    print("=================== " + filename)
    arches = False
    def save_arches(a):
        nonlocal arches
        arches = a
        return None # Cancel out of loading
    di = read_dwarf(filename, save_arches)
    if arches: # Fat binary - go through all through architectures
        for arch_no in range(0, len(arches)):
            print("----------- " + arches[arch_no])
            di = read_dwarf(filename, lambda arches:arch_no)
            if di:
                on_di(di)
    elif di:
        on_di(di)

def test_file(filename):
    test_file_for(filename, test_dwarfinfo)

def test_tree_for(path, on_di):
    for f in os.listdir(path):
        full_path = os.path.join(path, f)
        # See what can be done about JiPad ones
        if f.endswith('.dSYM') or f.endswith('.o') or f.endswith('.elf') or (f.endswith('.so') and not f.endswith('libJiPadLib.so')):
            test_file_for(full_path, on_di)
        elif os.path.isdir(full_path):
            test_tree_for(full_path, on_di)        

def test_tree(path):
    test_tree_for(path, test_dwarfinfo)




# Caught on GNU_call_site_value

# All sec_offsets must be parsed

# All expressions must be parsed - which forms are expressions?
```