Project Path: arc_benui-dev_UE-BUIValidator_w2f6epby

Source Tree:

```txt
arc_benui-dev_UE-BUIValidator_w2f6epby
├── BUIValidator.uplugin
├── Config
│   └── FilterPlugin.ini
├── LICENSE
├── README.md
└── Source
    └── BUIValidator
        ├── BUIValidator.Build.cs
        ├── Private
        │   ├── BUIEditorValidator_RequiredProperty.cpp
        │   ├── BUIEditorValidator_Textures.cpp
        │   ├── BUIValidateAllCommandlet.cpp
        │   ├── BUIValidateAllCommandlet.h
        │   ├── BUIValidatorModule.cpp
        │   └── BUIValidatorSettings.cpp
        └── Public
            ├── BUIEditorValidator_RequiredProperty.h
            ├── BUIEditorValidator_Textures.h
            ├── BUIValidatorModule.h
            └── BUIValidatorSettings.h

```

`BUIValidator.uplugin`:

```uplugin
{
	"FileVersion": 3,
	"Version": 1,
	"VersionName": "1.1",
	"FriendlyName": "BUIValidator",
	"Description": "Validate assets based on rules",
	"Category": "Other",
	"CreatedBy": "benui",
	"CreatedByURL": "https://benui.ca/",
	"DocsURL": "https://github.com/benui-dev/UE4-BUIValidator",
	"MarketplaceURL": "",
	"SupportURL": "https://github.com/benui-dev/UE4-BUIValidator",
	"CanContainContent": false,
	"IsBetaVersion": false,
	"IsExperimentalVersion": false,
	"Installed": false,
	"Modules": [
		{
			"Name": "BUIValidator",
			"Type": "Editor",
			"LoadingPhase": "Default",
			"WhitelistPlatforms": [ "Win64", "Mac", "Linux" ]
		}
	],
	"Plugins": [
		{
			"Name": "DataValidation",
			"Enabled": true
		}
	]
}

```

`Config/FilterPlugin.ini`:

```ini
[FilterPlugin]
; This section lists additional files which will be packaged along with your plugin. Paths should be listed relative to the root plugin directory, and
; may include "...", "*", and "?" wildcards to match directories, files, and individual characters respectively.
;
; Examples:
;    /README.txt
;    /Extras/...
;    /Binaries/ThirdParty/*.dll

```

`LICENSE`:

```
Creative Commons Legal Code

CC0 1.0 Universal

    CREATIVE COMMONS CORPORATION IS NOT A LAW FIRM AND DOES NOT PROVIDE
    LEGAL SERVICES. DISTRIBUTION OF THIS DOCUMENT DOES NOT CREATE AN
    ATTORNEY-CLIENT RELATIONSHIP. CREATIVE COMMONS PROVIDES THIS
    INFORMATION ON AN "AS-IS" BASIS. CREATIVE COMMONS MAKES NO WARRANTIES
    REGARDING THE USE OF THIS DOCUMENT OR THE INFORMATION OR WORKS
    PROVIDED HEREUNDER, AND DISCLAIMS LIABILITY FOR DAMAGES RESULTING FROM
    THE USE OF THIS DOCUMENT OR THE INFORMATION OR WORKS PROVIDED
    HEREUNDER.

Statement of Purpose

The laws of most jurisdictions throughout the world automatically confer
exclusive Copyright and Related Rights (defined below) upon the creator
and subsequent owner(s) (each and all, an "owner") of an original work of
authorship and/or a database (each, a "Work").

Certain owners wish to permanently relinquish those rights to a Work for
the purpose of contributing to a commons of creative, cultural and
scientific works ("Commons") that the public can reliably and without fear
of later claims of infringement build upon, modify, incorporate in other
works, reuse and redistribute as freely as possible in any form whatsoever
and for any purposes, including without limitation commercial purposes.
These owners may contribute to the Commons to promote the ideal of a free
culture and the further production of creative, cultural and scientific
works, or to gain reputation or greater distribution for their Work in
part through the use and efforts of others.

For these and/or other purposes and motivations, and without any
expectation of additional consideration or compensation, the person
associating CC0 with a Work (the "Affirmer"), to the extent that he or she
is an owner of Copyright and Related Rights in the Work, voluntarily
elects to apply CC0 to the Work and publicly distribute the Work under its
terms, with knowledge of his or her Copyright and Related Rights in the
Work and the meaning and intended legal effect of CC0 on those rights.

1. Copyright and Related Rights. A Work made available under CC0 may be
protected by copyright and related or neighboring rights ("Copyright and
Related Rights"). Copyright and Related Rights include, but are not
limited to, the following:

  i. the right to reproduce, adapt, distribute, perform, display,
     communicate, and translate a Work;
 ii. moral rights retained by the original author(s) and/or performer(s);
iii. publicity and privacy rights pertaining to a person's image or
     likeness depicted in a Work;
 iv. rights protecting against unfair competition in regards to a Work,
     subject to the limitations in paragraph 4(a), below;
  v. rights protecting the extraction, dissemination, use and reuse of data
     in a Work;
 vi. database rights (such as those arising under Directive 96/9/EC of the
     European Parliament and of the Council of 11 March 1996 on the legal
     protection of databases, and under any national implementation
     thereof, including any amended or successor version of such
     directive); and
vii. other similar, equivalent or corresponding rights throughout the
     world based on applicable law or treaty, and any national
     implementations thereof.

2. Waiver. To the greatest extent permitted by, but not in contravention
of, applicable law, Affirmer hereby overtly, fully, permanently,
irrevocably and unconditionally waives, abandons, and surrenders all of
Affirmer's Copyright and Related Rights and associated claims and causes
of action, whether now known or unknown (including existing as well as
future claims and causes of action), in the Work (i) in all territories
worldwide, (ii) for the maximum duration provided by applicable law or
treaty (including future time extensions), (iii) in any current or future
medium and for any number of copies, and (iv) for any purpose whatsoever,
including without limitation commercial, advertising or promotional
purposes (the "Waiver"). Affirmer makes the Waiver for the benefit of each
member of the public at large and to the detriment of Affirmer's heirs and
successors, fully intending that such Waiver shall not be subject to
revocation, rescission, cancellation, termination, or any other legal or
equitable action to disrupt the quiet enjoyment of the Work by the public
as contemplated by Affirmer's express Statement of Purpose.

3. Public License Fallback. Should any part of the Waiver for any reason
be judged legally invalid or ineffective under applicable law, then the
Waiver shall be preserved to the maximum extent permitted taking into
account Affirmer's express Statement of Purpose. In addition, to the
extent the Waiver is so judged Affirmer hereby grants to each affected
person a royalty-free, non transferable, non sublicensable, non exclusive,
irrevocable and unconditional license to exercise Affirmer's Copyright and
Related Rights in the Work (i) in all territories worldwide, (ii) for the
maximum duration provided by applicable law or treaty (including future
time extensions), (iii) in any current or future medium and for any number
of copies, and (iv) for any purpose whatsoever, including without
limitation commercial, advertising or promotional purposes (the
"License"). The License shall be deemed effective as of the date CC0 was
applied by Affirmer to the Work. Should any part of the License for any
reason be judged legally invalid or ineffective under applicable law, such
partial invalidity or ineffectiveness shall not invalidate the remainder
of the License, and in such case Affirmer hereby affirms that he or she
will not (i) exercise any of his or her remaining Copyright and Related
Rights in the Work or (ii) assert any associated claims and causes of
action with respect to the Work, in either case contrary to Affirmer's
express Statement of Purpose.

4. Limitations and Disclaimers.

 a. No trademark or patent rights held by Affirmer are waived, abandoned,
    surrendered, licensed or otherwise affected by this document.
 b. Affirmer offers the Work as-is and makes no representations or
    warranties of any kind concerning the Work, express, implied,
    statutory or otherwise, including without limitation warranties of
    title, merchantability, fitness for a particular purpose, non
    infringement, or the absence of latent or other defects, accuracy, or
    the present or absence of errors, whether or not discoverable, all to
    the greatest extent permissible under applicable law.
 c. Affirmer disclaims responsibility for clearing rights of other persons
    that may apply to the Work or any use thereof, including without
    limitation any person's Copyright and Related Rights in the Work.
    Further, Affirmer disclaims responsibility for obtaining any necessary
    consents, permissions or other rights required for any use of the
    Work.
 d. Affirmer understands and acknowledges that Creative Commons is not a
    party to this document and has no duty or obligation with respect to
    this CC0 or use of the Work.

```

`README.md`:

```md
# Unreal Engine Texture Validator Plugin

A plugin that both validates and automatically applies settings for texture assets in Unreal Engine.

## What can it do?

* Throw errors when texture size, texture group and other properties do not
  match customizable rules.
* Automatically set default values for new textures upon import.
* Set different validation rules for textures with different prefixes, or for
  different folders within Unreal.
* Throw errors when users import textures without setting the Data Source
  Folder in their Editor Settings.
* Throw errors when `UPROPERTY()` values are not set.
* Run all rules and validate assets from command-line

## Usage

Once installed, open Project Settings > BUI Validator.

Here you can set up validator groups, that consist of match conditions and
rules to be applied to those matches.

![Settings example](https://benui.ca/assets/unreal/validator-settings-example.png)

### Settings

#### Match Conditions

For a rule to be triggered, **all** conditions of the match must pass.

* **Texture groups:** Match textures with _any_ of the texture groups.
* **Prefixes:** Match textures with _any_ of the asset name prefixes.
* **Suffixes:** Match textures with _any_ of the asset name suffixes.
* **Paths:** Match textures in _any_ of the asset directories.

#### Validator Rules

Each rule allows multiple values for a given setting. For example a texture
could be allowed to be within World or UI. To pass, the asset must match
**any** of the values.

* **Texture groups:** Textures must have one of the specified Texture Groups.
* **Compression Settings:** Textures must have one of the specified
  Compression Settings.
* **Pixel Formats:** Textures must have one of these Pixel Formats
* **Mip Gen Settings:** Textures must have one of these Mip Gen Settings
* **Prefixes:** Textures must have one of these prefixes.
* **Texture Size:** Textures must pass these size requirements. Size
  requirements are "Multiple of Four" or "Power of Two"
* **Paths:** Textures must be within this path in Unreal.
* **Require Data Source Folder:** Require that the Data Source Folder be set in
  Editor Preferences, and that assets are imported from there. This is to aid [reimporting between team members](https://benui.ca/unreal/reimporting-assets/).

#### Auto-apply settings to new textures

Validator Groups have an _Apply On Import_ option. When checked, any
newly-imported assets that match the group will have some rules automatically
applied to them.

Prefix, Texture Size and Path rules are not applied on import.

### C++ UPROPERTY() Settings

The plugin also supports making `UPROPERTY` properties _required_.

```cpp
// If this is not set, the BP will show an error on save
UPROPERTY( EditAnywhere, meta = ( BUIRequired = "true" ) )
TSubclassOf<AActor> RequiredActor;
```

![BUIRequired flow example](https://benui.ca/assets/unreal/buivalidator-buirequired.png)

### Running Validation

Whenever UTexture2D asset is saved, the rules in Project Settings are applied.
If the asset does not pass, an error is shown.

![Failure example](https://benui.ca/assets/unreal/validator-fail-example.png)

### Command-line Validation

This is useful when validating assets as part of a build process.

```
"C:\Program Files\Epic Games\UE_5.0EA\Engine\Binaries\Win64\UnrealEditor-Win64-DebugGame-Cmd.exe" -run=BUIValidateAll
```

## Installation

1. Download the zip or clone the Github repository into
   `YourProject/Plugins/BUIValidator/`
2. Add the following to the end of your `.uproject` file, inside the `{ }`
```json
	"Plugins": [
		{
			"Name": "BUIValidator",
			"Enabled": true
		}
	]
```

## License

[CC0](https://creativecommons.org/publicdomain/zero/1.0/)

## Contact

If you find it useful, drop me a line [@_benui](https://twitter.com/_benui) on Twitter.

[benui.ca](https://benui.ca)


## Future Work

* Add support for validating builds using the [Data Validation plugin](https://docs.unrealengine.com/5.0/en-US/data-validation/)
* Regular expression support
* More explicit support for And/Or matching
* Support more texture settings (sRGB, others)
* Support more data types


```

`Source/BUIValidator/BUIValidator.Build.cs`:

```cs
// Copyright ben ui. All Rights Reserved.

using UnrealBuildTool;

public class BUIValidator : ModuleRules
{
	public BUIValidator(ReadOnlyTargetRules Target) : base(Target)
	{
		PCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;

		PublicDependencyModuleNames.AddRange(new string[]
		{
			"Core",
		});


		PrivateDependencyModuleNames.AddRange(new string[]
		{
			"CoreUObject",
			"Engine",
			"DataValidation",
			"UnrealEd"
		});
	}
}
```

`Source/BUIValidator/Private/BUIEditorValidator_RequiredProperty.cpp`:

```cpp
// Copyright ben ui. All Rights Reserved.

#include "BUIEditorValidator_RequiredProperty.h"
#include "Engine/Texture2D.h"
#include "UObject/UnrealType.h"

#define LOCTEXT_NAMESPACE "BUIEditorValidator"

const FName UBUIEditorValidator_RequiredProperty::PropertyName = "BUIRequired";

UBUIEditorValidator_RequiredProperty::UBUIEditorValidator_RequiredProperty()
	: Super()
{
	bIsEnabled = true;
}

bool UBUIEditorValidator_RequiredProperty::CanValidateAsset_Implementation(UObject* InAsset) const
{
	UClass* AssetClass = nullptr;
	UBlueprint* Bp = Cast<UBlueprint>(InAsset);
	if (Bp && Bp->ParentClass)
	{
		AssetClass = Bp->ParentClass;
	}
	else
	{
		AssetClass = InAsset->GetClass();
	}
	for (TFieldIterator<FProperty> PropertyIterator(AssetClass); PropertyIterator; ++PropertyIterator)
	{
		if (PropertyIterator->GetBoolMetaData(PropertyName))
		{
			return true;
		}
	}
	return false;
}

EDataValidationResult UBUIEditorValidator_RequiredProperty::ValidateLoadedAsset_Implementation(
	UObject* InAsset, TArray<FText>& ValidationErrors)
{
	bool bAnyFailed = false;
	bool bAnyChecked = false;

	UClass* AssetClass = nullptr;
	UBlueprint* Bp = Cast<UBlueprint>(InAsset);
	if (Bp && Bp->ParentClass)
	{
		AssetClass = Bp->GeneratedClass;
	}
	else
	{
		AssetClass = InAsset->GetClass();
	}

	UObject* MyCDO = AssetClass->GetDefaultObject(true);
	for (TFieldIterator<FProperty> PropertyIterator(AssetClass); PropertyIterator; ++PropertyIterator)
	{
		if (PropertyIterator->GetBoolMetaData(PropertyName))
		{
			bAnyChecked = true;
			FObjectPropertyBase* ObjProp = CastField<FObjectPropertyBase>(*PropertyIterator);
			if (ObjProp)
			{
				UObject* Something = ObjProp->GetObjectPropertyValue_InContainer(MyCDO);

				if (Something == nullptr)
				{
					bAnyFailed = true;
					AssetFails(InAsset, FText::FormatNamed(
						LOCTEXT("BUIValidatorError_NotSet", "Property '{PropertyName}' is not set. All variables marked with '{BUIMetaName}' must be set to non-null"),
						"PropertyName", ObjProp->GetDisplayNameText(),
						"BUIMetaName", FText::FromName(PropertyName)),
						ValidationErrors);
				}
			}
		}
	}

	if (!bAnyChecked)
		return EDataValidationResult::NotValidated;

	if (!bAnyFailed)
	{
		AssetPasses(InAsset);
	}
	return bAnyFailed ? EDataValidationResult::Invalid : EDataValidationResult::Valid;
}

#undef LOCTEXT_NAMESPACE

```

`Source/BUIValidator/Private/BUIEditorValidator_Textures.cpp`:

```cpp
// Copyright ben ui. All Rights Reserved.

#include "BUIEditorValidator_Textures.h"
#include "Engine/Texture2D.h"
#include "Editor/EditorPerProjectUserSettings.h"
#include "EditorFramework/AssetImportData.h"
#include "BUIValidatorSettings.h"

#define LOCTEXT_NAMESPACE "BUIEditorValidator"

UBUIEditorValidator_Textures::UBUIEditorValidator_Textures()
	: Super()
{
	bIsEnabled = true;
}

bool UBUIEditorValidator_Textures::CanValidateAsset_Implementation(const FAssetData& InAssetData, UObject* InObject, FDataValidationContext& InContext) const
{
	const UBUIValidatorSettings& ValidatorSettings = *GetDefault<UBUIValidatorSettings>();
	return ValidatorSettings.ShouldValidateAsset(InObject);
}

bool GetIsPowerOfTwo(int32 Num)
{
	return (Num & (Num - 1)) == 0;
}

EDataValidationResult UBUIEditorValidator_Textures::ValidateLoadedAsset_Implementation(const FAssetData& InAssetData, UObject* InAsset, FDataValidationContext& Context)
{
	bool bAnyFailed = false;
	bool bAnyChecked = false;

	UTexture2D* Texture = Cast<UTexture2D>(InAsset);
	if (Texture)
	{
		const FString ImportAssetPath = Texture->AssetImportData->GetFirstFilename();
		const UBUIValidatorSettings& ValidatorSettings = *GetDefault<UBUIValidatorSettings>();

		// First see if this matches
		for (const auto& Group : ValidatorSettings.ValidationGroups)
		{
			if (Group.ShouldGroupValidateAsset(InAsset))
			{
				if (Group.ValidationRule.TextureGroups.Num())
				{
					bAnyChecked = true;

					if (!Group.ValidationRule.TextureGroups.Contains(Texture->LODGroup))
					{
						bAnyFailed = true;
						TArray<FString> TextureGroupNames;
						UEnum* TextureGroupEnum = StaticEnum<TextureGroup>();
						for (const auto& TextureGroup : Group.ValidationRule.TextureGroups)
						{
							TextureGroupNames.Add(TextureGroupEnum->GetMetaData(TEXT("DisplayName"), TextureGroup));
						}
						AssetFails(InAsset, FText::Format(
							LOCTEXT("BUIValidatorError_TextureGroup", "Texture asset texture group must be '{0}', but is '{1}'"),
							FText::FromString(FString::Join(TextureGroupNames, TEXT(", "))),
							FText::FromString(TextureGroupEnum->GetMetaData(TEXT("DisplayName"), Texture->LODGroup))));
					}
				}

				if (Group.ValidationRule.PixelFormats.Num())
				{
					bAnyChecked = true;
					if (!Group.ValidationRule.PixelFormats.Contains(Texture->GetPixelFormat()))
					{
						bAnyFailed = true;
						TArray<FString> PixelFormatNames;
						for (const auto& PixelFormat : Group.ValidationRule.PixelFormats)
						{
							PixelFormatNames.Add(UEnum::GetValueAsString(PixelFormat));
						}
						AssetFails(InAsset, FText::Format(
							LOCTEXT("BUIValidatorError_PixelFormat","Texture asset pixel format must be '{0}', but is '{1}'"),
							FText::FromString(FString::Join(PixelFormatNames, TEXT(", "))),
							FText::FromString(UEnum::GetValueAsString(Texture->GetPixelFormat()))));
					}
				}

				if (Group.ValidationRule.CompressionSettings.Num())
				{
					bAnyChecked = true;
					if (!Group.ValidationRule.CompressionSettings.Contains(Texture->CompressionSettings))
					{
						bAnyFailed = true;
						TArray<FString> CompressionSettingNames;
						UEnum* CompressionSettingsEnum = StaticEnum<TextureCompressionSettings>();
						for (const auto& CompressionSetting : Group.ValidationRule.CompressionSettings)
						{
							CompressionSettingNames.Add(
								CompressionSettingsEnum->GetMetaData(TEXT("DisplayName"), CompressionSetting));
						}
						AssetFails(InAsset, FText::Format(
							LOCTEXT("BUIValidatorError_PixelFormat","Texture asset pixel format must be '{0}', but is '{1}'"),
							FText::FromString(FString::Join(CompressionSettingNames, TEXT(", "))),
							FText::FromString(CompressionSettingsEnum->GetMetaData(TEXT("DisplayName"), Texture->CompressionSettings))));
					}
				}

				if (Group.ValidationRule.MipGenSettings.Num())
				{
					bAnyChecked = true;
					if (!Group.ValidationRule.MipGenSettings.Contains(Texture->MipGenSettings))
					{
						bAnyFailed = true;
						TArray<FString> MipGenSettingNames;
						UEnum* MipGenSettingsEnum = StaticEnum<TextureMipGenSettings>();
						for (const auto& MipGenSetting : Group.ValidationRule.MipGenSettings)
						{
							MipGenSettingNames.Add(MipGenSettingsEnum->GetMetaData(TEXT("DisplayName"), MipGenSetting));
						}
						AssetFails(InAsset, FText::Format(
							LOCTEXT("BUIValidatorError_PixelFormat", "Texture asset mip gen settings must be '{0}', but is '{1}'"),
							FText::FromString(FString::Join(MipGenSettingNames, TEXT(", "))),
							FText::FromString(MipGenSettingsEnum->GetMetaData(TEXT("DisplayName"), Texture->MipGenSettings))));
					}
				}

				if (Group.ValidationRule.TextureSizeRequirements.Num() > 0)
				{
					bAnyChecked = true;
					if (Group.ValidationRule.TextureSizeRequirements.Contains(EBUITextureSizeRequirement::MultipleOfFour)
						&& (Texture->GetSizeX() % 4 != 0 || Texture->GetSizeY() % 4 != 0))
					{
						bAnyFailed = true;
						AssetFails(InAsset, FText::Format(
							LOCTEXT("BUIValidatorError_MultipleOfFour",
							"Texture asset size must be a multiple of 4, but is {0}x{1}"),
							FText::AsNumber(Texture->GetSizeX(), &FNumberFormattingOptions::DefaultNoGrouping()),
							FText::AsNumber(Texture->GetSizeY(), &FNumberFormattingOptions::DefaultNoGrouping())));
					}
					else if (Group.ValidationRule.TextureSizeRequirements.Contains(EBUITextureSizeRequirement::PowerOfTwo)
						&& (!GetIsPowerOfTwo(Texture->GetSizeX()) || !GetIsPowerOfTwo(Texture->GetSizeY())))
					{
						bAnyFailed = true;
						AssetFails(InAsset, FText::Format(
							LOCTEXT("BUIValidatorError_PowerOfTwo", "Texture asset size must be a power of two, but is {0}x{1}"),
							FText::AsNumber(Texture->GetSizeX(), &FNumberFormattingOptions::DefaultNoGrouping()),
							FText::AsNumber(Texture->GetSizeY(), &FNumberFormattingOptions::DefaultNoGrouping())));
					}
				}

				if (Group.ValidationRule.Prefixes.Num() > 0)
				{
					bAnyChecked = true;
					const FString Filename = FPaths::GetCleanFilename(ImportAssetPath);
					bool bAnyMatched = false;
					for (const auto& Prefix : Group.ValidationRule.Prefixes)
					{
						if (Filename.StartsWith(Prefix))
						{
							bAnyMatched = true;
						}
					}
					if (!bAnyMatched)
					{
						bAnyFailed = true;
						AssetFails(InAsset, FText::Format(
							LOCTEXT("BUIValidatorError_Prefix", "Texture asset name must be prefixed with '{0}', but is '{1}'"),
							FText::FromString(FString::Join(Group.ValidationRule.Prefixes, TEXT(", "))),
							FText::FromString(Filename)));
					}
				}

				if (Group.ValidationRule.Suffixes.Num() > 0)
				{
					bAnyChecked = true;
					const FString Filename = FPaths::GetCleanFilename(ImportAssetPath);
					bool bAnyMatched = false;
					for (const auto& Suffix : Group.ValidationRule.Suffixes)
					{
						if (Filename.EndsWith(Suffix))
						{
							bAnyMatched = true;
						}
					}
					if (!bAnyMatched)
					{
						bAnyFailed = true;
						AssetFails(InAsset, FText::Format(
							LOCTEXT("BUIValidatorError_Suffix", "Texture asset name must be suffixed with '{0}', but is '{1}'"),
							FText::FromString(FString::Join(Group.ValidationRule.Suffixes, TEXT(", "))),
							FText::FromString(Filename)));
					}
				}

				if (Group.ValidationRule.bRequireDataSourceFolder)
				{
					bAnyChecked = true;
					TArray<FString> AbsoluteFilenames = Texture->AssetImportData->ExtractFilenames();

					const UEditorPerProjectUserSettings& EditorSettings = *GetDefault<UEditorPerProjectUserSettings>();

					if (EditorSettings.DataSourceFolder.Path.IsEmpty())
					{
						bAnyFailed = true;
						AssetFails(InAsset, LOCTEXT("BUIValidatorError_NoDataSourceFolder", "Data Source Folder must be set. Please set it in Editor Preferences"));
					}
					else if (!ImportAssetPath.StartsWith(EditorSettings.DataSourceFolder.Path))
					{
						bAnyFailed = true;
						AssetFails(InAsset, FText::Format(
						LOCTEXT("BUIValidatorError_FileImportedOutsideDataSourceFolder", "Importing a file from '{0}', outside of Data Source Folder '{1}'"),
							FText::FromString(ImportAssetPath),
							FText::FromString(EditorSettings.DataSourceFolder.Path)));
					}
				}

				if (Group.ValidationRule.bSpecifySRGB)
				{
					bAnyChecked = true;

					if (Texture->SRGB != Group.ValidationRule.bSRGB)
					{
						bAnyFailed = true;
						AssetFails(InAsset, FText::Format(
							LOCTEXT("BUIValidatorError_SRGBMismatch", "Texture asset must have sRGB set to '{0}', was set to '{1}'"),
							Group.ValidationRule.bSRGB ? LOCTEXT("True", "True") : LOCTEXT("False", "False"),
							Texture->SRGB ? LOCTEXT("True", "True") : LOCTEXT("False", "False")));
					}
				}
			}
		}
	}

	if (!bAnyChecked)
		return EDataValidationResult::NotValidated;

	if (!bAnyFailed)
	{
		AssetPasses(InAsset);
	}
	return bAnyFailed ? EDataValidationResult::Invalid : EDataValidationResult::Valid;
}

#undef LOCTEXT_NAMESPACE

```

`Source/BUIValidator/Private/BUIValidateAllCommandlet.cpp`:

```cpp
// Copyright ben ui. All Rights Reserved.

#include "BUIValidateAllCommandlet.h"

DEFINE_LOG_CATEGORY(LogCommandletPlugin);

UBUIValidateAllCommandlet::UBUIValidateAllCommandlet()
{
	HelpDescription = "Runs existing validation rules on all assets";
	HelpWebLink = "https://github.com/benui-dev/UE-BUIValidator";
	
	IsClient = false;
	IsEditor = false;
	IsServer = false;
	LogToConsole = true;
}

int32 UBUIValidateAllCommandlet::Main(const FString& Params)
{
#if 0
	UE_LOG(LogCommandletPlugin, Display, TEXT("Hello world!"));

	FBUIValidatorModule& ValidatorModule = FModuleManager::LoadModuleChecked<FBUIValidatorModule>("BUIValidator");
	//AssetRegistryModule.Get().SearchAllAssets(true);
	
	FAssetRegistryModule& AssetRegistryModule = FModuleManager::LoadModuleChecked<FAssetRegistryModule>(AssetRegistryConstants::ModuleName);
	AssetRegistryModule.Get().SearchAllAssets(true);

	// Load paths from settings
	const UBUIValidatorSettings& ValidatorSettings = *GetDefault<UBUIValidatorSettings>();
	for ( const auto& Group : ValidatorSettings.ValidationGroups )
	{
		if ( Group.bRunInCommandlet
			&& Group.ShouldGroupValidateAsset()
		{
			if ( Group.ValidationRule.TextureGroups.Num() > 0 )
			{
				Texture->LODGroup = Group.ValidationRule.TextureGroups[ 0 ];
			}

			if ( Group.ValidationRule.CompressionSettings.Num() > 0 )
			{
				Texture->CompressionSettings = Group.ValidationRule.CompressionSettings[ 0 ];
			}

			if ( Group.ValidationRule.MipGenSettings.Num() > 0 )
			{
				Texture->MipGenSettings = Group.ValidationRule.MipGenSettings[ 0 ];
			}
		}
	}


	FARFilter Filter;
	Filter.ClassNames.Add(UTexture::StaticClass()->GetFName());

	AssetRegistryModule.Get().EnumerateAssets(Filter, [FoundAssets = &AssetData, InInterfaceClass](const FAssetData& InAssetData)
	{
		if (ImplementsInterface(InAssetData, InInterfaceClass))
		{
			FoundAssets->Add(InAssetData);
		}

		return true;
	});

#endif
	return 0;
}
```

`Source/BUIValidator/Private/BUIValidateAllCommandlet.h`:

```h
// Copyright ben ui. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Commandlets/Commandlet.h"
#include "BUIValidateAllCommandlet.generated.h"

DECLARE_LOG_CATEGORY_EXTERN(LogCommandletPlugin, Log, All);

UCLASS()
class UBUIValidateAllCommandlet : public UCommandlet
{
	GENERATED_BODY()
public:
	UBUIValidateAllCommandlet();

	// Begin UCommandlet interface
	virtual int32 Main(const FString& Params) override;
	// End UCommandlet interface
};

```

`Source/BUIValidator/Private/BUIValidatorModule.cpp`:

```cpp
// Copyright ben ui. All Rights Reserved.

#include "BUIValidatorModule.h"
#include "BUIValidatorSettings.h"
#include "ISettingsModule.h"
#include "ISettingsSection.h"
#include "ISettingsContainer.h"
#include "Subsystems/ImportSubsystem.h"

#define LOCTEXT_NAMESPACE "FBUIValidatorModule"

void FBUIValidatorModule::StartupModule()
{
	if (ISettingsModule* SettingsModule = FModuleManager::GetModulePtr<ISettingsModule>("Settings"))
	{
		ISettingsContainerPtr SettingsContainer = SettingsModule->GetContainer("Project");
		ISettingsSectionPtr SettingsSection = SettingsModule->RegisterSettings(
			"Project",
			"Plugins",
			"BUI Validator",
			LOCTEXT("RuntimeGeneralSettingsName", "BUI Validator"),
			LOCTEXT("RuntimeGeneralSettingsDescription", "Configure UI data asset validation."),
			GetMutableDefault<UBUIValidatorSettings>());

		if (SettingsSection.IsValid())
		{
			SettingsSection->OnModified().BindRaw(this, &FBUIValidatorModule::HandleSettingsSaved);
		}
	}

	FCoreDelegates::OnPostEngineInit.AddRaw(this, &FBUIValidatorModule::OnPostEngineInit);
}

void FBUIValidatorModule::ShutdownModule()
{
	if (ISettingsModule* SettingsModule = FModuleManager::GetModulePtr<ISettingsModule>("Settings"))
	{
		SettingsModule->UnregisterSettings("Project", "Project", "General");
	}

	if (GIsEditor)
	{
		if (GEditor && GEditor->GetEditorSubsystem<UImportSubsystem>())
			GEditor->GetEditorSubsystem<UImportSubsystem>()->OnAssetPostImport.RemoveAll(this);
	}
}

void FBUIValidatorModule::OnPostEngineInit()
{
	if (GIsEditor)
	{
		GEditor->GetEditorSubsystem<UImportSubsystem>()->OnAssetPostImport.AddRaw(
			this, &FBUIValidatorModule::OnObjectReimported);
	}
}

void FBUIValidatorModule::OnObjectReimported(UFactory* ImportFactory, UObject* InObject)
{
	UTexture2D* Texture = Cast<UTexture2D>(InObject);
	if (!Texture)
		return;

	// Only apply defaults to newly-imported assets
	const UBUIValidatorSettings& ValidatorSettings = *GetDefault<UBUIValidatorSettings>();
	for (const auto& Group : ValidatorSettings.ValidationGroups)
	{
		if (Group.bApplyOnImport
			&& Group.ShouldGroupValidateAsset(InObject))
		{
			if (Group.ValidationRule.TextureGroups.Num() > 0 && !Group.ValidationRule.TextureGroups.Contains(
				Texture->LODGroup))
			{
				Texture->LODGroup = Group.ValidationRule.TextureGroups[0];
			}

			if (Group.ValidationRule.CompressionSettings.Num() > 0 && !Group.ValidationRule.CompressionSettings.
			                                                                 Contains(Texture->CompressionSettings))
			{
				Texture->CompressionSettings = Group.ValidationRule.CompressionSettings[0];
			}

			if (Group.ValidationRule.MipGenSettings.Num() > 0 && !Group.ValidationRule.MipGenSettings.Contains(
				Texture->MipGenSettings))
			{
				Texture->MipGenSettings = Group.ValidationRule.MipGenSettings[0];
			}
		}
	}
}

bool FBUIValidatorModule::HandleSettingsSaved()
{
	UBUIValidatorSettings* Settings = GetMutableDefault<UBUIValidatorSettings>();
	bool ResaveSettings = false;

	// You can put any validation code in here and resave the settings in case an invalid
	// value has been entered

	if (ResaveSettings)
	{
		Settings->SaveConfig();
	}

	return true;
}

#undef LOCTEXT_NAMESPACE

IMPLEMENT_MODULE(FBUIValidatorModule, BUIValidator)

```

`Source/BUIValidator/Private/BUIValidatorSettings.cpp`:

```cpp
// Copyright ben ui. All Rights Reserved.

#include "BUIValidatorSettings.h"
#include "Engine/Texture2D.h"

#define LOCTEXT_NAMESPACE "BUIEditorValidator"

bool UBUIValidatorSettings::ShouldValidateAsset(UObject* InAsset) const
{
	UTexture2D* Texture = Cast<UTexture2D>(InAsset);
	if (Texture)
	{
		const UBUIValidatorSettings& ValidatorSettings = *GetDefault<UBUIValidatorSettings>();
		for (const auto& Group : ValidatorSettings.ValidationGroups)
		{
			if (Group.ShouldGroupValidateAsset(InAsset))
				return true;
		}
	}

	return false;
}

bool FBUIValidatorGroup::ShouldGroupValidateAsset(UObject* InAsset) const
{
	UTexture2D* Texture = Cast<UTexture2D>(InAsset);
	if (!Texture)
		return false;

	const FString AssetPathInUnreal = Texture->GetPathName();

	bool bMatchAnyTextureGroup = MatchConditions.TextureGroups.Num() == 0
		|| MatchConditions.TextureGroups.Contains(Texture->LODGroup);

	bool bMatchAnyPath = MatchConditions.Paths.Num() == 0;
	for (const auto& Path : MatchConditions.Paths)
	{
		if (AssetPathInUnreal.StartsWith(Path.Path))
		{
			bMatchAnyPath = true;
			break;
		}
	}

	bool bMatchAnyPrefix = MatchConditions.Prefixes.Num() == 0;
	for (const auto& Prefix : MatchConditions.Prefixes)
	{
		if (FPaths::GetCleanFilename(AssetPathInUnreal).StartsWith(Prefix))
		{
			bMatchAnyPrefix = true;
			break;
		}
	}

	bool bMatchAnySuffix = MatchConditions.Suffixes.Num() == 0;
	for (const auto& Suffix : MatchConditions.Suffixes)
	{
		if (FPaths::GetCleanFilename(AssetPathInUnreal).EndsWith(Suffix))
		{
			bMatchAnySuffix = true;
			break;
		}
	}

	// Let's apply rules to this texture
	return bMatchAnyTextureGroup && bMatchAnyPath && bMatchAnyPrefix && bMatchAnySuffix;
}

#undef LOCTEXT_NAMESPACE

```

`Source/BUIValidator/Public/BUIEditorValidator_RequiredProperty.h`:

```h
// Copyright ben ui. All Rights Reserved.

#pragma once

#include "EditorValidatorBase.h"
#include "BUIEditorValidator_RequiredProperty.generated.h"

UCLASS(meta = ( DisplayName = "BUI Required Property Validator" ))
class BUIVALIDATOR_API UBUIEditorValidator_RequiredProperty : public UEditorValidatorBase
{
	GENERATED_BODY()

public:
	UBUIEditorValidator_RequiredProperty();

protected:
	static const FName PropertyName;
	virtual bool CanValidateAsset_Implementation(UObject* InAsset) const override;
	virtual EDataValidationResult ValidateLoadedAsset_Implementation(UObject* InAsset, TArray<FText>& ValidationErrors) override;
};

```

`Source/BUIValidator/Public/BUIEditorValidator_Textures.h`:

```h
// Copyright ben ui. All Rights Reserved.

#pragma once

#include "EditorValidatorBase.h"
#include "BUIEditorValidator_Textures.generated.h"

struct FAssetData;

UCLASS(meta = ( DisplayName = "BUI Texture Validator" ))
class BUIVALIDATOR_API UBUIEditorValidator_Textures : public UEditorValidatorBase
{
	GENERATED_BODY()

public:
	UBUIEditorValidator_Textures();

protected:
	virtual bool CanValidateAsset_Implementation(const FAssetData& InAssetData, UObject* InObject, FDataValidationContext& InContext) const override;
	virtual EDataValidationResult ValidateLoadedAsset_Implementation(const FAssetData& InAssetData, UObject* InAsset, FDataValidationContext& Context) override;
};

```

`Source/BUIValidator/Public/BUIValidatorModule.h`:

```h
// Copyright ben ui. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Modules/ModuleManager.h"
#include "Tickable.h"

class FBUIValidatorModule : public IModuleInterface
{
public:
	// Begin IModuleInterface
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;

	virtual bool SupportsDynamicReloading() override { return true; }
	// End IModuleInterface

protected:
	bool HandleSettingsSaved();

	void OnPostEngineInit();
	void OnObjectReimported( UFactory* ImportFactory, UObject* InObject );
};

```

`Source/BUIValidator/Public/BUIValidatorSettings.h`:

```h
// Copyright ben ui. All Rights Reserved.

#pragma once

#include "BUIValidatorSettings.generated.h"

UENUM()
enum class EBUITextureSizeRequirement
{
	MultipleOfFour,
	PowerOfTwo,
};

USTRUCT(meta = ( ToolTip = "All parts of a rule must pass in order for the rule to be applied" ))
struct FBUIMatchConditions
{
	GENERATED_BODY()

public:
	// Match UTexture2D assets with any of these texture groups
	UPROPERTY(config, EditAnywhere, Category = Custom)
	TArray<TEnumAsByte<TextureGroup>> TextureGroups = {TextureGroup::TEXTUREGROUP_UI};

	// Match UTexture2D assets with any of these prefixes
	UPROPERTY(config, EditAnywhere, Category = Custom)
	TArray<FString> Prefixes = {"T_UI_"};

	// Match UTexture2D assets with any of these suffixes
	UPROPERTY(config, EditAnywhere, Category = Custom)
	TArray<FString> Suffixes;

	// Match UTexture2D assets under any of these directories
	UPROPERTY(EditAnywhere, meta = ( ContentDir, TitleProperty = "Path" ))
	TArray<FDirectoryPath> Paths;
};

USTRUCT()
struct FBUIValidationRule
{
	GENERATED_BODY()
	FBUIValidationRule()
	{
		// Defaults
		if (Paths.Num() == 0)
		{
			Paths.Add(FDirectoryPath());
			Paths[0].Path = "/Game/UI";
		}
	}

public:
	// Textures must be in one of these Texture Groups
	UPROPERTY(config, EditAnywhere)
	TArray<TEnumAsByte<TextureGroup>> TextureGroups = {TextureGroup::TEXTUREGROUP_UI};

	// Textures must have one of these Compression Settings
	UPROPERTY(config, EditAnywhere)
	TArray<TEnumAsByte<TextureCompressionSettings>> CompressionSettings = {TextureCompressionSettings::TC_Default};

	// Textures must have one of these Pixel Formats
	UPROPERTY(config, EditAnywhere)
	TArray<TEnumAsByte<EPixelFormat>> PixelFormats = {EPixelFormat::PF_DXT5};

	// Textures must have one of these mip gen settings
	UPROPERTY(config, EditAnywhere)
	TArray<TEnumAsByte<TextureMipGenSettings>> MipGenSettings = {TextureMipGenSettings::TMGS_FromTextureGroup};

	// Textures must have one of these prefixes. Is not applied on import
	UPROPERTY(config, EditAnywhere)
	TArray<FString> Prefixes = {"T_UI_"};

	// Textures must have one of these suffixes. Is not applied on import
	UPROPERTY(config, EditAnywhere)
	TArray<FString> Suffixes;

	// Textures must pass these size requirements. Is not applied on import
	UPROPERTY(config, EditAnywhere)
	TSet<EBUITextureSizeRequirement> TextureSizeRequirements = {EBUITextureSizeRequirement::MultipleOfFour};

	// Textures must be within this path in Unreal. Is not applied on import
	UPROPERTY(EditAnywhere, meta = ( ContentDir ))
	TArray<FDirectoryPath> Paths;

	// Require that the Data Source Folder be set in Editor Preferences, and that assets are imported from there
	UPROPERTY(EditAnywhere)
	bool bRequireDataSourceFolder = true;

	// Require that the texture
	UPROPERTY(EditAnywhere)
	bool bSpecifySRGB = false;

	// Require that the texture
	UPROPERTY(EditAnywhere, meta=(EditCondition="bSpecifySRGB", EditConditionHides ))
	bool bSRGB = true;
};

USTRUCT()
struct FBUIValidatorGroup
{
	GENERATED_BODY()

public:
	UPROPERTY(config, EditAnywhere)
	FString GroupName;

	// Apply this group's rules to newly-imported assets
	UPROPERTY(config, EditAnywhere)
	bool bApplyOnImport = false;

	// Apply this group's rules when running BUIValidateAll from the commandlet
	UPROPERTY(config, EditAnywhere)
	bool bRunInCommandlet = true;

	UPROPERTY(config, EditAnywhere, Category = "Validation", meta = ( ShowOnlyInnerProperties ))
	FBUIMatchConditions MatchConditions;

	UPROPERTY(config, EditAnywhere, Category = "Validation", meta = ( ShowOnlyInnerProperties ))
	FBUIValidationRule ValidationRule;

	bool ShouldGroupValidateAsset(UObject* InAsset) const;
};

UCLASS(config = Game, defaultconfig) //, AutoExpandCategories = "Validation" )
class UBUIValidatorSettings : public UObject
{
	GENERATED_BODY()

public:
	UPROPERTY(config, EditAnywhere, Category = "Validation", meta = ( TitleProperty = "GroupName", ShowOnlyInnerProperties ))
	TArray<FBUIValidatorGroup> ValidationGroups;

	bool ShouldValidateAsset(UObject* InAsset) const;
};

```