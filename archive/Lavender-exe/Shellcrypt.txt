Project Path: arc_Lavender-exe_Shellcrypt_dkgu_4mf

Source Tree:

```txt
arc_Lavender-exe_Shellcrypt_dkgu_4mf
â”œâ”€â”€ LICENSE
â”œâ”€â”€ README.md
â”œâ”€â”€ assets
â”‚   â””â”€â”€ Shellcrypt Demo.png
â”œâ”€â”€ config.yaml.example
â”œâ”€â”€ main.py
â”œâ”€â”€ pyproject.toml
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ shellcrypt.py
â”œâ”€â”€ tests
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ test_shellcode.bin
â”‚   â””â”€â”€ test_shellcrypt.py
â””â”€â”€ utils
    â”œâ”€â”€ __init__.py
    â”œâ”€â”€ crypters.py
    â””â”€â”€ logging.py

```

`LICENSE`:

```
MIT License

Copyright (c) 2022 iilegacyyii

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# Shellcrypt

A cross-platform quality of life tool to obfuscate a given shellcode file and output in a useful format for pasting directly into your source code.

![Screenshot of Shellcrypt encrypting shellcode](https://i.imgur.com/DavG7ad.png)
![Screenshot of Shellcrypt encrypting, encoding, and compressing shellcode](./assets/Shellcrypt%20Demo.png)

# Contributors

These are going here because they deserve it
- An00bRektn [github](https://github.com/An00bRektn) [twitter](https://twitter.com/An00bRektn) â™¥
- 0xtejas [github](https://github.com/0xtejas)
- Lavender-exe [github](https://github.com/Lavender-exe) ðŸ’œ

# Shellcode Conversions
## Crypters
### Encryption

Shellcrypt currently supports the following encryption methods (more to come in the future!)

- AES CBC - 128
- AES CBC - 256
- AES ECB - 256
- ChaCha20
- RC4
- Salsa20
- XOR
- XOR with Linear Congruential Generator (LCG)

### Encoding

- Alpha32
- Ascii85
- Base64
- Words256

### Compression

- LZNT1 (Windows Only)
- RLE

## Supported Formats

Shellcrypt currently supports the following output formats (more to come in the future!)

- C
- C#
- Nim
- Golang
- Python
- Powershell
- Visual Basic for Applications (VBA)
- Visual Basic Script (VBS)
- Rust
- Javascript
- Zig
- Raw

# Usage Information
**Encrypt shellcode with a random key**
```bash
uv run main.py -i ./shellcode.bin -f c
```
**Encrypt shellcode with 128-bit AES CBC**
```bash
uv run main.py -i ./shellcode.bin -e aes -f c
```
**Encrypt shellcode with XOR and LZNT1 Compression**
```bash
uv run main.py -i '.\test\shellcode.bin' -f c -a shellcode -e xor -k 4141 -c lznt
```
**Encrypt shellcode with a user-specified key**
```bash
uv run main.py -i ./shellcode.bin -f c -k 6d616c77617265
```
**Output in nim format with an array name of "shellcode"**
```bash
uv run main.py -i ./shellcode.bin -f nim -a shellcode
```
**Output to file**
```bash
uv run main.py -i ./shellcode.bin -f nim -o ./shellcode_out.nim
```
**Obfuscate via Config**
*config.yaml*
```yaml
chain:
  - type: compress
    method: lznt
  - type: encrypt
    method: aes_cbc
    key: "41414141414141414141414141414141"
    nonce: "41414141414141414141414141414141"
  - type: encode
    method: base64
```

```bash
uv run main.py -i ./shellcode.bin -f c -o config_obfuscation.c
```
**Get a list of compression methods**
```bash
uv run main.py --compressors
```
**Get a list of encoding methods**
```bash
uv run main.py --encoders
```
**Get a list of encryption methods**
```bash
uv run main.py --ciphers
```
**Get a list of output formats**
```bash
uv run main.py --formats
```

**Help**
```plaintext
   _____ __         ____                      __
  / ___// /_  ___  / / /___________  ______  / /_
  \__ \/ __ \/ _ \/ / / ___/ ___/ / / / __ \/ __/
 ___/ / / / /  __/ / / /__/ /  / /_/ / /_/ / /_
/____/_/ /_/\___/_/_/\___/_/   \__, / .___/\__/
                              /____/_/
v2.0 - Release

By: @0xLegacyy (Jordan Jay)

usage: shellcrypt [-h] -i INPUT [-e ENCRYPT] [--decrypt] [-d ENCODE] [-c COMPRESS] [-k KEY] [-n NONCE] [-f FORMAT] [--formats] [--ciphers] [--encoders] [--compressors] [-o OUTPUT] [-a ARRAY] [-v]
                  [--preserve-null] [--key-length KEY_LENGTH]

options:
  -h, --help            show this help message and exit
  -i INPUT, --input INPUT
                        Path to file to be encrypted.
  -e ENCRYPT, --encrypt ENCRYPT
                        Encryption method to use, default None.
  --decrypt             Enable decryption functionality (not yet implemented).
  -d ENCODE, --encode ENCODE
                        Encoding method to use, default None.
  -c COMPRESS, --compress COMPRESS
                        Compression method to use.
  -k KEY, --key KEY     Encryption key in hex format, default (random 16 bytes).
  -n NONCE, --nonce NONCE
                        Encryption nonce in hex format, default (random 16 bytes).
  -f FORMAT, --format FORMAT
                        Output format, specify --formats for a list of formats.
  --formats             Show a list of valid formats
  --ciphers             Show a list of valid ciphers
  --encoders            Show a list of valid encoders
  --compressors         Show a list of valid compressors
  -o OUTPUT, --output OUTPUT
                        Path to output file
  -a ARRAY, --array ARRAY
                        Array Name, default sh3llc0d3
  -v, --version         Shows the version and exits
  --preserve-null       Avoid XORing null bytes during XOR encryption.
  --key-length KEY_LENGTH
                        Specify the key length in bytes (default is 16).
```

## Future Development Goals

- [x] More output formats (rust etc.)
- [x] More encryption methods
- [x] Compression methods
- [x] Create a config system that allows for chaining encryption/encoding/compression methods
- [ ] Flag to add a decrypt method to the generated code
- [ ] [Shikata](https://github.com/EgeBalci/sgn) encoder mayhaps?

_**pssst** this is still heavily in development so if you'd like to contribute, have a go at working on one of the many `TODO`'s in the code :)_

```

`config.yaml.example`:

```example
# Specify the sequence of operations to apply to shellcode
# Supported types: encrypt, encode, compress

chain:
  - type: compress
    method: lznt
  - type: encrypt
    method: xor
    key: "41414141414141414141414141414141"
    nonce: "41414141414141414141414141414141"
  - type: encode
    method: base64

```

`main.py`:

```py
"""
~ @0xLegacyy (Jordan Jay)

Shellcrypt: Quality of Life Shellcode Obfuscation Tool

/ - Shellcrypt.py  : Main Program
/utils/
    - /crypters.py : Encryption, Encoding & Compression Toolkit
    - /winapi.py   : LZNT1 Compression WinAPI Helper
    - /logging.py  : Logging Helper
"""
import argparse
import logging
import pyfiglet

import yaml
from os.path import exists

from rich.console import Console
from rich.theme import Theme
from binascii import hexlify
from os import urandom
from os.path import isfile
from string import hexdigits

from utils.crypters import Encode, Encrypt, Compress, ShellcodeFormatter
from utils.logging import Log

theme = Theme({
    "success" : "spring_green3",
    "info" : "cornflower_blue",
    "error" : "red",
    "exception" : "red",
})
console = Console(theme=theme, color_system="auto")

# global vars
OUTPUT_FORMATS = [
    "c",
    "csharp",
    "nim",
    "go",
    "py",
    "ps1",
    "vba",
    "vbscript",
    "raw",
    "rust",
    "js",
    "zig"
]


CIPHERS = [
    "aes_128",
    "aes_ecb",
    "aes_cbc",
    "chacha20",
    "rc4",
    "salsa20",
    "xor",
    "xor_complex"
]

ENCODING = [
    "alpha32",
    "ascii85",
    "base64",
    "words256"
]

COMPRESSION = [
    "lznt",
    "rle",
]

VERSION = "v2.0 - Release"

def show_banner():
    banner = pyfiglet.figlet_format("Shellcrypt", font="slant", justify="left")
    console.print(f"[bold yellow]{banner}{VERSION}\n[/bold yellow]")
    console.print("By: @0xLegacyy (Jordan Jay)\n", style="green4")

def parse_args():
    # Parse arguments with additional features
    # TODO: Add decryption routines in the future

    argparser = argparse.ArgumentParser(prog="shellcrypt")

    # Required argument: Input file
    argparser.add_argument("-i", "--input", help="Path to file to be encrypted.", required=True)

    # Encryption related options
    argparser.add_argument("-e", "--encrypt", default=None, help="Encryption method to use, default None.")
    argparser.add_argument("--decrypt", action="store_true", help="Enable decryption functionality (not yet implemented).")

    # Encoding related options
    argparser.add_argument("-d", "--encode", default=None, help="Encoding method to use, default None.")

    # Compression related options
    argparser.add_argument("-c", "--compress", default=None, help="Compression method to use.")

    # Key and nonce options
    argparser.add_argument("-k", "--key", help="Encryption key in hex format, default (random 16 bytes).")
    argparser.add_argument("-n", "--nonce", help="Encryption nonce in hex format, default (random 16 bytes).")

    # Format related options
    argparser.add_argument("-f", "--format", help="Output format, specify --formats for a list of formats.")

    # Info-related arguments
    argparser.add_argument("--formats", action="store_true", help="Show a list of valid formats")
    argparser.add_argument("--ciphers", action="store_true", help="Show a list of valid ciphers")
    argparser.add_argument("--encoders", action="store_true", help="Show a list of valid encoders")
    argparser.add_argument("--compressors", action="store_true", help="Show a list of valid compressors")

    # Output file and version
    argparser.add_argument("-o", "--output", help="Path to output file")
    argparser.add_argument("-a", "--array", default="sh3llc0d3", help="Array Name, default sh3llc0d3")
    argparser.add_argument("-v", "--version", action="store_true", help="Shows the version and exits")

    # Additional Features
    # Preserve null bytes during XOR encryption
    argparser.add_argument("--preserve-null", action="store_true", help="Avoid XORing null bytes during XOR encryption.")

    # Specify key length (if greater than 16)
    argparser.add_argument("--key-length", type=int, default=16, help="Specify the key length in bytes (default is 16).")

    return argparser.parse_args()

def print_available_options(option_type, options, exit_on_print=True):
    print(f"The following {option_type} are available:")
    for option in options:
        print(f" - {option}")
    if exit_on_print:
        exit()

def validate_input_file(input_file):
    if input_file is None:
        Log.logError("""Must specify an input file e.g.
                     -i shellcode.bin (specify --help for more info)""")
        exit()
    if not isfile(input_file):
        Log.logError(f"Input file '{input_file}' does not exist.")
        exit()
    Log.logSuccess(f"Input file: '{input_file}'")

def validate_and_get_key(key, encrypt_type):
    if key is None:
        return urandom(32)

    if len(key) < 2 or len(key) % 2 == 1 or any(i not in hexdigits for i in key):
        Log.logError("Key must be valid byte(s) in hex format (e.g. 4141).")
        exit()

    if encrypt_type == "aes" and len(key) != 32:
        Log.logError("AES-128 key must be exactly 16 bytes long.")
        exit()

    return bytearray.fromhex(key)

def validate_and_get_nonce(nonce):
    if nonce is None:
        return urandom(16)

    if len(nonce) != 32 or any(i not in hexdigits for i in nonce):
        Log.logError("Nonce must be 16 valid bytes in hex format (e.g. 7468697369736d616c6963696f757321)")
        exit()

    return bytearray.fromhex(nonce)

def process_encoding(input_bytes, args, encoder):
    if args.encode:
        input_bytes = encoder.encode(args.encode, input_bytes)
    return input_bytes

def process_compression(input_bytes, args, compressor):
    if args.compress:
        input_bytes = compressor.compress(args.compress, input_bytes)
    return input_bytes

def process_encryption(input_bytes, args, cryptor, key, nonce):
    if args.encrypt:
        input_bytes = cryptor.encrypt(args.encrypt, input_bytes, key, nonce)
    return input_bytes

def main():
    try:
        # Show banner and parse arguments
        show_banner()
        args = parse_args()

        # --------- Config System ---------
        config_chain = None
        if exists("config.yaml"):
            with open("config.yaml", "r") as f:
                config = yaml.safe_load(f)
                config_chain = config.get("chain", None)

        # --------- Info-only arguments ---------
        if args.formats:
            print_available_options("formats", OUTPUT_FORMATS)
        if args.ciphers:
            print_available_options("ciphers", CIPHERS)
        if args.encoders:
            print_available_options("encoders", ENCODING)
        if args.compressors:
            print_available_options("compressors", COMPRESSION)
        if args.version:
            print(VERSION)
            exit()

        # --------- Argument Validation ---------
        Log.logDebug(msg="Validating arguments")

        validate_input_file(args.input)

        if args.format not in OUTPUT_FORMATS:
            Log.logError("""Invalid format specified, please specify a valid format e.g.
                         -f c (--formats gives a list of valid formats)""")
            exit()

        Log.logSuccess(f"Output format: {args.format}")

        if args.encrypt and args.encrypt not in CIPHERS:
            Log.logError("""Invalid cipher specified, please specify a valid cipher e.g.
                         -e xor (--ciphers gives a list of valid ciphers)""")
            exit()

        if args.encode and args.encode not in ENCODING:
            Log.logError("""Invalid encoder specified, please specify a valid encoder e.g.
                         -d ascii85 (--encoders gives a list of valid encoders)""")
            exit()

        if args.compress and args.compress not in COMPRESSION:
            Log.logError("""Invalid compression specified, please specify a valid compression e.g.
                         -c lznt (--compressors gives a list of valid compressors)""")
            exit()

        if args.compress != None:
            Log.logSuccess(f"Output Compression: {args.compress}")
        
        if args.encrypt != None:
            Log.logSuccess(f"Output Encryption: {args.encrypt}")
        else:
            Log.logInfo("No encryption found, defaulting to XOR")
        
        if args.encode != None:
            Log.logSuccess(f"Output Encoding: {args.encode}")

        key = validate_and_get_key(args.key, args.encrypt)
        Log.logSuccess(f"Using key: {hexlify(key).decode()}")

        nonce = validate_and_get_nonce(args.nonce)
        if args.encrypt == "aes":
            Log.logSuccess(f"Using nonce: {hexlify(nonce).decode()}")

        Log.logDebug("Arguments validated")

        # --------- Read Input File ---------
        with open(args.input, "rb") as input_handle:
            input_bytes = input_handle.read()

        # --------- Input File Processing ---------
        cryptor = Encrypt()
        compressor = Compress()
        encoder = Encode()

        # If config.yaml exists and chain is specified, use it
        if config_chain:
            for step in config_chain:
                step_type = step.get("type")
                method = step.get("method")
                if step_type == "compress":
                    Log.logSuccess(f"Output Compression: {method}")
                    input_bytes = compressor.compress(method, input_bytes)
                elif step_type == "encrypt":
                    Log.logSuccess(f"Output Encryption: {method}")
                    step_key = step.get("key")
                    step_nonce = step.get("nonce")
                    import re
                    def to_hex_str(val):
                        if val is None:
                            return None
                        if isinstance(val, int):
                            return format(val, 'x')
                        return str(val)
                    def validate_hex(val, expected_len, name):
                        if val is None:
                            return None
                        hex_str = to_hex_str(val)
                        if not re.fullmatch(r'[0-9a-fA-F]+', hex_str):
                            Log.logError(f"{name} in config.yaml must be a valid hex string.")
                            exit()
                        if len(hex_str) != expected_len:
                            Log.logError(f"{name} in config.yaml must be {expected_len} hex digits ({expected_len//2} bytes). Got {len(hex_str)}.")
                            exit()
                        return hex_str
                    use_key = bytearray.fromhex(validate_hex(step_key, 32, "key")) if step_key else key
                    use_nonce = bytearray.fromhex(validate_hex(step_nonce, 32, "nonce")) if step_nonce else nonce
                    input_bytes = cryptor.encrypt(method, input_bytes, use_key, use_nonce)
                elif step_type == "encode":
                    Log.logSuccess(f"Output Encoder: {method}")
                    input_bytes = encoder.encode(method, input_bytes)
                else:
                    Log.logError(f"Unknown step type in config: {step_type}")
                    exit()
        else:
            if args.compress:
                logging.info("Compressing Shellcode")
                input_bytes = process_compression(input_bytes, args, compressor)

            if args.encrypt:
                logging.info("Encrypting Shellcode")
                input_bytes = process_encryption(input_bytes, args, cryptor, key, nonce)

            if args.encode:
                logging.info("Encoding Shellcode")
                input_bytes = process_encoding(input_bytes, args, encoder)

        Log.logSuccess(f"Successfully processed input file ({len(input_bytes)} bytes)")
        Log.logInfo("Deobfuscation Routine: Decode -> Decrypt -> Decompress\n")

        # --------- Output Generation ---------
        arrays = {"key": key}
        if args.encrypt and args.encrypt in ["aes_128", "aes_ecb", "aes_cbc"]:
            arrays["nonce"] = nonce
        arrays[args.array] = input_bytes

        # Generate formatted output
        shellcode_formatter = ShellcodeFormatter()
        output = shellcode_formatter.generate(args.format, arrays)

        # --------- Output ---------
        if args.output is None:
            console.print(output.decode("latin1") if isinstance(output, bytearray) else output)
            exit()

        write_mode = "wb" if isinstance(output, bytearray) else "w"
        with open(args.output, write_mode) as file_handle:
            file_handle.write(output)

        Log.logSuccess(f"Output written to '{args.output}'")

    except Exception as e:
        Log.LogException(f"Exception Caught: {e}")

if __name__ == "__main__":
    main()

```

`pyproject.toml`:

```toml
[project]
name = "shellcrypt"
version = "2.0.0"
description = "A cross-platform quality of life tool to obfuscate a given shellcode file and output in a useful format for pasting directly into your source code."
readme = "README.md"
requires-python = ">=3.10"
dependencies = [
    "argparse==1.4.0",
    "lznt1==0.2",
    "markdown-it-py==4.0.0",
    "mdurl==0.1.2",
    "pycryptodome==3.23.0",
    "pyfiglet==1.0.4",
    "pygments==2.19.2",
    "rich==14.3.2",
    "pyyaml==6.0.3",
]

[tool.setuptools.packages.find]
include = ["utils", "tests"]
exclude = ["logs", "assets"]

```

`requirements.txt`:

```txt
rich
pycryptodome
argparse
pyfiglet
lznt1
```

`shellcrypt.py`:

```py
"""
~ @0xLegacyy (Jordan Jay)

Shellcrypt: Quality of Life Shellcode Obfuscation Tool

/ - Shellcrypt.py  : Main Program
/utils/
    - /crypters.py : Encryption, Encoding & Compression Toolkit
    - /logging.py  : Logging Helper
"""
import argparse
import logging
import pyfiglet

from rich.console import Console
from rich.theme import Theme
from binascii import hexlify
from os import urandom
from os.path import isfile
from string import hexdigits

from utils.crypters import Encode, Encrypt, Compress, ShellcodeFormatter
from utils.logging import Log

theme = Theme({
    "success" : "spring_green3",
    "info" : "cornflower_blue",
    "error" : "red",
    "exception" : "red",
})
console = Console(theme=theme, color_system="auto")

# global vars
OUTPUT_FORMATS = [
    "c",
    "csharp",
    "nim",
    "go",
    "py",
    "ps1",
    "vba",
    "vbscript",
    "raw",
    "rust",
    "js",
    "zig"
]


CIPHERS = [
    "aes_128",
    "aes_ecb",
    "aes_cbc",
    "chacha20",
    "rc4",
    "salsa20",
    "xor",
    "xor_complex"
]

ENCODING = [
    "alpha32",
    "ascii85",
    "base64",
    "words256"
]

COMPRESSION = [
    "lznt",
    "rle",
]

VERSION = "v2.0 - Release"

def show_banner():
    banner = pyfiglet.figlet_format("Shellcrypt", font="slant", justify="left")
    console.print(f"[bold yellow]{banner}{VERSION}\n[/bold yellow]")
    console.print("By: @0xLegacyy (Jordan Jay)\n", style="green4")

def parse_args():
    # Parse arguments with additional features
    # TODO: Add decryption routines in the future

    argparser = argparse.ArgumentParser(prog="shellcrypt")

    # Required argument: Input file
    argparser.add_argument("-i", "--input", help="Path to file to be encrypted.", required=True)

    # Encryption related options
    argparser.add_argument("-e", "--encrypt", default=None, help="Encryption method to use, default None.")
    argparser.add_argument("--decrypt", action="store_true", help="Enable decryption functionality (not yet implemented).")

    # Encoding related options
    argparser.add_argument("-d", "--encode", default=None, help="Encoding method to use, default None.")

    # Compression related options
    argparser.add_argument("-c", "--compress", default=None, help="Compression method to use.")

    # Key and nonce options
    argparser.add_argument("-k", "--key", help="Encryption key in hex format, default (random 16 bytes).")
    argparser.add_argument("-n", "--nonce", help="Encryption nonce in hex format, default (random 16 bytes).")

    # Format related options
    argparser.add_argument("-f", "--format", help="Output format, specify --formats for a list of formats.")

    # Info-related arguments
    argparser.add_argument("--formats", action="store_true", help="Show a list of valid formats")
    argparser.add_argument("--ciphers", action="store_true", help="Show a list of valid ciphers")
    argparser.add_argument("--encoders", action="store_true", help="Show a list of valid encoders")
    argparser.add_argument("--compressors", action="store_true", help="Show a list of valid compressors")

    # Output file and version
    argparser.add_argument("-o", "--output", help="Path to output file")
    argparser.add_argument("-a", "--array", default="sh3llc0d3", help="Array Name, default sh3llc0d3")
    argparser.add_argument("-v", "--version", action="store_true", help="Shows the version and exits")

    # Additional Features
    # Preserve null bytes during XOR encryption
    argparser.add_argument("--preserve-null", action="store_true", help="Avoid XORing null bytes during XOR encryption.")

    # Specify key length (if greater than 16)
    argparser.add_argument("--key-length", type=int, default=16, help="Specify the key length in bytes (default is 16).")

    return argparser.parse_args()

def print_available_options(option_type, options, exit_on_print=True):
    print(f"The following {option_type} are available:")
    for option in options:
        print(f" - {option}")
    if exit_on_print:
        exit()

def validate_input_file(input_file):
    if input_file is None:
        Log.logError("""Must specify an input file e.g.
                     -i shellcode.bin (specify --help for more info)""")
        exit()
    if not isfile(input_file):
        Log.logError(f"Input file '{input_file}' does not exist.")
        exit()
    Log.logSuccess(f"Input file: '{input_file}'")

def validate_and_get_key(key, encrypt_type):
    if key is None:
        return urandom(32)

    if len(key) < 2 or len(key) % 2 == 1 or any(i not in hexdigits for i in key):
        Log.logError("Key must be valid byte(s) in hex format (e.g. 4141).")
        exit()

    if encrypt_type == "aes" and len(key) != 32:
        Log.logError("AES-128 key must be exactly 16 bytes long.")
        exit()

    return bytearray.fromhex(key)

def validate_and_get_nonce(nonce):
    if nonce is None:
        return urandom(16)

    if len(nonce) != 32 or any(i not in hexdigits for i in nonce):
        Log.logError("Nonce must be 16 valid bytes in hex format (e.g. 7468697369736d616c6963696f757321)")
        exit()

    return bytearray.fromhex(nonce)

def process_encoding(input_bytes, args, encoder):
    if args.encode:
        input_bytes = encoder.encode(args.encode, input_bytes)
    return input_bytes

def process_compression(input_bytes, args, compressor):
    if args.compress:
        input_bytes = compressor.compress(args.compress, input_bytes)
    return input_bytes

def process_encryption(input_bytes, args, cryptor, key, nonce):
    if args.encrypt:
        input_bytes = cryptor.encrypt(args.encrypt, input_bytes, key, nonce)
    return input_bytes

def main():
    try:
        # Show banner and parse arguments
        show_banner()
        args = parse_args()

        # --------- Info-only arguments ---------
        if args.formats:
            print_available_options("formats", OUTPUT_FORMATS)
        if args.ciphers:
            print_available_options("ciphers", CIPHERS)
        if args.encoders:
            print_available_options("encoders", ENCODING)
        if args.compressors:
            print_available_options("compressors", COMPRESSION)
        if args.version:
            print(VERSION)
            exit()

        # --------- Argument Validation ---------
        Log.logDebug(msg="Validating arguments")

        validate_input_file(args.input)

        if args.format not in OUTPUT_FORMATS:
            Log.logError("""Invalid format specified, please specify a valid format e.g.
                         -f c (--formats gives a list of valid formats)""")
            exit()

        Log.logSuccess(f"Output format: {args.format}")

        if args.encrypt and args.encrypt not in CIPHERS:
            Log.logError("""Invalid cipher specified, please specify a valid cipher e.g.
                         -e xor (--ciphers gives a list of valid ciphers)""")
            exit()

        if args.encode and args.encode not in ENCODING:
            Log.logError("""Invalid encoder specified, please specify a valid encoder e.g.
                         -d ascii85 (--encoders gives a list of valid encoders)""")
            exit()

        if args.compress and args.compress not in COMPRESSION:
            Log.logError("""Invalid compression specified, please specify a valid compression e.g.
                         -c lznt (--compressors gives a list of valid compressors)""")
            exit()

        Log.logSuccess(f"Output Compression: {args.compress}")
        Log.logSuccess(f"Output Encryption: {args.encrypt}")
        Log.logSuccess(f"Output Encoding: {args.encode}")

        key = validate_and_get_key(args.key, args.encrypt)
        Log.logSuccess(f"Using key: {hexlify(key).decode()}")

        nonce = validate_and_get_nonce(args.nonce)
        if args.encrypt == "aes":
            Log.logSuccess(f"Using nonce: {hexlify(nonce).decode()}")

        Log.logDebug("Arguments validated")

        # --------- Read Input File ---------
        with open(args.input, "rb") as input_handle:
            input_bytes = input_handle.read()

        # --------- Input File Processing ---------
        cryptor = Encrypt()
        compressor = Compress()
        encoder = Encode()

        if args.compress:
            logging.info("Compressing Shellcode")
            input_bytes = process_compression(input_bytes, args, compressor)

        if args.encrypt:
            logging.info("Encrypting Shellcode")
            input_bytes = process_encryption(input_bytes, args, cryptor, key, nonce)

        if args.encode:
            logging.info("Encoding Shellcode")
            input_bytes = process_encoding(input_bytes, args, encoder)

        Log.logSuccess(f"Successfully processed input file ({len(input_bytes)} bytes)")
        Log.logInfo("Deobfuscation Routine: Decode -> Decrypt -> Decompress\n")

        # --------- Output Generation ---------
        arrays = {"key": key}
        if args.encrypt and args.encrypt in ["aes_128", "aes_ecb", "aes_cbc"]:
            arrays["nonce"] = nonce
        arrays[args.array] = input_bytes

        # Generate formatted output
        shellcode_formatter = ShellcodeFormatter()
        output = shellcode_formatter.generate(args.format, arrays)

        # --------- Output ---------
        if args.output is None:
            console.print(output.decode("latin1") if isinstance(output, bytearray) else output)
            exit()

        write_mode = "wb" if isinstance(output, bytearray) else "w"
        with open(args.output, write_mode) as file_handle:
            file_handle.write(output)

        Log.logSuccess(f"Output written to '{args.output}'")

    except Exception as e:
        Log.LogException(f"Exception Caught: {e}")

if __name__ == "__main__":
    main()

```

`tests/test_shellcode.bin`:

```bin
AAAAAAAAAAAAAAAA
```

`tests/test_shellcrypt.py`:

```py
"""
Comprehensive test suite for Shellcrypt
Tests all encryption, encoding, compression, and output format options.
"""
import subprocess
import sys
import os
import tempfile

# Ensure we can import from parent directory
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from utils.crypters import Encrypt, Encode, Compress, ShellcodeFormatter

# Test data
TEST_SHELLCODE = bytearray(b'\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50')

# Configuration
OUTPUT_FORMATS = ["c", "csharp", "nim", "go", "py", "ps1", "vba", "vbscript", "raw", "rust", "js", "zig"]
CIPHERS = ["aes_128", "aes_ecb", "aes_cbc", "chacha20", "rc4", "salsa20", "xor", "xor_complex"]
ENCODINGS = ["alpha32", "ascii85", "base64", "words256"]
COMPRESSIONS = ["lznt", "rle"]


class TestResults:
    def __init__(self):
        self.passed = 0
        self.failed = 0
        self.failures = []

    def add_pass(self, test_name):
        self.passed += 1
        print(f"  [PASS] {test_name}")

    def add_fail(self, test_name, error):
        self.failed += 1
        self.failures.append((test_name, str(error)))
        print(f"  [FAIL] {test_name}: {error}")

    def summary(self):
        print("\n" + "=" * 60)
        print(f"SUMMARY: {self.passed} passed, {self.failed} failed")
        if self.failures:
            print("\nFailed tests:")
            for name, error in self.failures:
                print(f"  - {name}: {error}")
        print("=" * 60)
        return self.failed == 0


def test_single_byte_key_formatting():
    """Test that single-byte keys are formatted correctly (Issue: x00 instead of 0x00)"""
    print("\n[TEST] Single-byte key formatting")
    results = TestResults()

    formatter = ShellcodeFormatter()

    # Test with single byte key 0x00
    arrays = {"key": bytearray([0x00]), "shellcode": TEST_SHELLCODE}
    output = formatter.generate("c", arrays)

    if "x00" in output and "0x00" not in output:
        results.add_fail("Single byte 0x00", "Got 'x00' instead of '0x00'")
    elif "0x00" in output:
        results.add_pass("Single byte 0x00")
    else:
        results.add_fail("Single byte 0x00", f"Unexpected output format")

    # Test with single byte key 0xFF
    arrays = {"key": bytearray([0xFF]), "shellcode": TEST_SHELLCODE}
    output = formatter.generate("c", arrays)

    if "xff" in output and "0xff" not in output:
        results.add_fail("Single byte 0xFF", "Got 'xff' instead of '0xff'")
    elif "0xff" in output:
        results.add_pass("Single byte 0xFF")
    else:
        results.add_fail("Single byte 0xFF", f"Unexpected output format")

    # Test with single byte key 0x41
    arrays = {"key": bytearray([0x41]), "shellcode": TEST_SHELLCODE}
    output = formatter.generate("c", arrays)

    if "x41" in output and "0x41" not in output:
        results.add_fail("Single byte 0x41", "Got 'x41' instead of '0x41'")
    elif "0x41" in output:
        results.add_pass("Single byte 0x41")
    else:
        results.add_fail("Single byte 0x41", f"Unexpected output format")

    return results


def test_output_formats():
    """Test all output format generations"""
    print("\n[TEST] Output formats")
    results = TestResults()

    formatter = ShellcodeFormatter()
    # Use "sh3llc0d3" as that's the default array name for raw format
    arrays = {"key": bytearray([0x41, 0x42]), "sh3llc0d3": TEST_SHELLCODE, "shellcode": TEST_SHELLCODE}

    for fmt in OUTPUT_FORMATS:
        try:
            output = formatter.generate(fmt, arrays)
            if output is not None and (len(output) > 0 if isinstance(output, (str, bytearray)) else True):
                results.add_pass(f"Format: {fmt}")
            else:
                results.add_fail(f"Format: {fmt}", "Empty output")
        except Exception as e:
            results.add_fail(f"Format: {fmt}", str(e))

    return results


def test_encryption_methods():
    """Test all encryption methods"""
    print("\n[TEST] Encryption methods")
    results = TestResults()

    cryptor = Encrypt()
    key_16 = bytearray([0x41] * 16)
    key_32 = bytearray([0x41] * 32)
    nonce = bytearray([0x42] * 16)

    for cipher in CIPHERS:
        try:
            # AES ciphers need 16-byte key, others can use 32-byte key
            key = key_16 if "aes" in cipher else key_32
            encrypted = cryptor.encrypt(cipher, TEST_SHELLCODE.copy(), key, nonce)
            if encrypted is not None and len(encrypted) > 0:
                # Verify encryption changed the data (except for xor with null key)
                if encrypted != TEST_SHELLCODE:
                    results.add_pass(f"Cipher: {cipher}")
                else:
                    results.add_fail(f"Cipher: {cipher}", "Encryption produced same output")
            else:
                results.add_fail(f"Cipher: {cipher}", "Empty output")
        except Exception as e:
            results.add_fail(f"Cipher: {cipher}", str(e))

    return results


def test_xor_with_null_key():
    """Test XOR encryption with null key (0x00)"""
    print("\n[TEST] XOR with null key")
    results = TestResults()

    cryptor = Encrypt()
    null_key = bytearray([0x00])
    nonce = bytearray([0x42] * 16)

    try:
        encrypted = cryptor.encrypt("xor", TEST_SHELLCODE.copy(), null_key, nonce)
        # XOR with 0x00 should produce the same output
        if encrypted == TEST_SHELLCODE:
            results.add_pass("XOR with 0x00 key (identity)")
        else:
            results.add_fail("XOR with 0x00 key", "Expected identity transformation")
    except Exception as e:
        results.add_fail("XOR with 0x00 key", str(e))

    return results


def test_encoding_methods():
    """Test all encoding methods"""
    print("\n[TEST] Encoding methods")
    results = TestResults()

    encoder = Encode()

    for encoding in ENCODINGS:
        try:
            encoded = encoder.encode(encoding, TEST_SHELLCODE.copy())
            if encoded is not None and len(encoded) > 0:
                # words256 and alpha32 use modulo, so they're lossy encodings
                # Only test full round-trip for lossless encodings
                if encoding in ["base64", "ascii85"]:
                    decoded = encoder.decode(encoding, encoded)
                    if decoded == TEST_SHELLCODE:
                        results.add_pass(f"Encoding: {encoding} (encode/decode)")
                    else:
                        results.add_fail(f"Encoding: {encoding}", "Decode mismatch")
                else:
                    # For lossy encodings (alpha32, words256), just verify encode works
                    results.add_pass(f"Encoding: {encoding} (encode only - lossy)")
            else:
                results.add_fail(f"Encoding: {encoding}", "Empty output")
        except Exception as e:
            results.add_fail(f"Encoding: {encoding}", str(e))

    return results


def test_compression_methods():
    """Test all compression methods"""
    print("\n[TEST] Compression methods")
    results = TestResults()

    compressor = Compress()

    for compression in COMPRESSIONS:
        try:
            compressed = compressor.compress(compression, TEST_SHELLCODE.copy())
            if compressed is not None and len(compressed) > 0:
                # Test decompress as well
                decompressed = compressor.decompress(compression, compressed)
                if bytearray(decompressed) == TEST_SHELLCODE:
                    results.add_pass(f"Compression: {compression} (compress/decompress)")
                else:
                    results.add_fail(f"Compression: {compression}", "Decompress mismatch")
            else:
                results.add_fail(f"Compression: {compression}", "Empty output")
        except Exception as e:
            results.add_fail(f"Compression: {compression}", str(e))

    return results


def test_cli_integration():
    """Test CLI integration with the fixed key issue"""
    print("\n[TEST] CLI integration")
    results = TestResults()

    # Get the path to shellcrypt.py
    script_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    shellcrypt_path = os.path.join(script_dir, "shellcrypt.py")
    test_bin = os.path.join(script_dir, "tests", "test_shellcode.bin")

    # Create test input file if it doesn't exist
    if not os.path.exists(test_bin):
        with open(test_bin, "wb") as f:
            f.write(TEST_SHELLCODE)

    # Test 1: XOR with single byte key 00
    try:
        result = subprocess.run(
            [sys.executable, shellcrypt_path, "-i", test_bin, "-e", "xor", "-k", "00", "-f", "c", "-a", "shellcode"],
            capture_output=True,
            text=True,
            timeout=30
        )
        output = result.stdout + result.stderr

        # Check for the bug: x00 without the leading 0
        if "key[1] = {" in output:
            # Find key line and check format
            lines = output.split('\n')
            key_found = False
            for i, line in enumerate(lines):
                if "key[1]" in line:
                    # Check the next line for the actual key value
                    if i + 1 < len(lines):
                        key_line = lines[i + 1].strip()
                        if key_line == "x00" or key_line == "x00,":
                            results.add_fail("CLI XOR key=00", f"Got '{key_line}' instead of '0x00'")
                        elif "0x00" in key_line:
                            results.add_pass("CLI XOR key=00")
                        else:
                            results.add_fail("CLI XOR key=00", f"Unexpected key format: '{key_line}'")
                        key_found = True
                        break
            if not key_found:
                results.add_fail("CLI XOR key=00", "Could not find key in output")
        else:
            results.add_fail("CLI XOR key=00", "Unexpected output format")
    except subprocess.TimeoutExpired:
        results.add_fail("CLI XOR key=00", "Timeout")
    except Exception as e:
        results.add_fail("CLI XOR key=00", str(e))

    # Test 2: Multiple output formats via CLI
    for fmt in ["c", "py", "raw"]:
        try:
            result = subprocess.run(
                [sys.executable, shellcrypt_path, "-i", test_bin, "-e", "xor", "-k", "4141", "-f", fmt, "-a", "test"],
                capture_output=True,
                text=True,
                timeout=30
            )
            if result.returncode == 0 or "Shellcrypt" in result.stdout:
                results.add_pass(f"CLI format: {fmt}")
            else:
                results.add_fail(f"CLI format: {fmt}", f"Exit code: {result.returncode}")
        except Exception as e:
            results.add_fail(f"CLI format: {fmt}", str(e))

    return results


def test_multi_byte_key():
    """Test that multi-byte keys still work correctly after the fix"""
    print("\n[TEST] Multi-byte key formatting")
    results = TestResults()

    formatter = ShellcodeFormatter()

    # Test with 2-byte key
    arrays = {"key": bytearray([0x41, 0x42]), "shellcode": TEST_SHELLCODE}
    output = formatter.generate("c", arrays)

    if "0x41,0x42" in output or ("0x41" in output and "0x42" in output):
        results.add_pass("2-byte key (0x41, 0x42)")
    else:
        results.add_fail("2-byte key", f"Unexpected format in output")

    # Test with 16-byte key
    key_16 = bytearray([i for i in range(16)])
    arrays = {"key": key_16, "shellcode": TEST_SHELLCODE}
    output = formatter.generate("c", arrays)

    if "0x00" in output and "0x0f" in output:
        results.add_pass("16-byte key")
    else:
        results.add_fail("16-byte key", "Missing expected bytes in output")

    return results


def test_string_format_single_byte():
    """Test string format output with single byte (Python format uses \\x)"""
    print("\n[TEST] String format single-byte")
    results = TestResults()

    formatter = ShellcodeFormatter()

    # Test Python format with single byte key
    arrays = {"key": bytearray([0x00]), "shellcode": TEST_SHELLCODE}
    output = formatter.generate("py", arrays)

    # Python format should have \x00, not just x00
    if "key = b\"\"\"" in output:
        # Check if \\x00 is properly formatted
        if "\\x00" in output:
            results.add_pass("Python format single byte key")
        elif "x00" in output and "\\x00" not in output:
            results.add_fail("Python format single byte key", "Got 'x00' instead of '\\x00'")
        else:
            results.add_fail("Python format single byte key", "Unexpected format")
    else:
        results.add_pass("Python format single byte key (alternate format)")

    return results


def run_all_tests():
    """Run all tests and report results"""
    all_results = []

    # Run all test categories
    all_results.append(test_single_byte_key_formatting())
    all_results.append(test_multi_byte_key())
    all_results.append(test_string_format_single_byte())
    all_results.append(test_output_formats())
    all_results.append(test_encryption_methods())
    all_results.append(test_xor_with_null_key())
    all_results.append(test_encoding_methods())
    all_results.append(test_compression_methods())
    all_results.append(test_cli_integration())

    # Calculate totals
    total_passed = sum(r.passed for r in all_results)
    total_failed = sum(r.failed for r in all_results)
    all_failures = []
    for r in all_results:
        all_failures.extend(r.failures)

    print("\n" + "=" * 60)
    print(f"FINAL RESULTS: {total_passed} passed, {total_failed} failed")
    if all_failures:
        print("\nAll failures:")
        for name, error in all_failures:
            print(f"  - {name}: {error}")
    print("=" * 60)

    return total_failed == 0


if __name__ == "__main__":
    success = run_all_tests()
    sys.exit(0 if success else 1)

```

`utils/crypters.py`:

```py
import base64
import random
import lznt1

from os import urandom
from Crypto.Cipher import AES, ARC4, ChaCha20, Salsa20
from Crypto.Util.Padding import pad
from Crypto.Random import get_random_bytes

from itertools import cycle


class ShellcodeFormatter:
    """Generates shellcode output in various formats."""
    def __init__(self):
        self.__format_handlers = {
            "c": self.__output_c,
            "csharp": self.__output_csharp,
            "nim": self.__output_nim,
            "go": self.__output_go,
            "py": self.__output_py,
            "ps1": self.__output_ps1,
            "vba": self.__output_vba,
            "vbscript": self.__output_vbscript,
            "raw": self.__output_raw,
            "rust": self.__output_rust,
            "js": self.__output_js,
            "zig": self.__output_zig
        }

    def __generate_array_contents(self, input_bytes: bytearray, string_format=False) -> str:
        """Generates formatted shellcode from bytearray."""
        output = ""
        if not string_format:
            for i in range(len(input_bytes) - 1):
                if i % 15 == 0:
                    output += "\n\t"
                output += f"0x{input_bytes[i]:0>2x},"
            output += f"0x{input_bytes[-1]:0>2x}"
            # Only strip the leading newline if one was added
            return output.lstrip("\n")
        else:
            for i in range(len(input_bytes) - 1):
                if i % 15 == 0:
                    output += "\n"
                output += f"\\x{input_bytes[i]:0>2x}"
            output += f"\\x{input_bytes[-1]:0>2x}"
            return output.lstrip("\n")

    def __output_format(self, arrays: dict, template: str, array_format="unsigned char") -> str:
        """Generate shellcode in specified format."""
        output = ""
        for array_name, array in arrays.items():
            output += f"{array_format} {array_name}[{len(array)}] = {{\n"
            output += self.__generate_array_contents(array)
            output += "\n};\n\n"
        return output

    def __output_c(self, arrays: dict) -> str:
        return self.__output_format(arrays, "c")

    def __output_rust(self, arrays: dict) -> str:
        return self.__output_format(arrays, "rust", array_format="let")

    def __output_csharp(self, arrays: dict) -> str:
        return self.__output_format(arrays, "csharp", array_format="byte[]")

    def __output_nim(self, arrays: dict) -> str:
        output = ""
        for array_name, array in arrays.items():
            output += f"var {array_name}: array[{len(array)}, byte] = [\n"
            output += "\tbyte " + self.__generate_array_contents(array)[1:]
            output += "\n]\n\n"
        return output

    def __output_go(self, arrays: dict) -> str:
        return self.__output_format(arrays, "go", array_format="[]byte")

    def __output_py(self, arrays: dict) -> str:
        output = ""
        for array_name, array in arrays.items():
            output += f"{array_name} = b\"\"\""
            output += self.__generate_array_contents(array, string_format=True)
            output += "\"\"\"\n\n"
        return output

    def __output_ps1(self, arrays: dict) -> str:
        output = ""
        for array_name, array in arrays.items():
            output += f"[Byte[]] ${array_name} = "
            output += self.__generate_array_contents(array)[1:]
            output += "\n\n"
        return output

    def __output_vba(self, arrays: dict) -> str:
        output = ""
        for array_name, array in arrays.items():
            output += f"{array_name} = Array("
            line_length = len(output)
            for _, x in enumerate(array):
                if line_length + 5 > 1022:
                    output += "_\n"
                    line_length = 0
                output += f"{x},"
                line_length += len(f"{x},")
            if line_length + 4 > 1023:
                output += "_\n"
            output += f"{x})\n\n"
        return output

    def __output_vbscript(self, arrays: dict) -> str:
        output = ""
        for array_name, array in arrays.items():
            output += f"{array_name}="
            output += "".join([f"Chr({str(c)})&" for c in array])[:-1]
            output += "\n\n"
        return output

    def __output_js(self, arrays: dict) -> str:
        """JavaScript output."""
        output = ""
        for array_name, array in arrays.items():
            output += f"const {array_name} = new Uint8Array({len(array)}); \n"
            output += f"{array_name}.set(["
            output += self.__generate_array_contents(array)
            output += "]);\n\n"
        return output

    def __output_zig(self, arrays: dict) -> str:
        """Zig output."""
        output = ""
        for array_name, array in arrays.items():
            output += f"var {array_name} = []u8{{\n"
            output += self.__generate_array_contents(array)
            output += "\n};\n\n"
        return output

    def __output_raw(self, arrays: dict) -> str:
        return arrays["sh3llc0d3"]

    def generate(self, output_format: str, arrays: dict) -> str:
        """Generates the formatted shellcode based on the output format."""
        handler = self.__format_handlers.get(output_format)
        if handler is None:
            raise ValueError(f"Unsupported output format: {output_format}. Valid formats: {', '.join(self.__format_handlers.keys())}")
        return handler(arrays)


class Encrypt:
    """ Consolidates encryption into a single class. """
    def __init__(self):
        super(Encrypt, self).__init__()
        self.__encryption_handlers = {
            "xor":         self.__xor,
            "xor_complex": self.__xor_complex,
            "aes_128":     self.__aes_128,
            "aes_ecb":     self.__aes_ecb,
            "aes_cbc":     self.__aes_cbc,
            "rc4":         self.__rc4,
            "chacha20":    self.__chacha20,
            "salsa20":     self.__salsa20
        }
        return

    def __random_key(self) -> int:
        self.seed = random.randint(0, 2**32 - 1)

        LCG_A = 1664525  # Multiplier
        LCG_C = 1013904223  # Increment
        LCG_M = 2**32  # Modulus (2^32)

        self.seed = (LCG_A * self.seed + LCG_C) % LCG_M
        return self.seed & 0xFF

    def encrypt(self, cipher:str, plaintext:bytearray, key:bytearray, nonce:bytearray) -> bytearray:
        """ Encrypts plaintext with the user-specified cipher.
            This has been written this way to support chaining of
            multiple encryption methods in the future.
        :param cipher: cipher to use, e.g. 'xor'/'aes'
        :param plaintext: bytearray containing our plaintext
        :param key: bytearray containing our encryption key
        :param nonce: bytearray containing nonce for aes etc.
                      if none will be generated on the fly
        :return ciphertext: bytearray containing encrypted plaintext
        """
        # If nonce not specified, generate one, otherwise use the specified one.
        self.nonce = urandom(16) if nonce is None else nonce
        self.key = key
        # cipher is already validated (check argument validation section).
        return self.__encryption_handlers[cipher](plaintext)

    def __xor(self, plaintext:bytearray) -> bytearray:
        """ Private method to encrypt the input plaintext with a repeating XOR key.
        :param plaintext: bytearray containing our plaintext
        :return ciphertext: bytearray containing encrypted plaintext
        """
        return bytearray(a ^ b for (a, b) in zip(plaintext, cycle(self.key)))

    def __xor_complex(self, plaintext: bytearray) -> bytearray:
        """
        XOR Encrypts/Decrypts given shellcode using a Linear Congruential Generator (LCG)
        """
        encrypted_shellcode = bytearray()
        for byte in plaintext:
            random_key = self.__random_key()
            encrypted_shellcode.append(byte ^ random_key)

        return encrypted_shellcode

    def __aes_128(self, plaintext:bytearray) -> bytearray:
        """ Private method to encrypt the input plaintext with AES-128 in CBC mode.
        :param plaintext: bytearray containing plaintext
        :return ciphertext: bytearray containing encrypted plaintext
        """
        aes_cipher = AES.new(self.key, AES.MODE_CBC, self.nonce)
        plaintext = bytearray(pad(plaintext, 16))
        return bytearray(aes_cipher.encrypt(plaintext))

    def __rc4(self, plaintext:bytearray) -> bytearray:
        """ Private method to encrypt the input plaintext via RC4.
        :param plaintext: bytearray containing plaintext
        :return ciphertext: bytearray containing encrypted plaintext
        """
        rc4_cipher = ARC4.new(self.key)
        return bytearray(rc4_cipher.encrypt(plaintext))

    def __chacha20(self, plaintext:bytearray) -> bytearray:
        """ Private method to encrypt the input plaintext via ChaCha20.
        :param plaintext: bytearray containing plaintext
        :return ciphertext: bytearray containing encrypted plaintext
        """
        chacha20_cipher = ChaCha20.new(key=self.key)
        return bytearray(chacha20_cipher.encrypt(plaintext))

    def __salsa20(self, plaintext:bytearray) -> bytearray:
        """ Private method to encrypt the input plaintext via Salsa20.
        :param plaintext: bytearray containing plaintext
        :return ciphertext: bytearray containing encrypted plaintext
        """
        salsa20_cipher = Salsa20.new(key=self.key)
        return bytearray(salsa20_cipher.encrypt(plaintext))

    def __aes_ecb(self, plaintext:bytearray) -> bytearray:
        cipher = AES.new(self.key, AES.MODE_ECB)
        padding_length = 16 - len(plaintext) % 16
        padded_shellcode = plaintext + bytearray([padding_length] * padding_length)
        return bytearray(cipher.encrypt(padded_shellcode))

    def __aes_cbc(self, plaintext:bytearray) -> bytearray:
        iv = get_random_bytes(16)
        cipher = AES.new(self.key, AES.MODE_CBC, iv)

        padding_length = 16 - len(plaintext) % 16
        padded_shellcode = plaintext + bytearray([padding_length] * padding_length)

        encrypted_shellcode = cipher.encrypt(padded_shellcode)
        return bytearray(iv) + bytearray(encrypted_shellcode)


class Compress:
    def __init__(self):
        self.__compression_handlers = {
            "lznt": self.__lznt_compress,
            "rle":  self.__rle_compress
        }
        self.__decompression_handlers = {
            "lznt": self.__lznt_decompress,
            "rle":  self.__rle_decompress
        }

    def compress(self, method: str, data: bytes) -> bytes:
        handler = self.__compression_handlers.get(method)
        if handler:
            return handler(data)
        raise ValueError(f"Unsupported compression method: {method}")

    def decompress(self, method: str, data: bytes) -> bytes:
        handler = self.__decompression_handlers.get(method)
        if handler:
            return handler(data)
        raise ValueError(f"Unsupported decompression method: {method}")

    def __lznt_compress(self, data: bytes) -> bytes:
        """LZNT compression via RtlCompressBuffer (LZNT1 + MAXIMUM engine)."""
        return bytearray(lznt1.compress(data))

    def __lznt_decompress(self, data: bytes) -> bytes:
        """LZNT decompression via RtlDecompressBuffer."""
        return bytearray(lznt1.decompress(data))

    def __rle_compress(self, data: bytearray) -> bytearray:
        compressed = bytearray()
        index = 0
        while index < len(data):
            byte = data[index]
            count = 1
            while index + 1 < len(data) and data[index + 1] == byte:
                count += 1
                index += 1
            compressed.extend([byte, count])
            index += 1
        return compressed

    def __rle_decompress(self, data: bytearray) -> bytearray:
        decompressed = bytearray()
        for i in range(0, len(data), 2):
            byte, count = data[i], data[i + 1]
            decompressed.extend([byte] * count)
        return decompressed


class Encode:
    def __init__(self):
        self.__encoding_handlers = {
            "base64": self.__base64_encode,
            "ascii85": self.__ascii85_encode,
            "alpha32": self.__alpha32_encode,
            "words256": self.__words256_encode
        }
        self.__decoding_handlers = {
            "base64": self.__base64_decode,
            "ascii85": self.__ascii85_decode,
            "alpha32": self.__alpha32_decode,
            "words256": self.__words256_decode
        }

    def encode(self, encoding: str, data: bytearray) -> bytearray:
        """Encode data using specified encoding."""
        handler = self.__encoding_handlers.get(encoding)
        if handler:
            return handler(data)
        raise ValueError(f"Unsupported encoding: {encoding}")

    def decode(self, decoding: str, data: bytearray) -> bytearray:
        """Decode data using specified decoding."""
        handler = self.__decoding_handlers.get(decoding)
        if handler:
            return handler(data)
        raise ValueError(f"Unsupported decoding: {decoding}")

    def __base64_encode(self, data: bytearray) -> bytearray:
        """Base64 encoding."""
        return bytearray(base64.b64encode(data))

    def __base64_decode(self, data: bytearray) -> bytearray:
        """Base64 decoding."""
        return bytearray(base64.b64decode(data))

    def __ascii85_encode(self, data: bytearray) -> bytearray:
        """ASCII85 encoding."""
        return bytearray(base64.a85encode(data))

    def __ascii85_decode(self, data: bytearray) -> bytearray:
        """ASCII85 decoding."""
        return bytearray(base64.a85decode(data))

    def __alpha32_encode(self, data: bytearray) -> bytearray:
        alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz!#$%&'()*+,-./:;<=>?@[]^_`{|}~"
        encoded = bytearray()
        for byte in data:
            encoded.extend(alphabet[byte % len(alphabet)].encode())
        return encoded

    def __alpha32_decode(self, data: bytearray) -> bytearray:
        alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz!#$%&'()*+,-./:;<=>?@[]^_`{|}~"
        decoded = bytearray()
        for char in data:
            decoded.append(alphabet.index(chr(char)))
        return decoded

    def __words256_encode(self, data: bytearray) -> bytearray:
        words = ["Alpha", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot",
                "Golf", "Hotel", "India", "Juliet", "Kilo", "Lima", "Mike",
                "November", "Oscar", "Papa", "Quebec", "Romeo", "Sierra", "Tango",
                "Uniform", "Victor", "Whiskey", "X-ray", "Yankee", "Zulu"]
        encoded = bytearray()
        for byte in data:
            encoded.extend(words[byte % len(words)].encode() + b" ")
        return encoded

    def __words256_decode(self, data: bytearray) -> bytearray:
        words = ["Alpha", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot",
                "Golf", "Hotel", "India", "Juliet", "Kilo", "Lima", "Mike",
                "November", "Oscar", "Papa", "Quebec", "Romeo", "Sierra", "Tango",
                "Uniform", "Victor", "Whiskey", "X-ray", "Yankee", "Zulu"]
        decoded = bytearray()
        word = b""
        for byte in data:
            word += bytes([byte])
            if word.endswith(b" "):  # Word boundary (space)
                decoded.append(words.index(word.decode().strip()))
                word = b""
        return decoded

```

`utils/logging.py`:

```py
from rich.logging import RichHandler
import logging
import os

DEBUG = False

log_path = "logs"
debug_path = "logs/debug_logs.log"
session_path = "logs/session_logs.log"
if not os.path.exists(log_path):
    os.mkdir(log_path)

if not os.path.exists(debug_path):
    with open(debug_path, 'w', encoding='utf-8'): pass

if not os.path.exists(session_path):
    with open(session_path, 'w', encoding='utf-8'): pass

logging.basicConfig(
    level="DEBUG",
    format="%(message)s",
    datefmt="[%X]",
    handlers=[
        RichHandler(rich_tracebacks=True),
        logging.FileHandler(debug_path, mode='a', encoding="utf-8"),
        logging.FileHandler(session_path, mode='w', encoding="utf-8"),
    ],
)

logger = logging.getLogger("rich")


class Log:
    """Handles all styled terminal output."""
    def __init__(self):
        pass

    @staticmethod
    def logSuccess(msg: str):
        """Logs msg to the terminal with a green [+] appended. Used to show task success."""
        return logger.debug(f"[+] {msg}")

    @staticmethod
    def logInfo(msg: str):
        """Logs msg to the terminal with a blue [*] appended. Used to show task status / info."""
        return logger.info(f"[!] {msg}")

    @staticmethod
    def logDebug(msg: str):
        """Logs msg to the terminal with a magenta [debug] appended. Used for debug info."""
        if DEBUG:
            return logger.debug(f"[+] {msg}")

    @staticmethod
    def logError(msg: str):
        """Logs msg to the terminal with a red [!] appended. Used for error messages."""
        return logger.error(f"[-] {msg}")

    @staticmethod
    def LogException(msg: str):
        """Logs msg to the terminal with a red [!!] appended. Used to show error messages."""
        return logger.exception(f"[!!] {msg}")

```