Project Path: arc_SilentVoid13_Silent_Packer_l0847l_r

Source Tree:

```txt
arc_SilentVoid13_Silent_Packer_l0847l_r
├── CMakeLists.txt
├── LICENSE.TXT
├── METHODS.md
├── README.md
├── TODO.md
├── bin
│   └── Silent_Packer
├── extern
│   └── argtable3
├── flake.lock
├── flake.nix
├── includes
│   ├── ELF
│   │   ├── elf_allocation.h
│   │   ├── elf_code_cave.h
│   │   ├── elf_deallocation.h
│   │   ├── elf_encryption.h
│   │   ├── elf_functions.h
│   │   ├── elf_packing.h
│   │   ├── elf_packing_method.h
│   │   ├── elf_section_insertion.h
│   │   ├── elf_silvio_infection.h
│   │   └── elf_writing.h
│   ├── PE
│   │   ├── pe_allocation.h
│   │   ├── pe_code_cave.h
│   │   ├── pe_deallocation.h
│   │   ├── pe_encryption.h
│   │   ├── pe_functions.h
│   │   ├── pe_packing.h
│   │   ├── pe_packing_method.h
│   │   ├── pe_section_insertion.h
│   │   ├── pe_struct.h
│   │   └── pe_writing.h
│   ├── STUB
│   │   ├── all_elf_loaders.h
│   │   ├── all_elf_loaders_infos.h
│   │   ├── all_loaders.h
│   │   ├── all_pe_loaders.h
│   │   ├── all_pe_loaders_infos.h
│   │   ├── amd64_aes_128_ecb_linux_elf_loader.h
│   │   ├── amd64_aes_128_ecb_win_pe_loader.h
│   │   ├── amd64_xor_linux_elf_loader.h
│   │   ├── amd64_xor_win_pe_loader.h
│   │   ├── i386_aes_128_ecb_linux_elf_loader.h
│   │   ├── i386_aes_128_ecb_win_pe_loader.h
│   │   ├── i386_xor_linux_elf_loader.h
│   │   └── i386_xor_win_pe_loader.h
│   ├── common
│   │   ├── aes_128_ecb_encryption.h
│   │   ├── cipher_functions.h
│   │   ├── file_functions.h
│   │   ├── loader_functions.h
│   │   └── packer_config.h
│   ├── main.h
│   └── packing_method.h
├── resources
│   ├── ELF_Section_Insertion.png
│   ├── ELF_Silvio_text_infection.png
│   ├── PE_Code_cave.png
│   ├── PE_structure.png
│   ├── elf_structure.svg
│   └── linking_execution_view.jpg
└── src
    ├── ELF
    │   ├── elf_allocation.c
    │   ├── elf_code_cave.c
    │   ├── elf_deallocation.c
    │   ├── elf_encryption.c
    │   ├── elf_functions.c
    │   ├── elf_packing.c
    │   ├── elf_packing_method.c
    │   ├── elf_section_insertion.c
    │   ├── elf_silvio_infection.c
    │   └── elf_writing.c
    ├── PE
    │   ├── pe_allocation.c
    │   ├── pe_code_cave.c
    │   ├── pe_deallocation.c
    │   ├── pe_encryption.c
    │   ├── pe_functions.c
    │   ├── pe_packing.c
    │   ├── pe_packing_method.c
    │   ├── pe_section_insertion.c
    │   └── pe_writing.c
    ├── STUB
    │   ├── amd64_aes_128_ecb_linux_elf_loader.asm
    │   ├── amd64_aes_128_ecb_win_pe_loader.asm
    │   ├── amd64_xor_linux_elf_loader.asm
    │   ├── amd64_xor_win_pe_loader.asm
    │   ├── i386_aes_128_ecb_linux_elf_loader.asm
    │   ├── i386_aes_128_ecb_win_pe_loader.asm
    │   ├── i386_xor_linux_elf_loader.asm
    │   └── i386_xor_win_pe_loader.asm
    ├── common
    │   ├── aes_128_ecb_encryption.asm
    │   ├── cipher_functions.c
    │   ├── file_functions.c
    │   ├── loader_functions.c
    │   └── packer_config.c
    ├── main.c
    └── utilities
        └── Silent_Log

```

`CMakeLists.txt`:

```txt
### Basic cmake setup ###

cmake_minimum_required(VERSION 3.2.1)

set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/staticlibs)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/staticlibs)
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)

set(CMAKE_C_FLAGS "-Wall")
set(CMAKE_C_FLAGS "-Wextra")

project(Silent_Packer)

# https://cliutils.gitlab.io/modern-cmake/chapters/projects/submodule.html
### Git Submodule management ###
find_package(Git REQUIRED)
if(GIT_FOUND AND EXISTS "${PROJECT_SOURCE_DIR}/.git")
    option(GIT_SUBMODULE "Check submodules during build" ON)
    if(GIT_SUBMODULE)
        message(STATUS "Submodule update")
        execute_process(COMMAND ${GIT_EXECUTABLE} submodule update --init --recursive
                WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
                RESULT_VARIABLE GIT_SUBMOD_RESULT)
        if(NOT GIT_SUBMOD_RESULT EQUAL "0")
            message(FATAL_ERROR "git submodule update --init failed with ${GIT_SUBMOD_RESULT}, please checkout submodules")
        endif()
    endif()
endif()

### NASM management ###
enable_language(ASM_NASM)
if(CMAKE_ASM_NASM_COMPILER_LOADED)
    set(CAN_USE_ASSEMBLER TRUE)

    # https://stackoverflow.com/questions/49131996/compile-asm-and-c-with-asm-for-debugging
    set(CMAKE_ASM_NASM_OBJECT_FORMAT elf64)
    set(CMAKE_ASM_NASM_COMPILE_OBJECT "<CMAKE_ASM_NASM_COMPILER> <INCLUDES> \
    <FLAGS> -f ${CMAKE_ASM_NASM_OBJECT_FORMAT} -o <OBJECT> <SOURCE>")
    set_source_files_properties(src/common/aes_128_ecb_encryption.asm PROPERTIES COMPILE_FLAGS "-g -Fdwarf")

    file(GLOB_RECURSE ENGINE_ASM_FILES "src/engine/*.asm")
    set(ENGINE_SOURCES ${ENGINE_SOURCES} ${ENGINE_ASM_FILES})
endif(CMAKE_ASM_NASM_COMPILER_LOADED)

### Includes ###
include_directories(includes)
include_directories(includes/ELF)
include_directories(includes/PE)
include_directories(includes/STUB)
include_directories(includes/common)
include_directories(src/utilities/Silent_Log)

### Sources ###
set(SOURCES src/main.c)

set(UTILITIES_SOURCES src/utilities/Silent_Log/log.c)
set(SOURCES ${SOURCES} ${UTILITIES_SOURCES})

set(ELF_SOURCES src/ELF/elf_allocation.c src/ELF/elf_functions.c src/ELF/elf_packing.c src/ELF/elf_encryption.c src/ELF/elf_section_insertion.c src/ELF/elf_writing.c src/ELF/elf_silvio_infection.c src/ELF/elf_code_cave.c src/ELF/elf_deallocation.c)
set(PE_SOURCES src/PE/pe_allocation.c src/PE/pe_functions.c src/PE/pe_writing.c src/PE/pe_packing.c src/PE/pe_code_cave.c src/PE/pe_packing_method.c src/PE/pe_encryption.c src/PE/pe_section_insertion.c src/PE/pe_deallocation.c)

set(COMMON_SOURCES ${ELF_SOURCES} ${PE_SOURCES} src/common/file_functions.c src/common/cipher_functions.c src/ELF/elf_packing_method.c src/common/loader_functions.c src/common/packer_config.c)

set(ASSEMBLY_SOURCES src/common/aes_128_ecb_encryption.asm)

set(SOURCES ${SOURCES} ${COMMON_SOURCES} ${ASSEMBLY_SOURCES})

add_executable(Silent_Packer ${SOURCES})
install(TARGETS Silent_Packer DESTINATION bin)

### External libs ###

option(ARGTABLE3_ENABLE_TESTS OFF)
option(ARGTABLE3_ENABLE_EXAMPLES OFF)
add_subdirectory("extern/argtable3")

target_link_libraries(Silent_Packer argtable3 pthread m)

```

`LICENSE.TXT`:

```TXT
                    GNU AFFERO GENERAL PUBLIC LICENSE
                       Version 3, 19 November 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU Affero General Public License is a free, copyleft license for
software and other kinds of works, specifically designed to ensure
cooperation with the community in the case of network server software.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
our General Public Licenses are intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  Developers that use our General Public Licenses protect your rights
with two steps: (1) assert copyright on the software, and (2) offer
you this License which gives you legal permission to copy, distribute
and/or modify the software.

  A secondary benefit of defending all users' freedom is that
improvements made in alternate versions of the program, if they
receive widespread use, become available for other developers to
incorporate.  Many developers of free software are heartened and
encouraged by the resulting cooperation.  However, in the case of
software used on network servers, this result may fail to come about.
The GNU General Public License permits making a modified version and
letting the public access it on a server without ever releasing its
source code to the public.

  The GNU Affero General Public License is designed specifically to
ensure that, in such cases, the modified source code becomes available
to the community.  It requires the operator of a network server to
provide the source code of the modified version running there to the
users of that server.  Therefore, public use of a modified version, on
a publicly accessible server, gives the public access to the source
code of the modified version.

  An older license, called the Affero General Public License and
published by Affero, was designed to accomplish similar goals.  This is
a different license, not a version of the Affero GPL, but Affero has
released a new version of the Affero GPL which permits relicensing under
this license.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU Affero General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Remote Network Interaction; Use with the GNU General Public License.

  Notwithstanding any other provision of this License, if you modify the
Program, your modified version must prominently offer all users
interacting with it remotely through a computer network (if your version
supports such interaction) an opportunity to receive the Corresponding
Source of your version by providing access to the Corresponding Source
from a network server at no charge, through some standard or customary
means of facilitating copying of software.  This Corresponding Source
shall include the Corresponding Source for any work covered by version 3
of the GNU General Public License that is incorporated pursuant to the
following paragraph.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the work with which it is combined will remain governed by version
3 of the GNU General Public License.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU Affero General Public License from time to time.  Such new versions
will be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU Affero General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU Affero General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU Affero General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If your software can interact with users remotely through a computer
network, you should also make sure that it provides a way for users to
get its source.  For example, if your program is a web application, its
interface could display a "Source" link that leads users to an archive
of the code.  There are many ways you could offer source, and different
solutions will be better for different programs; see section 13 for the
specific requirements.

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU AGPL, see
<https://www.gnu.org/licenses/>.

```

`METHODS.md`:

```md
This is a very basic explanation of the different file format structures and how does the different encryption methods used by Silent_Packer work.

# ELF

> In computing, the **Executable and Linkable Format** (ELF, formerly named Extensible Linking Format), is a common standard file format for executable files, object code, shared libraries, and core dumps.

## ELF Structure

![ELF Structure](resources/elf_structure.svg)

## ELF Code cave

**TODO**

## ELF Section Insertion

![ELF Section Insertion](resources/ELF_Section_Insertion.png)

## ELF Silvio Text Infection

![ELF Silvio Text Infection](resources/ELF_Silvio_text_infection.png)

# PE

> The **Portable Executable** (PE) format is a file format for executables, object code, DLLs and others used in 32-bit and 64-bit versions of Windows operating systems. The PE format is a data structure that encapsulates the information necessary for the Windows OS loader to manage the wrapped executable code.

## PE Structure

![PE Structure](resources/PE_structure.png)

## PE Code Cave

![PE Code Cave](resources/PE_Code_cave.png)

## PE Section Insertion

**TODO**
```

`README.md`:

```md
# Silent_Packer

Silent_Packer is an ELF / PE packer written in pure C.

This program can be used to obfuscate a binary. This packer supports PIE binaries.

## License

Silent_Packer is licensed under the GNU AGPLv3 license. Refer to [LICENSE](https://github.com/SilentVoid13/Silent_Packer/blob/master/LICENSE.txt) for more informations.

## What is a packer ?

> Binary packers alter the original binary data, and restore it (more or less) before execution.

Silent_Packer is a very basic and common packer, encrypting the code section from the binary (`.text`) and decrypting it before executing it. This technique can be used to obfuscate the binary code to bypass antiviruses or to make reverse engineering harder. Packers can also be used to compress a binary to reduce its size.

You can find a more detailed stackoverflow post [here](https://reverseengineering.stackexchange.com/questions/1779/what-are-the-different-types-of-packers).

## File formats

Silent_Packer currently support the following file formats :

- ELF64
- ELF32
- PE32+
- PE32

I will maybe add the MACH-O file format later. You can suggest me a file format that you want me to add.

## Cipher methods

Silent_Packer currently support the following cipher methods :

- XOR
- AES-128-ECB

Support for some more secure AES modes should arrive soon (AES-128-CBC, AES-256, ...)

You can suggest me a cipher method that you want me to add.

## Encryption methods

Silent_Packer currently support the following encryption methods :

- Section Insertion
- Code Cave
- Silvio Text Infection (only for ELF files)

For a basic explanation on how does these methods work, see the [METHODS](https://github.com/SilentVoid13/Silent_Packer/blob/master/METHODS.md) file.

## Usage

```bash
Usage: Silent_Packer [-hVvd] [-f file] [-c <xor, aes128_ecb>] [-m <section_insertion, code_cave, silvio_infection>] [-o file]
  -h, --help                Display this help and exit
  -V, --version             Display version info and exit
  -v, --verbose             Verbose output
  -d, --debug               Debug mode
  -f, --file=file           File to pack
  -c, --cipher=<xor, aes128_ecb> Cipher method to use
  -m, --method=<section_insertion, code_cave, silvio_infection> Method to pack the binary
  -o, --output=file         Output file
```

## Building

You can either get the compiled version from the latest [release](https://github.com/SilentVoid13/Silent_Packer/releases), from the [bin](https://github.com/SilentVoid13/Silent_Packer/tree/master/bin) directory, or compile it yourself.

This project relies on [Silent_Log](https://github.com/SilentVoid13/Silent_Log) for logging messages.

To build it yourself you will need `cmake`, `gcc` and `nasm`.

No windows version is available at the moment.

**On Linux**

```bash
mkdir build && cd build
cmake ..
make
make install
```

The compiled binary will be available in the **bin** directory.

## Known_bugs

Feel free to report any bugs, so that I can fix them.

The packer has some recurrent bugs with PE files, especially with big binaries with a lot of dynamic libs. The section insertion method has a weird behavior sometimes (adding some null bytes at the beginning of the section making the offsets wrong).

## Contributing

Feel free to contribute. See the [TODO](https://github.com/SilentVoid13/Silent_Packer/blob/master/TODO.md) list.

## Disclaimer

I am not responsible for what you do with the information and code provided. This is intended for professional or educational purposes only.

```

`TODO.md`:

```md

# Packer
- [x] Make README file
- [ ] Add dynamic library support
- [x] Add PIE support
    - Probably my nasm loader that needs to be changed
- [ ] Add new ciphers
    - [x] AES
- [x] Add PE Support
- [ ] Clean code
- [ ] Add mprotect in loader
- [x] Add functions prototypes
- [x] Add file recognition (ELF or PE)
- [x] Add file arch recognition (x32 or x64) 
- [x] Free malloc variables
- [x] Add submodule warning in makefile
- [ ] Add possibility to add a custom stub (no encryption just executing stub before jumping to main)
- [ ] Add more packing methods
- [ ] Change stub message

## ELF

### 32 bit
- [x] Add 32 bit support

### Section insertion
- [x] Add section name to the section string table
- [x] Fix string table errors

### Silvio infection
- [ ] Add possibility to add a big payload and add multiple PAGE_SIZE padding

### Code cave
- [x] Add code_cave support

### Heap allocated variables
- [x] file_data mmap - munmap

s_elf struct :

- [x] t_elf (elf_allocation)
- [x] elf_header (elf_allocation)
- [x] prog_header (elf_allocation)
- [x] section_header (elf_allocation)
- [x] section_data  (elf_allocation)
- [x] section_data\[i\] (elf_allocation)

- [x] loader (loader_functions)

## PE

### 32 bit
- [x] Add 32 bit support
    - Need to test it

### Code cave
- [ ] Clean code

### Section insertion
- [x] Add section insertion packing method
- [ ] Fix section insertion not working for every binary
    - Don't know why, but it's adding some null bytes at the beginning of the section making the offsets wrong when decrypting the .text

### Heap allocated variables

- [x] t_pe64 (pe_allocation)
- [x] dos_header (pe_allocation)
- [x] dos_stub (pe_allocation)
- [x] pe_header (pe_allocation)
- [x] section_header (pe_allocation)
- [x] section_data (pe_allocation)
- [x] section_data\[i\] (pe_allocation)

- [x] loader (loader_functions)

## AES

- [x] Add AES-128-ECB support for PE32, PE32+, ELF32
- [ ] Add AES-128-CBC
- [ ] Add AES-256

```

`flake.lock`:

```lock
{
  "nodes": {
    "flake-utils": {
      "inputs": {
        "systems": "systems"
      },
      "locked": {
        "lastModified": 1710146030,
        "narHash": "sha256-SZ5L6eA7HJ/nmkzGG7/ISclqe6oZdOZTNoesiInkXPQ=",
        "owner": "numtide",
        "repo": "flake-utils",
        "rev": "b1d9ab70662946ef0850d488da1c9019f3a9752a",
        "type": "github"
      },
      "original": {
        "owner": "numtide",
        "repo": "flake-utils",
        "type": "github"
      }
    },
    "nixpkgs": {
      "locked": {
        "lastModified": 1711523803,
        "narHash": "sha256-UKcYiHWHQynzj6CN/vTcix4yd1eCu1uFdsuarupdCQQ=",
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "2726f127c15a4cc9810843b96cad73c7eb39e443",
        "type": "github"
      },
      "original": {
        "id": "nixpkgs",
        "ref": "nixos-unstable",
        "type": "indirect"
      }
    },
    "root": {
      "inputs": {
        "flake-utils": "flake-utils",
        "nixpkgs": "nixpkgs"
      }
    },
    "systems": {
      "locked": {
        "lastModified": 1681028828,
        "narHash": "sha256-Vy1rq5AaRuLzOxct8nz4T6wlgyUR7zLU309k9mBC768=",
        "owner": "nix-systems",
        "repo": "default",
        "rev": "da67096a3b9bf56a91d16901293e51ba5b49a27e",
        "type": "github"
      },
      "original": {
        "owner": "nix-systems",
        "repo": "default",
        "type": "github"
      }
    }
  },
  "root": "root",
  "version": 7
}

```

`flake.nix`:

```nix
{
  description = "Silent_Packer";

  inputs = {
    nixpkgs.url = "nixpkgs/nixos-unstable";
    flake-utils.url = "github:numtide/flake-utils";
  };

  outputs = {
    self,
    nixpkgs,
    flake-utils,
    ...
  } @ inputs: let
  in
    flake-utils.lib.eachDefaultSystem (
      system: let
        pkgs = import nixpkgs {inherit system;};
        buildInputs = with pkgs; [
          libmhash
        ];
        nativeBuildInputs = with pkgs; [
          clang
          pkg-config
          cmake
          nasm
        ];
      in {
        devShells.default = pkgs.mkShell {
          inherit buildInputs;
          inherit nativeBuildInputs;
        };
      }
    );
}

```

`includes/ELF/elf_allocation.h`:

```h
//
// Created by silentvoid on 2/25/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_ELF_ALLOCATION_H
#define SILENT_PACKER_ELF_ALLOCATION_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <elf.h>
#include <linux/elf-em.h>

// http://man7.org/linux/man-pages/man5/elf.5.html

typedef struct s_elf {
    enum{ELF32, ELF64} s_type;
} t_elf;

typedef struct s_elf64
{
    t_elf type_header;
    Elf64_Ehdr	*elf_header;
    Elf64_Phdr	*prog_header;
    Elf64_Shdr	*section_header;
    // Array of bytes for each section
    char **section_data;
} t_elf64;

typedef struct s_elf32 {
    t_elf type_header;
    Elf32_Ehdr	*elf_header;
    Elf32_Phdr	*prog_header;
    Elf32_Shdr	*section_header;
    // Array of bytes for each section
    char **section_data;
} t_elf32;

int allocate_elf_elf_header(t_elf *elf, void *file_data, size_t file_data_size);
int allocate_elf_program_header(t_elf *elf, void *file_data, size_t file_data_size);
int allocate_elf_sections_header(t_elf *elf, void *file_data, size_t file_data_size);
int allocate_elf_sections_data(t_elf *elf, void *file_data, size_t file_data_size);

int allocate_elf(t_elf **elf, void *file_data, size_t file_data_size);


#endif //SILENT_PACKER_ELF_ALLOCATION_H

```

`includes/ELF/elf_code_cave.h`:

```h
//
// Created by silentvoid on 3/7/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_CODE_CAVE_H
#define SILENT_PACKER_CODE_CAVE_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "elf_allocation.h"

int find_elf_code_cave_index(t_elf *elf);
int set_new_elf_cave_segment_values(t_elf *elf, int segment_index);
int elf_cave_insert_loader(t_elf *elf, int section_index, int old_section_size);

int elf_code_cave_injection(t_elf *elf);

#endif //SILENT_PACKER_CODE_CAVE_H

```

`includes/ELF/elf_deallocation.h`:

```h
//
// Created by silentvoid on 4/12/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_ELF_DEALLOCATION_H
#define SILENT_PACKER_ELF_DEALLOCATION_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "elf_allocation.h"

void deallocate_elf_elf_header(t_elf *elf);
void deallocate_elf_program_header(t_elf *elf);
void deallocate_elf_sections_header(t_elf *elf);
void deallocate_elf_sections_data(t_elf *elf);
void deallocate_elf_sections_data_data(t_elf *elf);
void deallocate_elf_struct(t_elf *elf);
void deallocate_elf(t_elf *elf);

#endif //SILENT_PACKER_ELF_DEALLOCATION_H

```

`includes/ELF/elf_encryption.h`:

```h
//
// Created by silentvoid on 3/16/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_ENCRYPT_ELF_H
#define SILENT_PACKER_ENCRYPT_ELF_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "elf_allocation.h"

int encrypt_elf(t_elf *elf);

#endif //SILENT_PACKER_ENCRYPT_ELF_H

```

`includes/ELF/elf_functions.h`:

```h
//
// Created by silentvoid on 2/28/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_ELF_FUNCTIONS_H
#define SILENT_PACKER_ELF_FUNCTIONS_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "elf_allocation.h"

int set_new_elf_entry_to_section(t_elf *elf, int section_index);
int set_new_elf_entry_to_addr32(t_elf *elf, int32_t entry_address, int section_index, int section_size);
int set_new_elf_entry_to_addr64(t_elf *elf, int64_t entry_address, int section_index, int section_size);

int find_last_elf_segment_of_type(t_elf *elf, unsigned int p_type);
int find_last_elf_section_from_segment(t_elf *elf, int segment_index);
int find_elf_text_segment(t_elf *elf);
int find_elf_segment_index_of_section(t_elf *elf, int section_index);
char * find_elf_section_name(t_elf *elf, int index);
int find_elf_section_index(t_elf *elf, char *section_name);

void add_elf_segment_permission(t_elf *elf, int segment_index, int permission);

#endif //SILENT_PACKER_ELF_FUNCTIONS_H

```

`includes/ELF/elf_packing.h`:

```h
//
// Created by silentvoid on 2/25/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_PACK_ELF_H
#define SILENT_PACKER_PACK_ELF_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <mhash.h>

int pack_elf(char *file, char *file_data, size_t file_data_size, char *output);

#endif //SILENT_PACKER_PACK_ELF_H

```

`includes/ELF/elf_packing_method.h`:

```h
//
// Created by silentvoid on 2/28/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_PACKING_METHOD_ELF_H
#define SILENT_PACKER_PACKING_METHOD_ELF_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "elf_allocation.h"

#include "packing_method.h"

int elf_pack_using_method(t_elf *elf);

#endif //SILENT_PACKER_PACKING_METHOD_ELF_H

```

`includes/ELF/elf_section_insertion.h`:

```h
//
// Created by silentvoid on 2/26/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_SECTION_INSERTION_H
#define SILENT_PACKER_SECTION_INSERTION_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "elf_allocation.h"

int set_new_elf_section_string_table(t_elf *elf);
int set_new_elf_section_symtab_sh_link_value(t_elf *elf);
int elf_section_create_new_section(t_elf *elf, int last_pt_load_index, int last_loadable_section_index);
void print_link_fields(t_elf *elf);
int set_new_elf_section_pt_loader_permissions(t_elf *elf);

int elf_insert_section(t_elf *elf);

#endif //SILENT_PACKER_SECTION_INSERTION_H

```

`includes/ELF/elf_silvio_infection.h`:

```h
//
// Created by silentvoid on 2/28/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_SILVIO_INFECTION_H
#define SILENT_PACKER_SILVIO_INFECTION_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "ELF/elf_allocation.h"

#define PAGE_SIZE64 0x2000
#define PAGE_SIZE32 4096

int set_new_elf_silvio_segment_values(t_elf *elf, int text_segment_index);
int set_new_elf_silvio_section_values(t_elf *elf, int last_section_index);
int elf_silvio_insert_loader(t_elf *elf, int section_index, int old_section_size);

int elf_silvio_infect(t_elf *elf);

#endif //SILENT_PACKER_SILVIO_INFECTION_H

```

`includes/ELF/elf_writing.h`:

```h
//
// Created by silentvoid on 2/26/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_WRITE_ELF_H
#define SILENT_PACKER_WRITE_ELF_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#include "ELF/elf_allocation.h"

int write_elf(t_elf *elf, char *filename);

#endif //SILENT_PACKER_WRITE_ELF_H

```

`includes/PE/pe_allocation.h`:

```h
//
// Created by silentvoid on 3/16/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_PE_ALLOCATION_H
#define SILENT_PACKER_PE_ALLOCATION_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "pe_struct.h"

typedef struct s_pe {
    enum{PE32, PE64} s_type;
} t_pe;

typedef struct s_pe32 {
    t_pe type_header;
    IMAGE_DOS_HEADER *dos_header;
    char *dos_stub;
    IMAGE_NT_HEADERS32 *pe_header;
    IMAGE_SECTION_HEADER *section_header;
    char **section_data;
} t_pe32;

typedef struct s_pe64 {
    t_pe type_header;
    IMAGE_DOS_HEADER *dos_header;
    char *dos_stub;
    IMAGE_NT_HEADERS64 *pe_header;
    IMAGE_SECTION_HEADER *section_header;
    char **section_data;
} t_pe64;

/*
 * Can be a solution too
typedef struct s_pe {
    enum{PE32, PE64} s_type;

    union {
        t_pe64 pe64;
        t_pe32 pe32;
    };
} t_pe;
*/

int allocate_pe_dos_header(t_pe *pe, void *file_data, size_t file_data_size);
int allocate_pe_dos_stub(t_pe *pe, void *file_data);
int allocate_pe_pe_header(t_pe *pe, void *file_data, size_t file_data_size);
int allocate_pe_sections_headers(t_pe *pe, void *file_data, size_t file_data_size);
int allocate_pe_sections_data(t_pe *pe, void *file_data, size_t file_data_size);
void print_pe_info(t_pe *pe);

int allocate_pe(t_pe **pe, void *file_data, size_t file_data_size, int arch);

#endif //SILENT_PACKER_PE_ALLOCATION_H

```

`includes/PE/pe_code_cave.h`:

```h
//
// Created by silentvoid on 3/18/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_CODE_CAVE_H
#define SILENT_PACKER_CODE_CAVE_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "pe_allocation.h"

int find_pe_code_cave_index(t_pe *pe);
int set_new_pe_cave_section_values(t_pe *pe, int section_index);
int pe_cave_insert_loader(t_pe *pe, int section_index, int old_section_size);

int pe_code_cave_injection(t_pe *pe);

#endif //SILENT_PACKER_CODE_CAVE_H

```

`includes/PE/pe_deallocation.h`:

```h
//
// Created by silentvoid on 4/12/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_PE_DEALLOCATION_H
#define SILENT_PACKER_PE_DEALLOCATION_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "pe_allocation.h"

void deallocate_pe_dos_header(t_pe *pe);
void deallocate_pe_dos_stub(t_pe *pe);
void deallocate_pe_pe_header(t_pe *pe);
void deallocate_pe_sections_headers(t_pe *pe);
void deallocate_pe_sections_data(t_pe *pe);
void deallocate_pe_sections_data_data(t_pe *pe);
void deallocate_pe_struct(t_pe *pe);
void deallocate_pe(t_pe *pe);

#endif //SILENT_PACKER_PE_DEALLOCATION_H

```

`includes/PE/pe_encryption.h`:

```h
//
// Created by silentvoid on 3/19/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_ENCRYPT_PE_H
#define SILENT_PACKER_ENCRYPT_PE_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "pe_allocation.h"

int encrypt_pe(t_pe *pe);

#endif //SILENT_PACKER_ENCRYPT_PE_H

```

`includes/PE/pe_functions.h`:

```h
//
// Created by silentvoid on 3/16/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_PE_FUNCTIONS_H
#define SILENT_PACKER_PE_FUNCTIONS_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "pe_allocation.h"

int set_new_pe_entry_to_section(t_pe *pe, int section_index);
int set_new_pe_entry_to_addr(t_pe *pe, uint32_t entry_addr, int section_index, int section_size);

int find_pe_text_section(t_pe *pe);
void add_pe_section_permission(t_pe *pe, int segment_index, int permission);
void print_pe_section_info(t_pe *pe, int section_index);

#endif //SILENT_PACKER_PE_FUNCTIONS_H

```

`includes/PE/pe_packing.h`:

```h
//
// Created by silentvoid on 3/16/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_PACK_PE_H
#define SILENT_PACKER_PACK_PE_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int pack_pe(char *file, char *file_data, size_t file_data_size, char *output);

#endif //SILENT_PACKER_PACK_PE_H

```

`includes/PE/pe_packing_method.h`:

```h
//
// Created by silentvoid on 3/18/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_PACKING_METHOD_PE_H
#define SILENT_PACKER_PACKING_METHOD_PE_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "pe_allocation.h"
#include "packing_method.h"

int pe_pack_using_method(t_pe *pe);

#endif //SILENT_PACKER_PACKING_METHOD_PE_H

```

`includes/PE/pe_section_insertion.h`:

```h
//
// Created by silentvoid on 3/26/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_PE_SECTION_INSERTION_H
#define SILENT_PACKER_PE_SECTION_INSERTION_H

#include "pe_allocation.h"

int add_new_pe_section_header(t_pe *pe);
int add_new_pe_section_data(t_pe *pe);
int set_new_pe_header_values(t_pe *pe);
void print_new_section_header_info(IMAGE_SECTION_HEADER *section_header);

int pe_insert_section(t_pe *pe);

#endif //SILENT_PACKER_PE_SECTION_INSERTION_H

```

`includes/PE/pe_struct.h`:

```h
//
// Created by silentvoid on 3/16/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_PE_STRUCT_H
#define SILENT_PACKER_PE_STRUCT_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES 16
#define IMAGE_SIZEOF_SHORT_NAME 8

#define DOSMAG 0x5a4d

#define STR_DOSMAG "MZ"
#define SSTR_DOSMAG 2

#define PEMAG 0x00004550

#define DOS_STUB_SIZE 64

#define PE32MAG 0x10b
#define PE64MAG 0x20b

#define IMAGE_FILE_RELOCS_STRIPPED 0x0001 /**< No relocation info. */
#define IMAGE_FILE_EXECUTABLE_IMAGE 0x0002
#define IMAGE_FILE_LINE_NUMS_STRIPPED 0x0004
#define IMAGE_FILE_LOCAL_SYMS_STRIPPED 0x0008
#define IMAGE_FILE_AGGRESIVE_WS_TRIM 0x0010
#define IMAGE_FILE_LARGE_ADDRESS_AWARE 0x0020
#define IMAGE_FILE_16BIT_MACHINE 0x0040
#define IMAGE_FILE_BYTES_REVERSED_LO 0x0080
#define IMAGE_FILE_32BIT_MACHINE 0x0100
#define IMAGE_FILE_DEBUG_STRIPPED 0x0200
#define IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP 0x0400
#define IMAGE_FILE_NET_RUN_FROM_SWAP 0x0800
#define IMAGE_FILE_SYSTEM0x1000
#define IMAGE_FILE_DLL 0x2000
#define IMAGE_FILE_UP_SYSTEM_ONLY 0x4000
#define IMAGE_FILE_BYTES_REVERSED_HI 0x8000

/* These are the settings of the Machine field. */
#define IMAGE_FILE_MACHINE_UNKNOWN 0x0 /**< COFF header's Machine field for
                                         unknown machine. */
#define IMAGE_FILE_MACHINE_I386 0x014c /**< COFF header's Machine field for
                                         I386 machines. */
#define IMAGE_FILE_MACHINE_ARM 0x01c0 /**< COFF header's Machine field for ARM
                                        machines. */
#define IMAGE_FILE_MACHINE_AMD64 0x8664 /**< COFF header's Machine field for
                                          AMD machines. */

#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES 16

#define IMAGE_DOS_SIGNATURE 0x5A4D /**< DOS header signature. Equals to 'MZ'. */
#define IMAGE_NT_SIGNATURE 0x00004550 /**< PE header signature. Equals to 'PE\0\0'. */
#define IMAGE_NT_OPTIONAL_HDR32_MAGIC 0x10B /**< OPTIONAL header 32bits signature. */
#define IMAGE_NT_OPTIONAL_HDR64_MAGIC 0x20B /**< OPTIONAL header 64bits signature. */

#define IMAGE_SIZEOF_SHORT_NAME 8 /**< Max length for the section header's name field. */

#define IMAGE_SCN_CNT_CODE 0x00000020 /**< The section contains executable code. */
#define IMAGE_SCN_MEM_EXECUTE 0x20000000 /**< The section can be executed as code. */
#define IMAGE_SCN_MEM_READ 0x40000000 /**< The section can be read. */
#define IMAGE_SCN_MEM_WRITE 0x80000000 /**< The section can be written. */

/* PE classes */
#define PECLASSNONE 0 /**< Unknown class. */
#define PECLASS32 1 /**< 32-bit objects. */
#define PECLASS64 2 /**< 64-bit objects. */

typedef struct _IMAGE_DOS_HEADER {
    uint16_t e_magic; /**< DOS header signature. Must be equal to 'MZ' */
    uint16_t e_cblp; /**< Bytes on last page of file */
    uint16_t e_cp; /**< Pages in file */
    uint16_t e_crlc; /**< Relocations */
    uint16_t e_cparhdr; /**< Size of header in paragraphs */
    uint16_t e_minalloc; /**< Minimum extra paragraphs needed */
    uint16_t e_maxalloc; /**< Maximum extra paragraphs needed */
    uint16_t e_ss; /**< Initial (relative) SS value */
    uint16_t e_sp; /**< Initial SP value */
    uint16_t e_csum; /**< Checksum */
    uint16_t e_ip; /**< Initial IP value */
    uint16_t e_cs; /**< Initial (relative) CS value */
    uint16_t e_lfarlc; /**< File address of relocation table */
    uint16_t e_ovno; /**< Overlay number */
    uint16_t e_res[4]; /**< Reserved words */
    uint16_t e_oemid; /**< OEM identifier (for e_oeminfo) */
    uint16_t e_oeminfo; /**< OEM information; e_oemid specific */
    uint16_t e_res2[10]; /**< Reserved words */
    uint32_t e_lfanew; /**< Offset to extended header */
} IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

typedef struct _IMAGE_FILE_HEADER {
    uint16_t  Machine;
    uint16_t  NumberOfSections;
    uint32_t TimeDateStamp;
    uint32_t PointerToSymbolTable;
    uint32_t NumberOfSymbols;
    uint16_t  SizeOfOptionalHeader;
    uint16_t  Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

typedef struct _IMAGE_DATA_DIRECTORY {
    uint32_t VirtualAddress;
    uint32_t Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

typedef struct _IMAGE_OPTIONAL_HEADER32 {
    uint16_t Magic; /**< OPTIONAL header signature. Equals to
                      #IMAGE_NT_OPTIONAL_HDR32_MAGIC for 32bits EXE files. */
    uint8_t MajorLinkerVersion; /**< The version of the linker that produced the file. */
    uint8_t MinorLinkerVersion; /**< The version of the linker that produced the file. */
    uint32_t SizeOfCode; /**< The combined and rounded-up size of all the code
                           sections (most of the time, '.text' section). */
    uint32_t SizeOfInitializedData;
    uint32_t SizeOfUnitializedData;
    uint32_t AddressOfEntryPoint; /**< The address where the loader will begin
                                    the execution. */
    uint32_t BaseOfCode; /**< Relative virtual address where the code sections
                           begin. */
    uint32_t BaseOfData; /**< Relative virtual address where the data sections
                           begin. */
    uint32_t ImageBase; /**< Assumed location where the file will be
                          memory-mapped. */
    uint32_t SectionAlignment; /**< Alignment value for a section. */
    uint32_t FileAlignment; /**< Alignment value for the file's raw data. */
    uint16_t MajorOperatingSystemVersion; /**< The minimum version of the
                                            operating system required to use
                                            the executable. */
    uint16_t MinorOperatingSystemVersion; /**< The minimum version of the
                                            operating system required to use
                                            the executable. */
    uint16_t MajorImageVersion; /**< User-definable field to allow different
                                  version of an EXE file. */
    uint16_t MinorImageVersion; /**< User-definable field to allow different
                                  version of an EXE file. */
    uint16_t MajorSubsystemVersion; /**< The minimum subsystem version required
                                      to run the EXE file. Typical value 3.10
                                      (meaning Windows NT 3.1). */
    uint16_t MinorSubsystemVersion; /**< The minimum subsystem version required
                                      to run the EXE file. Typical value 3.10
                                      (meaning Windows NT 3.1). */
    uint32_t Win32VersionValue; /**< Reserved. */
    uint32_t SizeOfImage; /**< Total size starting from the image base to the
                            end of the last section. The end of the last
                            section is rounded up to the nearest multiple of
                            the #SectionAlignment value. */
    uint32_t SizeOfHeaders; /**< Size of the PE headers and the section table.
                              The raw section data starts immediately after all
                              the header components. */
    uint32_t CheckSum; /**< CRC checksum. Usualy ignored and set to 0. */
    uint16_t Subsystem; /**< Type of subsystem used for its user interface. */
    uint16_t DllCharacteristics; /**< Set of flags indicating under which
                                   circumstances a DLL's initialization
                                   function will be called. Appears to always
                                   be set to 0. */
    uint32_t SizeOfStackReserve; /**< The amount of virtual memory to reserve
                                   for the initial thread's stack. */
    uint32_t SizeOfStackCommit; /**< The amount of memory initially committed
                                  for the initial thread's stack. */
    uint32_t SizeOfHeapReserve; /**< The amount of virtual memory to reserve
                                  for the initial process heap. */
    uint32_t SizeOfHeapCommit; /**< The amount of memory initially committed in
                                 the process heap. */
    uint32_t LoaderFlags; /**< Debugging related field. */
    uint32_t NumberOfRvaAndSizes; /**< The number of entries in the
                                    #DataDirectory array. Always set to 16 by
                                    the tools. */
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; /**< Array of #IMAGE_DATA_DIRECTORY structures. See WINNT.H. */
} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;

typedef struct _IMAGE_OPTIONAL_HEADER64 {
    uint16_t Magic; /**< OPTIONAL header signature. Equals to
                      #IMAGE_NT_OPTIONAL_HDR64_MAGIC for 64bits EXE files. */
    uint8_t MajorLinkerVersion; /**< The version of the linker that produced the file. */
    uint8_t MinorLinkerVersion; /**< The version of the linker that produced the file. */
    uint32_t SizeOfCode; /**< The combined and rounded-up size of all the code
                           sections (most of the time, '.text' section). */
    uint32_t SizeOfInitializedData;
    uint32_t SizeOfUninitializedData;
    uint32_t AddressOfEntryPoint; /**< The address where the loader will begin
                                    the execution. */
    uint32_t BaseOfCode; /**< Relative virtual address where the code sections
                           begin. */
    uint64_t ImageBase; /**< Assumed location where the file will be
                          memory-mapped. */
    uint32_t SectionAlignment; /**< Alignment value for a section. */
    uint32_t FileAlignment; /**< Alignment value for the file's raw data. */
    uint16_t MajorOperatingSystemVersion; /**< The minimum version of the
                                            operating system required to use
                                            the executable. */
    uint16_t MinorOperatingSystemVersion; /**< The minimum version of the
                                            operating system required to use
                                            the executable. */
    uint16_t MajorImageVersion; /**< User-definable field to allow different
                                  version of an EXE file. */
    uint16_t MinorImageVersion; /**< User-definable field to allow different
                                  version of an EXE file. */
    uint16_t MajorSubsystemVersion; /**< The minimum subsystem version required
                                      to run the EXE file. Typical value 3.10
                                      (meaning Windows NT 3.1). */
    uint16_t MinorSubsystemVersion; /**< The minimum subsystem version required
                                      to run the EXE file. Typical value 3.10
                                      (meaning Windows NT 3.1). */
    uint32_t Win32VersionValue; /**< Reserved. */
    uint32_t SizeOfImage; /**< Total size starting from the image base to the
                            end of the last section. The end of the last
                            section is rounded up to the nearest multiple of
                            the #SectionAlignment value. */
    uint32_t SizeOfHeaders; /**< Size of the PE headers and the section table.
                              The raw section data starts immediately after all
                              the header components. */
    uint32_t CheckSum; /**< CRC checksum. Usualy ignored and set to 0. */
    uint16_t Subsystem; /**< Type of subsystem used for its user interface. */
    uint16_t DllCharacteristics; /**< Set of flags indicating under which
                                   circumstances a DLL's initialization
                                   function will be called. Appears to always
                                   be set to 0. */
    uint64_t SizeOfStackReserve; /**< The amount of virtual memory to reserve
                                   for the initial thread's stack. */
    uint64_t SizeOfStackCommit; /**< The amount of memory initially committed
                                  for the initial thread's stack. */
    uint64_t SizeOfHeapReserve; /**< The amount of memory initially committed
                                  in the process heap. */
    uint64_t SizeOfHeapCommit; /**< The amount of memory initially committed in
                                 the process heap. */
    uint32_t LoaderFlags; /**< Debugging related field. */
    uint32_t NumberOfRvaAndSizes; /**< The number of entries in the
                                    #DataDirectory array. Always set to 16 by
                                    the tools. */
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; /**< Array of #IMAGE_DATA_DIRECTORY structures. See WINNT.H. */
} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;

typedef struct _IMAGE_NT_HEADERS32 {
    uint32_t Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER32 OptionalHeader;
} IMAGE_NT_HEADERS32;

typedef struct _IMAGE_NT_HEADERS64 {
    uint32_t Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;

typedef struct _IMAGE_SECTION_HEADER {
    uint8_t Name[IMAGE_SIZEOF_SHORT_NAME]; /**< 8-bytes ANSI name of the
                                             section. If the length of the
                                             string is greater than 8, it is
                                             truncated without appending a NULL
                                             terminating byte. */
    union {
        uint32_t PhysicalAddress;
        uint32_t VirtualSize;
    } Misc; /**< Size of the code or the data before beeing rounded up to the
              nearest file alignment multiple. */
    uint32_t VirtualAddress; /**< Relative virtual address to where the loader
                               should map the section. */
    uint32_t SizeOfRawData; /**< Size of the section after beeing rounded up to
                              the nearest file alignment multiple. */
    uint32_t PointerToRawData; /**< File based offset to the raw data. */
    uint32_t PointerToRelocations; /**< Set to 0 for EXE files. */
    uint32_t PointerToLinenumbers; /**< File based offset to the line number
                                     table. */
    uint16_t NumberOfRelocations; /**< Irrelevant for EXE files. */
    uint16_t NumberOfLinenumbers; /**< Number of line numbers in the line
                                    number table for the section. */
    uint32_t Characteristics; /**< Set of flags describing the section.
                                (Readable, Writeable, Executable, etc.) */
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

#endif //SILENT_PACKER_PE_STRUCT_H

```

`includes/PE/pe_writing.h`:

```h
//
// Created by silentvoid on 3/16/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_WRITE_PE_H
#define SILENT_PACKER_WRITE_PE_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#include "pe_allocation.h"

int write_pe(t_pe *pe, char *filename);

#endif //SILENT_PACKER_WRITE_PE_H

```

`includes/STUB/all_elf_loaders.h`:

```h
//
// Created by silentvoid on 4/2/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_ALL_ELF_LOADERS_H
#define SILENT_PACKER_ALL_ELF_LOADERS_H

#include "i386_xor_linux_elf_loader.h"
#include "amd64_xor_linux_elf_loader.h"

#include "amd64_aes_128_ecb_linux_elf_loader.h"
#include "i386_aes_128_ecb_linux_elf_loader.h"

#endif //SILENT_PACKER_ALL_ELF_LOADERS_H

```

`includes/STUB/all_elf_loaders_infos.h`:

```h
//
// Created by silentvoid on 4/2/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_ALL_ELF_LOADERS_INFOS_H
#define SILENT_PACKER_ALL_ELF_LOADERS_INFOS_H

#define NO_PAYLOAD
#include "all_elf_loaders.h"

#endif //SILENT_PACKER_ALL_ELF_LOADERS_INFOS_H

```

`includes/STUB/all_loaders.h`:

```h
//
// Created by silentvoid on 4/2/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_ALL_LOADERS_H
#define SILENT_PACKER_ALL_LOADERS_H

#include "all_elf_loaders.h"

#include "all_pe_loaders.h"

#endif //SILENT_PACKER_ALL_LOADERS_H

```

`includes/STUB/all_pe_loaders.h`:

```h
//
// Created by silentvoid on 4/2/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_ALL_PE_LOADERS_H
#define SILENT_PACKER_ALL_PE_LOADERS_H

#include "amd64_xor_win_pe_loader.h"
#include "i386_xor_win_pe_loader.h"

#include "amd64_aes_128_ecb_win_pe_loader.h"
#include "i386_aes_128_ecb_win_pe_loader.h"

#endif //SILENT_PACKER_ALL_PE_LOADERS_H

```

`includes/STUB/all_pe_loaders_infos.h`:

```h
//
// Created by silentvoid on 4/2/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_ALL_PE_LOADERS_INFOS_H
#define SILENT_PACKER_ALL_PE_LOADERS_INFOS_H

#define NO_PAYLOAD
#include "all_pe_loaders.h"

#endif //SILENT_PACKER_ALL_PE_LOADERS_INFOS_H

```

`includes/STUB/amd64_aes_128_ecb_linux_elf_loader.h`:

```h
//
// Created by silentvoid on 4/10/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_AMD64_AES_128_ECB_LINUX_ELF_LOADER_H
#define SILENT_PACKER_AMD64_AES_128_ECB_LINUX_ELF_LOADER_H

#define AMD64_AES_128_ECB_LINUX_ELF_LOADER_INFOS_SIZE 40
#define AMD64_AES_128_ECB_LINUX_ELF_LOADER_SIZE 480

#ifndef NO_PAYLOAD
unsigned char amd64_aes_128_ecb_linux_elf_loader_stub[] = {
        0x9c, 0x50, 0x57, 0x56, 0x54, 0x52, 0x51, 0xb8, 0x01, 0x00, 0x00, 0x00, 0x48, 0x89, 0xc7, 0x48,
0x8d, 0x35, 0x3c, 0x00, 0x00, 0x00, 0xba, 0x10, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x4c, 0x8d, 0x25,
0xdc, 0xff, 0xff, 0xff, 0x4c, 0x2b, 0x25, 0xad, 0x01, 0x00, 0x00, 0xeb, 0x35, 0x66, 0x0f, 0x70,
0xd2, 0xff, 0xc5, 0xe1, 0x73, 0xf9, 0x04, 0x66, 0x0f, 0xef, 0xcb, 0xc5, 0xe1, 0x73, 0xf9, 0x04,
0x66, 0x0f, 0xef, 0xcb, 0xc5, 0xe1, 0x73, 0xf9, 0x04, 0x66, 0x0f, 0xef, 0xcb, 0x66, 0x0f, 0xef,
0xca, 0xc3, 0x5b, 0x55, 0x6e, 0x70, 0x61, 0x63, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x2e, 0x2e, 0x5d,
0x0a, 0x00, 0xf3, 0x0f, 0x6f, 0x0d, 0x4e, 0x01, 0x00, 0x00, 0x48, 0x8b, 0x05, 0x57, 0x01, 0x00,
0x00, 0x4c, 0x01, 0xe0, 0x48, 0x8b, 0x15, 0x55, 0x01, 0x00, 0x00, 0xf3, 0x0f, 0x6f, 0xc1, 0x66,
0x0f, 0x3a, 0xdf, 0xd1, 0x01, 0xe8, 0xa3, 0xff, 0xff, 0xff, 0xf3, 0x0f, 0x6f, 0xe1, 0x66, 0x0f,
0x3a, 0xdf, 0xd1, 0x02, 0xe8, 0x94, 0xff, 0xff, 0xff, 0xf3, 0x0f, 0x6f, 0xe9, 0x66, 0x0f, 0x3a,
0xdf, 0xd1, 0x04, 0xe8, 0x85, 0xff, 0xff, 0xff, 0xf3, 0x0f, 0x6f, 0xf1, 0x66, 0x0f, 0x3a, 0xdf,
0xd1, 0x08, 0xe8, 0x76, 0xff, 0xff, 0xff, 0xf3, 0x0f, 0x6f, 0xf9, 0x66, 0x0f, 0x3a, 0xdf, 0xd1,
0x10, 0xe8, 0x67, 0xff, 0xff, 0xff, 0xf3, 0x44, 0x0f, 0x6f, 0xc1, 0x66, 0x0f, 0x3a, 0xdf, 0xd1,
0x20, 0xe8, 0x57, 0xff, 0xff, 0xff, 0xf3, 0x44, 0x0f, 0x6f, 0xc9, 0x66, 0x0f, 0x3a, 0xdf, 0xd1,
0x40, 0xe8, 0x47, 0xff, 0xff, 0xff, 0xf3, 0x44, 0x0f, 0x6f, 0xd1, 0x66, 0x0f, 0x3a, 0xdf, 0xd1,
0x80, 0xe8, 0x37, 0xff, 0xff, 0xff, 0xf3, 0x44, 0x0f, 0x6f, 0xd9, 0x66, 0x0f, 0x3a, 0xdf, 0xd1,
0x1b, 0xe8, 0x27, 0xff, 0xff, 0xff, 0xf3, 0x44, 0x0f, 0x6f, 0xe1, 0x66, 0x0f, 0x3a, 0xdf, 0xd1,
0x36, 0xe8, 0x17, 0xff, 0xff, 0xff, 0xf3, 0x44, 0x0f, 0x6f, 0xe9, 0x66, 0x0f, 0x38, 0xdb, 0xe4,
0x66, 0x0f, 0x38, 0xdb, 0xed, 0x66, 0x0f, 0x38, 0xdb, 0xf6, 0x66, 0x0f, 0x38, 0xdb, 0xff, 0x66,
0x45, 0x0f, 0x38, 0xdb, 0xc0, 0x66, 0x45, 0x0f, 0x38, 0xdb, 0xc9, 0x66, 0x45, 0x0f, 0x38, 0xdb,
0xd2, 0x66, 0x45, 0x0f, 0x38, 0xdb, 0xdb, 0x66, 0x45, 0x0f, 0x38, 0xdb, 0xe4, 0x4d, 0x31, 0xc0,
0x48, 0x83, 0xea, 0x10, 0xf3, 0x46, 0x0f, 0x6f, 0x3c, 0x00, 0x66, 0x45, 0x0f, 0xef, 0xfd, 0x66,
0x45, 0x0f, 0x38, 0xde, 0xfc, 0x66, 0x45, 0x0f, 0x38, 0xde, 0xfb, 0x66, 0x45, 0x0f, 0x38, 0xde,
0xfa, 0x66, 0x45, 0x0f, 0x38, 0xde, 0xf9, 0x66, 0x45, 0x0f, 0x38, 0xde, 0xf8, 0x66, 0x44, 0x0f,
0x38, 0xde, 0xff, 0x66, 0x44, 0x0f, 0x38, 0xde, 0xfe, 0x66, 0x44, 0x0f, 0x38, 0xde, 0xfd, 0x66,
0x44, 0x0f, 0x38, 0xde, 0xfc, 0x66, 0x44, 0x0f, 0x38, 0xdf, 0xf8, 0xf3, 0x46, 0x0f, 0x7f, 0x3c,
0x00, 0x49, 0x83, 0xc0, 0x10, 0x4c, 0x39, 0xc2, 0x7e, 0x02, 0xeb, 0xa8, 0x59, 0x5a, 0x5c, 0x5e,
0x5f, 0x58, 0x9d, 0xe9, 0xfb, 0xff, 0xff, 0xff, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc,
0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee
};
#endif //NO_PAYLOAD

#endif //SILENT_PACKER_AMD64_AES_128_ECB_LINUX_ELF_LOADER_H

```

`includes/STUB/amd64_aes_128_ecb_win_pe_loader.h`:

```h
//
// Created by silentvoid on 4/10/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_AMD64_AES_128_ECB_WIN_PE_LOADER_H
#define SILENT_PACKER_AMD64_AES_128_ECB_WIN_PE_LOADER_H

#define AMD64_AES_128_ECB_WIN_PE_LOADER_INFOS_SIZE 40
#define AMD64_AES_128_ECB_WIN_PE_LOADER_SIZE 458

#ifndef NO_PAYLOAD
unsigned char amd64_aes_128_ecb_win_pe_loader_stub[] = {
        0x9c, 0x50, 0x57, 0x56, 0x54, 0x52, 0x51, 0x4c, 0x8d, 0x25, 0xf2, 0xff, 0xff, 0xff, 0x4c, 0x2b,
        0x25, 0xad, 0x01, 0x00, 0x00, 0xeb, 0x35, 0x66, 0x0f, 0x70, 0xd2, 0xff, 0xc5, 0xe1, 0x73, 0xf9,
        0x04, 0x66, 0x0f, 0xef, 0xcb, 0xc5, 0xe1, 0x73, 0xf9, 0x04, 0x66, 0x0f, 0xef, 0xcb, 0xc5, 0xe1,
        0x73, 0xf9, 0x04, 0x66, 0x0f, 0xef, 0xcb, 0x66, 0x0f, 0xef, 0xca, 0xc3, 0x5b, 0x55, 0x6e, 0x70,
        0x61, 0x63, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x2e, 0x2e, 0x5d, 0x0a, 0x00, 0xf3, 0x0f, 0x6f, 0x0d,
        0x4e, 0x01, 0x00, 0x00, 0x48, 0x8b, 0x05, 0x57, 0x01, 0x00, 0x00, 0x4c, 0x01, 0xe0, 0x48, 0x8b,
        0x15, 0x55, 0x01, 0x00, 0x00, 0xf3, 0x0f, 0x6f, 0xc1, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x01, 0xe8,
        0xa3, 0xff, 0xff, 0xff, 0xf3, 0x0f, 0x6f, 0xe1, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x02, 0xe8, 0x94,
        0xff, 0xff, 0xff, 0xf3, 0x0f, 0x6f, 0xe9, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x04, 0xe8, 0x85, 0xff,
        0xff, 0xff, 0xf3, 0x0f, 0x6f, 0xf1, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x08, 0xe8, 0x76, 0xff, 0xff,
        0xff, 0xf3, 0x0f, 0x6f, 0xf9, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x10, 0xe8, 0x67, 0xff, 0xff, 0xff,
        0xf3, 0x44, 0x0f, 0x6f, 0xc1, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x20, 0xe8, 0x57, 0xff, 0xff, 0xff,
        0xf3, 0x44, 0x0f, 0x6f, 0xc9, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x40, 0xe8, 0x47, 0xff, 0xff, 0xff,
        0xf3, 0x44, 0x0f, 0x6f, 0xd1, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x80, 0xe8, 0x37, 0xff, 0xff, 0xff,
        0xf3, 0x44, 0x0f, 0x6f, 0xd9, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x1b, 0xe8, 0x27, 0xff, 0xff, 0xff,
        0xf3, 0x44, 0x0f, 0x6f, 0xe1, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x36, 0xe8, 0x17, 0xff, 0xff, 0xff,
        0xf3, 0x44, 0x0f, 0x6f, 0xe9, 0x66, 0x0f, 0x38, 0xdb, 0xe4, 0x66, 0x0f, 0x38, 0xdb, 0xed, 0x66,
        0x0f, 0x38, 0xdb, 0xf6, 0x66, 0x0f, 0x38, 0xdb, 0xff, 0x66, 0x45, 0x0f, 0x38, 0xdb, 0xc0, 0x66,
        0x45, 0x0f, 0x38, 0xdb, 0xc9, 0x66, 0x45, 0x0f, 0x38, 0xdb, 0xd2, 0x66, 0x45, 0x0f, 0x38, 0xdb,
        0xdb, 0x66, 0x45, 0x0f, 0x38, 0xdb, 0xe4, 0x4d, 0x31, 0xc0, 0x48, 0x83, 0xea, 0x10, 0xf3, 0x46,
        0x0f, 0x6f, 0x3c, 0x00, 0x66, 0x45, 0x0f, 0xef, 0xfd, 0x66, 0x45, 0x0f, 0x38, 0xde, 0xfc, 0x66,
        0x45, 0x0f, 0x38, 0xde, 0xfb, 0x66, 0x45, 0x0f, 0x38, 0xde, 0xfa, 0x66, 0x45, 0x0f, 0x38, 0xde,
        0xf9, 0x66, 0x45, 0x0f, 0x38, 0xde, 0xf8, 0x66, 0x44, 0x0f, 0x38, 0xde, 0xff, 0x66, 0x44, 0x0f,
        0x38, 0xde, 0xfe, 0x66, 0x44, 0x0f, 0x38, 0xde, 0xfd, 0x66, 0x44, 0x0f, 0x38, 0xde, 0xfc, 0x66,
        0x44, 0x0f, 0x38, 0xdf, 0xf8, 0xf3, 0x46, 0x0f, 0x7f, 0x3c, 0x00, 0x49, 0x83, 0xc0, 0x10, 0x4c,
        0x39, 0xc2, 0x7e, 0x02, 0xeb, 0xa8, 0x59, 0x5a, 0x5c, 0x5e, 0x5f, 0x58, 0x9d, 0xe9, 0xfb, 0xff,
        0xff, 0xff, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
        0xbb, 0xbb, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
        0xdd, 0xdd, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee
};
#endif //NO_PAYLOAD

#endif //SILENT_PACKER_AMD64_AES_128_ECB_WIN_PE_LOADER_H

```

`includes/STUB/amd64_xor_linux_elf_loader.h`:

```h
//
// Created by silentvoid on 4/2/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_AMD64_XOR_LINUX_ELF_LOADER_H
#define SILENT_PACKER_AMD64_XOR_LINUX_ELF_LOADER_H

#define AMD64_XOR_LINUX_ELF_LOADER_INFOS_SIZE 32
#define AMD64_XOR_LINUX_ELF_LOADER_SIZE 146

#ifndef NO_PAYLOAD
unsigned char amd64_xor_linux_elf_loader_stub[] = {
        0x9c, 0x50, 0x57, 0x56, 0x54, 0x52, 0x51, 0xb8, 0x01, 0x00, 0x00, 0x00, 0x48, 0x89, 0xc7, 0x48,
0x8d, 0x35, 0x17, 0x00, 0x00, 0x00, 0xba, 0x10, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x4c, 0x8d, 0x25,
0xdc, 0xff, 0xff, 0xff, 0x4c, 0x2b, 0x25, 0x5f, 0x00, 0x00, 0x00, 0xeb, 0x10, 0x5b, 0x55, 0x6e,
0x70, 0x61, 0x63, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x2e, 0x2e, 0x5d, 0x0a, 0x00, 0x48, 0x8b, 0x05,
0x36, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x0d, 0x37, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x15, 0x20, 0x00,
0x00, 0x00, 0x4c, 0x01, 0xe0, 0x48, 0x01, 0xc1, 0x30, 0x10, 0x48, 0xc1, 0xca, 0x08, 0x48, 0xff,
0xc0, 0x48, 0x39, 0xc8, 0x75, 0xf2, 0x59, 0x5a, 0x5c, 0x5e, 0x5f, 0x58, 0x9d, 0xe9, 0xfb, 0xff,
0xff, 0xff, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
0xbb, 0xbb, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
0xdd, 0xdd
};
#endif // NO_PAYLOAD

#endif //SILENT_PACKER_AMD64_XOR_LINUX_ELF_LOADER_H

```

`includes/STUB/amd64_xor_win_pe_loader.h`:

```h
//
// Created by silentvoid on 4/2/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_AMD64_XOR_WIN_PE_LOADER_H
#define SILENT_PACKER_AMD64_XOR_WIN_PE_LOADER_H

#define AMD64_XOR_WIN_PE_LOADER_INFOS_SIZE 32
#define AMD64_XOR_WIN_PE_LOADER_SIZE 124

#ifndef NO_PAYLOAD
unsigned char amd64_xor_win_pe_loader_stub[] = {
        0x9c, 0x50, 0x57, 0x56, 0x54, 0x52, 0x51, 0x4c, 0x8d, 0x25, 0xf2, 0xff, 0xff, 0xff, 0x4c, 0x2b,
        0x25, 0x5f, 0x00, 0x00, 0x00, 0xeb, 0x10, 0x5b, 0x55, 0x6e, 0x70, 0x61, 0x63, 0x6b, 0x69, 0x6e,
        0x67, 0x2e, 0x2e, 0x2e, 0x5d, 0x0a, 0x00, 0x48, 0x8b, 0x05, 0x36, 0x00, 0x00, 0x00, 0x48, 0x8b,
        0x0d, 0x37, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x15, 0x20, 0x00, 0x00, 0x00, 0x4c, 0x01, 0xe0, 0x48,
        0x01, 0xc1, 0x30, 0x10, 0x48, 0xc1, 0xca, 0x08, 0x48, 0xff, 0xc0, 0x48, 0x39, 0xc8, 0x75, 0xf2,
        0x59, 0x5a, 0x5c, 0x5e, 0x5f, 0x58, 0x9d, 0xe9, 0xfb, 0xff, 0xff, 0xff, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xcc, 0xcc, 0xcc, 0xcc,
        0xcc, 0xcc, 0xcc, 0xcc, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd
};
#endif // NO_PAYLOAD

#endif //SILENT_PACKER_AMD64_XOR_WIN_PE_LOADER_H

```

`includes/STUB/i386_aes_128_ecb_linux_elf_loader.h`:

```h
//
// Created by silentvoid on 4/10/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_I386_AES_128_ECB_LINUX_ELF_LOADER_H
#define SILENT_PACKER_I386_AES_128_ECB_LINUX_ELF_LOADER_H

#define I386_AES_128_ECB_LINUX_ELF_LOADER_INFOS_SIZE 28
#define I386_AES_128_ECB_LINUX_ELF_LOADER_SIZE 658

#ifndef NO_PAYLOAD
unsigned char i386_aes_128_ecb_linux_elf_loader_stub[] = {
        0x50, 0x57, 0x56, 0x54, 0x52, 0x51, 0x53, 0xe8, 0x54, 0x00, 0x00, 0x00, 0x83, 0xea, 0xfe, 0x89,
0xd1, 0xba, 0x10, 0x00, 0x00, 0x00, 0xbb, 0x01, 0x00, 0x00, 0x00, 0xb8, 0x04, 0x00, 0x00, 0x00,
0xcd, 0x80, 0xe8, 0x39, 0x00, 0x00, 0x00, 0x83, 0xea, 0x65, 0x89, 0xd3, 0xe8, 0x2f, 0x00, 0x00,
0x00, 0x81, 0xea, 0xd7, 0xfd, 0xff, 0xff, 0x2b, 0x1a, 0xeb, 0x3c, 0x66, 0x0f, 0x70, 0xd2, 0xff,
0xc5, 0xe1, 0x73, 0xf9, 0x04, 0x66, 0x0f, 0xef, 0xcb, 0xc5, 0xe1, 0x73, 0xf9, 0x04, 0x66, 0x0f,
0xef, 0xcb, 0xc5, 0xe1, 0x73, 0xf9, 0x04, 0x66, 0x0f, 0xef, 0xcb, 0x66, 0x0f, 0xef, 0xca, 0xc3,
0xe8, 0x00, 0x00, 0x00, 0x00, 0x5a, 0xc3, 0x5b, 0x55, 0x6e, 0x70, 0x61, 0x63, 0x6b, 0x69, 0x6e,
0x67, 0x2e, 0x2e, 0x2e, 0x5d, 0x0a, 0x00, 0xe8, 0xe4, 0xff, 0xff, 0xff, 0x81, 0xea, 0xdf, 0xfd,
0xff, 0xff, 0x8b, 0x02, 0x01, 0xd8, 0xe8, 0xd5, 0xff, 0xff, 0xff, 0x81, 0xea, 0xef, 0xfd, 0xff,
0xff, 0xf3, 0x0f, 0x6f, 0x0a, 0xe8, 0xc6, 0xff, 0xff, 0xff, 0x81, 0xea, 0xdb, 0xfd, 0xff, 0xff,
0x8b, 0x12, 0xf3, 0x0f, 0x6f, 0xc1, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x01, 0xe8, 0x8a, 0xff, 0xff,
0xff, 0xf3, 0x0f, 0x6f, 0xe1, 0x66, 0x0f, 0x38, 0xdb, 0xe4, 0x83, 0xec, 0x10, 0xf3, 0x0f, 0x7f,
0x24, 0x24, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x02, 0xe8, 0x6e, 0xff, 0xff, 0xff, 0xf3, 0x0f, 0x6f,
0xe1, 0x66, 0x0f, 0x38, 0xdb, 0xe4, 0x83, 0xec, 0x10, 0xf3, 0x0f, 0x7f, 0x24, 0x24, 0x66, 0x0f,
0x3a, 0xdf, 0xd1, 0x04, 0xe8, 0x52, 0xff, 0xff, 0xff, 0xf3, 0x0f, 0x6f, 0xe1, 0x66, 0x0f, 0x38,
0xdb, 0xe4, 0x83, 0xec, 0x10, 0xf3, 0x0f, 0x7f, 0x24, 0x24, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x08,
0xe8, 0x36, 0xff, 0xff, 0xff, 0xf3, 0x0f, 0x6f, 0xe1, 0x66, 0x0f, 0x38, 0xdb, 0xe4, 0x83, 0xec,
0x10, 0xf3, 0x0f, 0x7f, 0x24, 0x24, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x10, 0xe8, 0x1a, 0xff, 0xff,
0xff, 0xf3, 0x0f, 0x6f, 0xe1, 0x66, 0x0f, 0x38, 0xdb, 0xe4, 0x83, 0xec, 0x10, 0xf3, 0x0f, 0x7f,
0x24, 0x24, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x20, 0xe8, 0xfe, 0xfe, 0xff, 0xff, 0xf3, 0x0f, 0x6f,
0xe1, 0x66, 0x0f, 0x38, 0xdb, 0xe4, 0x83, 0xec, 0x10, 0xf3, 0x0f, 0x7f, 0x24, 0x24, 0x66, 0x0f,
0x3a, 0xdf, 0xd1, 0x40, 0xe8, 0xe2, 0xfe, 0xff, 0xff, 0xf3, 0x0f, 0x6f, 0xe1, 0x66, 0x0f, 0x38,
0xdb, 0xe4, 0x83, 0xec, 0x10, 0xf3, 0x0f, 0x7f, 0x24, 0x24, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x80,
0xe8, 0xc6, 0xfe, 0xff, 0xff, 0xf3, 0x0f, 0x6f, 0xe1, 0x66, 0x0f, 0x38, 0xdb, 0xe4, 0x83, 0xec,
0x10, 0xf3, 0x0f, 0x7f, 0x24, 0x24, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x1b, 0xe8, 0xaa, 0xfe, 0xff,
0xff, 0xf3, 0x0f, 0x6f, 0xe1, 0x66, 0x0f, 0x38, 0xdb, 0xe4, 0x83, 0xec, 0x10, 0xf3, 0x0f, 0x7f,
0x24, 0x24, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x36, 0xe8, 0x8e, 0xfe, 0xff, 0xff, 0xf3, 0x0f, 0x6f,
0xe1, 0x83, 0xec, 0x10, 0xf3, 0x0f, 0x7f, 0x24, 0x24, 0x31, 0xc9, 0x83, 0xea, 0x10, 0xf3, 0x0f,
0x6f, 0xc8, 0xf3, 0x0f, 0x6f, 0x3c, 0x08, 0xf3, 0x0f, 0x6f, 0x24, 0x24, 0x83, 0xc4, 0x10, 0x66,
0x0f, 0xef, 0xfc, 0xf3, 0x0f, 0x6f, 0x24, 0x24, 0x83, 0xc4, 0x10, 0x66, 0x0f, 0x38, 0xde, 0xfc,
0xf3, 0x0f, 0x6f, 0x24, 0x24, 0x83, 0xc4, 0x10, 0x66, 0x0f, 0x38, 0xde, 0xfc, 0xf3, 0x0f, 0x6f,
0x24, 0x24, 0x83, 0xc4, 0x10, 0x66, 0x0f, 0x38, 0xde, 0xfc, 0xf3, 0x0f, 0x6f, 0x24, 0x24, 0x83,
0xc4, 0x10, 0x66, 0x0f, 0x38, 0xde, 0xfc, 0xf3, 0x0f, 0x6f, 0x24, 0x24, 0x83, 0xc4, 0x10, 0x66,
0x0f, 0x38, 0xde, 0xfc, 0xf3, 0x0f, 0x6f, 0x24, 0x24, 0x83, 0xc4, 0x10, 0x66, 0x0f, 0x38, 0xde,
0xfc, 0xf3, 0x0f, 0x6f, 0x24, 0x24, 0x83, 0xc4, 0x10, 0x66, 0x0f, 0x38, 0xde, 0xfc, 0xf3, 0x0f,
0x6f, 0x24, 0x24, 0x83, 0xc4, 0x10, 0x66, 0x0f, 0x38, 0xde, 0xfc, 0xf3, 0x0f, 0x6f, 0x24, 0x24,
0x83, 0xc4, 0x10, 0x66, 0x0f, 0x38, 0xde, 0xfc, 0x66, 0x0f, 0x38, 0xdf, 0xf8, 0xf3, 0x0f, 0x7f,
0x3c, 0x08, 0x81, 0xec, 0xa0, 0x00, 0x00, 0x00, 0x83, 0xc1, 0x10, 0x39, 0xca, 0x7e, 0x05, 0xe9,
0x5a, 0xff, 0xff, 0xff, 0x81, 0xc4, 0xa0, 0x00, 0x00, 0x00, 0x5b, 0x59, 0x5a, 0x5c, 0x5e, 0x5f,
0x58, 0xe9, 0xfb, 0xff, 0xff, 0xff, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xcc, 0xcc, 0xcc, 0xcc, 0xdd, 0xdd, 0xdd, 0xdd, 0xee, 0xee,
0xee, 0xee
};
#endif //NO_PAYLOAD

#endif //SILENT_PACKER_I386_AES_128_ECB_LINUX_ELF_LOADER_H

```

`includes/STUB/i386_aes_128_ecb_win_pe_loader.h`:

```h
//
// Created by silentvoid on 4/10/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_I386_AES_128_ECB_WIN_PE_LOADER_H
#define SILENT_PACKER_I386_AES_128_ECB_WIN_PE_LOADER_H

#define I386_AES_128_ECB_WIN_PE_LOADER_INFOS_SIZE 28
#define I386_AES_128_ECB_WIN_PE_LOADER_SIZE 631

#ifndef NO_PAYLOAD
unsigned char i386_aes_128_ecb_win_pe_loader_stub[] = {
        0x50, 0x57, 0x56, 0x54, 0x52, 0x51, 0x53, 0xe8, 0x39, 0x00, 0x00, 0x00, 0x83, 0xea, 0x4a, 0x89,
        0xd3, 0xe8, 0x2f, 0x00, 0x00, 0x00, 0x81, 0xea, 0xd7, 0xfd, 0xff, 0xff, 0x2b, 0x1a, 0xeb, 0x3c,
        0x66, 0x0f, 0x70, 0xd2, 0xff, 0xc5, 0xe1, 0x73, 0xf9, 0x04, 0x66, 0x0f, 0xef, 0xcb, 0xc5, 0xe1,
        0x73, 0xf9, 0x04, 0x66, 0x0f, 0xef, 0xcb, 0xc5, 0xe1, 0x73, 0xf9, 0x04, 0x66, 0x0f, 0xef, 0xcb,
        0x66, 0x0f, 0xef, 0xca, 0xc3, 0xe8, 0x00, 0x00, 0x00, 0x00, 0x5a, 0xc3, 0x5b, 0x55, 0x6e, 0x70,
        0x61, 0x63, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x2e, 0x2e, 0x5d, 0x0a, 0x00, 0xe8, 0xe4, 0xff, 0xff,
        0xff, 0x81, 0xea, 0xdf, 0xfd, 0xff, 0xff, 0x8b, 0x02, 0x01, 0xd8, 0xe8, 0xd5, 0xff, 0xff, 0xff,
        0x81, 0xea, 0xef, 0xfd, 0xff, 0xff, 0xf3, 0x0f, 0x6f, 0x0a, 0xe8, 0xc6, 0xff, 0xff, 0xff, 0x81,
        0xea, 0xdb, 0xfd, 0xff, 0xff, 0x8b, 0x12, 0xf3, 0x0f, 0x6f, 0xc1, 0x66, 0x0f, 0x3a, 0xdf, 0xd1,
        0x01, 0xe8, 0x8a, 0xff, 0xff, 0xff, 0xf3, 0x0f, 0x6f, 0xe1, 0x66, 0x0f, 0x38, 0xdb, 0xe4, 0x83,
        0xec, 0x10, 0xf3, 0x0f, 0x7f, 0x24, 0x24, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x02, 0xe8, 0x6e, 0xff,
        0xff, 0xff, 0xf3, 0x0f, 0x6f, 0xe1, 0x66, 0x0f, 0x38, 0xdb, 0xe4, 0x83, 0xec, 0x10, 0xf3, 0x0f,
        0x7f, 0x24, 0x24, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x04, 0xe8, 0x52, 0xff, 0xff, 0xff, 0xf3, 0x0f,
        0x6f, 0xe1, 0x66, 0x0f, 0x38, 0xdb, 0xe4, 0x83, 0xec, 0x10, 0xf3, 0x0f, 0x7f, 0x24, 0x24, 0x66,
        0x0f, 0x3a, 0xdf, 0xd1, 0x08, 0xe8, 0x36, 0xff, 0xff, 0xff, 0xf3, 0x0f, 0x6f, 0xe1, 0x66, 0x0f,
        0x38, 0xdb, 0xe4, 0x83, 0xec, 0x10, 0xf3, 0x0f, 0x7f, 0x24, 0x24, 0x66, 0x0f, 0x3a, 0xdf, 0xd1,
        0x10, 0xe8, 0x1a, 0xff, 0xff, 0xff, 0xf3, 0x0f, 0x6f, 0xe1, 0x66, 0x0f, 0x38, 0xdb, 0xe4, 0x83,
        0xec, 0x10, 0xf3, 0x0f, 0x7f, 0x24, 0x24, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x20, 0xe8, 0xfe, 0xfe,
        0xff, 0xff, 0xf3, 0x0f, 0x6f, 0xe1, 0x66, 0x0f, 0x38, 0xdb, 0xe4, 0x83, 0xec, 0x10, 0xf3, 0x0f,
        0x7f, 0x24, 0x24, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x40, 0xe8, 0xe2, 0xfe, 0xff, 0xff, 0xf3, 0x0f,
        0x6f, 0xe1, 0x66, 0x0f, 0x38, 0xdb, 0xe4, 0x83, 0xec, 0x10, 0xf3, 0x0f, 0x7f, 0x24, 0x24, 0x66,
        0x0f, 0x3a, 0xdf, 0xd1, 0x80, 0xe8, 0xc6, 0xfe, 0xff, 0xff, 0xf3, 0x0f, 0x6f, 0xe1, 0x66, 0x0f,
        0x38, 0xdb, 0xe4, 0x83, 0xec, 0x10, 0xf3, 0x0f, 0x7f, 0x24, 0x24, 0x66, 0x0f, 0x3a, 0xdf, 0xd1,
        0x1b, 0xe8, 0xaa, 0xfe, 0xff, 0xff, 0xf3, 0x0f, 0x6f, 0xe1, 0x66, 0x0f, 0x38, 0xdb, 0xe4, 0x83,
        0xec, 0x10, 0xf3, 0x0f, 0x7f, 0x24, 0x24, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x36, 0xe8, 0x8e, 0xfe,
        0xff, 0xff, 0xf3, 0x0f, 0x6f, 0xe1, 0x83, 0xec, 0x10, 0xf3, 0x0f, 0x7f, 0x24, 0x24, 0x31, 0xc9,
        0x83, 0xea, 0x10, 0xf3, 0x0f, 0x6f, 0xc8, 0xf3, 0x0f, 0x6f, 0x3c, 0x08, 0xf3, 0x0f, 0x6f, 0x24,
        0x24, 0x83, 0xc4, 0x10, 0x66, 0x0f, 0xef, 0xfc, 0xf3, 0x0f, 0x6f, 0x24, 0x24, 0x83, 0xc4, 0x10,
        0x66, 0x0f, 0x38, 0xde, 0xfc, 0xf3, 0x0f, 0x6f, 0x24, 0x24, 0x83, 0xc4, 0x10, 0x66, 0x0f, 0x38,
        0xde, 0xfc, 0xf3, 0x0f, 0x6f, 0x24, 0x24, 0x83, 0xc4, 0x10, 0x66, 0x0f, 0x38, 0xde, 0xfc, 0xf3,
        0x0f, 0x6f, 0x24, 0x24, 0x83, 0xc4, 0x10, 0x66, 0x0f, 0x38, 0xde, 0xfc, 0xf3, 0x0f, 0x6f, 0x24,
        0x24, 0x83, 0xc4, 0x10, 0x66, 0x0f, 0x38, 0xde, 0xfc, 0xf3, 0x0f, 0x6f, 0x24, 0x24, 0x83, 0xc4,
        0x10, 0x66, 0x0f, 0x38, 0xde, 0xfc, 0xf3, 0x0f, 0x6f, 0x24, 0x24, 0x83, 0xc4, 0x10, 0x66, 0x0f,
        0x38, 0xde, 0xfc, 0xf3, 0x0f, 0x6f, 0x24, 0x24, 0x83, 0xc4, 0x10, 0x66, 0x0f, 0x38, 0xde, 0xfc,
        0xf3, 0x0f, 0x6f, 0x24, 0x24, 0x83, 0xc4, 0x10, 0x66, 0x0f, 0x38, 0xde, 0xfc, 0x66, 0x0f, 0x38,
        0xdf, 0xf8, 0xf3, 0x0f, 0x7f, 0x3c, 0x08, 0x81, 0xec, 0xa0, 0x00, 0x00, 0x00, 0x83, 0xc1, 0x10,
        0x39, 0xca, 0x7e, 0x05, 0xe9, 0x5a, 0xff, 0xff, 0xff, 0x81, 0xc4, 0xa0, 0x00, 0x00, 0x00, 0x5b,
        0x59, 0x5a, 0x5c, 0x5e, 0x5f, 0x58, 0xe9, 0xfb, 0xff, 0xff, 0xff, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xcc, 0xcc, 0xcc, 0xcc, 0xdd,
        0xdd, 0xdd, 0xdd, 0xee, 0xee, 0xee, 0xee
};
#endif //NO_PAYLOAD

#endif //SILENT_PACKER_I386_AES_128_ECB_WIN_PE_LOADER_H

```

`includes/STUB/i386_xor_linux_elf_loader.h`:

```h
//
// Created by silentvoid on 4/2/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_I386_XOR_LINUX_LOADER_H
#define SILENT_PACKER_I386_XOR_LINUX_LOADER_H

#define I386_XOR_LINUX_ELF_LOADER_INFOS_SIZE 16
#define I386_XOR_LINUX_ELF_LOADER_SIZE 151

#ifndef NO_PAYLOAD
unsigned char i386_xor_linux_elf_loader_stub[] = {
        0x50, 0x57, 0x56, 0x54, 0x52, 0x51, 0x53, 0xe8, 0x3c, 0x00, 0x00, 0x00, 0x83, 0xea, 0x15, 0x89,
0xd1, 0xba, 0x10, 0x00, 0x00, 0x00, 0xbb, 0x01, 0x00, 0x00, 0x00, 0xb8, 0x04, 0x00, 0x00, 0x00,
0xcd, 0x80, 0xe8, 0x21, 0x00, 0x00, 0x00, 0x83, 0xea, 0x4d, 0x89, 0xd3, 0xe8, 0x17, 0x00, 0x00,
0x00, 0x83, 0xea, 0xba, 0x2b, 0x1a, 0xeb, 0x17, 0x5b, 0x55, 0x6e, 0x70, 0x61, 0x63, 0x6b, 0x69,
0x6e, 0x67, 0x2e, 0x2e, 0x2e, 0x5d, 0x0a, 0x00, 0xe8, 0x00, 0x00, 0x00, 0x00, 0x5a, 0xc3, 0xe8,
0xf4, 0xff, 0xff, 0xff, 0x83, 0xea, 0xc2, 0x8b, 0x02, 0xe8, 0xea, 0xff, 0xff, 0xff, 0x83, 0xea,
0xbe, 0x8b, 0x0a, 0xe8, 0xe0, 0xff, 0xff, 0xff, 0x83, 0xea, 0xc6, 0x8b, 0x12, 0x01, 0xd8, 0x01,
0xc1, 0x30, 0x10, 0xc1, 0xca, 0x04, 0x40, 0x39, 0xc8, 0x75, 0xf6, 0x5b, 0x59, 0x5a, 0x5c, 0x5e,
0x5f, 0x58, 0xe9, 0xfb, 0xff, 0xff, 0x0f, 0xaa, 0xaa, 0xaa, 0xaa, 0xbb, 0xbb, 0xbb, 0xbb, 0xcc,
0xcc, 0xcc, 0xcc, 0xdd, 0xdd, 0xdd, 0xdd
};
#endif // NO_PAYLOAD

#endif //SILENT_PACKER_I386_XOR_LINUX_LOADER_H
```

`includes/STUB/i386_xor_win_pe_loader.h`:

```h
//
// Created by silentvoid on 4/2/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_I386_XOR_WIN_PE_LOADER_H
#define SILENT_PACKER_I386_XOR_WIN_PE_LOADER_H

#define I386_XOR_WIN_PE_LOADER_INFOS_SIZE 16
#define I386_XOR_WIN_PE_LOADER_SIZE 124

#ifndef NO_PAYLOAD
unsigned char i386_xor_win_pe_loader_stub[] = {
        0x50, 0x57, 0x56, 0x54, 0x52, 0x51, 0x53, 0xe8, 0x21, 0x00, 0x00, 0x00, 0x83, 0xea, 0x32, 0x89,
        0xd3, 0xe8, 0x17, 0x00, 0x00, 0x00, 0x83, 0xea, 0xba, 0x2b, 0x1a, 0xeb, 0x17, 0x5b, 0x55, 0x6e,
        0x70, 0x61, 0x63, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x2e, 0x2e, 0x5d, 0x0a, 0x00, 0xe8, 0x00, 0x00,
        0x00, 0x00, 0x5a, 0xc3, 0xe8, 0xf4, 0xff, 0xff, 0xff, 0x83, 0xea, 0xc2, 0x8b, 0x02, 0xe8, 0xea,
        0xff, 0xff, 0xff, 0x83, 0xea, 0xbe, 0x8b, 0x0a, 0xe8, 0xe0, 0xff, 0xff, 0xff, 0x83, 0xea, 0xc6,
        0x8b, 0x12, 0x01, 0xd8, 0x01, 0xc1, 0x30, 0x10, 0xc1, 0xca, 0x04, 0x40, 0x39, 0xc8, 0x75, 0xf6,
        0x5b, 0x59, 0x5a, 0x5c, 0x5e, 0x5f, 0x58, 0xe9, 0xfb, 0xff, 0xff, 0x0f, 0xaa, 0xaa, 0xaa, 0xaa,
        0xbb, 0xbb, 0xbb, 0xbb, 0xcc, 0xcc, 0xcc, 0xcc, 0xdd, 0xdd, 0xdd, 0xdd
};
#endif // NO_PAYLOAD

#endif //SILENT_PACKER_I386_XOR_WIN_PE_LOADER_H

```

`includes/common/aes_128_ecb_encryption.h`:

```h
//
// Created by silentvoid on 4/10/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_AES_128_ECB_ENCRYPTION_H
#define SILENT_PACKER_AES_128_ECB_ENCRYPTION_H

void aes_128_ecb_encrypt(char *data, size_t data_size, unsigned char *key, size_t key_size);

#endif //SILENT_PACKER_AES_128_ECB_ENCRYPTION_H

```

`includes/common/cipher_functions.h`:

```h
//
// Created by silentvoid on 2/25/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_CIPHER_FUNCTIONS_H
#define SILENT_PACKER_CIPHER_FUNCTIONS_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#include <time.h>

extern uint32_t text_data_size32;
extern uint32_t text_entry_point32;
extern uint32_t cipher_key32;

extern uint64_t text_data_size64;
extern uint64_t text_entry_point64;
extern uint64_t cipher_key64;

extern unsigned char cipher_key128[17];

uint32_t generate_random_key32();
uint64_t generate_random_key64();
void generate_random_key128();

uint32_t rotate_right32(uint32_t value);
uint64_t rotate_right64(uint64_t value);

int xor_encrypt32(char *data, size_t data_size, uint32_t key);
int xor_encrypt64(char *data, size_t data_size, uint64_t key);

#endif //SILENT_PACKER_CIPHER_FUNCTIONS_H

```

`includes/common/file_functions.h`:

```h
//
// Created by silentvoid on 3/16/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_FILE_FUNCTIONS_H
#define SILENT_PACKER_FILE_FUNCTIONS_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <mhash.h>

#define ELF_FILE        1
#define PE_FILE         2
#define UNKNOWN_FILE    (-1)

#define x32_ARCH        32
#define x64_ARCH        64
#define UNKNOWN_ARCH    (-1)

int allocate_file(char *file, void **file_data, size_t *file_data_size);
int write_to_file(int fd, void *data, size_t data_size);
int dump_to_file(char *filename, char *data, size_t data_size);
void add_zero_padding(int fd, size_t end_offset);
int check_magic_bytes(char *file_data, size_t file_data_size);
int get_elf_arch(const char *file_data, size_t file_data_size);
int get_pe_arch(const char *file_data, size_t file_data_size);

#endif //SILENT_PACKER_FILE_FUNCTIONS_H

```

`includes/common/loader_functions.h`:

```h
//
// Created by silentvoid on 3/18/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_LOADER_FUNCTIONS_H
#define SILENT_PACKER_LOADER_FUNCTIONS_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#define CIPHER_KEY_OFFSET32_AES     28
#define CIPHER_KEY_OFFSET32         16
#define TEXT_ENTRY_POINT_OFFSET32   12
#define TEXT_DATA_SIZE_OFFSET32     8
#define LOADER_OFFSET_OFFSET32      4

#define CIPHER_KEY_OFFSET64_AES     40
#define CIPHER_KEY_OFFSET64         32
#define TEXT_ENTRY_POINT_OFFSET64   24
#define TEXT_DATA_SIZE_OFFSET64     16
#define LOADER_OFFSET_OFFSET64      8


extern uint32_t text_data_size32;
extern uint32_t text_entry_point32;
extern uint32_t cipher_key32;
extern uint32_t loader_offset32;

extern uint64_t text_data_size64;
extern uint64_t text_entry_point64;
extern uint64_t cipher_key64;
extern uint64_t loader_offset64;

char * patch_loader();

#endif //SILENT_PACKER_LOADER_FUNCTIONS_H

```

`includes/common/packer_config.h`:

```h
//
// Created by silentvoid on 4/10/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_PACKER_CONFIG_H
#define SILENT_PACKER_PACKER_CONFIG_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#define MAX_CIPHER_LENGTH 20
#define MAX_PACKING_METHOD_LENGTH 40

struct s_packer_config {
    int arch;
    char cipher[MAX_CIPHER_LENGTH];
    char packing_method[MAX_PACKING_METHOD_LENGTH];
    size_t cipher_key_offset;
    size_t loader_size;
    size_t loader_infos_size;
    unsigned char *loader_stub;
    int debug_mode;
};

extern struct s_packer_config packer_config;

int fill_packer_config(char *packing_method, char *cipher, int arch, int file_type, int debug_mode);

#endif //SILENT_PACKER_PACKER_CONFIG_H

```

`includes/main.h`:

```h
//
// Created by silentvoid on 2/25/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_MAIN_H
#define SILENT_PACKER_MAIN_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void display_argtable_help(char *progname, void **argtable);

#endif //SILENT_PACKER_MAIN_H

```

`includes/packing_method.h`:

```h
//
// Created by silentvoid on 3/18/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_PACKING_METHOD_H
#define SILENT_PACKER_PACKING_METHOD_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define SECTION_INSERTION_METHOD 1
#define SILVIO_INFECTION_METHOD 2
#define CODE_CAVE_METHOD 3

struct method_config {
    int method_type;
    int concerned_section;
};

extern struct method_config method_config;

#endif //SILENT_PACKER_PACKING_METHOD_H

```

`resources/elf_structure.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Created with Inkscape (http://www.inkscape.org/) -->

<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   version="1.0"
   width="739.51001"
   height="820"
   id="svg2"
   sodipodi:docname="Elf-layout--en.svg"
   inkscape:version="0.92.2 (5c3e80d, 2017-08-06)">
  <metadata
     id="metadata4562">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <sodipodi:namedview
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1"
     objecttolerance="10"
     gridtolerance="10"
     guidetolerance="10"
     inkscape:pageopacity="0"
     inkscape:pageshadow="2"
     inkscape:window-width="1600"
     inkscape:window-height="837"
     id="namedview4560"
     showgrid="false"
     inkscape:zoom="0.8"
     inkscape:cx="155.38"
     inkscape:cy="410"
     inkscape:window-x="-8"
     inkscape:window-y="-8"
     inkscape:window-maximized="1"
     inkscape:current-layer="svg2" />
  <defs
     id="defs4">
    <marker
       refX="0"
       refY="0"
       orient="auto"
       id="Arrow2Lend"
       style="overflow:visible">
      <path
         d="M 8.7185878,4.0337352 L -2.2072895,0.016013256 L 8.7185884,-4.0017078 C 6.97309,-1.6296469 6.9831476,1.6157441 8.7185878,4.0337352 z"
         transform="matrix(-1.1,0,0,-1.1,-1.1,0)"
         id="path4726"
         style="font-size:12px;fill-rule:evenodd;stroke-width:0.625;stroke-linejoin:round" />
    </marker>
    <marker
       refX="0"
       refY="0"
       orient="auto"
       id="Arrow1Mend"
       style="overflow:visible">
      <path
         d="M 0,0 L 5,-5 L -12.5,0 L 5,5 L 0,0 z"
         transform="matrix(-0.4,0,0,-0.4,-4,0)"
         id="path4738"
         style="fill-rule:evenodd;stroke:#000000;stroke-width:1pt;marker-start:none" />
    </marker>
    <marker
       refX="0"
       refY="0"
       orient="auto"
       id="Arrow2Mend"
       style="overflow:visible">
      <path
         d="M 8.7185878,4.0337352 L -2.2072895,0.016013256 L 8.7185884,-4.0017078 C 6.97309,-1.6296469 6.9831476,1.6157441 8.7185878,4.0337352 z"
         transform="scale(-0.6,-0.6)"
         id="path4720"
         style="font-size:12px;fill-rule:evenodd;stroke-width:0.625;stroke-linejoin:round" />
    </marker>
    <marker
       refX="0"
       refY="0"
       orient="auto"
       id="TriangleOutL"
       style="overflow:visible">
      <path
         d="M 5.77,0 L -2.88,5 L -2.88,-5 L 5.77,0 z"
         transform="scale(0.8,0.8)"
         id="path4649"
         style="fill-rule:evenodd;stroke:#000000;stroke-width:1pt;marker-start:none" />
    </marker>
    <linearGradient
       id="linearGradient3133">
      <stop
         id="stop3135"
         style="stop-color:#0000ff;stop-opacity:1"
         offset="0" />
      <stop
         id="stop3137"
         style="stop-color:#0000ff;stop-opacity:0"
         offset="1" />
    </linearGradient>
  </defs>
  <g
     transform="translate(-12.939504,-98.096169)"
     id="layer1">
    <g
       transform="translate(0,18)"
       id="g2640">
      <g
         id="g5175">
        <path
           d="M 613.625,724.53125 C 612.5981,724.53125 611.76562,725.36372 611.76562,726.39062 C 611.76562,727.41753 612.5981,728.25 613.625,728.25 C 622.90001,728.23499 630.70258,730.13353 636.03125,733.65625 C 641.35992,737.17897 644.3526,742.14212 644.34375,749.0625 C 644.32605,762.90325 631.26999,784.90482 596.375,813.5 C 595.79567,813.89505 595.48945,814.58364 595.58412,815.27842 C 595.6788,815.9732 596.15811,816.55476 596.82201,816.78039 C 597.48592,817.00603 598.22033,816.83696 598.71875,816.34375 C 633.97316,787.45405 648.0107,765.16483 648.03125,749.09375 C 648.04152,741.05821 644.28029,734.65235 638.09375,730.5625 C 631.90721,726.47265 623.40389,724.51543 613.625,724.53125 z"
           id="path3581"
           style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:3.70000005;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:3.70000005;stroke-dasharray:none;stroke-opacity:1" />
        <path
           d="M 596.55809,726.41912 L 622.13811,711.57772 L 622.18601,741.17768 L 596.55809,726.41912 z"
           id="path5181"
           style="fill-rule:evenodd;stroke:#000000;stroke-width:0.8pt;marker-start:none" />
      </g>
      <g
         id="g5167">
        <path
           d="M 615.53125,537.40625 C 614.84881,537.41915 614.22891,537.80672 613.91846,538.4146 C 613.60802,539.02248 613.65747,539.7519 614.04712,540.31231 C 614.43677,540.87272 615.10332,541.17308 615.78125,541.09375 C 624.30518,540.5271 641.5447,547.01808 658.4375,560.09375 C 675.3303,573.16942 692.0983,592.67701 700.9375,617.71875 C 709.7767,642.76049 710.77667,673.3453 696.03125,708.90625 C 681.28583,744.4672 650.73563,785.00468 596.375,829.59375 C 595.58109,830.24096 595.46217,831.40922 596.10937,832.20313 C 596.75658,832.99703 597.92484,833.11596 598.71875,832.46875 C 653.4037,787.61366 684.38073,746.62431 699.4375,710.3125 C 714.49427,674.00069 713.56383,642.35519 704.4375,616.5 C 695.31117,590.64481 678.08354,570.59726 660.71875,557.15625 C 643.35396,543.71524 626.08129,536.7049 615.53125,537.40625 z"
           id="path3583"
           style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:3.70000005;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:3.70000005;stroke-dasharray:none;stroke-opacity:1" />
        <path
           d="M 598.60784,540.39306 L 623.17375,523.9273 L 625.13716,553.46211 L 598.60784,540.39306 z"
           id="path5173"
           style="fill-rule:evenodd;stroke:#000000;stroke-width:0.8pt;marker-start:none" />
      </g>
      <g
         id="g5159">
        <path
           d="M 615.5,404.59375 C 614.4731,404.61964 613.66161,405.4731 613.6875,406.5 C 613.71339,407.5269 614.56685,408.33839 615.59375,408.3125 C 631.60747,408.78571 657.29883,423.17914 681.5625,448.0625 C 705.82617,472.94586 728.83428,508.15304 740.59375,549.8125 C 764.11269,633.13141 743.02185,742.29203 596.4375,847.625 C 595.85893,847.99334 595.53159,848.65152 595.58697,849.33515 C 595.64236,850.01878 596.07138,850.61568 596.7017,850.88608 C 597.33203,851.15647 598.06021,851.05599 598.59375,850.625 C 746.02889,744.68067 768.06415,633.50935 744.15625,548.8125 C 732.2023,506.46408 708.88382,470.76376 684.21875,445.46875 C 659.55368,420.17374 633.72034,405.12662 615.6875,404.59375 C 615.62504,404.59058 615.56246,404.59058 615.5,404.59375 L 615.5,404.59375 z"
           id="path3585"
           style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:3.70000005;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:3.70000005;stroke-opacity:1" />
        <path
           d="M 598.56551,405.95282 L 624.59549,391.91555 L 623.72119,421.50263 L 598.56551,405.95282 z"
           id="path5165"
           style="fill-rule:evenodd;stroke:#000000;stroke-width:0.8pt;marker-start:none" />
      </g>
    </g>
    <g
       transform="translate(0,18)"
       id="g2592">
      <rect
         width="434.62759"
         height="100.60824"
         x="162.03151"
         y="98.596169"
         id="rect2160"
         style="font-size:36px;fill:#ffffff;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" />
      <rect
         width="434.62759"
         height="100.60824"
         x="162.03151"
         y="203.99149"
         id="rect3149"
         style="font-size:36px;fill:#ffffff;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" />
      <rect
         width="434.62759"
         height="100.60824"
         x="162.03151"
         y="777.1507"
         id="rect3151"
         style="font-size:36px;fill:#ffffff;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" />
      <rect
         width="434.36804"
         height="159.70755"
         x="162.16129"
         y="309.5166"
         id="rect3153"
         style="font-size:36px;fill:#ffffff;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1.25955236px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" />
      <rect
         width="434.51022"
         height="125.64294"
         x="162.09019"
         y="474.19971"
         id="rect3155"
         style="font-size:36px;fill:#ffffff;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1.11736131px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" />
      <rect
         width="434.57434"
         height="111.62189"
         x="162.05814"
         y="660.71509"
         id="rect3157"
         style="font-size:36px;fill:#ffffff;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1.0532496px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" />
      <text
         x="378.45837"
         y="638.71503"
         id="text5129"
         xml:space="preserve"
         style="font-size:36px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:center;line-height:125%;writing-mode:lr-tb;text-anchor:middle;font-family:Bitstream Vera Sans"><tspan
           x="378.45837"
           y="638.71503"
           id="tspan5131">...</tspan></text>
      <text
         x="376.1044"
         y="727.50885"
         id="text5133"
         xml:space="preserve"
         style="font-size:36px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:center;line-height:125%;writing-mode:lr-tb;text-anchor:middle;font-family:Bitstream Vera Sans"><tspan
           x="376.1044"
           y="727.50885"
           id="tspan5135">.data</tspan></text>
      <text
         x="376.1044"
         y="548.00397"
         id="text5137"
         xml:space="preserve"
         style="font-size:36px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:center;line-height:125%;writing-mode:lr-tb;text-anchor:middle;font-family:Bitstream Vera Sans"><tspan
           x="376.1044"
           y="548.00397"
           id="tspan5139">.rodata</tspan></text>
      <text
         x="374.76651"
         y="402.67029"
         id="text5141"
         xml:space="preserve"
         style="font-size:36px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:center;line-height:125%;writing-mode:lr-tb;text-anchor:middle;font-family:Bitstream Vera Sans"><tspan
           x="374.76651"
           y="402.67029"
           id="tspan5143">.text</tspan></text>
      <text
         x="390.97278"
         y="259.24197"
         id="text5145"
         xml:space="preserve"
         style="font-size:36px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:center;line-height:125%;writing-mode:lr-tb;text-anchor:middle;font-family:Bitstream Vera Sans"><tspan
           x="390.97278"
           y="259.24197"
           id="tspan5147">Program header table</tspan></text>
      <text
         x="374.47354"
         y="159.88318"
         id="text5149"
         xml:space="preserve"
         style="font-size:36px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:center;line-height:125%;writing-mode:lr-tb;text-anchor:middle;font-family:Bitstream Vera Sans"><tspan
           x="374.47354"
           y="159.88318"
           id="tspan5151">ELF header</tspan></text>
      <text
         x="376.16299"
         y="842.33545"
         id="text5153"
         xml:space="preserve"
         style="font-size:36px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:center;line-height:125%;writing-mode:lr-tb;text-anchor:middle;font-family:Bitstream Vera Sans"><tspan
           x="376.16299"
           y="842.33545"
           id="tspan5155">Section header table</tspan></text>
    </g>
    <g
       transform="translate(0,9.9513409)"
       id="g2628"
       style="font-size:40px">
      <g
         id="g5191">
        <path
           d="M 158.59375,240.46875 C 158.17657,240.49346 157.78005,240.65868 157.46875,240.9375 C 12.232118,366.00238 -1.236628,475.64394 22.09375,553.75 C 45.424128,631.85606 105.21875,678.4375 105.21875,678.4375 C 106.02992,679.06745 107.19818,678.92054 107.82813,678.10938 C 108.45807,677.29821 108.31117,676.12995 107.5,675.5 C 107.5,675.5 48.605655,629.51813 25.65625,552.6875 C 2.7068448,475.85687 15.391155,368.19356 159.90625,243.75 C 160.53574,243.2394 160.7596,242.37851 160.45857,241.62595 C 160.15754,240.87338 159.40173,240.40437 158.59375,240.46875 L 158.59375,240.46875 z"
           id="path4760"
           style="font-size:40px;fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:3.70000005;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:3.70000005;stroke-dasharray:none;stroke-opacity:1" />
        <path
           d="M 119.83906,687.47222 L 90.54692,683.40096 L 108.74694,660.05745 L 119.83906,687.47222 z"
           id="path5197"
           style="fill-rule:evenodd;stroke:#000000;stroke-width:0.8pt;marker-start:none" />
      </g>
      <g
         id="g5183">
        <path
           d="M 160.1875,264.53125 C 159.83976,264.58497 159.51454,264.73674 159.25,264.96875 C 73.516681,335.57267 56.303827,382.38545 61.25,412.0625 C 66.196173,441.73955 93.28125,453.21875 93.28125,453.21875 C 93.895652,453.50878 94.619589,453.43873 95.166989,453.03629 C 95.714388,452.63384 95.997179,451.96375 95.903612,451.29081 C 95.810045,450.61787 95.355176,450.05034 94.71875,449.8125 C 94.71875,449.8125 69.517857,439.1384 64.90625,411.46875 C 60.294643,383.7991 76.293073,338.06012 161.59375,267.8125 C 162.24704,267.29362 162.47225,266.40171 162.14361,265.63488 C 161.81497,264.86806 161.01379,264.41603 160.1875,264.53125 z"
           id="path4764"
           style="font-size:40px;fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:3.70000005;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:3.70000005;stroke-dasharray:none;stroke-opacity:1" />
        <path
           d="M 109.73853,458.16544 L 80.39141,461.81941 L 91.924754,434.55878 L 109.73853,458.16544 z"
           id="path5189"
           style="fill-rule:evenodd;stroke:#000000;stroke-width:0.8pt;marker-start:none" />
      </g>
    </g>
  </g>
  <text
     xml:space="preserve"
     style="font-style:normal;font-weight:normal;font-size:40px;line-height:1;font-family:sans-serif;text-align:end;letter-spacing:0px;word-spacing:0px;text-anchor:end;fill:#000000;fill-opacity:1;stroke:none"
     x="143.91016"
     y="292"
     id="text9601"><tspan
       sodipodi:role="line"
       x="143.91016"
       y="292"
       id="tspan9633"
       style="font-size:46.66666667px;line-height:100%">⎧</tspan><tspan
       sodipodi:role="line"
       x="143.91016"
       y="340"
       id="tspan9677"
       style="font-size:46.66666667px;line-height:100%">⎪</tspan><tspan
       sodipodi:role="line"
       x="143.91016"
       y="388"
       id="tspan9679"
       style="font-size:46.66666667px;line-height:100%">⎨</tspan><tspan
       sodipodi:role="line"
       x="143.91016"
       y="436"
       id="tspan9681"
       style="font-size:46.66666667px;line-height:100%">⎪</tspan><tspan
       sodipodi:role="line"
       x="143.91016"
       y="484"
       id="tspan9683"
       style="font-size:46.66666667px;line-height:100%">⎩</tspan></text>
  <text
     xml:space="preserve"
     style="font-style:normal;font-weight:normal;font-size:40px;line-height:1;font-family:sans-serif;text-align:end;letter-spacing:0px;word-spacing:0px;text-anchor:end;fill:#000000;fill-opacity:1;stroke:none"
     x="144.75"
     y="559.87891"
     id="text9601-2"><tspan
       sodipodi:role="line"
       x="144.75"
       y="559.87891"
       id="tspan9677-4"
       style="font-size:46.66666794px;line-height:100%">⎧</tspan><tspan
       sodipodi:role="line"
       x="144.75"
       y="606.54559"
       id="tspan9681-9"
       style="font-size:46.66666794px;line-height:100%">⎨</tspan><tspan
       sodipodi:role="line"
       x="144.75"
       y="653.21222"
       id="tspan9683-5"
       style="font-size:46.66666794px;line-height:100%">⎩</tspan></text>
</svg>

```

`src/ELF/elf_allocation.c`:

```c
//
// Created by silentvoid on 2/25/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "elf_allocation.h"
#include "elf_deallocation.h"
#include "file_functions.h"
#include "packer_config.h"

#include "log.h"

int allocate_elf_elf_header(t_elf *elf, void *file_data, size_t file_data_size) {
    // http://www.openvirtualization.org/documentation/structElf64__Ehdr.html

    if(elf->s_type == ELF32) {
        if (file_data_size < sizeof(Elf32_Ehdr)) {
            log_error("Total file size is less than ELF Header size");
            return -1;
        }

        ((t_elf32 *)elf)->elf_header = malloc(sizeof(Elf32_Ehdr));
        if (((t_elf32 *)elf)->elf_header == NULL) {
            deallocate_elf_elf_header(elf);
            log_error("malloc() failure");
            return -1;
        }
        memcpy(((t_elf32 *)elf)->elf_header, file_data, sizeof(Elf32_Ehdr));

        // https://code.woboq.org/userspace/glibc/elf/elf.h.html
        // "\177ELF"
        if (strncmp((char *) ((t_elf32 *)elf)->elf_header->e_ident, ELFMAG, SELFMAG) != 0) {
            deallocate_elf_elf_header(elf);
            log_error("Magic bytes does not match ELF bytes");
            return -1;
        }

        if (((t_elf32 *)elf)->elf_header->e_machine != EM_386) {
            deallocate_elf_elf_header(elf);
            log_error("File is not a x32 executable");
            return -1;
        }
    }
    else {
        if (file_data_size < sizeof(Elf64_Ehdr)) {
            log_error("Total file size is less than ELF Header size");
            return -1;
        }

        ((t_elf64 *)elf)->elf_header = malloc(sizeof(Elf64_Ehdr));
        if (((t_elf64 *)elf)->elf_header == NULL) {
            deallocate_elf_elf_header(elf);
            log_error("malloc() failure");
            return -1;
        }
        memcpy(((t_elf64 *)elf)->elf_header, file_data, sizeof(Elf64_Ehdr));

        // https://code.woboq.org/userspace/glibc/elf/elf.h.html
        // "\177ELF"
        if (strncmp((char *) ((t_elf64 *)elf)->elf_header->e_ident, ELFMAG, SELFMAG) != 0) {
            deallocate_elf_elf_header(elf);
            log_error("Magic bytes does not match ELF bytes");
            return -1;
        }

        if (((t_elf64 *)elf)->elf_header->e_machine != EM_X86_64) {
            deallocate_elf_elf_header(elf);
            log_error("File is not a x64 executable");
            return -1;
        }
    }

    return 1;
}

int allocate_elf_program_header(t_elf *elf, void *file_data, size_t file_data_size) {
    if(elf->s_type == ELF32) {
        size_t elf_program_header_size = sizeof(Elf32_Phdr) * ((t_elf32 *)elf)->elf_header->e_phnum;
        if (file_data_size < sizeof(Elf32_Ehdr) + elf_program_header_size) {
            log_error("Total file size is inferior to ELF Header + Program Header size");
            return -1;
        }

        ((t_elf32 *)elf)->prog_header = malloc(elf_program_header_size);
        if (((t_elf32 *)elf)->prog_header == NULL) {
            deallocate_elf_program_header(elf);
            log_error("malloc() failure");
            return -1;
        }
        memcpy(((t_elf32 *)elf)->prog_header, file_data + ((t_elf32 *)elf)->elf_header->e_phoff, elf_program_header_size);
    }
    else {
        size_t elf_program_header_size = sizeof(Elf64_Phdr) * ((t_elf64 *)elf)->elf_header->e_phnum;
        if (file_data_size < sizeof(Elf64_Ehdr) + elf_program_header_size) {
            log_error("Total file size is inferior to ELF Header + Program Header size");
            return -1;
        }

        ((t_elf64 *)elf)->prog_header = malloc(elf_program_header_size);
        if (((t_elf64 *)elf)->prog_header == NULL) {
            deallocate_elf_program_header(elf);
            log_error("malloc() failure");
            return -1;
        }
        memcpy(((t_elf64 *)elf)->prog_header, file_data + ((t_elf64 *)elf)->elf_header->e_phoff, elf_program_header_size);
    }

    return 1;
}

int allocate_elf_sections_header(t_elf *elf, void *file_data, size_t file_data_size) {
    if(elf->s_type == ELF32) {
        size_t elf_sections_header_size = sizeof(Elf32_Shdr) * ((t_elf32 *)elf)->elf_header->e_shnum;

        ((t_elf32 *)elf)->section_header = malloc(elf_sections_header_size);
        if (((t_elf32 *)elf)->section_header == NULL) {
            deallocate_elf_sections_header(elf);
            log_error("malloc() failure");
            return -1;
        }
        memset(((t_elf32 *)elf)->section_header, 0, elf_sections_header_size);

        for (int i = 0; i < ((t_elf32 *)elf)->elf_header->e_shnum; i++) {
            if (file_data_size < ((t_elf32 *)elf)->elf_header->e_shoff + (i * sizeof(Elf32_Shdr))) {
                deallocate_elf_sections_header(elf);
                log_error("Total file size is inferior to ELF section header size");
                return -1;
            }
            memcpy(&(((t_elf32 *)elf)->section_header[i]), file_data + ((t_elf32 *)elf)->elf_header->e_shoff + (i * sizeof(Elf32_Shdr)),
                   sizeof(Elf32_Shdr));
        }
    }
    else {
        size_t elf_sections_header_size = sizeof(Elf64_Shdr) * ((t_elf64 *)elf)->elf_header->e_shnum;

        ((t_elf64 *)elf)->section_header = malloc(elf_sections_header_size);
        if (((t_elf64 *)elf)->section_header == NULL) {
            deallocate_elf_sections_header(elf);
            log_error("malloc() failure");
            return -1;
        }
        memset(((t_elf64 *)elf)->section_header, 0, elf_sections_header_size);

        for (int i = 0; i < ((t_elf64 *)elf)->elf_header->e_shnum; i++) {
            if (file_data_size < ((t_elf64 *)elf)->elf_header->e_shoff + (i * sizeof(Elf64_Shdr))) {
                deallocate_elf_sections_header(elf);
                log_error("Total file size is inferior to ELF section header size");
                return -1;
            }
            memcpy(&(((t_elf64 *)elf)->section_header[i]), file_data + ((t_elf64 *)elf)->elf_header->e_shoff + (i * sizeof(Elf64_Shdr)),
                   sizeof(Elf64_Shdr));
        }
    }

    return 1;
}

int allocate_elf_sections_data(t_elf *elf, void *file_data, size_t file_data_size) {
    if(elf->s_type == ELF32) {
        ((t_elf32 *)elf)->section_data = malloc(sizeof(char *) * ((t_elf32 *)elf)->elf_header->e_shnum);
        if (((t_elf32 *)elf)->section_data == NULL) {
            deallocate_elf_sections_data(elf);
            log_error("malloc() failure");
            return -1;
        }
        memset(((t_elf32 *)elf)->section_data, 0, sizeof(char *) * ((t_elf32 *)elf)->elf_header->e_shnum);

        // TODO: Free all the malloc section_data_data up to i
        size_t elf_section_data_size;
        for (int i = 0; i < ((t_elf32 *)elf)->elf_header->e_shnum; i++) {
            // Section that occupies no space in file
            if (((t_elf32 *)elf)->section_header[i].sh_type == SHT_NOBITS) {
                ((t_elf32 *)elf)->section_data[i] = NULL;
            } else {
                if (file_data_size < ((t_elf32 *)elf)->section_header[i].sh_offset) {
                    log_error("Total file size is less than section data offset");
                    return -1;
                }

                elf_section_data_size = ((t_elf32 *)elf)->section_header[i].sh_size;

                ((t_elf32 *)elf)->section_data[i] = malloc(elf_section_data_size);
                if (((t_elf32 *)elf)->section_data[i] == NULL) {
                    free(((t_elf32 *)elf)->section_data[i]);
                    log_error("malloc() failure");
                    return -1;
                }
                memset(((t_elf32 *)elf)->section_data[i], 0, elf_section_data_size);
                memcpy(((t_elf32 *)elf)->section_data[i], file_data + ((t_elf32 *)elf)->section_header[i].sh_offset, elf_section_data_size);
            }
        }
    }
    else {
        ((t_elf64 *)elf)->section_data = malloc(sizeof(char *) * ((t_elf64 *)elf)->elf_header->e_shnum);
        if (((t_elf64 *)elf)->section_data == NULL) {
            deallocate_elf_sections_data(elf);
            log_error("malloc() failure");
            return -1;
        }
        memset(((t_elf64 *)elf)->section_data, 0, sizeof(char *) * ((t_elf64 *)elf)->elf_header->e_shnum);

        size_t elf_section_data_size;
        for (int i = 0; i < ((t_elf64 *)elf)->elf_header->e_shnum; i++) {
            // Section that occupies no space in file
            if (((t_elf64 *)elf)->section_header[i].sh_type == SHT_NOBITS) {
                ((t_elf64 *)elf)->section_data[i] = NULL;
            } else {
                if (file_data_size < ((t_elf64 *)elf)->section_header[i].sh_offset) {
                    log_error("Total file size is less than section data offset");
                    return -1;
                }

                elf_section_data_size = ((t_elf64 *)elf)->section_header[i].sh_size;

                ((t_elf64 *)elf)->section_data[i] = malloc(elf_section_data_size);
                if (((t_elf64 *)elf)->section_data[i] == NULL) {
                    free(((t_elf64 *)elf)->section_data[i]);
                    log_error("malloc() failure");
                    return -1;
                }
                memset(((t_elf64 *)elf)->section_data[i], 0, elf_section_data_size);
                memcpy(((t_elf64 *)elf)->section_data[i], file_data + ((t_elf64 *)elf)->section_header[i].sh_offset, elf_section_data_size);
            }
        }
    }

    return 1;
}

int allocate_elf(t_elf **elf, void *file_data, size_t file_data_size) {
    size_t t_elf_size;

    if(packer_config.arch == x32_ARCH)
        t_elf_size = sizeof(t_elf32);
    else
        t_elf_size = sizeof(t_elf64);

    *elf = malloc(t_elf_size);
    if(*elf == NULL) {
        deallocate_elf_struct(*elf);
        log_error("malloc() failure");
        return -1;
    }
    memset(*elf, 0, t_elf_size);

    t_elf type_pe;
    if(packer_config.arch == 32) {
        type_pe.s_type = ELF32;
        ((t_elf32 *)(*elf))->type_header = type_pe;
    }
    else {
        type_pe.s_type = ELF64;
        ((t_elf64 *)(*elf))->type_header = type_pe;
    }

    log_verbose("Allocating ELF Header ...");

    if(allocate_elf_elf_header(*elf, file_data, file_data_size) == -1) {
        log_error("Error during ELF Header allocation");
        return -1;
    }

    log_verbose("Allocating Program Header ...");

    if(allocate_elf_program_header(*elf, file_data, file_data_size) == -1) {
        deallocate_elf_elf_header(*elf);
        log_error("Error during Program Header allocation");
        return -1;
    }

    log_verbose("Allocating Sections Headers ...");

    if(allocate_elf_sections_header(*elf, file_data, file_data_size) == -1) {
        deallocate_elf_elf_header(*elf);
        deallocate_elf_program_header(*elf);
        log_error("Error during Section Header allocation");
        return -1;
    }

    log_verbose("Allocating Sections Data ...");

    if(allocate_elf_sections_data(*elf, file_data, file_data_size) == -1) {
        deallocate_elf_elf_header(*elf);
        deallocate_elf_program_header(*elf);
        deallocate_elf_sections_header(*elf);
        log_error("Error during Section Data allocation");
        return -1;
    }

    return 1;
}

```

`src/ELF/elf_code_cave.c`:

```c
//
// Created by silentvoid on 3/7/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "elf_code_cave.h"
#include "elf_functions.h"
#include "elf_allocation.h"
#include "elf_packing_method.h"
#include "loader_functions.h"
#include "file_functions.h"
#include "packer_config.h"
#include "all_elf_loaders_infos.h"

#include "log.h"

int find_elf_code_cave_index(t_elf *elf) {
    if(elf->s_type == ELF32) {
        for (int i = 0; i < ((t_elf32 *)elf)->elf_header->e_shnum; i++) {
            if (((t_elf32 *)elf)->section_header[i].sh_type == SHT_NOBITS) {
                continue;
            }
            unsigned int code_cave_size;

            // TODO: Maybe change that since it's relying on the fact that the section header is located after the section data (may not always be the case)
            if (i == ((t_elf32 *)elf)->elf_header->e_shnum - 1) {
                code_cave_size =
                        ((t_elf32 *)elf)->elf_header->e_shoff - (((t_elf32 *)elf)->section_header[i].sh_offset + ((t_elf32 *)elf)->section_header[i].sh_size);
            } else {
                code_cave_size = ((t_elf32 *)elf)->section_header[i + 1].sh_offset -
                                 (((t_elf32 *)elf)->section_header[i].sh_offset + ((t_elf32 *)elf)->section_header[i].sh_size);
            }

            if (code_cave_size > packer_config.loader_size) {
                int segment_index = find_elf_segment_index_of_section(elf, i);
                if (((t_elf32 *)elf)->prog_header[segment_index].p_type == PT_LOAD) {
                    log_verbose("Code Cave size : %d", code_cave_size);
                    return i;
                }
            }
        }
    }
    else {
        for (int i = 0; i < ((t_elf64 *)elf)->elf_header->e_shnum; i++) {
            if (((t_elf64 *)elf)->section_header[i].sh_type == SHT_NOBITS) {
                continue;
            }
            unsigned int code_cave_size;

            // TODO: Maybe change that since it's relying on the fact that the section header is located after the section data (may not always be the case)
            if (i == ((t_elf64 *)elf)->elf_header->e_shnum - 1) {
                code_cave_size =
                        ((t_elf64 *)elf)->elf_header->e_shoff - (((t_elf64 *)elf)->section_header[i].sh_offset + ((t_elf64 *)elf)->section_header[i].sh_size);
            } else {
                code_cave_size = ((t_elf64 *)elf)->section_header[i + 1].sh_offset -
                                 (((t_elf64 *)elf)->section_header[i].sh_offset + ((t_elf64 *)elf)->section_header[i].sh_size);
            }

            if (code_cave_size > packer_config.loader_size) {
                int segment_index = find_elf_segment_index_of_section(elf, i);
                if (((t_elf64 *)elf)->prog_header[segment_index].p_type == PT_LOAD) {
                    log_verbose("Code Cave size : %d", code_cave_size);
                    return i;
                }
            }
        }
    }

    return -1;
}

int set_new_elf_cave_segment_values(t_elf *elf, int segment_index) {
    if(elf->s_type == ELF32) {
        ((t_elf32 *)elf)->prog_header[segment_index].p_memsz += packer_config.loader_size;
        ((t_elf32 *)elf)->prog_header[segment_index].p_filesz += packer_config.loader_size;
    }
    else {
        ((t_elf64 *)elf)->prog_header[segment_index].p_memsz += packer_config.loader_size;
        ((t_elf64 *)elf)->prog_header[segment_index].p_filesz += packer_config.loader_size;
    }

    add_elf_segment_permission(elf, segment_index, PF_W); // NOLINT(hicpp-signed-bitwise)
    add_elf_segment_permission(elf, segment_index, PF_X); // NOLINT(hicpp-signed-bitwise)

    int text_segment_index = find_elf_text_segment(elf);
    if(text_segment_index == -1) {
        log_error("Couldn't find .text segment");
        return -1;
    }
    add_elf_segment_permission(elf, text_segment_index, PF_W); // NOLINT(hicpp-signed-bitwise)

    return 1;
}

int elf_cave_insert_loader(t_elf *elf, int section_index, int old_section_size) {
    char *new_section_data;
    char *loader;

    if(elf->s_type == ELF32) {
        new_section_data = realloc(((t_elf32 *)elf)->section_data[section_index], old_section_size + packer_config.loader_size);
        if (new_section_data == NULL) {
            log_error("realloc() failure");
            return -1;
        }
        ((t_elf32 *)elf)->section_data[section_index] = new_section_data;
        // For ASM
        loader_offset32 = ((t_elf32 *)elf)->section_header[section_index].sh_addr + old_section_size;

        loader = patch_loader();
        if(loader == NULL) {
            free(loader);
            log_error("Error during loader patching");
            return -1;
        }
        memcpy(new_section_data + old_section_size, loader, packer_config.loader_size);
    }
    else {
        new_section_data = realloc(((t_elf64 *)elf)->section_data[section_index], old_section_size + packer_config.loader_size);
        if (new_section_data == NULL) {
            log_error("realloc() failure");
            return -1;
        }
        ((t_elf64 *)elf)->section_data[section_index] = new_section_data;
        // For ASM
        loader_offset64 = ((t_elf64 *)elf)->section_header[section_index].sh_addr + old_section_size;

        loader = patch_loader();
        if(loader == NULL) {
            free(loader);
            log_error("Error during loader patching");
            return -1;
        }
        memcpy(new_section_data + old_section_size, loader, packer_config.loader_size);
    }
    free(loader);

    return 1;
}

int elf_code_cave_injection(t_elf *elf) {

    log_verbose("Finding the code cave ...");

    int section_cave_index = find_elf_code_cave_index(elf);
    if(section_cave_index == -1) {
        log_error("Couldn't find any code cave in this ELF");
        return -1;
    }
    method_config.concerned_section = section_cave_index;

    int segment_index = find_elf_segment_index_of_section(elf, section_cave_index);
    if(segment_index == -1) {
        log_error("Couldn't find segment index");
        return -1;
    }

    log_verbose("Setting new segment values ...");

    if(set_new_elf_cave_segment_values(elf, segment_index) == -1) {
        log_error("Error during segment values modification");
        return -1;
    }

    log_verbose("Inserting the loader inside the code cave ...");

    int old_section_size;
    if(elf->s_type == ELF32)
        old_section_size = ((t_elf32 *)elf)->section_header[section_cave_index].sh_size;
    else
        old_section_size = ((t_elf64 *)elf)->section_header[section_cave_index].sh_size;

    if(elf_cave_insert_loader(elf, section_cave_index, old_section_size) == -1) {
        log_error("Error during Loader insertion");
        return -1;
    }

    log_verbose("Setting new ELF entry point ...");

    if(elf->s_type == ELF32) {
        Elf32_Addr loader_addr;
        loader_addr = ((t_elf32 *) elf)->section_header[section_cave_index].sh_addr + old_section_size;
        set_new_elf_entry_to_addr32(elf, loader_addr, section_cave_index, old_section_size);
    }
    else {
        Elf64_Addr loader_addr;
        loader_addr = ((t_elf64 *) elf)->section_header[section_cave_index].sh_addr + old_section_size;
        set_new_elf_entry_to_addr64(elf, loader_addr, section_cave_index, old_section_size);
    }

    return 1;
}

```

`src/ELF/elf_deallocation.c`:

```c
//
// Created by silentvoid on 4/12/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "elf_deallocation.h"
#include "elf_allocation.h"

void deallocate_elf_elf_header(t_elf *elf) {
    if(elf->s_type == ELF32) {
        free(((t_elf32 *)elf)->elf_header);
    }
    else {
        free(((t_elf64 *)elf)->elf_header);
    }
}

void deallocate_elf_program_header(t_elf *elf) {
    if(elf->s_type == ELF32) {
        free(((t_elf32 *)elf)->prog_header);
    }
    else {
        free(((t_elf64 *)elf)->prog_header);
    }
}

void deallocate_elf_sections_header(t_elf *elf) {
    if(elf->s_type == ELF32) {
        free(((t_elf32 *)elf)->section_header);
    }
    else {
        free(((t_elf64 *)elf)->section_header);
    }
}


void deallocate_elf_sections_data_data(t_elf *elf) {
    if(elf->s_type == ELF32) {
        for (int i = 0; i < ((t_elf32 *)elf)->elf_header->e_shnum; i++) {
            free(((t_elf32 *)elf)->section_data[i]);
        }
    }
    else {
        for (int i = 0; i < ((t_elf64 *)elf)->elf_header->e_shnum; i++) {
            free(((t_elf64 *)elf)->section_data[i]);
        }
    }
}

void deallocate_elf_sections_data(t_elf *elf) {
    if(elf->s_type == ELF32) {
        free(((t_elf32 *)elf)->section_data);
    }
    else {
        free(((t_elf64 *)elf)->section_data);
    }
}

void deallocate_elf_struct(t_elf *elf) {
    free(elf);
}

void deallocate_elf(t_elf *elf) {
    deallocate_elf_elf_header(elf);
    deallocate_elf_program_header(elf);
    deallocate_elf_sections_header(elf);
    deallocate_elf_sections_data_data(elf);
    deallocate_elf_sections_data(elf);
    deallocate_elf_struct(elf);
}


```

`src/ELF/elf_encryption.c`:

```c
//
// Created by silentvoid on 3/16/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "elf_encryption.h"
#include "cipher_functions.h"
#include "elf_allocation.h"
#include "elf_functions.h"
#include "loader_functions.h"
#include "packer_config.h"
#include "file_functions.h"
#include "aes_128_ecb_encryption.h"

#include "log.h"

int encrypt_elf(t_elf *elf) {
    int text_section_index = find_elf_section_index(elf, ".text");
    if(text_section_index == -1) {
        log_error("Couldn't find .text section in the ELF binary");
        return -1;
    }

    log_verbose("Got .text section index : %d", text_section_index);

    char *text_data;
    if(elf->s_type == ELF32) {
        text_data = ((t_elf32 *)elf)->section_data[text_section_index];

        // Setting global variables
        text_data_size32 = ((t_elf32 *)elf)->section_header[text_section_index].sh_size;
        text_entry_point32 = ((t_elf32 *)elf)->section_header[text_section_index].sh_addr;

        if(packer_config.debug_mode) {
            log_debug("Dumping .text ...");
            dump_to_file("text32.dmp", text_data, text_data_size32);
        }

        log_verbose("Generating random key ...");

        if(strcmp(packer_config.cipher, "xor") == 0) {
            cipher_key32 = generate_random_key32();
            uint32_t temp_key = cipher_key32;
            log_info("Random key : %x", cipher_key32);
            xor_encrypt32(text_data, text_data_size32, temp_key);
        }
        else if(strcmp(packer_config.cipher, "aes128_ecb") == 0) {
            generate_random_key128();

            log_info("Random key : ");
            for(int i = 0; i < 16; i++)
                printf("%02x", cipher_key128[i]);
            puts("");

            aes_128_ecb_encrypt(text_data, text_data_size32, cipher_key128, 16);
        }

        if(packer_config.debug_mode) {
            log_debug("Dumping encrypted .text ...");
            dump_to_file("text32_encrypted.dmp", text_data, text_data_size32);
        }
    }
    else {
        text_data = ((t_elf64 *)elf)->section_data[text_section_index];

        // Setting global variables
        text_data_size64 = ((t_elf64 *)elf)->section_header[text_section_index].sh_size;
        text_entry_point64 = ((t_elf64 *)elf)->section_header[text_section_index].sh_addr;

        if(packer_config.debug_mode) {
            log_debug("Dumping .text ...");
            dump_to_file("text64.dmp", text_data, text_data_size64);
        }

        log_verbose("Generating random key ...");

        if(strcmp(packer_config.cipher, "xor") == 0) {
            cipher_key64 = generate_random_key64();
            uint64_t temp_key = cipher_key64;
            log_info("Random key : %lx", cipher_key64);
            xor_encrypt64(text_data, text_data_size64, temp_key);
        }
        else if(strcmp(packer_config.cipher, "aes128_ecb") == 0) {
            generate_random_key128();

            log_info("Random key : ");
            for(int i = 0; i < 16; i++)
                printf("%02x", cipher_key128[i]);
            puts("");

            aes_128_ecb_encrypt(text_data, text_data_size64, cipher_key128, 16);
        }

        if(packer_config.debug_mode) {
            log_debug("Dumping encrypted .text ...");
            dump_to_file("text64_encrypted.dmp", text_data, text_data_size64);
        }
    }

    return 1;
}

```

`src/ELF/elf_functions.c`:

```c
//
// Created by silentvoid on 2/28/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "elf_functions.h"
#include "elf_allocation.h"
#include "loader_functions.h"
#include "packer_config.h"
#include "all_elf_loaders_infos.h"

#include "log.h"

int set_new_elf_entry_to_section(t_elf *elf, int section_index) {
    if(elf->s_type == ELF32) {
        Elf32_Addr last_entry = ((t_elf32 *)elf)->elf_header->e_entry;
        ((t_elf32 *)elf)->elf_header->e_entry = ((t_elf32 *)elf)->section_header[section_index].sh_addr;
        int32_t jump = last_entry - (((t_elf32 *)elf)->elf_header->e_entry + packer_config.loader_size - packer_config.loader_infos_size);

        memcpy(((t_elf32 *)elf)->section_data[section_index] + packer_config.loader_size - (packer_config.loader_infos_size + 4), &jump, 4);
    }
    else {
        Elf64_Addr last_entry = ((t_elf64 *)elf)->elf_header->e_entry;
        ((t_elf64 *)elf)->elf_header->e_entry = ((t_elf64 *)elf)->section_header[section_index].sh_addr;
        int32_t jump = last_entry - (((t_elf64 *)elf)->elf_header->e_entry + packer_config.loader_size - packer_config.loader_infos_size);

        memcpy(((t_elf64 *)elf)->section_data[section_index] + packer_config.loader_size - (packer_config.loader_infos_size + 4), &jump, 4);
    }

    return 1;
}

int set_new_elf_entry_to_addr32(t_elf *elf, int32_t entry_address, int section_index, int section_size) {
    Elf32_Addr last_entry = ((t_elf32 *)elf)->elf_header->e_entry;
    ((t_elf32 *)elf)->elf_header->e_entry = entry_address;
    int32_t jump = last_entry - (((t_elf32 *)elf)->elf_header->e_entry + packer_config.loader_size - packer_config.loader_infos_size);

    memcpy(((t_elf32 *)elf)->section_data[section_index] + section_size + packer_config.loader_size - (packer_config.loader_infos_size + 4), &jump, 4);

    return 1;
}

int set_new_elf_entry_to_addr64(t_elf *elf, int64_t entry_address, int section_index, int section_size) {
    Elf64_Addr last_entry = ((t_elf64 *)elf)->elf_header->e_entry;
    ((t_elf64 *)elf)->elf_header->e_entry = entry_address;
    int32_t jump = last_entry - (((t_elf64 *)elf)->elf_header->e_entry + packer_config.loader_size - packer_config.loader_infos_size);

    memcpy(((t_elf64 *)elf)->section_data[section_index] + section_size + packer_config.loader_size - (packer_config.loader_infos_size + 4), &jump, 4);

    return 1;
}

int find_last_elf_segment_of_type(t_elf *elf, unsigned int p_type) {
    int index = -1;

    if(elf->s_type == ELF32) {
        for (int i = 0; i < ((t_elf32 *)elf)->elf_header->e_phnum; i++) {
            if (((t_elf32 *)elf)->prog_header[i].p_type == p_type) {
                index = i;
            }
        }
    }
    else {
        for (int i = 0; i < ((t_elf64 *)elf)->elf_header->e_phnum; i++) {
            if (((t_elf64 *)elf)->prog_header[i].p_type == p_type) {
                index = i;
            }
        }
    }

    return index;
}

// Find last section from specified segment index
int find_last_elf_section_from_segment(t_elf *elf, int segment_index) {
    int index = -1;

    if(elf->s_type == ELF32) {
        Elf32_Phdr *program_header = ((t_elf32 *)elf)->prog_header + segment_index;
        for (int i = 0; i < ((t_elf32 *)elf)->elf_header->e_shnum; i++) {
            Elf32_Shdr *section_header = ((t_elf32 *)elf)->section_header + i;

            if (section_header->sh_addr >= program_header->p_vaddr
                && section_header->sh_addr < program_header->p_vaddr + program_header->p_memsz
                    ) {
                index = i;
            }
        }
    }
    else {
        Elf64_Phdr *program_header = ((t_elf64 *)elf)->prog_header + segment_index;
        for (int i = 0; i < ((t_elf64 *)elf)->elf_header->e_shnum; i++) {
            Elf64_Shdr *section_header = ((t_elf64 *)elf)->section_header + i;

            if (section_header->sh_addr >= program_header->p_vaddr
                && section_header->sh_addr < program_header->p_vaddr + program_header->p_memsz
                    ) {
                index = i;
            }
        }
    }

    return index;
}

// Find the text segment based on the fact that the elf entry point is located at the start of the .text section
int find_elf_text_segment(t_elf *elf) {
    int index = -1;

    if(elf->s_type == ELF32) {
        for (int i = 0; i < ((t_elf32 *)elf)->elf_header->e_phnum; i++) {
            if (((t_elf32 *)elf)->prog_header[i].p_type == PT_LOAD
                && ((t_elf32 *)elf)->elf_header->e_entry < (((t_elf32 *)elf)->prog_header[i].p_vaddr + ((t_elf32 *)elf)->prog_header[i].p_filesz)
                && ((t_elf32 *)elf)->elf_header->e_entry > ((t_elf32 *)elf)->prog_header[i].p_vaddr) {
                index = i;
                break;
            }
        }
    }
    else {
        for (int i = 0; i < ((t_elf64 *)elf)->elf_header->e_phnum; i++) {
            if (((t_elf64 *)elf)->prog_header[i].p_type == PT_LOAD
                && ((t_elf64 *)elf)->elf_header->e_entry < (((t_elf64 *)elf)->prog_header[i].p_vaddr + ((t_elf64 *)elf)->prog_header[i].p_filesz)
                && ((t_elf64 *)elf)->elf_header->e_entry > ((t_elf64 *)elf)->prog_header[i].p_vaddr) {
                index = i;
                break;
            }
        }
    }

    return index;
}

int find_elf_segment_index_of_section(t_elf *elf, int section_index) {
    int index = -1;

    if(elf->s_type == ELF32) {
        for (int i = 0; i < ((t_elf32 *)elf)->elf_header->e_phnum; i++) {
            if (((t_elf32 *)elf)->prog_header[i].p_offset <= ((t_elf32 *)elf)->section_header[section_index].sh_offset) {
                index = i;
            } else {
                if (index == -1)
                    index = 0;
                break;
            }
        }
    }
    else {
        for (int i = 0; i < ((t_elf64 *)elf)->elf_header->e_phnum; i++) {
            if (((t_elf64 *)elf)->prog_header[i].p_offset <= ((t_elf64 *)elf)->section_header[section_index].sh_offset) {
                index = i;
            } else {
                if (index == -1)
                    index = 0;
                break;
            }
        }
    }

    return index;
}

char* find_elf_section_name(t_elf *elf, int index) {
    // sh_name contains the index into the section string table of the section name string
    if(elf->s_type == ELF32) {
        int section_string_table_index = ((t_elf32 *)elf)->elf_header->e_shstrndx;
        return ((char *) (((t_elf32 *)elf)->section_data[section_string_table_index] + ((t_elf32 *)elf)->section_header[index].sh_name));
    }
    else {
        int section_string_table_index = ((t_elf64 *)elf)->elf_header->e_shstrndx;
        return ((char *) (((t_elf64 *)elf)->section_data[section_string_table_index] + ((t_elf64 *)elf)->section_header[index].sh_name));
    }
}

int find_elf_section_index(t_elf *elf, char *section_name) {
    if(elf->s_type == ELF32) {
        for (int i = 0; i < ((t_elf32 *)elf)->elf_header->e_shnum; i++) {
            char *s_name = find_elf_section_name(elf, i);
            if (strcmp(section_name, s_name) == 0) {
                return i;
            }
        }
    }
    else {
        for (int i = 0; i < ((t_elf64 *)elf)->elf_header->e_shnum; i++) {
            char *s_name = find_elf_section_name(elf, i);
            if (strcmp(section_name, s_name) == 0) {
                return i;
            }
        }
    }

    return -1;
}

void add_elf_segment_permission(t_elf *elf, int segment_index, int permission) {
    if(elf->s_type == ELF32)
        ((t_elf32 *)elf)->prog_header[segment_index].p_flags |= permission; // NOLINT(hicpp-signed-bitwise)
    else
        ((t_elf64 *)elf)->prog_header[segment_index].p_flags |= permission; // NOLINT(hicpp-signed-bitwise)
}

```

`src/ELF/elf_packing.c`:

```c
//
// Created by silentvoid on 2/25/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "elf_packing.h"
#include "elf_allocation.h"
#include "elf_deallocation.h"
#include "file_functions.h"
#include "elf_encryption.h"
#include "elf_writing.h"
#include "elf_packing_method.h"
#include "packer_config.h"

#include "log.h"

/*
 * Basic ELF structure
 *
 * -----------
 * ELF Header
 * -----------
 * Program header table
 * -----------
 * [section_data]
 * .text
 * .rodata
 * .shstrtab (string table section names)
 * [...]
 * -----------
 * Section header table containing multiple section headers
 * .text header
 * -----------
 *
*/

int pack_elf(char *file, char *file_data, size_t file_data_size, char *output) {
    log_verbose("Detected arch : x%d", packer_config.arch);
    log_info("Allocating ELF in memory ...");

    t_elf *elf = NULL;
    if(allocate_elf(&elf, file_data, file_data_size) == -1) {
        munmap(file_data, file_data_size);
        log_error("Error during ELF allocation");
        return -1;
    }

    // De-allocate mapped file as we don't need it anymore
    munmap(file_data, file_data_size);

    log_info("Encrypting .text section ...");
    if(encrypt_elf(elf) == -1) {
        deallocate_elf(elf);
        log_error("Error during ELF encryption");
        return -1;
    }

    log_info("Packing using specified method ...");
    if(elf_pack_using_method(elf) == -1) {
        deallocate_elf(elf);
        log_error("Error during ELF packing");
        return -1;
    }

    char *filename;
    if(output != NULL)
        filename = output;
    else
        filename = "packed.elf";

    log_info("Writing Packed ELF to file ...");
    if(write_elf(elf, filename) == -1) {
        deallocate_elf(elf);
        log_error("Error during new ELF writing");
        return -1;
    }

    log_success("File %s packed into %s !", file, filename);
    deallocate_elf(elf);

    return 1;
}

```

`src/ELF/elf_packing_method.c`:

```c
//
// Created by silentvoid on 2/28/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "elf_packing_method.h"
#include "elf_allocation.h"
#include "packer_config.h"
#include "elf_packing.h"
#include "elf_section_insertion.h"
#include "elf_silvio_infection.h"
#include "elf_code_cave.h"

#include "log.h"

int elf_pack_using_method(t_elf *elf) {
    if(strcmp(packer_config.packing_method, "section_insertion") == 0) {
        method_config.method_type = SECTION_INSERTION_METHOD;
        if (elf_insert_section(elf) == -1) {
            log_error("Error during Section insertion");
            return -1;
        }
    }
    else if(strcmp(packer_config.packing_method, "code_cave") == 0) {
        method_config.method_type = CODE_CAVE_METHOD;
        if(elf_code_cave_injection(elf) == -1) {
            log_error("Error during Code Cave Injection");
            return -1;
        }
    }
    else if(strcmp(packer_config.packing_method, "silvio_infection") == 0) {
        method_config.method_type = SILVIO_INFECTION_METHOD;
        if(elf_silvio_infect(elf) == -1) {
            log_error("Error during Silvio infection");
            return -1;
        }
    }

    return 1;
}

```

`src/ELF/elf_section_insertion.c`:

```c
//
// Created by silentvoid on 2/26/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "elf_section_insertion.h"
#include "elf_packing_method.h"
#include "elf_functions.h"
#include "loader_functions.h"
#include "packer_config.h"
#include "file_functions.h"
#include "all_elf_loaders_infos.h"

#include "log.h"


Elf64_Shdr new_section64 = {
        .sh_name = 0,
        .sh_type = SHT_PROGBITS,
        .sh_flags = SHF_EXECINSTR | SHF_ALLOC, // NOLINT(hicpp-signed-bitwise)
        .sh_addr = 0,
        .sh_offset = 0,
        .sh_size = 0,
        .sh_link = 0,
        .sh_info = 0,
        .sh_addralign = 16,
        .sh_entsize = 0,
};

Elf32_Shdr new_section32 = {
        .sh_name = 0,
        .sh_type = SHT_PROGBITS,
        .sh_flags = SHF_EXECINSTR | SHF_ALLOC, // NOLINT(hicpp-signed-bitwise)
        .sh_addr = 0,
        .sh_offset = 0,
        .sh_size = 0,
        .sh_link = 0,
        .sh_info = 0,
        .sh_addralign = 16,
        .sh_entsize = 0,
};

int set_new_elf_section_string_table(t_elf *elf) {
    char *new_string_table;

    char *section_name = ".dec";
    size_t section_name_length = strlen(section_name);

    if(elf->s_type == ELF32) {
        int section_string_table_index = ((t_elf32 *)elf)->elf_header->e_shstrndx;

        int old_size = ((t_elf32 *)elf)->section_header[section_string_table_index].sh_size;

        size_t new_string_table_size = ((t_elf32 *)elf)->section_header[section_string_table_index].sh_size + section_name_length + 1;
        new_string_table = realloc(((t_elf32 *)elf)->section_data[section_string_table_index], new_string_table_size);
        if (new_string_table == NULL) {
            log_error("realloc() failure");
            return -1;
        }
        memcpy(new_string_table + old_size, section_name,section_name_length+1);

        // We set it to the end of the old section_string_table
        new_section32.sh_name = old_size;

        ((t_elf32 *)elf)->section_data[section_string_table_index] = new_string_table;
        ((t_elf32 *)elf)->section_header[section_string_table_index].sh_size = new_string_table_size;
    }
    else {
        int section_string_table_index = ((t_elf64 *)elf)->elf_header->e_shstrndx;

        int old_size = ((t_elf64 *)elf)->section_header[section_string_table_index].sh_size;

        size_t new_string_table_size = ((t_elf64 *)elf)->section_header[section_string_table_index].sh_size + section_name_length + 1;
        new_string_table = realloc(((t_elf64 *)elf)->section_data[section_string_table_index], new_string_table_size);
        if (new_string_table == NULL) {
            log_error("realloc() failure");
            return -1;
        }
        memcpy(new_string_table + old_size, section_name,section_name_length+1);

        // We set it to the end of the old section_string_table
        new_section64.sh_name = old_size;

        ((t_elf64 *)elf)->section_data[section_string_table_index] = new_string_table;
        ((t_elf64 *)elf)->section_header[section_string_table_index].sh_size = new_string_table_size;
    }

    return 1;
}

int set_new_elf_section_symtab_sh_link_value(t_elf *elf) {
    if(elf->s_type == ELF32) {
        for (int i = 0; i < ((t_elf32 *)elf)->elf_header->e_shnum; i++) {
            char *section_name = find_elf_section_name(elf, i);
            if (strcmp(section_name, ".symtab") == 0) {
                ((t_elf32 *)elf)->section_header[i].sh_link += 1;
            }
        }
    }
    else {
        for (int i = 0; i < ((t_elf64 *)elf)->elf_header->e_shnum; i++) {
            char *section_name = find_elf_section_name(elf, i);
            if (strcmp(section_name, ".symtab") == 0) {
                ((t_elf64 *)elf)->section_header[i].sh_link += 1;
            }
        }
    }

    return 1;
}

/* Map example
     *
     * --------
     * loadable1
     * --------
     * loadable2
     * --------
     * loadable3 --> last_loadable_section_index
     * --------
     * non_loadable1
     * --------
     * non_loadable2
     * --------
     * new_created_empty_section
     * --------
     *
     * We change it to this :
     *
     * --------
     * loadable1
     * --------
     * loadable2
     * --------
     * loadable3 --> last_loadable_section_index
     * --------
     * new_section_loadable4
     * --------
     * non_loadable1
     * --------
     * non_loadable2
     * --------
     *
*/
int elf_section_create_new_section(t_elf *elf, int last_pt_load_index, int last_loadable_section_index) {
    char **new_section_data;
    char *loader;

    if(elf->s_type == ELF32) {
        Elf32_Shdr *new_section_headers;
        ((t_elf32 *)elf)->elf_header->e_shnum += 1;

        // We realloc to add the new section header
        size_t new_section_headers_size = sizeof(Elf32_Shdr) * ((t_elf32 *)elf)->elf_header->e_shnum;
        new_section_headers = realloc(((t_elf32 *)elf)->section_header, new_section_headers_size);
        if (new_section_headers == NULL) {
            log_error("realloc() failure");
            return -1;
        }

        // We realloc to add the new section data
        size_t new_section_data_size = sizeof(char *) * ((t_elf32 *)elf)->elf_header->e_shnum;
        new_section_data = realloc(((t_elf32 *)elf)->section_data, new_section_data_size);
        if (new_section_data == NULL) {
            log_error("realloc() failure");
            return -1;
        }

        // Re-map to new memory location
        ((t_elf32 *)elf)->section_header = new_section_headers;
        ((t_elf32 *)elf)->section_data = new_section_data;

        // Set new section values
        // sh_offset and sh_addr == end of last loadable segment since we know we will add it there
        new_section32.sh_offset =
                ((t_elf32 *)elf)->prog_header[last_pt_load_index].p_offset + ((t_elf32 *)elf)->prog_header[last_pt_load_index].p_memsz;
        new_section32.sh_addr =
                ((t_elf32 *)elf)->prog_header[last_pt_load_index].p_vaddr + ((t_elf32 *)elf)->prog_header[last_pt_load_index].p_memsz;

        new_section32.sh_size = packer_config.loader_size;

        // For ASM
        loader_offset32 = new_section32.sh_addr;

        loader = patch_loader(x32_ARCH, ELF32, packer_config.cipher);
        if (loader == NULL) {
            free(loader);
            log_error("Error during loader patching");
            return -1;
        }

        // -1 because e_shnum starts at 1 / -1 because we created an empty section which doesn't count
        size_t remaining_after_section_headers_data_size =
                sizeof(Elf32_Shdr) * (((t_elf32 *)elf)->elf_header->e_shnum - last_loadable_section_index - 1 - 1);
        size_t remaining_after_section_headers_count =
                sizeof(char *) * (((t_elf32 *)elf)->elf_header->e_shnum - last_loadable_section_index - 1 - 1);

        // We move all sections after the last loadable section to + 1
        memmove(new_section_headers + last_loadable_section_index + 2,
                new_section_headers + last_loadable_section_index + 1, remaining_after_section_headers_data_size);
        // Shift all char * pointer after the last loadable section to + 1
        memmove(new_section_data + last_loadable_section_index + 2, new_section_data + last_loadable_section_index + 1,
                remaining_after_section_headers_count);

        // Since we append a new section
        last_loadable_section_index += 1;

        // If the section header string table is after our inserted section, we add + 1 to e_shstrndx to correct its index
        if (((t_elf32 *)elf)->elf_header->e_shstrndx >= last_loadable_section_index) {
            ((t_elf32 *)elf)->elf_header->e_shstrndx += 1;
        }

        // We set a new proper section name
        if (set_new_elf_section_string_table(elf) == -1) {
            free(loader);
            log_error("Error setting new string table");
            return -1;
        }

        // Inserting our new loadable section after the last loadable section
        memcpy(new_section_headers + last_loadable_section_index, &new_section32, sizeof(Elf32_Shdr));
        char *new_section_d = malloc(new_section32.sh_size);
        if(new_section_d == NULL) {
            free(loader);
            free(new_section_d);
            log_error("malloc() failure");
            return -1;
        }
        memcpy(new_section_d, loader, packer_config.loader_size);
        ((t_elf32 *)elf)->section_data[last_loadable_section_index] = new_section_d;
    }
    else {
        Elf64_Shdr *new_section_headers;
        ((t_elf64 *)elf)->elf_header->e_shnum += 1;

        size_t new_section_headers_size = sizeof(Elf64_Shdr) * ((t_elf64 *)elf)->elf_header->e_shnum;
        new_section_headers = realloc(((t_elf64 *)elf)->section_header, new_section_headers_size);
        if (new_section_headers == NULL) {
            log_error("realloc() failure");
            return -1;
        }

        size_t new_section_data_size = sizeof(char *) * ((t_elf64 *)elf)->elf_header->e_shnum;
        new_section_data = realloc(((t_elf64 *)elf)->section_data, new_section_data_size);
        if (new_section_data == NULL) {
            log_error("realloc() failure");
            return -1;
        }

        ((t_elf64 *)elf)->section_header = new_section_headers;
        ((t_elf64 *)elf)->section_data = new_section_data;

        new_section64.sh_offset =
                ((t_elf64 *)elf)->prog_header[last_pt_load_index].p_offset + ((t_elf64 *)elf)->prog_header[last_pt_load_index].p_memsz;
        new_section64.sh_addr =
                ((t_elf64 *)elf)->prog_header[last_pt_load_index].p_vaddr + ((t_elf64 *)elf)->prog_header[last_pt_load_index].p_memsz;

        new_section64.sh_size = packer_config.loader_size;

        // For ASM
        loader_offset64 = new_section64.sh_addr;

        loader = patch_loader();
        if (loader == NULL) {
            free(loader);
            log_error("Error during loader patching");
            return -1;
        }

        size_t remaining_after_section_headers_data_size =
                sizeof(Elf64_Shdr) * (((t_elf64 *)elf)->elf_header->e_shnum - last_loadable_section_index - 1 - 1);
        size_t remaining_after_section_headers_count =
                sizeof(char *) * (((t_elf64 *)elf)->elf_header->e_shnum - last_loadable_section_index - 1 - 1);

        memmove(new_section_headers + last_loadable_section_index + 2,
                new_section_headers + last_loadable_section_index + 1, remaining_after_section_headers_data_size);
        memmove(new_section_data + last_loadable_section_index + 2, new_section_data + last_loadable_section_index + 1,
                remaining_after_section_headers_count);

        last_loadable_section_index += 1;

        if (((t_elf64 *)elf)->elf_header->e_shstrndx >= last_loadable_section_index) {
            ((t_elf64 *)elf)->elf_header->e_shstrndx += 1;
        }

        // We set a new proper section name
        if (set_new_elf_section_string_table(elf) == -1) {
            free(loader);
            log_error("Error setting new string table");
            return -1;
        }

        memcpy(new_section_headers + last_loadable_section_index, &new_section64, sizeof(Elf64_Shdr));
        char *new_section_d = malloc(new_section64.sh_size);
        if(new_section_d == NULL) {
            free(loader);
            free(new_section_d);
            log_error("malloc() failure");
            return -1;
        }
        memcpy(new_section_d, loader, packer_config.loader_size);
        ((t_elf64 *)elf)->section_data[last_loadable_section_index] = new_section_d;
    }
    free(loader);

    // Fixing sh_link symbol_table index value
    // https://docs.oracle.com/cd/E19683-01/816-1386/6m7qcoblj/index.html#chapter6-47976
    if (set_new_elf_section_symtab_sh_link_value(elf) == -1) {
        log_error("Error modifying symtab sh_link value");
        return -1;
    }

    return 1;
}

int elf_section_set_new_segment_values(t_elf *elf, int segment_index) {
    if(elf->s_type == ELF32) {
        // Set new segment size with our new section included
        size_t new_segment_size = ((t_elf32 *)elf)->prog_header[segment_index].p_memsz + packer_config.loader_size;
        ((t_elf32 *)elf)->prog_header[segment_index].p_memsz = new_segment_size;
        ((t_elf32 *)elf)->prog_header[segment_index].p_filesz = new_segment_size;
    }
    else {
        size_t new_segment_size = ((t_elf64 *)elf)->prog_header[segment_index].p_memsz + packer_config.loader_size;
        ((t_elf64 *)elf)->prog_header[segment_index].p_memsz = new_segment_size;
        ((t_elf64 *)elf)->prog_header[segment_index].p_filesz = new_segment_size;
    }

    // Set all pt_loader permissions on RWX (pretty ugly)
    set_new_elf_section_pt_loader_permissions(elf);

    return 1;
}

int elf_section_set_new_section_values(t_elf *elf, int section_index) {
    if(elf->s_type == ELF32) {
        // We shift each section offset to make it correct since we moved sections to leave space for our inserted section
        for (int i = section_index; i < ((t_elf32 *)elf)->elf_header->e_shnum - 1; i++) {
            ((t_elf32 *)elf)->section_header[i + 1].sh_offset = ((t_elf32 *)elf)->section_header[i].sh_offset + ((t_elf32 *)elf)->section_header[i].sh_size;
        }

        // We change the offset of the start of the section header to be correct
        // We set it at the end of the last section data == start of section headers (c.f elf structure)
        int section_count = ((t_elf32 *)elf)->elf_header->e_shnum;
        ((t_elf32 *)elf)->elf_header->e_shoff = ((t_elf32 *)elf)->section_header[section_count - 1].sh_offset + ((t_elf32 *)elf)->section_header[section_count - 1].sh_size;
    }
    else {
        for (int i = section_index; i < ((t_elf64 *)elf)->elf_header->e_shnum - 1; i++) {
            ((t_elf64 *)elf)->section_header[i + 1].sh_offset = ((t_elf64 *)elf)->section_header[i].sh_offset + ((t_elf64 *)elf)->section_header[i].sh_size;
        }

        int section_count = ((t_elf64 *)elf)->elf_header->e_shnum;
        ((t_elf64 *)elf)->elf_header->e_shoff = ((t_elf64 *)elf)->section_header[section_count - 1].sh_offset + ((t_elf64 *)elf)->section_header[section_count - 1].sh_size;
    }

    return 1;
}

void print_link_fields(t_elf *elf) {
    if(elf->s_type == ELF32) {
        for (int i = 0; i < ((t_elf32 *)elf)->elf_header->e_shnum; i++) {
            printf("section_name : %s\n", find_elf_section_name(elf, i));
            printf("sh_type : %d\n", ((t_elf32 *)elf)->section_header[i].sh_type);
            printf("sh_link : %d\n", ((t_elf32 *)elf)->section_header[i].sh_link);
            printf("\n");
        }
    }
    else {
        for (int i = 0; i < ((t_elf64 *)elf)->elf_header->e_shnum; i++) {
            printf("section_name : %s\n", find_elf_section_name(elf, i));
            printf("sh_type : %d\n", ((t_elf64 *)elf)->section_header[i].sh_type);
            printf("sh_link : %d\n", ((t_elf64 *)elf)->section_header[i].sh_link);
            printf("\n");
        }
    }
}

int set_new_elf_section_pt_loader_permissions(t_elf *elf) {
    if(elf->s_type == ELF32) {
        for (int i = 0; i < ((t_elf32 *)elf)->elf_header->e_phnum; i++) {
            if (((t_elf32 *)elf)->prog_header[i].p_type == PT_LOAD) {
                ((t_elf32 *)elf)->prog_header[i].p_flags = PF_X | PF_W | PF_R; // NOLINT(hicpp-signed-bitwise)
            }
        }
    }
    else {
        for (int i = 0; i < ((t_elf64 *)elf)->elf_header->e_phnum; i++) {
            if (((t_elf64 *)elf)->prog_header[i].p_type == PT_LOAD) {
                ((t_elf64 *)elf)->prog_header[i].p_flags = PF_X | PF_W | PF_R; // NOLINT(hicpp-signed-bitwise)
            }
        }
    }

    return 1;
}

int elf_insert_section(t_elf *elf) {
    int last_pt_load_index = find_last_elf_segment_of_type(elf, PT_LOAD);
    if(last_pt_load_index == -1) {
        log_error("Couldn't find PT_LOAD segment");
        return -1;
    }

    int last_loadable_section_index = find_last_elf_section_from_segment(elf, last_pt_load_index);
    if(last_loadable_section_index == -1) {
        log_error("Couldn't find the last Section index");
        return -1;
    }

    log_verbose("Creating new section ...");

    if(elf_section_create_new_section(elf, last_pt_load_index, last_loadable_section_index) == -1) {
        log_error("Error during new Section creation");
        return -1;
    }

    // Since we appended a new section
    last_loadable_section_index += 1;
    method_config.concerned_section = last_loadable_section_index;

    log_verbose("Setting new segment values ...");

    if(elf_section_set_new_segment_values(elf, last_pt_load_index) == -1) {
        log_error("Couldn't set new segment values");
        return -1;
    }

    log_verbose("Setting new section values ...");

    if(elf_section_set_new_section_values(elf, last_loadable_section_index) == -1) {
        log_error("Couldn't set new section values");
        return -1;
    }

    log_verbose("Setting new ELF entry point ...");

    // Add our new section as the new elf entry point
    set_new_elf_entry_to_section(elf, last_loadable_section_index);

    return 1;
}
```

`src/ELF/elf_silvio_infection.c`:

```c
//
// Created by silentvoid on 2/28/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "elf_silvio_infection.h"
#include "elf_functions.h"
#include "elf_allocation.h"
#include "loader_functions.h"
#include "elf_packing_method.h"
#include "file_functions.h"
#include "packer_config.h"
#include "all_elf_loaders_infos.h"

#include "log.h"

Elf32_Addr loader_addr32;
Elf64_Addr loader_addr64;

int set_new_elf_silvio_segment_values(t_elf *elf, int text_segment_index) {
    if(elf->s_type == ELF32) {
        loader_addr32 = ((t_elf32 *)elf)->prog_header[text_segment_index].p_vaddr + ((t_elf32 *)elf)->prog_header[text_segment_index].p_filesz;

        ((t_elf32 *)elf)->prog_header[text_segment_index].p_filesz += packer_config.loader_size;
        ((t_elf32 *)elf)->prog_header[text_segment_index].p_memsz += packer_config.loader_size;

        for (int i = text_segment_index + 1; i < ((t_elf32 *)elf)->elf_header->e_phnum; i++) {
            ((t_elf32 *)elf)->prog_header[i].p_offset += PAGE_SIZE32;
        }
    }
    else {
        loader_addr64 = ((t_elf64 *)elf)->prog_header[text_segment_index].p_vaddr + ((t_elf64 *)elf)->prog_header[text_segment_index].p_filesz;

        ((t_elf64 *)elf)->prog_header[text_segment_index].p_filesz += packer_config.loader_size;
        ((t_elf64 *)elf)->prog_header[text_segment_index].p_memsz += packer_config.loader_size;

        for (int i = text_segment_index + 1; i < ((t_elf64 *)elf)->elf_header->e_phnum; i++) {
            ((t_elf64 *)elf)->prog_header[i].p_offset += PAGE_SIZE64;
        }
    }

    return 1;
}

int set_new_elf_silvio_section_values(t_elf *elf, int last_section_index) {
    if(elf->s_type == ELF32) {
        ((t_elf32 *)elf)->elf_header->e_shoff += PAGE_SIZE32;

        ((t_elf32 *)elf)->section_header[last_section_index].sh_size += packer_config.loader_size;

        for (int i = last_section_index + 1; i < ((t_elf32 *)elf)->elf_header->e_shnum; i++) {
            ((t_elf32 *)elf)->section_header[i].sh_offset += PAGE_SIZE32;
        }
    }
    else {
        ((t_elf64 *)elf)->elf_header->e_shoff += PAGE_SIZE64;

        ((t_elf64 *)elf)->section_header[last_section_index].sh_size += packer_config.loader_size;

        for (int i = last_section_index + 1; i < ((t_elf64 *)elf)->elf_header->e_shnum; i++) {
            ((t_elf64 *)elf)->section_header[i].sh_offset += PAGE_SIZE64;
        }
    }

    return 1;
}

int elf_silvio_insert_loader(t_elf *elf, int section_index, int old_section_size) {
    char *new_section_data;
    char *loader;
    if(elf->s_type == ELF32) {
        size_t new_section_data_size = ((t_elf32 *)elf)->section_header[section_index].sh_size;
        new_section_data = realloc(((t_elf32 *)elf)->section_data[section_index], new_section_data_size);
        if (new_section_data == NULL) {
            log_error("realloc() failure");
            return -1;
        }
        ((t_elf32 *)elf)->section_data[section_index] = new_section_data;

        // For ASM
        loader_offset32 = loader_addr32;

        loader = patch_loader();
        if(loader == NULL) {
            free(loader);
            log_error("Error during loader patching");
            return -1;
        }
        memcpy(new_section_data + old_section_size, loader, packer_config.loader_size);
    }
    else {
        size_t new_section_data_size = ((t_elf64 *)elf)->section_header[section_index].sh_size;
        new_section_data = realloc(((t_elf64 *)elf)->section_data[section_index], new_section_data_size);
        if (new_section_data == NULL) {
            log_error("realloc() failure");
            return -1;
        }
        ((t_elf64 *)elf)->section_data[section_index] = new_section_data;

        // For ASM
        loader_offset64 = loader_addr64;

        loader = patch_loader();
        if(loader == NULL) {
            free(loader);
            log_error("Error during loader patching");
            return -1;

        }
        memcpy(new_section_data + old_section_size, loader, packer_config.loader_size);
    }
    free(loader);

    return 1;
}

int elf_silvio_infect(t_elf *elf) {
    int text_segment_index = find_elf_text_segment(elf);
    if(text_segment_index == -1) {
        log_error("Couldn't find .text segment");
        return -1;
    }

    int last_section_index = find_last_elf_section_from_segment(elf, text_segment_index);
    if(last_section_index == -1) {
        log_error("Couldn't find last section from .text segment");
        return -1;
    }
    method_config.concerned_section = last_section_index;


    int old_section_size;
    if(elf->s_type == ELF32)
        old_section_size = ((t_elf32 *)elf)->section_header[last_section_index].sh_size;
    else
        old_section_size = ((t_elf64 *)elf)->section_header[last_section_index].sh_size;


    log_verbose("Setting new section values ...");

    set_new_elf_silvio_section_values(elf, last_section_index);

    log_verbose("Setting new segment values ...");

    set_new_elf_silvio_segment_values(elf, text_segment_index);

    log_verbose("Inserting the loader ...");

    if(elf_silvio_insert_loader(elf, last_section_index, old_section_size) == -1) {
        log_error("Loader insertion failed");
        return -1;
    }

    // Add write permission to be able to decrypt it
    add_elf_segment_permission(elf, text_segment_index, PF_W); // NOLINT(hicpp-signed-bitwise)

    log_verbose("Setting new ELF entry point ...");

    if(elf->s_type == ELF32) {
        set_new_elf_entry_to_addr32(elf, loader_addr32, last_section_index, old_section_size);
    }
    else {
        set_new_elf_entry_to_addr64(elf, loader_addr64, last_section_index, old_section_size);
    }

    return 1;
}
```

`src/ELF/elf_writing.c`:

```c
//
// Created by silentvoid on 2/26/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "elf_writing.h"
#include "elf_allocation.h"
#include "file_functions.h"
#include "elf_packing_method.h"
#include "loader_functions.h"
#include "packer_config.h"
#include "all_elf_loaders_infos.h"

#include "log.h"



int write_elf(t_elf *elf, char *filename) {
    int fd = open(filename, O_CREAT | O_WRONLY | O_TRUNC, 0755); // NOLINT(hicpp-signed-bitwise)
    if(fd < 0) {
        log_error("open() failure");
        return -1;
    }

    if(elf->s_type == ELF32) {
        log_verbose("Writing ELF header ...");
        write_to_file(fd, ((t_elf32 *)elf)->elf_header, sizeof(Elf32_Ehdr));
        add_zero_padding(fd, ((t_elf32 *)elf)->elf_header->e_phoff);

        log_verbose("Writing Program header ...");
        write_to_file(fd, ((t_elf32 *)elf)->prog_header, sizeof(Elf32_Phdr) * ((t_elf32 *)elf)->elf_header->e_phnum);

        log_verbose("Writing Sections data ...");
        for (int i = 0; i < ((t_elf32 *)elf)->elf_header->e_shnum; i++) {
            if (((t_elf32 *)elf)->section_header[i].sh_type != SHT_NOBITS) {
                add_zero_padding(fd, ((t_elf32 *)elf)->section_header[i].sh_offset);

                // If we find the section with the code cave
                if (method_config.method_type == CODE_CAVE_METHOD && i == method_config.concerned_section) {
                    write_to_file(fd, ((t_elf32 *)elf)->section_data[i], ((t_elf32 *)elf)->section_header[i].sh_size + packer_config.loader_size);
                } else {
                    write_to_file(fd, ((t_elf32 *)elf)->section_data[i], ((t_elf32 *)elf)->section_header[i].sh_size);
                }
            }
        }
        add_zero_padding(fd, ((t_elf32 *)elf)->elf_header->e_shoff);

        log_verbose("Writing Sections headers ...");
        for (int i = 0; i < ((t_elf32 *)elf)->elf_header->e_shnum; i++) {
            write_to_file(fd, &(((t_elf32 *)elf)->section_header[i]), sizeof(Elf32_Shdr));
        }
    }
    else {
        log_verbose("Writing ELF header ...");
        write_to_file(fd, ((t_elf64 *)elf)->elf_header, sizeof(Elf64_Ehdr));
        add_zero_padding(fd, ((t_elf64 *)elf)->elf_header->e_phoff);

        log_verbose("Writing Program header ...");
        write_to_file(fd, ((t_elf64 *)elf)->prog_header, sizeof(Elf64_Phdr) * ((t_elf64 *)elf)->elf_header->e_phnum);

        log_verbose("Writing Sections data ...");
        for (int i = 0; i < ((t_elf64 *)elf)->elf_header->e_shnum; i++) {
            if (((t_elf64 *)elf)->section_header[i].sh_type != SHT_NOBITS) {
                add_zero_padding(fd, ((t_elf64 *)elf)->section_header[i].sh_offset);

                // If we find the section with the code cave
                if (method_config.method_type == CODE_CAVE_METHOD && i == method_config.concerned_section) {
                    write_to_file(fd, ((t_elf64 *)elf)->section_data[i], ((t_elf64 *)elf)->section_header[i].sh_size + packer_config.loader_size);
                } else {
                    write_to_file(fd, ((t_elf64 *)elf)->section_data[i], ((t_elf64 *)elf)->section_header[i].sh_size);
                }
            }
        }
        add_zero_padding(fd, ((t_elf64 *)elf)->elf_header->e_shoff);

        log_verbose("Writing Sections headers ...");
        for (int i = 0; i < ((t_elf64 *)elf)->elf_header->e_shnum; i++) {
            write_to_file(fd, &(((t_elf64 *) elf)->section_header[i]), sizeof(Elf64_Shdr));
        }
    }

    close(fd);

    return 1;
}
```

`src/PE/pe_allocation.c`:

```c
//
// Created by silentvoid on 3/16/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "pe_allocation.h"
#include "pe_deallocation.h"
#include "file_functions.h"

#include "log.h"

int allocate_pe_dos_header(t_pe *pe, void *file_data, size_t file_data_size) {
    if(file_data_size < sizeof(IMAGE_DOS_HEADER)) {
        log_error("Total file size is less than DOS Header size");
        return -1;
    }

    // PE32 and PE32+ have the same DOS Header

    ((t_pe32 *)pe)->dos_header = malloc(sizeof(IMAGE_DOS_HEADER));
    if (((t_pe32 *)pe)->dos_header == NULL) {
        deallocate_pe_dos_header(pe);
        log_error("malloc() failure");
        return -1;
    }
    memcpy(((t_pe32 *)pe)->dos_header, file_data, sizeof(IMAGE_DOS_HEADER));

    // 0x5a4d
    if (((t_pe32 *)pe)->dos_header->e_magic != DOSMAG) {
        deallocate_pe_dos_header(pe);
        log_error("Magic bytes do not match PE file");
        return -1;
    }

    // TODO : check architecture like in ELF

    return 1;
}

int allocate_pe_dos_stub(t_pe *pe, void *file_data) {
    size_t dos_stub_size = ((t_pe32 *)pe)->dos_header->e_lfanew - sizeof(IMAGE_DOS_HEADER);

    // PE32 and PE32+ have the same DOS Stub

    ((t_pe32 *)pe)->dos_stub = malloc(dos_stub_size);
    if(((t_pe32 *)pe)->dos_stub == NULL) {
        deallocate_pe_dos_stub(pe);
        log_error("malloc() failure");
        return -1;
    }
    memcpy(((t_pe32 *)pe)->dos_stub, file_data + sizeof(IMAGE_DOS_HEADER), dos_stub_size);

    return 1;
}

int allocate_pe_pe_header(t_pe *pe, void *file_data, size_t file_data_size) {
    if(pe->s_type == PE32) {
        if (file_data_size < sizeof(IMAGE_NT_HEADERS32)) {
            log_error("Total file size is less than PE Header size");
            return -1;
        }

        ((t_pe32 *)pe)->pe_header = malloc(sizeof(IMAGE_NT_HEADERS32));
        if (((t_pe32 *)pe)->pe_header == NULL) {
            deallocate_pe_pe_header(pe);
            log_error("malloc() failure");
            return -1;
        }
        memcpy(((t_pe32 *)pe)->pe_header, file_data + ((t_pe32 *)pe)->dos_header->e_lfanew, sizeof(IMAGE_NT_HEADERS32));

        if ((((t_pe32 *)pe)->pe_header->FileHeader.Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE) == 0) { // NOLINT(hicpp-signed-bitwise)
            deallocate_pe_pe_header(pe);
            log_error("The file is not an executable");
            return -1;
        }

        if (((t_pe32 *)pe)->pe_header->FileHeader.SizeOfOptionalHeader == 0) {
            deallocate_pe_pe_header(pe);
            log_error("The file is an OBJ file");
            return -1;
        }

        if (((t_pe32 *)pe)->pe_header->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            deallocate_pe_pe_header(pe);
            log_error("File is not an executable image");
            return -1;
        }
    }
    else {
        if (file_data_size < sizeof(IMAGE_NT_HEADERS64)) {
            log_error("Total file size is less than PE Header size");
            return -1;
        }

        ((t_pe64 *)pe)->pe_header = malloc(sizeof(IMAGE_NT_HEADERS64));
        if (((t_pe64 *)pe)->pe_header == NULL) {
            deallocate_pe_pe_header(pe);
            log_error("malloc() failure");
            return -1;
        }
        memcpy(((t_pe64 *)pe)->pe_header, file_data + ((t_pe64 *)pe)->dos_header->e_lfanew, sizeof(IMAGE_NT_HEADERS64));

        if ((((t_pe64 *)pe)->pe_header->FileHeader.Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE) == 0) { // NOLINT(hicpp-signed-bitwise)
            deallocate_pe_pe_header(pe);
            log_error("The file is not an executable");
            return -1;
        }

        if (((t_pe64 *)pe)->pe_header->FileHeader.SizeOfOptionalHeader == 0) {
            deallocate_pe_pe_header(pe);
            log_error("The file is an OBJ file");
            return -1;
        }

        if (((t_pe64 *)pe)->pe_header->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
            deallocate_pe_pe_header(pe);
            log_error("File is not an executable image");
            return -1;
        }
    }

    return 1;
}

int allocate_pe_sections_headers(t_pe *pe, void *file_data, size_t file_data_size) {
    if(pe->s_type == PE32) {
        size_t pe_sections_header_size = sizeof(IMAGE_SECTION_HEADER) * ((t_pe32 *)pe)->pe_header->FileHeader.NumberOfSections;

        ((t_pe32 *)pe)->section_header = malloc(pe_sections_header_size);
        if (((t_pe32 *)pe)->section_header == NULL) {
            deallocate_pe_sections_headers(pe);
            log_error("malloc() failure");
            return -1;
        }
        memset(((t_pe32 *)pe)->section_header, 0, pe_sections_header_size);

        // TODO: Check for IMAGE_SCN_CNT_UNINITIALIZED_DATA type like in elf_allocation
        for (int i = 0; i < ((t_pe32 *)pe)->pe_header->FileHeader.NumberOfSections; i++) {
            if (file_data_size <
                ((t_pe32 *)pe)->dos_header->e_lfanew + sizeof(IMAGE_NT_HEADERS32) + (i * sizeof(IMAGE_SECTION_HEADER))) {
                deallocate_pe_sections_headers(pe);
                log_error("Total file size is inferior to PE section header size");
                return -1;
            }
            memcpy(&(((t_pe32 *)pe)->section_header[i]), file_data + ((t_pe32 *)pe)->dos_header->e_lfanew + sizeof(IMAGE_NT_HEADERS32) +
                                             (i * sizeof(IMAGE_SECTION_HEADER)), sizeof(IMAGE_SECTION_HEADER));
        }
    }
    else {
        size_t pe_sections_header_size = sizeof(IMAGE_SECTION_HEADER) * ((t_pe64 *)pe)->pe_header->FileHeader.NumberOfSections;

        ((t_pe64 *)pe)->section_header = malloc(pe_sections_header_size);
        if (((t_pe64 *)pe)->section_header == NULL) {
            deallocate_pe_sections_headers(pe);
            log_error("malloc() failure");
            return -1;
        }
        memset(((t_pe64 *)pe)->section_header, 0, pe_sections_header_size);

        // TODO: Check for IMAGE_SCN_CNT_UNINITIALIZED_DATA type like in elf_allocation
        for (int i = 0; i < ((t_pe64 *)pe)->pe_header->FileHeader.NumberOfSections; i++) {
            if (file_data_size <
                ((t_pe64 *)pe)->dos_header->e_lfanew + sizeof(IMAGE_NT_HEADERS64) + (i * sizeof(IMAGE_SECTION_HEADER))) {
                deallocate_pe_sections_headers(pe);
                log_error("Total file size is inferior to PE section header size");
                return -1;
            }
            memcpy(&(((t_pe64 *)pe)->section_header[i]), file_data + ((t_pe64 *)pe)->dos_header->e_lfanew + sizeof(IMAGE_NT_HEADERS64) +
                                                         (i * sizeof(IMAGE_SECTION_HEADER)), sizeof(IMAGE_SECTION_HEADER));
        }
    }

    return 1;
}

int allocate_pe_sections_data(t_pe *pe, void *file_data, size_t file_data_size) {
    if(pe->s_type == PE32) {
        size_t section_data_size = sizeof(char *) * ((t_pe32 *)pe)->pe_header->FileHeader.NumberOfSections;

        ((t_pe32 *)pe)->section_data = malloc(section_data_size);
        if (((t_pe32 *)pe)->section_data == NULL) {
            deallocate_pe_sections_data(pe);
            log_error("malloc() failure");
            return -1;
        }
        memset(((t_pe32 *)pe)->section_data, 0, section_data_size);

        // TODO: Free all the malloc section_data_data up to i
        size_t pe_section_data_size;
        for (int i = 0; i < ((t_pe32 *)pe)->pe_header->FileHeader.NumberOfSections; i++) {
            if (file_data_size < ((t_pe32 *)pe)->section_header[i].PointerToRawData) {
                log_error("Total file size is less than section data offset");
                return -1;
            }
            pe_section_data_size = ((t_pe32 *)pe)->section_header[i].SizeOfRawData;

            ((t_pe32 *)pe)->section_data[i] = malloc(pe_section_data_size);
            if (((t_pe32 *)pe)->section_data[i] == NULL) {
                free(((t_pe32 *)pe)->section_data[i]);
                log_error("malloc() error");
                return -1;
            }
            memset(((t_pe32 *)pe)->section_data[i], 0, pe_section_data_size);
            memcpy(((t_pe32 *)pe)->section_data[i], file_data + ((t_pe32 *)pe)->section_header[i].PointerToRawData, pe_section_data_size);
        }
    }
    else {
        size_t section_data_size = sizeof(char *) * ((t_pe64 *)pe)->pe_header->FileHeader.NumberOfSections;

        ((t_pe64 *)pe)->section_data = malloc(section_data_size);
        if (((t_pe64 *)pe)->section_data == NULL) {
            deallocate_pe_sections_data(pe);
            log_error("malloc() failure");
            return -1;
        }
        memset(((t_pe64 *)pe)->section_data, 0, section_data_size);

        size_t pe_section_data_size;
        for (int i = 0; i < ((t_pe64 *)pe)->pe_header->FileHeader.NumberOfSections; i++) {
            if (file_data_size < ((t_pe64 *)pe)->section_header[i].PointerToRawData) {
                log_error("Total file size is less than section data offset");
                return -1;
            }
            pe_section_data_size = ((t_pe64 *)pe)->section_header[i].SizeOfRawData;

            ((t_pe64 *)pe)->section_data[i] = malloc(pe_section_data_size);
            if (((t_pe64 *)pe)->section_data[i] == NULL) {
                free(((t_pe64 *)pe)->section_data[i]);
                log_error("malloc() error");
                return -1;
            }
            memset(((t_pe64 *)pe)->section_data[i], 0, pe_section_data_size);
            memcpy(((t_pe64 *)pe)->section_data[i], file_data + ((t_pe64 *)pe)->section_header[i].PointerToRawData, pe_section_data_size);
        }
    }

    return 1;
}

void print_pe_info(t_pe *pe) {
    if(pe->s_type == PE32) {
        printf("e_lfanew : %d\n", ((t_pe32 *)pe)->dos_header->e_lfanew);
        printf("section_header size : %ld\n",
               sizeof(IMAGE_SECTION_HEADER) * ((t_pe32 *)pe)->pe_header->FileHeader.NumberOfSections);

        for (int i = 0; i < ((t_pe32 *)pe)->pe_header->FileHeader.NumberOfSections; i++) {
            printf("section_offset: %d\n", ((t_pe32 *)pe)->section_header[i].PointerToRawData);
            printf("section_size : %d\n", ((t_pe32 *)pe)->section_header[i].SizeOfRawData);
            if (i != ((t_pe32 *)pe)->pe_header->FileHeader.NumberOfSections - 1) {
                printf("next_section_offset : %d\n", ((t_pe32 *)pe)->section_header[i + 1].PointerToRawData);
            }
            printf("\n");
        }
    }
    else {
        printf("e_lfanew : %d\n", ((t_pe64 *)pe)->dos_header->e_lfanew);
        printf("section_header size : %ld\n",
               sizeof(IMAGE_SECTION_HEADER) * ((t_pe64 *)pe)->pe_header->FileHeader.NumberOfSections);

        for (int i = 0; i < ((t_pe64 *)pe)->pe_header->FileHeader.NumberOfSections; i++) {
            printf("section_offset: %d\n", ((t_pe64 *)pe)->section_header[i].PointerToRawData);
            printf("section_size : %d\n", ((t_pe64 *)pe)->section_header[i].SizeOfRawData);
            if (i != ((t_pe64 *)pe)->pe_header->FileHeader.NumberOfSections - 1) {
                printf("next_section_offset : %d\n", ((t_pe64 *)pe)->section_header[i + 1].PointerToRawData);
            }
            printf("\n");
        }
    }
}

int allocate_pe(t_pe **pe, void *file_data, size_t file_data_size, int arch) {
    size_t t_pe_size;
    if(arch == x32_ARCH) {
        t_pe_size = sizeof(t_pe32);
    }
    else {
        t_pe_size = sizeof(t_pe64);
    }

    *pe = malloc(t_pe_size);
    if(*pe == NULL) {
        deallocate_pe_struct(*pe);
        log_error("malloc() failure");
        return -1;
    }
    memset(*pe, 0, t_pe_size);

    t_pe type_pe;
    if(arch == 32) {
        type_pe.s_type = PE32;
        ((t_pe32 *)(*pe))->type_header = type_pe;
    }
    else {
        type_pe.s_type = PE64;
        ((t_pe32 *)(*pe))->type_header = type_pe;
    }

    log_verbose("Allocating DOS Header ...");
    if(allocate_pe_dos_header(*pe, file_data, file_data_size) == -1) {
        deallocate_pe_struct(*pe);
        log_error("Error during DOS Header allocation");
        return -1;
    }

    log_verbose("Allocating DOS Stub ...");
    if(allocate_pe_dos_stub(*pe, file_data) == -1) {
        deallocate_pe_dos_header(*pe);
        deallocate_pe_struct(*pe);
        log_error("Error during DOS Stub allocation");
        return -1;
    }

    log_verbose("Allocating PE Header ...");
    if(allocate_pe_pe_header(*pe, file_data, file_data_size) == -1) {
        deallocate_pe_dos_header(*pe);
        deallocate_pe_dos_stub(*pe);
        deallocate_pe_struct(*pe);
        log_error("Error during PE Header allocation");
        return -1;
    }

    log_verbose("Allocating Sections Headers ...");
    if(allocate_pe_sections_headers(*pe, file_data, file_data_size) == -1) {
        deallocate_pe_dos_header(*pe);
        deallocate_pe_dos_stub(*pe);
        deallocate_pe_pe_header(*pe);
        deallocate_pe_struct(*pe);
        log_error("Error during Section Headers allocation");
        return -1;
    }

    log_verbose("Allocating Sections Data ...");
    if(allocate_pe_sections_data(*pe, file_data, file_data_size) == -1) {
        deallocate_pe_dos_header(*pe);
        deallocate_pe_dos_stub(*pe);
        deallocate_pe_pe_header(*pe);
        deallocate_pe_sections_headers(*pe);
        deallocate_pe_struct(*pe);
        log_error("Error during Section Data allocation");
        return -1;
    }

    //print_pe_info(*pe);

    return 1;
}
```

`src/PE/pe_code_cave.c`:

```c
//
// Created by silentvoid on 3/18/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "pe_code_cave.h"
#include "pe_struct.h"
#include "pe_allocation.h"
#include "pe_functions.h"
#include "loader_functions.h"
#include "file_functions.h"
#include "packer_config.h"
#include "all_pe_loaders_infos.h"

#include "log.h"

int find_pe_code_cave_index(t_pe *pe) {
    size_t code_cave_size;

    if(pe->s_type == PE32) {
        for (int i = 0; i < ((t_pe32 *)pe)->pe_header->FileHeader.NumberOfSections - 1; i++) {
            if (((t_pe32 *)pe)->section_header[i].SizeOfRawData > ((t_pe32 *)pe)->section_header[i].Misc.VirtualSize) {
                code_cave_size = ((t_pe32 *)pe)->section_header[i].SizeOfRawData - ((t_pe32 *)pe)->section_header[i].Misc.VirtualSize;

                //print_pe_section_info(pe, i);

                if (code_cave_size > packer_config.loader_size) {
                    return i;
                }
            }
        }
    }
    else {
        for (int i = 0; i < ((t_pe64 *)pe)->pe_header->FileHeader.NumberOfSections - 1; i++) {
            if (((t_pe64 *)pe)->section_header[i].SizeOfRawData > ((t_pe64 *)pe)->section_header[i].Misc.VirtualSize) {
                code_cave_size = ((t_pe64 *)pe)->section_header[i].SizeOfRawData - ((t_pe64 *)pe)->section_header[i].Misc.VirtualSize;

                //print_pe_section_info(pe, i);

                if (code_cave_size > packer_config.loader_size) {
                    return i;
                }
            }
        }
    }

    return -1;
}

int set_new_pe_cave_section_values(t_pe *pe, int section_index) {
    if(pe->s_type == PE32)
        ((t_pe32 *)pe)->section_header[section_index].Misc.VirtualSize += packer_config.loader_size;
    else
        ((t_pe64 *)pe)->section_header[section_index].Misc.VirtualSize += packer_config.loader_size;

    // TODO: Change this to use mprotect in the loader

    int text_section_index = find_pe_text_section(pe);
    if(text_section_index == -1) {
        log_error("Couldn't find .text segment");
        return -1;
    }
    add_pe_section_permission(pe, text_section_index, IMAGE_SCN_MEM_WRITE); // NOLINT(hicpp-signed-bitwise)

    add_pe_section_permission(pe, section_index, IMAGE_SCN_MEM_WRITE); // NOLINT(hicpp-signed-bitwise)
    add_pe_section_permission(pe, section_index, IMAGE_SCN_MEM_READ); // NOLINT(hicpp-signed-bitwise)
    add_pe_section_permission(pe, section_index, IMAGE_SCN_MEM_EXECUTE); // NOLINT(hicpp-signed-bitwise)

    return 1;
}

int pe_cave_insert_loader(t_pe *pe, int section_index, int old_section_size) {
    char *new_section_data;
    char *loader;

    if(pe->s_type == PE32) {
        new_section_data = realloc(((t_pe32 *)pe)->section_data[section_index], old_section_size + packer_config.loader_size);
        if (new_section_data == NULL) {
            log_error("realloc() failure");
            return -1;
        }
        ((t_pe32 *)pe)->section_data[section_index] = new_section_data;

        // For ASM
        loader_offset32 = ((t_pe32 *)pe)->section_header[section_index].VirtualAddress + old_section_size;

        loader = patch_loader();
        if(loader == NULL) {
            free(loader);
            log_error("Error during loader patching");
            return -1;
        }
        memcpy(new_section_data + old_section_size, loader, packer_config.loader_size);
    }
    else {
        new_section_data = realloc(((t_pe64 *)pe)->section_data[section_index], old_section_size + packer_config.loader_size);
        if (new_section_data == NULL) {
            log_error("realloc() failure");
            return -1;
        }
        ((t_pe64 *)pe)->section_data[section_index] = new_section_data;

        // For ASM
        loader_offset64 = ((t_pe64 *)pe)->section_header[section_index].VirtualAddress + old_section_size;

        loader = patch_loader();
        if(loader == NULL) {
            free(loader);
            log_error("Error during loader patching");
            return -1;
        }
        memcpy(new_section_data + old_section_size, loader, packer_config.loader_size);
    }
    free(loader);

    return 1;
}

int pe_code_cave_injection(t_pe *pe) {

    log_verbose("Finding a code cave ...");

    int section_cave_index = find_pe_code_cave_index(pe);
    if(section_cave_index == -1) {
        log_error("Couldn't find any code cave in this PE file");
        return -1;
    }

    log_verbose("Setting new section values ...");


    int old_section_size;
    if(pe->s_type == PE32)
        old_section_size = ((t_pe32 *)pe)->section_header[section_cave_index].Misc.VirtualSize;
    else
        old_section_size = ((t_pe64 *)pe)->section_header[section_cave_index].Misc.VirtualSize;

    if(set_new_pe_cave_section_values(pe, section_cave_index) == -1) {
        log_error("Error during section values modification");
        return -1;
    }

    log_verbose("Inserting the loader inside the code cave ...");

    if(pe_cave_insert_loader(pe, section_cave_index, old_section_size) == -1) {
        log_error("Error during Loader insertion");
        return -1;
    }

    log_verbose("Setting new PE entry point ...");

    uint32_t loader_addr;
    if(pe->s_type == PE32)
        loader_addr = ((t_pe32 *)pe)->section_header[section_cave_index].VirtualAddress + old_section_size;
    else
        loader_addr = ((t_pe64 *)pe)->section_header[section_cave_index].VirtualAddress + old_section_size;

    set_new_pe_entry_to_addr(pe, loader_addr, section_cave_index, old_section_size);

    return 1;
}
```

`src/PE/pe_deallocation.c`:

```c
//
// Created by silentvoid on 4/12/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "pe_deallocation.h"
#include "pe_allocation.h"

void deallocate_pe_dos_header(t_pe *pe) {
    if(pe->s_type == PE32) {
        free(((t_pe32 *)pe)->dos_header);
    }
    else {
        free(((t_pe64 *)pe)->dos_header);
    }
}
void deallocate_pe_dos_stub(t_pe *pe) {
    if(pe->s_type == PE32) {
        free(((t_pe32 *)pe)->dos_stub);
    }
    else {
        free(((t_pe64 *)pe)->dos_stub);
    }
}

void deallocate_pe_pe_header(t_pe *pe) {
    if(pe->s_type == PE32) {
        free(((t_pe32 *)pe)->pe_header);
    }
    else {
        free(((t_pe64 *)pe)->pe_header);
    }
}

void deallocate_pe_sections_headers(t_pe *pe) {
    if(pe->s_type == PE32) {
        free(((t_pe32 *)pe)->section_header);
    }
    else {
        free(((t_pe64 *)pe)->section_header);
    }
}

void deallocate_pe_sections_data(t_pe *pe) {
    if(pe->s_type == PE32) {
        free(((t_pe32 *)pe)->section_data);
    }
    else {
        free(((t_pe64 *)pe)->section_data);
    }
}

void deallocate_pe_sections_data_data(t_pe *pe) {
    if(pe->s_type == PE32) {
        for (int i = 0; i < ((t_pe32 *)pe)->pe_header->FileHeader.NumberOfSections; i++) {
            free(((t_pe32 *)pe)->section_data[i]);
        }
    }
    else {
        for (int i = 0; i < ((t_pe64 *)pe)->pe_header->FileHeader.NumberOfSections; i++) {
            free(((t_pe64 *)pe)->section_data[i]);
        }
    }
}

void deallocate_pe_struct(t_pe *pe) {
    free(pe);
}

void deallocate_pe(t_pe *pe) {
    deallocate_pe_dos_header(pe);
    deallocate_pe_dos_stub(pe);
    deallocate_pe_pe_header(pe);
    deallocate_pe_sections_headers(pe);
    deallocate_pe_sections_data(pe);
    deallocate_pe_sections_data_data(pe);
    deallocate_pe_struct(pe);
}

```

`src/PE/pe_encryption.c`:

```c
//
// Created by silentvoid on 3/19/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "pe_encryption.h"
#include "pe_struct.h"
#include "cipher_functions.h"
#include "file_functions.h"
#include "packer_config.h"
#include "pe_allocation.h"
#include "pe_functions.h"
#include "aes_128_ecb_encryption.h"

#include "log.h"

int encrypt_pe(t_pe *pe) {
    int text_section_index = find_pe_text_section(pe);
    if(text_section_index == -1) {
        log_error("Couldn't find .text section");
        return -1;
    }

    log_verbose("Got .text section index : %d", text_section_index);

    char *text_data;

    if(pe->s_type == PE32) {
        // Setting global variables
        text_entry_point32 = ((t_pe32 *)pe)->section_header[text_section_index].VirtualAddress;
        text_data_size32 = ((t_pe32 *)pe)->section_header[text_section_index].Misc.VirtualSize;

        text_data = ((t_pe32 *)pe)->section_data[text_section_index];

        if(packer_config.debug_mode) {
            log_debug("Dumping .text ...");
            dump_to_file("text32.dmp", text_data, text_data_size32);
        }

        log_verbose("Generating random key ...");
        cipher_key32 = generate_random_key32();
        uint64_t temp_key = cipher_key32;
        log_info("Random key : %d", cipher_key32);

        if(strcmp(packer_config.cipher, "xor") == 0) {
            xor_encrypt32(text_data, text_data_size32, temp_key);
        }
        else if(strcmp(packer_config.cipher, "aes128_ecb") == 0) {
            generate_random_key128();

            log_info("Random key : ");
            for(int i = 0; i < 16; i++)
                printf("%02x", cipher_key128[i]);
            puts("");

            aes_128_ecb_encrypt(text_data, text_data_size32, cipher_key128, 16);
        }

        if(packer_config.debug_mode) {
            log_debug("Dumping encrypted .text ...");
            dump_to_file("text32_encrypted.dmp", text_data, text_data_size32);
        }
    }
    else {
        // Setting global variables
        text_entry_point64 = ((t_pe64 *)pe)->section_header[text_section_index].VirtualAddress;
        text_data_size64 = ((t_pe64 *)pe)->section_header[text_section_index].Misc.VirtualSize;

        text_data = ((t_pe64 *)pe)->section_data[text_section_index];

        if(packer_config.debug_mode) {
            log_debug("Dumping .text ...");
            dump_to_file("text64.dmp", text_data, text_data_size64);
        }

        log_verbose("Generating random key ...");
        cipher_key64 = generate_random_key64();
        uint64_t temp_key = cipher_key64;
        log_info("Random key : %d", cipher_key64);

        if(strcmp(packer_config.cipher, "xor") == 0) {
            xor_encrypt64(text_data, text_data_size64, temp_key);
        }
        else if(strcmp(packer_config.cipher, "aes128_ecb") == 0) {
            generate_random_key128();

            log_info("Random key : ");
            for(int i = 0; i < 16; i++)
                printf("%02x", cipher_key128[i]);
            puts("");

            aes_128_ecb_encrypt(text_data, text_data_size64, cipher_key128, 16);
        }

        if(packer_config.debug_mode) {
            log_debug("Dumping encrypted .text ...");
            dump_to_file("text64_encrypted.dmp", text_data, text_data_size64);
        }
    }

    return 1;
}

```

`src/PE/pe_functions.c`:

```c
//
// Created by silentvoid on 3/16/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "pe_functions.h"
#include "pe_struct.h"
#include "pe_allocation.h"
#include "loader_functions.h"
#include "packer_config.h"
#include "all_pe_loaders_infos.h"

#include "log.h"

int set_new_pe_entry_to_addr(t_pe *pe, uint32_t entry_addr, int section_index, int section_size)  {
    if(pe->s_type == PE32) {
        uint32_t last_entry = ((t_pe32 *)pe)->pe_header->OptionalHeader.AddressOfEntryPoint;
        ((t_pe32 *)pe)->pe_header->OptionalHeader.AddressOfEntryPoint = entry_addr;
        int32_t jump = last_entry - (((t_pe32 *)pe)->pe_header->OptionalHeader.AddressOfEntryPoint + packer_config.loader_size - packer_config.loader_infos_size);

        memcpy(((t_pe32 *)pe)->section_data[section_index] + section_size + packer_config.loader_size - (packer_config.loader_infos_size + 4), &jump, 4);
    }
    else {
        uint32_t last_entry = ((t_pe64 *)pe)->pe_header->OptionalHeader.AddressOfEntryPoint;
        ((t_pe64 *)pe)->pe_header->OptionalHeader.AddressOfEntryPoint = entry_addr;
        int32_t jump = last_entry - (((t_pe64 *)pe)->pe_header->OptionalHeader.AddressOfEntryPoint + packer_config.loader_size - packer_config.loader_infos_size);

        memcpy(((t_pe64 *)pe)->section_data[section_index] + section_size + packer_config.loader_size - (packer_config.loader_infos_size + 4), &jump, 4);
    }

    return 1;
}

int set_new_pe_entry_to_section(t_pe *pe, int section_index) {
    if(pe->s_type == PE32) {
        uint32_t last_entry = ((t_pe32 *)pe)->pe_header->OptionalHeader.AddressOfEntryPoint;
        ((t_pe32 *)pe)->pe_header->OptionalHeader.AddressOfEntryPoint = ((t_pe32 *)pe)->section_header[section_index].VirtualAddress;
        int32_t jump = last_entry - (((t_pe32 *)pe)->pe_header->OptionalHeader.AddressOfEntryPoint + packer_config.loader_size - packer_config.loader_infos_size);

        memcpy(((t_pe32 *)pe)->section_data[section_index] + packer_config.loader_size - (packer_config.loader_infos_size + 4), &jump, 4);
    }
    else {
        uint32_t last_entry = ((t_pe64 *)pe)->pe_header->OptionalHeader.AddressOfEntryPoint;
        ((t_pe32 *)pe)->pe_header->OptionalHeader.AddressOfEntryPoint = ((t_pe64 *)pe)->section_header[section_index].VirtualAddress;
        int32_t jump = last_entry - (((t_pe64 *)pe)->pe_header->OptionalHeader.AddressOfEntryPoint + packer_config.loader_size - packer_config.loader_infos_size);

        memcpy(((t_pe64 *)pe)->section_data[section_index] + packer_config.loader_size - (packer_config.loader_infos_size + 4), &jump, 4);
    }

    return 1;
}

int find_pe_text_section(t_pe *pe) {
    int index = -1;
    if(pe->s_type == PE32) {
        for (int i = 0; i < ((t_pe32 *)pe)->pe_header->FileHeader.NumberOfSections; i++) {
            if (((t_pe32 *)pe)->section_header[i].Characteristics & IMAGE_SCN_MEM_EXECUTE) { // NOLINT(hicpp-signed-bitwise)
                index = i;
            }
        }
    }
    else {
        for (int i = 0; i < ((t_pe64 *)pe)->pe_header->FileHeader.NumberOfSections; i++) {
            if (((t_pe64 *)pe)->section_header[i].Characteristics & IMAGE_SCN_MEM_EXECUTE) { // NOLINT(hicpp-signed-bitwise)
                index = i;
            }
        }
    }
    return index;
}

void add_pe_section_permission(t_pe *pe, int segment_index, int permission) {
    if(pe->s_type == PE32) {
        ((t_pe32 *)pe)->section_header[segment_index].Characteristics |= permission; // NOLINT(hicpp-signed-bitwise)
    }
    else {
        ((t_pe64 *)pe)->section_header[segment_index].Characteristics |= permission; // NOLINT(hicpp-signed-bitwise)
    }
}

void print_pe_section_info(t_pe *pe, int section_index) {
    puts("");

    if(pe->s_type == PE32) {
        printf("Section name : %s\n", ((t_pe32 *)pe)->section_header[section_index].Name);
        printf("VirtualSize : %d\n", ((t_pe32 *)pe)->section_header[section_index].Misc.VirtualSize);
        printf("SizeofRawData : %d\n", ((t_pe32 *)pe)->section_header[section_index].SizeOfRawData);
        printf("PointerToRawData : %x\n", ((t_pe32 *)pe)->section_header[section_index].PointerToRawData);
        printf("VirtualAddress : %x\n", ((t_pe32 *)pe)->section_header[section_index].VirtualAddress);
    }
    else {
        printf("Section name : %s\n", ((t_pe64 *)pe)->section_header[section_index].Name);
        printf("VirtualSize : %d\n", ((t_pe64 *)pe)->section_header[section_index].Misc.VirtualSize);
        printf("SizeofRawData : %d\n", ((t_pe64 *)pe)->section_header[section_index].SizeOfRawData);
        printf("PointerToRawData : %x\n", ((t_pe64 *)pe)->section_header[section_index].PointerToRawData);
        printf("VirtualAddress : %x\n", ((t_pe64 *)pe)->section_header[section_index].VirtualAddress);
    }
}

```

`src/PE/pe_packing.c`:

```c
//
// Created by silentvoid on 3/16/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "pe_packing.h"
#include "pe_allocation.h"
#include "pe_deallocation.h"
#include "file_functions.h"
#include "packer_config.h"
#include "pe_writing.h"
#include "pe_packing_method.h"
#include "pe_encryption.h"

#include "log.h"

int pack_pe(char *file, char *file_data, size_t file_data_size, char *output) {
    log_verbose("Detected arch : x%d", packer_config.arch);
    log_info("Allocating PE in memory ...");

    t_pe *pe = NULL;
    if (allocate_pe(&pe, file_data, file_data_size, packer_config.arch) == -1) {
        munmap(file_data, file_data_size);
        log_error("Error during PE allocation");
        return -1;
    }

    // De-allocate mapped file as we don't need it anymore
    munmap(file_data, file_data_size);

    log_info("Encrypting .text section ...");
    if(encrypt_pe(pe) == -1) {
        deallocate_pe(pe);
        log_error("Error during PE encryption");
        return -1;
    }

    log_info("Packing using specified method ...");
    if(pe_pack_using_method(pe) == -1) {
        deallocate_pe(pe);
        log_error("Error during PE packing");
        return -1;
    }

    char *filename;
    if(output != NULL)
        filename = output;
    else
        filename = "packed.exe";

    log_info("Writing Packed PE to file ...");
    if(write_pe(pe, filename) == -1) {
        deallocate_pe(pe);
        log_error("Error during new PE writing");
        return -1;
    }

    log_success("File %s packed into %s !", file, filename);
    deallocate_pe(pe);

    return 1;
}


```

`src/PE/pe_packing_method.c`:

```c
//
// Created by silentvoid on 2/28/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "pe_packing_method.h"
#include "pe_allocation.h"
#include "packer_config.h"
#include "pe_code_cave.h"
#include "pe_section_insertion.h"

#include "log.h"

int pe_pack_using_method(t_pe *pe) {
    if(strcmp(packer_config.packing_method, "section_insertion") == 0) {
        method_config.method_type = SECTION_INSERTION_METHOD;
        if (pe_insert_section(pe) == -1) {
            log_error("Error during Section insertion");
            return -1;
        }
    }
    else if(strcmp(packer_config.packing_method, "code_cave") == 0) {
        method_config.method_type = CODE_CAVE_METHOD;
        if(pe_code_cave_injection(pe) == -1) {
            log_error("Error during Code Cave Injection");
            return -1;
        }
    }

    return 1;
}

```

`src/PE/pe_section_insertion.c`:

```c
#pragma clang diagnostic push
#pragma ide diagnostic ignored "hicpp-signed-bitwise"
//
// Created by silentvoid on 3/26/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "pe_section_insertion.h"
#include "pe_struct.h"
#include "pe_allocation.h"
#include "pe_functions.h"
#include "loader_functions.h"
#include "file_functions.h"
#include "packer_config.h"
#include "all_pe_loaders_infos.h"

#include "log.h"

void print_new_section_header_info(IMAGE_SECTION_HEADER *section_header) {
    printf("VirtualAddress : %d\n", section_header->VirtualAddress);
    printf("VirtualSize : %d\n", section_header->Misc.VirtualSize);
    printf("SizeOfRawData : %d\n", section_header->SizeOfRawData);
}

int add_new_pe_section_header(t_pe *pe) {
    int sections_count;
    if(pe->s_type == PE32) {
        sections_count = ((t_pe32 *)pe)->pe_header->FileHeader.NumberOfSections;
        size_t new_section_header_size = sections_count * sizeof(IMAGE_SECTION_HEADER) + sizeof(IMAGE_SECTION_HEADER);
        IMAGE_SECTION_HEADER *new_section_header = realloc(((t_pe32 *)pe)->section_header, new_section_header_size);
        if (new_section_header == NULL) {
            log_error("realloc() failure\n");
            return -1;
        }
        ((t_pe32 *)pe)->section_header = new_section_header;
    }
    else {
        sections_count = ((t_pe64 *)pe)->pe_header->FileHeader.NumberOfSections;
        size_t new_section_header_size = sections_count * sizeof(IMAGE_SECTION_HEADER) + sizeof(IMAGE_SECTION_HEADER);
        IMAGE_SECTION_HEADER *new_section_header = realloc(((t_pe64 *)pe)->section_header, new_section_header_size);
        if (new_section_header == NULL) {
            log_error("realloc() failure\n");
            return -1;
        }
        ((t_pe64 *)pe)->section_header = new_section_header;
    }

    IMAGE_SECTION_HEADER new_header;
    memset(&new_header, 0, sizeof(IMAGE_SECTION_HEADER));

    char *section_name = ".dec";
    memset(new_header.Name, 0, sizeof(new_header.Name));
    memcpy(new_header.Name, section_name, strlen(section_name));

    if(pe->s_type == PE32) {
        new_header.VirtualAddress = ((t_pe32 *)pe)->pe_header->OptionalHeader.SizeOfImage;
        new_header.PointerToRawData =   ((t_pe32 *)pe)->section_header[sections_count - 1].PointerToRawData +
                                        ((t_pe32 *)pe)->section_header[sections_count - 1].SizeOfRawData;

        new_header.Misc.VirtualSize = packer_config.loader_size;
        // TO SEE
        size_t raw_data_size = 0;
        while(raw_data_size < packer_config.loader_size) {
            raw_data_size += ((t_pe32 *)pe)->pe_header->OptionalHeader.FileAlignment;
        }
        new_header.SizeOfRawData = raw_data_size;

        new_header.Characteristics = IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE | IMAGE_SCN_CNT_CODE; // NOLINT(hicpp-signed-bitwise)

        //print_new_section_header_info(&new_header);

        memcpy(&(((t_pe32 *)pe)->section_header[sections_count]), &new_header, sizeof(IMAGE_SECTION_HEADER));
    }
    else {
        new_header.VirtualAddress = ((t_pe64 *)pe)->pe_header->OptionalHeader.SizeOfImage;
        new_header.PointerToRawData =   ((t_pe64 *)pe)->section_header[sections_count - 1].PointerToRawData +
                                        ((t_pe64 *)pe)->section_header[sections_count - 1].SizeOfRawData;

        new_header.Misc.VirtualSize = packer_config.loader_size;

        // TO SEE
        size_t raw_data_size = 0;
        while(raw_data_size < packer_config.loader_size) {
            raw_data_size += ((t_pe64 *)pe)->pe_header->OptionalHeader.FileAlignment;
        }
        new_header.SizeOfRawData = raw_data_size;

        new_header.Characteristics = IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE | IMAGE_SCN_CNT_CODE; // NOLINT(hicpp-signed-bitwise)

        //print_new_section_header_info(&new_header);

        memcpy(&(((t_pe64 *)pe)->section_header[sections_count]), &new_header, sizeof(IMAGE_SECTION_HEADER));
    }

    return 1;
}

int set_new_pe_header_values(t_pe *pe) {
    if(pe->s_type == PE32) {
        int old_sections_count = ((t_pe32 *)pe)->pe_header->FileHeader.NumberOfSections;
        ((t_pe32 *)pe)->pe_header->FileHeader.NumberOfSections += 1;

        ((t_pe32 *)pe)->pe_header->OptionalHeader.SizeOfCode += ((t_pe32 *)pe)->section_header[old_sections_count - 1].SizeOfRawData;
        ((t_pe32 *)pe)->pe_header->OptionalHeader.SizeOfHeaders += sizeof(IMAGE_SECTION_HEADER);
        ((t_pe32 *)pe)->pe_header->OptionalHeader.SizeOfImage += packer_config.loader_size;
    }
    else {
        int old_sections_count = ((t_pe64 *)pe)->pe_header->FileHeader.NumberOfSections;
        ((t_pe64 *)pe)->pe_header->FileHeader.NumberOfSections += 1;

        ((t_pe64 *)pe)->pe_header->OptionalHeader.SizeOfCode += ((t_pe64 *)pe)->section_header[old_sections_count - 1].SizeOfRawData;
        ((t_pe64 *)pe)->pe_header->OptionalHeader.SizeOfHeaders += sizeof(IMAGE_SECTION_HEADER);
        ((t_pe64 *)pe)->pe_header->OptionalHeader.SizeOfImage += packer_config.loader_size;
    }

    return 1;
}

int add_new_pe_section_data(t_pe *pe) {
    char *loader;

    if(pe->s_type == PE32) {
        int sections_count = ((t_pe32 *)pe)->pe_header->FileHeader.NumberOfSections;
        char **new_section_data = realloc(((t_pe32 *)pe)->section_data, sizeof(char *) * sections_count);
        if (new_section_data == NULL) {
            log_error("realloc() failure");
            return -1;
        }
        ((t_pe32 *)pe)->section_data = new_section_data;

        // For ASM
        loader_offset32 = ((t_pe32 *)pe)->section_header[sections_count - 1].VirtualAddress;

        loader = patch_loader();
        if (loader == NULL) {
            free(loader);
            log_error("Error during loader patching");
            return -1;
        }
        char *new_section = malloc(((t_pe32 *)pe)->section_header[sections_count - 1].SizeOfRawData);
        if(new_section == NULL) {
            free(loader);
            free(new_section);
            log_error("malloc() failure");
            return -1;
        }
        memset(new_section, 0, ((t_pe32 *)pe)->section_header[sections_count - 1].SizeOfRawData);
        memcpy(new_section, loader, packer_config.loader_size);
        ((t_pe32 *)pe)->section_data[sections_count - 1] = new_section;
    }
    else {
        int sections_count = ((t_pe64 *)pe)->pe_header->FileHeader.NumberOfSections;
        char **new_section_data = realloc(((t_pe64 *)pe)->section_data, sizeof(char *) * sections_count);
        if (new_section_data == NULL) {
            log_error("realloc() failure");
            return -1;
        }
        ((t_pe64 *)pe)->section_data = new_section_data;

        // For ASM
        loader_offset64 = ((t_pe64 *)pe)->section_header[sections_count - 1].VirtualAddress;

        loader = patch_loader();
        if (loader == NULL) {
            free(loader);
            log_error("Error during loader patching");
            return -1;
        }
        char *new_section = malloc(((t_pe64 *)pe)->section_header[sections_count - 1].SizeOfRawData);
        if(new_section == NULL) {
            free(loader);
            free(new_section);
            log_error("malloc() failure");
            return -1;
        }
        memset(new_section, 0, ((t_pe64 *)pe)->section_header[sections_count - 1].SizeOfRawData);
        memcpy(new_section, loader, packer_config.loader_size);
        ((t_pe64 *)pe)->section_data[sections_count - 1] = new_section;
    }
    free(loader);

    return 1;
}

int pe_insert_section(t_pe *pe) {
    int text_section_index = find_pe_text_section(pe);
    if(text_section_index == -1) {
        log_error("Couldn't find .text section");
        return -1;
    }
    add_pe_section_permission(pe, text_section_index, IMAGE_SCN_MEM_WRITE);

    log_verbose("Creating new section ...");

    if(add_new_pe_section_header(pe) == -1) {
        log_error("Error during new Section Header insertion");
        return -1;
    }

    log_verbose("Setting new sections headers values ...");

    if(set_new_pe_header_values(pe) == -1) {
        log_error("Couldn't set new PE Header values");
        return -1;
    }

    log_verbose("Inserting the section data ...");

    if(add_new_pe_section_data(pe) == -1) {
        log_error("Error during new Section Data insertion");
        return -1;
    }

    log_verbose("Setting new PE entry point ...");

    if(pe->s_type == PE32)
        set_new_pe_entry_to_section(pe, ((t_pe32 *)pe)->pe_header->FileHeader.NumberOfSections-1);
    else
        set_new_pe_entry_to_section(pe, ((t_pe64 *)pe)->pe_header->FileHeader.NumberOfSections-1);

    return 1;
}
#pragma clang diagnostic pop
```

`src/PE/pe_writing.c`:

```c
//
// Created by silentvoid on 3/16/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "pe_writing.h"
#include "pe_allocation.h"
#include "file_functions.h"

#include "log.h"

int write_pe(t_pe *pe, char *filename) {
    int fd = open(filename, O_CREAT | O_WRONLY | O_TRUNC, 0755); // NOLINT(hicpp-signed-bitwise)
    if(fd < 0) {
        log_error("open() failure");
        return -1;
    }

    if(pe->s_type == PE32) {
        log_verbose("Writing DOS header ...");
        write_to_file(fd, ((t_pe32 *)pe)->dos_header, sizeof(IMAGE_DOS_HEADER));

        log_verbose("Writing DOS Stub ...");
        write_to_file(fd, ((t_pe32 *)pe)->dos_stub, ((t_pe32 *)pe)->dos_header->e_lfanew - sizeof(IMAGE_DOS_HEADER));

        log_verbose("Writing PE header ...");
        write_to_file(fd, ((t_pe32 *)pe)->pe_header, sizeof(IMAGE_NT_HEADERS32));

        log_verbose("Writing Sections headers ...");
        for (int i = 0; i < ((t_pe32 *)pe)->pe_header->FileHeader.NumberOfSections; i++) {
            write_to_file(fd, &(((t_pe32 *)pe)->section_header[i]), sizeof(IMAGE_SECTION_HEADER));
        }
        add_zero_padding(fd, ((t_pe32 *)pe)->section_header[0].PointerToRawData);

        log_verbose("Writing Sections data ...");
        for (int i = 0; i < ((t_pe32 *)pe)->pe_header->FileHeader.NumberOfSections; i++) {
            write_to_file(fd, ((t_pe32 *)pe)->section_data[i], ((t_pe32 *)pe)->section_header[i].SizeOfRawData);
        }
    }
    else {
        log_verbose("Writing DOS header ...");
        write_to_file(fd, ((t_pe64 *)pe)->dos_header, sizeof(IMAGE_DOS_HEADER));

        log_verbose("Writing DOS Stub ...");
        write_to_file(fd, ((t_pe64 *)pe)->dos_stub, ((t_pe64 *)pe)->dos_header->e_lfanew - sizeof(IMAGE_DOS_HEADER));

        log_verbose("Writing PE header ...");
        write_to_file(fd, ((t_pe64 *)pe)->pe_header, sizeof(IMAGE_NT_HEADERS64));

        log_verbose("Writing Sections headers ...");
        for (int i = 0; i < ((t_pe64 *)pe)->pe_header->FileHeader.NumberOfSections; i++) {
            write_to_file(fd, &(((t_pe64 *)pe)->section_header[i]), sizeof(IMAGE_SECTION_HEADER));
        }
        add_zero_padding(fd, ((t_pe64 *)pe)->section_header[0].PointerToRawData);

        log_verbose("Writing Sections data ...");
        for (int i = 0; i < ((t_pe64 *)pe)->pe_header->FileHeader.NumberOfSections; i++) {
            write_to_file(fd, ((t_pe64 *)pe)->section_data[i], ((t_pe64 *)pe)->section_header[i].SizeOfRawData);
        }
    }

    close(fd);

    return 1;
}

```

`src/STUB/amd64_aes_128_ecb_linux_elf_loader.asm`:

```asm
%macro pushx 1-*
 %rep %0
   push %1
   %rotate 1
 %endrep
%endmacro

%macro popx 1-*
  %rep %0
    %rotate -1
    pop %1
  %endrep
%endmacro

%macro aes_128_keygenassist 1-2
    aeskeygenassist xmm2, xmm1, %1
    call key_expansion_128
    movdqu %2, xmm1
%endmacro

[BITS 64]

aes_128_ecb_decrypt:
	pushfq
	pushx rax, rdi, rsi, rsp, rdx, rcx

    ; sys_write
    mov rax, 1
	mov	rdi, rax
	lea	rsi, [rel msg]
	mov	rdx, msg_len
	syscall

    ; We save pie offset
    lea r12, [rel aes_128_ecb_decrypt]
    sub r12, [rel info_offset]

    jmp start_unpacking

key_expansion_128:
    pshufd xmm2, xmm2, 0xff
    vpslldq xmm3, xmm1, 0x4
    pxor xmm1, xmm3
    vpslldq xmm3, xmm1, 0x4
    pxor xmm1, xmm3
    vpslldq xmm3, xmm1, 0x4
    pxor xmm1, xmm3
    pxor xmm1, xmm2
    ret

msg	db	"[Unpacking...]", 10, 0
msg_len	equ	$ - msg

start_unpacking:
    movdqu xmm1, [rel info_key]

    ; Load .text address in rax
    mov rax, [rel info_addr]
    add rax, r12

    ; For later
    mov rdx, [rel info_size]

    ; Move the key in xmm0 to backup
    movdqu xmm0, xmm1

    ; Generating round keys

    ; 10 times
    aes_128_keygenassist 0x1, xmm4
    aes_128_keygenassist 0x2, xmm5
    aes_128_keygenassist 0x4, xmm6
    aes_128_keygenassist 0x8, xmm7
    aes_128_keygenassist 0x10, xmm8
    aes_128_keygenassist 0x20, xmm9
    aes_128_keygenassist 0x40, xmm10
    aes_128_keygenassist 0x80, xmm11
    aes_128_keygenassist 0x1b, xmm12
    aes_128_keygenassist 0x36, xmm13

    ;  Getting ready to use with the Equivalent Inverse Cipher
    ; 9 times - Not on the last one
    aesimc xmm4, xmm4
    aesimc xmm5, xmm5
    aesimc xmm6, xmm6
    aesimc xmm7, xmm7
    aesimc xmm8, xmm8
    aesimc xmm9, xmm9
    aesimc xmm10, xmm10
    aesimc xmm11, xmm11
    aesimc xmm12, xmm12

	xor r8, r8

; Because we can't fully encrypt the .text data when it's not a 16bytes multiple - TOFIX
    sub rdx, 16
aes_loop:
    ; Load .text encrypted section block in xmm15
    movdqu xmm15, [rax + r8]

    pxor xmm15, xmm13 ; First xor
    aesdec xmm15, xmm12 ; Round 1
    aesdec xmm15, xmm11 ; Round 2
    aesdec xmm15, xmm10 ; Round 3
    aesdec xmm15, xmm9 ; Round 4
    aesdec xmm15, xmm8 ; Round 5
    aesdec xmm15, xmm7 ; Round 6
    aesdec xmm15, xmm6 ; Round 7
    aesdec xmm15, xmm5 ; Round 8
    aesdec xmm15, xmm4 ; Round 9
    aesdeclast xmm15, xmm0 ; Round 10

    ; Load the encrypted .text section block
    movdqu [rax + r8], xmm15

    add r8, 16
    cmp rdx, r8
    jle clean
    jmp aes_loop

clean:
    popx rax, rdi, rsi, rsp, rdx, rcx
    popfq
    jmp	0xFFFFFFFF

; random values here, to be patched
info_start:
info_key:	    dq	0xaaaaaaaaaaaaaaaa
info_key1:      dq  0xbbbbbbbbbbbbbbbb
info_addr:	    dq	0xcccccccccccccccc
info_size:	    dq  0xdddddddddddddddd
info_offset:    dq  0xeeeeeeeeeeeeeeee


```

`src/STUB/amd64_aes_128_ecb_win_pe_loader.asm`:

```asm
%macro pushx 1-*
 %rep %0
   push %1
   %rotate 1
 %endrep
%endmacro

%macro popx 1-*
  %rep %0
    %rotate -1
    pop %1
  %endrep
%endmacro

%macro aes_128_keygenassist 1-2
    aeskeygenassist xmm2, xmm1, %1
    call key_expansion_128
    movdqu %2, xmm1
%endmacro

[BITS 64]

aes_128_ecb_decrypt:
	pushfq
	pushx rax, rdi, rsi, rsp, rdx, rcx

    ; syscall on windows seems like a pain
    ;mov rax, 1
	;mov	rdi, rax
	;lea	rsi, [rel msg]
	;mov	rdx, msg_len
	;syscall

    ; We save pie offset
    lea r12, [rel aes_128_ecb_decrypt]
    sub r12, [rel info_offset]

    jmp start_unpacking

key_expansion_128:
    pshufd xmm2, xmm2, 0xff
    vpslldq xmm3, xmm1, 0x4
    pxor xmm1, xmm3
    vpslldq xmm3, xmm1, 0x4
    pxor xmm1, xmm3
    vpslldq xmm3, xmm1, 0x4
    pxor xmm1, xmm3
    pxor xmm1, xmm2
    ret

msg	db	"[Unpacking...]", 10, 0
msg_len	equ	$ - msg

start_unpacking:
    movdqu xmm1, [rel info_key]

    ; Load .text address in rax
    mov rax, [rel info_addr]
    add rax, r12

    ; For later
    mov rdx, [rel info_size]

    ; Move the key in xmm0 to backup
    movdqu xmm0, xmm1

    ; Generating round keys

    ; 10 times
    aes_128_keygenassist 0x1, xmm4
    aes_128_keygenassist 0x2, xmm5
    aes_128_keygenassist 0x4, xmm6
    aes_128_keygenassist 0x8, xmm7
    aes_128_keygenassist 0x10, xmm8
    aes_128_keygenassist 0x20, xmm9
    aes_128_keygenassist 0x40, xmm10
    aes_128_keygenassist 0x80, xmm11
    aes_128_keygenassist 0x1b, xmm12
    aes_128_keygenassist 0x36, xmm13

    ;  Getting ready to use with the Equivalent Inverse Cipher
    ; 9 times - Not on the last one
    aesimc xmm4, xmm4
    aesimc xmm5, xmm5
    aesimc xmm6, xmm6
    aesimc xmm7, xmm7
    aesimc xmm8, xmm8
    aesimc xmm9, xmm9
    aesimc xmm10, xmm10
    aesimc xmm11, xmm11
    aesimc xmm12, xmm12

	xor r8, r8

; Because we can't fully encrypt the .text data when it's not a 16bytes multiple - TOFIX
    sub rdx, 16
aes_loop:
    ; Load .text encrypted section block in xmm15
    movdqu xmm15, [rax + r8]

    pxor xmm15, xmm13 ; First xor
    aesdec xmm15, xmm12 ; Round 1
    aesdec xmm15, xmm11 ; Round 2
    aesdec xmm15, xmm10 ; Round 3
    aesdec xmm15, xmm9 ; Round 4
    aesdec xmm15, xmm8 ; Round 5
    aesdec xmm15, xmm7 ; Round 6
    aesdec xmm15, xmm6 ; Round 7
    aesdec xmm15, xmm5 ; Round 8
    aesdec xmm15, xmm4 ; Round 9
    aesdeclast xmm15, xmm0 ; Round 10

    ; Load the encrypted .text section block
    movdqu [rax + r8], xmm15

    add r8, 16
    cmp rdx, r8
    jle clean
    jmp aes_loop

clean:
    popx rax, rdi, rsi, rsp, rdx, rcx
    popfq
    jmp	0xFFFFFFFF

; random values here, to be patched
info_start:
info_key:	    dq	0xaaaaaaaaaaaaaaaa
info_key1:      dq  0xbbbbbbbbbbbbbbbb
info_addr:	    dq	0xcccccccccccccccc
info_size:	    dq  0xdddddddddddddddd
info_offset:    dq  0xeeeeeeeeeeeeeeee


```

`src/STUB/amd64_xor_linux_elf_loader.asm`:

```asm
%macro pushx 1-*
 %rep %0
   push %1
   %rotate 1
 %endrep
%endmacro

%macro popx 1-*
  %rep %0
    %rotate -1
    pop %1
  %endrep
%endmacro

section .text

loader_entry_point:
	pushfq
	pushx rax, rdi, rsi, rsp, rdx, rcx

    ; syscall : rax
    ; parameter order : rdi, rsi, rdx, r10, r8, r9
    ; sys_write
    mov rax, 1
	mov	rdi, rax
	lea	rsi, [rel msg]
	mov	rdx, msg_len
	syscall

    ; We save pie offset
    lea r12, [rel loader_entry_point]
    sub r12, [rel info_offset]

	jmp	start_unpacking

msg	db	"[Unpacking...]", 10, 0
msg_len	equ	$ - msg

start_unpacking:
	mov	rax, [rel info_addr]
	mov	rcx, [rel info_size]
	mov	rdx, [rel info_key]

    ; We add PIE offset
	add rax, r12
	add	rcx, rax

.loop:
	xor	byte [rax], dl
	ror	rdx, 8
	inc	rax
	cmp	rax, rcx
	jnz	.loop

	popx rax, rdi, rsi, rsp, rdx, rcx
	popfq
	jmp	0xFFFFFFFF

; random values here, to be patched
info_start:
info_key:	    dq	0xaaaaaaaaaaaaaaaa
info_addr:	    dq	0xbbbbbbbbbbbbbbbb
info_size:	    dq  0xcccccccccccccccc
info_offset:    dq  0xdddddddddddddddd

```

`src/STUB/amd64_xor_win_pe_loader.asm`:

```asm
%macro pushx 1-*
 %rep %0
   push %1
   %rotate 1
 %endrep
%endmacro

%macro popx 1-*
  %rep %0
    %rotate -1
    pop %1
  %endrep
%endmacro

section .text

loader_entry_point:
	pushfq
	pushx rax, rdi, rsi, rsp, rdx, rcx

    ; syscall on windows seems like a pain
    ;mov rax, 1
	;mov	rdi, rax
	;lea	rsi, [rel msg]
	;mov	rdx, msg_len
	;syscall

    ; We save pie offset
    lea r12, [rel loader_entry_point]
    sub r12, [rel info_offset]

	jmp	start_unpacking

msg	db	"[Unpacking...]", 10, 0
msg_len	equ	$ - msg

start_unpacking:
	mov	rax, [rel info_addr]
	mov	rcx, [rel info_size]
	mov	rdx, [rel info_key]

    ; We add PIE offset
	add rax, r12
	add	rcx, rax

.loop:
	xor	byte [rax], dl
	ror	rdx, 8
	inc	rax
	cmp	rax, rcx
	jnz	.loop

	popx rax, rdi, rsi, rsp, rdx, rcx
	popfq
	jmp	0xFFFFFFFF

; random values here, to be patched
info_start:
info_key:	    dq	0xaaaaaaaaaaaaaaaa
info_addr:	    dq	0xbbbbbbbbbbbbbbbb
info_size:	    dq  0xcccccccccccccccc
info_offset:    dq  0xdddddddddddddddd

```

`src/STUB/i386_aes_128_ecb_linux_elf_loader.asm`:

```asm
%macro pushx 1-*
 %rep %0
   push %1
   %rotate 1
 %endrep
%endmacro

%macro popx 1-*
  %rep %0
    %rotate -1
    pop %1
  %endrep
%endmacro

%macro aes_128_keygenassist 1-2
    aeskeygenassist xmm2, xmm1, %1
    call key_expansion_128
    movdqu %2, xmm1
%endmacro

[BITS 32]

aes_128_ecb_decrypt:
	pushx eax, edi, esi, esp, edx, ecx, ebx

	; sys_write
    call get_my_loc
    sub edx, next_i - msg
    mov ecx, edx
    mov edx, msg_len
    mov ebx, 1
    mov eax, 4
    int 0x80

    ; We save pie offset
    call get_my_loc
    sub edx, next_i - aes_128_ecb_decrypt
    mov ebx, edx
    call get_my_loc
    sub edx, next_i - info_offset
    sub ebx, [edx]

    jmp start_unpacking

; Uses xmm1, xmm2 and xmm3
key_expansion_128:
    pshufd xmm2, xmm2, 0xff
    vpslldq xmm3, xmm1, 0x4
    pxor xmm1, xmm3
    vpslldq xmm3, xmm1, 0x4
    pxor xmm1, xmm3
    vpslldq xmm3, xmm1, 0x4
    pxor xmm1, xmm3
    pxor xmm1, xmm2
    ret

get_my_loc:
    call next_i

next_i:
    pop edx
    ret

msg	db	"[Unpacking...]", 10, 0
msg_len	equ	$ - msg

start_unpacking:
    call get_my_loc
    sub edx, next_i - info_addr
	mov	eax, [edx]
	; We add PIE offset
    add eax, ebx
    call get_my_loc
	sub edx, next_i - info_key
    movdqu xmm1, [edx]
    call get_my_loc
	sub edx, next_i - info_size
	mov	edx, [edx]

    ; Move the key in xmm0 to backup
    movdqu xmm0, xmm1

    ; We don't have enough xmm registers in x86 to store every round keys, so we push them to the stack

    ; Generating round keys

    ; 10 times
    aes_128_keygenassist 0x1, xmm4
    aesimc xmm4, xmm4
    sub esp, 16
    movdqu oword [esp], xmm4
    aes_128_keygenassist 0x2, xmm4
    aesimc xmm4, xmm4
    sub esp, 16
    movdqu oword [esp], xmm4
    aes_128_keygenassist 0x4, xmm4
    aesimc xmm4, xmm4
    sub esp, 16
    movdqu oword [esp], xmm4
    aes_128_keygenassist 0x8, xmm4
    aesimc xmm4, xmm4
    sub esp, 16
    movdqu oword [esp], xmm4
    aes_128_keygenassist 0x10, xmm4
    aesimc xmm4, xmm4
    sub esp, 16
    movdqu oword [esp], xmm4
    aes_128_keygenassist 0x20, xmm4
    aesimc xmm4, xmm4
    sub esp, 16
    movdqu oword [esp], xmm4
    aes_128_keygenassist 0x40, xmm4
    aesimc xmm4, xmm4
    sub esp, 16
    movdqu oword [esp], xmm4
    aes_128_keygenassist 0x80, xmm4
    aesimc xmm4, xmm4
    sub esp, 16
    movdqu oword [esp], xmm4
    aes_128_keygenassist 0x1b, xmm4
    aesimc xmm4, xmm4
    sub esp, 16
    movdqu oword [esp], xmm4
    aes_128_keygenassist 0x36, xmm4
    sub esp, 16
    movdqu oword [esp], xmm4

	xor ecx, ecx

; Because we can't fully encrypt the .text data when it's not a 16bytes multiple - TOFIX
    sub edx, 16
aes_loop:
    movdqu xmm1, xmm0

    ; Load .text encrypted section block in xmm15
    movdqu xmm7, [eax + ecx]

    movdqu  xmm4, oword [esp]
    add     esp, 16
    pxor xmm7, xmm4 ; First xor
    movdqu  xmm4, oword [esp]
    add     esp, 16
    aesdec xmm7, xmm4 ; Round 1
    movdqu  xmm4, oword [esp]
    add     esp, 16
    aesdec xmm7, xmm4 ; Round 2
    movdqu  xmm4, oword [esp]
    add     esp, 16
    aesdec xmm7, xmm4 ; Round 3
    movdqu  xmm4, oword [esp]
    add     esp, 16
    aesdec xmm7, xmm4 ; Round 4
    movdqu  xmm4, oword [esp]
    add     esp, 16
    aesdec xmm7, xmm4 ; Round 5
    movdqu  xmm4, oword [esp]
    add     esp, 16
    aesdec xmm7, xmm4 ; Round 6
    movdqu  xmm4, oword [esp]
    add     esp, 16
    aesdec xmm7, xmm4 ; Round 7
    movdqu  xmm4, oword [esp]
    add     esp, 16
    aesdec xmm7, xmm4 ; Round 8
    movdqu  xmm4, oword [esp]
    add     esp, 16
    aesdec xmm7, xmm4 ; Round 9
    aesdeclast xmm7, xmm0 ; Round 10

    ; Load the encrypted .text section block
    movdqu [eax + ecx], xmm7

    ; Restore the stack for another loop
    sub esp, 160

    add ecx, 16
    cmp edx, ecx
    jle clean
    jmp aes_loop

clean:
    ; Reset the stack
    add esp, 160
	popx eax, edi, esi, esp, edx, ecx, ebx
    jmp	0xFFFFFFFF

; random values here, to be patched
info_start:
info_key:	    dd	0xaaaaaaaa
info_key1:	    dd	0xaaaaaaaa
info_key2:	    dd	0xaaaaaaaa
info_key3:	    dd	0xaaaaaaaa
info_addr:	    dd	0xcccccccc
info_size:	    dd  0xdddddddd
info_offset:    dd  0xeeeeeeee


```

`src/STUB/i386_aes_128_ecb_win_pe_loader.asm`:

```asm
%macro pushx 1-*
 %rep %0
   push %1
   %rotate 1
 %endrep
%endmacro

%macro popx 1-*
  %rep %0
    %rotate -1
    pop %1
  %endrep
%endmacro

%macro aes_128_keygenassist 1-2
    aeskeygenassist xmm2, xmm1, %1
    call key_expansion_128
    movdqu %2, xmm1
%endmacro

[BITS 32]

aes_128_ecb_decrypt:
	pushx eax, edi, esi, esp, edx, ecx, ebx

    ; syscall on windows seems like a pain
    ;call get_my_loc
    ;sub edx, next_i - msg
	;mov ecx, edx
	;mov edx, msg_len
	;mov ebx, 1
    ;mov eax, 4
    ;int 0x80

    ; We save pie offset
    call get_my_loc
    sub edx, next_i - aes_128_ecb_decrypt
    mov ebx, edx
    call get_my_loc
    sub edx, next_i - info_offset
    sub ebx, [edx]

    jmp start_unpacking

; Uses xmm1, xmm2 and xmm3
key_expansion_128:
    pshufd xmm2, xmm2, 0xff
    vpslldq xmm3, xmm1, 0x4
    pxor xmm1, xmm3
    vpslldq xmm3, xmm1, 0x4
    pxor xmm1, xmm3
    vpslldq xmm3, xmm1, 0x4
    pxor xmm1, xmm3
    pxor xmm1, xmm2
    ret

get_my_loc:
    call next_i

next_i:
    pop edx
    ret

msg	db	"[Unpacking...]", 10, 0
msg_len	equ	$ - msg

start_unpacking:
    call get_my_loc
    sub edx, next_i - info_addr
	mov	eax, [edx]
	; We add PIE offset
    add eax, ebx
    call get_my_loc
	sub edx, next_i - info_key
    movdqu xmm1, [edx]
    call get_my_loc
	sub edx, next_i - info_size
	mov	edx, [edx]

    ; Move the key in xmm0 to backup
    movdqu xmm0, xmm1

    ; We don't have enough xmm registers in x86 to store every round keys, so we push them to the stack

    ; Generating round keys

    ; 10 times
    aes_128_keygenassist 0x1, xmm4
    aesimc xmm4, xmm4
    sub esp, 16
    movdqu oword [esp], xmm4
    aes_128_keygenassist 0x2, xmm4
    aesimc xmm4, xmm4
    sub esp, 16
    movdqu oword [esp], xmm4
    aes_128_keygenassist 0x4, xmm4
    aesimc xmm4, xmm4
    sub esp, 16
    movdqu oword [esp], xmm4
    aes_128_keygenassist 0x8, xmm4
    aesimc xmm4, xmm4
    sub esp, 16
    movdqu oword [esp], xmm4
    aes_128_keygenassist 0x10, xmm4
    aesimc xmm4, xmm4
    sub esp, 16
    movdqu oword [esp], xmm4
    aes_128_keygenassist 0x20, xmm4
    aesimc xmm4, xmm4
    sub esp, 16
    movdqu oword [esp], xmm4
    aes_128_keygenassist 0x40, xmm4
    aesimc xmm4, xmm4
    sub esp, 16
    movdqu oword [esp], xmm4
    aes_128_keygenassist 0x80, xmm4
    aesimc xmm4, xmm4
    sub esp, 16
    movdqu oword [esp], xmm4
    aes_128_keygenassist 0x1b, xmm4
    aesimc xmm4, xmm4
    sub esp, 16
    movdqu oword [esp], xmm4
    aes_128_keygenassist 0x36, xmm4
    sub esp, 16
    movdqu oword [esp], xmm4

	xor ecx, ecx

; Because we can't fully encrypt the .text data when it's not a 16bytes multiple - TOFIX
    sub edx, 16
aes_loop:
    movdqu xmm1, xmm0

    ; Load .text encrypted section block in xmm15
    movdqu xmm7, [eax + ecx]

    movdqu  xmm4, oword [esp]
    add     esp, 16
    pxor xmm7, xmm4 ; First xor
    movdqu  xmm4, oword [esp]
    add     esp, 16
    aesdec xmm7, xmm4 ; Round 1
    movdqu  xmm4, oword [esp]
    add     esp, 16
    aesdec xmm7, xmm4 ; Round 2
    movdqu  xmm4, oword [esp]
    add     esp, 16
    aesdec xmm7, xmm4 ; Round 3
    movdqu  xmm4, oword [esp]
    add     esp, 16
    aesdec xmm7, xmm4 ; Round 4
    movdqu  xmm4, oword [esp]
    add     esp, 16
    aesdec xmm7, xmm4 ; Round 5
    movdqu  xmm4, oword [esp]
    add     esp, 16
    aesdec xmm7, xmm4 ; Round 6
    movdqu  xmm4, oword [esp]
    add     esp, 16
    aesdec xmm7, xmm4 ; Round 7
    movdqu  xmm4, oword [esp]
    add     esp, 16
    aesdec xmm7, xmm4 ; Round 8
    movdqu  xmm4, oword [esp]
    add     esp, 16
    aesdec xmm7, xmm4 ; Round 9
    aesdeclast xmm7, xmm0 ; Round 10

    ; Load the encrypted .text section block
    movdqu [eax + ecx], xmm7

    ; Restore the stack for another loop
    sub esp, 160

    add ecx, 16
    cmp edx, ecx
    jle clean
    jmp aes_loop

clean:
    ; Reset the stack
    add esp, 160
	popx eax, edi, esi, esp, edx, ecx, ebx
    jmp	0xFFFFFFFF

; random values here, to be patched
info_start:
info_key:	    dd	0xaaaaaaaa
info_key1:	    dd	0xaaaaaaaa
info_key2:	    dd	0xaaaaaaaa
info_key3:	    dd	0xaaaaaaaa
info_addr:	    dd	0xcccccccc
info_size:	    dd  0xdddddddd
info_offset:    dd  0xeeeeeeee


```

`src/STUB/i386_xor_linux_elf_loader.asm`:

```asm
%macro pushx 1-*
 %rep %0
   push %1
   %rotate 1
 %endrep
%endmacro

%macro popx 1-*
  %rep %0
    %rotate -1
    pop %1
  %endrep
%endmacro

section .text

loader_entry_point32:
	pushx eax, edi, esi, esp, edx, ecx, ebx

    ; syscall : eax
    ; parameters order : ebx, ecx, edx, esi, edi, ebp
    ; sys_write
    call get_my_loc
    sub edx, next_i - msg
	mov ecx, edx
	mov edx, msg_len
	mov ebx, 1
    mov eax, 4
    int 0x80

    ; We save pie offset
    call get_my_loc
    sub edx, next_i - loader_entry_point32
    mov ebx, edx
    call get_my_loc
    sub edx, next_i - info_offset
    sub ebx, [edx]

	jmp	start_unpacking

msg	db	"[Unpacking...]", 10, 0
msg_len	equ	$ - msg

get_my_loc:
    call next_i

next_i:
    pop edx
    ret

start_unpacking:
    call get_my_loc
    sub edx, next_i - info_addr
	mov	eax, [edx]
	call get_my_loc
	sub edx, next_i - info_size
	mov	ecx, [edx]
	call get_my_loc
	sub edx, next_i - info_key
	mov	edx, [edx]

    ; We add PIE offset
	add eax, ebx
	add	ecx, eax

.loop:
	xor	byte [eax], dl
	ror	edx, 4
	inc	eax
	cmp	eax, ecx
	jnz	.loop

	popx eax, edi, esi, esp, edx, ecx, ebx

	jmp	0xFFFFFFF

; Random values here, to be patched
info_key:	    dd	0xaaaaaaaa
info_addr:	    dd	0xbbbbbbbb
info_size:	    dd  0xcccccccc
info_offset:    dd  0xdddddddd

```

`src/STUB/i386_xor_win_pe_loader.asm`:

```asm
%macro pushx 1-*
 %rep %0
   push %1
   %rotate 1
 %endrep
%endmacro

%macro popx 1-*
  %rep %0
    %rotate -1
    pop %1
  %endrep
%endmacro

section .text

loader_entry_point32:
	pushx eax, edi, esi, esp, edx, ecx, ebx

    ; syscall on windows seems like a pain
    ;call get_my_loc
    ;sub edx, next_i - msg
	;mov ecx, edx
	;mov edx, msg_len
	;mov ebx, 1
    ;mov eax, 4
    ;int 0x80

    ; We save pie offset
    call get_my_loc
    sub edx, next_i - loader_entry_point32
    mov ebx, edx
    call get_my_loc
    sub edx, next_i - info_offset
    sub ebx, [edx]

	jmp	start_unpacking

msg	db	"[Unpacking...]", 10, 0
msg_len	equ	$ - msg

get_my_loc:
    call next_i

next_i:
    pop edx
    ret

start_unpacking:
    call get_my_loc
    sub edx, next_i - info_addr
	mov	eax, [edx]
	call get_my_loc
	sub edx, next_i - info_size
	mov	ecx, [edx]
	call get_my_loc
	sub edx, next_i - info_key
	mov	edx, [edx]

    ; We add PIE offset
	add eax, ebx
	add	ecx, eax

.loop:
	xor	byte [eax], dl
	ror	edx, 4
	inc	eax
	cmp	eax, ecx
	jnz	.loop

	popx eax, edi, esi, esp, edx, ecx, ebx

	jmp	0xFFFFFFF

; Random values here, to be patched
info_key:	    dd	0xaaaaaaaa
info_addr:	    dd	0xbbbbbbbb
info_size:	    dd  0xcccccccc
info_offset:    dd  0xdddddddd

```

`src/common/aes_128_ecb_encryption.asm`:

```asm
%macro pushx 1-*
 %rep %0
   push %1
   %rotate 1
 %endrep
%endmacro

%macro popx 1-*
  %rep %0
    %rotate -1
    pop %1
  %endrep
%endmacro

%macro aes_128_keygenassist 1-2
    aeskeygenassist xmm2, xmm1, %1
    call key_expansion_128
    movdqu %2, xmm1
%endmacro

[BITS 64]

global aes_128_ecb_encrypt:function

key_expansion_128:
    pshufd xmm2, xmm2, 0xff
    vpslldq xmm3, xmm1, 0x4
    pxor xmm1, xmm3
    vpslldq xmm3, xmm1, 0x4
    pxor xmm1, xmm3
    vpslldq xmm3, xmm1, 0x4
    pxor xmm1, xmm3
    pxor xmm1, xmm2
    ret

; Used for padding
; PKCS PADDING
;aes_pkcs_padding:
;    sub r9, rsi
;    mov rcx, 16
;    sub rcx, r9
;
;    ; push
;    sub rsp, 16
;    movdqu oword [rsp], xmm15
;.aes_pkcs_pad_loop:
;    mov [rsp+rcx], r9b
;    inc rcx
;    cmp rcx, 16
;    jnz .aes_pkcs_pad_loop
;
;    ; pop
;    movdqu  xmm15, oword [rsp]
;    add     rsp, 16
;
;    jmp after_padding


; void aes_128_ecb_encrypt(char *data, size_t data_size, char *key, size_t key_size)
;                           rdi             rsi         rdx             r10
aes_128_ecb_encrypt:
	pushfq
	pushx rax, rdi, rsi, rsp, rdx, rcx

    ; TODO
	; cmp r10, 128
    ; cmp data_size, ?

    ; 128 bit key
    movdqu xmm1, [rdx]

    ; Move the key in xmm0
    movdqu xmm0, xmm1

    ; Generating round keys
    ; 10 times
    aes_128_keygenassist 0x1, xmm4
    aes_128_keygenassist 0x2, xmm5
    aes_128_keygenassist 0x4, xmm6
    aes_128_keygenassist 0x8, xmm7
    aes_128_keygenassist 0x10, xmm8
    aes_128_keygenassist 0x20, xmm9
    aes_128_keygenassist 0x40, xmm10
    aes_128_keygenassist 0x80, xmm11
    aes_128_keygenassist 0x1b, xmm12
    aes_128_keygenassist 0x36, xmm13

    xor r8, r8

; We can't fully encrypt the .text data when it's not a 16bytes multiple - TOFIX
    sub rsi, 16
aes_loop:
    ; Load .text plaintext section block in xmm15
    movdqu xmm15, [rdi + r8]

; Used for padding
;
;    mov r9, r8
;    add r9, 16
;    cmp r9, rsi
;    jg aes_pkcs_padding
;after_padding:

    ; Whitening step - Round 0
    pxor xmm15, xmm0 ; First xor

    aesenc xmm15, xmm4 ; Round 1
    aesenc xmm15, xmm5 ; Round 2
    aesenc xmm15, xmm6 ; Round 3
    aesenc xmm15, xmm7 ; Round 4
    aesenc xmm15, xmm8 ; Round 5
    aesenc xmm15, xmm9 ; Round 6
    aesenc xmm15, xmm10 ; Round 7
    aesenc xmm15, xmm11 ; Round 8
    aesenc xmm15, xmm12 ; Round 9
    aesenclast xmm15, xmm13 ; Round 10

    ; Load the encrypted .text section block
    movdqu [rdi + r8], xmm15

    add r8, 16
    cmp rsi, r8
    jle clean
    jmp aes_loop

; Used for padding
;    mov r9, r8
;    add r9, 16
;    cmp r9, rsi
;    jg padded_block
;    ; Load the encrypted .text section block
;    movdqu [rdi + r8], xmm15
;    jmp end_aes_loop
;padded_block:
;    mov rcx, rsi
;    sub rcx, r8
;    ; push
;    sub rsp, 16
;    movdqu oword [rsp], xmm15
;padded_block_loop:
;    mov rdx, [rdi+r8]
;    add rsp, 1
;    mov [rdx+rcx], spl
;    inc rcx
;    cmp rcx,16
;    jnz padded_block_loop
;    add rsp, 16
;end_aes_loop:
;    add r8, 16
;    jmp aes_loop

clean:
    popx rax, rdi, rsi, rsp, rdx, rcx
    popfq
    ret


```

`src/common/cipher_functions.c`:

```c
#pragma clang diagnostic push
#pragma ide diagnostic ignored "hicpp-signed-bitwise"
//
// Created by silentvoid on 2/25/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "cipher_functions.h"

#include "log.h"

uint32_t generate_random_key32() {
    // Note: rand() is not a really good pRNG generator but that should be ok in our case
    srand(time(NULL)); // NOLINT(cert-msc32-c,cert-msc51-cpp)
    uint32_t key = rand(); // NOLINT(cert-msc30-c,cert-msc50-cpp)
    return key;
}

uint64_t generate_random_key64() {
    // Note: rand() is not a really good pRNG generator but that should be ok in our case
    srand(time(NULL)); // NOLINT(cert-msc32-c,cert-msc51-cpp)
    uint64_t key = rand(); // NOLINT(cert-msc30-c,cert-msc50-cpp)
    return key;
}

void generate_random_key128() {
    srand(time(NULL)); // NOLINT(cert-msc32-c,cert-msc51-cpp)

    uint32_t first = rand();// NOLINT(cert-msc30-c,cert-msc50-cpp)
    uint32_t second = rand();// NOLINT(cert-msc30-c,cert-msc50-cpp)
    uint32_t third = rand();// NOLINT(cert-msc30-c,cert-msc50-cpp)
    uint32_t fourth = rand();// NOLINT(cert-msc30-c,cert-msc50-cpp)

    memcpy(cipher_key128, &first, sizeof(uint32_t));
    memcpy(cipher_key128+4, &second, sizeof(uint32_t));
    memcpy(cipher_key128+8, &third, sizeof(uint32_t));
    memcpy(cipher_key128+12, &fourth, sizeof(uint32_t));

    //uint32_t test = 0x41414141;
    //memcpy(key, &test, sizeof(uint32_t));
    //memcpy(key+4, &test, sizeof(uint32_t));
    //memcpy(key+8, &test, sizeof(uint32_t));
    //memcpy(key+12, &test, sizeof(uint32_t));
}

uint32_t rotate_right32(uint32_t value) {
    // https://www.geeksforgeeks.org/rotate-bits-of-an-integer/
    // https://blog.regehr.org/archives/1063
    uint32_t n_rotations = sizeof(uint32_t);
    uint32_t int_bits = sizeof(uint32_t) * 8;
    return (value >> n_rotations) | (value << (int_bits - n_rotations));
}

uint64_t rotate_right64(uint64_t value) {
    // https://www.geeksforgeeks.org/rotate-bits-of-an-integer/
    // https://blog.regehr.org/archives/1063
    uint64_t n_rotations = sizeof(uint64_t);
    uint64_t int_bits = sizeof(uint64_t) * 8;
    return (value >> n_rotations) | (value << (int_bits - n_rotations));
}


int xor_encrypt32(char *data, size_t data_size, uint32_t key) {
    for(int i = 0; i < (int)data_size; i++) {
        data[i] = (char)(data[i] ^ key);
        key = rotate_right32(key);
    }

    return 1;
}

int xor_encrypt64(char *data, size_t data_size, uint64_t key) {
    for(int i = 0; i < (int)data_size; i++) {
        data[i] = (char)(data[i] ^ key);
        key = rotate_right64(key);
    }

    return 1;
}

#pragma clang diagnostic pop
```

`src/common/file_functions.c`:

```c
//
// Created by silentvoid on 3/16/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "file_functions.h"
#include "elf_allocation.h"
#include "pe_struct.h"

#include "log.h"

// To keep track of the bytes written for the padding
size_t offset = 0;

/*
 * Mapping file in memory using mmap
 *
 */
int allocate_file(char *file, void **file_data, size_t *file_data_size) {
    int fd = open(file, O_RDONLY);
    if(fd < 0) {
        log_error("open() failure");
        return -1;
    }

    int size = lseek(fd, 0, SEEK_END);
    if(size < 0) {
        close(fd);
        log_error("lseek() failure");
        return -1;
    }
    *file_data_size = size;

    *file_data = mmap(NULL, *file_data_size, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0); // NOLINT(hicpp-signed-bitwise)
    if(*file_data == MAP_FAILED) {
        close(fd);
        log_error("mmap() failure");
        return -1;
    }
    close(fd);

    return 1;
}

int write_to_file(int fd, void *data, size_t data_size) {
    size_t n_bytes;
    if((n_bytes = write(fd, data, data_size)) != data_size) {
        log_error("write() failure");
        return -1;
    }
    offset += n_bytes;

    return 1;
}

int dump_to_file(char *filename, char *data, size_t data_size) {
    FILE *dump;
    dump = fopen(filename, "w");
    if(dump == NULL) {
        log_error("Error dumping file");
        return -1;
    }
    fwrite(data, data_size, 1, dump);
    fclose(dump);

    return 1;
}

void add_zero_padding(int fd, size_t end_offset) {
    char c = 0;
    while(offset < end_offset) {
        write_to_file(fd, &c, sizeof(c));
    }
}

int check_magic_bytes(char *file_data, size_t file_data_size) {
    // TODO: Random value - See for a coherent value
    if(file_data_size < 50) {
        log_error("Invalid file size");
        return UNKNOWN_FILE;
    }

    if(strncmp(file_data, ELFMAG, SELFMAG) == 0) {
        return ELF_FILE;
    }
    else if(strncmp(file_data, STR_DOSMAG, SSTR_DOSMAG) == 0) {
        return PE_FILE;
    }
    else {
        return UNKNOWN_FILE;
    }
}

int get_elf_arch(const char *file_data, size_t file_data_size) {
    // TODO: Maybe improve this
    if(file_data_size < sizeof(Elf32_Ehdr)) {
        log_error("Invalid file size");
        return UNKNOWN_ARCH;
    }

    if(file_data[EI_CLASS] == ELFCLASS32) {
        return x32_ARCH;
    }
    else if(file_data[EI_CLASS] == ELFCLASS64) {
        return x64_ARCH;
    }
    else {
        return UNKNOWN_ARCH;
    }
}

int get_pe_arch(const char *file_data, size_t file_data_size) {
    // TODO: Maybe improve this
    if(file_data_size < sizeof(IMAGE_DOS_HEADER) + DOS_STUB_SIZE + sizeof(IMAGE_NT_HEADERS32)) {
        log_error("Invalid file size");
        return UNKNOWN_ARCH;
    }

    size_t machine_type_offset = sizeof(IMAGE_DOS_HEADER) + DOS_STUB_SIZE + sizeof(uint32_t) + sizeof(IMAGE_FILE_HEADER);
    uint16_t arch_value = *((uint16_t *)(file_data+machine_type_offset));

    if(arch_value == PE32MAG) {
        return x32_ARCH;
    }
    else if(arch_value == PE64MAG) {
        return x64_ARCH;
    }
    else {
        return UNKNOWN_ARCH;
    }
}
```

`src/common/loader_functions.c`:

```c
//
// Created by silentvoid on 3/18/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "loader_functions.h"
#include "cipher_functions.h"
#include "file_functions.h"
#include "elf_allocation.h"
#include "pe_allocation.h"
#include "packer_config.h"

#include "log.h"

uint64_t text_data_size64;
uint64_t text_entry_point64;
uint64_t cipher_key64;
uint64_t loader_offset64;

uint32_t text_data_size32;
uint32_t text_entry_point32;
uint32_t cipher_key32;
uint32_t loader_offset32;

unsigned char cipher_key128[17];

// Set globals variables for nasm code
char * patch_loader() {
    char *loader;

    if(packer_config.arch == x32_ARCH) {
        loader = malloc(packer_config.loader_size);
        if(loader == NULL) {
            log_error("malloc() failure");
            return NULL;
        }
        memset(loader, 0x0, packer_config.loader_size);

        // Copy the loader asm entry point
        memcpy(loader, packer_config.loader_stub, packer_config.loader_size);

        if(strcmp(packer_config.cipher, "aes128_ecb") == 0) {
            memcpy(loader + packer_config.loader_size - CIPHER_KEY_OFFSET32_AES, cipher_key128, 16);
        }
        else {
            memcpy(loader + packer_config.loader_size - CIPHER_KEY_OFFSET32, &cipher_key32, sizeof(uint32_t));
        }
        memcpy(loader + packer_config.loader_size - TEXT_ENTRY_POINT_OFFSET32, &text_entry_point32, sizeof(uint32_t));
        memcpy(loader + packer_config.loader_size - TEXT_DATA_SIZE_OFFSET32, &text_data_size32, sizeof(uint32_t));
        memcpy(loader + packer_config.loader_size - LOADER_OFFSET_OFFSET32, &loader_offset32, sizeof(uint32_t));
    }
    else {
        loader = malloc(packer_config.loader_size);
        if(loader == NULL) {
            log_error("malloc() failure");
            return NULL;
        }
        memset(loader, 0x0, packer_config.loader_size);

        // Copy the loader asm entry point
        memcpy(loader, packer_config.loader_stub, packer_config.loader_size);

        if(strcmp(packer_config.cipher, "aes128_ecb") == 0) {
            memcpy(loader + packer_config.loader_size - CIPHER_KEY_OFFSET64_AES, cipher_key128, 16);
        }
        else {
            memcpy(loader + packer_config.loader_size - CIPHER_KEY_OFFSET64, &cipher_key64, sizeof(uint64_t));
        }
        memcpy(loader + packer_config.loader_size - TEXT_ENTRY_POINT_OFFSET64, &text_entry_point64, sizeof(uint64_t));
        memcpy(loader + packer_config.loader_size - TEXT_DATA_SIZE_OFFSET64, &text_data_size64, sizeof(uint64_t));
        memcpy(loader + packer_config.loader_size - LOADER_OFFSET_OFFSET64, &loader_offset64, sizeof(uint64_t));
    }

    if(packer_config.debug_mode) {
        log_debug("Dumping loader ...");
        dump_to_file("loader.dmp", loader, packer_config.loader_size);
    }

    return loader;
}

```

`src/common/packer_config.c`:

```c
//
// Created by silentvoid on 4/10/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "packer_config.h"
#include "all_loaders.h"
#include "cipher_functions.h"
#include "file_functions.h"
#include "elf_allocation.h"
#include "pe_allocation.h"

#include "log.h"

struct s_packer_config packer_config;

int fill_packer_config(char *packing_method, char *cipher, int arch, int file_type, int debug_mode) {
    strncpy(packer_config.packing_method, packing_method, MAX_PACKING_METHOD_LENGTH);
    strncpy(packer_config.cipher, cipher, MAX_CIPHER_LENGTH);
    packer_config.arch = arch;
    packer_config.debug_mode = debug_mode;

    if(arch == x32_ARCH) {
        if (file_type == ELF_FILE) {
            if (strcmp(cipher, "aes128_ecb") == 0) {
                packer_config.loader_infos_size = I386_AES_128_ECB_LINUX_ELF_LOADER_INFOS_SIZE;
                packer_config.loader_size = I386_AES_128_ECB_LINUX_ELF_LOADER_SIZE;
                packer_config.loader_stub = &(i386_aes_128_ecb_linux_elf_loader_stub[0]);
            } else if (strcmp(cipher, "xor") == 0) {
                packer_config.loader_infos_size = I386_XOR_LINUX_ELF_LOADER_INFOS_SIZE;
                packer_config.loader_size = I386_XOR_LINUX_ELF_LOADER_SIZE;
                packer_config.loader_stub = &(i386_xor_linux_elf_loader_stub[0]);
            }
            else {
                log_error("Unknown cipher");
                return -1;
            }
        } else if (file_type == PE_FILE) {
            if (strcmp(cipher, "aes128_ecb") == 0) {
                packer_config.loader_infos_size = I386_AES_128_ECB_WIN_PE_LOADER_INFOS_SIZE;
                packer_config.loader_size = I386_AES_128_ECB_WIN_PE_LOADER_SIZE;
                packer_config.loader_stub = &(i386_aes_128_ecb_win_pe_loader_stub[0]);
            } else if (strcmp(cipher, "xor") == 0) {
                packer_config.loader_infos_size = I386_XOR_WIN_PE_LOADER_INFOS_SIZE;
                packer_config.loader_size = I386_XOR_WIN_PE_LOADER_SIZE;
                packer_config.loader_stub = &(i386_xor_win_pe_loader_stub[0]);
            }
            else {
                log_error("Unknown cipher");
                return -1;
            }
        } else {
            log_error("Unknown file type");
            return -1;
        }
        return 1;
    }
    else if(arch == x64_ARCH) {
        if(file_type == ELF_FILE) {
            if(strcmp(cipher, "aes128_ecb") == 0) {
                packer_config.loader_infos_size = AMD64_AES_128_ECB_LINUX_ELF_LOADER_INFOS_SIZE;
                packer_config.loader_size = AMD64_AES_128_ECB_LINUX_ELF_LOADER_SIZE;
                packer_config.loader_stub = &(amd64_aes_128_ecb_linux_elf_loader_stub[0]);
            }
            else if(strcmp(cipher, "xor") == 0) {
                packer_config.loader_infos_size = AMD64_XOR_LINUX_ELF_LOADER_INFOS_SIZE;
                packer_config.loader_size = AMD64_XOR_LINUX_ELF_LOADER_SIZE;
                packer_config.loader_stub = &(amd64_xor_linux_elf_loader_stub[0]);
            }
            else {
                log_error("Unknown cipher");
                return -1;
            }
        }
        else if(file_type == PE_FILE) {
            if(strcmp(cipher, "aes128_ecb") == 0) {
                packer_config.loader_infos_size = AMD64_AES_128_ECB_WIN_PE_LOADER_INFOS_SIZE;
                packer_config.loader_size = AMD64_AES_128_ECB_WIN_PE_LOADER_SIZE;
                packer_config.loader_stub = amd64_aes_128_ecb_win_pe_loader_stub;
            }
            else if(strcmp(cipher, "xor") == 0) {
                packer_config.loader_infos_size = AMD64_XOR_WIN_PE_LOADER_INFOS_SIZE;
                packer_config.loader_size = AMD64_XOR_WIN_PE_LOADER_SIZE;
                packer_config.loader_stub = &(amd64_xor_win_pe_loader_stub[0]);
            }
            else {
                log_error("Unknown cipher");
                return -1;
            }
        }
        else {
            log_error("Unknown file type");
            return -1;
        }
    }

    return 1;
}


```

`src/main.c`:

```c
#include <stdio.h>
#include <stdlib.h>

#include "main.h"
#include "packing_method.h"
#include "elf_packing.h"
#include "pe_packing.h"
#include "file_functions.h"
#include "packer_config.h"

#include "argtable3.h"
#include "log.h"

struct method_config method_config;

struct arg_lit *verb, *help, *version, *debug;
struct arg_str *cipher, *packing_method;
struct arg_file *output, *file;
struct arg_end *end;

void display_argtable_help(char *progname, void **argtable) {
    printf("Usage: %s", progname);
    arg_print_syntax(stdout, argtable, "\n");
    arg_print_glossary(stdout, argtable, "  %-25s %s\n");
    exit(0);
}

int main(int argc, char** argv) {
        void *argtable[] = {
                help     = arg_litn("h", "help", 0, 1, "Display this help and exit"),
                version  = arg_litn("V", "version", 0, 1, "Display version info and exit"),
                verb     = arg_litn("v", "verbose", 0, 1, "Verbose output"),
                debug    = arg_litn("d", "debug", 0, 1, "Debug mode"),
                file     = arg_filen("f", "file", "file", 0, 1, "File to pack"),
                cipher   = arg_strn("c", "cipher", "<xor, aes128_ecb>", 0, 1, "Cipher method to use"),
                packing_method = arg_strn("m", "method", "<section_insertion, code_cave, silvio_infection>", 0, 1, "Method to pack the binary"),
                output   = arg_filen("o", "output", "file", 0, 1, "Output file"),
                end      = arg_end(20),
        };

        char *progname = "Silent_Packer";
        char *progversion = "0.1";
        char *progdate = "2020";
        char *author_name = "SilentVoid";

        output->filename[0] = NULL;
        file->filename[0] = NULL;
        cipher->sval[0] = NULL;
        packing_method->sval[0] = NULL;

        int nerrors;
        nerrors = arg_parse(argc, argv, argtable);

        verbose = verb->count;

        if(help->count > 0) {
            display_argtable_help(progname, argtable);
        }

        if(version->count > 0) {
                printf("%s %s\n", progname, progversion);
                printf("Copyright (C) %s %s\n", progdate, author_name);
                exit(0);
        }

        if(nerrors > 0) {
                arg_print_errors(stdout, end, progname);
                printf("Try '%s --help' for more informations.\n", progname);
                exit(1);
        }

        if(file->count > 0 && cipher->count > 0 && packing_method->count > 0) {
            if(
                    (strcmp(cipher->sval[0], "xor") != 0) &&
                    (strcmp(cipher->sval[0], "aes128_ecb") != 0)
            ) {
                log_error("Wrong cipher method");
                display_argtable_help(progname, argtable);
            }

            if(
                    (strcmp(packing_method->sval[0], "silvio_infection") != 0) &&
                    (strcmp(packing_method->sval[0], "code_cave") != 0) &&
                    (strcmp(packing_method->sval[0], "section_insertion") != 0)
            ) {
                log_error("Wrong packing method");
                display_argtable_help(progname, argtable);
            }

            void *file_data;
            size_t file_data_size;

            log_info("Allocating file in memory ...");
            if(allocate_file((char *) file->filename[0], &file_data, &file_data_size) == -1) {
                log_error("Error during file allocation");
                return -1;
            }

            int file_type = check_magic_bytes(file_data, file_data_size);
            if(file_type == ELF_FILE) {
                int arch = get_elf_arch(file_data, file_data_size);
                if(arch == UNKNOWN_ARCH) {
                    munmap(file_data, file_data_size);
                    log_error("Couldn't detect the architecture of the file");
                    return -1;
                }

                if(fill_packer_config((char *) packing_method->sval[0], (char *) cipher->sval[0], arch, file_type, debug->count) == -1) {
                    munmap(file_data, file_data_size);
                    log_error("Error during packer configuration");
                    return -1;
                }

                int p_status = pack_elf((char *) file->filename[0], file_data, file_data_size, (char *) output->filename[0]);
                if(p_status == -1) {
                    log_error("An error occured during the ELF packing");
                }
            }
            else if(file_type == PE_FILE) {
                int arch = get_pe_arch(file_data, file_data_size);
                if(arch == UNKNOWN_ARCH) {
                    munmap(file_data, file_data_size);
                    log_error("Couldn't detect the architecture of the file");
                    return -1;
                }

                if(strcmp(packing_method->sval[0], "silvio_infection") == 0) {
                    munmap(file_data, file_data_size);
                    log_error("Silvio infection is not available for PE files");
                    return -1;
                }

                if(fill_packer_config((char *) packing_method->sval[0], (char *) cipher->sval[0], arch, file_type, debug->count) == -1) {
                    munmap(file_data, file_data_size);
                    log_error("Error during packer configuration");
                    return -1;
                }

                int p_status = pack_pe((char *) file->filename[0], file_data, file_data_size, (char *) output->filename[0]);
                if(p_status == -1) {
                    log_error("An error occured during the PE packing");
                }
             }
            else {
                log_error("Invalid file type");
            }
        }
        else {
            display_argtable_help(progname, argtable);
        }

        arg_freetable(argtable, sizeof(argtable) / sizeof(argtable[0]));
        return 0;
}

```