Project Path: arc_kantam5_DeadByDaylight_amyq1foi

Source Tree:

```txt
arc_kantam5_DeadByDaylight_amyq1foi
├── Binaries
├── Config
│   ├── DefaultEditor.ini
│   ├── DefaultEngine.ini
│   ├── DefaultGame.ini
│   ├── DefaultInput.ini
│   └── HoloLens
│       └── HoloLensEngine.ini
├── Content
│   ├── Ace__1_.uasset
│   ├── Actors
│   │   ├── BP_BearTrap.uasset
│   │   ├── BP_ExitDoor.uasset
│   │   ├── BP_Generator.uasset
│   │   ├── BP_Hook.uasset
│   │   ├── BP_Pallet.uasset
│   │   ├── BP_Trapper_Weapon.uasset
│   │   ├── BP_Window.uasset
│   │   └── MyInteractiveActor.uasset
│   ├── Animations
│   │   ├── ABP_Killer.uasset
│   │   ├── ABP_Survivor.uasset
│   │   ├── Ace_Skeleton_Vault_Montage.uasset
│   │   ├── Crouched_Walking.uasset
│   │   ├── Dropping.uasset
│   │   ├── Dwarf_Walk.uasset
│   │   ├── Fallen_Idle.uasset
│   │   ├── Fallen_Idle1.uasset
│   │   ├── Female_Dynamic_Pose.uasset
│   │   ├── Harvesting.uasset
│   │   ├── Idle.uasset
│   │   ├── Idle__1_.uasset
│   │   ├── Injured_Idle.uasset
│   │   ├── Injured_Run.uasset
│   │   ├── Injured_Stumble_Idle.uasset
│   │   ├── Injured_Walking.uasset
│   │   ├── Kicking.uasset
│   │   ├── Kneeling_Inspecting.uasset
│   │   ├── Lifting_Anim_mixamo_com.uasset
│   │   ├── Lifting__2_.uasset
│   │   ├── Lifting__3_.uasset
│   │   ├── Looking_Down.uasset
│   │   ├── Male_Crouch_Pose.uasset
│   │   ├── Orc_Walk__1_.uasset
│   │   ├── Running.uasset
│   │   ├── Running_Slide.uasset
│   │   ├── Standing_Melee_Attack_Downward.uasset
│   │   ├── Trapper_KnockOut_Montage.uasset
│   │   ├── Trapper_LiftTrap_Montage.uasset
│   │   ├── Trapper_Lift_Montage.uasset
│   │   ├── Trapper_Skeleton_Montage.uasset
│   │   ├── Trapper_Vault_Montage.uasset
│   │   ├── Vault_Over_Box.uasset
│   │   ├── Vault_Over_Box_Anim_mixamo_com.uasset
│   │   ├── Walking__1_.uasset
│   │   └── Zombie_Crawl.uasset
│   ├── Characters
│   │   ├── BP_Killer.uasset
│   │   └── BP_Survivor.uasset
│   ├── Data
│   │   └── SurvivorTable.uasset
│   ├── Default.umap
│   ├── GameModes
│   │   └── BP_DBDGameMode.uasset
│   ├── InteractingInterface.uasset
│   ├── Materials
│   │   ├── Killers
│   │   │   └── Trapper
│   │   │       ├── Weapons
│   │   │       │   ├── machete01_addon01_bc.uasset
│   │   │       │   ├── machete01_addon01_n.uasset
│   │   │       │   ├── machete_bc.uasset
│   │   │       │   └── machete_n.uasset
│   │   │       ├── coach_head_wrp.uasset
│   │   │       ├── detail_skin.uasset
│   │   │       ├── eye-reflection-cubemap.uasset
│   │   │       ├── nothing_eye.uasset
│   │   │       ├── pupil_ambient.uasset
│   │   │       ├── trapper_body_bc.uasset
│   │   │       ├── trapper_body_n.uasset
│   │   │       ├── trapper_body_prestige01_bc.uasset
│   │   │       ├── trapper_body_prestige01_n.uasset
│   │   │       ├── trapper_eyeball.uasset
│   │   │       ├── trapper_mask01_cva_bc.uasset
│   │   │       ├── trapper_mask01_cva_n.uasset
│   │   │       ├── trapper_mask03_bc.uasset
│   │   │       ├── trapper_mask03_n.uasset
│   │   │       ├── trapper_mask04_bc.uasset
│   │   │       ├── trapper_mask04_n.uasset
│   │   │       ├── trapper_mask05_bc.uasset
│   │   │       ├── trapper_mask05_n.uasset
│   │   │       ├── trapper_mask_bc.uasset
│   │   │       ├── trapper_mask_h2o_bc.uasset
│   │   │       ├── trapper_mask_h2o_n.uasset
│   │   │       ├── trapper_mask_n.uasset
│   │   │       ├── trapper_mask_prestige01_bc.uasset
│   │   │       ├── trapper_mask_prestige01_n.uasset
│   │   │       ├── trapper_pants_bc.uasset
│   │   │       ├── trapper_pants_n.uasset
│   │   │       ├── trapper_pants_prestige01_bc.uasset
│   │   │       └── trapper_pants_prestige01_n.uasset
│   │   ├── Objects
│   │   │   ├── closetwood.uasset
│   │   │   ├── hookbanshee.uasset
│   │   │   ├── hookhillbilly.uasset
│   │   │   ├── hooknurse.uasset
│   │   │   ├── hooknurse_n.uasset
│   │   │   ├── map01.uasset
│   │   │   ├── skeleton_key01_bc.uasset
│   │   │   ├── skeleton_key01_n.uasset
│   │   │   ├── t_beartrap01_bc.uasset
│   │   │   ├── t_chest01_bc.uasset
│   │   │   ├── t_flashlight01_bc.uasset
│   │   │   ├── t_generator_bc.uasset
│   │   │   ├── t_generator_n.uasset
│   │   │   ├── t_medkit01_bc.uasset
│   │   │   ├── t_metalplates03_bc.uasset
│   │   │   ├── t_miscellaneous_01_bc.uasset
│   │   │   ├── t_miscellaneous_exitbuilding_bc.uasset
│   │   │   ├── t_pd_plank_04_bc.uasset
│   │   │   └── t_shackplate01_bc.uasset
│   │   ├── PP_CustomDepth.uasset
│   │   └── Survivors
│   │       ├── ace_eyeball.uasset
│   │       ├── avacc01_bc.uasset
│   │       ├── avacc01_bigf.uasset
│   │       ├── avacc01_n.uasset
│   │       ├── avacc01_prestige01_bc.uasset
│   │       ├── avhair02.uasset
│   │       ├── avhead01_bc.uasset
│   │       ├── avhead01_n.uasset
│   │       ├── avhead01_prestige01_bc.uasset
│   │       ├── avlegs01_bc.uasset
│   │       ├── avlegs01_n.uasset
│   │       ├── avlegs01_prestige01_bc.uasset
│   │       ├── avlegs02_bc.uasset
│   │       ├── avlegs02_n.uasset
│   │       ├── avtorso01_bc.uasset
│   │       ├── avtorso01_n.uasset
│   │       ├── avtorso01_prestige01_bc.uasset
│   │       ├── avtorso01_prestige01_n.uasset
│   │       ├── avtorso02_bc.uasset
│   │       ├── avtorso02_n.uasset
│   │       └── hair01_nm.uasset
│   ├── Meshs
│   │   ├── Killers
│   │   │   └── Trapper
│   │   │       ├── Trapper.uasset
│   │   │       ├── Trapper_Body_BC.uasset
│   │   │       ├── Trapper_Mask01_CVA_BC.uasset
│   │   │       ├── Trapper_Mask03_BC.uasset
│   │   │       ├── Trapper_Mask04_BC.uasset
│   │   │       ├── Trapper_Mask05_BC.uasset
│   │   │       ├── Trapper_Mask_BC.uasset
│   │   │       ├── Trapper_Mask_H2O_BC.uasset
│   │   │       ├── Trapper_Pants_BC.uasset
│   │   │       ├── Trapper_PhysicsAsset.uasset
│   │   │       ├── Trapper_Skeleton.uasset
│   │   │       ├── Trapper_eyeball_l.uasset
│   │   │       ├── Trapper_eyeball_r.uasset
│   │   │       └── Weapons
│   │   │           ├── Machete.uasset
│   │   │           ├── Machete01_Addon01_BC.uasset
│   │   │           ├── Machete_Anim.uasset
│   │   │           ├── Machete_BC.uasset
│   │   │           ├── Machete_PhysicsAsset.uasset
│   │   │           └── Machete_Skeleton.uasset
│   │   ├── Objects
│   │   │   ├── BearTrap.uasset
│   │   │   ├── BearTrap_Anim_beartrap01_qc_skeleton_idle.uasset
│   │   │   ├── BearTrap_Anim_beartrap01_qc_skeleton_idle_001.uasset
│   │   │   ├── BearTrap_PhysicsAsset.uasset
│   │   │   ├── BearTrap_Skeleton.uasset
│   │   │   ├── BearTrap_StaticMesh.uasset
│   │   │   ├── ExitDoors.uasset
│   │   │   ├── Generator.uasset
│   │   │   ├── Generator_Anim.uasset
│   │   │   ├── Generator_PhysicsAsset.uasset
│   │   │   ├── Generator_Skeleton.uasset
│   │   │   ├── Generator_StaticMesh.uasset
│   │   │   ├── Hook.uasset
│   │   │   ├── HookBanshee.uasset
│   │   │   ├── Hook_Anim_hookbanshee_qc_skeleton_idle.uasset
│   │   │   ├── Hook_Anim_hookbanshee_qc_skeleton_idle_001.uasset
│   │   │   ├── Hook_PhysicsAsset.uasset
│   │   │   ├── Hook_Skeleton.uasset
│   │   │   ├── Hook_StaticMesh.uasset
│   │   │   ├── Pallet.uasset
│   │   │   ├── Pallet_Anim.uasset
│   │   │   ├── Pallet_PhysicsAsset.uasset
│   │   │   ├── Pallet_Skeleton.uasset
│   │   │   ├── Pallet_StaticMesh.uasset
│   │   │   ├── T_BearTrap01_BC.uasset
│   │   │   ├── T_Generator_BC.uasset
│   │   │   ├── T_MetalPlates03_BC.uasset
│   │   │   ├── T_Miscellaneous_01_BC.uasset
│   │   │   ├── T_Miscellaneous_ExitBuilding_BC.uasset
│   │   │   ├── T_PD_Plank_04_BC.uasset
│   │   │   └── T_ShackPlate01_BC.uasset
│   │   └── Survivors
│   │       ├── AVAcc01_BC.uasset
│   │       ├── AVAcc01_BigF.uasset
│   │       ├── AVHair01.uasset
│   │       ├── AVHead01_BC.uasset
│   │       ├── AVLegs01_BC.uasset
│   │       ├── AVLegs02_BC.uasset
│   │       ├── AVTorso01_BC.uasset
│   │       ├── AVTorso02_BC.uasset
│   │       ├── Ace.uasset
│   │       ├── Ace_PhysicsAsset.uasset
│   │       ├── Ace_Pull_Down_Montage.uasset
│   │       ├── Ace_Skeleton.uasset
│   │       ├── Ace_eyeball_l.uasset
│   │       └── Ace_eyeball_r.uasset
│   ├── MyInteractiveActor.uasset
│   ├── PP_CustomDepth.uasset
│   ├── UI
│   │   ├── ProgressWidget.uasset
│   │   └── SurviveWidget.uasset
│   └── Vault_Over_Box.uasset
├── DeadByDaylight.uproject
├── Intermediate
├── Saved
└── Source
    ├── DeadByDaylight
    │   ├── BearTrap.cpp
    │   ├── BearTrap.h
    │   ├── DBDGameInstance.cpp
    │   ├── DBDGameInstance.h
    │   ├── DBDGameMode.cpp
    │   ├── DBDGameMode.h
    │   ├── DeadByDaylight.Build.cs
    │   ├── DeadByDaylight.cpp
    │   ├── DeadByDaylight.h
    │   ├── ExitDoor.cpp
    │   ├── ExitDoor.h
    │   ├── Generator.cpp
    │   ├── Generator.h
    │   ├── Hook.cpp
    │   ├── Hook.h
    │   ├── InteractiveActor.cpp
    │   ├── InteractiveActor.h
    │   ├── Killer.cpp
    │   ├── Killer.h
    │   ├── KillerAnimInstance.cpp
    │   ├── KillerAnimInstance.h
    │   ├── Pallet.cpp
    │   ├── Pallet.h
    │   ├── Survivor.cpp
    │   ├── Survivor.h
    │   ├── SurvivorAnimInstance.cpp
    │   ├── SurvivorAnimInstance.h
    │   ├── SurvivorStatComponent.cpp
    │   ├── SurvivorStatComponent.h
    │   ├── Weapon.cpp
    │   ├── Weapon.h
    │   ├── Window.cpp
    │   └── Window.h
    ├── DeadByDaylight.Target.cs
    └── DeadByDaylightEditor.Target.cs

```

`Config/DefaultEngine.ini`:

```ini


[/Script/EngineSettings.GameMapsSettings]
EditorStartupMap=/Game/Default.Default
LocalMapOptions=
TransitionMap=None
bUseSplitscreen=True
TwoPlayerSplitscreenLayout=Horizontal
ThreePlayerSplitscreenLayout=FavorTop
FourPlayerSplitscreenLayout=Grid
bOffsetPlayerGamepadIds=False
GameInstanceClass=/Script/DeadByDaylight.DBDGameInstance
GameDefaultMap=/Game/Default.Default
ServerDefaultMap=/Engine/Maps/Entry.Entry
GlobalDefaultGameMode=/Game/GameModes/BP_DBDGameMode.BP_DBDGameMode_C
GlobalDefaultServerGameMode=None

[/Script/HardwareTargeting.HardwareTargetingSettings]
TargetedHardwareClass=Desktop
AppliedTargetedHardwareClass=Desktop
DefaultGraphicsPerformance=Maximum
AppliedDefaultGraphicsPerformance=Maximum

[/Script/WindowsTargetPlatform.WindowsTargetSettings]
DefaultGraphicsRHI=DefaultGraphicsRHI_DX12

[/Script/Engine.RendererSettings]
r.GenerateMeshDistanceFields=True
r.DynamicGlobalIlluminationMethod=1
r.ReflectionMethod=1
r.Shadow.Virtual.Enable=1

[/Script/WorldPartitionEditor.WorldPartitionEditorSettings]
CommandletClass=Class'/Script/UnrealEd.WorldPartitionConvertCommandlet'

[/Script/Engine.Engine]
+ActiveGameNameRedirects=(OldGameName="TP_BlankBP",NewGameName="/Script/DeadByDaylight")
+ActiveGameNameRedirects=(OldGameName="/Script/TP_BlankBP",NewGameName="/Script/DeadByDaylight")

[/Script/AndroidFileServerEditor.AndroidFileServerRuntimeSettings]
bEnablePlugin=True
bAllowNetworkConnection=True
SecurityToken=489A231A43B15B189552009668DBA7FB
bIncludeInShipping=False
bAllowExternalStartInShipping=False
bCompileAFSProject=False
bUseCompression=False
bLogFiles=False
bReportStats=False
ConnectionType=USBOnly
bUseManualIPAddress=False
ManualIPAddress=

[/Script/Engine.CollisionProfile]
-Profiles=(Name="NoCollision",CollisionEnabled=NoCollision,ObjectTypeName="WorldStatic",CustomResponses=((Channel="Visibility",Response=ECR_Ignore),(Channel="Camera",Response=ECR_Ignore)),HelpMessage="No collision",bCanModify=False)
-Profiles=(Name="BlockAll",CollisionEnabled=QueryAndPhysics,ObjectTypeName="WorldStatic",CustomResponses=,HelpMessage="WorldStatic object that blocks all actors by default. All new custom channels will use its own default response. ",bCanModify=False)
-Profiles=(Name="OverlapAll",CollisionEnabled=QueryOnly,ObjectTypeName="WorldStatic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Overlap),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldStatic object that overlaps all actors by default. All new custom channels will use its own default response. ",bCanModify=False)
-Profiles=(Name="BlockAllDynamic",CollisionEnabled=QueryAndPhysics,ObjectTypeName="WorldDynamic",CustomResponses=,HelpMessage="WorldDynamic object that blocks all actors by default. All new custom channels will use its own default response. ",bCanModify=False)
-Profiles=(Name="OverlapAllDynamic",CollisionEnabled=QueryOnly,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Overlap),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldDynamic object that overlaps all actors by default. All new custom channels will use its own default response. ",bCanModify=False)
-Profiles=(Name="IgnoreOnlyPawn",CollisionEnabled=QueryOnly,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore)),HelpMessage="WorldDynamic object that ignores Pawn and Vehicle. All other channels will be set to default.",bCanModify=False)
-Profiles=(Name="OverlapOnlyPawn",CollisionEnabled=QueryOnly,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="Pawn",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Ignore)),HelpMessage="WorldDynamic object that overlaps Pawn, Camera, and Vehicle. All other channels will be set to default. ",bCanModify=False)
-Profiles=(Name="Pawn",CollisionEnabled=QueryAndPhysics,ObjectTypeName="Pawn",CustomResponses=((Channel="Visibility",Response=ECR_Ignore)),HelpMessage="Pawn object. Can be used for capsule of any playerable character or AI. ",bCanModify=False)
-Profiles=(Name="Spectator",CollisionEnabled=QueryOnly,ObjectTypeName="Pawn",CustomResponses=((Channel="WorldStatic",Response=ECR_Block),(Channel="Pawn",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore),(Channel="WorldDynamic",Response=ECR_Ignore),(Channel="Camera",Response=ECR_Ignore),(Channel="PhysicsBody",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore),(Channel="Destructible",Response=ECR_Ignore)),HelpMessage="Pawn object that ignores all other actors except WorldStatic.",bCanModify=False)
-Profiles=(Name="CharacterMesh",CollisionEnabled=QueryOnly,ObjectTypeName="Pawn",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore)),HelpMessage="Pawn object that is used for Character Mesh. All other channels will be set to default.",bCanModify=False)
-Profiles=(Name="PhysicsActor",CollisionEnabled=QueryAndPhysics,ObjectTypeName="PhysicsBody",CustomResponses=,HelpMessage="Simulating actors",bCanModify=False)
-Profiles=(Name="Destructible",CollisionEnabled=QueryAndPhysics,ObjectTypeName="Destructible",CustomResponses=,HelpMessage="Destructible actors",bCanModify=False)
-Profiles=(Name="InvisibleWall",CollisionEnabled=QueryAndPhysics,ObjectTypeName="WorldStatic",CustomResponses=((Channel="Visibility",Response=ECR_Ignore)),HelpMessage="WorldStatic object that is invisible.",bCanModify=False)
-Profiles=(Name="InvisibleWallDynamic",CollisionEnabled=QueryAndPhysics,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="Visibility",Response=ECR_Ignore)),HelpMessage="WorldDynamic object that is invisible.",bCanModify=False)
-Profiles=(Name="Trigger",CollisionEnabled=QueryOnly,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Ignore),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldDynamic object that is used for trigger. All other channels will be set to default.",bCanModify=False)
-Profiles=(Name="Ragdoll",CollisionEnabled=QueryAndPhysics,ObjectTypeName="PhysicsBody",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore)),HelpMessage="Simulating Skeletal Mesh Component. All other channels will be set to default.",bCanModify=False)
-Profiles=(Name="Vehicle",CollisionEnabled=QueryAndPhysics,ObjectTypeName="Vehicle",CustomResponses=,HelpMessage="Vehicle object that blocks Vehicle, WorldStatic, and WorldDynamic. All other channels will be set to default.",bCanModify=False)
-Profiles=(Name="UI",CollisionEnabled=QueryOnly,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Block),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldStatic object that overlaps all actors by default. All new custom channels will use its own default response. ",bCanModify=False)
+Profiles=(Name="NoCollision",CollisionEnabled=NoCollision,bCanModify=False,ObjectTypeName="WorldStatic",CustomResponses=((Channel="Visibility",Response=ECR_Ignore),(Channel="Camera",Response=ECR_Ignore)),HelpMessage="No collision")
+Profiles=(Name="BlockAll",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="WorldStatic",CustomResponses=,HelpMessage="WorldStatic object that blocks all actors by default. All new custom channels will use its own default response. ")
+Profiles=(Name="OverlapAll",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="WorldStatic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Overlap),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldStatic object that overlaps all actors by default. All new custom channels will use its own default response. ")
+Profiles=(Name="BlockAllDynamic",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=,HelpMessage="WorldDynamic object that blocks all actors by default. All new custom channels will use its own default response. ")
+Profiles=(Name="OverlapAllDynamic",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Overlap),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldDynamic object that overlaps all actors by default. All new custom channels will use its own default response. ")
+Profiles=(Name="IgnoreOnlyPawn",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore)),HelpMessage="WorldDynamic object that ignores Pawn and Vehicle. All other channels will be set to default.")
+Profiles=(Name="OverlapOnlyPawn",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="Pawn",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Ignore)),HelpMessage="WorldDynamic object that overlaps Pawn, Camera, and Vehicle. All other channels will be set to default. ")
+Profiles=(Name="Pawn",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="Pawn",CustomResponses=((Channel="Visibility",Response=ECR_Ignore)),HelpMessage="Pawn object. Can be used for capsule of any playerable character or AI. ")
+Profiles=(Name="Spectator",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="Pawn",CustomResponses=((Channel="WorldStatic"),(Channel="Pawn",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore),(Channel="WorldDynamic",Response=ECR_Ignore),(Channel="Camera",Response=ECR_Ignore),(Channel="PhysicsBody",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore),(Channel="Destructible",Response=ECR_Ignore)),HelpMessage="Pawn object that ignores all other actors except WorldStatic.")
+Profiles=(Name="CharacterMesh",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="Pawn",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore)),HelpMessage="Pawn object that is used for Character Mesh. All other channels will be set to default.")
+Profiles=(Name="PhysicsActor",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="PhysicsBody",CustomResponses=,HelpMessage="Simulating actors")
+Profiles=(Name="Destructible",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="Destructible",CustomResponses=,HelpMessage="Destructible actors")
+Profiles=(Name="InvisibleWall",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="WorldStatic",CustomResponses=((Channel="Visibility",Response=ECR_Ignore)),HelpMessage="WorldStatic object that is invisible.")
+Profiles=(Name="InvisibleWallDynamic",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="Visibility",Response=ECR_Ignore)),HelpMessage="WorldDynamic object that is invisible.")
+Profiles=(Name="Trigger",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Ignore),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldDynamic object that is used for trigger. All other channels will be set to default.")
+Profiles=(Name="Ragdoll",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="PhysicsBody",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore)),HelpMessage="Simulating Skeletal Mesh Component. All other channels will be set to default.")
+Profiles=(Name="Vehicle",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="Vehicle",CustomResponses=,HelpMessage="Vehicle object that blocks Vehicle, WorldStatic, and WorldDynamic. All other channels will be set to default.")
+Profiles=(Name="UI",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility"),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldStatic object that overlaps all actors by default. All new custom channels will use its own default response. ")
+Profiles=(Name="Survivor",CollisionEnabled=QueryAndPhysics,bCanModify=True,ObjectTypeName="Survivor",CustomResponses=((Channel="HealSphere",Response=ECR_Overlap),(Channel="Stun",Response=ECR_Ignore)),HelpMessage="Needs description")
+Profiles=(Name="HealSphere",CollisionEnabled=QueryOnly,bCanModify=True,ObjectTypeName="HealSphere",CustomResponses=((Channel="WorldStatic",Response=ECR_Ignore),(Channel="WorldDynamic",Response=ECR_Ignore),(Channel="Pawn",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore),(Channel="Camera",Response=ECR_Ignore),(Channel="PhysicsBody",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore),(Channel="Destructible",Response=ECR_Ignore),(Channel="Survivor",Response=ECR_Overlap),(Channel="Attack",Response=ECR_Ignore),(Channel="Killer",Response=ECR_Overlap),(Channel="Stun",Response=ECR_Ignore)),HelpMessage="Needs description")
+Profiles=(Name="Killer",CollisionEnabled=QueryAndPhysics,bCanModify=True,ObjectTypeName="Killer",CustomResponses=((Channel="HealSphere",Response=ECR_Overlap)),HelpMessage="Needs description")
+DefaultChannelResponses=(Channel=ECC_GameTraceChannel1,DefaultResponse=ECR_Block,bTraceType=False,bStaticObject=False,Name="Survivor")
+DefaultChannelResponses=(Channel=ECC_GameTraceChannel2,DefaultResponse=ECR_Block,bTraceType=True,bStaticObject=False,Name="Attack")
+DefaultChannelResponses=(Channel=ECC_GameTraceChannel3,DefaultResponse=ECR_Ignore,bTraceType=False,bStaticObject=False,Name="HealSphere")
+DefaultChannelResponses=(Channel=ECC_GameTraceChannel4,DefaultResponse=ECR_Block,bTraceType=False,bStaticObject=False,Name="Killer")
+DefaultChannelResponses=(Channel=ECC_GameTraceChannel5,DefaultResponse=ECR_Block,bTraceType=True,bStaticObject=False,Name="Stun")
+EditProfiles=(Name="OverlapAll",CustomResponses=((Channel="Survivor",Response=ECR_Overlap),(Channel="Killer",Response=ECR_Overlap),(Channel="Attack",Response=ECR_Overlap),(Channel="Stun",Response=ECR_Overlap)))
+EditProfiles=(Name="OverlapAllDynamic",CustomResponses=((Channel="Survivor",Response=ECR_Overlap),(Channel="Killer",Response=ECR_Overlap)))
+EditProfiles=(Name="OverlapOnlyPawn",CustomResponses=((Channel="Survivor",Response=ECR_Overlap),(Channel="Killer",Response=ECR_Overlap)))
+EditProfiles=(Name="Spectator",CustomResponses=((Channel="Survivor",Response=ECR_Ignore),(Channel="Killer",Response=ECR_Ignore),(Channel="Attack",Response=ECR_Ignore),(Channel="Stun",Response=ECR_Ignore)))
+EditProfiles=(Name="CharacterMesh",CustomResponses=((Channel="Survivor",Response=ECR_Ignore),(Channel="Killer",Response=ECR_Ignore)))
+EditProfiles=(Name="Trigger",CustomResponses=((Channel="Survivor",Response=ECR_Overlap),(Channel="Killer",Response=ECR_Overlap)))
+EditProfiles=(Name="UI",CustomResponses=((Channel="Survivor",Response=ECR_Overlap),(Channel="Killer",Response=ECR_Overlap)))
+EditProfiles=(Name="NoCollision",CustomResponses=((Channel="Attack",Response=ECR_Ignore),(Channel="Stun",Response=ECR_Ignore)))
-ProfileRedirects=(OldName="BlockingVolume",NewName="InvisibleWall")
-ProfileRedirects=(OldName="InterpActor",NewName="IgnoreOnlyPawn")
-ProfileRedirects=(OldName="StaticMeshComponent",NewName="BlockAllDynamic")
-ProfileRedirects=(OldName="SkeletalMeshActor",NewName="PhysicsActor")
-ProfileRedirects=(OldName="InvisibleActor",NewName="InvisibleWallDynamic")
+ProfileRedirects=(OldName="BlockingVolume",NewName="InvisibleWall")
+ProfileRedirects=(OldName="InterpActor",NewName="IgnoreOnlyPawn")
+ProfileRedirects=(OldName="StaticMeshComponent",NewName="BlockAllDynamic")
+ProfileRedirects=(OldName="SkeletalMeshActor",NewName="PhysicsActor")
+ProfileRedirects=(OldName="InvisibleActor",NewName="InvisibleWallDynamic")
-CollisionChannelRedirects=(OldName="Static",NewName="WorldStatic")
-CollisionChannelRedirects=(OldName="Dynamic",NewName="WorldDynamic")
-CollisionChannelRedirects=(OldName="VehicleMovement",NewName="Vehicle")
-CollisionChannelRedirects=(OldName="PawnMovement",NewName="Pawn")
+CollisionChannelRedirects=(OldName="Static",NewName="WorldStatic")
+CollisionChannelRedirects=(OldName="Dynamic",NewName="WorldDynamic")
+CollisionChannelRedirects=(OldName="VehicleMovement",NewName="Vehicle")
+CollisionChannelRedirects=(OldName="PawnMovement",NewName="Pawn")


```

`Config/DefaultGame.ini`:

```ini


[/Script/EngineSettings.GeneralProjectSettings]
ProjectID=2001E2C342E22B73CCE35F9DA8CBE87E

```

`Config/DefaultInput.ini`:

```ini
[/Script/Engine.InputSettings]
-AxisConfig=(AxisKeyName="Gamepad_LeftX",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
-AxisConfig=(AxisKeyName="Gamepad_LeftY",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
-AxisConfig=(AxisKeyName="Gamepad_RightX",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
-AxisConfig=(AxisKeyName="Gamepad_RightY",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
-AxisConfig=(AxisKeyName="MouseX",AxisProperties=(DeadZone=0.f,Exponent=1.f,Sensitivity=0.07f))
-AxisConfig=(AxisKeyName="MouseY",AxisProperties=(DeadZone=0.f,Exponent=1.f,Sensitivity=0.07f))
-AxisConfig=(AxisKeyName="Mouse2D",AxisProperties=(DeadZone=0.f,Exponent=1.f,Sensitivity=0.07f))
+AxisConfig=(AxisKeyName="Gamepad_LeftX",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_LeftY",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_RightX",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_RightY",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MouseX",AxisProperties=(DeadZone=0.000000,Sensitivity=0.070000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MouseY",AxisProperties=(DeadZone=0.000000,Sensitivity=0.070000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Mouse2D",AxisProperties=(DeadZone=0.000000,Sensitivity=0.070000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MouseWheelAxis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_LeftTriggerAxis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_RightTriggerAxis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_Special_Left_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_Special_Left_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Left_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Left_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Right_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Right_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Left_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Left_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Left_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Left_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Right_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Right_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Right_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Right_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Left_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Left_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Left_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Right_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Right_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Right_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Grip_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Trackpad_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Trackpad_Touch",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Grip_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Trackpad_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
bAltEnterTogglesFullscreen=True
bF11TogglesFullscreen=True
bUseMouseForTouch=False
bEnableMouseSmoothing=True
bEnableFOVScaling=True
bCaptureMouseOnLaunch=True
bEnableLegacyInputScales=True
bAlwaysShowTouchInterface=False
bShowConsoleOnFourFingerTap=True
bEnableGestureRecognizer=False
bUseAutocorrect=False
DefaultViewportMouseCaptureMode=CapturePermanently_IncludingInitialMouseDown
DefaultViewportMouseLockMode=LockOnCapture
FOVScale=0.011110
DoubleClickTime=0.200000
+ActionMappings=(ActionName="StartRun",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=LeftShift)
+ActionMappings=(ActionName="Interact",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=LeftMouseButton)
+ActionMappings=(ActionName="Attack",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=LeftMouseButton)
+ActionMappings=(ActionName="Crouch",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=LeftControl)
+ActionMappings=(ActionName="Action Interact",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=SpaceBar)
+ActionMappings=(ActionName="Killer Interact",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=SpaceBar)
+ActionMappings=(ActionName="Power",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=RightMouseButton)
+AxisMappings=(AxisName="Move Forward / Backward",Scale=1.000000,Key=W)
+AxisMappings=(AxisName="Move Right / Left",Scale=1.000000,Key=D)
+AxisMappings=(AxisName="Look Up / Down Mouse",Scale=-1.000000,Key=MouseY)
+AxisMappings=(AxisName="Turn Right / Left Mouse",Scale=1.000000,Key=MouseX)
+AxisMappings=(AxisName="Move Right / Left",Scale=-1.000000,Key=A)
+AxisMappings=(AxisName="Move Forward / Backward",Scale=-1.000000,Key=S)
+AxisMappings=(AxisName="Interact",Scale=1.000000,Key=LeftMouseButton)
+AxisMappings=(AxisName="Killer Interact",Scale=1.000000,Key=SpaceBar)
+AxisMappings=(AxisName="Attack",Scale=1.000000,Key=LeftMouseButton)
+AxisMappings=(AxisName="Power",Scale=1.000000,Key=RightMouseButton)
DefaultPlayerInputClass=/Script/Engine.PlayerInput
DefaultInputComponentClass=/Script/Engine.InputComponent
DefaultTouchInterface=/Engine/MobileResources/HUD/DefaultVirtualJoysticks.DefaultVirtualJoysticks
-ConsoleKeys=Tilde
+ConsoleKeys=Tilde


```

`Config/HoloLens/HoloLensEngine.ini`:

```ini


[/Script/HoloLensPlatformEditor.HoloLensTargetSettings]
bBuildForEmulation=False
bBuildForDevice=True
bUseNameForLogo=True
bBuildForRetailWindowsStore=False
bAutoIncrementVersion=False
bShouldCreateAppInstaller=False
AppInstallerInstallationURL=
HoursBetweenUpdateChecks=0
bEnablePIXProfiling=False
TileBackgroundColor=(B=64,G=0,R=0,A=255)
SplashScreenBackgroundColor=(B=64,G=0,R=0,A=255)
+PerCultureResources=(CultureId="",Strings=(PackageDisplayName="",PublisherDisplayName="",PackageDescription="",ApplicationDisplayName="",ApplicationDescription=""),Images=())
TargetDeviceFamily=Windows.Holographic
MinimumPlatformVersion=
MaximumPlatformVersionTested=10.0.18362.0
MaxTrianglesPerCubicMeter=500.000000
SpatialMeshingVolumeSize=20.000000
CompilerVersion=Default
Windows10SDKVersion=10.0.18362.0
+CapabilityList=internetClientServer
+CapabilityList=privateNetworkClientServer
+Uap2CapabilityList=spatialPerception
bSetDefaultCapabilities=False
SpatializationPlugin=
ReverbPlugin=
OcclusionPlugin=
SoundCueCookQualityIndex=-1


```

`DeadByDaylight.uproject`:

```uproject
{
	"FileVersion": 3,
	"EngineAssociation": "5.0",
	"Category": "",
	"Description": "",
	"Modules": [
		{
			"Name": "DeadByDaylight",
			"Type": "Runtime",
			"LoadingPhase": "Default",
			"AdditionalDependencies": [
				"Engine"
			]
		}
	],
	"Plugins": [
		{
			"Name": "ModelingToolsEditorMode",
			"Enabled": true,
			"TargetAllowList": [
				"Editor"
			]
		},
		{
			"Name": "Bridge",
			"Enabled": true,
			"SupportedTargetPlatforms": [
				"Win64",
				"Mac",
				"Linux"
			]
		}
	]
}
```

`Source/DeadByDaylight.Target.cs`:

```cs
// Fill out your copyright notice in the Description page of Project Settings.

using UnrealBuildTool;
using System.Collections.Generic;

public class DeadByDaylightTarget : TargetRules
{
	public DeadByDaylightTarget(TargetInfo Target) : base(Target)
	{
		Type = TargetType.Game;
		DefaultBuildSettings = BuildSettingsVersion.V2;

		ExtraModuleNames.AddRange( new string[] { "DeadByDaylight" } );
	}
}

```

`Source/DeadByDaylight/BearTrap.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "BearTrap.h"
#include "Components/SphereComponent.h"
#include "Survivor.h"

// Sets default values
ABearTrap::ABearTrap()
{
	Mesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("Mesh"));
	RootComponent = Mesh;

	InnerSphereCollision = CreateDefaultSubobject<USphereComponent>(TEXT("Inner Sphere Collision"));
	InnerSphereCollision->SetupAttachment(RootComponent);
	InnerSphereCollision->SetSphereRadius(80.0f);

	OuterSphereCollision = CreateDefaultSubobject<USphereComponent>(TEXT("Outer Sphere Collision"));
	OuterSphereCollision->SetupAttachment(RootComponent);
	OuterSphereCollision->SetSphereRadius(150.0f);

	UnlockProgress = 0.0f;
	MaxUnlockProgress = 2.0f;
	bTraping = false;
	bUsed = false;
}

void ABearTrap::Interact()
{
	if (UnlockProgress < MaxUnlockProgress)
	{
		UnlockProgress += FApp::GetDeltaTime() * 1.0f;
	}
	else if (bTraping == true)
	{
		UnlockProgress = 0.0f;

		int flag = FMath::RandRange(0, 1);
		
		if (flag == 0)
		{
			Unlock();
		}
		else if (flag == 1)
		{
			UE_LOG(LogTemp, Warning, TEXT("Try again"));
		}
	}
	else if (bTraping == false)
	{
		UE_LOG(LogTemp, Warning, TEXT("Trap Unlock"));
		UnlockProgress = 0.0f;
		
		bUsed = true;
	}
}

void ABearTrap::EndInteract()
{
	UnlockProgress = 0.0f;
}

void ABearTrap::Unlock()
{
	UE_LOG(LogTemp, Warning, TEXT("Trap Unlock"));
	bTraping = false;

	if (Survivor != nullptr)
	{
		Survivor->SetTraped(false);
		Survivor = nullptr;
	}
}

// Called when the game starts or when spawned
void ABearTrap::BeginPlay()
{
	Super::BeginPlay();
	
	InnerSphereCollision->OnComponentBeginOverlap.AddDynamic(this, &ABearTrap::HandleOverlap);
}

void ABearTrap::HandleOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
{
	if (bUsed == false)
	{
		if (OtherActor->IsA(ASurvivor::StaticClass()))
		{
			Survivor = Cast<ASurvivor>(OtherActor);
			if (Survivor->GetHp() >= 2)
			{
				Survivor->SetTraped(true);

				bTraping = true;
				bUsed = true;

				GEngine->AddOnScreenDebugMessage(-1, 2.f, FColor::Red, TEXT("Trap"));
				UE_LOG(LogTemp, Warning, TEXT("OtherActor: %s"), *OtherActor->GetName());
			}
		}
	}
}

```

`Source/DeadByDaylight/BearTrap.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "BearTrap.generated.h"

UCLASS()
class DEADBYDAYLIGHT_API ABearTrap : public AActor
{
	GENERATED_BODY()
	
public:	
	// Sets default values for this actor's properties
	ABearTrap();

	void Interact();
	void EndInteract();

	void Unlock();

	bool IsTraping() { return bTraping; }
	bool IsUsed() { return bUsed; }

protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;

	UFUNCTION()
	void HandleOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);

private:
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Coponents", meta = (AllowPrivateAccess = "true"))
	UStaticMeshComponent* Mesh;

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Coponents", meta = (AllowPrivateAccess = "true"))
	class USphereComponent* InnerSphereCollision;

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Coponents", meta = (AllowPrivateAccess = "true"))
	USphereComponent* OuterSphereCollision;

	UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = "Gameplay", meta = (AllowPrivateAccess = "true"))
	float MaxUnlockProgress;
	UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = "Gameplay", meta = (AllowPrivateAccess = "true"))
	float UnlockProgress;

	bool bTraping;
	bool bUsed;

	class ASurvivor* Survivor;
};

```

`Source/DeadByDaylight/DBDGameInstance.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "DBDGameInstance.h"

UDBDGameInstance::UDBDGameInstance()
{
	static ConstructorHelpers::FObjectFinder<UDataTable> SurvivorDATA(TEXT("DataTable'/Game/Data/SurvivorTable.SurvivorTable'"));
	// 문제가 있으면 크래시
	if (SurvivorDATA.Succeeded())
	{
		SurvivorStats = SurvivorDATA.Object;
	}
}

void UDBDGameInstance::Init()
{
	Super::Init();
	
}

FSurvivorData* UDBDGameInstance::GetSurvivorData(int32 MaxHp)
{
	return SurvivorStats->FindRow<FSurvivorData>(*FString::FromInt(MaxHp), TEXT(""));
}

```

`Source/DeadByDaylight/DBDGameInstance.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Engine/GameInstance.h"
#include "Engine/DataTable.h"
#include "DBDGameInstance.generated.h"

USTRUCT()
struct FSurvivorData : public FTableRowBase
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	int32 MaxHp;

	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	int32 WalkSpeed;

	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	int32 RunSpeed;

	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	int32 CrawlSpeed;

	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	int32 HangedCount;
};

/**
 * 
 */
UCLASS()
class DEADBYDAYLIGHT_API UDBDGameInstance : public UGameInstance
{
	GENERATED_BODY()
	
public:
	UDBDGameInstance();

	virtual void Init() override;

	FSurvivorData* GetSurvivorData(int32 MaxHp);

private:
	UPROPERTY()
	class UDataTable* SurvivorStats;

};

```

`Source/DeadByDaylight/DBDGameMode.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "DBDGameMode.h"
#include "ExitDoor.h"
#include "Hook.h"
#include "Engine/TargetPoint.h"
#include "Kismet/GameplayStatics.h"
#include "Math/UnrealMathUtility.h"
#include "Blueprint/UserWidget.h"

void ADBDGameMode::BeginPlay()
{
	Super::BeginPlay();

	RemainGenerator = 1;

	UGameplayStatics::GetAllActorsOfClass(this, ATargetPoint::StaticClass(), ExitDoorSpawnPoints);

	ExitDoorSpawnPointIndex_1 = FMath::RandRange(0, 1);
	ExitDoorSpawnPointIndex_2 = FMath::RandRange(2, 3);
}

void ADBDGameMode::SetHookRenderCustomDepth(bool state)
{
	TArray<AActor*> Hooks;

	UGameplayStatics::GetAllActorsOfClass(this, AHook::StaticClass(), Hooks);

	for (AActor* Hook : Hooks)
	{
		AHook* CastedHook = Cast<AHook>(Hook);
		
		CastedHook->Mesh->SetRenderCustomDepth(state);
	}
}

void ADBDGameMode::RepairCompleted()
{
	RemainGenerator--;
	UE_LOG(LogTemp, Warning, TEXT("RemainGenerator : %d"), RemainGenerator);

	if (RemainGenerator == 0)
	{
		ActivateExitGenerator();
	}
}

// 출구 스폰
void ADBDGameMode::ActivateExitGenerator()
{
	FVector ExitDoorSpawnLocation_1 = ExitDoorSpawnPoints[ExitDoorSpawnPointIndex_1]->GetActorLocation();
	FRotator ExitDoorSpawnRotation_1 = ExitDoorSpawnPoints[ExitDoorSpawnPointIndex_1]->GetActorRotation();

	FVector ExitDoorSpawnLocation_2 = ExitDoorSpawnPoints[ExitDoorSpawnPointIndex_2]->GetActorLocation();
	FRotator ExitDoorSpawnRotation_2 = ExitDoorSpawnPoints[ExitDoorSpawnPointIndex_2]->GetActorRotation();

	GetWorld()->SpawnActor<AExitDoor>(ExitDoorClass, ExitDoorSpawnLocation_1, ExitDoorSpawnRotation_1);
	GetWorld()->SpawnActor<AExitDoor>(ExitDoorClass, ExitDoorSpawnLocation_2, ExitDoorSpawnRotation_2);
}

void ADBDGameMode::GameOver(bool)
{
	SurviveScreen = CreateWidget<UUserWidget>(GetWorld(), SurviveWidget);
	if (SurviveScreen)
	{
		SurviveScreen->AddToViewport();
	}
}

```

`Source/DeadByDaylight/DBDGameMode.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/GameModeBase.h"
#include "DBDGameMode.generated.h"

/**
 * 
 */
UCLASS()
class DEADBYDAYLIGHT_API ADBDGameMode : public AGameModeBase
{
	GENERATED_BODY()

public:
	virtual void BeginPlay() override;

	void SetHookRenderCustomDepth(bool state);
	
	void RepairCompleted();

	void ActivateExitGenerator();

	void GameOver(bool bWonGame);

private:
	int RemainGenerator;

	TArray<AActor*> ExitDoorSpawnPoints;

	int ExitDoorSpawnPointIndex_1;
	int ExitDoorSpawnPointIndex_2;

	UPROPERTY(EditDefaultsOnly, Category = "GamePlay")
	TSubclassOf<class AExitDoor> ExitDoorClass;

	UPROPERTY(EditAnywhere)
	TSubclassOf<UUserWidget> SurviveWidget;

	UUserWidget* SurviveScreen;
};

```

`Source/DeadByDaylight/DeadByDaylight.Build.cs`:

```cs
// Fill out your copyright notice in the Description page of Project Settings.

using UnrealBuildTool;

public class DeadByDaylight : ModuleRules
{
	public DeadByDaylight(ReadOnlyTargetRules Target) : base(Target)
	{
		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;

		PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore", "GameplayTasks", "UMG" });

		PrivateDependencyModuleNames.AddRange(new string[] {  });

		// Uncomment if you are using Slate UI
		// PrivateDependencyModuleNames.AddRange(new string[] { "Slate", "SlateCore" });
		
		// Uncomment if you are using online features
		// PrivateDependencyModuleNames.Add("OnlineSubsystem");
		
		// To include OnlineSubsystemSteam, add it to the plugins section in your uproject file with the Enabled attribute set to true
	}
}

```

`Source/DeadByDaylight/DeadByDaylight.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.

#include "DeadByDaylight.h"
#include "Modules/ModuleManager.h"

IMPLEMENT_PRIMARY_GAME_MODULE( FDefaultGameModuleImpl, DeadByDaylight, "DeadByDaylight" );

```

`Source/DeadByDaylight/DeadByDaylight.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"


```

`Source/DeadByDaylight/ExitDoor.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "ExitDoor.h"
#include "Components/BoxComponent.h"
#include "Components/SphereComponent.h"
#include "Misc/App.h"
#include "Kismet/GameplayStatics.h"
#include "DBDGameMode.h"
#include "Survivor.h"

AExitDoor::AExitDoor()
{
	Exit = CreateDefaultSubobject<UBoxComponent>(TEXT("Exit"));
	Exit->SetBoxExtent(FVector(480.0f));
	Exit->SetupAttachment(RootComponent);

	SphereCollision = CreateDefaultSubobject<USphereComponent>(TEXT("Sphere Collision"));
	SphereCollision->SetupAttachment(RootComponent);

	InteractCharacterLocation_0 = CreateDefaultSubobject<USceneComponent>(TEXT("Interact Character Location 0"));
	InteractCharacterLocations.Add(InteractCharacterLocation_0);
	InteractCharacterLocation_0->SetupAttachment(RootComponent);

	PowerProgress = 0.0f;
	MaxPowerProgress = 2.0f;

	bPowered = false;
}

void AExitDoor::Interact()
{
	if (PowerProgress < MaxPowerProgress)
	{
		Super::Interact();
	
		PowerProgress += FApp::GetDeltaTime() * 1.0f;
	}
	else if (bPowered != true)
	{
		bPowered = true;
	
		// 문열기
		Mesh->SetCollisionEnabled(ECollisionEnabled::NoCollision);
		Mesh->SetHiddenInGame(true);
	}
}

void AExitDoor::BeginPlay()
{
	Super::BeginPlay();

	DBDGameMode = Cast<ADBDGameMode>(UGameplayStatics::GetGameMode(this));

	Exit->OnComponentBeginOverlap.AddDynamic(this, &AExitDoor::HandleExitOverlap);
}

void AExitDoor::HandleExitOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
{
	if (OtherActor->IsA(ASurvivor::StaticClass()))
	{
		DBDGameMode->GameOver(true);

		APlayerController* SurvivorController = Cast<APlayerController>(OtherActor->GetInstigatorController());
		OtherActor->DisableInput(SurvivorController);
	}
}

```

`Source/DeadByDaylight/ExitDoor.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "InteractiveActor.h"
#include "ExitDoor.generated.h"

/**
 * 
 */
UCLASS()
class DEADBYDAYLIGHT_API AExitDoor : public AInteractiveActor
{
	GENERATED_BODY()
	
public:
	AExitDoor();

	virtual void Interact() override;

protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;

private:
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Coponents", meta = (AllowPrivateAccess = "true"))
	class UBoxComponent* Exit;

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Coponents", meta = (AllowPrivateAccess = "true"))
	class USphereComponent* SphereCollision;

	UPROPERTY(EditAnywhere, Category = "Coponents", meta = (AllowPrivateAccess = "true"))
	USceneComponent* InteractCharacterLocation_0;

	class ADBDGameMode* DBDGameMode;

	float PowerProgress;
	float MaxPowerProgress;
	bool bPowered;

	UFUNCTION()
	void HandleExitOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);
};

```

`Source/DeadByDaylight/Generator.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "Generator.h"
#include "Components/SphereComponent.h"
#include "Components/BoxComponent.h"
#include "Survivor.h"
#include "Killer.h"
#include "Misc/App.h"
#include "DBDGameMode.h"
#include "Kismet/GameplayStatics.h"

// Sets default values
AGenerator::AGenerator()
{
	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;
	
	SphereCollision = CreateDefaultSubobject<USphereComponent>(TEXT("Sphere Collision"));
	SphereCollision->SetupAttachment(RootComponent);

	InteractCharacterLocation_0 = CreateDefaultSubobject<USceneComponent>(TEXT("Interact Character Location 0"));
	InteractCharacterLocations.Add(InteractCharacterLocation_0);
	InteractCharacterLocation_0->SetupAttachment(RootComponent);

	InteractCharacterLocation_1 = CreateDefaultSubobject<USceneComponent>(TEXT("Interact Character Location 1"));
	InteractCharacterLocations.Add(InteractCharacterLocation_1);
	InteractCharacterLocation_1->SetupAttachment(RootComponent);

	InteractCharacterLocation_2 = CreateDefaultSubobject<USceneComponent>(TEXT("Interact Character Location 2"));
	InteractCharacterLocations.Add(InteractCharacterLocation_2);
	InteractCharacterLocation_2->SetupAttachment(RootComponent);

	InteractCharacterLocation_3 = CreateDefaultSubobject<USceneComponent>(TEXT("Interact Character Location 3"));
	InteractCharacterLocations.Add(InteractCharacterLocation_3);
	InteractCharacterLocation_3->SetupAttachment(RootComponent);

	RepairProgress = 4.0f;
	MaxRepairProgress = 5.0f;

	BrokenProgress = 0.0f;
	MaxBrokenProgress = 1.1f;

	bRepaired = false;
	bBroken = false;

}

// Called when the game starts or when spawned
void AGenerator::BeginPlay()
{
	Super::BeginPlay();

	// GameMode는 BeginPlay에서 설정한다. (Crash 발생)
	DBDGameMode = Cast<ADBDGameMode>(UGameplayStatics::GetGameMode(this));

	// SphereCollision->OnComponentBeginOverlap.AddDynamic(this, &AGenerator::HandleOverlap);
	// SphereCollision->OnComponentEndOverlap.AddDynamic(this, &AGenerator::HandleEndOverlap);

	if (UGameplayStatics::GetPlayerCharacter(GetWorld(), 0)->IsA(AKiller::StaticClass()))
	{
		Mesh->SetRenderCustomDepth(true);
	}
}

// Called every frame
void AGenerator::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

	if (bBroken == true)
	{
		if (RepairProgress > 0.0f)
		{
			RepairProgress -= DeltaTime * 0.3f;
		}
	}
}

void AGenerator::Interact()
{
	if (RepairProgress < MaxRepairProgress)
	{
		Super::Interact();

		bBroken = false;
		RepairProgress += FApp::GetDeltaTime() * 1.0f;
	}
	else if (bRepaired != true)
	{
		bRepaired = true;
		DBDGameMode->RepairCompleted();
	}
}

void AGenerator::KillerInteract()
{
	if (BrokenProgress < MaxBrokenProgress && bBroken == false)
	{
		Super::KillerInteract();
		BrokenProgress += FApp::GetDeltaTime() * 1.0f;
	}
	else if (bBroken != true)
	{
		BrokenProgress = 0.0f;
		bBroken = true;
	}
}

void AGenerator::KillerEndInteract()
{
	BrokenProgress = 0.0f;
}

//void AGenerator::HandleOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
//{
//	ASurvivor* Survivor = Cast<ASurvivor>(OtherActor);
//	RepairProgressScreen = CreateWidget<UUserWidget>(GetWorld(), RepairProgressWidget);
//	if (RepairProgressScreen)
//	{
//		RepairProgressScreen->AddToViewport();
//	}
//
//}
//
//void AGenerator::HandleEndOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
//{
//	if (RepairProgressScreen)
//	{
//		RepairProgressScreen->RemoveFromViewport();
//	}
//}

```

`Source/DeadByDaylight/Generator.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "InteractiveActor.h"
#include "Generator.generated.h"

/**
 * 
 */
UCLASS()
class DEADBYDAYLIGHT_API AGenerator : public AInteractiveActor
{
	GENERATED_BODY()

public:
	// Sets default values for this actor's properties
	AGenerator();

protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;

public:
	// Called every frame
	virtual void Tick(float DeltaTime) override;

	virtual void Interact() override;

	virtual void KillerInteract() override;

	virtual void KillerEndInteract() override;

private:
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Coponents", meta = (AllowPrivateAccess = "true"))
	class USphereComponent* SphereCollision;

	UPROPERTY(EditAnywhere, Category = "Coponents", meta = (AllowPrivateAccess = "true"))
	USceneComponent* InteractCharacterLocation_0;
	UPROPERTY(EditAnywhere, Category = "Coponents", meta = (AllowPrivateAccess = "true"))
	USceneComponent* InteractCharacterLocation_1;
	UPROPERTY(EditAnywhere, Category = "Coponents", meta = (AllowPrivateAccess = "true"))
	USceneComponent* InteractCharacterLocation_2;
	UPROPERTY(EditAnywhere, Category = "Coponents", meta = (AllowPrivateAccess = "true"))
	USceneComponent* InteractCharacterLocation_3;

	UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = "Gameplay", meta = (AllowPrivateAccess = "true"))
	float RepairProgress;
	UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = "Gameplay", meta = (AllowPrivateAccess = "true"))
	float MaxRepairProgress;
	bool bRepaired;

	UPROPERTY(EditAnywhere)
	TSubclassOf<UUserWidget> RepairProgressWidget;
	UUserWidget* RepairProgressScreen;

	class ADBDGameMode* DBDGameMode;

	UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = "Gameplay", meta = (AllowPrivateAccess = "true"))
	float BrokenProgress;
	UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = "Gameplay", meta = (AllowPrivateAccess = "true"))
	float MaxBrokenProgress;

	/*UFUNCTION()
	void HandleOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);

	UFUNCTION()
	void HandleEndOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);*/
	
};

```

`Source/DeadByDaylight/Hook.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "Hook.h"
#include "Survivor.h"
#include "GameFramework/CharacterMovementComponent.h"
#include "Components/SphereComponent.h"
#include "SurvivorStatComponent.h"

AHook::AHook()
{
	SphereCollision = CreateDefaultSubobject<USphereComponent>(TEXT("Sphere Collision"));
	SphereCollision->SetupAttachment(RootComponent);

	SurvivorHookedLocation = CreateDefaultSubobject<USceneComponent>(TEXT("Survivor Hooked Location"));
	SurvivorHookedLocation->SetupAttachment(RootComponent);

	InteractCharacterLocation_0 = CreateDefaultSubobject<USceneComponent>(TEXT("Interact Character Location 0"));
	InteractCharacterLocations.Add(InteractCharacterLocation_0);
	InteractCharacterLocation_0->SetupAttachment(RootComponent);

	SaveProgress = 0.0f;
	MaxSaveProgress = 1.5f;

	HangProgress = 0.0f;
	MaxHangProgress = 1.5f;

	bHanging = false;
}

void AHook::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

}

void AHook::Interact()
{
	if (SaveProgress < MaxSaveProgress && bHanging == true)
	{
		Super::Interact();
		SaveProgress += FApp::GetDeltaTime() * 1.0f;
	}
	else if (bHanging != false)
	{
		SaveProgress = 0.0f;
		bHanging = false;

		// 걸려있는 생존자 떨어뜨리기
		HangingSurvivor->SetActorEnableCollision(true);
		HangingSurvivor->GetCharacterMovement()->GravityScale = 1.0f;
		HangingSurvivor->SetHanged(false);
		HangingSurvivor = nullptr;
	}
}

void AHook::EndInteract()
{
	SaveProgress = 0.0f;
}

void AHook::KillerInteract()
{
	if (HangProgress < MaxHangProgress && bHanging == false)
	{
		Super::KillerInteract();
		HangProgress += FApp::GetDeltaTime() * 1.0f;
	}
	else if (bHanging != true)
	{
		HangProgress = 0.0f;
		bHanging = true;

		HangingSurvivor->DetachFromActor(FDetachmentTransformRules::KeepWorldTransform);
		HangingSurvivor->SetActorEnableCollision(false);
		HangingSurvivor->GetCharacterMovement()->GravityScale = 0.0f;
		HangingSurvivor->SetActorLocation(SurvivorHookedLocation->GetComponentLocation());
		HangingSurvivor->SetActorRotation(SurvivorHookedLocation->GetComponentRotation());
		HangingSurvivor->SetHanged(true);
	}
}

void AHook::KillerEndInteract()
{
	HangingSurvivor = nullptr;
	HangProgress = 0.0f;
}

void AHook::SetHangingSurvivor(ASurvivor* Survivor)
{
	HangingSurvivor = Survivor;
}

```

`Source/DeadByDaylight/Hook.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "InteractiveActor.h"
#include "Hook.generated.h"

/**
 * 
 */
UCLASS()
class DEADBYDAYLIGHT_API AHook : public AInteractiveActor
{
	GENERATED_BODY()
	
public:
	AHook();

	virtual void Tick(float DeltaTime) override;

	virtual void Interact() override;
	virtual void EndInteract() override;

	virtual void KillerInteract() override;
	virtual void KillerEndInteract() override;

	void SetHangingSurvivor(class ASurvivor* Survivor);

	bool IsHanging() { return bHanging; }

private:
	UPROPERTY(EditAnywhere, Category = "Coponents", meta = (AllowPrivateAccess = "true"))
	USceneComponent* SurvivorHookedLocation;

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Coponents", meta = (AllowPrivateAccess = "true"))
	class USphereComponent* SphereCollision;

	UPROPERTY(EditAnywhere, Category = "Coponents", meta = (AllowPrivateAccess = "true"))
	USceneComponent* InteractCharacterLocation_0;

	UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = "Gameplay", meta = (AllowPrivateAccess = "true"))
	float SaveProgress;
	UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = "Gameplay", meta = (AllowPrivateAccess = "true"))
	float MaxSaveProgress;

	UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = "Gameplay", meta = (AllowPrivateAccess = "true"))
	float HangProgress;
	UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = "Gameplay", meta = (AllowPrivateAccess = "true"))
	float MaxHangProgress;

	bool bHanging;

	class ASurvivor* HangingSurvivor;
};

```

`Source/DeadByDaylight/InteractiveActor.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "InteractiveActor.h"

// Sets default values
AInteractiveActor::AInteractiveActor()
{
 	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;

	Mesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("Mesh"));
	RootComponent = Mesh;
}

// Called when the game starts or when spawned
void AInteractiveActor::BeginPlay()
{
	Super::BeginPlay();
	
}

// Called every frame
void AInteractiveActor::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

}

void AInteractiveActor::Interact()
{
	
}

void AInteractiveActor::EndInteract()
{

}

void AInteractiveActor::KillerInteract()
{

}

void AInteractiveActor::KillerEndInteract()
{

}

bool AInteractiveActor::IsBroken()
{
	return bBroken;
}

```

`Source/DeadByDaylight/InteractiveActor.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "InteractiveActor.generated.h"

UCLASS()
class DEADBYDAYLIGHT_API AInteractiveActor : public AActor
{
	GENERATED_BODY()
	
public:	
	// Sets default values for this actor's properties
	AInteractiveActor();

protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;

public:
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Coponents", meta = (AllowPrivateAccess = "true"))
	UStaticMeshComponent* Mesh;

public:	
	// Called every frame
	virtual void Tick(float DeltaTime) override;

	virtual void Interact();
	virtual void EndInteract();

	virtual void KillerInteract();
	virtual void KillerEndInteract();

	virtual bool IsBroken();

	TArray<USceneComponent*> InteractCharacterLocations;

	bool bBroken;
};

```

`Source/DeadByDaylight/Killer.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "Killer.h"
#include "Camera/CameraComponent.h"
#include "GameFramework/CharacterMovementComponent.h"
#include "Components/SpotLightComponent.h"
#include "Components/CapsuleComponent.h"
#include "Kismet/KismetSystemLibrary.h"
#include "Kismet/GameplayStatics.h"
#include "Weapon.h"
#include "KillerAnimInstance.h"
#include "InteractiveActor.h"
#include "Generator.h"
#include "Pallet.h"
#include "Window.h"
#include "Survivor.h"
#include "Hook.h"
#include "Misc/App.h"
#include "BearTrap.h"
#include "DBDGameMode.h"

AKiller::AKiller()
{
	PrimaryActorTick.bCanEverTick = true;

	Camera = CreateDefaultSubobject<UCameraComponent>(TEXT("Camera"));
	Camera->bUsePawnControlRotation = true;

	EyeLight = CreateDefaultSubobject<USpotLightComponent>(TEXT("Eye Light"));
	EyeLight->SetIntensity(5000.0f);
	EyeLight->SetLightColor(FLinearColor::Red);

	WalkSpeed = 1400.0f;
	AttackDelaySpeed = 400.0f;
	CarryingWalkSpeed = 1000.0f;
	GetCharacterMovement()->MaxWalkSpeed = WalkSpeed;

	bAttackDelay = false;
	bCanAttack = true;
	bHoldingAttack = false;
	MaxHoldingAttackProgress = 1.0f;
	HoldingAttackProgress = 0.0f;

	MaxPowerCount = 2;
	PowerCount = MaxPowerCount;
	PowerProgress = 0.0f;
	MaxPowerProgress = 3.0f;

	bAttacking = false;
	bInteracting = false;
	bCarrying = false;
	bActionInteracting = false;
	bUsingPower = false;
}

void AKiller::BeginPlay()
{
	Super::BeginPlay();

	DBDGameMode = Cast<ADBDGameMode>(UGameplayStatics::GetGameMode(this));
	
	// 생성자에서 호출 시 Head에 달리지 않음
	Camera->AttachToComponent(GetMesh(), FAttachmentTransformRules::SnapToTargetIncludingScale, "Head");
	EyeLight->AttachToComponent(GetMesh(), FAttachmentTransformRules::SnapToTargetIncludingScale, "Head");
	
	Weapon = GetWorld()->SpawnActor<AWeapon>(WeaponClass);
	if (Weapon)
	{
		Weapon->AttachToComponent(GetMesh(), FAttachmentTransformRules::SnapToTargetNotIncludingScale, TEXT("WeaponSocket"));
		Weapon->SetOwner(this);
	}

	BearTrap = GetWorld()->SpawnActor<ABearTrap>(BearTrapClass);
	if (BearTrap)
	{
		BearTrap->AttachToComponent(GetMesh(), FAttachmentTransformRules::SnapToTargetNotIncludingScale, TEXT("BearTrapSocket"));
		BearTrap->SetOwner(this);
		BearTrap->SetActorEnableCollision(false);
	}
}

void AKiller::PostInitializeComponents()
{
	Super::PostInitializeComponents();

	KillerAnimInstance = Cast<UKillerAnimInstance>(GetMesh()->GetAnimInstance());
	if (KillerAnimInstance)
	{
		KillerAnimInstance->OnMontageEnded.AddDynamic(this, &AKiller::OnAttackMontageEnded);
		KillerAnimInstance->OnAttackHit.AddUObject(this, &AKiller::AttackCheck);
	}
}

void AKiller::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);
	
	if (IsActionInteracting())
	{
		GetController()->SetIgnoreLookInput(true);
		GetController()->SetIgnoreMoveInput(true);
	}
}

void AKiller::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)
{
	Super::SetupPlayerInputComponent(PlayerInputComponent);

	PlayerInputComponent->BindAxis("Move Forward / Backward", this, &AKiller::MoveForward);
	PlayerInputComponent->BindAxis("Move Right / Left", this, &AKiller::MoveRight);

	PlayerInputComponent->BindAxis("Turn Right / Left Mouse", this, &APawn::AddControllerYawInput);
	PlayerInputComponent->BindAxis("Look Up / Down Mouse", this, &APawn::AddControllerPitchInput);

	PlayerInputComponent->BindAxis("Attack", this, &AKiller::AttackAxis);
	PlayerInputComponent->BindAction("Attack", EInputEvent::IE_Released, this, &AKiller::EndAttack);

	PlayerInputComponent->BindAxis("Power", this, &AKiller::Power);
	PlayerInputComponent->BindAction("Power", EInputEvent::IE_Pressed, this, &AKiller::PickUpTrap);
	PlayerInputComponent->BindAction("Power", EInputEvent::IE_Released, this, &AKiller::EndPower);

	PlayerInputComponent->BindAxis("Killer Interact", this, &AKiller::Interact);
	PlayerInputComponent->BindAction("Killer Interact", EInputEvent::IE_Released, this, &AKiller::EndInteract);

	PlayerInputComponent->BindAction("Action Interact", EInputEvent::IE_Pressed, this, &AKiller::ActionInteract);
}


void AKiller::MoveForward(float Value)
{
	if ((Controller != nullptr) && (Value != 0.0f))
	{
		// find out which way is forward
		const FRotator Rotation = Controller->GetControlRotation();
		const FRotator YawRotation(0, Rotation.Yaw, 0);

		// get forward vector
		const FVector Direction = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::X);
		AddMovementInput(Direction, Value);
	}
}

void AKiller::MoveRight(float Value)
{
	if ((Controller != nullptr) && (Value != 0.0f))
	{
		// find out which way is right
		const FRotator Rotation = Controller->GetControlRotation();
		const FRotator YawRotation(0, Rotation.Yaw, 0);

		// get right vector 
		const FVector Direction = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::Y);
		// add movement in that direction
		AddMovementInput(Direction, Value);
	}
}


void AKiller::AttackAxis(float Value)
{
	if ((Controller != nullptr) && (Value != 0.0f) && bCanAttack)
	{
		bAttackDelay = true;

		if (HoldingAttackProgress < MaxHoldingAttackProgress)
		{
			HoldingAttackProgress += FApp::GetDeltaTime() * 1.0f;
		}
		else if (bHoldingAttack != true)
		{
			bHoldingAttack = true;
			LungeAttack();
		}
	}
}

void AKiller::LungeAttack()
{
	if (bCanAttack)
	{
		bCanAttack = false;
		GetCharacterMovement()->MaxWalkSpeed = 3000.0f;

		FTimerHandle AttackTimerHandle;
		float MontageDelay = KillerAnimInstance->PlayAttackMontage() - 0.2f;
		GetWorld()->GetTimerManager().SetTimer(AttackTimerHandle, this, &AKiller::EndAttackMontage, MontageDelay);
	}
}

void AKiller::EndAttack()
{
	if (HoldingAttackProgress < 0.4f && bCanAttack)
	{
		bCanAttack = false;
		FTimerHandle AttackTimerHandle;
		float MontageDelay = KillerAnimInstance->PlayAttackMontage() - 0.2f;
		GetWorld()->GetTimerManager().SetTimer(AttackTimerHandle, this, &AKiller::EndAttackMontage, MontageDelay);
	}

	bHoldingAttack = false;
	HoldingAttackProgress = 0.0f;
}

void AKiller::EndAttackMontage()
{
	GetCharacterMovement()->MaxWalkSpeed = AttackDelaySpeed;

	// hit result에 따라 애니메이션 호출
	FTimerHandle AttackDelayTimerHandle;
	float AttackDelay = 1.0f;
	GetWorld()->GetTimerManager().SetTimer(AttackDelayTimerHandle, this, &AKiller::EndAttackDelay, AttackDelay);


	bHoldingAttack = false;
	HoldingAttackProgress = 0.0f;
}

void AKiller::EndAttackDelay()
{
	bAttackDelay = false;

	bCanAttack = true;

	GetCharacterMovement()->StopMovementImmediately();
	GetCharacterMovement()->MaxWalkSpeed = WalkSpeed;

	bHoldingAttack = false;
	HoldingAttackProgress = 0.0f;
}

void AKiller::OnAttackMontageEnded(UAnimMontage* Montage, bool bInterrupted)
{
	bAttacking = false;
}

// 몽타주에서 설정한 AttackHit
void AKiller::AttackCheck()
{
	FHitResult HitResult;
	FCollisionQueryParams Params(NAME_None, false, this);

	float AttackRange = 200.0f;
	float AttackRadius = 100.0f;

	bool bResult = GetWorld()->SweepSingleByChannel(
		HitResult,
		GetActorLocation(),
		GetActorLocation() + GetActorForwardVector() * AttackRange,
		FQuat::Identity,
		ECollisionChannel::ECC_GameTraceChannel2,
		FCollisionShape::MakeSphere(AttackRadius),
		Params
	);

	FVector Vec = GetActorForwardVector() * AttackRange;
	FVector Center = GetActorLocation() + Vec * 0.5f;
	float HalfHeight = AttackRange * 0.5f + AttackRange;
	FQuat Rotation = FRotationMatrix::MakeFromZ(Vec).ToQuat();
	FColor DrawColor;
	if (bResult)
	{
		DrawColor = FColor::Green;
	}
	else
	{
		DrawColor = FColor::Red;
	}

	DrawDebugCapsule(GetWorld(), Center, HalfHeight, AttackRadius, Rotation, DrawColor, false, 2.0f);

	UE_LOG(LogTemp, Warning, TEXT("Attack"));

	if (bResult && HitResult.GetActor())
	{
		UE_LOG(LogTemp, Warning, TEXT("Hit Actor : %s"), *HitResult.GetActor()->GetName());

		FDamageEvent DamageEvent;
		HitResult.GetActor()->TakeDamage(1.0f, DamageEvent, GetController(), this);
	}
}

// 덫 설치
void AKiller::Power(float Value)
{
	if (Controller != nullptr && Value != 0.0f)
	{
		if (PowerCount > 0)
		{
			if (PowerProgress < MaxPowerProgress)
			{
				PowerProgress += FApp::GetDeltaTime() * 1.0f;

				SetUsingPower(true);
			}
			else
			{
				PowerCount--;
				PowerProgress = 0.0f;

				FVector BearTrapLocation = GetActorLocation() + GetActorForwardVector() * 300.0f;
				BearTrapLocation = FVector(BearTrapLocation.X, BearTrapLocation.Y, 0.0f);
				GetWorld()->SpawnActor<ABearTrap>(BearTrapClass, BearTrapLocation, GetActorRotation());

				SetUsingPower(false);
			}
		}
	}
}

void AKiller::EndPower()
{
	SetUsingPower(false);

	PowerProgress = 0.0f;
}

void AKiller::PickUpTrap()
{
	GetOverlappingActors(OverlappingActors);
	if (Controller != nullptr)
	{
		AActor* MinOverlappingActor = GetMinOverlappingActor();

		if (MinOverlappingActor && MinOverlappingActor->IsA(ABearTrap::StaticClass()) && bAttackDelay == false)
		{
			if (PowerCount < MaxPowerCount)
			{
				ABearTrap* GroundBearTrap = Cast<ABearTrap>(MinOverlappingActor);
				GroundBearTrap->Destroy();

				PowerCount++;

				SetActionInteracting(true);

				FTimerHandle LiftTimerHandle;
				float MontageDelay = KillerAnimInstance->PlayLiftTrapMontage();
				GetWorld()->GetTimerManager().SetTimer(LiftTimerHandle, this, &AKiller::EndPickUpTrapMontage, MontageDelay);
			}
		}
	}
}

void AKiller::EndPickUpTrapMontage()
{
	UE_LOG(LogTemp, Warning, TEXT("Power Count: %d"), PowerCount);
	SetActionInteracting(false);
}


void AKiller::SetInteracting(bool state)
{
	bInteracting = state;
	if (state == true)
	{
		GetController()->SetIgnoreLookInput(true);
		GetController()->SetIgnoreMoveInput(true);
	}
	else if (state == false)
	{
		GetController()->ResetIgnoreInputFlags();
	}
}

void AKiller::SetCarrying(bool state)
{
	// Set hook custom depth render
	DBDGameMode->SetHookRenderCustomDepth(state);

	bCarrying = state;
	if (state == true)
	{
		GetCharacterMovement()->MaxWalkSpeed = CarryingWalkSpeed;
	}
	else if (state == false)
	{
		GetCharacterMovement()->MaxWalkSpeed = WalkSpeed;
	}
}

void AKiller::SetActionInteracting(bool state)
{
	bActionInteracting = state;
	if (state == true)
	{
		GetController()->SetIgnoreLookInput(true);
		GetController()->SetIgnoreMoveInput(true);
	}
	else if (state == false)
	{
		GetController()->ResetIgnoreInputFlags();
	}
}

void AKiller::SetUsingPower(bool state)
{
	bUsingPower = state;
	if (state == true)
	{
		GetController()->SetIgnoreLookInput(true);
		GetController()->SetIgnoreMoveInput(true);
	}
	else if (state == false)
	{
		GetController()->ResetIgnoreInputFlags();
	}
}


void AKiller::Interact(float Value)
{
	// Survivor와 Overlap된 Actor들 중에서 가장 가까운 Actors에 Interact
	GetOverlappingActors(OverlappingActors);

	if ((Controller != nullptr) && (Value != 0.0f))
	{
		AActor* MinOverlappingActor = GetMinOverlappingActor();

		// 발전기
		if (MinOverlappingActor && MinOverlappingActor->IsA(AGenerator::StaticClass()) && bAttackDelay == false)
		{
			InteractingActor = Cast<AGenerator>(MinOverlappingActor);
			if (InteractingActor && !InteractingActor->IsBroken())
			{
				InteractingActor->KillerInteract();

				SetKillerInteractLocation(MinOverlappingActor);

				SetInteracting(true);
			}
		}
		// 판자
		else if (MinOverlappingActor && MinOverlappingActor->IsA(APallet::StaticClass()) && bAttackDelay == false)
		{
			APallet* Pallet = Cast<APallet>(MinOverlappingActor);
			if (Pallet && !Pallet->IsBroken() && Pallet->IsUsed())
			{
				Pallet->KillerInteract();

				SetKillerInteractLocation(MinOverlappingActor);

				SetInteracting(true);
			}
		}
		// 갈고리
		else if (MinOverlappingActor && MinOverlappingActor->IsA(AHook::StaticClass()) && bCarrying && Survivor && bAttackDelay == false)
		{
			AHook* Hook = Cast<AHook>(MinOverlappingActor);
			if (Hook && !Hook->IsHanging())
			{
				Hook->SetHangingSurvivor(Survivor);
				Hook->KillerInteract();

				SetKillerInteractLocation(MinOverlappingActor);

				// hook 애니메이션으로 변경
				SetInteracting(true);
			}
		}
	}
}

void AKiller::EndInteract()
{
	if (InteractingActor)
	{
		InteractingActor->KillerEndInteract();
		InteractingActor = nullptr;
	}

	SetInteracting(false);
}



void AKiller::ActionInteract()
{
	GetOverlappingActors(OverlappingActors);

	AActor* MinOverlappingActor = GetMinOverlappingActor();

	bool bHook = false;
	if (MinOverlappingActor)
	{
		if (MinOverlappingActor->IsA(AHook::StaticClass()))
		{
			bHook = true;
		}
	}
	// 생존자를 들고 있을 때 내려놓기
	if (Controller != nullptr && Survivor && Survivor->IsCarried() && !bHook && bAttackDelay == false)
	{
		Survivor->SetActorEnableCollision(true);
		Survivor->SetCarried(false);
		Survivor->GetCharacterMovement()->GravityScale = 1.0f;
		Survivor->DetachFromActor(FDetachmentTransformRules::KeepWorldTransform);
		Survivor = nullptr;

		SetCarrying(false);
	}
	else if (Controller != nullptr && Survivor == nullptr && bAttackDelay == false)
	{
		// 창틀
		if (MinOverlappingActor && MinOverlappingActor->IsA(AWindow::StaticClass()))
		{
			SetKillerActionInteractLocation(MinOverlappingActor);
			
			FTimerHandle VaultTimerHandle;
			float MontageDelay = KillerAnimInstance->PlayVaultMontage();
			GetWorld()->GetTimerManager().SetTimer(VaultTimerHandle, this, &AKiller::EndVaultMontage, MontageDelay);
		}
		// 생존자 들기
		else if (MinOverlappingActor && MinOverlappingActor->IsA(ASurvivor::StaticClass()))
		{
			Survivor = Cast<ASurvivor>(MinOverlappingActor);
			if (Survivor->GetHp() == 1 && !Survivor->IsCarried())
			{	
				SetKillerActionInteractLocation(MinOverlappingActor);

				FTimerHandle VaultTimerHandle;
				float MontageDelay = KillerAnimInstance->PlayLiftMontage();
				GetWorld()->GetTimerManager().SetTimer(VaultTimerHandle, this, &AKiller::EndLiftMontage, MontageDelay);
			}
		}
	}
}

void AKiller::EndVaultMontage()
{
	InteractingActor = nullptr;

	SetActorLocation(WindowPalletInteractMoveLocation);

	// GetCapsuleComponent()->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);
	// GetCharacterMovement()->SetMovementMode(EMovementMode::MOVE_Walking);

	SetActionInteracting(false);

	WindowPalletInteractMoveLocation = GetActorLocation();
}

void AKiller::EndLiftMontage()
{
	Survivor->SetActorEnableCollision(false);

	SetActionInteracting(false);

	FDamageEvent DamageEvent;
	Survivor->TakeDamage(2.0f, DamageEvent, GetController(), this);

	Survivor->SetCarried(true);
	Survivor->GetCharacterMovement()->GravityScale = 0.0f;
	Survivor->AttachToComponent(GetMesh(), FAttachmentTransformRules::SnapToTargetNotIncludingScale, TEXT("SurvivorHangLocation"));
}


void AKiller::KnockOut()
{
	GEngine->AddOnScreenDebugMessage(-1, 2.f, FColor::Red, TEXT("Killer KnockOut"));
	UE_LOG(LogTemp, Warning, TEXT("KnockOut"));
	GetController()->SetIgnoreLookInput(true);
	GetController()->SetIgnoreMoveInput(true);

	FTimerHandle StunTimerHandle;
	float MontageDelay = KillerAnimInstance->PlayKnockOutMontage();
	GetWorld()->GetTimerManager().SetTimer(StunTimerHandle, this, &AKiller::EndKnockOut, MontageDelay);
}

void AKiller::EndKnockOut()
{
	GEngine->AddOnScreenDebugMessage(-1, 2.f, FColor::Red, TEXT("Killer EndKnockOut"));
	UE_LOG(LogTemp, Warning, TEXT("EndKnockOut"));
	GetController()->ResetIgnoreInputFlags();
}



// 상호작용 시 생존자와 Overlap중인 가장 가까운 Actor를 반환
AActor* AKiller::GetMinOverlappingActor()
{
	// 가장 가까운 InteractingActor
	AActor* MinOverlappingActor = nullptr;
	float MinDistance = 5000.0f;

	if (!OverlappingActors.IsEmpty())
	{
		for (AActor* OverlappingActor : OverlappingActors)
		{
			float ActorDistance = FVector::Dist(GetActorLocation(), OverlappingActor->GetActorLocation());
			if (MinDistance > ActorDistance)
			{
				MinDistance = ActorDistance;
				MinOverlappingActor = OverlappingActor;
			}
		}
	}

	return MinOverlappingActor;
}

void AKiller::SetKillerInteractLocation(AActor* MinOverlappingActor)
{
	InteractingActor = Cast<AInteractiveActor>(MinOverlappingActor);

	// Interact시 Killer의 위치를 고정
	USceneComponent* InteractLocation = nullptr;
	float MinInteractDistance = 1000.0f;
	if (!InteractLocation)
	{
		for (USceneComponent* InteractCharacterLocation : InteractingActor->InteractCharacterLocations)
		{
			float LocationDistance = FVector::Dist(GetActorLocation(), InteractCharacterLocation->GetComponentLocation());
			if (MinInteractDistance >= LocationDistance)
			{
				MinInteractDistance = LocationDistance;
				InteractLocation = InteractCharacterLocation;
			}
		}
	}

	SetActorLocation(FVector(InteractLocation->GetComponentLocation().X, InteractLocation->GetComponentLocation().Y, GetActorLocation().Z));

	FVector ToTarget = InteractingActor->GetActorLocation() - GetActorLocation();
	FRotator LookAtRotation = FRotator(0.0f, ToTarget.Rotation().Yaw, 0.0f);
	GetController()->SetControlRotation(LookAtRotation);
}

void AKiller::SetKillerActionInteractLocation(AActor* MinOverlappingActor)
{
	if (MinOverlappingActor->IsA(ASurvivor::StaticClass()))
	{
		FVector ToTarget = Survivor->GetActorLocation() - Camera->GetComponentLocation();
		FRotator LookAtRotation = FRotator(ToTarget.Rotation());
		GetController()->SetControlRotation(LookAtRotation);

		SetActionInteracting(true);

		GetCharacterMovement()->StopMovementImmediately();

		// carry 애니메이션
		SetCarrying(true);
	}
	else
	{
		InteractingActor = Cast<AInteractiveActor>(MinOverlappingActor);

		USceneComponent* MoveLocation = nullptr;
		USceneComponent* InteractLocation = nullptr;
		float MaxInteractDistance = 0.0f;
		float MinInteractDistance = 1000.0f;
		for (USceneComponent* InteractCharacterLocation : InteractingActor->InteractCharacterLocations)
		{
			float LocationDistance = FVector::Dist(GetActorLocation(), InteractCharacterLocation->GetComponentLocation());
			if (MaxInteractDistance <= LocationDistance)
			{
				MaxInteractDistance = LocationDistance;
				MoveLocation = InteractCharacterLocation;
			}
			if (MinInteractDistance >= LocationDistance)
			{
				MinInteractDistance = LocationDistance;
				InteractLocation = InteractCharacterLocation;
			}
		}

		// GetCharacterMovement()->SetMovementMode(EMovementMode::MOVE_Flying);
		// GetCapsuleComponent()->SetCollisionEnabled(ECollisionEnabled::NoCollision);
		SetActorLocation(FVector(InteractLocation->GetComponentLocation().X, InteractLocation->GetComponentLocation().Y, GetActorLocation().Z));

		// FVector ToTarget = MoveLocation->GetComponentLocation() - InteractLocation->GetComponentLocation();
		FVector ToTarget = InteractingActor->GetActorLocation() - Camera->GetComponentLocation();
		FRotator LookAtRotation = FRotator(ToTarget.Rotation());
		GetController()->SetControlRotation(LookAtRotation);

		SetActionInteracting(true);
		GetCharacterMovement()->StopMovementImmediately();
		WindowPalletInteractMoveLocation = FVector(MoveLocation->GetComponentLocation().X, MoveLocation->GetComponentLocation().Y, GetActorLocation().Z);
	}
	
}
```

`Source/DeadByDaylight/Killer.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Character.h"
#include "Killer.generated.h"

UCLASS()
class DEADBYDAYLIGHT_API AKiller : public ACharacter
{
	GENERATED_BODY()

public:
	// Sets default values for this character's properties
	AKiller();

protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;

	virtual void PostInitializeComponents() override;

public:	
	// Called every frame
	virtual void Tick(float DeltaTime) override;

	// Called to bind functionality to input
	virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;

protected:
	void MoveForward(float Value);
	void MoveRight(float Value);

	void AttackAxis(float Value);
	void LungeAttack();
	void EndAttack();
	void EndAttackMontage();
	void EndAttackDelay();

	UFUNCTION()
	void OnAttackMontageEnded(UAnimMontage* Montage, bool bInterrupted);

	UFUNCTION()
	void AttackCheck();

	void Power(float Value);
	void EndPower();
	void PickUpTrap();
	void EndPickUpTrapMontage();

	void SetKillerInteractLocation(AActor* MinOverlappingActor);
	void Interact(float Value);
	void EndInteract();

	void SetKillerActionInteractLocation(AActor* MinOverlappingActor);
	void ActionInteract();
	void EndVaultMontage();
	void EndLiftMontage();

	AActor* GetMinOverlappingActor();

public:
	void KnockOut();
	void EndKnockOut();

	void SetInteracting(bool state);
	bool IsInteracting() { return bInteracting; }

	void SetCarrying(bool state);
	bool IsCarrying() { return bCarrying; }

	void SetActionInteracting(bool state);
	bool IsActionInteracting() { return bActionInteracting; }

	void SetUsingPower(bool state);
	bool IsUsingPower() { return bUsingPower; }

private:
	UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = Camera, meta = (AllowPrivateAccess = "true"))
	class UCameraComponent* Camera;
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = light, meta = (AllowPrivateAccess = "true"))
	class USpotLightComponent* EyeLight;

	UPROPERTY()
	class UKillerAnimInstance* KillerAnimInstance;

	UPROPERTY(EditDefaultsOnly)
	TSubclassOf<class AWeapon> WeaponClass;
	UPROPERTY()
	AWeapon* Weapon;

	UPROPERTY(EditDefaultsOnly)
	TSubclassOf<class ABearTrap> BearTrapClass;
	UPROPERTY()
	ABearTrap* BearTrap;

	bool bCanAttack;
	bool bHoldingAttack;
	UPROPERTY(EditDefaultsOnly, Category = "Movement")
	bool bAttackDelay;
	UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = "Gameplay", meta = (AllowPrivateAccess = "true"))
	float MaxHoldingAttackProgress;
	UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = "Gameplay", meta = (AllowPrivateAccess = "true"))
	float HoldingAttackProgress;
	
	UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = "Gameplay", meta = (AllowPrivateAccess = "true"))
	int32 MaxPowerCount;
	UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = "Gameplay", meta = (AllowPrivateAccess = "true"))
	int32 PowerCount;
	UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = "Gameplay", meta = (AllowPrivateAccess = "true"))
	float PowerProgress;
	UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = "Gameplay", meta = (AllowPrivateAccess = "true"))
	float MaxPowerProgress;
	
	UPROPERTY(EditAnywhere, Category = "Movement")
	float WalkSpeed;
	UPROPERTY(EditAnywhere, Category = "Movement")
	float AttackDelaySpeed;
	UPROPERTY(EditAnywhere, Category = "Movement")
	float CarryingWalkSpeed;

	UPROPERTY(VisibleAnywhere, Category = "Movement")
	bool bAttacking;
	UPROPERTY(EditDefaultsOnly, Category = "Movement")
	bool bInteracting;
	UPROPERTY(EditDefaultsOnly, Category = "Movement")
	bool bCarrying;
	UPROPERTY(EditDefaultsOnly, Category = "Movement")
	bool bActionInteracting;
	UPROPERTY(EditDefaultsOnly, Category = "Movement")
	bool bUsingPower;

	TArray<AActor*> OverlappingActors;
	class AInteractiveActor* InteractingActor;
	FVector WindowPalletInteractMoveLocation;

	class ASurvivor* Survivor;

	class ADBDGameMode* DBDGameMode;
};

```

`Source/DeadByDaylight/KillerAnimInstance.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "KillerAnimInstance.h"
#include "GameFramework/Character.h"
#include "GameFramework/PawnMovementComponent.h"
#include "Killer.h"

UKillerAnimInstance::UKillerAnimInstance()
{

}

void UKillerAnimInstance::NativeUpdateAnimation(float DeltaSeconds)
{
	Super::NativeUpdateAnimation(DeltaSeconds);

	APawn* Pawn = TryGetPawnOwner();
	if (IsValid(Pawn))
	{
		Speed = Pawn->GetVelocity().Size();

		AKiller* Character = Cast<AKiller>(Pawn);

		bFalling = Character->GetMovementComponent()->IsFalling();
		bInteracting = Character->IsInteracting();
		bUsingPower = Character->IsUsingPower();
	}
}

float UKillerAnimInstance::PlayAttackMontage()
{
	if (!Montage_IsPlaying(AttackMontage))
	{
		return Montage_Play(AttackMontage, 1.0f);
	}
	else
	{
		return 0.0f;
	}
}

float UKillerAnimInstance::PlayVaultMontage()
{
	if (!Montage_IsPlaying(VaultMontage))
	{
		return Montage_Play(VaultMontage);
	}
	else
	{
		return 0.0f;
	}
}

float UKillerAnimInstance::PlayLiftMontage()
{
	if (!Montage_IsPlaying(LiftMontage))
	{
		return Montage_Play(LiftMontage);
	}
	else
	{
		return 0.0f;
	}
}

float UKillerAnimInstance::PlayKnockOutMontage()
{
	if (!Montage_IsPlaying(KnockOutMontage))
	{
		return Montage_Play(KnockOutMontage);
	}
	else
	{
		return 0.0f;
	}
}

float UKillerAnimInstance::PlayLiftTrapMontage()
{
	if (!Montage_IsPlaying(LiftTrapMontage))
	{
		return Montage_Play(LiftTrapMontage);
	}
	else
	{
		return 0.0f;
	}
}

// 몽타주에서 설정한 AttackHit
void UKillerAnimInstance::AnimNotify_AttackHit()
{
	OnAttackHit.Broadcast();
}

```

`Source/DeadByDaylight/KillerAnimInstance.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Animation/AnimInstance.h"
#include "KillerAnimInstance.generated.h"

DECLARE_MULTICAST_DELEGATE(FOnAttackHit);

/**
 * 
 */
UCLASS()
class DEADBYDAYLIGHT_API UKillerAnimInstance : public UAnimInstance
{
	GENERATED_BODY()

public:
	UKillerAnimInstance();

	virtual void NativeUpdateAnimation(float DeltaSeconds);

	float PlayAttackMontage();

	float PlayVaultMontage();

	float PlayLiftMontage();

	float PlayKnockOutMontage();

	float PlayLiftTrapMontage();

private:
	UFUNCTION()
	void AnimNotify_AttackHit();

private:
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Pawn, meta = (AllowPrivateAccess = "true"))
	float Speed;
	
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Pawn, meta = (AllowPrivateAccess = "true"))
	bool bFalling;
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Pawn, meta = (AllowPrivateAccess = "true"))
	bool bInteracting;
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Pawn, meta = (AllowPrivateAccess = "true"))
	bool bUsingPower;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Pawn, meta = (AllowPrivateAccess = "true"))
	UAnimMontage* AttackMontage;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Pawn, meta = (AllowPrivateAccess = "true"))
	UAnimMontage* VaultMontage;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Pawn, meta = (AllowPrivateAccess = "true"))
	UAnimMontage* LiftMontage;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Pawn, meta = (AllowPrivateAccess = "true"))
	UAnimMontage* KnockOutMontage;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Pawn, meta = (AllowPrivateAccess = "true"))
	UAnimMontage* LiftTrapMontage;

public:
	FOnAttackHit OnAttackHit;
};

```

`Source/DeadByDaylight/Pallet.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "Pallet.h"
#include "Components/BoxComponent.h"
#include "Killer.h"

APallet::APallet()
{
	BoxCollision = CreateDefaultSubobject<UBoxComponent>(TEXT("Box Collision"));
	BoxCollision->SetupAttachment(RootComponent);

	KillerStunCollision = CreateDefaultSubobject<UBoxComponent>(TEXT("Killer Stun Collision"));
	KillerStunCollision->SetupAttachment(RootComponent);
	KillerStunCollision->SetBoxExtent(FVector(250.0f, 200.0f, 200.0f));

	InteractCharacterLocation_0 = CreateDefaultSubobject<USceneComponent>(TEXT("Interact Character Location 0"));
	InteractCharacterLocations.Add(InteractCharacterLocation_0);
	InteractCharacterLocation_0->SetupAttachment(RootComponent);

	InteractCharacterLocation_1 = CreateDefaultSubobject<USceneComponent>(TEXT("Interact Character Location 1"));
	InteractCharacterLocations.Add(InteractCharacterLocation_1);
	InteractCharacterLocation_1->SetupAttachment(RootComponent);

	Mesh->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);

	BrokenProgress = 0.0f;
	MaxBrokenProgress = 1.1f;

	bUsed = false;
}

void APallet::BeginPlay()
{
	Super::BeginPlay();
}

void APallet::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

}

void APallet::Interact()
{
	Super::Interact();

	FHitResult HitResult;
	FCollisionQueryParams Params(NAME_None, false, this);
	FVector CollisionLocation = KillerStunCollision->GetComponentLocation();

	bool bResult = GetWorld()->SweepSingleByChannel(
		HitResult,
		CollisionLocation,
		CollisionLocation + FVector(0.0f, 0.0f, 0.001f),
		FQuat::Identity,
		ECollisionChannel::ECC_GameTraceChannel5,
		FCollisionShape::MakeBox(KillerStunCollision->GetScaledBoxExtent()),
		Params
	);

	FColor DrawColor;
	if (bResult)
	{
		UE_LOG(LogTemp, Warning, TEXT("Hit Actor : %s"), *HitResult.GetActor()->GetName());
		DrawColor = FColor::Green;
	}
	else
	{
		DrawColor = FColor::Red;
	}
	DrawDebugBox(GetWorld(), CollisionLocation, KillerStunCollision->GetScaledBoxExtent(), DrawColor, false, 20.0f);

	if (bResult && HitResult.GetActor())
	{
		if (HitResult.GetActor()->IsA(AKiller::StaticClass()))
		{
			AKiller* Killer = Cast<AKiller>(HitResult.GetActor());
			Killer->KnockOut();
		}
	}

	FRotator UsedPalletRotation = FRotator(GetActorRotation().Pitch, GetActorRotation().Yaw, 45.0f);
	Mesh->SetRelativeRotation(UsedPalletRotation);

	bUsed = true;
}


void APallet::KillerInteract()
{
	if (BrokenProgress < MaxBrokenProgress && bBroken == false)
	{
		Super::KillerInteract();
		BrokenProgress += FApp::GetDeltaTime() * 1.0f;
	}
	else if (bBroken != true)
	{
		UE_LOG(LogTemp, Warning, TEXT("Broken"));
		BrokenProgress = 0.0f;
		bBroken = true;
		Destroy();
	}
}

void APallet::KillerEndInteract()
{
	BrokenProgress = 0.0f;
}

```

`Source/DeadByDaylight/Pallet.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "InteractiveActor.h"
#include "Pallet.generated.h"

/**
 * 
 */
UCLASS()
class DEADBYDAYLIGHT_API APallet : public AInteractiveActor
{
	GENERATED_BODY()

public:
	// Sets default values for this actor's properties
	APallet();

protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;

public:
	virtual void Tick(float DeltaTime) override;

	virtual void Interact() override;

	virtual void KillerInteract() override;
	virtual void KillerEndInteract() override;

	bool IsUsed() { return bUsed; }

private:
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Coponents", meta = (AllowPrivateAccess = "true"))
	class UBoxComponent* BoxCollision;

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Coponents", meta = (AllowPrivateAccess = "true"))
	class UBoxComponent* KillerStunCollision;

	UPROPERTY(EditAnywhere, Category = "Coponents", meta = (AllowPrivateAccess = "true"))
	USceneComponent* InteractCharacterLocation_0;
	UPROPERTY(EditAnywhere, Category = "Coponents", meta = (AllowPrivateAccess = "true"))
	USceneComponent* InteractCharacterLocation_1;
	
	UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = "Gameplay", meta = (AllowPrivateAccess = "true"))
	float BrokenProgress;
	UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = "Gameplay", meta = (AllowPrivateAccess = "true"))
	float MaxBrokenProgress;

	bool bUsed;
};

```

`Source/DeadByDaylight/Survivor.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "Survivor.h"
#include "GameFramework/SpringArmComponent.h"
#include "Camera/CameraComponent.h"
#include "GameFramework/CharacterMovementComponent.h"
#include "Components/CapsuleComponent.h"
#include "Components/SphereComponent.h"
#include "Math/UnrealMathUtility.h"
#include "InteractiveActor.h"
#include "Window.h"
#include "Pallet.h"
#include "Hook.h"
#include "Generator.h"
#include "ExitDoor.h"
#include "BearTrap.h"
#include "SurvivorStatComponent.h"
#include "SurvivorAnimInstance.h"

// Sets default values
ASurvivor::ASurvivor()
{
	// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;

	// Set size for collision capsule
	GetCapsuleComponent()->InitCapsuleSize(55.0f, 200.0f);

	// Don't rotate when the controller rotates. Let that just affect the camera.
	bUseControllerRotationPitch = false;
	bUseControllerRotationYaw = false;
	bUseControllerRotationRoll = false;

	// Configure character movement
	GetCharacterMovement()->bOrientRotationToMovement = true; // Character moves in the direction of input...	
	GetCharacterMovement()->RotationRate = FRotator(0.0f, 500.0f, 0.0f); // ...at this rotation rate

	// Note: For faster iteration times these variables, and many more, can be tweaked in the Character Blueprint
	// instead of recompiling to adjust them
	GetCharacterMovement()->JumpZVelocity = 700.f;
	GetCharacterMovement()->AirControl = 0.35f;
	GetCharacterMovement()->MinAnalogWalkSpeed = 20.f;
	GetCharacterMovement()->BrakingDecelerationWalking = 2000.f;

	// Create a camera boom (pulls in towards the player if there is a collision)
	CameraBoom = CreateDefaultSubobject<USpringArmComponent>(TEXT("CameraBoom"));
	CameraBoom->SetupAttachment(RootComponent);
	CameraBoom->TargetArmLength = 400.0f; // The camera follows at this distance behind the character	
	CameraBoom->SetRelativeLocation(FVector(0, 0, 80.0f));
	CameraBoom->bUsePawnControlRotation = true; // Rotate the arm based on the controller

	// Create a follow camera
	FollowCamera = CreateDefaultSubobject<UCameraComponent>(TEXT("FollowCamera"));
	FollowCamera->SetupAttachment(CameraBoom, USpringArmComponent::SocketName); // Attach the camera to the end of the boom and let the boom adjust to match the controller orientation
	FollowCamera->bUsePawnControlRotation = false; // Camera does not rotate relative to arm

	// Note: The skeletal mesh and anim blueprint references on the Mesh component (inherited from Character) 
	// are set in the derived blueprint asset named ThirdPersonCharacter (to avoid direct content references in C++)

	Stat = CreateDefaultSubobject<USurvivorStatComponent>(TEXT("Stat"));

	SphereCollision = CreateDefaultSubobject<USphereComponent>(TEXT("Sphere Collision"));
	SphereCollision->SetupAttachment(RootComponent);

	bRunning = false;
	bCarried = false;
	bHanged = false;
	bTraped = false;
}

// Called when the game starts or when spawned
void ASurvivor::BeginPlay()
{
	Super::BeginPlay();

	Hp = Stat->GetHp();
	
	WalkSpeed = Stat->GetWalkSpeed();
	RunSpeed = Stat->GetRunSpeed();
	CrawlSpeed = Stat->GetCrawlSpeed();
	GetCharacterMovement()->MaxWalkSpeed = WalkSpeed;
	GetCharacterMovement()->NavAgentProps.bCanCrouch = true;
	GetCharacterMovement()->SetCrouchedHalfHeight(200.0f);

	// Hp 2인 상태로 시작
	FDamageEvent DamageEvent;
	TakeDamage(1.0f, DamageEvent, GetController(), this);
}

void ASurvivor::PostInitializeComponents()
{
	Super::PostInitializeComponents();

	SurvivorAnimInstance = Cast<USurvivorAnimInstance>(GetMesh()->GetAnimInstance());

}

// Called every frame
void ASurvivor::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);
}

// Called to bind functionality to input
void ASurvivor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)
{
	Super::SetupPlayerInputComponent(PlayerInputComponent);

	// Set up gameplay key bindings
	check(PlayerInputComponent);

	PlayerInputComponent->BindAxis("Move Forward / Backward", this, &ASurvivor::MoveForward);
	PlayerInputComponent->BindAxis("Move Right / Left", this, &ASurvivor::MoveRight);

	// "turn" handles devices that provide an absolute delta, such as a mouse.
	PlayerInputComponent->BindAxis("Turn Right / Left Mouse", this, &APawn::AddControllerYawInput);
	PlayerInputComponent->BindAxis("Look Up / Down Mouse", this, &APawn::AddControllerPitchInput);

	PlayerInputComponent->BindAxis(TEXT("Interact"), this, &ASurvivor::Interact);
	PlayerInputComponent->BindAction(TEXT("Interact"), EInputEvent::IE_Released, this, &ASurvivor::EndInteract);

	PlayerInputComponent->BindAction(TEXT("StartRun"), EInputEvent::IE_Pressed, this, &ASurvivor::StartRun);
	PlayerInputComponent->BindAction(TEXT("StartRun"), EInputEvent::IE_Released, this, &ASurvivor::StopRun);

	PlayerInputComponent->BindAction(TEXT("Crouch"), EInputEvent::IE_Pressed, this, &ASurvivor::CrouchStart);
	PlayerInputComponent->BindAction(TEXT("Crouch"), EInputEvent::IE_Released, this, &ASurvivor::CrouchEnd);

	PlayerInputComponent->BindAction(TEXT("Action Interact"), EInputEvent::IE_Pressed, this, &ASurvivor::ActionInteract);
}

void ASurvivor::MoveForward(float Value)
{
	if ((Controller != nullptr) && (Value != 0.0f))
	{
		// find out which way is forward
		const FRotator Rotation = Controller->GetControlRotation();
		const FRotator YawRotation(0, Rotation.Yaw, 0);

		// get forward vector
		const FVector Direction = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::X);
		AddMovementInput(Direction, Value);
	}
}

void ASurvivor::MoveRight(float Value)
{
	if ((Controller != nullptr) && (Value != 0.0f))
	{
		// find out which way is right
		const FRotator Rotation = Controller->GetControlRotation();
		const FRotator YawRotation(0, Rotation.Yaw, 0);

		// get right vector 
		const FVector Direction = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::Y);
		// add movement in that direction
		AddMovementInput(Direction, Value);
	}
}

void ASurvivor::StartRun()
{
	if (Hp > 1)
	{
		bRunning = true;
		GetCharacterMovement()->MaxWalkSpeed = RunSpeed;
	}
}

void ASurvivor::StopRun()
{
	if (Hp > 1)
	{
		bRunning = false;
		GetCharacterMovement()->MaxWalkSpeed = WalkSpeed;
	}
}

void ASurvivor::CrouchStart()
{
	Crouch();
}

void ASurvivor::CrouchEnd()
{
	UnCrouch();
}

void ASurvivor::RecoverHp()
{
	Hp++;
	if (Hp > 1)
	{
		GetCharacterMovement()->MaxWalkSpeed = WalkSpeed;
	}
}

float ASurvivor::TakeDamage(float DamageAmount, FDamageEvent const& DamageEvent, AController* EventInstigator, AActor* DamageCauser)
{
	// Stat에서 Survivor의 상태를 변경
	Stat->OnAttacked(DamageAmount);

	Hp = Stat->GetHp();
	if (Hp == 1)
	{
		GetCharacterMovement()->MaxWalkSpeed = CrawlSpeed;
	}

	return DamageAmount;
}


void ASurvivor::SetCarried(bool state)
{
	bCarried = state;
	if (state == true)
	{
		GetCapsuleComponent()->SetGenerateOverlapEvents(false);
		SphereCollision->SetGenerateOverlapEvents(false);

		GetController()->SetIgnoreMoveInput(true);
	}
	else if (state == false)
	{
		GetCapsuleComponent()->SetGenerateOverlapEvents(true);
		SphereCollision->SetGenerateOverlapEvents(true);

		GetController()->ResetIgnoreInputFlags();
	}
}

void ASurvivor::SetHanged(bool state)
{
	bHanged = state;
	if (state == true)
	{
		Stat->IncreaseHangedCount();

		GetController()->SetIgnoreMoveInput(true);
	}
	else if (state == false)
	{
		Stat->ResetHangingTime();

		GetController()->ResetIgnoreInputFlags();
	}
}

void ASurvivor::SetTraped(bool state)
{
	bTraped = state;
	if (state == true)
	{
		Stat->OnTrapped();
		Hp = Stat->GetHp();

		GetController()->SetIgnoreMoveInput(true);
	}
	else if (state == false)
	{
		GetController()->ResetIgnoreInputFlags();
	}
}


void ASurvivor::Interact(float Value)
{
	// Survivor와 Overlap된 Actor들 중에서 가장 가까운 Actors에 Interact
	GetOverlappingActors(OverlappingActors);

	if ((Controller != nullptr) && (Value != 0.0f))
	{
		AActor* MinOverlappingActor = GetMinOverlappingActor();

		// 발전기, 출구
		if (MinOverlappingActor && (MinOverlappingActor->IsA(AGenerator::StaticClass()) || MinOverlappingActor->IsA(AExitDoor::StaticClass())) && Hp >= 2)
		{
			InteractingActor = Cast<AInteractiveActor>(MinOverlappingActor);
			if (InteractingActor)
			{
				InteractingActor->Interact();
			}

			SetSurvivorInteractLocation(MinOverlappingActor);

			bInteracting = true;
		}
		// 생존자 치료
		else if (MinOverlappingActor && MinOverlappingActor->IsA(ASurvivor::StaticClass()) && Hp >= 2)
		{
			ASurvivor* WoundedSurvivor = Cast<ASurvivor>(MinOverlappingActor);

			if (WoundedSurvivor->Stat->GetHp() <= 2 && !WoundedSurvivor->IsHanged())
			{
				WoundedSurvivor->Stat->Recover();

				GetCharacterMovement()->StopMovementImmediately();
				FVector ToTarget = WoundedSurvivor->GetActorLocation() - GetActorLocation();
				FRotator LookAtRotation = FRotator(0.0f, ToTarget.Rotation().Yaw, 0.0f);
				SetActorRotation(LookAtRotation);

				bInteracting = true;
			}
		}
		// 갈고리
		else if (MinOverlappingActor && MinOverlappingActor->IsA(AHook::StaticClass()) && Hp >= 2)
		{
			InteractingActor = Cast<AInteractiveActor>(MinOverlappingActor);
			AHook* Hook = Cast<AHook>(MinOverlappingActor);
			if (Hook && Hook->IsHanging())
			{
				Hook->Interact();

				GetCharacterMovement()->StopMovementImmediately();
				FVector ToTarget = InteractingActor->GetActorLocation() - GetActorLocation();
				FRotator LookAtRotation = FRotator(0.0f, ToTarget.Rotation().Yaw, 0.0f);
				SetActorRotation(LookAtRotation);

				bInteracting = true;
			}
		}
		// 덫
		else if (MinOverlappingActor && MinOverlappingActor->IsA(ABearTrap::StaticClass()))
		{
			ABearTrap* BearTrap = Cast<ABearTrap>(MinOverlappingActor);
			if (bTraped)
			{
				if (BearTrap && BearTrap->IsTraping())
				{
					BearTrap->Interact();
				}
			}
			else
			{
				if (BearTrap && !BearTrap->IsTraping() && !BearTrap->IsUsed())
				{
					BearTrap->Interact();

					bInteracting = true;
				}
			}
		}
	}
}

void ASurvivor::EndInteract()
{
	if (InteractingActor)
	{
		if (InteractingActor->IsA(AHook::StaticClass()))
		{
			InteractingActor->EndInteract();
			InteractingActor = nullptr;
		}
		else if (InteractingActor->IsA(ABearTrap::StaticClass()))
		{
			ABearTrap* BearTrap = Cast<ABearTrap>(InteractingActor);
			if (BearTrap)
			{
				BearTrap->EndInteract();
				InteractingActor = nullptr;
			}
		}
	}

	bInteracting = false;
}


void ASurvivor::ActionInteract()
{
	GetOverlappingActors(OverlappingActors);
	if (Controller != nullptr)
	{
		AActor* MinOverlappingActor = GetMinOverlappingActor();

		// 창틀
		if (MinOverlappingActor && MinOverlappingActor->IsA(AWindow::StaticClass()) && Hp >= 2)
		{
			SetSurvivorActionInteractLocation(MinOverlappingActor);

			FTimerHandle VaultTimerHandle;
			float VaultMontageDelay = SurvivorAnimInstance->PlayVaultMontage() - 0.2f;
			GetWorld()->GetTimerManager().SetTimer(VaultTimerHandle, this, &ASurvivor::EndActionInteractMontage, VaultMontageDelay);
		}
		// 판자
		else if (MinOverlappingActor && MinOverlappingActor->IsA(APallet::StaticClass()) && Hp >= 2)
		{
			APallet* Pallet = Cast<APallet>(MinOverlappingActor);
			if (Pallet->IsUsed())
			{
				SetSurvivorActionInteractLocation(MinOverlappingActor);

				FTimerHandle VaultTimerHandle;
				float VaultMontageDelay = SurvivorAnimInstance->PlayVaultMontage() - 0.2f;
				GetWorld()->GetTimerManager().SetTimer(VaultTimerHandle, this, &ASurvivor::EndActionInteractMontage, VaultMontageDelay);
			}
			else
			{
				SetSurvivorActionInteractLocation(MinOverlappingActor);

				Pallet->Interact();

				FTimerHandle PullDownTimerHandle;
				float PullDownMontageDelay = SurvivorAnimInstance->PlayPullDownMontage() - 0.2f;
				GetWorld()->GetTimerManager().SetTimer(PullDownTimerHandle, this, &ASurvivor::EndActionInteractMontage, PullDownMontageDelay);
			}
		}
	}
}

void ASurvivor::EndActionInteractMontage()
{
	InteractingActor = nullptr;

	SetActorLocation(WindowPalletInteractMoveLocation);


	GetController()->ResetIgnoreInputFlags();

	WindowPalletInteractMoveLocation = GetActorLocation();

	// GetCapsuleComponent()->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);
	// GetCharacterMovement()->SetMovementMode(EMovementMode::MOVE_Walking);
}


// 상호작용 시 생존자와 Overlap중인 가장 가까운 Actor를 반환
AActor* ASurvivor::GetMinOverlappingActor()
{
	// 가장 가까운 InteractingActor
	AActor* MinOverlappingActor = nullptr;
	float MinDistance = 5000.0f;

	if (!OverlappingActors.IsEmpty())
	{
		for (AActor* OverlappingActor : OverlappingActors)
		{
			float ActorDistance = FVector::Dist(GetActorLocation(), OverlappingActor->GetActorLocation());
			if (MinDistance > ActorDistance)
			{
				MinDistance = ActorDistance;
				MinOverlappingActor = OverlappingActor;
			}
		}
	}

	return MinOverlappingActor;
}

// 생존자가 발전기, 출구와 상호작용했을 경우의 Location과 Rotation설정
void ASurvivor::SetSurvivorInteractLocation(AActor* MinOverlappingActor)
{
	InteractingActor = Cast<AInteractiveActor>(MinOverlappingActor);

	// Interact시 Survivor의 위치를 고정
	USceneComponent* InteractLocation = nullptr;
	float MinInteractDistance = 1000.0f;
	if (!InteractLocation)
	{
		for (USceneComponent* InteractCharacterLocation : InteractingActor->InteractCharacterLocations)
		{
			float LocationDistance = FVector::Dist(GetActorLocation(), InteractCharacterLocation->GetComponentLocation());
			if (MinInteractDistance >= LocationDistance)
			{
				MinInteractDistance = LocationDistance;
				InteractLocation = InteractCharacterLocation;
			}
		}
	}

	SetActorLocation(FVector(InteractLocation->GetComponentLocation().X, InteractLocation->GetComponentLocation().Y, GetActorLocation().Z));

	FVector ToTarget = InteractingActor->GetActorLocation() - GetActorLocation();
	FRotator LookAtRotation = FRotator(0.0f, ToTarget.Rotation().Yaw, 0.0f);
	SetActorRotation(LookAtRotation);
}

// 생존자가 창틀, 판자와 상호작용했을 경우의 Location과 Rotation설정
void ASurvivor::SetSurvivorActionInteractLocation(AActor* MinOverlappingActor)
{
	InteractingActor = Cast<AInteractiveActor>(MinOverlappingActor);

	USceneComponent* MaxDistanceLocation = nullptr;
	USceneComponent* MinDistanceLocation = nullptr;
	float MaxInteractDistance = 0.0f;
	float MinInteractDistance = 1000.0f;
	for (USceneComponent* InteractCharacterLocation : InteractingActor->InteractCharacterLocations)
	{
		float LocationDistance = FVector::Dist(GetActorLocation(), InteractCharacterLocation->GetComponentLocation());
		if (MaxInteractDistance <= LocationDistance)
		{
			MaxInteractDistance = LocationDistance;
			MaxDistanceLocation = InteractCharacterLocation;
		}
		if (MinInteractDistance >= LocationDistance)
		{
			MinInteractDistance = LocationDistance;
			MinDistanceLocation = InteractCharacterLocation;
		}
	}

	// GetCharacterMovement()->SetMovementMode(EMovementMode::MOVE_Flying);
	// GetCapsuleComponent()->SetCollisionEnabled(ECollisionEnabled::NoCollision);
	SetActorLocation(FVector(MinDistanceLocation->GetComponentLocation().X, MinDistanceLocation->GetComponentLocation().Y, GetActorLocation().Z));

	FVector ToTarget = MaxDistanceLocation->GetComponentLocation() - MinDistanceLocation->GetComponentLocation();
	FRotator LookAtRotation = FRotator(0.0f, ToTarget.Rotation().Yaw, 0.0f);
	SetActorRotation(LookAtRotation);

	GetCharacterMovement()->StopMovementImmediately();
	GetController()->SetIgnoreMoveInput(true);

	if (InteractingActor->IsA(APallet::StaticClass()))
	{
		APallet* Pallet = Cast<APallet>(InteractingActor);
		if (Pallet->IsUsed())
		{
			WindowPalletInteractMoveLocation = FVector(MaxDistanceLocation->GetComponentLocation().X, MaxDistanceLocation->GetComponentLocation().Y, GetActorLocation().Z);
		}
		else
		{
			WindowPalletInteractMoveLocation = FVector(MinDistanceLocation->GetComponentLocation().X, MinDistanceLocation->GetComponentLocation().Y, GetActorLocation().Z);
		}
	}
	else
	{
		WindowPalletInteractMoveLocation = FVector(MaxDistanceLocation->GetComponentLocation().X, MaxDistanceLocation->GetComponentLocation().Y, GetActorLocation().Z);
	}

}
```

`Source/DeadByDaylight/Survivor.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Character.h"
#include "Survivor.generated.h"


UCLASS()
class DEADBYDAYLIGHT_API ASurvivor : public ACharacter
{
	GENERATED_BODY()

public:
	ASurvivor();

protected:
	virtual void BeginPlay() override;
	virtual void PostInitializeComponents() override;

public:
	virtual void Tick(float DeltaTime) override;

	bool IsRunning() { return bRunning; };
	bool IsInteracting() { return bInteracting; };

	void SetCarried(bool state);
	bool IsCarried() { return bCarried; }

	void SetHanged(bool state);
	bool IsHanged() { return bHanged; }

	void SetTraped(bool state);
	bool IsTraped() { return bTraped; }

protected:
	void MoveForward(float Value);
	void MoveRight(float Value);

	void StartRun();
	void StopRun();

	void CrouchStart();
	void CrouchEnd();

	void SetSurvivorInteractLocation(AActor* MinOverlappingActor);
	void Interact(float Value);
	void EndInteract();

	void SetSurvivorActionInteractLocation(AActor* MinOverlappingActor);
	void ActionInteract();
	void EndActionInteractMontage();

	AActor* GetMinOverlappingActor();

protected:
	// APawn interface
	virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;
	// End of APawn interface

public:
	/** Returns CameraBoom subobject **/
	FORCEINLINE class USpringArmComponent* GetCameraBoom() const { return CameraBoom; }
	/** Returns FollowCamera subobject **/
	FORCEINLINE class UCameraComponent* GetFollowCamera() const { return FollowCamera; }

	class USurvivorStatComponent* GetStat() { return Stat; }

	int32 GetHp() { return Hp; }
	void RecoverHp();

	virtual float TakeDamage(float DamageAmount, FDamageEvent const& DamageEvent, AController* EventInstigator, AActor* DamageCauser) override;

private:
	/** Camera boom positioning the camera behind the character */
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = "true"))
	class USpringArmComponent* CameraBoom;
	/** Follow camera */
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = "true"))
	class UCameraComponent* FollowCamera;

	// 생존자 치료 가능 범위
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Coponents", meta = (AllowPrivateAccess = "true"))
	class USphereComponent* SphereCollision;

	UPROPERTY()
	class USurvivorAnimInstance* SurvivorAnimInstance;

	UPROPERTY(VisibleAnywhere)
	USurvivorStatComponent* Stat;
	UPROPERTY(VisibleAnywhere, Category = Stat, Meta = (AllowPrivateAccess = true))
	int32 Hp;

	UPROPERTY(EditAnywhere, Category = "Movement")
	float WalkSpeed;
	UPROPERTY(EditAnywhere, Category = "Movement")
	float RunSpeed;
	UPROPERTY(EditAnywhere, Category = "Movement")
	float CrawlSpeed;

	UPROPERTY(EditDefaultsOnly, Category = "Movement")
	bool bRunning;
	UPROPERTY(EditDefaultsOnly, Category = "Movement")
	bool bInteracting;
	UPROPERTY(EditDefaultsOnly, Category = "Movement")
	bool bCarried;
	UPROPERTY(EditDefaultsOnly, Category = "Movement")
	bool bHanged;
	UPROPERTY(EditDefaultsOnly, Category = "Movement")
	bool bTraped;

	TArray<AActor*> OverlappingActors;
	class AInteractiveActor* InteractingActor;
	FVector WindowPalletInteractMoveLocation;

};

```

`Source/DeadByDaylight/SurvivorAnimInstance.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "SurvivorAnimInstance.h"
#include "GameFramework/Character.h"
#include "GameFramework/PawnMovementComponent.h"
#include "GameFramework/CharacterMovementComponent.h"
#include "Survivor.h"

USurvivorAnimInstance::USurvivorAnimInstance()
{
	bRunning = false;
	bInjured = false;
	bSeriousInjured = false;
	bInteracting = false;
	bCarried = false;
	bHanged = false;
	bTraped = false;
}

void USurvivorAnimInstance::NativeUpdateAnimation(float DeltaSeconds)
{
	Super::NativeUpdateAnimation(DeltaSeconds);

	APawn* Pawn = TryGetPawnOwner();
	if (IsValid(Pawn))
	{
		Speed = Pawn->GetVelocity().Size();

		ASurvivor* Character = Cast<ASurvivor>(Pawn);

		bFalling = Character->GetMovementComponent()->IsFalling();
		bCrouching = Character->GetMovementComponent()->IsCrouching();
		bRunning = Character->IsRunning();
		bInteracting = Character->IsInteracting();
		bCarried = Character->IsCarried();
		bHanged = Character->IsHanged();
		bTraped = Character->IsTraped();

		if (Character->GetHp() == 3)
		{
			bInjured = false;
			bSeriousInjured = false;
		}
		if (Character->GetHp() == 2)
		{
			bInjured = true;
			bSeriousInjured = false;
		}
		else if (Character->GetHp() == 1)
		{
			bInjured = true;
			bSeriousInjured = true;
		}
	}
}

float USurvivorAnimInstance::PlayVaultMontage()
{
	if (!Montage_IsPlaying(VaultMontage))
	{
		return Montage_Play(VaultMontage);
	}
	else
	{
		return 0.0f;
	}
}

float USurvivorAnimInstance::PlayPullDownMontage()
{
	if (!Montage_IsPlaying(PullDownMontage))
	{
		return Montage_Play(PullDownMontage);
	}
	else
	{
		return 0.0f;
	}
}

```

`Source/DeadByDaylight/SurvivorAnimInstance.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Animation/AnimInstance.h"
#include "SurvivorAnimInstance.generated.h"

/**
 * 
 */
UCLASS()
class DEADBYDAYLIGHT_API USurvivorAnimInstance : public UAnimInstance
{
	GENERATED_BODY()

public:
	USurvivorAnimInstance();

	virtual void NativeUpdateAnimation(float DeltaSeconds);

	float PlayVaultMontage();

	float PlayPullDownMontage();
	
private:
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Pawn, meta = (AllowPrivateAccess = "true"))
	float Speed;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Pawn, meta = (AllowPrivateAccess = "true"))
	bool bFalling;
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Pawn, meta = (AllowPrivateAccess = "true"))
	bool bRunning;
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Pawn, meta = (AllowPrivateAccess = "true"))
	bool bCrouching;
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Pawn, meta = (AllowPrivateAccess = "true"))
	bool bInjured;
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Pawn, meta = (AllowPrivateAccess = "true"))
	bool bSeriousInjured;
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Pawn, meta = (AllowPrivateAccess = "true"))
	bool bInteracting;
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Pawn, meta = (AllowPrivateAccess = "true"))
	bool bCarried;
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Pawn, meta = (AllowPrivateAccess = "true"))
	bool bHanged;
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Pawn, meta = (AllowPrivateAccess = "true"))
	bool bTraped;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Pawn, meta = (AllowPrivateAccess = "true"))
	UAnimMontage* VaultMontage;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Pawn, meta = (AllowPrivateAccess = "true"))
	UAnimMontage* PullDownMontage;
};

```

`Source/DeadByDaylight/SurvivorStatComponent.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "SurvivorStatComponent.h"
#include "DBDGameInstance.h"
#include "Kismet/GameplayStatics.h"
#include "Engine/DecalActor.h"
#include "Components/DecalComponent.h"
#include "TimerManager.h"
#include "Survivor.h"

// Sets default values for this component's properties
USurvivorStatComponent::USurvivorStatComponent()
{
	// Set this component to be initialized when the game starts, and to be ticked every frame.  You can turn these features
	// off to improve performance if you don't need them.

	// ...
	bWantsInitializeComponent = true;

	Hp = 3;

	MaxRecoverProgress = 2.0f;
	RecoverProgress = 0.0f;

	MaxHangingTime = 5.0f;
	HangingTime = 0.0f;

	BloodRate = 1.0f;
}


// Called when the game starts
void USurvivorStatComponent::BeginPlay()
{
	Super::BeginPlay();

	PrimaryComponentTick.Target = this;
	PrimaryComponentTick.bCanEverTick = true;
	PrimaryComponentTick.SetTickFunctionEnable(true);
	PrimaryComponentTick.RegisterTickFunction(GetComponentLevel());

	// ...
	SetMaxHp(Hp);

	GetWorld()->GetTimerManager().SetTimer(BloodTimerHandle, this, &USurvivorStatComponent::SpawnBloodDecalActor, BloodRate, true, BloodRate);
	PauseBloodTimerHandle();
}

void USurvivorStatComponent::InitializeComponent()
{
	Super::InitializeComponent();

	Survivor = Cast<ASurvivor>(GetOwner());
}

void USurvivorStatComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)
{
	Super::TickComponent(DeltaTime, TickType, ThisTickFunction);

	if (Survivor->IsHanged())
	{
		IncreaseHangingTime();
	}
	if (Hp < 3)
	{
		float SurvivorSpeed = Survivor->GetVelocity().Size();
		if (SurvivorSpeed > 0.0f)
		{
			UnPauseBloodTimerHandle();
		}
		else if (SurvivorSpeed == 0.0f)
		{
			PauseBloodTimerHandle();
		}
	}
}

void USurvivorStatComponent::SetMaxHp(int32 MaxHp)
{
	auto DBDGameInstance = Cast<UDBDGameInstance>(UGameplayStatics::GetGameInstance(GetWorld()));
	if (DBDGameInstance)
	{		
		auto StatData = DBDGameInstance->GetSurvivorData(Hp);
		if (StatData)
		{
			Hp = StatData->MaxHp;
			WalkSpeed = StatData->WalkSpeed;
			RunSpeed = StatData->RunSpeed;
			CrawlSpeed = StatData->CrawlSpeed;
			HangedCount = StatData->HangedCount;
		}
	}
}

void USurvivorStatComponent::OnAttacked(float DamageAmount)
{
	Hp -= DamageAmount;
	if (Hp <= 1)
	{
		Hp = 1;
	}

	UE_LOG(LogTemp, Warning, TEXT("OnAttacked %d"), Hp);
}

void USurvivorStatComponent::OnTrapped()
{
	if (Hp > 2)
	{
		OnAttacked(1);
	}

	UE_LOG(LogTemp, Warning, TEXT("OnTrapped %d"), Hp);
}

void USurvivorStatComponent::Recover()
{
	if (RecoverProgress < MaxRecoverProgress && !bRecovered)
	{
		RecoverProgress += FApp::GetDeltaTime() * 1.0f;
	}
	else if (Hp < 3)
	{
		Hp++;
		RecoverProgress = 0.0f;

		if (Hp == 3)
		{
			PauseBloodTimerHandle();
		}

		ASurvivor* Owner = Cast<ASurvivor>(GetOwner());
		Owner->RecoverHp();
	}
}

void USurvivorStatComponent::IncreaseHangingTime()
{
	// 말리기 처리
	if (HangingTime < MaxHangingTime && HangedCount < 3)
	{
		HangingTime += FApp::GetDeltaTime() * 1.0f;
	}
	else if (HangedCount < 3)
	{
		IncreaseHangedCount();
		HangingTime = 0.0f;
	}
}

int32 USurvivorStatComponent::IncreaseHangedCount()
{
	HangedCount++;

	UE_LOG(LogTemp, Warning, TEXT("Hanged Count is %d"), HangedCount);

	if (HangedCount >= 3)
	{
		HangedCount = 3;
		Hp = 0;

		Survivor->Destroy();
		
		return HangedCount;
	}

	return HangedCount;
}

void USurvivorStatComponent::SpawnBloodDecalActor()
{
	FVector DecalSpawnLocation = FVector(Survivor->GetActorLocation().X, Survivor->GetActorLocation().Y, 0.0f);
	FRotator DecalSpawnRotation = FRotator(0.0f, 0.0f, Survivor->GetActorRotation().Yaw);
	BloodDecal = GetWorld()->SpawnActor<ADecalActor>(DecalSpawnLocation, DecalSpawnRotation);
	if (BloodDecal != nullptr)
	{
		BloodDecal->SetDecalMaterial(BloodDecalMaterial);
		BloodDecal->SetLifeSpan(3.5f);
		BloodDecal->GetDecal()->DecalSize = FVector(120.0f, 120.0f, 120.0f);
	}
}

void USurvivorStatComponent::PauseBloodTimerHandle()
{
	GetWorld()->GetTimerManager().PauseTimer(BloodTimerHandle);
}

void USurvivorStatComponent::UnPauseBloodTimerHandle()
{
	GetWorld()->GetTimerManager().UnPauseTimer(BloodTimerHandle);
}

```

`Source/DeadByDaylight/SurvivorStatComponent.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Components/ActorComponent.h"
#include "SurvivorStatComponent.generated.h"


UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )
class DEADBYDAYLIGHT_API USurvivorStatComponent : public UActorComponent
{
	GENERATED_BODY()

public:
	// Sets default values for this component's properties
	USurvivorStatComponent();

protected:
	// Called when the game starts
	virtual void BeginPlay() override;
	virtual void InitializeComponent() override;

public:
	virtual void TickComponent(float DeltaTime, enum ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;

public:
	void SetMaxHp(int32 MaxHp);
	void OnAttacked(float DamageAmount);

	void OnTrapped();

	int32 GetHp() { return Hp; }
	float GetWalkSpeed() { return WalkSpeed; }
	float GetRunSpeed() { return RunSpeed; }
	float GetCrawlSpeed() { return CrawlSpeed; }

	void Recover();

	void IncreaseHangingTime();
	void ResetHangingTime() { HangingTime = 0.0f; };

	int32 IncreaseHangedCount();

	void SpawnBloodDecalActor();
	void PauseBloodTimerHandle();
	void UnPauseBloodTimerHandle();

private:
	UPROPERTY(VisibleAnywhere, Category = Stat, Meta = (AllowPrivateAccess = true))
	int32 Hp;

	UPROPERTY(VisibleAnywhere, Category = Stat, Meta = (AllowPrivateAccess = true))
	float WalkSpeed;
	UPROPERTY(VisibleAnywhere, Category = Stat, Meta = (AllowPrivateAccess = true))
	float RunSpeed;
	UPROPERTY(VisibleAnywhere, Category = Stat, Meta = (AllowPrivateAccess = true))
	float CrawlSpeed;

	UPROPERTY(VisibleAnywhere, Category = Stat, Meta = (AllowPrivateAccess = true))
	int32 HangedCount;

	UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = Stat, meta = (AllowPrivateAccess = "true"))
	float MaxRecoverProgress;
	UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = Stat, meta = (AllowPrivateAccess = "true"))
	float RecoverProgress;
	bool bRecovered;

	UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = Stat, meta = (AllowPrivateAccess = "true"))
	float MaxHangingTime;
	UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = Stat, meta = (AllowPrivateAccess = "true"))
	float HangingTime;

	FTimerHandle BloodTimerHandle;
	float BloodRate;
	// 새로 파서 size를 tick에서 처리
	class ADecalActor* BloodDecal;
	UPROPERTY(EditAnywhere, Category = Decal, meta = (AllowPrivateAccess = "true"))
	UMaterialInterface* BloodDecalMaterial;

	class ASurvivor* Survivor;
};

```

`Source/DeadByDaylight/Weapon.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "Weapon.h"

// Sets default values
AWeapon::AWeapon()
{
 	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;

	Mesh = CreateDefaultSubobject<USkeletalMeshComponent>(TEXT("Mesh"));
	Mesh->SetupAttachment(RootComponent);

}

// Called when the game starts or when spawned
void AWeapon::BeginPlay()
{
	Super::BeginPlay();
	
}

// Called every frame
void AWeapon::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

}


```

`Source/DeadByDaylight/Weapon.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "Weapon.generated.h"

UCLASS()
class DEADBYDAYLIGHT_API AWeapon : public AActor
{
	GENERATED_BODY()
	
public:	
	// Sets default values for this actor's properties
	AWeapon();

protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;

public:	
	// Called every frame
	virtual void Tick(float DeltaTime) override;

private:
	UPROPERTY(VisibleAnywhere)
	USkeletalMeshComponent* Mesh;

};

```

`Source/DeadByDaylight/Window.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "Window.h"
#include "Components/BoxComponent.h"

AWindow::AWindow()
{
	BoxCollision = CreateDefaultSubobject<UBoxComponent>(TEXT("Box Collision"));
	BoxCollision->SetupAttachment(RootComponent);

	InteractCharacterLocation_0 = CreateDefaultSubobject<USceneComponent>(TEXT("Interact Character Location 0"));
	InteractCharacterLocations.Add(InteractCharacterLocation_0);
	InteractCharacterLocation_0->SetupAttachment(RootComponent);

	InteractCharacterLocation_1 = CreateDefaultSubobject<USceneComponent>(TEXT("Interact Character Location 1"));
	InteractCharacterLocations.Add(InteractCharacterLocation_1);
	InteractCharacterLocation_1->SetupAttachment(RootComponent);
}

```

`Source/DeadByDaylight/Window.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "InteractiveActor.h"
#include "Window.generated.h"

/**
 * 
 */
UCLASS()
class DEADBYDAYLIGHT_API AWindow : public AInteractiveActor
{
	GENERATED_BODY()

public:
	// Sets default values for this actor's properties
	AWindow();
	
private:
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Coponents", meta = (AllowPrivateAccess = "true"))
	class UBoxComponent* BoxCollision;

	UPROPERTY(EditAnywhere, Category = "Coponents", meta = (AllowPrivateAccess = "true"))
	USceneComponent* InteractCharacterLocation_0;
	UPROPERTY(EditAnywhere, Category = "Coponents", meta = (AllowPrivateAccess = "true"))
	USceneComponent* InteractCharacterLocation_1;
};

```

`Source/DeadByDaylightEditor.Target.cs`:

```cs
// Fill out your copyright notice in the Description page of Project Settings.

using UnrealBuildTool;
using System.Collections.Generic;

public class DeadByDaylightEditorTarget : TargetRules
{
	public DeadByDaylightEditorTarget(TargetInfo Target) : base(Target)
	{
		Type = TargetType.Editor;
		DefaultBuildSettings = BuildSettingsVersion.V2;

		ExtraModuleNames.AddRange( new string[] { "DeadByDaylight" } );
	}
}

```