Project Path: arc_praydog_luagenny_cbcfuxd7

Source Tree:

```txt
arc_praydog_luagenny_cbcfuxd7
├── CMakeLists.txt
├── LICENSE
├── README.md
├── cmake.toml
├── cmkr.cmake
├── include
│   ├── LuaGenny.h
│   └── LuaGenny.hpp
├── src
│   ├── LuaGenny.cpp
│   └── classes
│       ├── Array.cpp
│       ├── Array.hpp
│       ├── ClassMacros.hpp
│       ├── Constant.cpp
│       ├── Constant.hpp
│       ├── Enum.cpp
│       ├── Enum.hpp
│       ├── Function.cpp
│       ├── Function.hpp
│       ├── Namespace.cpp
│       ├── Namespace.hpp
│       ├── Object.cpp
│       ├── Object.hpp
│       ├── Parameter.cpp
│       ├── Parameter.hpp
│       ├── Reference.cpp
│       ├── Reference.hpp
│       ├── Sdk.cpp
│       ├── Sdk.hpp
│       ├── Struct.cpp
│       ├── Struct.hpp
│       ├── Type.cpp
│       ├── Type.hpp
│       ├── Typename.cpp
│       ├── Typename.hpp
│       ├── Variable.cpp
│       ├── Variable.hpp
│       ├── VirtualFunction.cpp
│       └── VirtualFunction.hpp
├── test
│   ├── Main.cpp
│   └── test.lua
└── vcpkg.json

```

`CMakeLists.txt`:

```txt
# This file is automatically generated from cmake.toml - DO NOT EDIT
# See https://github.com/build-cpp/cmkr for more information

cmake_minimum_required(VERSION 3.15)

if(CMAKE_SOURCE_DIR STREQUAL CMAKE_BINARY_DIR)
	message(FATAL_ERROR "In-tree builds are not supported. Run CMake from a separate directory: cmake -B build")
endif()

# Regenerate CMakeLists.txt automatically in the root project
set(CMKR_ROOT_PROJECT OFF)
if(CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_SOURCE_DIR)
	set(CMKR_ROOT_PROJECT ON)

	# Bootstrap cmkr
	include(cmkr.cmake OPTIONAL RESULT_VARIABLE CMKR_INCLUDE_RESULT)
	if(CMKR_INCLUDE_RESULT)
		cmkr()
	endif()

	# Enable folder support
	set_property(GLOBAL PROPERTY USE_FOLDERS ON)
endif()

# Create a configure-time dependency on cmake.toml to improve IDE support
if(CMKR_ROOT_PROJECT)
	configure_file(cmake.toml cmake.toml COPYONLY)
endif()

add_compile_options($<$<CXX_COMPILER_ID:MSVC>:/MP>)
option(LUAGENNY_BUILD_STATIC OFF)
message("${LUAGENNY_BUILD_STATIC}")

project(luagenny)

if(CMKR_ROOT_PROJECT AND NOT CMKR_DISABLE_VCPKG)
	include(FetchContent)
	message(STATUS "Fetching vcpkg (2025.04.09)...")
	FetchContent_Declare(vcpkg URL "https://github.com/microsoft/vcpkg/archive/refs/tags/2025.04.09.tar.gz")
	FetchContent_GetProperties(vcpkg)
	if(NOT vcpkg_POPULATED)
		FetchContent_Populate(vcpkg)
		include("${vcpkg_SOURCE_DIR}/scripts/buildsystems/vcpkg.cmake")
	endif()
endif()

include(FetchContent)

message(STATUS "Fetching sdkgenny (5a6768a13d7d929cc7495d95d5f604593efcfd50)...")
FetchContent_Declare(sdkgenny
	GIT_REPOSITORY
		"https://github.com/cursey/sdkgenny.git"
	GIT_TAG
		5a6768a13d7d929cc7495d95d5f604593efcfd50
)
FetchContent_MakeAvailable(sdkgenny)

# Packages
find_package(pegtl REQUIRED)

find_package(lua)

find_package(sol2)

# Target luagenny_static
if(LUAGENNY_BUILD_STATIC) # static
	set(CMKR_TARGET luagenny_static)
	set(luagenny_static_SOURCES "")

	list(APPEND luagenny_static_SOURCES
		"src/LuaGenny.cpp"
		"src/classes/Array.cpp"
		"src/classes/Constant.cpp"
		"src/classes/Enum.cpp"
		"src/classes/Function.cpp"
		"src/classes/Namespace.cpp"
		"src/classes/Object.cpp"
		"src/classes/Parameter.cpp"
		"src/classes/Reference.cpp"
		"src/classes/Sdk.cpp"
		"src/classes/Struct.cpp"
		"src/classes/Type.cpp"
		"src/classes/Typename.cpp"
		"src/classes/Variable.cpp"
		"src/classes/VirtualFunction.cpp"
		"src/classes/Array.hpp"
		"src/classes/ClassMacros.hpp"
		"src/classes/Constant.hpp"
		"src/classes/Enum.hpp"
		"src/classes/Function.hpp"
		"src/classes/Namespace.hpp"
		"src/classes/Object.hpp"
		"src/classes/Parameter.hpp"
		"src/classes/Reference.hpp"
		"src/classes/Sdk.hpp"
		"src/classes/Struct.hpp"
		"src/classes/Type.hpp"
		"src/classes/Typename.hpp"
		"src/classes/Variable.hpp"
		"src/classes/VirtualFunction.hpp"
	)

	list(APPEND luagenny_static_SOURCES
		cmake.toml
	)

	set(CMKR_SOURCES ${luagenny_static_SOURCES})
	add_library(luagenny_static STATIC)

	if(luagenny_static_SOURCES)
		target_sources(luagenny_static PRIVATE ${luagenny_static_SOURCES})
	endif()

	source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${luagenny_static_SOURCES})

	add_library(luagenny::luagenny ALIAS luagenny_static)

	target_compile_features(luagenny_static PUBLIC
		cxx_std_20
	)

	if(MSVC) # msvc
		target_compile_options(luagenny_static PUBLIC
			"/bigobj"
		)
	endif()

	if(CMAKE_CXX_COMPILER_ID MATCHES "Clang" OR CMAKE_C_COMPILER_ID MATCHES "Clang") # clang
		target_compile_options(luagenny_static PUBLIC
			-fdeclspec
			-Wno-ignored-attributes
		)
	endif()

	target_include_directories(luagenny_static PUBLIC
		include
	)

	target_link_libraries(luagenny_static PUBLIC
		lua
		sol2::sol2
		sdkgenny
	)

	set_target_properties(luagenny_static PROPERTIES
		OUTPUT_NAME
			luagenny
	)

	unset(CMKR_TARGET)
	unset(CMKR_SOURCES)
endif()

# Target luagenny_shared
if(NOT LUAGENNY_BUILD_STATIC) # shared
	set(CMKR_TARGET luagenny_shared)
	set(luagenny_shared_SOURCES "")

	list(APPEND luagenny_shared_SOURCES
		"src/LuaGenny.cpp"
		"src/classes/Array.cpp"
		"src/classes/Constant.cpp"
		"src/classes/Enum.cpp"
		"src/classes/Function.cpp"
		"src/classes/Namespace.cpp"
		"src/classes/Object.cpp"
		"src/classes/Parameter.cpp"
		"src/classes/Reference.cpp"
		"src/classes/Sdk.cpp"
		"src/classes/Struct.cpp"
		"src/classes/Type.cpp"
		"src/classes/Typename.cpp"
		"src/classes/Variable.cpp"
		"src/classes/VirtualFunction.cpp"
		"src/classes/Array.hpp"
		"src/classes/ClassMacros.hpp"
		"src/classes/Constant.hpp"
		"src/classes/Enum.hpp"
		"src/classes/Function.hpp"
		"src/classes/Namespace.hpp"
		"src/classes/Object.hpp"
		"src/classes/Parameter.hpp"
		"src/classes/Reference.hpp"
		"src/classes/Sdk.hpp"
		"src/classes/Struct.hpp"
		"src/classes/Type.hpp"
		"src/classes/Typename.hpp"
		"src/classes/Variable.hpp"
		"src/classes/VirtualFunction.hpp"
	)

	list(APPEND luagenny_shared_SOURCES
		cmake.toml
	)

	set(CMKR_SOURCES ${luagenny_shared_SOURCES})
	add_library(luagenny_shared SHARED)

	if(luagenny_shared_SOURCES)
		target_sources(luagenny_shared PRIVATE ${luagenny_shared_SOURCES})
	endif()

	source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${luagenny_shared_SOURCES})

	add_library(luagenny::luagenny ALIAS luagenny_shared)
	target_compile_definitions(luagenny_shared PUBLIC
		LUAGENNY_EXPORTS
	)

	target_compile_features(luagenny_shared PUBLIC
		cxx_std_20
	)

	if(MSVC) # msvc
		target_compile_options(luagenny_shared PUBLIC
			"/bigobj"
		)
	endif()

	if(CMAKE_CXX_COMPILER_ID MATCHES "Clang" OR CMAKE_C_COMPILER_ID MATCHES "Clang") # clang
		target_compile_options(luagenny_shared PUBLIC
			-fdeclspec
			-Wno-ignored-attributes
		)
	endif()

	target_include_directories(luagenny_shared PUBLIC
		include
	)

	target_link_libraries(luagenny_shared PUBLIC
		lua
		sol2::sol2
		sdkgenny
	)

	set_target_properties(luagenny_shared PROPERTIES
		OUTPUT_NAME
			luagenny
	)

	unset(CMKR_TARGET)
	unset(CMKR_SOURCES)
endif()

# Target repl
set(CMKR_TARGET repl)
set(repl_SOURCES "")

list(APPEND repl_SOURCES
	"test/Main.cpp"
)

list(APPEND repl_SOURCES
	cmake.toml
)

set(CMKR_SOURCES ${repl_SOURCES})
add_executable(repl)

if(repl_SOURCES)
	target_sources(repl PRIVATE ${repl_SOURCES})
endif()

get_directory_property(CMKR_VS_STARTUP_PROJECT DIRECTORY ${PROJECT_SOURCE_DIR} DEFINITION VS_STARTUP_PROJECT)
if(NOT CMKR_VS_STARTUP_PROJECT)
	set_property(DIRECTORY ${PROJECT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT repl)
endif()

source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${repl_SOURCES})

target_compile_features(repl PRIVATE
	cxx_std_20
)

target_include_directories(repl PRIVATE
	src
)

target_link_libraries(repl PRIVATE
	lua
	sol2::sol2
	luagenny::luagenny
	sdkgenny::sdkgenny
)

unset(CMKR_TARGET)
unset(CMKR_SOURCES)

enable_testing()

add_test(
	NAME
		mytest
	CONFIGURATIONS
		Debug
		Release
		RelWithDebInfo
		MinSizeRelease
	WORKING_DIRECTORY
		"${CMAKE_CURRENT_LIST_DIR}/"
	COMMAND
		"$<TARGET_FILE:repl>"
		--test
		"${CMAKE_CURRENT_SOURCE_DIR}/test/test.lua"
)

if(NOT LUAGENNY_BUILD_STATIC) # shared
	install(
		TARGETS
			luagenny_shared
			repl
		DESTINATION
			bin
		COMPONENT
			luagenny_shared
	)
endif()
if(LUAGENNY_BUILD_STATIC) # static
	install(
		TARGETS
			luagenny_static
			repl
		DESTINATION
			bin
		COMPONENT
			luagenny_static
	)
endif()

```

`LICENSE`:

```
MIT License

Copyright (c) 2022 praydog

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# luagenny ![buildstatus](https://github.com/praydog/luagenny/actions/workflows/build.yml/badge.svg)
Lua bindings for [sdkgenny](https://github.com/cursey/sdkgenny)

## Projects using this
* [regenny](https://github.com/cursey/regenny) - A reverse engineering tool to interactively reconstruct structures and generate header files 
	* Can REPL or run scripts using the Lua API to perform convenient/automated analysis on structures
	* See the initial [Pull Request](https://github.com/cursey/regenny/pull/10) for examples

## Examples
```
PS F:\Programming\projects\sdkgenny-lua\build\Debug> .\test.exe
0x223aa80d010
> baz = sdkgenny.StructOverlay(0x223aa80d010, parsed:global_ns():struct("Baz")) 
> print(baz.things:address())
2352207548688
> print(baz.things[0])
sol.luagenny::api::StructOverlay: 00000223AA7D8338
> print(baz.things[0].abc)
0
> print(baz.things[1].abc)
2
> print(baz.things[2].abc)
4
> print(baz.hello)
Hello, world!
> print(baz.im_true)
true
> print(baz.im_false)
false
> print(baz.im_also_true)
true
> print(baz.ta.hours)
40
```

gennyfile used
```cpp
constexpr auto gennyfile = R"(
type int 4 [[i32]]
type float 4 [[f32]]
type ushort 2 [[u16]]
type str 8 [[utf8*]]
type wstr 8 [[utf16*]]
type bool 1 [[bool]]
type uintptr_t 8 [[u64]]
type char 1
type wchar_t 2

struct RTTITest{}

enum Place {
    EARTH = 1,
    MOON = 2,
    MARS = 3,
}

struct Date {
    ushort nWeekDay : 3
    ushort nMonthDay : 6
    ushort nMonth : 5
    ushort nYear : 8
}

struct Foo {
    int a
    int b
    float c
    Place p
    Place bf1 : 4
    Place bf2 : 2
}

struct Bar {
    int d
    Foo* foo
    int[4][3] m
    Date date
}

struct Thing {
    int abc
}

struct Person {
    int age
}

struct Student : Person {
    float gpa
}

struct Faculty : Person {
    int wage
}

struct TA : Student, Faculty {
    int hours
}

struct Baz : Bar 0x100 {
	TA ta
    int e
    int thing
    int* f
    Foo g
    Thing* things
    char* hello [[utf8*]]
    //wchar_t* wide_hello [[utf16*]]
    //char[32] intrusive_hello [[utf8*]]
    bool im_true +40
    bool im_false
    bool im_also_true
	//RTTITest* test + 5
}

struct RTTITest 0x100 {
	uintptr_t** vtable
}
)";
```

```

`cmake.toml`:

```toml
[project]
name = "luagenny"
cmake-before="""
add_compile_options($<$<CXX_COMPILER_ID:MSVC>:/MP>)
option(LUAGENNY_BUILD_STATIC OFF)
message("${LUAGENNY_BUILD_STATIC}")
"""

[vcpkg]
version = "2025.04.09"
packages = [
    "pegtl",
    "lua",
    "sol2"
]

[fetch-content.sdkgenny]
git = "https://github.com/cursey/sdkgenny.git"
tag = "5a6768a13d7d929cc7495d95d5f604593efcfd50" 


[find-package]
pegtl = {}
lua = { required = false }
sol2 = { required = false }

[conditions]
static = "LUAGENNY_BUILD_STATIC"
shared = "NOT LUAGENNY_BUILD_STATIC"

[target.luagenny_static]
condition = "static"
type = "static"
sources = [
    "src/**.cpp",
    "src/**.hpp",
]
link-libraries = [
    "lua",
    "sol2::sol2",
    "sdkgenny"
]
include-directories = [
    "include",
]
compile-features = ["cxx_std_20"]
msvc.compile-options = ["/bigobj"]
clang.compile-options = ["-fdeclspec", "-Wno-ignored-attributes"]
compile-definitions = []
alias = "luagenny::luagenny"

[target.luagenny_static.properties]
OUTPUT_NAME="luagenny"

[target.luagenny_shared]
condition = "shared"
type = "shared"
sources = [
    "src/**.cpp",
    "src/**.hpp",
]
link-libraries = [
    "lua",
    "sol2::sol2",
    "sdkgenny"
]
include-directories = [
    "include",
]
compile-features = ["cxx_std_20"]
msvc.compile-options = ["/bigobj"]
clang.compile-options = ["-fdeclspec", "-Wno-ignored-attributes"]
compile-definitions = ["LUAGENNY_EXPORTS"]
alias = "luagenny::luagenny"

[target.luagenny_shared.properties]
OUTPUT_NAME="luagenny"

[target.repl]
type = "executable"
sources = ["test/Main.cpp"]
include-directories = [
    "src",
]
link-libraries = [
    "lua",
    "sol2::sol2",
    "luagenny::luagenny",
    "sdkgenny::sdkgenny"
]
compile-features = ["cxx_std_20"]

[[test]]
name = "mytest"
command = "$<TARGET_FILE:repl>"
arguments = ["--test", "${CMAKE_CURRENT_SOURCE_DIR}/test/test.lua"]
configurations = ["Debug", "Release", "RelWithDebInfo", "MinSizeRelease"]

[[install]]
condition = "shared"
targets = ["luagenny_shared", "repl"]
destination = "bin"

[[install]]
condition = "static"
targets = ["luagenny_static", "repl"]
destination = "bin"

```

`cmkr.cmake`:

```cmake
include_guard()

# Change these defaults to point to your infrastructure if desired
set(CMKR_REPO "https://github.com/build-cpp/cmkr" CACHE STRING "cmkr git repository" FORCE)
set(CMKR_TAG "v0.2.14" CACHE STRING "cmkr git tag (this needs to be available forever)" FORCE)
set(CMKR_COMMIT_HASH "" CACHE STRING "cmkr git commit hash (optional)" FORCE)

# To bootstrap/generate a cmkr project: cmake -P cmkr.cmake
if(CMAKE_SCRIPT_MODE_FILE)
    set(CMAKE_BINARY_DIR "${CMAKE_BINARY_DIR}/build")
    set(CMAKE_CURRENT_BINARY_DIR "${CMAKE_BINARY_DIR}")
    file(MAKE_DIRECTORY "${CMAKE_BINARY_DIR}")
endif()

# Set these from the command line to customize for development/debugging purposes
set(CMKR_EXECUTABLE "" CACHE FILEPATH "cmkr executable")
set(CMKR_SKIP_GENERATION OFF CACHE BOOL "skip automatic cmkr generation")
set(CMKR_BUILD_TYPE "Debug" CACHE STRING "cmkr build configuration")
mark_as_advanced(CMKR_REPO CMKR_TAG CMKR_COMMIT_HASH CMKR_EXECUTABLE CMKR_SKIP_GENERATION CMKR_BUILD_TYPE)

# Disable cmkr if generation is disabled
if(DEFINED ENV{CI} OR CMKR_SKIP_GENERATION OR CMKR_BUILD_SKIP_GENERATION)
    message(STATUS "[cmkr] Skipping automatic cmkr generation")
    unset(CMKR_BUILD_SKIP_GENERATION CACHE)
    macro(cmkr)
    endmacro()
    return()
endif()

# Disable cmkr if no cmake.toml file is found
if(NOT CMAKE_SCRIPT_MODE_FILE AND NOT EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/cmake.toml")
    message(AUTHOR_WARNING "[cmkr] Not found: ${CMAKE_CURRENT_SOURCE_DIR}/cmake.toml")
    macro(cmkr)
    endmacro()
    return()
endif()

# Convert a Windows native path to CMake path
if(CMKR_EXECUTABLE MATCHES "\\\\")
    string(REPLACE "\\" "/" CMKR_EXECUTABLE_CMAKE "${CMKR_EXECUTABLE}")
    set(CMKR_EXECUTABLE "${CMKR_EXECUTABLE_CMAKE}" CACHE FILEPATH "" FORCE)
    unset(CMKR_EXECUTABLE_CMAKE)
endif()

# Helper macro to execute a process (COMMAND_ERROR_IS_FATAL ANY is 3.19 and higher)
function(cmkr_exec)
    execute_process(COMMAND ${ARGV} RESULT_VARIABLE CMKR_EXEC_RESULT)
    if(NOT CMKR_EXEC_RESULT EQUAL 0)
        message(FATAL_ERROR "cmkr_exec(${ARGV}) failed (exit code ${CMKR_EXEC_RESULT})")
    endif()
endfunction()

# Windows-specific hack (CMAKE_EXECUTABLE_PREFIX is not set at the moment)
if(WIN32)
    set(CMKR_EXECUTABLE_NAME "cmkr.exe")
else()
    set(CMKR_EXECUTABLE_NAME "cmkr")
endif()

# Use cached cmkr if found
if(DEFINED ENV{CMKR_CACHE})
    set(CMKR_DIRECTORY_PREFIX "$ENV{CMKR_CACHE}")
    string(REPLACE "\\" "/" CMKR_DIRECTORY_PREFIX "${CMKR_DIRECTORY_PREFIX}")
    if(NOT CMKR_DIRECTORY_PREFIX MATCHES "\\/$")
        set(CMKR_DIRECTORY_PREFIX "${CMKR_DIRECTORY_PREFIX}/")
    endif()
    # Build in release mode for the cache
    set(CMKR_BUILD_TYPE "Release")
else()
    set(CMKR_DIRECTORY_PREFIX "${CMAKE_CURRENT_BINARY_DIR}/_cmkr_")
endif()
set(CMKR_DIRECTORY "${CMKR_DIRECTORY_PREFIX}${CMKR_TAG}")
set(CMKR_CACHED_EXECUTABLE "${CMKR_DIRECTORY}/bin/${CMKR_EXECUTABLE_NAME}")

# Helper function to check if a string starts with a prefix
# Cannot use MATCHES, see: https://github.com/build-cpp/cmkr/issues/61
function(cmkr_startswith str prefix result)
    string(LENGTH "${prefix}" prefix_length)
    string(LENGTH "${str}" str_length)
    if(prefix_length LESS_EQUAL str_length)
        string(SUBSTRING "${str}" 0 ${prefix_length} str_prefix)
        if(prefix STREQUAL str_prefix)
            set("${result}" ON PARENT_SCOPE)
            return()
        endif()
    endif()
    set("${result}" OFF PARENT_SCOPE)
endfunction()

# Handle upgrading logic
if(CMKR_EXECUTABLE AND NOT CMKR_CACHED_EXECUTABLE STREQUAL CMKR_EXECUTABLE)
    cmkr_startswith("${CMKR_EXECUTABLE}" "${CMAKE_CURRENT_BINARY_DIR}/_cmkr" CMKR_STARTSWITH_BUILD)
    cmkr_startswith("${CMKR_EXECUTABLE}" "${CMKR_DIRECTORY_PREFIX}" CMKR_STARTSWITH_CACHE)
    if(CMKR_STARTSWITH_BUILD)
        if(DEFINED ENV{CMKR_CACHE})
            message(AUTHOR_WARNING "[cmkr] Switching to cached cmkr: '${CMKR_CACHED_EXECUTABLE}'")
            if(EXISTS "${CMKR_CACHED_EXECUTABLE}")
                set(CMKR_EXECUTABLE "${CMKR_CACHED_EXECUTABLE}" CACHE FILEPATH "Full path to cmkr executable" FORCE)
            else()
                unset(CMKR_EXECUTABLE CACHE)
            endif()
        else()
            message(AUTHOR_WARNING "[cmkr] Upgrading '${CMKR_EXECUTABLE}' to '${CMKR_CACHED_EXECUTABLE}'")
            unset(CMKR_EXECUTABLE CACHE)
        endif()
    elseif(DEFINED ENV{CMKR_CACHE} AND CMKR_STARTSWITH_CACHE)
        message(AUTHOR_WARNING "[cmkr] Upgrading cached '${CMKR_EXECUTABLE}' to '${CMKR_CACHED_EXECUTABLE}'")
        unset(CMKR_EXECUTABLE CACHE)
    endif()
endif()

if(CMKR_EXECUTABLE AND EXISTS "${CMKR_EXECUTABLE}")
    message(VERBOSE "[cmkr] Found cmkr: '${CMKR_EXECUTABLE}'")
elseif(CMKR_EXECUTABLE AND NOT CMKR_EXECUTABLE STREQUAL CMKR_CACHED_EXECUTABLE)
    message(FATAL_ERROR "[cmkr] '${CMKR_EXECUTABLE}' not found")
elseif(NOT CMKR_EXECUTABLE AND EXISTS "${CMKR_CACHED_EXECUTABLE}")
    set(CMKR_EXECUTABLE "${CMKR_CACHED_EXECUTABLE}" CACHE FILEPATH "Full path to cmkr executable" FORCE)
    message(STATUS "[cmkr] Found cached cmkr: '${CMKR_EXECUTABLE}'")
else()
    set(CMKR_EXECUTABLE "${CMKR_CACHED_EXECUTABLE}" CACHE FILEPATH "Full path to cmkr executable" FORCE)
    message(VERBOSE "[cmkr] Bootstrapping '${CMKR_EXECUTABLE}'")

    message(STATUS "[cmkr] Fetching cmkr...")
    if(EXISTS "${CMKR_DIRECTORY}")
        cmkr_exec("${CMAKE_COMMAND}" -E rm -rf "${CMKR_DIRECTORY}")
    endif()
    find_package(Git QUIET REQUIRED)
    cmkr_exec("${GIT_EXECUTABLE}"
        clone
        --config advice.detachedHead=false
        --branch ${CMKR_TAG}
        --depth 1
        ${CMKR_REPO}
        "${CMKR_DIRECTORY}"
    )
    if(CMKR_COMMIT_HASH)
        execute_process(
            COMMAND "${GIT_EXECUTABLE}" checkout -q "${CMKR_COMMIT_HASH}"
            RESULT_VARIABLE CMKR_EXEC_RESULT
            WORKING_DIRECTORY "${CMKR_DIRECTORY}"
        )
        if(NOT CMKR_EXEC_RESULT EQUAL 0)
            message(FATAL_ERROR "Tag '${CMKR_TAG}' hash is not '${CMKR_COMMIT_HASH}'")
        endif()
    endif()
    message(STATUS "[cmkr] Building cmkr (using system compiler)...")
    cmkr_exec("${CMAKE_COMMAND}"
        --no-warn-unused-cli
        "${CMKR_DIRECTORY}"
        "-B${CMKR_DIRECTORY}/build"
        "-DCMAKE_BUILD_TYPE=${CMKR_BUILD_TYPE}"
        "-DCMAKE_UNITY_BUILD=ON"
        "-DCMAKE_INSTALL_PREFIX=${CMKR_DIRECTORY}"
        "-DCMKR_GENERATE_DOCUMENTATION=OFF"
    )
    cmkr_exec("${CMAKE_COMMAND}"
        --build "${CMKR_DIRECTORY}/build"
        --config "${CMKR_BUILD_TYPE}"
        --parallel
    )
    cmkr_exec("${CMAKE_COMMAND}"
        --install "${CMKR_DIRECTORY}/build"
        --config "${CMKR_BUILD_TYPE}"
        --prefix "${CMKR_DIRECTORY}"
        --component cmkr
    )
    if(NOT EXISTS ${CMKR_EXECUTABLE})
        message(FATAL_ERROR "[cmkr] Failed to bootstrap '${CMKR_EXECUTABLE}'")
    endif()
    cmkr_exec("${CMKR_EXECUTABLE}" version)
    message(STATUS "[cmkr] Bootstrapped ${CMKR_EXECUTABLE}")
endif()
execute_process(COMMAND "${CMKR_EXECUTABLE}" version
    RESULT_VARIABLE CMKR_EXEC_RESULT
)
if(NOT CMKR_EXEC_RESULT EQUAL 0)
    message(FATAL_ERROR "[cmkr] Failed to get version, try clearing the cache and rebuilding")
endif()

# Use cmkr.cmake as a script
if(CMAKE_SCRIPT_MODE_FILE)
    if(NOT EXISTS "${CMAKE_SOURCE_DIR}/cmake.toml")
        execute_process(COMMAND "${CMKR_EXECUTABLE}" init
            RESULT_VARIABLE CMKR_EXEC_RESULT
        )
        if(NOT CMKR_EXEC_RESULT EQUAL 0)
            message(FATAL_ERROR "[cmkr] Failed to bootstrap cmkr project. Please report an issue: https://github.com/build-cpp/cmkr/issues/new")
        else()
            message(STATUS "[cmkr] Modify cmake.toml and then configure using: cmake -B build")
        endif()
    else()
        execute_process(COMMAND "${CMKR_EXECUTABLE}" gen
            RESULT_VARIABLE CMKR_EXEC_RESULT
        )
        if(NOT CMKR_EXEC_RESULT EQUAL 0)
            message(FATAL_ERROR "[cmkr] Failed to generate project.")
        else()
            message(STATUS "[cmkr] Configure using: cmake -B build")
        endif()
    endif()
endif()

# This is the macro that contains black magic
macro(cmkr)
    # When this macro is called from the generated file, fake some internal CMake variables
    get_source_file_property(CMKR_CURRENT_LIST_FILE "${CMAKE_CURRENT_LIST_FILE}" CMKR_CURRENT_LIST_FILE)
    if(CMKR_CURRENT_LIST_FILE)
        set(CMAKE_CURRENT_LIST_FILE "${CMKR_CURRENT_LIST_FILE}")
        get_filename_component(CMAKE_CURRENT_LIST_DIR "${CMAKE_CURRENT_LIST_FILE}" DIRECTORY)
    endif()

    # File-based include guard (include_guard is not documented to work)
    get_source_file_property(CMKR_INCLUDE_GUARD "${CMAKE_CURRENT_LIST_FILE}" CMKR_INCLUDE_GUARD)
    if(NOT CMKR_INCLUDE_GUARD)
        set_source_files_properties("${CMAKE_CURRENT_LIST_FILE}" PROPERTIES CMKR_INCLUDE_GUARD TRUE)

        file(SHA256 "${CMAKE_CURRENT_LIST_FILE}" CMKR_LIST_FILE_SHA256_PRE)

        # Generate CMakeLists.txt
        cmkr_exec("${CMKR_EXECUTABLE}" gen
            WORKING_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}"
        )

        file(SHA256 "${CMAKE_CURRENT_LIST_FILE}" CMKR_LIST_FILE_SHA256_POST)

        # Delete the temporary file if it was left for some reason
        set(CMKR_TEMP_FILE "${CMAKE_CURRENT_SOURCE_DIR}/CMakerLists.txt")
        if(EXISTS "${CMKR_TEMP_FILE}")
            file(REMOVE "${CMKR_TEMP_FILE}")
        endif()

        if(NOT CMKR_LIST_FILE_SHA256_PRE STREQUAL CMKR_LIST_FILE_SHA256_POST)
            # Copy the now-generated CMakeLists.txt to CMakerLists.txt
            # This is done because you cannot include() a file you are currently in
            configure_file(CMakeLists.txt "${CMKR_TEMP_FILE}" COPYONLY)

            # Add the macro required for the hack at the start of the cmkr macro
            set_source_files_properties("${CMKR_TEMP_FILE}" PROPERTIES
                CMKR_CURRENT_LIST_FILE "${CMAKE_CURRENT_LIST_FILE}"
            )

            # 'Execute' the newly-generated CMakeLists.txt
            include("${CMKR_TEMP_FILE}")

            # Delete the generated file
            file(REMOVE "${CMKR_TEMP_FILE}")

            # Do not execute the rest of the original CMakeLists.txt
            return()
        endif()
        # Resume executing the unmodified CMakeLists.txt
    endif()
endmacro()

```

`include/LuaGenny.h`:

```h
#ifndef LUAGENNY_H
#define LUAGENNY_H

struct lua_State;

#ifdef __cplusplus
extern "C" {
#endif
#ifdef LUAGENNY_EXPORTS
__declspec(dllexport) int luaopen_luagenny(lua_State* l);
#else
int luaopen_luagenny(lua_State* l);
#endif
#ifdef __cplusplus
}
#endif

#endif // LUAGENNY_H

```

`include/LuaGenny.hpp`:

```hpp
#pragma once

struct lua_State;

namespace luagenny {
int open(lua_State* l);
} // namespace luagenny
```

`src/LuaGenny.cpp`:

```cpp
#include <vector>
#include <fstream>
#include <bit>

extern "C" {
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>
}
#include <sol/sol.hpp>

#if _MSC_VER == 1932 || _MSC_VER == 1933
#if _MSC_VER == 1932
#define _MSC_OLD_VER 1932
#endif

#if _MSC_VER == 1933
#define _MSC_OLD_VER 1933
#endif

#undef _MSC_VER
#define _MSC_VER 1919
#include <tao/pegtl/demangle.hpp>
#undef _MSC_VER
#define _MSC_VER _MSC_OLD_VER
#endif

#include <sdkgenny.hpp>
#include <sdkgenny_parser.hpp>

#include "classes/ClassMacros.hpp"
#include "classes/Sdk.hpp"
#include "classes/Object.hpp"
#include "classes/Type.hpp"
#include "classes/Typename.hpp"
#include "classes/Struct.hpp"
#include "classes/Enum.hpp"
#include "classes/Namespace.hpp"
#include "classes/Variable.hpp"
#include "classes/Reference.hpp"
#include "classes/Function.hpp"
#include "classes/VirtualFunction.hpp"
#include "classes/Parameter.hpp"
#include "classes/Constant.hpp"
#include "classes/Array.hpp"

#include "LuaGenny.h"
#include "LuaGenny.hpp"

namespace luagenny {
static constexpr auto hash(std::string_view data) {
    size_t result = 0xcbf29ce484222325;

    for (char c : data) {
        result ^= c;
        result *= (size_t)1099511628211;
    }

    return result;
}

constexpr auto operator "" _fnv(const char* s, size_t) {
    return hash(s);
}

namespace api {
sol::object standalone_parse(sol::this_state s, uintptr_t address, sdkgenny::Type* t, sdkgenny::Variable* v = nullptr);

sol::object reader(sol::this_state s, uintptr_t address, size_t size) {
    switch(size) {
    case 8:
        return sol::make_object(s, *(uint64_t*)address);
    case 4:
        return sol::make_object(s, *(uint32_t*)address);
    case 2:
        return sol::make_object(s, *(uint16_t*)address);
    case 1:
        return sol::make_object(s, *(uint8_t*)address);
    }
    
    return sol::make_object(s, sol::lua_nil);
}

sol::object string_reader(sol::this_state s, uintptr_t address) {
    return sol::make_object(s, (const char*)address);
}

void writer(sol::this_state s, uintptr_t address, size_t size, sol::object value) {
    switch(size) {
    case 8:
        if (!value.is<sol::lua_nil_t>()) {
            value.push();

            if (lua_isinteger(s, -1)) {
                *(uint64_t*)address = (uint64_t)lua_tointeger(s, -1);
            } else if (lua_isnumber(s, -1)) {
                *(double*)address = lua_tonumber(s, -1);
            }

            value.pop();
        } else {
            *(uint64_t*)address = 0;
        }

        break;
    case 4:
        if (!value.is<sol::lua_nil_t>()) {
            value.push();

            if (lua_isinteger(s, -1)) {
                *(uint32_t*)address = (uint32_t)lua_tointeger(s, -1);
            } else if (lua_isnumber(s, -1)) {
                *(float*)address = (float)lua_tonumber(s, -1);
            }

            value.pop();
        } else {
            *(uint32_t*)address = 0;
        }

        break;
    case 2:
        *(uint16_t*)address = value.as<uint16_t>();
        break;
    case 1:
        value.push();

        if (lua_isboolean(s, -1)) {
            *(bool*)address = lua_toboolean(s, -1);
        } else if (lua_isinteger(s, -1)) {
            *(uint8_t*)address = (uint8_t)lua_tointeger(s, -1);
        }

        value.pop();

        break;
    }
}

std::optional<std::tuple<sdkgenny::Variable*, size_t>> get_variable(sdkgenny::Struct* s, const std::string& name, size_t additional_offset = 0) {
    auto v = s->find<sdkgenny::Variable>(name);

    if (v != nullptr) {
        return std::make_tuple(v, additional_offset);
    }

    const auto& parents = s->parents();

    for (auto parent : parents) {
        auto v = get_variable(parent, name, additional_offset);

        if (v) {
            return v;
        }

        additional_offset += parent->size();
    }

    return std::nullopt;
}

template<typename T>
class Overlay {
public:
    Overlay(uintptr_t address, T* t) 
        : m_address(address),
        m_type{t}
    {
    }

    virtual sol::object index(sol::this_state s, sol::object key) = 0;
    virtual void new_index(sol::this_state s, sol::object key, sol::object value) {};

    sol::object type_(sol::this_state s) const {
        return sol::make_object(s, m_type);
    }

    sol::object address(sol::this_state s) const {
        return sol::make_object(s, m_address);
    }

protected:
    uintptr_t m_address{};
    T* m_type{};
};

class StructOverlay : public Overlay<sdkgenny::Struct> {
public:
    StructOverlay(uintptr_t address, sdkgenny::Struct* s) 
        : Overlay(address, s)
    {
    }

    sol::object index(sol::this_state s, sol::object key) override {
        if (key.is<int>()) {
            // Pretend it's an inlined array
            return sol::make_object(s, StructOverlay{m_address + (key.as<int>() * m_type->size()), m_type});
        }

        if (!key.is<std::string>()) {
            return sol::make_object(s, sol::lua_nil);
        }

        const auto name = key.as<std::string>();
        const auto pv = get_variable(m_type, name);

        if (!pv) {
            return sol::make_object(s, sol::lua_nil);
        }

        const auto& [v, additional_offset] = *pv;

        if (v == nullptr || v->type() == nullptr) {
            return sol::make_object(s, sol::lua_nil);
        }

        return sol::make_object(s, parse_and_read(s, v, additional_offset));
    }

    void new_index(sol::this_state s, sol::object key, sol::object value) override {
        if (!key.is<std::string>()) {
            return;
        }

        const auto name = key.as<std::string>();
        const auto pv = get_variable(m_type, name);

        if (!pv) {
            return;
        }

        const auto& [v, additional_offset] = *pv;

        if (v == nullptr || v->type() == nullptr) {
            return;
        }

        // TODO: maybe figure out the type pointed to
        // and adjust how we write the value rather than writing
        // the value verbatim to the address (e.g. struct.some_float = 1 will write an integer instead of a float)
        this->write(s, v, additional_offset, value);
    }

protected:
    uintptr_t get_final_address(sdkgenny::Variable* v, size_t additional_offset = 0) const {
         const auto offset = v->offset();

        if (offset > m_type->size()) {
            throw std::runtime_error("offset out of bounds");
            return 0;
        }

        return m_address + offset + additional_offset;
    }

    sol::object parse_and_read(sol::this_state s, sdkgenny::Variable* v, size_t additional_offset = 0) {
        const auto address = get_final_address(v, additional_offset);

        return sol::make_object(s, standalone_parse(s, address, v->type(), v));
    }

    void write(sol::this_state s, sdkgenny::Variable* v, size_t additional_offset, sol::object value) {
        const auto address = get_final_address(v, additional_offset);

        sol::function lua_writer = sol::state_view{s}["sdkgenny_writer"];
        lua_writer(s, address, v->type()->size(), value);
    }
};

class PointerOverlay : public Overlay<sdkgenny::Pointer> {
public:
    PointerOverlay(uintptr_t address, sdkgenny::Pointer* p, sdkgenny::Variable* from = nullptr) 
        : Overlay(address, p),
        m_from{from}
    {
    }

    sol::object index(sol::this_state s, sol::object key) override {
        const auto pointed_to = ptr_internal(s);

        if (pointed_to == 0) {
            return sol::make_object(s, sol::lua_nil);
        }

        if (m_type->to()->is_a<sdkgenny::Struct>()) {
            return StructOverlay{pointed_to, dynamic_cast<sdkgenny::Struct*>(m_type->to())}.index(s, key);
        }

        if (key.is<int>()) {
            const auto adjusted_to = pointed_to + (m_type->to()->size() * key.as<int>());
            return sol::make_object(s, standalone_parse(s, adjusted_to, m_type->to(), m_from));
        }

        return sol::make_object(s, sol::lua_nil);
    }

    void new_index(sol::this_state s, sol::object key, sol::object value) override {
        const auto pointed_to = ptr_internal(s);

        if (pointed_to == 0) {
            return;
        }

        if (m_type->to()->is_a<sdkgenny::Struct>()) {
            StructOverlay{pointed_to, dynamic_cast<sdkgenny::Struct*>(m_type->to())}.new_index(s, key, value);
            return;
        }

        // TODO: maybe figure out the type pointed to
        // and adjust how we write the value rather than writing
        // the value verbatim to the address (e.g. struct.some_float = 1 will write an integer instead of a float)
        if (key.is<int>()) {
            const auto adjusted_to = pointed_to + (m_type->to()->size() * key.as<int>());
            sol::function lua_writer = sol::state_view{s}["sdkgenny_writer"];
            lua_writer(s, adjusted_to, m_type->to()->size(), value);
        }
    }
    
    // Address pointed to, not address of pointer
    sol::object d(sol::this_state s) const {
        const auto pointed_to = ptr_internal(s);

        if (pointed_to == 0) {
            return sol::make_object(s, sol::lua_nil);
        }

        return sol::make_object(s, standalone_parse(s, pointed_to, m_type->to(), m_from));
    }

    uintptr_t ptr(sol::this_state s) const {
        return ptr_internal(s);
    }

protected:
    uintptr_t ptr_internal(sol::this_state s) const {
        sol::function lua_reader = sol::state_view{s}["sdkgenny_reader"];
        uintptr_t deref_address = 0;

        if constexpr (sizeof(void*) == 8) {
            deref_address = (uintptr_t)lua_reader(s, m_address, sizeof(void*)).get<uint64_t>();
        } else {
            deref_address = (uintptr_t)lua_reader(s, m_address, sizeof(void*)).get<uint32_t>();
        }

        return deref_address;
    }

    sdkgenny::Variable* m_from{};
};

sol::object standalone_parse(sol::this_state s, uintptr_t address, sdkgenny::Type* t, sdkgenny::Variable* v) {
    if (t == nullptr) {
        return sol::make_object(s, address);
    }

    if (t->is_a<sdkgenny::Struct>()) {
        return sol::make_object(s, StructOverlay{address, dynamic_cast<sdkgenny::Struct*>(t)});
    }

    const auto is_pointer = t->is_a<sdkgenny::Pointer>();
    sdkgenny::Type* pointer_t = nullptr;

    auto metadata = t->metadata();

    if (metadata.empty() && v != nullptr) {
        metadata = v->metadata();
    }

    sol::function lua_reader = sol::state_view{s}["sdkgenny_reader"];
    sol::function lua_string_reader = sol::state_view{s}["sdkgenny_string_reader"];

    if (is_pointer) {
        const auto p = dynamic_cast<sdkgenny::Pointer*>(t);
        const auto to = p->to();

        if (to->is_a<sdkgenny::Struct>() || to->is_a<sdkgenny::Pointer>() || metadata.empty()) {
            return sol::make_object(s, PointerOverlay{address, p, v});
        }

        address = lua_reader(s, address, sizeof(void*)).get<uintptr_t>();

        if (address == 0) {
            return sol::make_object(s, sol::lua_nil);
        }

        if (metadata.empty()) {
            metadata = to->metadata();
        }
    }

    if (metadata.empty()){
        throw std::runtime_error("No metadata for type");
        return sol::make_object(s, sol::lua_nil);
    }

    for (auto&& md : metadata) {
        switch (hash(md)) {
            case "bool"_fnv:
                return sol::make_object(s, (bool)lua_reader(s, address, 1).get<uint8_t>());
            case "u8"_fnv:
                return sol::make_object(s, (uint8_t)lua_reader(s, address, 1).get<uint8_t>());
            case "u16"_fnv:
                return sol::make_object(s, (uint16_t)lua_reader(s, address, 2).get<uint16_t>());
            case "u32"_fnv:
                return sol::make_object(s, (uint32_t)lua_reader(s, address, 4).get<uint32_t>());
            case "u64"_fnv:
                return sol::make_object(s, (uint64_t)lua_reader(s, address, 8).get<uint64_t>());
            case "i8"_fnv:
                return sol::make_object(s, (int8_t)lua_reader(s, address, 1).get<uint8_t>());
            case "i16"_fnv:
                return sol::make_object(s, (int16_t)lua_reader(s, address, 2).get<uint16_t>());
            case "i32"_fnv:
                return sol::make_object(s, (int32_t)lua_reader(s, address, 4).get<uint32_t>());
            case "i64"_fnv:
                return sol::make_object(s, (int64_t)lua_reader(s, address, 8).get<uint64_t>());
            case "f32"_fnv: {
#if defined(__cpp_lib_bit_cast)
                return sol::make_object(s, std::bit_cast<float>(lua_reader(s, address, 4).get<uint32_t>()));
#else
                auto value = lua_reader(s, address, 4).get<uint32_t>();
                return sol::make_object(s, *(float*)&value);
#endif
            }
            case "f64"_fnv: {
#if defined(__cpp_lib_bit_cast)
                return sol::make_object(s, std::bit_cast<double>(lua_reader(s, address, 8).get<uint64_t>()));
#else
                auto value = lua_reader(s, address, 8).get<uint64_t>();
                return sol::make_object(s, *(double*)&value);
#endif
            }
            case "utf8*"_fnv:
                return sol::make_object(s, lua_string_reader(s, address, 1).get<const char*>());
            default:
                continue;
        }
    }

    return sol::make_object(s, sol::lua_nil);
}

sol::object parse(sol::this_state s, std::string data) {
    auto sdk = std::make_unique<sdkgenny::Sdk>();

    sdkgenny::parser::State state{};
    state.parents.push_back(sdk->global_ns());

    tao::pegtl::memory_input in{data, "text"};
    tao::pegtl::parse<sdkgenny::parser::Grammar, sdkgenny::parser::Action>(in, state);

    return sol::make_object(s, std::move(sdk));
}

sol::object parse_file(sol::this_state s, std::string filename) {
    std::ifstream file{filename};
    std::string data{(std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>()};
    return parse(s, data);
}
}

int open(lua_State* l) {
    sol::state_view lua{l};

    auto sdkgenny = lua.create_table();

    lua["sdkgenny_reader"] = &api::reader;
    lua["sdkgenny_string_reader"] = &api::string_reader;
    lua["sdkgenny_writer"] = &api::writer;
    sdkgenny["parse"] = &api::parse;
    sdkgenny["parse_file"] = &api::parse_file;

    sdkgenny.new_usertype<api::StructOverlay>("StructOverlay",
        sol::meta_function::construct, sol::constructors<api::StructOverlay(uintptr_t, sdkgenny::Struct*)>(),
        sol::call_constructor, sol::constructors<api::StructOverlay(uintptr_t, sdkgenny::Struct*)>(),
        "type", &api::StructOverlay::type_,
        "address", &api::StructOverlay::address,
        sol::meta_function::index, &api::StructOverlay::index,
        sol::meta_function::new_index, &api::StructOverlay::new_index
    );

    sdkgenny.new_usertype<api::PointerOverlay>("PointerOverlay",
        sol::meta_function::construct, sol::constructors<api::PointerOverlay(uintptr_t, sdkgenny::Pointer*)>(),
        sol::call_constructor, sol::constructors<api::PointerOverlay(uintptr_t, sdkgenny::Pointer*)>(),
        "type", &api::PointerOverlay::type_,
        "address", &api::PointerOverlay::address, // address of the pointer, not what it points to. Same as &ptr.
        "d", &api::PointerOverlay::d, // Resolve the pointed to address into a pointer or value. Same as ptr[0].
        "deref", &api::PointerOverlay::d, // Resolve the pointed to address into a pointer or value. Same as ptr[0].
        "dereference", &api::PointerOverlay::d, // Resolve the pointed to address into a pointer or value. Same as ptr[0].
        "p", &api::PointerOverlay::ptr, // address pointed to, like auto var = (uintptr_t)ptr.
        "ptr", &api::PointerOverlay::ptr, // address pointed to, like auto var = (uintptr_t)ptr.
        sol::meta_function::index, &api::PointerOverlay::index, // Access like ptr->field in C++ or an array, like ptr[i]
        sol::meta_function::new_index, &api::PointerOverlay::new_index // Access like ptr->field = value in C++ or an array, like ptr[i] = value
    );

    sdkgenny.push();
    luagenny::open_sdk(l);

    sdkgenny.push();
    luagenny::open_object(l);

    sdkgenny.push();
    luagenny::open_typename(l);

    sdkgenny.push();
    luagenny::open_type(l);

    sdkgenny.new_usertype<sdkgenny::GenericType>("GenericType",
        sol::base_classes, sol::bases<GENNY_TYPE_BASES>()
    );

    sdkgenny.push();
    luagenny::open_struct(l);

    sdkgenny.new_usertype<sdkgenny::Class>("Class",
        sol::base_classes, sol::bases<sdkgenny::Struct, GENNY_TYPE_BASES>()
    );

    sdkgenny.push();
    luagenny::open_enum(l);

    sdkgenny.new_usertype<sdkgenny::EnumClass>("EnumClass",
        sol::base_classes, sol::bases<sdkgenny::Enum, GENNY_TYPE_BASES>()
    );

    sdkgenny.push();
    luagenny::open_namespace(l);

    sdkgenny.push();
    luagenny::open_reference(l);

    sdkgenny.new_usertype<sdkgenny::Pointer>("Pointer",
        sol::base_classes, sol::bases<GENNY_REFERENCE_BASES>()
    );

    sdkgenny.push();
    luagenny::open_variable(l);

    sdkgenny.push();
    luagenny::open_function(l);

    sdkgenny.push();
    luagenny::open_virtual_function(l);

    sdkgenny.new_usertype<sdkgenny::StaticFunction>("StaticFunction",
        sol::base_classes, sol::bases<sdkgenny::Function, sdkgenny::Object>()
    );

    sdkgenny.push();
    luagenny::open_array(l);

    sdkgenny.push();
    luagenny::open_parameter(l);

    sdkgenny.push();
    luagenny::open_constant(l);

    sdkgenny.push(l);
    return 1;
} // namespace luagenny
}

int luaopen_luagenny(lua_State* l) {
    return luagenny::open(l);
}
```

`src/classes/Array.cpp`:

```cpp
extern "C" {
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>
}

#include <sol/sol.hpp>

#include "sdkgenny.hpp"
#include "ClassMacros.hpp"
#include "Array.hpp"

namespace luagenny {
int open_array(lua_State* l) {
    sol::table sdkgenny = sol::stack::pop<sol::table>(l);

    sdkgenny.new_usertype<sdkgenny::Array>("Array",
        sol::base_classes, sol::bases<GENNY_TYPE_BASES>(),
        MULTIFUNCTION(sdkgenny::Array, of, sdkgenny::Type*),
        MULTIFUNCTION(sdkgenny::Array, count, int)
    );

    return 0;
}
}
```

`src/classes/Array.hpp`:

```hpp
#pragma once

struct lua_State;

namespace luagenny {
int open_array(lua_State* l);
} // namespace luagenny
```

`src/classes/ClassMacros.hpp`:

```hpp
#pragma once

#include <sol/sol.hpp>

#define GENNY_OBJECT_GEN(luaname, cppname) \
    "is_" #luaname, [](sdkgenny::Object& o) { return o.is_a<cppname>(); }, \
    "as_" #luaname, [](sdkgenny::Object& o) -> cppname* { return o.is_a<cppname>() ? dynamic_cast<cppname*>(&o) : nullptr; }, \
    "has_any_" #luaname, [](sdkgenny::Object& o) { return o.has_any<cppname>(); }, \
    "has_any_" #luaname "_in_children", [](sdkgenny::Object& o) { return o.has_any_in_children<cppname>(); }, \
    #luaname "_owners", [](sdkgenny::Object& o) { return o.owners<cppname>(); }, \
    "get_all_" #luaname, [](sdkgenny::Object& o) { return o.get_all<cppname>(); }, \
    "is_child_of_" #luaname, [](sdkgenny::Object& o, cppname* obj) { return o.is_child_of<cppname>(obj); }, \
    "find_" #luaname, [](sdkgenny::Object& o, std::string name) { return o.find<cppname>(name); }, \
    "find_" #luaname "_in_owners", [](sdkgenny::Object& o, std::string name, bool include_self) { return o.find_in_owners<cppname>(name, include_self); }
    

#define MULTIFUNCTION(parent_type, name, possible_type) \
    #name, [](sol::this_state s, parent_type& f, sol::object param) -> sol::object { \
        if (param.is<sol::lua_nil_t>()) { \
            return sol::make_object(s, f.name()); \
        } \
        return sol::make_object(s, f.name(param.as<possible_type>())); \
    }

#define FUNCTION(parent_type, name) \
    #name, [](sol::this_state s, parent_type& f) -> sol::object { \
        return sol::make_object(s, f.name()); \
    }

#define PARAMFUNCTION(parent_type, name, t) \
    #name, [](sol::this_state s, parent_type& f, sol::object param) -> sol::object { \
        return sol::make_object(s, f.name(param.as<t>())); \
    }

#define GENNY_TYPENAME_BASES sdkgenny::Typename, sdkgenny::Object
#define GENNY_TYPE_BASES sdkgenny::Type, sdkgenny::Typename, sdkgenny::Object
#define GENNY_REFERENCE_BASES sdkgenny::Reference, GENNY_TYPE_BASES
```

`src/classes/Constant.cpp`:

```cpp
extern "C" {
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>
}

#include <sol/sol.hpp>

#include "sdkgenny.hpp"
#include "ClassMacros.hpp"
#include "Constant.hpp"

namespace luagenny {
int open_constant(lua_State* l) {
    sol::table sdkgenny = sol::stack::pop<sol::table>(l);

    sdkgenny.new_usertype<sdkgenny::Constant>("Constant",
        sol::base_classes, sol::bases<sdkgenny::Object>(),
        MULTIFUNCTION(sdkgenny::Constant, type, sdkgenny::Type*),
        PARAMFUNCTION(sdkgenny::Constant, type, std::string),
        MULTIFUNCTION(sdkgenny::Constant, value, std::string),
        "string", &sdkgenny::Constant::string
    );

    return 0;
}
}
```

`src/classes/Constant.hpp`:

```hpp
#pragma once

struct lua_State;

namespace luagenny {
int open_constant(lua_State* l);
} // namespace luagenny
```

`src/classes/Enum.cpp`:

```cpp
extern "C" {
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>
}

#include <sol/sol.hpp>

#include "sdkgenny.hpp"
#include "ClassMacros.hpp"
#include "Enum.hpp"

namespace luagenny {
int open_enum(lua_State* l) {
    sol::table sdkgenny = sol::stack::pop<sol::table>(l);

    sdkgenny.new_usertype<sdkgenny::Enum>("Enum",
        sol::base_classes, sol::bases<GENNY_TYPE_BASES>(),
        "value", [] (sdkgenny::Enum& e, std::string name, uint64_t value) {
            e.value(name, value);
        },
        "values", [] (sdkgenny::Enum& e) -> std::vector<std::tuple<std::string, uint64_t>> {
            return e.values();
        },
        MULTIFUNCTION(sdkgenny::Enum, type, sdkgenny::Type*)
    );

    return 0;
}
}
```

`src/classes/Enum.hpp`:

```hpp
#pragma once

struct lua_State;

namespace luagenny {
int open_enum(lua_State* l);
} // namespace luagenny
```

`src/classes/Function.cpp`:

```cpp
extern "C" {
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>
}

#include <sol/sol.hpp>

#include "sdkgenny.hpp"
#include "ClassMacros.hpp"
#include "Function.hpp"

namespace luagenny {
int open_function(lua_State* l) {
    sol::table sdkgenny = sol::stack::pop<sol::table>(l);

    sdkgenny.new_usertype<sdkgenny::Function>("Function",
        sol::base_classes, sol::bases<sdkgenny::Object>(),
        MULTIFUNCTION(sdkgenny::Function, returns, sdkgenny::Type*),
        MULTIFUNCTION(sdkgenny::Function, procedure, std::string),
        "dependencies", &sdkgenny::Function::dependencies,
        PARAMFUNCTION(sdkgenny::Function, depends_on, sdkgenny::Type*),
        MULTIFUNCTION(sdkgenny::Function, defined, bool)
    );

    return 0;
}
}
```

`src/classes/Function.hpp`:

```hpp
#pragma once

struct lua_State;

namespace luagenny {
int open_function(lua_State* l);
} // namespace luagenny
```

`src/classes/Namespace.cpp`:

```cpp
extern "C" {
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>
}

#include <sol/sol.hpp>

#include "sdkgenny.hpp"
#include "ClassMacros.hpp"
#include "Namespace.hpp"

namespace luagenny {
int open_namespace(lua_State* l) {
    sol::table sdkgenny = sol::stack::pop<sol::table>(l);

    sdkgenny.new_usertype<sdkgenny::Namespace>("Namespace",
        sol::base_classes, sol::bases<GENNY_TYPENAME_BASES>(),
        "type", &sdkgenny::Namespace::type,
        "generic_type", &sdkgenny::Namespace::generic_type,
        "struct", &sdkgenny::Namespace::struct_,
        "enum", &sdkgenny::Namespace::enum_,
        "enum_class", &sdkgenny::Namespace::enum_class,
        "namespace", &sdkgenny::Namespace::namespace_
    );

    return 0;
}
}
```

`src/classes/Namespace.hpp`:

```hpp
#pragma once

struct lua_State;

namespace luagenny {
int open_namespace(lua_State* l);
} // namespace luagenny
```

`src/classes/Object.cpp`:

```cpp
extern "C" {
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>
}

#include <type_traits>
#include <string_view>

#include <sol/sol.hpp>

#include "sdkgenny.hpp"
#include "ClassMacros.hpp"
#include "Object.hpp"

namespace luagenny {
template<size_t N>
struct String {
    constexpr String(const char (&str)[N]) {
        std::copy_n(str, N, value);
    }

    char value[N];
};

template<typename T, String Name>
struct TypeDescriptor {
    using Type = T;

    static bool is_a(sdkgenny::Object& o, std::string_view name) {
        return name == Name.value && o.is_a<T>();
    }

    static T* as(sdkgenny::Object& o, std::string_view name) {
        if (name == Name.value) {
            return dynamic_cast<T*>(&o);
        }
        return nullptr;
    }

    static T* as_standalone(sdkgenny::Object& o) {
        return dynamic_cast<T*>(&o);
    }


    static T* find(sdkgenny::Object& o, std::string_view name, std::string_view target_name) {
        if (name == Name.value) {
            return o.find<T>(target_name);
        }
        return nullptr;
    }

    static T* find_in_owners(sdkgenny::Object& o, std::string_view name, std::string_view target_name, bool include_self) {
        if (name == Name.value) {
            return o.find_in_owners<T>(target_name, include_self);
        }
        return nullptr;
    }

    static bool has_any(sdkgenny::Object& o, std::string_view name) {
        return name == Name.value && o.has_any<T>();
    }

    static bool has_any_in_children(sdkgenny::Object& o, std::string_view name) {
        return name == Name.value && o.has_any_in_children<T>();
    }

    static T* owner(sdkgenny::Object& o, std::string_view name) {
        if (name == Name.value) {
            return o.owner<T>();
        }
        return nullptr;
    }
    
    static T* topmost_owner(sdkgenny::Object& o, std::string_view name) {
        if (name == Name.value) {
            return o.topmost_owner<T>();
        }
        return nullptr;
    }

    static std::optional<std::vector<T*>> get_all(sdkgenny::Object& o, std::string_view name) {
        if (name == Name.value) {
            return o.get_all<T>();
        }

        return std::nullopt;
    }

    static consteval std::string_view name() {
        return Name.value;
    }

    static constexpr auto is_a_standalone = &sdkgenny::Object::is_a<T>;
    static constexpr auto find_standalone = &sdkgenny::Object::find<T>;
    static constexpr auto find_in_owners_standalone = &sdkgenny::Object::find_in_owners<T>;
    static constexpr auto has_any_standalone = &sdkgenny::Object::has_any<T>;
    static constexpr auto has_any_in_children_standalone = &sdkgenny::Object::has_any_in_children<T>;
    static constexpr auto owner_standalone = (T* (sdkgenny::Object::*)())&sdkgenny::Object::owner<T>;
    static constexpr auto topmost_owner_standalone = (T* (sdkgenny::Object::*)())&sdkgenny::Object::topmost_owner<T>;
    static constexpr auto get_all_standalone = &sdkgenny::Object::get_all<T>;
};

template <typename ...Args>
struct Bindings {

};

template <typename ...Args> // args are TypeDescriptors
void create_bindings(sol::table sdkgenny) {
    auto object = sdkgenny.new_usertype<sdkgenny::Object>("Object",
        "metadata", [](sol::this_state s, sdkgenny::Object& o) -> std::vector<std::string>& {
            return o.metadata();
        },
        MULTIFUNCTION(sdkgenny::Object, name, std::string),
        "is_a", [] (sol::this_state s, sdkgenny::Object& o, const char* name) -> bool {
            return (Args::is_a(o, name) || ... || false);
        },
        "as", [] (sol::this_state s, sdkgenny::Object& o, const char* name) -> sol::object {
            /*sol::object result = sol::make_object(s, sol::lua_nil);

            (((
                (result = sol::make_object(s, Args::as(o, name))) && !result.is<sol::lua_nil_t>()))
                || ...
                || (result = sol::make_object(s, sol::lua_nil))
            );

            return result;*/

            using ft = std::function<sol::object(sol::this_state s, sdkgenny::Object&)>;
            static std::unordered_map<std::string, ft> find_functions = []() {
                std::unordered_map<std::string, ft> find_functions{};
                (find_functions.emplace(Args::name().data(), [] (sol::this_state s, sdkgenny::Object& o) -> sol::object {
                    return sol::make_object(s, dynamic_cast<typename Args::Type*>(&o));
                }), ...);

                return find_functions;
            }();

            if (auto it = find_functions.find(name); it != find_functions.end()) {
                return it->second(s, o);
            }

            return sol::make_object(s, sol::lua_nil);
        },
        "find", [] (sol::this_state s, sdkgenny::Object& o, const char* name, const char* target_name) -> sol::object {
            /*sol::object result = sol::make_object(s, sol::lua_nil);

            (((
                (result = sol::make_object(s, Args::find(o, name, target_name))) && !result.is<sol::lua_nil_t>()))
                || ...
                || (result = sol::make_object(s, sol::lua_nil))
            );

            return result;*/

            using ft = std::function<sol::object(sol::this_state s, sdkgenny::Object&, std::string_view)>;
            static std::unordered_map<std::string, ft> find_functions = []() {
                std::unordered_map<std::string, ft> find_functions{};
                (find_functions.emplace(Args::name().data(), [] (sol::this_state s, sdkgenny::Object& o, std::string_view target_name) -> sol::object {
                    return sol::make_object(s, o.find<typename Args::Type>(target_name));
                }), ...);

                return find_functions;
            }();

            if (auto it = find_functions.find(name); it != find_functions.end()) {
                return it->second(s, o, target_name);
            }

            return sol::make_object(s, sol::lua_nil);
        },
        "find_in_owners", [] (sol::this_state s, sdkgenny::Object& o, const char* name, const char* target_name, bool include_self) -> sol::object {
            /*sol::object result = sol::make_object(s, sol::lua_nil);

            (((
                (result = sol::make_object(s, Args::find_in_owners(o, name, target_name, include_self))) && !result.is<sol::lua_nil_t>()))
                || ...
                || (result = sol::make_object(s, sol::lua_nil))
            );

            return result;*/

            using ft = std::function<sol::object(sol::this_state s, sdkgenny::Object&, std::string_view, bool)>;
            static std::unordered_map<std::string, ft> find_in_owners_functions = []() {
                std::unordered_map<std::string, ft> find_in_owners_functions{};
                (find_in_owners_functions.emplace(Args::name().data(), [] (sol::this_state s, sdkgenny::Object& o, std::string_view target_name, bool include_self) -> sol::object {
                    return sol::make_object(s, o.find_in_owners<typename Args::Type>(target_name, include_self));
                }), ...);

                return find_in_owners_functions;
            }();

            if (auto it = find_in_owners_functions.find(name); it != find_in_owners_functions.end()) {
                return it->second(s, o, target_name, include_self);
            }

            return sol::make_object(s, sol::lua_nil);
        },
        "has_any", [] (sol::this_state s, sdkgenny::Object& o, const char* name) -> bool {
            return (Args::has_any(o, name) || ... || false); // this is faster than using the map
        },
        "has_any_in_children", [] (sol::this_state s, sdkgenny::Object& o, const char* name) -> bool {
            return (Args::has_any_in_children(o, name) || ... || false);
        },
        "owner", [] (sol::this_state s, sdkgenny::Object& o, const char* name) -> sol::object {
            /*sol::object result = sol::make_object(s, sol::lua_nil);

            (((
                (result = sol::make_object(s, Args::owner(o, name))) && !result.is<sol::lua_nil_t>()))
                || ...
                || (result = sol::make_object(s, sol::lua_nil))
            );

            return result;*/

            using ft = std::function<sol::object(sol::this_state s, sdkgenny::Object&)>;
            static std::unordered_map<std::string, ft> find_functions = []() {
                std::unordered_map<std::string, ft> find_functions{};
                (find_functions.emplace(Args::name().data(), [] (sol::this_state s, sdkgenny::Object& o) -> sol::object {
                    return sol::make_object(s, o.owner<typename Args::Type>());
                }), ...);

                return find_functions;
            }();

            if (auto it = find_functions.find(name); it != find_functions.end()) {
                return it->second(s, o);
            }

            return sol::make_object(s, sol::lua_nil);
        },
        "topmost_owner", [] (sol::this_state s, sdkgenny::Object& o, const char* name) -> sol::object {
            /*sol::object result = sol::make_object(s, sol::lua_nil);

            (((
                (result = sol::make_object(s, Args::topmost_owner(o, name))) && !result.is<sol::lua_nil_t>()))
                || ...
                || (result = sol::make_object(s, sol::lua_nil))
            );

            return result;*/

            using ft = std::function<sol::object(sol::this_state s, sdkgenny::Object&)>;
            static std::unordered_map<std::string, ft> find_functions = []() {
                std::unordered_map<std::string, ft> find_functions{};
                (find_functions.emplace(Args::name().data(), [] (sol::this_state s, sdkgenny::Object& o) -> sol::object {
                    return sol::make_object(s, o.topmost_owner<typename Args::Type>());
                }), ...);

                return find_functions;
            }();

            if (auto it = find_functions.find(name); it != find_functions.end()) {
                return it->second(s, o);
            }

            return sol::make_object(s, sol::lua_nil);
        },
        "get_all", [] (sol::this_state s, sdkgenny::Object& o, const char* name) -> sol::object {
            /*sol::object result = sol::make_object(s, sol::lua_nil);

            (((
                (result = sol::make_object(s, Args::get_all(o, name))) && !result.is<sol::lua_nil_t>()))
                || ...
                || (result = sol::make_object(s, sol::lua_nil))
            );

            return result;*/

            using ft = std::function<sol::object(sol::this_state s, sdkgenny::Object&)>;
            static std::unordered_map<std::string, ft> find_functions = []() {
                std::unordered_map<std::string, ft> find_functions{};
                (find_functions.emplace(Args::name().data(), [] (sol::this_state s, sdkgenny::Object& o) -> sol::object {
                    return sol::make_object(s, o.get_all<typename Args::Type>());
                }), ...);

                return find_functions;
            }();

            if (auto it = find_functions.find(name); it != find_functions.end()) {
                return it->second(s, o);
            }

            return sol::make_object(s, sol::lua_nil);
        }
    );

    (object.set(std::string("is_") + Args::name().data(), Args::is_a_standalone), ...);
    (object.set(std::string("as_") + Args::name().data(), Args::as_standalone), ...);
    (object.set(std::string("find_") + Args::name().data(), Args::find_standalone), ...);
    (object.set(std::string("find_") + Args::name().data() + "_in_owners", Args::find_in_owners_standalone), ...);
    (object.set(std::string("has_any_") + Args::name().data(), Args::has_any_standalone), ...);
    (object.set(std::string("has_any_") + Args::name().data() + "_in_children", Args::has_any_in_children_standalone), ...);
    (object.set(std::string("owner_") + Args::name().data(), Args::owner_standalone), ...);
    (object.set(std::string("topmost_owner_") + Args::name().data(), Args::topmost_owner_standalone), ...);
    (object.set(std::string("get_all_") + Args::name().data(), Args::get_all_standalone), ...);
}

int open_object(lua_State* l) {
    sol::table sdkgenny = sol::stack::pop<sol::table>(l);

    create_bindings<
        TypeDescriptor<sdkgenny::Typename, "typename">,
        TypeDescriptor<sdkgenny::Type, "type">,
        TypeDescriptor<sdkgenny::GenericType, "generic_type">,
        TypeDescriptor<sdkgenny::Struct, "struct">,
        TypeDescriptor<sdkgenny::Class, "class">,
        TypeDescriptor<sdkgenny::Enum, "enum">,
        TypeDescriptor<sdkgenny::EnumClass, "enum_class">,
        TypeDescriptor<sdkgenny::Namespace, "namespace">,
        TypeDescriptor<sdkgenny::Reference, "reference">,
        TypeDescriptor<sdkgenny::Pointer, "pointer">,
        TypeDescriptor<sdkgenny::Variable, "variable">,
        TypeDescriptor<sdkgenny::Function, "function">,
        TypeDescriptor<sdkgenny::VirtualFunction, "virtual_function">,
        TypeDescriptor<sdkgenny::StaticFunction, "static_function">,
        TypeDescriptor<sdkgenny::Array, "array">,
        TypeDescriptor<sdkgenny::Parameter, "parameter">,
        TypeDescriptor<sdkgenny::Constant, "constant">>(sdkgenny);

    return 0;
}
}
```

`src/classes/Object.hpp`:

```hpp
#pragma once

struct lua_State;

namespace luagenny {
int open_object(lua_State* l);
} // namespace luagenny
```

`src/classes/Parameter.cpp`:

```cpp
extern "C" {
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>
}

#include <sol/sol.hpp>

#include "sdkgenny.hpp"
#include "ClassMacros.hpp"
#include "Parameter.hpp"

namespace luagenny {
int open_parameter(lua_State* l) {
    sol::table sdkgenny = sol::stack::pop<sol::table>(l);

    sdkgenny.new_usertype<sdkgenny::Parameter>("Parameter",
        sol::base_classes, sol::bases<sdkgenny::Object>(),
        MULTIFUNCTION(sdkgenny::Parameter, type, sdkgenny::Type*)
    );

    return 0;
}
}
```

`src/classes/Parameter.hpp`:

```hpp
#pragma once

struct lua_State;

namespace luagenny {
int open_parameter(lua_State* l);
} // namespace luagenny
```

`src/classes/Reference.cpp`:

```cpp
extern "C" {
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>
}

#include <sol/sol.hpp>

#include "sdkgenny.hpp"
#include "ClassMacros.hpp"
#include "Struct.hpp"

namespace luagenny {
int open_reference(lua_State* l) {
    sol::table sdkgenny = sol::stack::pop<sol::table>(l);

    sdkgenny.new_usertype<sdkgenny::Reference>("Reference",
        sol::base_classes, sol::bases<GENNY_TYPE_BASES>(),
        MULTIFUNCTION(sdkgenny::Reference, to, sdkgenny::Type*)
    );

    return 0;
}
}
```

`src/classes/Reference.hpp`:

```hpp
#pragma once

struct lua_State;

namespace luagenny {
int open_reference(lua_State* l);
} // namespace luagenny
```

`src/classes/Sdk.cpp`:

```cpp
extern "C" {
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>
}

#include <sol/sol.hpp>

#include "sdkgenny.hpp"
#include "ClassMacros.hpp"
#include "Struct.hpp"

namespace luagenny {
int open_sdk(lua_State* l) {
    sol::table sdkgenny = sol::stack::pop<sol::table>(l);

    sdkgenny.new_usertype<sdkgenny::Sdk>("Sdk",
        "global_ns", &sdkgenny::Sdk::global_ns,
        "preamble", &sdkgenny::Sdk::preamble,
        "postamble", &sdkgenny::Sdk::postamble,
        "include", &sdkgenny::Sdk::include,
        "include_local", &sdkgenny::Sdk::include_local,
        "generate", [](sdkgenny::Sdk& sdk, std::string p) {
            return sdk.generate(p);
        },
        MULTIFUNCTION(sdkgenny::Sdk, header_extension, std::string),
        MULTIFUNCTION(sdkgenny::Sdk, source_extension, std::string),
        MULTIFUNCTION(sdkgenny::Sdk, generate_namespaces, bool)
    );

    return 0;
}
}
```

`src/classes/Sdk.hpp`:

```hpp
#pragma once

struct lua_State;

namespace luagenny {
int open_sdk(lua_State* l);
} // namespace luagenny
```

`src/classes/Struct.cpp`:

```cpp
extern "C" {
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>
}

#include <sol/sol.hpp>

#include "sdkgenny.hpp"
#include "ClassMacros.hpp"
#include "Struct.hpp"

namespace luagenny {
template<size_t N>
struct String {
    constexpr String(const char (&str)[N]) {
        std::copy_n(str, N, value);
    }

    char value[N];
};

template<typename T, String Name>
struct STypeDescriptor {
    using Type = T;

    static T* find_in_parents(sdkgenny::Struct& s, std::string_view name, std::string_view target_name, bool include_self) {
        if (name == Name.value) {
            return s.find_in_parents<T>(target_name);
        }
        return nullptr;
    }

    static consteval std::string_view name() {
        return Name.value;
    }

    static constexpr auto find_in_parents_standalone = &sdkgenny::Struct::find_in_parents<T>;
};

template <typename ...Args> // args are TypeDescriptors
void create_bindings(sol::table sdkgenny) {
    auto object = sdkgenny.new_usertype<sdkgenny::Struct>("Struct",
        sol::base_classes, sol::bases<GENNY_TYPE_BASES>(),
        MULTIFUNCTION(sdkgenny::Struct, size, int),
        "parent", &sdkgenny::Struct::parent,
        "parents", &sdkgenny::Struct::parents,
        "variable", &sdkgenny::Struct::variable,
        "constant", &sdkgenny::Struct::constant,
        "struct", &sdkgenny::Struct::struct_,
        "class", &sdkgenny::Struct::class_,
        "enum", &sdkgenny::Struct::enum_,
        "enum_class", &sdkgenny::Struct::enum_class,
        "function", &sdkgenny::Struct::function,
        "virtual_function", &sdkgenny::Struct::virtual_function,
        "static_function", &sdkgenny::Struct::static_function,
        "bitfield", [] (sdkgenny::Struct& st, int offset, sol::this_state s) -> sol::table {
            auto bitfield_vars = st.bitfield(offset);
            sol::table result = sol::state_view(s).create_table();
            for (const auto& [bit_offset, var] : bitfield_vars) {
                result[bit_offset] = var;
            }
            return result;
        },
        "find_in_parents", [] (sol::this_state s, sdkgenny::Struct& st, const char* name, const char* target_name) -> sol::object {
            using ft = std::function<sol::object(sol::this_state s, sdkgenny::Struct&, std::string_view)>;
            static std::unordered_map<std::string, ft> find_in_parents_functions = []() {
                std::unordered_map<std::string, ft> find_in_parents_functions{};
                (find_in_parents_functions.emplace(Args::name().data(), [] (sol::this_state s, sdkgenny::Struct& st, std::string_view target_name) -> sol::object {
                    return sol::make_object(s, st.find_in_parents<typename Args::Type>(target_name));
                }), ...);

                return find_in_parents_functions;
            }();

            if (auto it = find_in_parents_functions.find(name); it != find_in_parents_functions.end()) {
                return it->second(s, st, target_name);
            }

            return sol::make_object(s, sol::lua_nil);
        }
    );

    (object.set(std::string("find_") + Args::name().data() + "_in_parents", Args::find_in_parents_standalone), ...);
}

int open_struct(lua_State* l) {
    sol::table sdkgenny = sol::stack::pop<sol::table>(l);

    create_bindings<
        STypeDescriptor<sdkgenny::Typename, "typename">,
        STypeDescriptor<sdkgenny::Type, "type">,
        STypeDescriptor<sdkgenny::GenericType, "generic_type">,
        STypeDescriptor<sdkgenny::Struct, "struct">,
        STypeDescriptor<sdkgenny::Class, "class">,
        STypeDescriptor<sdkgenny::Enum, "enum">,
        STypeDescriptor<sdkgenny::EnumClass, "enum_class">,
        STypeDescriptor<sdkgenny::Namespace, "namespace">,
        STypeDescriptor<sdkgenny::Reference, "reference">,
        STypeDescriptor<sdkgenny::Pointer, "pointer">,
        STypeDescriptor<sdkgenny::Variable, "variable">,
        STypeDescriptor<sdkgenny::Function, "function">,
        STypeDescriptor<sdkgenny::VirtualFunction, "virtual_function">,
        STypeDescriptor<sdkgenny::StaticFunction, "static_function">,
        STypeDescriptor<sdkgenny::Array, "array">,
        STypeDescriptor<sdkgenny::Parameter, "parameter">,
        STypeDescriptor<sdkgenny::Constant, "constant">>(sdkgenny);

    return 0;
}
}
```

`src/classes/Struct.hpp`:

```hpp
#pragma once

struct lua_State;

namespace luagenny {
int open_struct(lua_State* l);
} // namespace luagenny
```

`src/classes/Type.cpp`:

```cpp
extern "C" {
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>
}

#include <sol/sol.hpp>

#include "sdkgenny.hpp"
#include "ClassMacros.hpp"
#include "Type.hpp"

namespace luagenny {
int open_type(lua_State* l) {
    sol::table sdkgenny = sol::stack::pop<sol::table>(l);

    sdkgenny.new_usertype<sdkgenny::Type>("Type",
        sol::base_classes, sol::bases<GENNY_TYPENAME_BASES>(),
        MULTIFUNCTION(sdkgenny::Type, size, int),
        "ref", &sdkgenny::Type::ref,
        "ptr", &sdkgenny::Type::ptr,
        "array", &sdkgenny::Type::array_
    );

    return 0;
}
}
```

`src/classes/Type.hpp`:

```hpp
#pragma once

struct lua_State;

namespace luagenny {
int open_type(lua_State* l);
} // namespace luagenny
```

`src/classes/Typename.cpp`:

```cpp
extern "C" {
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>
}

#include <sol/sol.hpp>

#include "sdkgenny.hpp"
#include "ClassMacros.hpp"
#include "Typename.hpp"

namespace luagenny {
int open_typename(lua_State* l) {
    sol::table sdkgenny = sol::stack::pop<sol::table>(l);

    sdkgenny.new_usertype<sdkgenny::Typename>("Typename",
        sol::base_classes, sol::bases<sdkgenny::Object>(),
        MULTIFUNCTION(sdkgenny::Typename, simple_typename_generation, bool)
    );

    return 0;
}
}
```

`src/classes/Typename.hpp`:

```hpp
#pragma once

struct lua_State;

namespace luagenny {
int open_typename(lua_State* l);
} // namespace luagenny
```

`src/classes/Variable.cpp`:

```cpp
extern "C" {
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>
}

#include <sol/sol.hpp>

#include "sdkgenny.hpp"
#include "ClassMacros.hpp"
#include "Variable.hpp"

namespace luagenny {
int open_variable(lua_State* l) {
    sol::table sdkgenny = sol::stack::pop<sol::table>(l);

    sdkgenny.new_usertype<sdkgenny::Variable>("Variable",
        sol::base_classes, sol::bases<sdkgenny::Object>(),
        "type", [](sol::this_state s, sdkgenny::Variable& f, sol::object param) -> sol::object {
            if (param.is<sol::lua_nil_t>()) {
                return sol::make_object(s, f.type());
            }

            if (param.is<std::string>()) {
                return sol::make_object(s, f.type(param.as<std::string>()));
            }

            return sol::make_object(s, f.type(param.as<sdkgenny::Type*>()));
        },
        MULTIFUNCTION(sdkgenny::Variable, offset, int),
        "append", &sdkgenny::Variable::append,
        "end", &sdkgenny::Variable::end,

        MULTIFUNCTION(sdkgenny::Variable, bit_size, size_t),
        MULTIFUNCTION(sdkgenny::Variable, bit_offset, size_t),
        "is_bitfield", &sdkgenny::Variable::is_bitfield,
        "bit_append", &sdkgenny::Variable::bit_append
    );


    return 0;
}
}
```

`src/classes/Variable.hpp`:

```hpp
#pragma once

struct lua_State;

namespace luagenny {
int open_variable(lua_State* l);
} // namespace luagenny
```

`src/classes/VirtualFunction.cpp`:

```cpp
extern "C" {
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>
}

#include <sol/sol.hpp>

#include "sdkgenny.hpp"
#include "ClassMacros.hpp"
#include "VirtualFunction.hpp"

namespace luagenny {
int open_virtual_function(lua_State* l) {
    sol::table sdkgenny = sol::stack::pop<sol::table>(l);

    sdkgenny.new_usertype<sdkgenny::VirtualFunction>("VirtualFunction",
        sol::base_classes, sol::bases<sdkgenny::Function, sdkgenny::Object>(),
        MULTIFUNCTION(sdkgenny::VirtualFunction, vtable_index, int)
    );

    return 0;
}
}
```

`src/classes/VirtualFunction.hpp`:

```hpp
#pragma once

struct lua_State;

namespace luagenny {
int open_virtual_function(lua_State* l);
} // namespace luagenny
```

`test/Main.cpp`:

```cpp
#include <iostream>
#include <memory>

extern "C" {
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>
}
#include <sol/sol.hpp>

#if _MSC_VER == 1932 || _MSC_VER == 1933
#if _MSC_VER == 1932
#define _MSC_OLD_VER 1932
#endif

#if _MSC_VER == 1933
#define _MSC_OLD_VER 1933
#endif

#undef _MSC_VER
#define _MSC_VER 1919
#include <tao/pegtl/demangle.hpp>
#undef _MSC_VER
#define _MSC_VER _MSC_OLD_VER
#endif

#include <LuaGenny.h>

#include <sdkgenny_parser.hpp>

#pragma pack(push,1)
enum Place { EARTH = 1, MOON = 2, MARS = 3 };

struct Date {
    unsigned short nWeekDay : 3;
    unsigned short nMonthDay : 6;
    unsigned short nMonth : 5;
    unsigned short nYear : 8;
};

struct Foo {
    int a{};
    int b{};
    float c{};
    Place p{};
    int bf1 : 4;
    Place bf2 : 2;
    int rest : 26;
};

struct Bar {
    int d{};
    Foo* foo{};
    int m[4][3];
    union {
        Date date;
        unsigned int date_int{};
    };
};

struct Thing {
    int abc{};
};

struct RTTITest {
    virtual ~RTTITest(){};
};

struct A {
    virtual ~A() {}
};

struct B : A {
    virtual ~B() {}
};

struct C : B {
    virtual ~C() {}
};

struct D {
    virtual ~D() {}
};

struct E : C, D {
    virtual ~E() {}
};

struct Person {
    int age{20};
};

struct Student : Person {
    float gpa{3.9};
};

struct Faculty : Person {
    int wage{30000};
};

struct TA : Student, Faculty {
    int hours{40};
};

struct Baz : Bar {
    TA ta{};
    int e{};
    int thing{};
    int* f{};
    Foo g{};
    Thing* things{};
    char* hello{};
    wchar_t* wide_hello{};
    char intrusive_hello[32]{"hello, intrusive world!"};
    bool im_true{true};
    bool im_false{false};
    char im_also_true{7};
    __declspec(align(sizeof(void*))) RTTITest* rtti{};
    E* e_ptr{};
};
#pragma pack(pop)

constexpr auto gennyfile = R"(
type int 4 [[i32]]
type float 4 [[f32]]
type ushort 2 [[u16]]
type str 8 [[utf8*]]
type wstr 8 [[utf16*]]
type bool 1 [[bool]]
type uintptr_t 8 [[u64]]
type char 1
type wchar_t 2

struct RTTITest{}

enum Place {
    EARTH = 1,
    MOON = 2,
    MARS = 3,
}

struct Date {
    ushort nWeekDay : 3
    ushort nMonthDay : 6
    ushort nMonth : 5
    ushort nYear : 8
}

struct Foo {
    int a
    int b
    float c
    Place p
    Place bf1 : 4
    Place bf2 : 2
}

struct Bar {
    int d
    Foo* foo
    int[4][3] m
    Date date
}

struct Thing {
    int abc
}

struct Person {
    int age
}

struct Student : Person {
    float gpa
}

struct Faculty : Person {
    int wage
}

struct TA : Student, Faculty {
    int hours
}

struct Baz : Bar 0x100 {
	TA ta
    int e
    int thing
    int* f
    Foo g
    Thing* things
    char* hello [[utf8*]]
    //wchar_t* wide_hello [[utf16*]]
    //char[32] intrusive_hello [[utf8*]]
    bool im_true +40
    bool im_false
    bool im_also_true
	//RTTITest* test + 5
}

struct RTTITest 0x100 {
	uintptr_t** vtable
}
)";

std::unique_ptr<sdkgenny::Sdk> parse_gennyfile() {
    auto sdk = std::make_unique<sdkgenny::Sdk>();

    sdkgenny::parser::State s{};
    s.parents.push_back(sdk->global_ns());

    tao::pegtl::memory_input in{gennyfile, "text"};

    try {
        if (tao::pegtl::parse<sdkgenny::parser::Grammar, sdkgenny::parser::Action>(in, s)) {
        }
    } catch (const std::exception& e) {
        std::cout << "Error: " << e.what() << std::endl;
    } catch (...) {
        std::cout << "unknown error" << std::endl;
    }
    
    return sdk;
}

int main(int argc, char* argv[]) {
    bool performing_tests = false;
    std::string script_path{};

    if (argc >= 2) {
        performing_tests = std::string{argv[1]} == "--test";
        script_path = argv[2];
    }

    // Create a Lua state
    sol::state lua{};

    lua.open_libraries(sol::lib::base, sol::lib::package, sol::lib::string, sol::lib::math, sol::lib::table, sol::lib::bit32,
    sol::lib::utf8, sol::lib::os, sol::lib::coroutine);

    // Add the sdkgenny bindings
    luaopen_luagenny(lua);
    sol::table sdkgenny = sol::stack::pop<sol::table>(lua);
    lua["sdkgenny"] = sdkgenny;

    auto sdk = parse_gennyfile();
    lua["parsed"] = sdk.get();

    auto foo = new Foo{};
    foo->a = 42;
    foo->b = 1337;
    foo->c = 77.7f;
    foo->p = Place::MARS;
    foo->bf1 = Place::MOON;
    foo->bf2 = Place::MARS;
    foo->rest = 12345678;

    auto baz = new Baz{};
    baz->d = 123;
    baz->foo = foo;
    for (auto i = 0; i < 4; ++i) {
        for (auto j = 0; j < 3; ++j) {
            baz->m[i][j] = i + j;
        }
    }
    baz->date.nWeekDay = 1;
    baz->date.nMonthDay = 2;
    baz->date.nMonth = 3;
    baz->date.nYear = 4;
    baz->e = 666;
    baz->f = new int[10];
    for (auto i = 0; i < 10; ++i) {
        baz->f[i] = i;
    }
    baz->g = *foo;
    ++baz->g.a;
    ++baz->g.b;
    ++baz->g.c;
    baz->g.p = Place::MOON;
    baz->things = new Thing[10];
    for (auto i = 0; i < 10; ++i) {
        baz->things[i].abc = i * 2;
    }
    baz->hello = (char*)"Hello, world!";
    baz->wide_hello = (wchar_t*)L"Hello, wide world!";

    auto rtti = new RTTITest{};
    baz->rtti = rtti;
    baz->e_ptr = new E{};

    lua["bazaddr"] = (uintptr_t)baz;

    std::cout << "0x" << std::hex << (uintptr_t)baz << std::endl;
    int result = 1;

    if (!performing_tests) {
        std::string input{};

        while (true) {
            std::cout << "> ";
            std::getline(std::cin, input);

            const auto command = input.c_str();

            if (input == "quit") {
                break;
            } else {
                auto result = luaL_loadbuffer(lua, command, strlen(command), nullptr);

                if (result == LUA_OK) {
                    result = lua_pcall(lua, 0, LUA_MULTRET, 0);

                    if (result != LUA_OK) {
                        std::cout << "ERROR: " << luaL_checkstring(lua, -1) << std::endl;
                    }
                } else {
                    std::cout << "ERROR: " << luaL_checkstring(lua, -1) << std::endl;
                }
            }
        }
    } else {
        try {
            result = lua.script_file(script_path).get<bool>() ? 0 : 1;
        } catch (const std::exception& e) {
            std::cout << "Error: " << e.what() << std::endl;
        } catch (...) {
            std::cout << "unknown error" << std::endl;
        }

        if (result == 0) {
            std::cout << "Test passed!" << std::endl;
        } else {
            std::cout << "Test failed!" << std::endl;
        }
    }

    return result;
}
```

`test/test.lua`:

```lua
local test_start = os.clock()

baz = sdkgenny.StructOverlay(bazaddr, parsed:global_ns():find_struct("Baz"))
print(baz)
print(baz:type())
print(string.format("%x", baz:address()))

local bazstruct = baz:type()
print(bazstruct:name())

local function testcompare(x, name)
    for k, v in pairs(
    {
        "typename",
        "type",
        "generic_type",
        "struct",
        "class",
        "enum",
        "enum_class",
        "namespace",
        "reference",
        "pointer",
        "variable",
        "function",
        "virtual_function",
        "static_function",
        "array",
        "parameter",
        "constant"
    }
    ) do
        print(tostring(name or x) .. " == " .. tostring(v) .. ": " .. tostring(x["is_"..v](x)))
        --print(tostring(name or x) .. " == " .. tostring(v) .. ": " .. tostring(x:is_a(v)))
    end
end

testcompare(bazstruct, "bazstruct")

local test_count = 0

local function value_expect(x, expected, metadata)
    test_count = test_count + 1

    if not metadata then
        metadata = "test " .. tostring(test_count)
    end

    if x ~= expected then
        print("test " .. tostring(test_count) .. " failed " .. "[ " .. metadata .. " ]" .. ", got " .. tostring(x) .. ", expected " .. tostring(expected))
        return false
    end

    print("test " .. tostring(test_count) .. " passed " .. "[ " .. metadata .. " ] == " .. tostring(expected))
    return true
end

function do_tests()
    print("testing...")

    local round = function(val, dec)
        dec = dec or 1
        return math.floor(val * 10 ^ dec + 0.5) / 10 ^ dec
    end

    local results = {
        value_expect(bazstruct:name(), "Baz", "bazstruct:name()"),
        value_expect(bazstruct:is_a("struct"), true, "bazstruct:is_a(\"struct\")"),
        value_expect(bazstruct:is_a("type"), true, "bazstruct:is_a(\"type\")"),
        value_expect(bazstruct:is_struct(), true, "bazstruct:is_struct()"),
        value_expect(bazstruct:is_type(), true, "bazstruct:is_type()"),
        value_expect(baz.d, 123, "baz.d"),
        value_expect(baz.foo.a, 42, "baz.foo.a"),
        value_expect(baz.foo.b, 1337, "baz.foo.b"),
        value_expect(round(baz.foo.c, 1), 77.7, "round(baz.foo.c)"),
        value_expect(baz.g.a, 43, "baz.g.a"),
        value_expect(baz.g.b, 1338, "baz.g.b"),
        value_expect(round(baz.g.c, 1), 78.7, "round(baz.g.c)"),
        value_expect(baz.hello, "Hello, world!", "baz.hello"),
        value_expect(baz.e, 666, "baz.e"),
        value_expect(baz.ta.age, 20, "baz.ta.age"),
        value_expect(round(baz.ta.gpa, 1), 3.9, "baz.ta.gpa"),
        value_expect(baz.ta.wage, 30000, "baz.ta.wage"),
        value_expect(baz.ta.hours, 40, "baz.ta.hours"),
        value_expect(bazstruct:find_variable_in_parents("foo") ~= nil, true, "bazstruct:find_variable(\"foo\") ~= nil"),
        value_expect(bazstruct:find_variable_in_parents("foo"):name(), "foo", "bazstruct:find_variable(\"foo\"):name()"),
        value_expect(bazstruct:find_variable_in_parents("foo"):type():is_pointer(), true, "bazstruct:find_variable(\"foo\"):type():is_pointer()"),
        value_expect(bazstruct:find("variable", "e") ~= nil, true, "bazstruct:find(\"variable\", \"e\") ~= nil"),
        value_expect(bazstruct:find_variable("e") == bazstruct:find("variable", "e"), true, "bazstruct:find_variable(\"e\") == bazstruct:find(\"variable\", \"e\")"),
        value_expect(bazstruct:find_variable("e"):is_a("variable"), true, "bazstruct:find(\"variable\", \"e\"):is_a(\"variable\")"),
        value_expect(bazstruct:find_variable("e"):is_variable(), true, "bazstruct:find(\"variable\", \"e\"):is_variable()"),
        value_expect(bazstruct:find_variable("e"):as("variable") ~= nil, true, "bazstruct:find(\"variable\", \"e\"):as(\"variable\") ~= nil"),
        value_expect(bazstruct:find_variable("e"):as_variable() ~= nil, true, "bazstruct:find(\"variable\", \"e\"):as_variable() ~= nil"),
        value_expect(bazstruct:find_variable("e"):is_a("class"), false, "bazstruct:find(\"variable\", \"e\"):is_a(\"class\")"),
        value_expect(bazstruct:find_variable("e"):is_class(), false, "bazstruct:find(\"variable\", \"e\"):is_class()"),
        value_expect(bazstruct:find_variable("e"):as("class") == nil, true, "bazstruct:find(\"variable\", \"e\"):as(\"class\") == nil"),
        value_expect(bazstruct:find_variable("e"):as_class() == nil, true, "bazstruct:find(\"variable\", \"e\"):as_class() == nil"),
        value_expect(bazstruct:find_variable("e"):is_a("struct"), false, "bazstruct:find(\"variable\", \"e\"):is_a(\"struct\")"),
        value_expect(bazstruct:find_variable("e"):is_struct(), false, "bazstruct:find(\"variable\", \"e\"):is_struct()"),
        value_expect(bazstruct:find_variable("e"):as("struct") == nil, true, "bazstruct:find(\"variable\", \"e\"):as(\"struct\") == nil"),
        value_expect(bazstruct:find_variable("e"):as_struct() == nil, true, "bazstruct:find(\"variable\", \"e\"):as_struct() == nil"),
        value_expect(bazstruct:find_variable("e"):is_a("type"), false, "bazstruct:find(\"variable\", \"e\"):is_a(\"type\")"),
        value_expect(bazstruct:find_variable("e"):is_type(), false, "bazstruct:find(\"variable\", \"e\"):is_type()"),
        value_expect(bazstruct:find_variable("e"):as("type") == nil, true, "bazstruct:find(\"variable\", \"e\"):as(\"type\") == nil"),
        value_expect(bazstruct:find_variable("e"):as_type() == nil, true, "bazstruct:find(\"variable\", \"e\"):as_type() == nil"),
        value_expect(bazstruct:find_variable("e"):type() ~= nil, true, "bazstruct:find(\"variable\", \"e\"):type() ~= nil"),
        value_expect(bazstruct:find_variable("e"):type():is_a("type"), true, "bazstruct:find(\"variable\", \"e\"):type():is_a(\"type\")"),
        value_expect(bazstruct:find_variable("e"):type():is_type(), true, "bazstruct:find(\"variable\", \"e\"):type():is_type()"),
        value_expect(bazstruct:find_variable("e"):type():name() == "int", true, "bazstruct:find(\"variable\", \"e\"):type():name() == \"int\""),
        value_expect(bazstruct:find_variable("e"):type():metadata()[1] == "i32", true, "bazstruct:find(\"variable\", \"e\"):type():metadata()[0] == \"i32\""),
        value_expect(bazstruct:find_variable("not_real_var") == nil, true, "bazstruct:find(\"variable\", \"not_real_var\") == nil"),

        value_expect(bazstruct:find_variable("ta"):type():name() == "TA", true, "bazstruct:find(\"variable\", \"ta\"):type():name() == \"TA\""),
        value_expect(bazstruct:find_variable("ta"):type():as_struct() ~= nil, true, "bazstruct:find(\"variable\", \"ta\"):type():as_struct() ~= nil"),
        value_expect(bazstruct:find_variable("ta"):type():as_struct():parents()[1]:name() == "Student", true, "bazstruct:find(\"variable\", \"ta\"):type():as_struct():parents()[1]:name() == \"Student\""),
        value_expect(bazstruct:find_variable("ta"):type():as_struct():parents()[2]:name() == "Faculty", true, "bazstruct:find(\"variable\", \"ta\"):type():parents()[2]:name() == \"Faculty\""),
        value_expect(#bazstruct:find_variable("ta"):type():as_struct():parents()[1]:parents() == 1, true, "#bazstruct:find(\"variable\", \"ta\"):type():as_struct():parents()[1]:parents() == 1"),
        value_expect(bazstruct:find_variable("ta"):type():as_struct():parents()[1]:parents()[1]:name() == "Person", true, "bazstruct:find(\"variable\", \"ta\"):type():as_struct():parents()[1]:parents()[1]:name() == \"Person\""),
        value_expect(#bazstruct:find_variable("ta"):type():as_struct():parents()[1]:parents()[1]:parents(), 0, "#bazstruct:find(\"variable\", \"ta\"):type():as_struct():parents()[1]:parents()[1]:parents() == 0"),
        value_expect(bazstruct:find_variable("ta"):type():as_struct():parents()[1]:find_variable_in_parents("age") ~= nil, true, "bazstruct:find(\"variable\", \"ta\"):type():as_struct():parents()[1]:find_variable_in_parents(\"age\") ~= nil"),
        value_expect(bazstruct:find_variable("ta"):type():as_struct():parents()[1]:find_variable_in_parents("age"):name() == "age", true, "bazstruct:find(\"variable\", \"ta\"):type():as_struct():parents()[1]:find_variable_in_parents(\"age\"):name() == \"age\""),
        
        value_expect(baz.things:type():is_a("pointer"), true, "baz.things:type():is_a(\"pointer\")"),
        value_expect(baz.things:type():to():is_a("struct"), true, "baz.things:type():to():is_a(\"struct\")"),
        value_expect(baz.things:type():to():is_struct(), true, "baz.things:type():to():is_struct()"),
        value_expect(baz.things:type():name(), "Thing*", "baz.things:type():name()"),
    }

    --[[for i=0, 10000 do
        bazstruct:find_variable("e"):type():is_type()
    end]]

    for i=0, 10-1 do
        table.insert(results, value_expect(baz.things[i].abc, i * 2, "baz.things[" .. tostring(i) .. "].abc"))
    end

    table.insert(results, value_expect(baz.f:type():name(), "int*", "baz.f:type():name()"))
    table.insert(results, value_expect(baz.f:type():to():name(), "int", "baz.f:type():to():name()"))

    for i=0, 10-1 do
        table.insert(results, value_expect(baz.f[i], i, "baz.f[" .. tostring(i) .. "]"))
    end

    table.insert(results, value_expect(baz.f:deref() == baz.f[0], true, "baz.f:deref() == baz.f[0]"))

    local known_variables = bazstruct:get_all("variable")
    local known_variables2 = bazstruct:get_all_variable()

    table.insert(results, value_expect(#known_variables == #known_variables2, true, "#known_variables == #known_variables2"))

    table.insert(results, value_expect(known_variables ~= nil, true, "known_variables ~= nil"))
    table.insert(results, value_expect(#known_variables, 10, "#known_variables"))

    for k, v in pairs(known_variables) do
        table.insert(results, value_expect(known_variables[k] == known_variables2[k], true, "known_variables[" .. tostring(k) .. "] == known_variables2[" .. tostring(k) .. "]"))

        local mt = getmetatable(baz)
        local ok, val = pcall(mt.__index, baz, v:name())
        table.insert(results, value_expect(ok, true, "pcall baz." .. v:name()))
    end


    ----------------------------
    ------- write tests --------
    ----------------------------
    -- baz.g.a modification
    local old_baz_g_a = baz.g.a
    baz.g.a = baz.g.a + 1

    table.insert(results, value_expect(baz.g.a, old_baz_g_a + 1, "baz.g.a = baz.g.a + 1"))

    baz.g.a = old_baz_g_a

    table.insert(results, value_expect(baz.g.a, old_baz_g_a, "baz.g.a = old_baz_g_a"))

    -- baz.g.c modification (float/number)
    local old_baz_g_c = baz.g.c

    baz.g.c = baz.g.c + 13.337

    table.insert(results, value_expect(round(baz.g.c, 3), round(old_baz_g_c + 13.337, 3), "baz.g.c = baz.g.c + 13.337"))

    baz.g.c = old_baz_g_c

    table.insert(results, value_expect(round(baz.g.c, 3), round(old_baz_g_c, 3), "baz.g.c = old_baz_g_c"))

    -- TA age modification
    local old_ta_age = baz.ta.age
    baz.ta.age = baz.ta.age + 1

    table.insert(results, value_expect(baz.ta.age, old_ta_age + 1, "baz.ta.age = baz.ta.age + 1"))

    baz.ta.age = old_ta_age

    table.insert(results, value_expect(baz.ta.age, old_ta_age, "baz.ta.age = old_ta_age"))

    -- Testing writing to baz.f[i] (pointer to int array)
    for i=0, 10-1 do
        local old_baz_f_i = baz.f[i]
        baz.f[i] = baz.f[i] * 1337

        table.insert(results, value_expect(baz.f[i], old_baz_f_i * 1337, "baz.f[" .. tostring(i) .. "] = baz.f[" .. tostring(i) .. "] * 1337"))

        baz.f[i] = old_baz_f_i

        table.insert(results, value_expect(baz.f[i], old_baz_f_i, "baz.f[" .. tostring(i) .. "] = old_baz_f_i"))
    end

    -- Testing writing to baz.foo (pointer to structure)
    local old_foo_addr = baz.foo:ptr()
    baz.foo = 123456789

    table.insert(results, value_expect(baz.foo:ptr(), 123456789, "baz.foo = 123456789"))

    baz.foo = nil

    table.insert(results, value_expect(baz.foo:ptr(), 0, "baz.foo = nil (0)"))

    baz.foo = old_foo_addr

    table.insert(results, value_expect(baz.foo:ptr(), old_foo_addr, "baz.foo = old_foo_addr"))

    local total_passed = 0

    for k, v in pairs(results) do
        if v == false then
            print("Detected failure at test " .. tostring(k))
        else
            total_passed = total_passed + 1
        end
    end

    print(tostring(total_passed) .. " / " .. tostring(#results) .. " tests passed")

    return #results == total_passed
end

local retval = do_tests()

local time_elapsed = os.clock() - test_start

print("Tests took " .. tostring(time_elapsed) .. " seconds (" .. tostring(time_elapsed * 1000) .. "ms)")

local gen_start = os.clock()
parsed:generate("test/")

local gen_time = os.clock() - gen_start
print("Generation took " .. tostring(gen_time) .. " seconds (" .. tostring(gen_time * 1000) .. "ms)")

return retval
```

`vcpkg.json`:

```json
{
  "$cmkr": "This file is automatically generated from cmake.toml - DO NOT EDIT",
  "$cmkr-url": "https://github.com/build-cpp/cmkr",
  "$schema": "https://raw.githubusercontent.com/microsoft/vcpkg/master/scripts/vcpkg.schema.json",
  "dependencies": [
    "pegtl",
    "lua",
    "sol2"
  ],
  "description": "",
  "name": "luagenny",
  "version-string": ""
}

```