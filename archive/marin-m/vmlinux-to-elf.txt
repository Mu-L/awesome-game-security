Project Path: arc_marin-m_vmlinux-to-elf_dcmlso27

Source Tree:

```txt
arc_marin-m_vmlinux-to-elf_dcmlso27
├── LICENSE
├── README.md
├── pics
│   └── landing_illustration.png
├── pyproject.toml
├── uv.lock
└── vmlinux_to_elf
    ├── __init__.py
    ├── core
    │   ├── architecture_detecter.py
    │   ├── elf_symbolizer.py
    │   ├── kallsyms.py
    │   └── vmlinuz_decompressor.py
    ├── kernel_db
    │   ├── README.md
    │   ├── database.py
    │   └── database.sqlite3
    ├── scripts
    │   ├── kallsyms_finder.py
    │   ├── run_tests.py
    │   └── vmlinux_to_elf.py
    └── utils
        ├── __init__.py
        ├── elf.py
        ├── elf_tests
        │   ├── ls_arm32_le.elf
        │   ├── ls_mips32_be.elf
        │   ├── ls_mips32_le.elf
        │   ├── ls_mips64_be.elf
        │   ├── ls_renesas.elf
        │   ├── ls_x64.elf
        │   └── x86_shared_library.so
        ├── lz4_legacy.py
        └── pretty_print.py

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

```

`README.md`:

```md
# vmlinux-to-elf

This tool allows to obtain a fully analyzable .ELF file from a vmlinux/vmlinuz/bzImage/zImage kernel image (either a raw binary blob or a preexisting but stripped .ELF file), with recovered function and variable symbols.

<p align="center"><img src="https://raw.githubusercontent.com/marin-m/vmlinux-to-elf/master/pics/landing_illustration.png"></p>

For this, it scans your kernel for a kernel symbol table ([kallsyms](https://github.com/torvalds/linux/blob/master/kernel/kallsyms.c)), a compressed symbol table that is present in almost every kernel, mostly unaltered.

Because the concerned symbol table is originally compressed, it should recover strings that aren't visible in the original binary.

It produces an .ELF file that you can analyze using IDA Pro and Ghidra. This tool is hence useful for embedded systems reverse engineering.

Usage:
```bash
vmlinux-to-elf <input_kernel.bin> <output_kernel.elf>
```

Installation:
```bash
# With uv
sudo snap install --classic astral-uv
uv tool install vmlinux-to-elf

# Or with pipx
sudo apt install pipx
pipx install vmlinux-to-elf
```

Local development environment setup:
```bash
git clone git@github.com:marin-m/vmlinux-to-elf.git
cd vmlinux-to-elf
# With uv (creates ".venv", call "source .venv/bin/activate" to set up)
uv sync
# With uv, vmlinux-to-elf is callable system-wide (creates a symlink
# to the source in "~/.local/bin")
uv tool install -e .
# Or with pipx (vmlinux-to-elf is callable system wide)
pipx install -e .
```

## Features
* Take a raw binary blob or ELF kernel file as an input  [OK]
* Automatically detect and unpack the main compression formats used for the Linux kernel [OK]
* Find and extract the embedded kernel symbols table (kallsyms) from the input file  [OK]
* Infer the instruction set architecture, endianness, bit size, relying upon other things on common function prologue signatures [OK]
* Infer the entry point of the kernel from the symbols contained in the kallsyms table  [OK]
* Provide basic inference for the kernel base address  [OK] (for now, consider that it is the first "TEXT" symbol address of the binary with the lower 0xfff bits clear - seems to work well enough)
* Unpack certain types of Android `boot.img` files, starting with an `ANDROID!` or `UNCOMPRESSED_IMG` magic [OK]
* Produce an .ELF file fully analyzable with IDA Pro or Ghidra as an output  [OK]


## How does it work, really?

A brief history of the "kallsyms" symbol table can be found at the top of the "[kallsyms.py](vmlinux_to_elf/core/kallsyms.py)" file. Briefly, this was introduced circa 2004 in the Linux kernel in its current form and is used to print the "Kernel oops" messages, among other things.

It contains tuples of "symbol name", "symbol address", "symbol type" (symbol types being designated with a single letter in a fashion similar to the [`nm`](http://man7.org/linux/man-pages/man1/nm.1p.html) utility), this information being tightly packed with a simple compression algorithm.

The schema below displays how this information is serialized into the kernel, the offset of each respective structure being detected by `vmlinux-to-elf` through [heuristics](vmlinux_to_elf/core/kallsyms.py):

| Array name | Description | Sample contents |
| ---------- | ----------- | --------------- |
| `kallsyms_addresses` (or `kallsyms_offsets` + `kallsyms_relative_base`) |  The addresses (or offsets relative to a base, in recent kernels) of each symbol, as an array | `80 82 00 C0  80 82 00 C0  80 82 00 C0  0C 84 00 C0  B4 84 00 C0  5C 85 00 C0  60 85 00 C0  60 85 00 C0` ...
| `kallsyms_num_syms`      | The total number of symbols, as an integer (useful for checking for endianness, alignment, correct decoding of the symbols table) | `54 D4 00 00`
| `kallsyms_names`         | The compressed, length-separated symbol names themselves. Each byte in the compressed symbol strings references an index in the "kallsyms_token_index" array, that itself references the offset of a character or string fragment in the "kallsyms_token_table" array. | `09 54 64 6F  5F E1 F1 66  F5 25 05 54  F3 74 AB 74  0E 54 FF AB` ...
| `kallsyms_markers`       | A lookup table serving to find quickly the approximative offset of a compressed symbol name in "kallsyms_names": every 256 symbols, an offset to the concerned symbol in "kallsyms_names" is added as a long to this table. | `00 00 00 00  03 0C 00 00  0C 18 00 00  1B 24 00 00  0F 31 00 00  DA 3D 00 00  CF 4A 00 00` ...
| `kallsyms_seqs_of_names` | This lookup table (present in 6.2+ kernels only) contains an array sequence of packed 3-byte integers, where array indexes match the alphanumeric order for a given symbol name, and array values match the corresponding entry indexes in the `kallsyms_addresses` and `kallsyms_names` arrays
| `kallsyms_token_table`   | Null-terminated string fragments or characters that may be contained in kernel symbol names. This can contain at most 256 string fragments or characters. Indexes corresponding to ASCII code points which are actually used in any kernel symbol will correspond to the concerned ASCII character, other positions will contain a statistically chosen string fragment. This tool tries to heuristically find this array across the passed file first in order to find the `kallsyms` symbols table. | `73 69 00 67  70 00 74 74  00 79 6E 00  69 6E 74 5F  00 66 72 00  ` ...
| `kallsyms_token_index`   | 256 words, each mapping to the offsets of the characters or string fragments designated by their respective indexes in "kallsyms_token_table". |  `00 00 03 00  06 00 09 00  0C 00 11 00  14 00 1B 00  1E 00 22 00  2C 00 30 00  35 00 38 00` ...

These fields have variable alignment and field size. The field sizes may vary over architecture and kernel version too. For this reason, `vmlinux-to-elf` has been tested over a variety of cases.

OpenWRT [since 2013](https://git.openwrt.org/?p=openwrt/svn-archive/archive.git;a=commit;h=5317e9cb69bb42dee167e0552a5e1f01147ba072) has a [patch](https://github.com/openwrt-mirror/openwrt/blob/9b4650b/target/linux/generic/patches-4.4/203-kallsyms_uncompressed.patch) that removes compression over the `kallsyms` table by default (when building `kallsyms` has been enabled by the user). They do this in order to save space when re-compressing over the kernel using LZMA.

This means that the `kallsyms_token_table` and `kallsyms_token_address` entries disappear, and that the symbol names use plain text ASCII instead. This case is supported too.

In standard Linux 6.2 kernels, `kallsyms` arrays are encoded in the following order:

1. `kallsyms_addresses` (or `kallsyms_offsets` + `kallsyms_relative_base`)
2. `kallsyms_num_syms`
3. `kallsyms_names`
4. `kallsyms_markers`
5. `kallsyms_seqs_of_names` (6.2+ only)
6. `kallsyms_token_table`
7. `kallsyms_token_index`

For Linux 6.4+ kernels, this layout is changed to: 

1. `kallsyms_num_syms`
2. `kallsyms_names`
3. `kallsyms_markers`
4. `kallsyms_token_table`
5. `kallsyms_token_index`
6. `kallsyms_addresses` (or `kallsyms_offsets` + `kallsyms_relative_base`)
7. `kallsyms_seqs_of_names`

While these are parsed in the following order by `vmlinux-to-elf`'s parsing algorithm:

1. `kallsyms_token_table` (before-last structure)
2. `kallsyms_token_index` (last structure, forwards)
3. `kallsyms_markers` (backwards)
4. `kallsyms_names` (backwards again)
5. `kallsyms_num_syms` (backwards again)
6. `kallsyms_addresses` (or `kallsyms_offsets` + `kallsyms_relative_base`) (backwards again)

## Kernels support
It should support kernels from version 2.6.10 (December 2004), until the current 6.4 (as of August 2023). Only kernels explicitly configured without `CONFIG_KALLSYMS` should not be supported. If this kernel configuration variable was not set at build, then you will get: `KallsymsNotFoundException: No embedded symbol table found in this kernel`.

For raw kernels, the following architectures can be detected (using magics from [binwalk](https://github.com/ReFirmLabs/binwalk/blob/master/src/binwalk/magic/binarch)): MIPSEL, MIPSEB, ARMEL, ARMEB, PowerPC, SPARC, x86, x86-64, ARM64, MIPS64, SuperH, ARC.

The following kernel compression formats can be automatically detected: XZ, LZMA, GZip, BZ2, LZ4, LZO and Zstd.

## Advanced usage

You can also obtain a text-only output of the kernel's symbol names, addresses and types through using the `kallsyms-finder` utility, also bundled with this tool. The format of its output will be similar to the `/proc/kallsyms` procfs file.

Some parameters that should be automatically inferred by the tool (such as the instruction set or base address) may be overriden in case of issue. The full specification of the arguments allowing to do that is presented below:

```
$ vmlinux-to-elf -h
usage: vmlinux-to-elf [-h] [--e-machine DECIMAL_NUMBER] [--bit-size BIT_SIZE]
                      [--file-offset HEX_NUMBER] [--base-address HEX_NUMBER]
                      [--bss-size BSS_SIZE] [--use-absolute]
                      input_file output_file

Turn a raw or compressed kernel binary, or a kernel ELF without symbols, into a fully analyzable ELF whose symbols were extracted from the kernel symbol table

positional arguments:
  input_file            Path to the vmlinux/vmlinuz/zImage/bzImage/kernel.bin/kernel.elf file to make into an analyzable .ELF
  output_file           Path to the analyzable .ELF to output

options:
  -h, --help            show this help message and exit
  --e-machine DECIMAL_NUMBER
                        Force overriding the output ELF "e_machine" field with this integer value (rather than auto-detect)
  --bit-size BIT_SIZE   Force overriding the input kernel bit size, providing 32 or 64 bit (rather than auto-detect)
  --file-offset HEX_NUMBER
                        Consider that the raw kernel starts at this offset of the provided raw file or compressed stream (rather than 0, or the beginning of the ELF
                        sections if an ELF header was present in the input)
  --base-address HEX_NUMBER
                        Force overriding the output ELF base address field with this integer value (rather than auto-detect)
  --bss-size BSS_SIZE   Size in megabytes of the .bss section in the binary
  --use-absolute        Assume kallsyms offsets are absolute addresses

```

## Bug fixes, improvements, etc.

Don't hesitate to [open an issue](https://github.com/marin-m/vmlinux-to-elf/issues/new) for any suggestion of improvement.

Please privilege the current Github repository issues and pull requests in priority for reporting bugs, asking questions, etc.

Alternatively, you can use [this matrix channel](https://matrix.to/#/!ppalJoNacGRgESlXnK:matrix.org) if needing directly contact with the author of the project, but please reserve this as a secondary channel e.g for sending kernel samples, what goes here otherwise is more likely to be lost.


```

`pyproject.toml`:

```toml

[build-system]
requires = ["uv_build>=0.10.3,<0.11.0"]
build-backend = "uv_build"

[tool.uv.build-backend]
module-name = "vmlinux_to_elf"
module-root = ""

[project]
name = "vmlinux-to-elf"
version = "1.1.0"
dependencies = [
    "lz4>=4.4.5",
    "zstandard>=0.25.0",
    "minilzo>=1.2",
    "peewee>=4.0.0",
]
requires-python = ">=3.9"
authors = [{ name = "Marin Moulinier" }]
description = "A tool to recover a fully analyzable .ELF from a raw kernel, through extracting the kernel symbol table (kallsyms)"
readme = "README.md"
license = "GPL-3.0-or-later"
license-files = ["LICENSE"]

[project.urls]
Homepage = "https://github.com/marin-m/vmlinux-to-elf"
Repository = "https://github.com/marin-m/vmlinux-to-elf"
Issues = "https://github.com/marin-m/vmlinux-to-elf/issues"

[project.scripts]
kallsyms-finder = "vmlinux_to_elf.scripts.kallsyms_finder:main"
vmlinux-to-elf = "vmlinux_to_elf.scripts.vmlinux_to_elf:main"

[tool.ruff]
line-length = 79

[tool.ruff.format]
quote-style = "single"

```

`uv.lock`:

```lock
version = 1
revision = 3
requires-python = ">=3.9"

[[package]]
name = "lz4"
version = "4.4.5"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/57/51/f1b86d93029f418033dddf9b9f79c8d2641e7454080478ee2aab5123173e/lz4-4.4.5.tar.gz", hash = "sha256:5f0b9e53c1e82e88c10d7c180069363980136b9d7a8306c4dca4f760d60c39f0", size = 172886, upload-time = "2025-11-03T13:02:36.061Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/7b/45/2466d73d79e3940cad4b26761f356f19fd33f4409c96f100e01a5c566909/lz4-4.4.5-cp310-cp310-macosx_10_9_x86_64.whl", hash = "sha256:d221fa421b389ab2345640a508db57da36947a437dfe31aeddb8d5c7b646c22d", size = 207396, upload-time = "2025-11-03T13:01:24.965Z" },
    { url = "https://files.pythonhosted.org/packages/72/12/7da96077a7e8918a5a57a25f1254edaf76aefb457666fcc1066deeecd609/lz4-4.4.5-cp310-cp310-macosx_11_0_arm64.whl", hash = "sha256:7dc1e1e2dbd872f8fae529acd5e4839efd0b141eaa8ae7ce835a9fe80fbad89f", size = 207154, upload-time = "2025-11-03T13:01:26.922Z" },
    { url = "https://files.pythonhosted.org/packages/b8/0e/0fb54f84fd1890d4af5bc0a3c1fa69678451c1a6bd40de26ec0561bb4ec5/lz4-4.4.5-cp310-cp310-manylinux1_i686.manylinux_2_28_i686.manylinux_2_5_i686.whl", hash = "sha256:e928ec2d84dc8d13285b4a9288fd6246c5cde4f5f935b479f50d986911f085e3", size = 1291053, upload-time = "2025-11-03T13:01:28.396Z" },
    { url = "https://files.pythonhosted.org/packages/15/45/8ce01cc2715a19c9e72b0e423262072c17d581a8da56e0bd4550f3d76a79/lz4-4.4.5-cp310-cp310-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:daffa4807ef54b927451208f5f85750c545a4abbff03d740835fc444cd97f758", size = 1278586, upload-time = "2025-11-03T13:01:29.906Z" },
    { url = "https://files.pythonhosted.org/packages/6d/34/7be9b09015e18510a09b8d76c304d505a7cbc66b775ec0b8f61442316818/lz4-4.4.5-cp310-cp310-manylinux2014_x86_64.manylinux_2_17_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:2a2b7504d2dffed3fd19d4085fe1cc30cf221263fd01030819bdd8d2bb101cf1", size = 1367315, upload-time = "2025-11-03T13:01:31.054Z" },
    { url = "https://files.pythonhosted.org/packages/2a/94/52cc3ec0d41e8d68c985ec3b2d33631f281d8b748fb44955bc0384c2627b/lz4-4.4.5-cp310-cp310-win32.whl", hash = "sha256:0846e6e78f374156ccf21c631de80967e03cc3c01c373c665789dc0c5431e7fc", size = 88173, upload-time = "2025-11-03T13:01:32.643Z" },
    { url = "https://files.pythonhosted.org/packages/ca/35/c3c0bdc409f551404355aeeabc8da343577d0e53592368062e371a3620e1/lz4-4.4.5-cp310-cp310-win_amd64.whl", hash = "sha256:7c4e7c44b6a31de77d4dc9772b7d2561937c9588a734681f70ec547cfbc51ecd", size = 99492, upload-time = "2025-11-03T13:01:33.813Z" },
    { url = "https://files.pythonhosted.org/packages/1d/02/4d88de2f1e97f9d05fd3d278fe412b08969bc94ff34942f5a3f09318144a/lz4-4.4.5-cp310-cp310-win_arm64.whl", hash = "sha256:15551280f5656d2206b9b43262799c89b25a25460416ec554075a8dc568e4397", size = 91280, upload-time = "2025-11-03T13:01:35.081Z" },
    { url = "https://files.pythonhosted.org/packages/93/5b/6edcd23319d9e28b1bedf32768c3d1fd56eed8223960a2c47dacd2cec2af/lz4-4.4.5-cp311-cp311-macosx_10_9_x86_64.whl", hash = "sha256:d6da84a26b3aa5da13a62e4b89ab36a396e9327de8cd48b436a3467077f8ccd4", size = 207391, upload-time = "2025-11-03T13:01:36.644Z" },
    { url = "https://files.pythonhosted.org/packages/34/36/5f9b772e85b3d5769367a79973b8030afad0d6b724444083bad09becd66f/lz4-4.4.5-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:61d0ee03e6c616f4a8b69987d03d514e8896c8b1b7cc7598ad029e5c6aedfd43", size = 207146, upload-time = "2025-11-03T13:01:37.928Z" },
    { url = "https://files.pythonhosted.org/packages/04/f4/f66da5647c0d72592081a37c8775feacc3d14d2625bbdaabd6307c274565/lz4-4.4.5-cp311-cp311-manylinux1_i686.manylinux_2_28_i686.manylinux_2_5_i686.whl", hash = "sha256:33dd86cea8375d8e5dd001e41f321d0a4b1eb7985f39be1b6a4f466cd480b8a7", size = 1292623, upload-time = "2025-11-03T13:01:39.341Z" },
    { url = "https://files.pythonhosted.org/packages/85/fc/5df0f17467cdda0cad464a9197a447027879197761b55faad7ca29c29a04/lz4-4.4.5-cp311-cp311-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:609a69c68e7cfcfa9d894dc06be13f2e00761485b62df4e2472f1b66f7b405fb", size = 1279982, upload-time = "2025-11-03T13:01:40.816Z" },
    { url = "https://files.pythonhosted.org/packages/25/3b/b55cb577aa148ed4e383e9700c36f70b651cd434e1c07568f0a86c9d5fbb/lz4-4.4.5-cp311-cp311-manylinux2014_x86_64.manylinux_2_17_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:75419bb1a559af00250b8f1360d508444e80ed4b26d9d40ec5b09fe7875cb989", size = 1368674, upload-time = "2025-11-03T13:01:42.118Z" },
    { url = "https://files.pythonhosted.org/packages/fb/31/e97e8c74c59ea479598e5c55cbe0b1334f03ee74ca97726e872944ed42df/lz4-4.4.5-cp311-cp311-win32.whl", hash = "sha256:12233624f1bc2cebc414f9efb3113a03e89acce3ab6f72035577bc61b270d24d", size = 88168, upload-time = "2025-11-03T13:01:43.282Z" },
    { url = "https://files.pythonhosted.org/packages/18/47/715865a6c7071f417bef9b57c8644f29cb7a55b77742bd5d93a609274e7e/lz4-4.4.5-cp311-cp311-win_amd64.whl", hash = "sha256:8a842ead8ca7c0ee2f396ca5d878c4c40439a527ebad2b996b0444f0074ed004", size = 99491, upload-time = "2025-11-03T13:01:44.167Z" },
    { url = "https://files.pythonhosted.org/packages/14/e7/ac120c2ca8caec5c945e6356ada2aa5cfabd83a01e3170f264a5c42c8231/lz4-4.4.5-cp311-cp311-win_arm64.whl", hash = "sha256:83bc23ef65b6ae44f3287c38cbf82c269e2e96a26e560aa551735883388dcc4b", size = 91271, upload-time = "2025-11-03T13:01:45.016Z" },
    { url = "https://files.pythonhosted.org/packages/1b/ac/016e4f6de37d806f7cc8f13add0a46c9a7cfc41a5ddc2bc831d7954cf1ce/lz4-4.4.5-cp312-cp312-macosx_10_13_x86_64.whl", hash = "sha256:df5aa4cead2044bab83e0ebae56e0944cc7fcc1505c7787e9e1057d6d549897e", size = 207163, upload-time = "2025-11-03T13:01:45.895Z" },
    { url = "https://files.pythonhosted.org/packages/8d/df/0fadac6e5bd31b6f34a1a8dbd4db6a7606e70715387c27368586455b7fc9/lz4-4.4.5-cp312-cp312-macosx_11_0_arm64.whl", hash = "sha256:6d0bf51e7745484d2092b3a51ae6eb58c3bd3ce0300cf2b2c14f76c536d5697a", size = 207150, upload-time = "2025-11-03T13:01:47.205Z" },
    { url = "https://files.pythonhosted.org/packages/b7/17/34e36cc49bb16ca73fb57fbd4c5eaa61760c6b64bce91fcb4e0f4a97f852/lz4-4.4.5-cp312-cp312-manylinux1_i686.manylinux_2_28_i686.manylinux_2_5_i686.whl", hash = "sha256:7b62f94b523c251cf32aa4ab555f14d39bd1a9df385b72443fd76d7c7fb051f5", size = 1292045, upload-time = "2025-11-03T13:01:48.667Z" },
    { url = "https://files.pythonhosted.org/packages/90/1c/b1d8e3741e9fc89ed3b5f7ef5f22586c07ed6bb04e8343c2e98f0fa7ff04/lz4-4.4.5-cp312-cp312-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:2c3ea562c3af274264444819ae9b14dbbf1ab070aff214a05e97db6896c7597e", size = 1279546, upload-time = "2025-11-03T13:01:50.159Z" },
    { url = "https://files.pythonhosted.org/packages/55/d9/e3867222474f6c1b76e89f3bd914595af69f55bf2c1866e984c548afdc15/lz4-4.4.5-cp312-cp312-manylinux2014_x86_64.manylinux_2_17_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:24092635f47538b392c4eaeff14c7270d2c8e806bf4be2a6446a378591c5e69e", size = 1368249, upload-time = "2025-11-03T13:01:51.273Z" },
    { url = "https://files.pythonhosted.org/packages/b2/e7/d667d337367686311c38b580d1ca3d5a23a6617e129f26becd4f5dc458df/lz4-4.4.5-cp312-cp312-win32.whl", hash = "sha256:214e37cfe270948ea7eb777229e211c601a3e0875541c1035ab408fbceaddf50", size = 88189, upload-time = "2025-11-03T13:01:52.605Z" },
    { url = "https://files.pythonhosted.org/packages/a5/0b/a54cd7406995ab097fceb907c7eb13a6ddd49e0b231e448f1a81a50af65c/lz4-4.4.5-cp312-cp312-win_amd64.whl", hash = "sha256:713a777de88a73425cf08eb11f742cd2c98628e79a8673d6a52e3c5f0c116f33", size = 99497, upload-time = "2025-11-03T13:01:53.477Z" },
    { url = "https://files.pythonhosted.org/packages/6a/7e/dc28a952e4bfa32ca16fa2eb026e7a6ce5d1411fcd5986cd08c74ec187b9/lz4-4.4.5-cp312-cp312-win_arm64.whl", hash = "sha256:a88cbb729cc333334ccfb52f070463c21560fca63afcf636a9f160a55fac3301", size = 91279, upload-time = "2025-11-03T13:01:54.419Z" },
    { url = "https://files.pythonhosted.org/packages/2f/46/08fd8ef19b782f301d56a9ccfd7dafec5fd4fc1a9f017cf22a1accb585d7/lz4-4.4.5-cp313-cp313-macosx_10_13_x86_64.whl", hash = "sha256:6bb05416444fafea170b07181bc70640975ecc2a8c92b3b658c554119519716c", size = 207171, upload-time = "2025-11-03T13:01:56.595Z" },
    { url = "https://files.pythonhosted.org/packages/8f/3f/ea3334e59de30871d773963997ecdba96c4584c5f8007fd83cfc8f1ee935/lz4-4.4.5-cp313-cp313-macosx_11_0_arm64.whl", hash = "sha256:b424df1076e40d4e884cfcc4c77d815368b7fb9ebcd7e634f937725cd9a8a72a", size = 207163, upload-time = "2025-11-03T13:01:57.721Z" },
    { url = "https://files.pythonhosted.org/packages/41/7b/7b3a2a0feb998969f4793c650bb16eff5b06e80d1f7bff867feb332f2af2/lz4-4.4.5-cp313-cp313-manylinux1_i686.manylinux_2_28_i686.manylinux_2_5_i686.whl", hash = "sha256:216ca0c6c90719731c64f41cfbd6f27a736d7e50a10b70fad2a9c9b262ec923d", size = 1292136, upload-time = "2025-11-03T13:02:00.375Z" },
    { url = "https://files.pythonhosted.org/packages/89/d1/f1d259352227bb1c185288dd694121ea303e43404aa77560b879c90e7073/lz4-4.4.5-cp313-cp313-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:533298d208b58b651662dd972f52d807d48915176e5b032fb4f8c3b6f5fe535c", size = 1279639, upload-time = "2025-11-03T13:02:01.649Z" },
    { url = "https://files.pythonhosted.org/packages/d2/fb/ba9256c48266a09012ed1d9b0253b9aa4fe9cdff094f8febf5b26a4aa2a2/lz4-4.4.5-cp313-cp313-manylinux2014_x86_64.manylinux_2_17_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:451039b609b9a88a934800b5fc6ee401c89ad9c175abf2f4d9f8b2e4ef1afc64", size = 1368257, upload-time = "2025-11-03T13:02:03.35Z" },
    { url = "https://files.pythonhosted.org/packages/a5/6d/dee32a9430c8b0e01bbb4537573cabd00555827f1a0a42d4e24ca803935c/lz4-4.4.5-cp313-cp313-win32.whl", hash = "sha256:a5f197ffa6fc0e93207b0af71b302e0a2f6f29982e5de0fbda61606dd3a55832", size = 88191, upload-time = "2025-11-03T13:02:04.406Z" },
    { url = "https://files.pythonhosted.org/packages/18/e0/f06028aea741bbecb2a7e9648f4643235279a770c7ffaf70bd4860c73661/lz4-4.4.5-cp313-cp313-win_amd64.whl", hash = "sha256:da68497f78953017deb20edff0dba95641cc86e7423dfadf7c0264e1ac60dc22", size = 99502, upload-time = "2025-11-03T13:02:05.886Z" },
    { url = "https://files.pythonhosted.org/packages/61/72/5bef44afb303e56078676b9f2486f13173a3c1e7f17eaac1793538174817/lz4-4.4.5-cp313-cp313-win_arm64.whl", hash = "sha256:c1cfa663468a189dab510ab231aad030970593f997746d7a324d40104db0d0a9", size = 91285, upload-time = "2025-11-03T13:02:06.77Z" },
    { url = "https://files.pythonhosted.org/packages/49/55/6a5c2952971af73f15ed4ebfdd69774b454bd0dc905b289082ca8664fba1/lz4-4.4.5-cp313-cp313t-macosx_10_13_x86_64.whl", hash = "sha256:67531da3b62f49c939e09d56492baf397175ff39926d0bd5bd2d191ac2bff95f", size = 207348, upload-time = "2025-11-03T13:02:08.117Z" },
    { url = "https://files.pythonhosted.org/packages/4e/d7/fd62cbdbdccc35341e83aabdb3f6d5c19be2687d0a4eaf6457ddf53bba64/lz4-4.4.5-cp313-cp313t-macosx_11_0_arm64.whl", hash = "sha256:a1acbbba9edbcbb982bc2cac5e7108f0f553aebac1040fbec67a011a45afa1ba", size = 207340, upload-time = "2025-11-03T13:02:09.152Z" },
    { url = "https://files.pythonhosted.org/packages/77/69/225ffadaacb4b0e0eb5fd263541edd938f16cd21fe1eae3cd6d5b6a259dc/lz4-4.4.5-cp313-cp313t-manylinux1_i686.manylinux_2_28_i686.manylinux_2_5_i686.whl", hash = "sha256:a482eecc0b7829c89b498fda883dbd50e98153a116de612ee7c111c8bcf82d1d", size = 1293398, upload-time = "2025-11-03T13:02:10.272Z" },
    { url = "https://files.pythonhosted.org/packages/c6/9e/2ce59ba4a21ea5dc43460cba6f34584e187328019abc0e66698f2b66c881/lz4-4.4.5-cp313-cp313t-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:e099ddfaa88f59dd8d36c8a3c66bd982b4984edf127eb18e30bb49bdba68ce67", size = 1281209, upload-time = "2025-11-03T13:02:12.091Z" },
    { url = "https://files.pythonhosted.org/packages/80/4f/4d946bd1624ec229b386a3bc8e7a85fa9a963d67d0a62043f0af0978d3da/lz4-4.4.5-cp313-cp313t-manylinux2014_x86_64.manylinux_2_17_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:a2af2897333b421360fdcce895c6f6281dc3fab018d19d341cf64d043fc8d90d", size = 1369406, upload-time = "2025-11-03T13:02:13.683Z" },
    { url = "https://files.pythonhosted.org/packages/02/a2/d429ba4720a9064722698b4b754fb93e42e625f1318b8fe834086c7c783b/lz4-4.4.5-cp313-cp313t-win32.whl", hash = "sha256:66c5de72bf4988e1b284ebdd6524c4bead2c507a2d7f172201572bac6f593901", size = 88325, upload-time = "2025-11-03T13:02:14.743Z" },
    { url = "https://files.pythonhosted.org/packages/4b/85/7ba10c9b97c06af6c8f7032ec942ff127558863df52d866019ce9d2425cf/lz4-4.4.5-cp313-cp313t-win_amd64.whl", hash = "sha256:cdd4bdcbaf35056086d910d219106f6a04e1ab0daa40ec0eeef1626c27d0fddb", size = 99643, upload-time = "2025-11-03T13:02:15.978Z" },
    { url = "https://files.pythonhosted.org/packages/77/4d/a175459fb29f909e13e57c8f475181ad8085d8d7869bd8ad99033e3ee5fa/lz4-4.4.5-cp313-cp313t-win_arm64.whl", hash = "sha256:28ccaeb7c5222454cd5f60fcd152564205bcb801bd80e125949d2dfbadc76bbd", size = 91504, upload-time = "2025-11-03T13:02:17.313Z" },
    { url = "https://files.pythonhosted.org/packages/63/9c/70bdbdb9f54053a308b200b4678afd13efd0eafb6ddcbb7f00077213c2e5/lz4-4.4.5-cp314-cp314-macosx_10_15_x86_64.whl", hash = "sha256:c216b6d5275fc060c6280936bb3bb0e0be6126afb08abccde27eed23dead135f", size = 207586, upload-time = "2025-11-03T13:02:18.263Z" },
    { url = "https://files.pythonhosted.org/packages/b6/cb/bfead8f437741ce51e14b3c7d404e3a1f6b409c440bad9b8f3945d4c40a7/lz4-4.4.5-cp314-cp314-macosx_11_0_arm64.whl", hash = "sha256:c8e71b14938082ebaf78144f3b3917ac715f72d14c076f384a4c062df96f9df6", size = 207161, upload-time = "2025-11-03T13:02:19.286Z" },
    { url = "https://files.pythonhosted.org/packages/e7/18/b192b2ce465dfbeabc4fc957ece7a1d34aded0d95a588862f1c8a86ac448/lz4-4.4.5-cp314-cp314-manylinux1_i686.manylinux_2_28_i686.manylinux_2_5_i686.whl", hash = "sha256:9b5e6abca8df9f9bdc5c3085f33ff32cdc86ed04c65e0355506d46a5ac19b6e9", size = 1292415, upload-time = "2025-11-03T13:02:20.829Z" },
    { url = "https://files.pythonhosted.org/packages/67/79/a4e91872ab60f5e89bfad3e996ea7dc74a30f27253faf95865771225ccba/lz4-4.4.5-cp314-cp314-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:3b84a42da86e8ad8537aabef062e7f661f4a877d1c74d65606c49d835d36d668", size = 1279920, upload-time = "2025-11-03T13:02:22.013Z" },
    { url = "https://files.pythonhosted.org/packages/f1/01/d52c7b11eaa286d49dae619c0eec4aabc0bf3cda7a7467eb77c62c4471f3/lz4-4.4.5-cp314-cp314-manylinux2014_x86_64.manylinux_2_17_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:0bba042ec5a61fa77c7e380351a61cb768277801240249841defd2ff0a10742f", size = 1368661, upload-time = "2025-11-03T13:02:23.208Z" },
    { url = "https://files.pythonhosted.org/packages/f7/da/137ddeea14c2cb86864838277b2607d09f8253f152156a07f84e11768a28/lz4-4.4.5-cp314-cp314-win32.whl", hash = "sha256:bd85d118316b53ed73956435bee1997bd06cc66dd2fa74073e3b1322bd520a67", size = 90139, upload-time = "2025-11-03T13:02:24.301Z" },
    { url = "https://files.pythonhosted.org/packages/18/2c/8332080fd293f8337779a440b3a143f85e374311705d243439a3349b81ad/lz4-4.4.5-cp314-cp314-win_amd64.whl", hash = "sha256:92159782a4502858a21e0079d77cdcaade23e8a5d252ddf46b0652604300d7be", size = 101497, upload-time = "2025-11-03T13:02:25.187Z" },
    { url = "https://files.pythonhosted.org/packages/ca/28/2635a8141c9a4f4bc23f5135a92bbcf48d928d8ca094088c962df1879d64/lz4-4.4.5-cp314-cp314-win_arm64.whl", hash = "sha256:d994b87abaa7a88ceb7a37c90f547b8284ff9da694e6afcfaa8568d739faf3f7", size = 93812, upload-time = "2025-11-03T13:02:26.133Z" },
    { url = "https://files.pythonhosted.org/packages/da/34/508f2ee73c126e4de53a3b8523ad14d666aeb00a6795425315f770dbf2f4/lz4-4.4.5-cp39-cp39-macosx_10_9_x86_64.whl", hash = "sha256:f6538aaaedd091d6e5abdaa19b99e6e82697d67518f114721b5248709b639fad", size = 207384, upload-time = "2025-11-03T13:02:27.043Z" },
    { url = "https://files.pythonhosted.org/packages/64/84/da7fda86dcc7b6d40d45dd28201fc136adfc390815126db41411bf1e5205/lz4-4.4.5-cp39-cp39-macosx_11_0_arm64.whl", hash = "sha256:13254bd78fef50105872989a2dc3418ff09aefc7d0765528adc21646a7288294", size = 207137, upload-time = "2025-11-03T13:02:28.021Z" },
    { url = "https://files.pythonhosted.org/packages/01/95/fb9c5bffed0f985eab70daf2087a94ad55cbbf83024175f39ff663f48b22/lz4-4.4.5-cp39-cp39-manylinux1_i686.manylinux_2_28_i686.manylinux_2_5_i686.whl", hash = "sha256:e64e61f29cf95afb43549063d8433b46352baf0c8a70aa45e2585618fcf59d86", size = 1290508, upload-time = "2025-11-03T13:02:29.485Z" },
    { url = "https://files.pythonhosted.org/packages/57/6e/6a39b5ca9b9538cc9d61248c431065ad76cc0f10b40cb07d60b5bdde7750/lz4-4.4.5-cp39-cp39-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:ff1b50aeeec64df5603f17984e4b5be6166058dcf8f1e26a3da40d7a0f6ab547", size = 1278102, upload-time = "2025-11-03T13:02:30.878Z" },
    { url = "https://files.pythonhosted.org/packages/73/57/551a7f95825c9721d8bee4ec02d8b139b1a44796e63d09a737ca0d67b6b1/lz4-4.4.5-cp39-cp39-manylinux2014_x86_64.manylinux_2_17_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:1dd4d91d25937c2441b9fc0f4af01704a2d09f30a38c5798bc1d1b5a15ec9581", size = 1366651, upload-time = "2025-11-03T13:02:32.31Z" },
    { url = "https://files.pythonhosted.org/packages/4f/85/daa1ae5695ce40924813257d7f5a8990ba5dd78a9170f912dd85c498f97c/lz4-4.4.5-cp39-cp39-win32.whl", hash = "sha256:d64141085864918392c3159cdad15b102a620a67975c786777874e1e90ef15ce", size = 88165, upload-time = "2025-11-03T13:02:33.413Z" },
    { url = "https://files.pythonhosted.org/packages/df/db/3e84e506fdd5e04c9e8564d30bb08b0f3103dd9a2fb863c86bd46accb99a/lz4-4.4.5-cp39-cp39-win_amd64.whl", hash = "sha256:f32b9e65d70f3684532358255dc053f143835c5f5991e28a5ac4c93ce94b9ea7", size = 99487, upload-time = "2025-11-03T13:02:34.246Z" },
    { url = "https://files.pythonhosted.org/packages/6a/85/40aa9d006fdebc4ae868c86ce2108a9453c2b524284817427de1284b5b00/lz4-4.4.5-cp39-cp39-win_arm64.whl", hash = "sha256:f9b8bde9909a010c75b3aea58ec3910393b758f3c219beed67063693df854db0", size = 91275, upload-time = "2025-11-03T13:02:35.117Z" },
]

[[package]]
name = "minilzo"
version = "1.2"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/9f/cf/70409b35fbd32f5456fe72f410bf5fb30e279d3226e8a2228f11daede5f7/minilzo-1.2.tar.gz", hash = "sha256:4cdcc0dc3e8558a29d8a6fed5c66a1ae3c8014e12d0a27554890c4248f76b141", size = 76563, upload-time = "2025-06-07T19:55:55.251Z" }

[[package]]
name = "peewee"
version = "4.0.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/37/e3/98ed8ab20f26d429f61b3d5d455c52ac88ba343444fbcf7154374111eb3e/peewee-4.0.0.tar.gz", hash = "sha256:bc2722abf32a8074362c346fc8a95f2d34a9587873e81025b6429676c32044b6", size = 686951, upload-time = "2026-02-20T15:38:50.312Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/39/40/89664cce41f4bedab105d705885cbb152d7bd85ce0facbf0ec02e90eb02a/peewee-4.0.0-py3-none-any.whl", hash = "sha256:6de14ff11ab50c3152dc1d4e12628c1b28c1e03ff4e4213e463429bfcd7340b6", size = 139317, upload-time = "2026-02-20T15:38:48.519Z" },
]

[[package]]
name = "vmlinux-to-elf"
version = "1.0"
source = { editable = "." }
dependencies = [
    { name = "lz4" },
    { name = "minilzo" },
    { name = "peewee" },
    { name = "zstandard" },
]

[package.metadata]
requires-dist = [
    { name = "lz4", specifier = ">=4.4.5" },
    { name = "minilzo", specifier = ">=1.2" },
    { name = "peewee", specifier = ">=4.0.0" },
    { name = "zstandard", specifier = ">=0.25.0" },
]

[[package]]
name = "zstandard"
version = "0.25.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/fd/aa/3e0508d5a5dd96529cdc5a97011299056e14c6505b678fd58938792794b1/zstandard-0.25.0.tar.gz", hash = "sha256:7713e1179d162cf5c7906da876ec2ccb9c3a9dcbdffef0cc7f70c3667a205f0b", size = 711513, upload-time = "2025-09-14T22:15:54.002Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/56/7a/28efd1d371f1acd037ac64ed1c5e2b41514a6cc937dd6ab6a13ab9f0702f/zstandard-0.25.0-cp310-cp310-macosx_10_9_x86_64.whl", hash = "sha256:e59fdc271772f6686e01e1b3b74537259800f57e24280be3f29c8a0deb1904dd", size = 795256, upload-time = "2025-09-14T22:15:56.415Z" },
    { url = "https://files.pythonhosted.org/packages/96/34/ef34ef77f1ee38fc8e4f9775217a613b452916e633c4f1d98f31db52c4a5/zstandard-0.25.0-cp310-cp310-macosx_11_0_arm64.whl", hash = "sha256:4d441506e9b372386a5271c64125f72d5df6d2a8e8a2a45a0ae09b03cb781ef7", size = 640565, upload-time = "2025-09-14T22:15:58.177Z" },
    { url = "https://files.pythonhosted.org/packages/9d/1b/4fdb2c12eb58f31f28c4d28e8dc36611dd7205df8452e63f52fb6261d13e/zstandard-0.25.0-cp310-cp310-manylinux2010_i686.manylinux2014_i686.manylinux_2_12_i686.manylinux_2_17_i686.whl", hash = "sha256:ab85470ab54c2cb96e176f40342d9ed41e58ca5733be6a893b730e7af9c40550", size = 5345306, upload-time = "2025-09-14T22:16:00.165Z" },
    { url = "https://files.pythonhosted.org/packages/73/28/a44bdece01bca027b079f0e00be3b6bd89a4df180071da59a3dd7381665b/zstandard-0.25.0-cp310-cp310-manylinux2014_aarch64.manylinux_2_17_aarch64.whl", hash = "sha256:e05ab82ea7753354bb054b92e2f288afb750e6b439ff6ca78af52939ebbc476d", size = 5055561, upload-time = "2025-09-14T22:16:02.22Z" },
    { url = "https://files.pythonhosted.org/packages/e9/74/68341185a4f32b274e0fc3410d5ad0750497e1acc20bd0f5b5f64ce17785/zstandard-0.25.0-cp310-cp310-manylinux2014_ppc64le.manylinux_2_17_ppc64le.whl", hash = "sha256:78228d8a6a1c177a96b94f7e2e8d012c55f9c760761980da16ae7546a15a8e9b", size = 5402214, upload-time = "2025-09-14T22:16:04.109Z" },
    { url = "https://files.pythonhosted.org/packages/8b/67/f92e64e748fd6aaffe01e2b75a083c0c4fd27abe1c8747fee4555fcee7dd/zstandard-0.25.0-cp310-cp310-manylinux2014_s390x.manylinux_2_17_s390x.whl", hash = "sha256:2b6bd67528ee8b5c5f10255735abc21aa106931f0dbaf297c7be0c886353c3d0", size = 5449703, upload-time = "2025-09-14T22:16:06.312Z" },
    { url = "https://files.pythonhosted.org/packages/fd/e5/6d36f92a197c3c17729a2125e29c169f460538a7d939a27eaaa6dcfcba8e/zstandard-0.25.0-cp310-cp310-manylinux2014_x86_64.manylinux_2_17_x86_64.whl", hash = "sha256:4b6d83057e713ff235a12e73916b6d356e3084fd3d14ced499d84240f3eecee0", size = 5556583, upload-time = "2025-09-14T22:16:08.457Z" },
    { url = "https://files.pythonhosted.org/packages/d7/83/41939e60d8d7ebfe2b747be022d0806953799140a702b90ffe214d557638/zstandard-0.25.0-cp310-cp310-musllinux_1_1_aarch64.whl", hash = "sha256:9174f4ed06f790a6869b41cba05b43eeb9a35f8993c4422ab853b705e8112bbd", size = 5045332, upload-time = "2025-09-14T22:16:10.444Z" },
    { url = "https://files.pythonhosted.org/packages/b3/87/d3ee185e3d1aa0133399893697ae91f221fda79deb61adbe998a7235c43f/zstandard-0.25.0-cp310-cp310-musllinux_1_1_x86_64.whl", hash = "sha256:25f8f3cd45087d089aef5ba3848cd9efe3ad41163d3400862fb42f81a3a46701", size = 5572283, upload-time = "2025-09-14T22:16:12.128Z" },
    { url = "https://files.pythonhosted.org/packages/0a/1d/58635ae6104df96671076ac7d4ae7816838ce7debd94aecf83e30b7121b0/zstandard-0.25.0-cp310-cp310-musllinux_1_2_aarch64.whl", hash = "sha256:3756b3e9da9b83da1796f8809dd57cb024f838b9eeafde28f3cb472012797ac1", size = 4959754, upload-time = "2025-09-14T22:16:14.225Z" },
    { url = "https://files.pythonhosted.org/packages/75/d6/57e9cb0a9983e9a229dd8fd2e6e96593ef2aa82a3907188436f22b111ccd/zstandard-0.25.0-cp310-cp310-musllinux_1_2_i686.whl", hash = "sha256:81dad8d145d8fd981b2962b686b2241d3a1ea07733e76a2f15435dfb7fb60150", size = 5266477, upload-time = "2025-09-14T22:16:16.343Z" },
    { url = "https://files.pythonhosted.org/packages/d1/a9/ee891e5edf33a6ebce0a028726f0bbd8567effe20fe3d5808c42323e8542/zstandard-0.25.0-cp310-cp310-musllinux_1_2_ppc64le.whl", hash = "sha256:a5a419712cf88862a45a23def0ae063686db3d324cec7edbe40509d1a79a0aab", size = 5440914, upload-time = "2025-09-14T22:16:18.453Z" },
    { url = "https://files.pythonhosted.org/packages/58/08/a8522c28c08031a9521f27abc6f78dbdee7312a7463dd2cfc658b813323b/zstandard-0.25.0-cp310-cp310-musllinux_1_2_s390x.whl", hash = "sha256:e7360eae90809efd19b886e59a09dad07da4ca9ba096752e61a2e03c8aca188e", size = 5819847, upload-time = "2025-09-14T22:16:20.559Z" },
    { url = "https://files.pythonhosted.org/packages/6f/11/4c91411805c3f7b6f31c60e78ce347ca48f6f16d552fc659af6ec3b73202/zstandard-0.25.0-cp310-cp310-musllinux_1_2_x86_64.whl", hash = "sha256:75ffc32a569fb049499e63ce68c743155477610532da1eb38e7f24bf7cd29e74", size = 5363131, upload-time = "2025-09-14T22:16:22.206Z" },
    { url = "https://files.pythonhosted.org/packages/ef/d6/8c4bd38a3b24c4c7676a7a3d8de85d6ee7a983602a734b9f9cdefb04a5d6/zstandard-0.25.0-cp310-cp310-win32.whl", hash = "sha256:106281ae350e494f4ac8a80470e66d1fe27e497052c8d9c3b95dc4cf1ade81aa", size = 436469, upload-time = "2025-09-14T22:16:25.002Z" },
    { url = "https://files.pythonhosted.org/packages/93/90/96d50ad417a8ace5f841b3228e93d1bb13e6ad356737f42e2dde30d8bd68/zstandard-0.25.0-cp310-cp310-win_amd64.whl", hash = "sha256:ea9d54cc3d8064260114a0bbf3479fc4a98b21dffc89b3459edd506b69262f6e", size = 506100, upload-time = "2025-09-14T22:16:23.569Z" },
    { url = "https://files.pythonhosted.org/packages/2a/83/c3ca27c363d104980f1c9cee1101cc8ba724ac8c28a033ede6aab89585b1/zstandard-0.25.0-cp311-cp311-macosx_10_9_x86_64.whl", hash = "sha256:933b65d7680ea337180733cf9e87293cc5500cc0eb3fc8769f4d3c88d724ec5c", size = 795254, upload-time = "2025-09-14T22:16:26.137Z" },
    { url = "https://files.pythonhosted.org/packages/ac/4d/e66465c5411a7cf4866aeadc7d108081d8ceba9bc7abe6b14aa21c671ec3/zstandard-0.25.0-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:a3f79487c687b1fc69f19e487cd949bf3aae653d181dfb5fde3bf6d18894706f", size = 640559, upload-time = "2025-09-14T22:16:27.973Z" },
    { url = "https://files.pythonhosted.org/packages/12/56/354fe655905f290d3b147b33fe946b0f27e791e4b50a5f004c802cb3eb7b/zstandard-0.25.0-cp311-cp311-manylinux2010_i686.manylinux2014_i686.manylinux_2_12_i686.manylinux_2_17_i686.whl", hash = "sha256:0bbc9a0c65ce0eea3c34a691e3c4b6889f5f3909ba4822ab385fab9057099431", size = 5348020, upload-time = "2025-09-14T22:16:29.523Z" },
    { url = "https://files.pythonhosted.org/packages/3b/13/2b7ed68bd85e69a2069bcc72141d378f22cae5a0f3b353a2c8f50ef30c1b/zstandard-0.25.0-cp311-cp311-manylinux2014_aarch64.manylinux_2_17_aarch64.whl", hash = "sha256:01582723b3ccd6939ab7b3a78622c573799d5d8737b534b86d0e06ac18dbde4a", size = 5058126, upload-time = "2025-09-14T22:16:31.811Z" },
    { url = "https://files.pythonhosted.org/packages/c9/dd/fdaf0674f4b10d92cb120ccff58bbb6626bf8368f00ebfd2a41ba4a0dc99/zstandard-0.25.0-cp311-cp311-manylinux2014_ppc64le.manylinux_2_17_ppc64le.whl", hash = "sha256:5f1ad7bf88535edcf30038f6919abe087f606f62c00a87d7e33e7fc57cb69fcc", size = 5405390, upload-time = "2025-09-14T22:16:33.486Z" },
    { url = "https://files.pythonhosted.org/packages/0f/67/354d1555575bc2490435f90d67ca4dd65238ff2f119f30f72d5cde09c2ad/zstandard-0.25.0-cp311-cp311-manylinux2014_s390x.manylinux_2_17_s390x.whl", hash = "sha256:06acb75eebeedb77b69048031282737717a63e71e4ae3f77cc0c3b9508320df6", size = 5452914, upload-time = "2025-09-14T22:16:35.277Z" },
    { url = "https://files.pythonhosted.org/packages/bb/1f/e9cfd801a3f9190bf3e759c422bbfd2247db9d7f3d54a56ecde70137791a/zstandard-0.25.0-cp311-cp311-manylinux2014_x86_64.manylinux_2_17_x86_64.whl", hash = "sha256:9300d02ea7c6506f00e627e287e0492a5eb0371ec1670ae852fefffa6164b072", size = 5559635, upload-time = "2025-09-14T22:16:37.141Z" },
    { url = "https://files.pythonhosted.org/packages/21/88/5ba550f797ca953a52d708c8e4f380959e7e3280af029e38fbf47b55916e/zstandard-0.25.0-cp311-cp311-musllinux_1_1_aarch64.whl", hash = "sha256:bfd06b1c5584b657a2892a6014c2f4c20e0db0208c159148fa78c65f7e0b0277", size = 5048277, upload-time = "2025-09-14T22:16:38.807Z" },
    { url = "https://files.pythonhosted.org/packages/46/c0/ca3e533b4fa03112facbe7fbe7779cb1ebec215688e5df576fe5429172e0/zstandard-0.25.0-cp311-cp311-musllinux_1_1_x86_64.whl", hash = "sha256:f373da2c1757bb7f1acaf09369cdc1d51d84131e50d5fa9863982fd626466313", size = 5574377, upload-time = "2025-09-14T22:16:40.523Z" },
    { url = "https://files.pythonhosted.org/packages/12/9b/3fb626390113f272abd0799fd677ea33d5fc3ec185e62e6be534493c4b60/zstandard-0.25.0-cp311-cp311-musllinux_1_2_aarch64.whl", hash = "sha256:6c0e5a65158a7946e7a7affa6418878ef97ab66636f13353b8502d7ea03c8097", size = 4961493, upload-time = "2025-09-14T22:16:43.3Z" },
    { url = "https://files.pythonhosted.org/packages/cb/d3/23094a6b6a4b1343b27ae68249daa17ae0651fcfec9ed4de09d14b940285/zstandard-0.25.0-cp311-cp311-musllinux_1_2_i686.whl", hash = "sha256:c8e167d5adf59476fa3e37bee730890e389410c354771a62e3c076c86f9f7778", size = 5269018, upload-time = "2025-09-14T22:16:45.292Z" },
    { url = "https://files.pythonhosted.org/packages/8c/a7/bb5a0c1c0f3f4b5e9d5b55198e39de91e04ba7c205cc46fcb0f95f0383c1/zstandard-0.25.0-cp311-cp311-musllinux_1_2_ppc64le.whl", hash = "sha256:98750a309eb2f020da61e727de7d7ba3c57c97cf6213f6f6277bb7fb42a8e065", size = 5443672, upload-time = "2025-09-14T22:16:47.076Z" },
    { url = "https://files.pythonhosted.org/packages/27/22/503347aa08d073993f25109c36c8d9f029c7d5949198050962cb568dfa5e/zstandard-0.25.0-cp311-cp311-musllinux_1_2_s390x.whl", hash = "sha256:22a086cff1b6ceca18a8dd6096ec631e430e93a8e70a9ca5efa7561a00f826fa", size = 5822753, upload-time = "2025-09-14T22:16:49.316Z" },
    { url = "https://files.pythonhosted.org/packages/e2/be/94267dc6ee64f0f8ba2b2ae7c7a2df934a816baaa7291db9e1aa77394c3c/zstandard-0.25.0-cp311-cp311-musllinux_1_2_x86_64.whl", hash = "sha256:72d35d7aa0bba323965da807a462b0966c91608ef3a48ba761678cb20ce5d8b7", size = 5366047, upload-time = "2025-09-14T22:16:51.328Z" },
    { url = "https://files.pythonhosted.org/packages/7b/a3/732893eab0a3a7aecff8b99052fecf9f605cf0fb5fb6d0290e36beee47a4/zstandard-0.25.0-cp311-cp311-win32.whl", hash = "sha256:f5aeea11ded7320a84dcdd62a3d95b5186834224a9e55b92ccae35d21a8b63d4", size = 436484, upload-time = "2025-09-14T22:16:55.005Z" },
    { url = "https://files.pythonhosted.org/packages/43/a3/c6155f5c1cce691cb80dfd38627046e50af3ee9ddc5d0b45b9b063bfb8c9/zstandard-0.25.0-cp311-cp311-win_amd64.whl", hash = "sha256:daab68faadb847063d0c56f361a289c4f268706b598afbf9ad113cbe5c38b6b2", size = 506183, upload-time = "2025-09-14T22:16:52.753Z" },
    { url = "https://files.pythonhosted.org/packages/8c/3e/8945ab86a0820cc0e0cdbf38086a92868a9172020fdab8a03ac19662b0e5/zstandard-0.25.0-cp311-cp311-win_arm64.whl", hash = "sha256:22a06c5df3751bb7dc67406f5374734ccee8ed37fc5981bf1ad7041831fa1137", size = 462533, upload-time = "2025-09-14T22:16:53.878Z" },
    { url = "https://files.pythonhosted.org/packages/82/fc/f26eb6ef91ae723a03e16eddb198abcfce2bc5a42e224d44cc8b6765e57e/zstandard-0.25.0-cp312-cp312-macosx_10_13_x86_64.whl", hash = "sha256:7b3c3a3ab9daa3eed242d6ecceead93aebbb8f5f84318d82cee643e019c4b73b", size = 795738, upload-time = "2025-09-14T22:16:56.237Z" },
    { url = "https://files.pythonhosted.org/packages/aa/1c/d920d64b22f8dd028a8b90e2d756e431a5d86194caa78e3819c7bf53b4b3/zstandard-0.25.0-cp312-cp312-macosx_11_0_arm64.whl", hash = "sha256:913cbd31a400febff93b564a23e17c3ed2d56c064006f54efec210d586171c00", size = 640436, upload-time = "2025-09-14T22:16:57.774Z" },
    { url = "https://files.pythonhosted.org/packages/53/6c/288c3f0bd9fcfe9ca41e2c2fbfd17b2097f6af57b62a81161941f09afa76/zstandard-0.25.0-cp312-cp312-manylinux2010_i686.manylinux2014_i686.manylinux_2_12_i686.manylinux_2_17_i686.whl", hash = "sha256:011d388c76b11a0c165374ce660ce2c8efa8e5d87f34996aa80f9c0816698b64", size = 5343019, upload-time = "2025-09-14T22:16:59.302Z" },
    { url = "https://files.pythonhosted.org/packages/1e/15/efef5a2f204a64bdb5571e6161d49f7ef0fffdbca953a615efbec045f60f/zstandard-0.25.0-cp312-cp312-manylinux2014_aarch64.manylinux_2_17_aarch64.whl", hash = "sha256:6dffecc361d079bb48d7caef5d673c88c8988d3d33fb74ab95b7ee6da42652ea", size = 5063012, upload-time = "2025-09-14T22:17:01.156Z" },
    { url = "https://files.pythonhosted.org/packages/b7/37/a6ce629ffdb43959e92e87ebdaeebb5ac81c944b6a75c9c47e300f85abdf/zstandard-0.25.0-cp312-cp312-manylinux2014_ppc64le.manylinux_2_17_ppc64le.whl", hash = "sha256:7149623bba7fdf7e7f24312953bcf73cae103db8cae49f8154dd1eadc8a29ecb", size = 5394148, upload-time = "2025-09-14T22:17:03.091Z" },
    { url = "https://files.pythonhosted.org/packages/e3/79/2bf870b3abeb5c070fe2d670a5a8d1057a8270f125ef7676d29ea900f496/zstandard-0.25.0-cp312-cp312-manylinux2014_s390x.manylinux_2_17_s390x.whl", hash = "sha256:6a573a35693e03cf1d67799fd01b50ff578515a8aeadd4595d2a7fa9f3ec002a", size = 5451652, upload-time = "2025-09-14T22:17:04.979Z" },
    { url = "https://files.pythonhosted.org/packages/53/60/7be26e610767316c028a2cbedb9a3beabdbe33e2182c373f71a1c0b88f36/zstandard-0.25.0-cp312-cp312-manylinux2014_x86_64.manylinux_2_17_x86_64.whl", hash = "sha256:5a56ba0db2d244117ed744dfa8f6f5b366e14148e00de44723413b2f3938a902", size = 5546993, upload-time = "2025-09-14T22:17:06.781Z" },
    { url = "https://files.pythonhosted.org/packages/85/c7/3483ad9ff0662623f3648479b0380d2de5510abf00990468c286c6b04017/zstandard-0.25.0-cp312-cp312-musllinux_1_1_aarch64.whl", hash = "sha256:10ef2a79ab8e2974e2075fb984e5b9806c64134810fac21576f0668e7ea19f8f", size = 5046806, upload-time = "2025-09-14T22:17:08.415Z" },
    { url = "https://files.pythonhosted.org/packages/08/b3/206883dd25b8d1591a1caa44b54c2aad84badccf2f1de9e2d60a446f9a25/zstandard-0.25.0-cp312-cp312-musllinux_1_1_x86_64.whl", hash = "sha256:aaf21ba8fb76d102b696781bddaa0954b782536446083ae3fdaa6f16b25a1c4b", size = 5576659, upload-time = "2025-09-14T22:17:10.164Z" },
    { url = "https://files.pythonhosted.org/packages/9d/31/76c0779101453e6c117b0ff22565865c54f48f8bd807df2b00c2c404b8e0/zstandard-0.25.0-cp312-cp312-musllinux_1_2_aarch64.whl", hash = "sha256:1869da9571d5e94a85a5e8d57e4e8807b175c9e4a6294e3b66fa4efb074d90f6", size = 4953933, upload-time = "2025-09-14T22:17:11.857Z" },
    { url = "https://files.pythonhosted.org/packages/18/e1/97680c664a1bf9a247a280a053d98e251424af51f1b196c6d52f117c9720/zstandard-0.25.0-cp312-cp312-musllinux_1_2_i686.whl", hash = "sha256:809c5bcb2c67cd0ed81e9229d227d4ca28f82d0f778fc5fea624a9def3963f91", size = 5268008, upload-time = "2025-09-14T22:17:13.627Z" },
    { url = "https://files.pythonhosted.org/packages/1e/73/316e4010de585ac798e154e88fd81bb16afc5c5cb1a72eeb16dd37e8024a/zstandard-0.25.0-cp312-cp312-musllinux_1_2_ppc64le.whl", hash = "sha256:f27662e4f7dbf9f9c12391cb37b4c4c3cb90ffbd3b1fb9284dadbbb8935fa708", size = 5433517, upload-time = "2025-09-14T22:17:16.103Z" },
    { url = "https://files.pythonhosted.org/packages/5b/60/dd0f8cfa8129c5a0ce3ea6b7f70be5b33d2618013a161e1ff26c2b39787c/zstandard-0.25.0-cp312-cp312-musllinux_1_2_s390x.whl", hash = "sha256:99c0c846e6e61718715a3c9437ccc625de26593fea60189567f0118dc9db7512", size = 5814292, upload-time = "2025-09-14T22:17:17.827Z" },
    { url = "https://files.pythonhosted.org/packages/fc/5f/75aafd4b9d11b5407b641b8e41a57864097663699f23e9ad4dbb91dc6bfe/zstandard-0.25.0-cp312-cp312-musllinux_1_2_x86_64.whl", hash = "sha256:474d2596a2dbc241a556e965fb76002c1ce655445e4e3bf38e5477d413165ffa", size = 5360237, upload-time = "2025-09-14T22:17:19.954Z" },
    { url = "https://files.pythonhosted.org/packages/ff/8d/0309daffea4fcac7981021dbf21cdb2e3427a9e76bafbcdbdf5392ff99a4/zstandard-0.25.0-cp312-cp312-win32.whl", hash = "sha256:23ebc8f17a03133b4426bcc04aabd68f8236eb78c3760f12783385171b0fd8bd", size = 436922, upload-time = "2025-09-14T22:17:24.398Z" },
    { url = "https://files.pythonhosted.org/packages/79/3b/fa54d9015f945330510cb5d0b0501e8253c127cca7ebe8ba46a965df18c5/zstandard-0.25.0-cp312-cp312-win_amd64.whl", hash = "sha256:ffef5a74088f1e09947aecf91011136665152e0b4b359c42be3373897fb39b01", size = 506276, upload-time = "2025-09-14T22:17:21.429Z" },
    { url = "https://files.pythonhosted.org/packages/ea/6b/8b51697e5319b1f9ac71087b0af9a40d8a6288ff8025c36486e0c12abcc4/zstandard-0.25.0-cp312-cp312-win_arm64.whl", hash = "sha256:181eb40e0b6a29b3cd2849f825e0fa34397f649170673d385f3598ae17cca2e9", size = 462679, upload-time = "2025-09-14T22:17:23.147Z" },
    { url = "https://files.pythonhosted.org/packages/35/0b/8df9c4ad06af91d39e94fa96cc010a24ac4ef1378d3efab9223cc8593d40/zstandard-0.25.0-cp313-cp313-macosx_10_13_x86_64.whl", hash = "sha256:ec996f12524f88e151c339688c3897194821d7f03081ab35d31d1e12ec975e94", size = 795735, upload-time = "2025-09-14T22:17:26.042Z" },
    { url = "https://files.pythonhosted.org/packages/3f/06/9ae96a3e5dcfd119377ba33d4c42a7d89da1efabd5cb3e366b156c45ff4d/zstandard-0.25.0-cp313-cp313-macosx_11_0_arm64.whl", hash = "sha256:a1a4ae2dec3993a32247995bdfe367fc3266da832d82f8438c8570f989753de1", size = 640440, upload-time = "2025-09-14T22:17:27.366Z" },
    { url = "https://files.pythonhosted.org/packages/d9/14/933d27204c2bd404229c69f445862454dcc101cd69ef8c6068f15aaec12c/zstandard-0.25.0-cp313-cp313-manylinux2010_i686.manylinux2014_i686.manylinux_2_12_i686.manylinux_2_17_i686.whl", hash = "sha256:e96594a5537722fdfb79951672a2a63aec5ebfb823e7560586f7484819f2a08f", size = 5343070, upload-time = "2025-09-14T22:17:28.896Z" },
    { url = "https://files.pythonhosted.org/packages/6d/db/ddb11011826ed7db9d0e485d13df79b58586bfdec56e5c84a928a9a78c1c/zstandard-0.25.0-cp313-cp313-manylinux2014_aarch64.manylinux_2_17_aarch64.whl", hash = "sha256:bfc4e20784722098822e3eee42b8e576b379ed72cca4a7cb856ae733e62192ea", size = 5063001, upload-time = "2025-09-14T22:17:31.044Z" },
    { url = "https://files.pythonhosted.org/packages/db/00/87466ea3f99599d02a5238498b87bf84a6348290c19571051839ca943777/zstandard-0.25.0-cp313-cp313-manylinux2014_ppc64le.manylinux_2_17_ppc64le.whl", hash = "sha256:457ed498fc58cdc12fc48f7950e02740d4f7ae9493dd4ab2168a47c93c31298e", size = 5394120, upload-time = "2025-09-14T22:17:32.711Z" },
    { url = "https://files.pythonhosted.org/packages/2b/95/fc5531d9c618a679a20ff6c29e2b3ef1d1f4ad66c5e161ae6ff847d102a9/zstandard-0.25.0-cp313-cp313-manylinux2014_s390x.manylinux_2_17_s390x.whl", hash = "sha256:fd7a5004eb1980d3cefe26b2685bcb0b17989901a70a1040d1ac86f1d898c551", size = 5451230, upload-time = "2025-09-14T22:17:34.41Z" },
    { url = "https://files.pythonhosted.org/packages/63/4b/e3678b4e776db00f9f7b2fe58e547e8928ef32727d7a1ff01dea010f3f13/zstandard-0.25.0-cp313-cp313-manylinux2014_x86_64.manylinux_2_17_x86_64.whl", hash = "sha256:8e735494da3db08694d26480f1493ad2cf86e99bdd53e8e9771b2752a5c0246a", size = 5547173, upload-time = "2025-09-14T22:17:36.084Z" },
    { url = "https://files.pythonhosted.org/packages/4e/d5/ba05ed95c6b8ec30bd468dfeab20589f2cf709b5c940483e31d991f2ca58/zstandard-0.25.0-cp313-cp313-musllinux_1_1_aarch64.whl", hash = "sha256:3a39c94ad7866160a4a46d772e43311a743c316942037671beb264e395bdd611", size = 5046736, upload-time = "2025-09-14T22:17:37.891Z" },
    { url = "https://files.pythonhosted.org/packages/50/d5/870aa06b3a76c73eced65c044b92286a3c4e00554005ff51962deef28e28/zstandard-0.25.0-cp313-cp313-musllinux_1_1_x86_64.whl", hash = "sha256:172de1f06947577d3a3005416977cce6168f2261284c02080e7ad0185faeced3", size = 5576368, upload-time = "2025-09-14T22:17:40.206Z" },
    { url = "https://files.pythonhosted.org/packages/5d/35/398dc2ffc89d304d59bc12f0fdd931b4ce455bddf7038a0a67733a25f550/zstandard-0.25.0-cp313-cp313-musllinux_1_2_aarch64.whl", hash = "sha256:3c83b0188c852a47cd13ef3bf9209fb0a77fa5374958b8c53aaa699398c6bd7b", size = 4954022, upload-time = "2025-09-14T22:17:41.879Z" },
    { url = "https://files.pythonhosted.org/packages/9a/5c/36ba1e5507d56d2213202ec2b05e8541734af5f2ce378c5d1ceaf4d88dc4/zstandard-0.25.0-cp313-cp313-musllinux_1_2_i686.whl", hash = "sha256:1673b7199bbe763365b81a4f3252b8e80f44c9e323fc42940dc8843bfeaf9851", size = 5267889, upload-time = "2025-09-14T22:17:43.577Z" },
    { url = "https://files.pythonhosted.org/packages/70/e8/2ec6b6fb7358b2ec0113ae202647ca7c0e9d15b61c005ae5225ad0995df5/zstandard-0.25.0-cp313-cp313-musllinux_1_2_ppc64le.whl", hash = "sha256:0be7622c37c183406f3dbf0cba104118eb16a4ea7359eeb5752f0794882fc250", size = 5433952, upload-time = "2025-09-14T22:17:45.271Z" },
    { url = "https://files.pythonhosted.org/packages/7b/01/b5f4d4dbc59ef193e870495c6f1275f5b2928e01ff5a81fecb22a06e22fb/zstandard-0.25.0-cp313-cp313-musllinux_1_2_s390x.whl", hash = "sha256:5f5e4c2a23ca271c218ac025bd7d635597048b366d6f31f420aaeb715239fc98", size = 5814054, upload-time = "2025-09-14T22:17:47.08Z" },
    { url = "https://files.pythonhosted.org/packages/b2/e5/fbd822d5c6f427cf158316d012c5a12f233473c2f9c5fe5ab1ae5d21f3d8/zstandard-0.25.0-cp313-cp313-musllinux_1_2_x86_64.whl", hash = "sha256:4f187a0bb61b35119d1926aee039524d1f93aaf38a9916b8c4b78ac8514a0aaf", size = 5360113, upload-time = "2025-09-14T22:17:48.893Z" },
    { url = "https://files.pythonhosted.org/packages/8e/e0/69a553d2047f9a2c7347caa225bb3a63b6d7704ad74610cb7823baa08ed7/zstandard-0.25.0-cp313-cp313-win32.whl", hash = "sha256:7030defa83eef3e51ff26f0b7bfb229f0204b66fe18e04359ce3474ac33cbc09", size = 436936, upload-time = "2025-09-14T22:17:52.658Z" },
    { url = "https://files.pythonhosted.org/packages/d9/82/b9c06c870f3bd8767c201f1edbdf9e8dc34be5b0fbc5682c4f80fe948475/zstandard-0.25.0-cp313-cp313-win_amd64.whl", hash = "sha256:1f830a0dac88719af0ae43b8b2d6aef487d437036468ef3c2ea59c51f9d55fd5", size = 506232, upload-time = "2025-09-14T22:17:50.402Z" },
    { url = "https://files.pythonhosted.org/packages/d4/57/60c3c01243bb81d381c9916e2a6d9e149ab8627c0c7d7abb2d73384b3c0c/zstandard-0.25.0-cp313-cp313-win_arm64.whl", hash = "sha256:85304a43f4d513f5464ceb938aa02c1e78c2943b29f44a750b48b25ac999a049", size = 462671, upload-time = "2025-09-14T22:17:51.533Z" },
    { url = "https://files.pythonhosted.org/packages/3d/5c/f8923b595b55fe49e30612987ad8bf053aef555c14f05bb659dd5dbe3e8a/zstandard-0.25.0-cp314-cp314-macosx_10_13_x86_64.whl", hash = "sha256:e29f0cf06974c899b2c188ef7f783607dbef36da4c242eb6c82dcd8b512855e3", size = 795887, upload-time = "2025-09-14T22:17:54.198Z" },
    { url = "https://files.pythonhosted.org/packages/8d/09/d0a2a14fc3439c5f874042dca72a79c70a532090b7ba0003be73fee37ae2/zstandard-0.25.0-cp314-cp314-macosx_11_0_arm64.whl", hash = "sha256:05df5136bc5a011f33cd25bc9f506e7426c0c9b3f9954f056831ce68f3b6689f", size = 640658, upload-time = "2025-09-14T22:17:55.423Z" },
    { url = "https://files.pythonhosted.org/packages/5d/7c/8b6b71b1ddd517f68ffb55e10834388d4f793c49c6b83effaaa05785b0b4/zstandard-0.25.0-cp314-cp314-manylinux2010_i686.manylinux_2_12_i686.manylinux_2_28_i686.whl", hash = "sha256:f604efd28f239cc21b3adb53eb061e2a205dc164be408e553b41ba2ffe0ca15c", size = 5379849, upload-time = "2025-09-14T22:17:57.372Z" },
    { url = "https://files.pythonhosted.org/packages/a4/86/a48e56320d0a17189ab7a42645387334fba2200e904ee47fc5a26c1fd8ca/zstandard-0.25.0-cp314-cp314-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:223415140608d0f0da010499eaa8ccdb9af210a543fac54bce15babbcfc78439", size = 5058095, upload-time = "2025-09-14T22:17:59.498Z" },
    { url = "https://files.pythonhosted.org/packages/f8/ad/eb659984ee2c0a779f9d06dbfe45e2dc39d99ff40a319895df2d3d9a48e5/zstandard-0.25.0-cp314-cp314-manylinux2014_ppc64le.manylinux_2_17_ppc64le.manylinux_2_28_ppc64le.whl", hash = "sha256:2e54296a283f3ab5a26fc9b8b5d4978ea0532f37b231644f367aa588930aa043", size = 5551751, upload-time = "2025-09-14T22:18:01.618Z" },
    { url = "https://files.pythonhosted.org/packages/61/b3/b637faea43677eb7bd42ab204dfb7053bd5c4582bfe6b1baefa80ac0c47b/zstandard-0.25.0-cp314-cp314-manylinux2014_s390x.manylinux_2_17_s390x.manylinux_2_28_s390x.whl", hash = "sha256:ca54090275939dc8ec5dea2d2afb400e0f83444b2fc24e07df7fdef677110859", size = 6364818, upload-time = "2025-09-14T22:18:03.769Z" },
    { url = "https://files.pythonhosted.org/packages/31/dc/cc50210e11e465c975462439a492516a73300ab8caa8f5e0902544fd748b/zstandard-0.25.0-cp314-cp314-manylinux2014_x86_64.manylinux_2_17_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:e09bb6252b6476d8d56100e8147b803befa9a12cea144bbe629dd508800d1ad0", size = 5560402, upload-time = "2025-09-14T22:18:05.954Z" },
    { url = "https://files.pythonhosted.org/packages/c9/ae/56523ae9c142f0c08efd5e868a6da613ae76614eca1305259c3bf6a0ed43/zstandard-0.25.0-cp314-cp314-musllinux_1_2_aarch64.whl", hash = "sha256:a9ec8c642d1ec73287ae3e726792dd86c96f5681eb8df274a757bf62b750eae7", size = 4955108, upload-time = "2025-09-14T22:18:07.68Z" },
    { url = "https://files.pythonhosted.org/packages/98/cf/c899f2d6df0840d5e384cf4c4121458c72802e8bda19691f3b16619f51e9/zstandard-0.25.0-cp314-cp314-musllinux_1_2_i686.whl", hash = "sha256:a4089a10e598eae6393756b036e0f419e8c1d60f44a831520f9af41c14216cf2", size = 5269248, upload-time = "2025-09-14T22:18:09.753Z" },
    { url = "https://files.pythonhosted.org/packages/1b/c0/59e912a531d91e1c192d3085fc0f6fb2852753c301a812d856d857ea03c6/zstandard-0.25.0-cp314-cp314-musllinux_1_2_ppc64le.whl", hash = "sha256:f67e8f1a324a900e75b5e28ffb152bcac9fbed1cc7b43f99cd90f395c4375344", size = 5430330, upload-time = "2025-09-14T22:18:11.966Z" },
    { url = "https://files.pythonhosted.org/packages/a0/1d/7e31db1240de2df22a58e2ea9a93fc6e38cc29353e660c0272b6735d6669/zstandard-0.25.0-cp314-cp314-musllinux_1_2_s390x.whl", hash = "sha256:9654dbc012d8b06fc3d19cc825af3f7bf8ae242226df5f83936cb39f5fdc846c", size = 5811123, upload-time = "2025-09-14T22:18:13.907Z" },
    { url = "https://files.pythonhosted.org/packages/f6/49/fac46df5ad353d50535e118d6983069df68ca5908d4d65b8c466150a4ff1/zstandard-0.25.0-cp314-cp314-musllinux_1_2_x86_64.whl", hash = "sha256:4203ce3b31aec23012d3a4cf4a2ed64d12fea5269c49aed5e4c3611b938e4088", size = 5359591, upload-time = "2025-09-14T22:18:16.465Z" },
    { url = "https://files.pythonhosted.org/packages/c2/38/f249a2050ad1eea0bb364046153942e34abba95dd5520af199aed86fbb49/zstandard-0.25.0-cp314-cp314-win32.whl", hash = "sha256:da469dc041701583e34de852d8634703550348d5822e66a0c827d39b05365b12", size = 444513, upload-time = "2025-09-14T22:18:20.61Z" },
    { url = "https://files.pythonhosted.org/packages/3a/43/241f9615bcf8ba8903b3f0432da069e857fc4fd1783bd26183db53c4804b/zstandard-0.25.0-cp314-cp314-win_amd64.whl", hash = "sha256:c19bcdd826e95671065f8692b5a4aa95c52dc7a02a4c5a0cac46deb879a017a2", size = 516118, upload-time = "2025-09-14T22:18:17.849Z" },
    { url = "https://files.pythonhosted.org/packages/f0/ef/da163ce2450ed4febf6467d77ccb4cd52c4c30ab45624bad26ca0a27260c/zstandard-0.25.0-cp314-cp314-win_arm64.whl", hash = "sha256:d7541afd73985c630bafcd6338d2518ae96060075f9463d7dc14cfb33514383d", size = 476940, upload-time = "2025-09-14T22:18:19.088Z" },
    { url = "https://files.pythonhosted.org/packages/14/0d/d0a405dad6ab6f9f759c26d866cca66cb209bff6f8db656074d662a953dd/zstandard-0.25.0-cp39-cp39-macosx_10_9_x86_64.whl", hash = "sha256:b9af1fe743828123e12b41dd8091eca1074d0c1569cc42e6e1eee98027f2bbd0", size = 795263, upload-time = "2025-09-14T22:18:21.683Z" },
    { url = "https://files.pythonhosted.org/packages/ca/aa/ceb8d79cbad6dabd4cb1178ca853f6a4374d791c5e0241a0988173e2a341/zstandard-0.25.0-cp39-cp39-macosx_11_0_arm64.whl", hash = "sha256:4b14abacf83dfb5c25eb4e4a79520de9e7e205f72c9ee7702f91233ae57d33a2", size = 640560, upload-time = "2025-09-14T22:18:22.867Z" },
    { url = "https://files.pythonhosted.org/packages/88/cd/2cf6d476131b509cc122d25d3416a2d0aa17687ddbada7599149f9da620e/zstandard-0.25.0-cp39-cp39-manylinux2010_i686.manylinux2014_i686.manylinux_2_12_i686.manylinux_2_17_i686.whl", hash = "sha256:a51ff14f8017338e2f2e5dab738ce1ec3b5a851f23b18c1ae1359b1eecbee6df", size = 5344244, upload-time = "2025-09-14T22:18:24.724Z" },
    { url = "https://files.pythonhosted.org/packages/5c/71/e14820b61a1c137966b7667b400b72fa4a45c836257e443f3d77607db268/zstandard-0.25.0-cp39-cp39-manylinux2014_aarch64.manylinux_2_17_aarch64.whl", hash = "sha256:3b870ce5a02d4b22286cf4944c628e0f0881b11b3f14667c1d62185a99e04f53", size = 5054550, upload-time = "2025-09-14T22:18:26.445Z" },
    { url = "https://files.pythonhosted.org/packages/f9/ce/26dc5a6fa956be41d0e984909224ed196ee6f91d607f0b3fd84577741a77/zstandard-0.25.0-cp39-cp39-manylinux2014_ppc64le.manylinux_2_17_ppc64le.whl", hash = "sha256:05353cef599a7b0b98baca9b068dd36810c3ef0f42bf282583f438caf6ddcee3", size = 5401150, upload-time = "2025-09-14T22:18:28.745Z" },
    { url = "https://files.pythonhosted.org/packages/f2/1b/402cab5edcfe867465daf869d5ac2a94930931c0989633bc01d6a7d8bd68/zstandard-0.25.0-cp39-cp39-manylinux2014_s390x.manylinux_2_17_s390x.whl", hash = "sha256:19796b39075201d51d5f5f790bf849221e58b48a39a5fc74837675d8bafc7362", size = 5448595, upload-time = "2025-09-14T22:18:30.475Z" },
    { url = "https://files.pythonhosted.org/packages/86/b2/fc50c58271a1ead0e5a0a0e6311f4b221f35954dce438ce62751b3af9b68/zstandard-0.25.0-cp39-cp39-manylinux2014_x86_64.manylinux_2_17_x86_64.whl", hash = "sha256:53e08b2445a6bc241261fea89d065536f00a581f02535f8122eba42db9375530", size = 5555290, upload-time = "2025-09-14T22:18:32.336Z" },
    { url = "https://files.pythonhosted.org/packages/d2/20/5f72d6ba970690df90fdd37195c5caa992e70cb6f203f74cc2bcc0b8cf30/zstandard-0.25.0-cp39-cp39-musllinux_1_1_aarch64.whl", hash = "sha256:1f3689581a72eaba9131b1d9bdbfe520ccd169999219b41000ede2fca5c1bfdb", size = 5043898, upload-time = "2025-09-14T22:18:34.215Z" },
    { url = "https://files.pythonhosted.org/packages/e4/f1/131a0382b8b8d11e84690574645f528f5c5b9343e06cefd77f5fd730cd2b/zstandard-0.25.0-cp39-cp39-musllinux_1_1_x86_64.whl", hash = "sha256:d8c56bb4e6c795fc77d74d8e8b80846e1fb8292fc0b5060cd8131d522974b751", size = 5571173, upload-time = "2025-09-14T22:18:36.117Z" },
    { url = "https://files.pythonhosted.org/packages/53/f6/2a37931023f737fd849c5c28def57442bbafadb626da60cf9ed58461fe24/zstandard-0.25.0-cp39-cp39-musllinux_1_2_aarch64.whl", hash = "sha256:53f94448fe5b10ee75d246497168e5825135d54325458c4bfffbaafabcc0a577", size = 4958261, upload-time = "2025-09-14T22:18:38.098Z" },
    { url = "https://files.pythonhosted.org/packages/b5/52/ca76ed6dbfd8845a5563d3af4e972da3b9da8a9308ca6b56b0b929d93e23/zstandard-0.25.0-cp39-cp39-musllinux_1_2_i686.whl", hash = "sha256:c2ba942c94e0691467ab901fc51b6f2085ff48f2eea77b1a48240f011e8247c7", size = 5265680, upload-time = "2025-09-14T22:18:39.834Z" },
    { url = "https://files.pythonhosted.org/packages/7a/59/edd117dedb97a768578b49fb2f1156defb839d1aa5b06200a62be943667f/zstandard-0.25.0-cp39-cp39-musllinux_1_2_ppc64le.whl", hash = "sha256:07b527a69c1e1c8b5ab1ab14e2afe0675614a09182213f21a0717b62027b5936", size = 5439747, upload-time = "2025-09-14T22:18:41.647Z" },
    { url = "https://files.pythonhosted.org/packages/75/71/c2e9234643dcfbd6c5e975e9a2b0050e1b2afffda6c3a959e1b87997bc80/zstandard-0.25.0-cp39-cp39-musllinux_1_2_s390x.whl", hash = "sha256:51526324f1b23229001eb3735bc8c94f9c578b1bd9e867a0a646a3b17109f388", size = 5818805, upload-time = "2025-09-14T22:18:43.602Z" },
    { url = "https://files.pythonhosted.org/packages/f5/93/8ebc19f0a31c44ea0e7348f9b0d4b326ed413b6575a3c6ff4ed50222abb6/zstandard-0.25.0-cp39-cp39-musllinux_1_2_x86_64.whl", hash = "sha256:89c4b48479a43f820b749df49cd7ba2dbc2b1b78560ecb5ab52985574fd40b27", size = 5362280, upload-time = "2025-09-14T22:18:45.625Z" },
    { url = "https://files.pythonhosted.org/packages/b8/e9/29cc59d4a9d51b3fd8b477d858d0bd7ab627f700908bf1517f46ddd470ae/zstandard-0.25.0-cp39-cp39-win32.whl", hash = "sha256:1cd5da4d8e8ee0e88be976c294db744773459d51bb32f707a0f166e5ad5c8649", size = 436460, upload-time = "2025-09-14T22:18:49.077Z" },
    { url = "https://files.pythonhosted.org/packages/41/b5/bc7a92c116e2ef32dc8061c209d71e97ff6df37487d7d39adb51a343ee89/zstandard-0.25.0-cp39-cp39-win_amd64.whl", hash = "sha256:37daddd452c0ffb65da00620afb8e17abd4adaae6ce6310702841760c2c26860", size = 506097, upload-time = "2025-09-14T22:18:47.342Z" },
]

```

`vmlinux_to_elf/core/architecture_detecter.py`:

```py
#!/usr/bin/env python3
# -*- encoding: Utf-8 -*-
import logging
from collections import Counter
from enum import IntEnum
from re import DOTALL, findall
from time import time
from typing import Optional

"""
    Guess the architecture of a given binary.
    
    For this, scan it for simple function prologues.
    Inspiration: https://github.com/ReFirmLabs/binwalk/blob/master/src/binwalk/magic/binarch
    
    Also, return a sequence of the spacing in bytes
    between each detected function prologue, so that
    it can be matched with function symbols from the
    kallsys table and the base address at the offset
    0 of the binary can be guessed.
"""


class ArchitectureGuessError(Exception):
    pass


class ArchitectureName(IntEnum):
    mipsle = 1
    mipsbe = 2
    mips64le = 3
    mips64be = 4
    x86 = 5
    x86_64 = 6
    powerpcbe = 7
    powerpcle = 8
    armle = 9
    armbe = 10
    aarch64 = 11
    mips16e = 12
    superhle = 13
    superhbe = 14
    sparc = 15
    arcompact = 16


# Prologues taken from the binwalk file linked above
architecture_to_prologue_regex: dict[ArchitectureName, bytes] = {
    ArchitectureName.mipsle: rb'.\xFF\xBD\x27..[\xA0-\xBF]\xAF',
    ArchitectureName.mipsbe: rb'\x27\xBD\xFF.\xAF[\xA0-\xBF]..',
    ArchitectureName.mips64le: rb'.\xFF\xBD\x67..[\xA0-\xBF]\xFF',
    ArchitectureName.mips64be: rb'\x67\xBD\xFF.\xFF[\xA0-\xBF]..',
    ArchitectureName.x86: rb'\x55\x89\xE5(?:\x83\xEC|\x57\x56)',
    ArchitectureName.x86_64: rb'\x55\x48\x89\xE5',
    ArchitectureName.powerpcbe: rb'\x7C\x08\x02\xA6',
    ArchitectureName.powerpcle: rb'\xA6\x02\x08\x7C',
    ArchitectureName.armbe: rb'\xE9\x2D..(?:[\xE0-\xEF]...){2}',
    ArchitectureName.armle: rb'\x2D\xE9(?:...[\xE0-\xEF]){2}',
    ArchitectureName.mips16e: rb'\xf0\x08\x64.\x01.',
    ArchitectureName.superhle: rb'\xF6\x69\x0B\x00\xF6\x68',  # This is an epilogue
    ArchitectureName.superhbe: rb'\x69\xF6\x00\x0B\x68\xF6',  # This is an epilogue
    ArchitectureName.aarch64: rb'\xc0\x03\x5f\xd6',  # This is an epilogue
    ArchitectureName.sparc: rb'\x81\xC7\xE0\x08\x81\xE8',  # This is an epilogue
    ArchitectureName.arcompact: b'\xf1\xc0.\x1c\x48[\xb0-\xbf]',  # push_s blink; st.a r??, [sp, -??]
}


# From https://github.com/torvalds/linux/blob/master/include/uapi/linux/elf-em.h


class ElfMachine(IntEnum):
    # These constants define the various ELF target machines
    EM_NONE = 0
    EM_M32 = 1
    EM_SPARC = 2
    EM_386 = 3
    EM_68K = 4
    EM_88K = 5
    EM_486 = 6  # Perhaps disused
    EM_860 = 7
    EM_MIPS = 8  # MIPS R3000 (officially, big-endian only)
    # Next two are historical and binaries and
    # modules of these types will be rejected by
    # Linux.
    EM_MIPS_RS3_LE = 10  # MIPS R3000 little-endian
    EM_MIPS_RS4_BE = 10  # MIPS R4000 big-endian

    EM_PARISC = 15  # HPPA
    EM_SPARC32PLUS = 18  # Sun's "v8plus"
    EM_PPC = 20  # PowerPC
    EM_PPC64 = 21  # PowerPC64
    EM_SPU = 23  # Cell BE SPU
    EM_ARM = 40  # ARM 32 bit
    EM_SH = 42  # SuperH
    EM_SPARCV9 = 43  # SPARC v9 64-bit
    EM_H8_300 = 46  # Renesas H8/300
    EM_IA_64 = 50  # HP/Intel IA-64
    EM_X86_64 = 62  # AMD x86-64
    EM_S390 = 22  # IBM S/390
    EM_CRIS = 76  # Axis Communications 32-bit embedded processor
    EM_M32R = 88  # Renesas M32R
    EM_MN10300 = 89  # Panasonic/MEI MN10300, AM33
    EM_OPENRISC = 92  # OpenRISC 32-bit embedded processor
    EM_ARCOMPACT = 93  # ARCompact processor
    EM_XTENSA = 94  # Tensilica Xtensa Architecture
    EM_BLACKFIN = 106  # ADI Blackfin Processor
    EM_UNICORE = 110  # UniCore-32
    EM_ALTERA_NIOS2 = 113  # Altera Nios II soft-core processor
    EM_TI_C6000 = 140  # TI C6X DSPs
    EM_HEXAGON = 164  # QUALCOMM Hexagon
    EM_NDS32 = 167  # Andes Technology compact code size embedded RISC processor family
    EM_AARCH64 = 183  # ARM 64 bit
    EM_TILEPRO = 188  # Tilera TILEPro
    EM_MICROBLAZE = 189  # Xilinx MicroBlaze
    EM_TILEGX = 191  # Tilera TILE-Gx
    EM_ARCV2 = 195  # ARCv2 Cores
    EM_RISCV = 243  # RISC-V
    EM_BPF = 247  # Linux BPF - in-kernel virtual machine
    EM_CSKY = 252  # C-SKY
    EM_FRV = 0x5441  # Fujitsu FR-V

    # This is an interim value that we will use until the committee comes
    # up with a final number.
    EM_ALPHA = 0x9026

    # Bogus old m32r magic number, used by old tools.
    EM_CYGNUS_M32R = 0x9041
    # This is the old interim value for S/390 architecture
    EM_S390_OLD = 0xA390
    # Also Panasonic/MEI MN10300, AM33
    EM_CYGNUS_MN10300 = 0xBEEF


class ArchitectureDetectionResult:
    architecture_name: ArchitectureName
    elf_machine: ElfMachine
    is_64_bit: bool
    is_big_endian: bool

    def __init__(self, architecture_name: ArchitectureName):
        self.architecture_name = architecture_name

        lookup_table: dict[ArchitectureName, tuple[int, bool, bool]] = {
            ArchitectureName.mipsle: (ElfMachine.EM_MIPS, False, False),
            ArchitectureName.mipsbe: (ElfMachine.EM_MIPS, False, True),
            ArchitectureName.mips64le: (ElfMachine.EM_MIPS, True, False),
            ArchitectureName.mips64be: (ElfMachine.EM_MIPS, True, True),
            ArchitectureName.x86: (ElfMachine.EM_386, False, False),
            ArchitectureName.x86_64: (ElfMachine.EM_X86_64, True, False),
            ArchitectureName.powerpcbe: (ElfMachine.EM_PPC, False, True),
            ArchitectureName.powerpcle: (ElfMachine.EM_PPC, False, False),
            ArchitectureName.armbe: (ElfMachine.EM_ARM, False, True),
            ArchitectureName.armle: (ElfMachine.EM_ARM, False, False),
            ArchitectureName.mips16e: (ElfMachine.EM_MIPS, False, True),
            ArchitectureName.superhle: (ElfMachine.EM_SH, False, False),
            ArchitectureName.superhbe: (ElfMachine.EM_SH, False, True),
            ArchitectureName.aarch64: (ElfMachine.EM_AARCH64, True, False),
            ArchitectureName.sparc: (ElfMachine.EM_SPARC, False, True),
            ArchitectureName.arcompact: (
                ElfMachine.EM_ARCOMPACT,
                False,
                False,
            ),
        }

        self.elf_machine, self.is_64_bit, self.is_big_endian = lookup_table[
            architecture_name
        ]


class ArchitectureDetector:
    """
    Main architecture guess function

    @param binary (bytes): A raw kernel blob
    @raises ArchitectureGuessError
    @returns ArchitectureDetectionResult
    """

    @classmethod
    def guess(cls, binary: bytes) -> ArchitectureDetectionResult:
        begin_time = time()

        architecture_guess = cls._guess_architecture_special(binary)
        if not architecture_guess:
            architecture_guess = cls._guess_architecture_common(binary)

        if not architecture_guess:
            raise ArchitectureGuessError(
                'The architecture could not be guessed successfully'
            )

        logging.info(
            '[+] Guessed architecture: %s successfully in %.2f seconds'
            % (architecture_guess.name, time() - begin_time)
        )

        return ArchitectureDetectionResult(architecture_guess)

    """
        Guess the architecture based on special knowledge, like custom signatures or binary format
    """

    @staticmethod
    def _guess_architecture_special(
        binary: bytes,
    ) -> Optional[ArchitectureName]:
        if binary[:2] == b'MZ':
            # Maybe UEFI boot stub ?
            if binary[0x38:0x3C] == b'ARMd':
                return ArchitectureName.aarch64

        return None

    """
        Guess the architecture based on common patterns
    """

    @staticmethod
    def _guess_architecture_common(
        binary: bytes,
    ) -> Optional[ArchitectureName]:
        architecture_to_number_of_prologues: dict[ArchitectureName, int] = (
            Counter()
        )

        for architecture, prologue in architecture_to_prologue_regex.items():
            architecture_to_number_of_prologues[architecture] = len(
                findall(prologue, binary, flags=DOTALL)
            )

        best_architecture_guess, number_of_prologues = (
            architecture_to_number_of_prologues.most_common(1)[0]
        )

        return None if number_of_prologues < 100 else best_architecture_guess

```

`vmlinux_to_elf/core/elf_symbolizer.py`:

```py
#!/usr/bin/env python3
# -*- encoding: Utf-8 -*-
import logging
from io import BytesIO

from vmlinux_to_elf.core.architecture_detecter import ArchitectureGuessError
from vmlinux_to_elf.core.kallsyms import KallsymsFinder, KallsymsSymbolType
from vmlinux_to_elf.utils.elf import (
    SH_FLAGS,
    SPECIAL_SECTION_INDEX,
    ST_INFO_BINDING,
    ST_INFO_TYPE,
    Elf32BigEndianRelocationWithAddendTableEntry,
    Elf32BigEndianSymbolTableEntry,
    Elf32LittleEndianRelocationWithAddendTableEntry,
    Elf32LittleEndianSymbolTableEntry,
    Elf64BigEndianRelocationWithAddendTableEntry,
    Elf64BigEndianSymbolTableEntry,
    Elf64LittleEndianRelocationWithAddendTableEntry,
    Elf64LittleEndianSymbolTableEntry,
    ElfFile,
    ElfNoBits,
    ElfNullSection,
    ElfProgbits,
    ElfRela,
    ElfStrtab,
    ElfSymtab,
)

"""
    The ElfSymbolizer class, defined in this file, gathers information from
    the other modules (such as kallsyms_finder, which extracts the kernel's
    runtime symbol table, or vmlinuz_decompressor, which processes possible
    kernel compressions), in order to generate the output ELF file.
"""


class ElfSymbolizer:
    def __init__(
        self,
        file_contents: bytes,
        output_file: str,
        elf_machine: int = None,
        bit_size: int = None,
        base_address: int = None,
        bss_size: int = 16,
        file_offset: int = None,
        override_relative: bool = None,
        # extra_info: bool = False,
    ):
        if file_contents.startswith(
            b'\x27\x05\x19\x56'
        ):  # uImage header magic (always big-endian)
            if file_offset is None:
                file_offset = 64  # uImage header size (image_header_t from u-boot/image.h)

            if base_address is None:
                base_address = int.from_bytes(
                    file_contents[4 * 4 : 4 * 5], 'big'
                )

        if file_offset:
            file_contents = file_contents[file_offset:]

        kallsyms_finder = KallsymsFinder(
            file_contents,
            bit_size,
            override_relative,
            base_address,
            # extra_info,
        )

        if elf_machine is None and not kallsyms_finder.elf_machine:
            raise ArchitectureGuessError(
                'The architecture could not be guessed successfully'
            )

        if file_contents.startswith(b'\x7fELF'):
            kernel = ElfFile.from_bytes(BytesIO(file_contents))

        else:
            kernel = ElfFile(
                kallsyms_finder.is_big_endian, kallsyms_finder.is_64_bits
            )

            #  Previsouly the register size was based on the kernel version string: bool(kallsyms_finder.offset_table_element_size >= 8 or search('itanium|(?:amd|aarch|ia|arm|x86_|\D-)64', kallsyms_finder.version_string, flags = IGNORECASE))

            if elf_machine is not None:
                kernel.file_header.e_machine = elf_machine
            else:
                kernel.file_header.e_machine = kallsyms_finder.elf_machine

            ET_EXEC = 2
            kernel.file_header.e_type = ET_EXEC

            null = ElfNullSection(kernel)
            null.section_name = ''

            progbits = ElfProgbits(kernel)
            progbits.section_name = '.kernel'
            progbits.section_header.sh_flags = (
                SH_FLAGS.SHF_ALLOC
                | SH_FLAGS.SHF_EXECINSTR
                | SH_FLAGS.SHF_WRITE
            )

            first_symbol_virtual_address = next(
                (
                    symbol.virtual_address
                    for symbol in kallsyms_finder.symbols
                    if symbol.symbol_type == KallsymsSymbolType.TEXT
                ),
                None,
            )

            if kallsyms_finder.has_base_relative:
                first_symbol_virtual_address = min(
                    first_symbol_virtual_address,
                    kallsyms_finder.relative_base_address,
                )

            if base_address is not None:
                progbits.section_header.sh_addr = base_address
                logging.info(
                    f'[+] An explicit base address was given ({progbits.section_header.sh_addr:x})'
                )
            elif kallsyms_finder.kernel_text_candidate:
                progbits.section_header.sh_addr = (
                    kallsyms_finder.kernel_text_candidate
                )
                logging.info(
                    f'[+] Guessed the base address using the kernel_text_candidate heuristic ({progbits.section_header.sh_addr:x})'
                )
            else:
                progbits.section_header.sh_addr = (
                    first_symbol_virtual_address & 0xFFFFFFFFFFFFF000
                )
                logging.info(
                    f'[+] Guessed the base address using the first_symbol_virtual_address fallback heuristic ({progbits.section_header.sh_addr:x})'
                )

            kernel.sections += [null, progbits]

            if kallsyms_finder.elf64_rela:
                # Punch a hole into the ELF to remove relocation tables
                progbits.section_header.sh_size = (
                    kallsyms_finder.elf64_rela_start
                )
                progbits.section_contents = file_contents[
                    : progbits.section_header.sh_size
                ]
                progbits2 = ElfProgbits(kernel)
                progbits2.section_name = '.kernel2'
                progbits2.section_header.sh_flags = (
                    SH_FLAGS.SHF_ALLOC
                    | SH_FLAGS.SHF_EXECINSTR
                    | SH_FLAGS.SHF_WRITE
                )
                progbits2.section_header.sh_addr = (
                    progbits.section_header.sh_addr
                    + kallsyms_finder.elf64_rela_end_excl
                )
                progbits2.section_header.sh_size = (
                    len(file_contents) - kallsyms_finder.elf64_rela_end_excl
                )
                progbits2.section_contents = file_contents[
                    kallsyms_finder.elf64_rela_end_excl :
                ]
                kernel.sections += [progbits2]
            else:
                progbits.section_contents = file_contents
                progbits.section_header.sh_size = len(file_contents)

            bss = ElfNoBits(kernel)
            bss.section_name = '.bss'
            bss.section_header.sh_flags = (
                SH_FLAGS.SHF_ALLOC
                | SH_FLAGS.SHF_EXECINSTR
                | SH_FLAGS.SHF_WRITE
            )
            bss.section_header.sh_size = bss_size * 1024 * 1024
            bss.section_header.sh_addr = progbits.section_header.sh_addr + len(
                file_contents
            )

            kernel.sections += [bss]

        r"""
            Find the entry point symbol. Based on executing this command
            on the Linux tree source:
            
            for i in $(find -iname 'vmlinux.lds.S' -o -iname 'dyn.lds.S' -o -iname 'vmlinux-std.lds');
                do echo "$i:"$(grep -P '^ENTRY\(' $i);
            done | grep -Po 'ENTRY\((.+?)\)' | sort -u

            You can find the possible symbols that are used as an entry
            point for the kernel, here sorted from the most specific to
            the less specific
        """

        POSSIBLE_ENTRY_POINT_SYMBOLS = [
            'kernel_entry',
            'microblaze_start',
            'parisc_kernel_start',
            'phys_startup_32',
            'phys_startup_64',
            'phys_start',
            '_stext_lma',
            'res_service',
            '_c_int00',
            'startup_32',
            'startup_64',
            'startup_continue',
            'startup',
            '__start',
            '_start',
            'start_kernel',
            'stext',
            '_stext',
            '_text',
        ]

        entry_point_address: int = None

        for symbol_name in POSSIBLE_ENTRY_POINT_SYMBOLS:
            symbol = kallsyms_finder.name_to_symbol.get(symbol_name)

            if symbol:
                entry_point_address = symbol.virtual_address

                break

        if entry_point_address is None:
            raise ValueError('No entry point symbol found in the kallsyms')

        kernel.file_header.e_entry = entry_point_address

        # Add symbols

        symtab = next(
            (i for i in kernel.sections if i.section_name == '.symtab'), None
        )

        if not symtab:
            symtab = ElfSymtab(kernel)
            symtab.section_name = '.symtab'

            strtab = ElfStrtab(kernel)
            strtab.section_name = '.strtab'
            symtab.string_table = strtab

            shstrtab = ElfStrtab(kernel)
            shstrtab.section_name = '.shstrtab'

            kernel.section_string_table = shstrtab
            kernel.sections += [symtab, strtab, shstrtab]

        sections = sorted(
            [i for i in kernel.sections if i.section_header.sh_addr > 0],
            key=lambda x: x.section_header.sh_addr,
        )

        def _find_section(address):
            """
            Uses binary search to quickly find the section which the address belongs to
            """
            # Set baseline and roofline hypotheses, expressed in
            # section table indexes:
            lower_range, upper_range = 0, len(sections) - 1
            # Wait for the hypotheses to converge
            while lower_range < upper_range:
                # Mean operation to pick a new tentative hypothesis
                # (add one to ensure to ceil-round the upper
                # hypothesis in case of a difference of 1)
                middle = (lower_range + upper_range + 1) // 2
                if (
                    sections[middle].section_header.sh_addr <= address
                ):  # Test the hypothesis
                    lower_range = middle  # Use the hypothesis as a baseline
                else:
                    upper_range = middle - 1  # Disqualify the hypothesis
            if (
                sections[lower_range].section_header.sh_addr
                <= address
                <= sections[lower_range].section_header.sh_addr
                + sections[lower_range].section_header.sh_size
            ):
                return sections[
                    lower_range
                ]  # Select the best hypothesis if it qualifies
            return None

        elf_symbol_class = {
            (False, False): Elf32LittleEndianSymbolTableEntry,
            (True, False): Elf32BigEndianSymbolTableEntry,
            (False, True): Elf64LittleEndianSymbolTableEntry,
            (True, True): Elf64BigEndianSymbolTableEntry,
        }[(kernel.is_big_endian, kernel.is_64_bits)]

        for symbol in kallsyms_finder.symbols:
            elf_symbol = elf_symbol_class(
                kernel.is_big_endian, kernel.is_64_bits
            )

            elf_symbol.symbol_name = symbol.name
            elf_symbol.st_value = symbol.virtual_address

            if symbol.symbol_type not in (
                KallsymsSymbolType.TEXT,
                KallsymsSymbolType.WEAK_SYMBOL_WITH_DEFAULT,
            ):
                elf_symbol.st_info_type = ST_INFO_TYPE.STT_OBJECT
            else:
                elf_symbol.st_info_type = ST_INFO_TYPE.STT_FUNC

            if symbol.symbol_type in (
                KallsymsSymbolType.WEAK_OBJECT_WITH_DEFAULT,
                KallsymsSymbolType.WEAK_SYMBOL_WITH_DEFAULT,
            ):
                elf_symbol.st_info_binding = ST_INFO_BINDING.STB_WEAK
            elif symbol.is_global:
                elf_symbol.st_info_binding = ST_INFO_BINDING.STB_GLOBAL
            else:
                elf_symbol.st_info_binding = ST_INFO_BINDING.STB_LOCAL

            if symbol.symbol_type == KallsymsSymbolType.ABSOLUTE:
                elf_symbol.st_shndx = SPECIAL_SECTION_INDEX.SHN_ABS
            else:
                elf_symbol.associated_section = _find_section(
                    symbol.virtual_address
                )

            symtab.symbol_table.append(elf_symbol)

        if kallsyms_finder.elf64_rela:
            srela = ElfRela(kernel)
            srela.section_name = '.rela.dyn'
            relocation_class = {
                (
                    False,
                    False,
                ): Elf32LittleEndianRelocationWithAddendTableEntry,
                (True, False): Elf32BigEndianRelocationWithAddendTableEntry,
                (False, True): Elf64LittleEndianRelocationWithAddendTableEntry,
                (True, True): Elf64BigEndianRelocationWithAddendTableEntry,
            }[(kernel.is_big_endian, kernel.is_64_bits)]
            srela.relocation_table = []
            srela.symtab_section = symtab
            kernel.sections += [srela]
            for rela in kallsyms_finder.elf64_rela:
                relocation = relocation_class(
                    kernel.is_big_endian, kernel.is_64_bits
                )

                relocation.r_offset = rela[0]
                relocation.r_info_type = 1027
                relocation.r_addend = rela[2]

                srela.relocation_table.append(relocation)

        # Save the modified ELF

        with open(output_file, 'wb') as fd:
            kernel.serialize(fd)

        logging.info(
            '[+] Successfully wrote the new ELF kernel to %s' % output_file
        )

```

`vmlinux_to_elf/core/kallsyms.py`:

```py
#!/usr/bin/env python3
# -*- encoding: Utf-8 -*-

import logging
import math
from enum import Enum
from re import match, search, findall
from struct import pack, unpack_from

from vmlinux_to_elf.core.architecture_detecter import (
    ArchitectureDetectionResult,
    ArchitectureDetector,
    ArchitectureGuessError,
    ArchitectureName,
)

from vmlinux_to_elf.kernel_db.database import (
    KernelVersion,
    KernelRelevantFile,
    DebianRelease,
    KernelVersionDependency,
    EMachineValue,
    KnownArchitecture,
)

"""
    This class will take a raw kernel image (.IMG), and return the file
    offsets for all kernel symbols, as well as the kallsyms_* structs and
    base addresses, etc.
    
    It is used as an import by "vmlinuz_extractor.py" and "elf_symbolizer.py".
    
    The kallsyms table's current layout was introduced in August 2004 (since
    kernel 2.6.10), its 2004+ implementation can be found here for parsing:
    https://github.com/torvalds/linux/blob/v2.6.32/kernel/kallsyms.c
    And here for generation:
    https://github.com/torvalds/linux/blob/v2.6.32/scripts/kallsyms.c
    
    ^ This format is fully supported.
    
    A major evolution is that since v4.6 (2016), by default on all architectures
    except IA64, a new label called "kallsyms_relative_base" was added and
    addresses are now offsets relative to this base, rather than relative
    addresses. Also, these offsets are stored as the GNU As ".long" type, which
    is 32-bits on x86_64.
    
    https://github.com/torvalds/linux/commit/2213e9a66bb87d8344a1256b4ef568220d9587fb
    
    ^ This format should be supported.
    
    In v4.20 (2018), more fields were shrunk down independently.
    
    https://github.com/torvalds/linux/commit/80ffbaa5b1bd98e80e3239a3b8cfda2da433009a
    
    ^ This format should be supported.
    
    Its 2002-2004 (versions 2.5.54-2.6.9) implementation code with basic "stem
    compression" can be found here for parsing:
    https://github.com/sarnobat/knoppix/blob/master/kernel/kallsyms.c
    Here for generation:
    https://github.com/sarnobat/knoppix/blob/master/scripts/kallsyms.c
    (patch https://lwn.net/Articles/18837/)
    
    In 2002 (versions 2.5.49-2.5.53) it shortly had a version of this code
    without compression:
    https://kernel.googlesource.com/pub/scm/linux/kernel/git/ralf/linux/+/refs/tags/linux-2.5.49/kernel/kallsyms.c
    https://kernel.googlesource.com/pub/scm/linux/kernel/git/ralf/linux/+/refs/tags/linux-2.5.49/scripts/kallsyms
    
    In earlier implementations (2000-2002), it was part of the modutils package
    and was more primitive (no real compression). Its implementation code can be found
    here for parsing:
    https://github.com/carlobar/uclinux_leon3_UD/blob/master/user/modutils-2.4.26/example/kallsyms.c
    Here for generation:
    https://github.com/carlobar/uclinux_leon3_UD/blob/master/user/modutils-2.4.26/obj/obj_kallsyms.c
    
    Kernels 2.5.39-2.5.48 (2002) also had a transitory parser at "kernel/kallsyms.c", but the generation
    was still in modutils:
    
    https://kernel.googlesource.com/pub/scm/linux/kernel/git/ralf/linux/+/refs/tags/linux-2.5.39/kernel/kallsyms.c
    (patch https://lwn.net/Articles/10796/)

    
"""


# Symbol types are the same as exposed by "man nm"


class KallsymsSymbolType(Enum):
    # Seen in actual kernels
    ABSOLUTE = 'A'
    BSS = 'B'
    DATA = 'D'
    RODATA = 'R'
    TEXT = 'T'
    WEAK_OBJECT_WITH_DEFAULT = 'V'
    WEAK_SYMBOL_WITH_DEFAULT = 'W'

    # Seen on nm's manpage
    SMALL_DATA = 'G'
    INDIRECT_FUNCTION = 'I'
    DEBUGGING = 'N'
    STACK_UNWIND = 'P'
    COMMON = 'C'
    SMALL_BSS = 'S'
    UNDEFINED = 'U'
    UNIQUE_GLOBAL = 'u'
    WEAK_OBJECT = 'v'
    WEAK_SYMBOL = 'w'
    STABS_DEBUG = '-'
    UNKNOWN = '?'


class KallsymsSymbol:
    name: str = None

    file_offset: int = None
    virtual_address: int = None

    symbol_type: KallsymsSymbolType = None
    is_global: bool = False


class KallsymsNotFoundException(ValueError):
    pass


class KallsymsFinder:
    # Structure offsets to find

    kallsyms_addresses_or_offsets__offset: int = None
    kallsyms_num_syms__offset: int = None

    kallsyms_names__offset: int = None
    kallsyms_markers__offset: int = None

    kallsyms_token_table__offset: int = None
    kallsyms_token_index__offset: int = None
    kallsyms_token_index_end__offset: int = None

    elf64_rela: list[tuple[int, int, int]] = None
    elf64_rela_start: int = None
    elf64_rela_end_excl: int = None
    kernel_text_candidate: int = None

    # Inferred information

    architecture: ArchitectureName = None

    elf_machine: int = None
    is_64_bits: int = None  # Can be set manually
    is_big_endian: bool = None
    offset_table_element_size: int = None

    # Parsed information

    num_symbols: int = None
    symbol_names: list = None
    symbol_addresses: list = None

    has_relative_base: bool = None
    has_absolute_percpu: bool = None
    relative_base_address: int = None

    kernel_addresses: list[int] = None

    symbols: list[KallsymsSymbol] = None
    name_to_symbol: dict[str, KallsymsSymbol] = None

    """
        Symbols are output in this order:
    
        $ curl -sL https://github.com/torvalds/linux/raw/v2.6.32/scripts/kallsyms.c | grep output_label
        
            output_label("kallsyms_addresses");
            output_label("kallsyms_num_syms");
            output_label("kallsyms_names");
            output_label("kallsyms_markers");
            output_label("kallsyms_token_table");
            output_label("kallsyms_token_index");
            
        We'll find kallsyms_token_table and infer the rest
    """

    def __init__(
        self,
        kernel_img: bytes,
        bit_size: int = None,
        override_relative_base: bool = False,
        base_address: int = None,
        # extra_info: bool = False,
    ):
        self.override_relative_base = override_relative_base
        self.kernel_img = kernel_img

        # -

        self.find_linux_kernel_version()

        if bit_size:
            if bit_size not in (64, 32):
                exit(
                    '[!] Please specify a register bit size of either 32 or 64 bits'
                )
            else:
                self.is_64_bits = bit_size == 64

        self.guess_architecture()

        self.extract_db_information()

        if self.is_64_bits:
            self.find_elf64_rela(base_address)
            self.apply_elf64_rela()

        # -

        try:
            self.find_kallsyms_token_table()
            self.find_kallsyms_token_index()
            self.uncompressed_kallsyms = False

        except KallsymsNotFoundException as first_error:  # Maybe an OpenWRT kernel with an uncompressed kallsyms
            try:
                self.find_kallsyms_names_uncompressed()
                self.find_kallsyms_markers_uncompressed()
                self.uncompressed_kallsyms = True

            except KallsymsNotFoundException:
                raise first_error

        else:
            self.find_kallsyms_markers()
            self.find_kallsyms_names()

        self.find_kallsyms_num_syms()
        self.find_kallsyms_addresses_or_symbols()

        # -

        self.parse_symbol_table()

    def find_linux_kernel_version(self):
        regex_match = search(
            rb'Linux version (\d+\.[\d.]*\d)[ -~]+', self.kernel_img
        )

        if not regex_match:
            raise ValueError('No version string found in this kernel')

        self.version_string = regex_match.group(0).decode('ascii')
        self.version_number = regex_match.group(1).decode('ascii')

        logging.info('[+] Version string: {0:s}'.format(self.version_string))
        logging.info(
            '[+]   Other related strings containing the version number: %s'
            % findall(
                b'[ -~]*%s[ -~]*' % regex_match.group(1), self.kernel_img
            )
        )
        arch_string = search(b'mod_unload[ -~]+', self.kernel_img)
        if arch_string:
            logging.info(
                '[+]   Architecture string: %s'
                % arch_string.group(0).decode('utf-8')
            )

    def guess_architecture(self):
        try:
            result: ArchitectureDetectionResult = ArchitectureDetector.guess(
                self.kernel_img
            )
        except ArchitectureGuessError:
            if self.is_64_bits is None:
                raise
        else:
            self.architecture: ArchitectureName = result.architecture_name

            self.elf_machine = int(result.elf_machine)
            if self.is_64_bits is None:
                self.is_64_bits = result.is_64_bit
            self.is_big_endian = result.is_big_endian

    def extract_db_information(self, extra_info=True):
        kernel_major = int(self.version_number.split('.')[0])
        kernel_minor = int(self.version_number.split('.')[1])
        version_partial = 'v%d.%d' % (kernel_major, kernel_minor)
        if self.version_number.count('.') > 1:
            kernel_sublevel = int(self.version_number.split('.')[2])
            version_full = '%s.%d' % (version_partial, kernel_sublevel)
        else:
            kernel_sublevel = None
            version_full = version_partial
        kernel = next(
            iter(
                KernelVersion.select().where(
                    KernelVersion.version_string == version_full
                )
            ),
            None,
        ) or next(
            iter(
                KernelVersion.select().where(
                    KernelVersion.version_string == version_partial
                )
            ),
            None,
        )
        if kernel:
            logging.info('[+] Kernel found in database')
            logging.info('[+]   Read kernel source: ' + kernel.browse_url)
            logging.info('[+]   Download kernel: ' + kernel.download_url)
            logging.info(
                '[+]   Kernel release date: '
                + kernel.release_date.strftime('%Y-%m-%d')
            )
            if self.elf_machine:
                # if not extra_info:
                #     logging.info(
                #         '[+]   Use --extra-info or -e to print more interesting details'
                #     )
                if extra_info:
                    logging.info('[+]   Interesting files:')
                    for file in kernel.relevant_files.select().where(
                        KernelRelevantFile.architecture_code == None
                    ):
                        if file.vcs_browser_url:
                            logging.info(
                                '[~]     - %s: %s'
                                % (file.file_name, file.vcs_browser_url)
                            )
                        else:
                            file.file_name
                            logging.info('[~]     - ' + file.file_name)

                e_machine = next(
                    iter(
                        EMachineValue.select().where(
                            EMachineValue.elf_machine_int == self.elf_machine
                        )
                    ),
                    None,
                )
                if e_machine:
                    machine_name = e_machine.elf_machine_str
                    for link in e_machine.arch_code_links:
                        arch: KnownArchitecture = link.architecture
                        arch_code: str = arch.architecture_code
                        capacities = []
                        if arch.has_32bit_class:
                            capacities.append('32-bit')
                        if arch.has_64bit_class:
                            capacities.append('64-bit')
                        if arch.has_msb_class:
                            capacities.append('big-endian')
                        if arch.has_lsb_class:
                            capacities.append('little-endian')
                        logging.info(
                            '[+]   Architecture %s (%s) supports %s'
                            % (arch_code, machine_name, ', '.join(capacities))
                        )
                        if extra_info:
                            for file in kernel.relevant_files.select().where(
                                KernelRelevantFile.architecture_code
                                == arch_code
                            ):
                                if file.vcs_browser_url:
                                    logging.info(
                                        '[~]     - %s: %s'
                                        % (
                                            file.file_name,
                                            file.vcs_browser_url,
                                        )
                                    )
                                else:
                                    file.file_name
                                    logging.info('[~]     - ' + file.file_name)
            if extra_info:
                debian_version = next(
                    iter(
                        DebianRelease.select()
                        .where(
                            DebianRelease.debian_release_date
                            <= kernel.release_date
                        )
                        .order_by(DebianRelease.debian_release_date.desc())
                    ),
                    None,
                )
                if debian_version:
                    logging.info(
                        '[+]   Suggested build environment: docker run -it %s (Debian %s "%s" released %s)'
                        % (
                            debian_version.docker_archive_name,
                            debian_version.debian_version_number,
                            debian_version.debian_version_name,
                            debian_version.debian_release_date.strftime(
                                '%Y-%m-%d'
                            ),
                        )
                    )

    def find_elf64_rela(self, base_address: int = None) -> bool:
        """
        Find relocations table, return True if success, False
        otherwise
        """

        # FIX: architecture is not set when guess_architecture() wasn't called
        if (
            not hasattr(self, 'architecture')
            or ArchitectureName.aarch64 != self.architecture
        ):
            # I've tested this only for ARM64
            return False

        rela64_size = 24
        self.elf64_rela_start = len(self.kernel_img)
        self.elf64_rela_start -= (
            self.elf64_rela_start & 3
        )  # align to pointer size
        R_AARCH64_RELATIVE = 0x403
        elf64_rela = []
        minimal_heuristic_count = 1000
        minimal_kernel_va = 0xFFFFC00080000000
        maximal_kernel_va = 0xFFFFFFFFFFFFFFFF
        addend_candidate = None

        # Relocations table located at 'init' part of kernel image
        # Thus reverse-search is more efficient

        while self.elf64_rela_start >= rela64_size:
            rela = unpack_from(
                '<QQQ', self.kernel_img, self.elf64_rela_start - rela64_size
            )
            r_offset, r_info, r_addend = rela
            if (0 == r_offset) and (0 == r_info) and (0 == r_addend):
                # possible empty entry ?

                if elf64_rela:
                    # just skip empty entries inside relocation table

                    self.elf64_rela_start -= (
                        rela64_size  # move to one rela64 struct backward
                    )
                    continue

            if R_AARCH64_RELATIVE != r_info:
                # Relocations must be the same type
                # BUG: this is not true in practice, R_AARCH64_GLOB_DAT and maybe some other are between first few R_AARCH64_RELATIVE, which results in missing ~30 relocations

                if len(elf64_rela) >= minimal_heuristic_count:
                    break

                # reset current state

                elf64_rela = []
                kernel_text_candidate = maximal_kernel_va

                # move to the next candidate

                possible_offset = self.elf64_rela_start - 1

                while (
                    possible_offset % 8 != 0
                ):  # Find a pointer-aligned r_info entry
                    possible_offset = self.kernel_img.rfind(
                        R_AARCH64_RELATIVE.to_bytes(8, 'little'),
                        8,
                        possible_offset - rela64_size + 1,
                    )
                    if possible_offset == -1:
                        self.elf64_rela_start = 0
                        break

                if possible_offset != -1:
                    self.elf64_rela_start = possible_offset - 8

                continue

            elf64_rela.append(rela)
            if (0 == (r_addend & 0xFFF)) and (minimal_kernel_va <= r_addend):
                if addend_candidate is None or r_addend < addend_candidate:
                    addend_candidate = r_addend
            self.elf64_rela_start -= (
                rela64_size  # move to one rela64 struct backward
            )

        count = len(elf64_rela)

        if count < minimal_heuristic_count:
            return False

        self.elf64_rela = elf64_rela
        self.elf64_rela_end_excl = self.elf64_rela_start + count * rela64_size
        logging.info(
            '[+] Found relocations table at file offset 0x%04x (count=%d)'
            % (self.elf64_rela_start, count)
        )

        # Infer a sane base range from relocation offsets so that every
        # relocation offset maps somewhere inside the image.
        min_offset = min(r[0] for r in elf64_rela)
        max_offset = max(r[0] for r in elf64_rela)
        img_len = len(self.kernel_img)
        base_low = max_offset - (img_len - 8)
        base_high = min_offset

        def fits(base: int) -> bool:
            return base is not None and base_low <= base <= base_high

        if base_address is not None:
            self.kernel_text_candidate = base_address
            logging.info(
                '[+] Using supplied base address as kernel text candidate: 0x%08x'
                % (self.kernel_text_candidate)
            )
        elif addend_candidate is not None and fits(addend_candidate):
            self.kernel_text_candidate = addend_candidate
            logging.info(
                '[+] Found kernel text candidate from relocation addends: 0x%08x'
                % (self.kernel_text_candidate)
            )
        elif base_low <= base_high:
            # HACK: kernel might not be aligned to 0x10000?
            ALIGN = 0x10000
            candidate = (base_low + ALIGN - 1) & ~(ALIGN - 1)
            if candidate > base_high:
                candidate = base_high & ~(ALIGN - 1)
            self.kernel_text_candidate = candidate
            logging.info(
                '[+] Guessed kernel base from relocation offsets range 0x%08x-0x%08x -> 0x%08x'
                % (base_low, base_high, self.kernel_text_candidate)
            )
        else:
            self.kernel_text_candidate = (
                addend_candidate
                if addend_candidate is not None
                else base_address
            )
            logging.info(
                '[!] Could not derive a consistent base from relocations, keeping candidate 0x%08x'
                % (self.kernel_text_candidate)
            )

        logging.info(
            '[+] Found relocations table at file offset 0x%04x (count=%d)'
            % (self.elf64_rela_start, count)
        )
        return True

    def apply_elf64_rela(self) -> bool:
        """
        Apply relocations table, return True if success, False
        otherwise
        """
        if self.elf64_rela is None or self.kernel_text_candidate is None:
            return False

        img = bytearray(self.kernel_img)
        offset_max = len(img) - 8  # size of ptr
        kernel_base = self.kernel_text_candidate

        # There is no guarantee that relocation addresses are monotonous

        count = 0
        for rela in self.elf64_rela:
            r_offset, r_info, r_addend = rela
            offset = r_offset - kernel_base

            if offset < 0 or offset >= offset_max:
                logging.warning('WARNING! bad rela offset %08x' % (r_offset))

                self.kernel_text_candidate = None
                self.elf64_rela = None
                return False  # Don't try more to apply relocations

            (value,) = unpack_from('<Q', self.kernel_img, offset)
            if value == r_addend:
                # don't know why, but some relocations already initialized

                continue

            # BUG: Sometimes 'r_addend' has pretty small value, and applied to 0.
            # BUG: Result much smaller that valid kernel address.
            # BUG: Probably 'r_addend' can represent offset from kernel_base. Need further investigation.

            value += r_addend
            value &= (1 << 64) - 1

            img[offset : offset + 8] = pack('<Q', value)
            count += 1

        self.kernel_img = bytes(img)
        logging.info('[+] Successfully applied %d relocations.' % count)
        return True

    def find_kallsyms_token_table(self):
        """
        kallsyms_token_table is an array of 256 variable length null-
        terminated string fragments. Positions which correspond to
        an ASCII character which is used in at least one symbol
        contain the corresponing character (1), other position contain
        a string fragment chosen by the compression algorithm (2).

        Hence, characters [0-9] and [a-z] are always present at their
        respective positions, but ":" (which comes after "9") never does.

        (1) See "insert_real_symbols_in_table" of "scripts/kallsyms.c"
        (2) See "optimize_result" of "scripts/kallsyms.c"
        """

        position = 0

        candidates_offsets = []  # offsets at which sequence_to_find was found
        candidates_offsets_followed_with_ascii = []  # variant with an higher certainty

        sequence_to_find = b''.join(
            b'%c\0' % i for i in range(ord('0'), ord('9') + 1)
        )

        sequences_to_avoid = [b':\0', b'\0\0', b'\0\1', b'\0\2', b'ASCII\0']

        while True:
            position = self.kernel_img.find(sequence_to_find, position + 1)
            if position == -1:
                break

            for seq in sequences_to_avoid:
                pos = position + len(sequence_to_find)
                if self.kernel_img[pos : pos + len(seq)] == seq:
                    break
            else:
                candidates_offsets.append(position)

                if self.kernel_img[pos : pos + 1].isalnum():
                    candidates_offsets_followed_with_ascii.append(position)

        if len(candidates_offsets) != 1:
            if len(candidates_offsets_followed_with_ascii) == 1:
                candidates_offsets = candidates_offsets_followed_with_ascii
            elif len(candidates_offsets) == 0:
                raise KallsymsNotFoundException(
                    '%d candidates for kallsyms_token_table in kernel image'
                    % len(candidates_offsets)
                )
            else:
                raise ValueError(
                    '%d candidates for kallsyms_token_table in kernel image'
                    % len(candidates_offsets)
                )

        position = candidates_offsets[0]

        # Get back to the beginning of the table

        current_index_in_array = ord('0')

        position -= 1
        assert position >= 0 and self.kernel_img[position] == 0

        for tokens_backwards in range(current_index_in_array):
            for chars_in_token_backwards in range(50):
                position -= 1
                assert position >= 0

                # (caveat: we may overlap on "kallsyms_markers" for the
                # last entry, so also check for high-range characters)

                if self.kernel_img[position] == 0 or self.kernel_img[
                    position
                ] > ord('z'):
                    break

                if chars_in_token_backwards >= 50 - 1:
                    raise ValueError(
                        'This structure is not a kallsyms_token_table'
                    )

        position += 1
        position += -position % 4

        self.kallsyms_token_table__offset = position

        logging.info(
            '[+] Found kallsyms_token_table at file offset 0x%08x'
            % self.kallsyms_token_table__offset
        )

    def find_kallsyms_token_index(self):
        # Get to the end of the kallsyms_token_table

        position = self.kallsyms_token_table__offset

        all_token_offsets = []

        position -= 1

        for tokens_forward in range(256):
            position += 1

            all_token_offsets.append(
                position - self.kallsyms_token_table__offset
            )

            for chars_in_token_forward in range(50):
                position += 1

                if self.kernel_img[position] == 0:
                    break

                if chars_in_token_forward >= 50 - 1:
                    raise ValueError(
                        'This structure is not a kallsyms_token_table'
                    )

        # Find kallsyms_token_index through the offset through searching
        # the reconstructed structure, also use this to guess endianness

        MAX_ALIGNMENT = 256
        KALLSYMS_TOKEN_INDEX__SIZE = 256 * 2

        memory_to_search = bytes(
            self.kernel_img[
                position : position
                + KALLSYMS_TOKEN_INDEX__SIZE
                + MAX_ALIGNMENT
            ]
        )

        little_endian_offsets = pack(
            '<%dH' % len(all_token_offsets), *all_token_offsets
        )
        big_endian_offsets = pack(
            '>%dH' % len(all_token_offsets), *all_token_offsets
        )

        found_position_for_le_value = memory_to_search.find(
            little_endian_offsets
        )
        found_position_for_be_value = memory_to_search.find(big_endian_offsets)

        if found_position_for_le_value == found_position_for_be_value == -1:
            raise ValueError('The value of kallsyms_token_index was not found')

        elif found_position_for_le_value > found_position_for_be_value:
            self.is_big_endian = False

            self.kallsyms_token_index__offset = (
                position + found_position_for_le_value
            )

        elif found_position_for_be_value > found_position_for_le_value:
            self.is_big_endian = True

            self.kallsyms_token_index__offset = (
                position + found_position_for_be_value
            )

        self.kallsyms_token_index_end__offset = (
            self.kallsyms_token_index__offset + len(little_endian_offsets)
        )

        logging.info(
            '[+] Found kallsyms_token_index at file offset 0x%08x'
            % self.kallsyms_token_index__offset
        )

    def find_kallsyms_names_uncompressed(self):
        """
        OpenWRT versions since 2013 may have an
        uncompressed kallsyms table built-in.
        """

        # Find the length byte-separated symbol names

        ksymtab_match = search(
            rb'(?:[\x05-\x23][TWtbBrRAdD][a-z0-9_.]{4,34}){14}',
            self.kernel_img,
        )

        if not ksymtab_match:
            raise KallsymsNotFoundException(
                'No embedded symbol table found in this kernel'
            )

        self.kallsyms_names__offset = ksymtab_match.start(0)

        # Count the number of symbol names

        position = self.kallsyms_names__offset
        self.number_of_symbols = 0

        self.symbol_names: list[str] = []

        while position + 1 < len(self.kernel_img):
            if (
                self.kernel_img[position] < 2
                or chr(self.kernel_img[position + 1]).lower()
                not in 'abdrtvwginpcsu-?'
            ):
                break

            symbol_name_and_type: bytes = self.kernel_img[
                position + 1 : position + 1 + self.kernel_img[position]
            ]

            if not match(rb'^[\x21-\x7e]+$', symbol_name_and_type):
                break

            position += 1 + self.kernel_img[position]
            self.number_of_symbols += 1

        if self.number_of_symbols < 100:
            raise KallsymsNotFoundException(
                'No embedded symbol table found in this kernel'
            )

        logging.info(
            '[+] Kernel symbol names found at file offset 0x%08x'
            % ksymtab_match.start(0)
        )

        logging.info(
            '[+] Found %d uncompressed kernel symbols (end at 0x%08x)'
            % (self.number_of_symbols, position)
        )

        self.end_of_kallsyms_names_uncompressed = position

    def find_kallsyms_markers_uncompressed(self):
        """
        This is the OpenWRT-specific version of the
        "find_kallsyms_markers" method below. It works
        the same except that is tries to guess the integer
        size forward rather than backard.
        """

        position = self.end_of_kallsyms_names_uncompressed
        position += -position % 4

        max_number_of_space_between_two_nulls = 0

        # Go just after the first chunk of non-null bytes

        while (
            position + 1 < len(self.kernel_img)
            and self.kernel_img[position + 1] == 0
        ):
            position += 1

        for null_separated_bytes_chunks in range(20):
            num_non_null_bytes = (
                1  # we always start at a non-null byte in this loop
            )
            num_null_bytes = 1  # we will at least encounter one null byte before the end of this loop

            while True:
                position += 1
                assert position >= 0

                if self.kernel_img[position] == 0:
                    break
                num_non_null_bytes += 1

            while True:
                position += 1
                assert position >= 0

                if self.kernel_img[position] != 0:
                    break
                num_null_bytes += 1

            max_number_of_space_between_two_nulls = max(
                max_number_of_space_between_two_nulls,
                num_non_null_bytes + num_null_bytes,
            )

        if (
            max_number_of_space_between_two_nulls % 2 == 1
        ):  # There may be a leap to a shorter offset in the latest processed entries
            max_number_of_space_between_two_nulls -= 1

        if max_number_of_space_between_two_nulls not in (2, 4, 8):
            raise ValueError(
                'Could not guess the architecture register '
                + 'size for kernel'
            )

        self.offset_table_element_size = max_number_of_space_between_two_nulls

        # Once the size of a long has been guessed, use it to find
        # the first offset (0)

        position = self.end_of_kallsyms_names_uncompressed
        position += -position % 4

        # Go just at the first non-null byte

        while (
            position < len(self.kernel_img) and self.kernel_img[position] == 0
        ):
            position += 1

        likely_is_big_endian = position % self.offset_table_element_size > 1
        if self.is_big_endian is None:  # Manual architecture specification
            self.is_big_endian = likely_is_big_endian

        if position % self.offset_table_element_size == 0:
            position += self.offset_table_element_size
        else:
            position += -position + self.offset_table_element_size

        position -= self.offset_table_element_size
        position -= self.offset_table_element_size

        position -= position % self.offset_table_element_size

        self.kallsyms_markers__offset = position

        logging.info(
            '[+] Found kallsyms_markers at file offset 0x%08x' % position
        )

    def find_kallsyms_markers(self):
        """
        kallsyms_markers contains one offset in kallsyms_names for each
        1 in 256 entries of it. Offsets are stored as either ".long"
        (a Gnu AS type that corresponds for example to 4 bytes in
        x86_64) since kernel v4.20, either as the maximum register
        byte of the system (the C "long" type) on older kernels.
        Remember about the size of this field for later.
        The first index is always 0, it is sorted, and it is aligned.
        """

        # Try possible sizes for the table element (long type)
        for table_element_size in (8, 4, 2):
            position = self.kallsyms_token_table__offset
            endianness_marker = '>' if self.is_big_endian else '<'
            long_size_marker = {2: 'H', 4: 'I', 8: 'Q'}[table_element_size]

            # Search for start of kallsyms_markers given first element is 0 and it is sorted
            for _ in range(32):
                position = self.kernel_img.rfind(
                    b'\x00' * table_element_size, 0, position
                )
                position -= position % table_element_size
                entries = unpack_from(
                    endianness_marker + '4' + long_size_marker,
                    self.kernel_img,
                    position,
                )
                if entries[0] != 0:
                    continue

                for i in range(1, len(entries)):
                    # kallsyms_names entries are at least 2 bytes and at most 0x3FFF bytes long
                    if (
                        entries[i - 1] + 0x200 >= entries[i]
                        or entries[i - 1] + 0x40000 < entries[i]
                    ):
                        break
                else:
                    logging.info(
                        '[+] Found kallsyms_markers at file offset 0x%08x'
                        % position
                    )
                    self.kallsyms_markers__offset = position
                    self.offset_table_element_size = table_element_size
                    return
        raise ValueError('Could not find kallsyms_markers')

    def find_kallsyms_names(self):
        position = self.kallsyms_markers__offset

        # Approximate the position of kallsyms_names based on the
        # last entry of "kallsyms_markers" - we'll determine the
        # precise position in the next method

        endianness_marker = '>' if self.is_big_endian else '<'

        long_size_marker = {2: 'H', 4: 'I', 8: 'Q'}[
            self.offset_table_element_size
        ]

        # Estimate kallsyms_markers length. Limit to 3000 for kernels with kallsyms_seqs_of_names
        num_of_kallsyms_markers_entries = (
            self.kallsyms_token_table__offset - self.kallsyms_markers__offset
        ) // self.offset_table_element_size

        kallsyms_markers_entries = unpack_from(
            endianness_marker
            + str(min(3000, num_of_kallsyms_markers_entries))
            + long_size_marker,
            self.kernel_img,
            self.kallsyms_markers__offset,
        )

        for i in range(1, len(kallsyms_markers_entries)):
            curr = kallsyms_markers_entries[i]
            last = kallsyms_markers_entries[i - 1]
            if last + 0x200 >= curr or last + 0x40000 < curr:
                kallsyms_markers_entries = kallsyms_markers_entries[:i]
                break

        last_kallsyms_markers_entry = list(
            filter(None, kallsyms_markers_entries)
        )[-1]

        position -= last_kallsyms_markers_entry

        position += -position % self.offset_table_element_size

        assert position > 0

        self.kallsyms_names__offset = position
        # Guessing continues in the function below (in order to handle the
        # absence of padding)

    def find_kallsyms_num_syms(self):
        needle = -1

        token_table = self.get_token_table()
        possible_symbol_types = [i.value for i in KallsymsSymbolType]

        dp = []

        while needle == -1:
            position = self.kallsyms_names__offset

            # Check whether this looks like the correct symbol
            # table, first depending on the beginning of the
            # first symbol (as this is where an uncertain gap
            # of 4 padding bytes may be present depending on
            # versions or builds), then thorough the whole
            # table. Raise an issue further in the code (in
            # another function) if an exotic kind of symbol is
            # found somewhere else than in the first entry.

            first_token_index_of_first_name = self.kernel_img[position + 1]
            first_token_of_first_name = token_table[
                first_token_index_of_first_name
            ]

            if (
                not (
                    first_token_of_first_name[0].lower() in 'uvw'
                    and first_token_of_first_name[0] in possible_symbol_types
                )
                and first_token_of_first_name[0].upper()
                not in possible_symbol_types
            ):
                self.kallsyms_names__offset -= 4
                if self.kallsyms_names__offset < 0:
                    raise ValueError('Could not find kallsyms_names')
                continue

            # Each entry in the symbol table starts with a u8 size followed by the contents.
            # The table ends with an entry of size 0, and must lie before kallsyms_markers.
            # This for loop uses a bottom-up DP approach to calculate the numbers of symbols without recalculations.
            # dp[i] is the length of the symbol table given a starting position of "kallsyms_markers - i"
            # If the table position is invalid, i.e. it reaches out of bounds, the length is marked as -1.
            # The loop ends with the number of symbols for the current position in the last entry of dp.

            for i in range(
                len(dp), self.kallsyms_markers__offset - position + 1
            ):
                curr = self.kernel_img[self.kallsyms_markers__offset - i]
                if curr & 0x80:
                    # "Big" symbol
                    symbol_size = (
                        curr & 0x7F
                        | (
                            self.kernel_img[
                                self.kallsyms_markers__offset - i + 1
                            ]
                            << 7
                        )
                    ) + 2
                else:
                    symbol_size = curr + 1
                next_i = i - symbol_size
                if curr == 0:  # Last entry of the symbol table
                    dp.append(0 if i <= 256 else -1)
                elif (
                    next_i < 0 or dp[next_i] == -1
                ):  # If table would exceed kallsyms_markers, mark as invalid
                    dp.append(-1)
                else:
                    dp.append(dp[next_i] + 1)
            num_symbols = dp[-1]

            if num_symbols < 256:
                self.kallsyms_names__offset -= 4
                if self.kallsyms_names__offset < 0:
                    raise ValueError('Could not find kallsyms_names')
                continue

            self.num_symbols = num_symbols

            # Find the long or PTR (it should be the same size as a kallsyms_marker
            # entry) encoding the number of symbols right before kallsyms_names

            endianness_marker = '>' if self.is_big_endian else '<'

            long_size_marker = {2: 'H', 4: 'I', 8: 'Q'}[
                self.offset_table_element_size
            ]

            MAX_ALIGNMENT = 256

            encoded_num_symbols = pack(
                endianness_marker + long_size_marker, num_symbols
            )

            needle = self.kernel_img.rfind(
                encoded_num_symbols,
                max(0, self.kallsyms_names__offset - MAX_ALIGNMENT - 20),
                self.kallsyms_names__offset,
            )

            if (
                needle == -1
            ):  # There may be no padding between kallsyms_names and kallsyms_num_syms, if the alignment is already correct: in this case: try other offsets for "kallsyms_names"
                self.kallsyms_names__offset -= 4
                if self.kallsyms_names__offset < 0:
                    raise ValueError('Could not find kallsyms_names')

        logging.info(
            '[+] Found kallsyms_names at file offset 0x%08x (%d symbols)'
            % (self.kallsyms_names__offset, self.num_symbols)
        )

        position = needle

        self.kallsyms_num_syms__offset = position

        logging.info(
            '[+] Found kallsyms_num_syms at file offset 0x%08x' % position
        )

    """
        This method defines self.kallsyms_addresses_or_offsets__offset,
        self.has_base_relative, self.has_absolute_percpu, self.relative_base_address (may be None)
        and the "self.kernel_addresses" list (the only one variable that shoud le
        externally used, it contains the decoded addresses for items, calculated
        from offsets relative to the specified base for recent kernels with
        CONFIG_KALLSYMS_BASE_RELATIVE)
    """

    def find_kallsyms_addresses_or_symbols(self):
        # --- New checks here

        kernel_major = int(self.version_number.split('.')[0])
        kernel_minor = int(self.version_number.split('.')[1])

        # Is CONFIG_KALLSYMS_BASE_RELATIVE (https://github.com/torvalds/linux/blob/v5.4/init/Kconfig#L1609) likely enabled?

        likely_has_base_relative = False

        if (
            kernel_major > 4
            or (kernel_major == 4 and kernel_minor >= 6)
            and 'ia64' not in self.version_string.lower()
            and 'itanium' not in self.version_string.lower()
        ):
            likely_has_base_relative = True

        # Does the system seem to be 64-bits?

        # Previously: inference from kernel version string
        # likely_is_64_bits = bool(self.offset_table_element_size >= 8 or search('itanium|(?:amd|aarch|ia|arm|x86_|\D-)64', self.version_string, flags = IGNORECASE))

        # Now: inference from ISA prologues signature detection
        likely_is_64_bits = self.is_64_bits

        # Is CONFIG_KALLSYMS_ABSOLUTE_PERCPU (https://github.com/torvalds/linux/blob/v5.4/init/Kconfig#L1604) likely enabled?

        # ==> We'll guess through looking for negative symbol values

        # Try different possibilities heuristically:

        heuristic_search_parameters = (
            [(True, True), (False, False)]
            if likely_has_base_relative
            else [(False, True), (False, False)]
        )
        if self.override_relative_base:
            heuristic_search_parameters = [(False, False)]
        for has_base_relative, can_skip in heuristic_search_parameters:
            address_byte_size = (
                8 if likely_is_64_bits else self.offset_table_element_size
            )
            offset_byte_size = min(
                4, self.offset_table_element_size
            )  # Size of an assembly ".long"

            if kernel_major > 6 or (kernel_major == 6 and kernel_minor >= 4):
                # Linux 6.4 or later place (kallsyms_addresses)/(kallsyms_offsets+kallsyms_relative_base) after kallsyms_token_index.

                # The align_size is defined at (https://github.com/torvalds/linux/blob/v6.4/scripts/kallsyms.c#L390).
                align_size = 8 if likely_is_64_bits else 4

                position = self.kallsyms_token_index_end__offset
                position += -position % align_size

                if has_base_relative:
                    position += self.num_symbols * offset_byte_size
                    position += -position % align_size
                    position += address_byte_size

                else:
                    position += self.num_symbols * address_byte_size

            else:
                position = self.kallsyms_num_syms__offset

            # Now, position should point to some address immediately following the kallsyms_addresses or kallsyms_relative_base
            # Go right after the previous address. And we may skip some alignments.

            while True:
                assert (
                    position > 0
                )  # >= self.offset_table_element_size # Needed?

                previous_word = self.kernel_img[
                    position - address_byte_size : position
                ]

                if previous_word != address_byte_size * b'\x00':
                    break
                position -= address_byte_size

            if has_base_relative:
                self.has_base_relative = True

                position -= address_byte_size

                # Parse the base_relative value

                self.relative_base_address: int = int.from_bytes(
                    self.kernel_img[position : position + address_byte_size],
                    'big' if self.is_big_endian else 'little',
                )

                # Go right after the previous offset

                while True:
                    assert (
                        position > 0
                    )  # >= self.offset_table_element_size # Needed?

                    previous_word = self.kernel_img[
                        position - offset_byte_size : position
                    ]

                    if previous_word != offset_byte_size * b'\x00':
                        break
                    position -= offset_byte_size

                position -= self.num_symbols * offset_byte_size

            else:
                self.has_base_relative = False

                position -= self.num_symbols * address_byte_size

            self.kallsyms_addresses_or_offsets__offset = position

            # Check the obtained values

            endianness_marker = '>' if self.is_big_endian else '<'

            if self.has_base_relative:
                long_size_marker = {2: 'h', 4: 'i'}[
                    offset_byte_size
                ]  # Offsets may be negative, contrary to addresses
            else:
                long_size_marker = {2: 'H', 4: 'I', 8: 'Q'}[address_byte_size]

            # Parse symbols addresses

            tentative_addresses_or_offsets = list(
                unpack_from(
                    endianness_marker
                    + str(self.num_symbols)
                    + long_size_marker,
                    self.kernel_img,
                    self.kallsyms_addresses_or_offsets__offset,
                )
            )

            if self.has_base_relative:
                number_of_negative_items = len(
                    [
                        offset
                        for offset in tentative_addresses_or_offsets
                        if offset < 0
                    ]
                )

                # Many kernels put their addresses in the upper half of the
                # virtual address space. This means that many of the addresses
                # will look like negative numbers. On the other hand (?), there
                # should be the same zeroes in the high part of the address.

                # A true negative address will probably have the top 3 nibbles
                # or so as in 0xfff00000.  Let's check this as well.

                BITS = 64 if self.is_64_bits else 32
                NEGATIVE_HEURISTIC_MASK = 0xFFF << (
                    BITS - 12
                )  # Mask for the top 3 nibbles
                ABSOLUTE_HEURISTIC_MASK = 0x3F << (
                    BITS - 8
                )  # Mask for zeros in the top byte

                heuristically_negative = len(
                    [
                        offset
                        for offset in tentative_addresses_or_offsets
                        if (offset & NEGATIVE_HEURISTIC_MASK)
                        == NEGATIVE_HEURISTIC_MASK
                    ]
                )
                heuristically_absolute = len(
                    [
                        offset
                        for offset in tentative_addresses_or_offsets
                        if (offset & ABSOLUTE_HEURISTIC_MASK) == 0
                    ]
                )

                heuristic_negative_percent = heuristically_negative / len(
                    tentative_addresses_or_offsets
                )
                heuristic_absolute_percent = heuristically_absolute / len(
                    tentative_addresses_or_offsets
                )

                if heuristic_negative_percent < 0.5:
                    logging.warning(
                        f'[!] WARNING: Less than half ({math.trunc(heuristic_negative_percent * 100)}%) of offsets are negative'
                    )
                    logging.warning(
                        '             You may want to re-run this utility, overriding the relative base'
                    )

                if heuristic_absolute_percent > 0.5:
                    logging.warning(
                        f'[!] WARNING: More than half ({math.trunc(heuristic_absolute_percent * 100)}%) of offsets look like absolute addresses'
                    )
                    logging.warning(
                        '[!]          You may want to re-run this utility, overriding the relative base'
                    )

                if (
                    heuristic_absolute_percent > 0.5
                    or heuristic_negative_percent < 0.5
                ):
                    logging.info(
                        '[i] Note: sometimes there is junk at the beginning of the kernel, and the load address is not the guessed'
                    )
                    logging.info(
                        '          base address. You may need to play around with different load addresses to get everything'
                    )
                    logging.info(
                        '          to line up. There may be some decent tables in the kernel with known patterns that could be'
                    )
                    logging.info(
                        '          used to line things up heuristically, but this has not been explored this yet.'
                    )

                logging.info(
                    '[i] Negative offsets overall: %g %%'
                    % (
                        number_of_negative_items
                        / len(tentative_addresses_or_offsets)
                        * 100
                    )
                )

                if (
                    number_of_negative_items
                    / len(tentative_addresses_or_offsets)
                    >= 0.5
                ):  # Non-absolute symbols are negative with CONFIG_KALLSYMS_ABSOLUTE_PERCPU
                    self.has_absolute_percpu = True

                    tentative_addresses_or_offsets = [
                        (
                            (self.relative_base_address - 1 - offset)
                            if offset < 0
                            else offset
                        )
                        for offset in tentative_addresses_or_offsets
                    ]  # https://github.com/torvalds/linux/blob/v5.4/kernel/kallsyms.c#L159
                else:
                    self.has_absolute_percpu = False

                    tentative_addresses_or_offsets = [
                        offset + self.relative_base_address
                        for offset in tentative_addresses_or_offsets
                    ]

            else:
                self.has_absolute_percpu = False

            number_of_null_items = len(
                [
                    address
                    for address in tentative_addresses_or_offsets
                    if address == 0
                ]
            )

            logging.info(
                '[i] Null addresses overall: %g %%'
                % (
                    number_of_null_items
                    / len(tentative_addresses_or_offsets)
                    * 100
                )
            )

            if (
                number_of_null_items / len(tentative_addresses_or_offsets)
                >= 0.2
            ):  # If there are too much null symbols we have likely tried to parse the wrong integer size
                if can_skip:
                    continue

            logging.info(
                '[+] Found %s at file offset 0x%08x'
                % (
                    'kallsyms_offsets'
                    if self.has_base_relative
                    else 'kallsyms_addresses',
                    position,
                )
            )

            self.kernel_addresses = tentative_addresses_or_offsets

            break

    def get_token_table(self) -> list:
        if not self.uncompressed_kallsyms:
            # Parse symbol name tokens

            tokens = []

            position = self.kallsyms_token_table__offset

            for num_token in range(256):
                token = ''

                while self.kernel_img[position]:
                    token += chr(self.kernel_img[position])
                    position += 1

                position += 1

                tokens.append(token)

        else:
            tokens = [chr(i) for i in range(256)]

        return tokens

    def parse_symbol_table(self):
        tokens = self.get_token_table()

        # Parse symbol names

        self.symbol_names = []

        position = self.kallsyms_names__offset

        for num_symbol in range(self.num_symbols):
            symbol_name = ''

            length = self.kernel_img[position]
            position += 1
            if length & 0x80:
                length = length & 0x7F | (self.kernel_img[position] << 7)
                position += 1

            for i in range(length):
                symbol_token_index = self.kernel_img[position]
                symbol_token = tokens[symbol_token_index]
                position += 1

                symbol_name += symbol_token

            self.symbol_names.append(symbol_name)

        # Build consistent objects

        self.symbols = []
        self.name_to_symbol = {}

        for symbol_address, symbol_name in zip(
            self.kernel_addresses, self.symbol_names
        ):
            symbol = KallsymsSymbol()

            symbol.name = symbol_name[1:]  # Exclude the type letter

            symbol.virtual_address = symbol_address

            if symbol_name[0].lower() in 'uvw':
                symbol.symbol_type = KallsymsSymbolType(symbol_name[0])
                symbol.is_global = True

            else:
                symbol.symbol_type = KallsymsSymbolType(symbol_name[0].upper())
                symbol.is_global = symbol_name[0].isupper()

            self.symbols.append(symbol)

            self.name_to_symbol[symbol.name] = symbol

    def print_symbols_debug(self):
        # Print symbol types (debug)

        symbol_types = set()

        for symbol_name in self.symbol_names:
            symbol_types.add(symbol_name[0])

        logging.info('Symbol types => %r' % sorted(symbol_types))
        logging.info('')

        # Print symbols, in a fashion similar to /proc/kallsyms

        for symbol_address, symbol_name in zip(
            self.kernel_addresses, self.symbol_names
        ):
            logging.info(
                '{0:s} {1:s} {2:s}'.format(
                    '%016x' % symbol_address
                    if self.is_64_bits
                    else '%08x' % symbol_address,
                    symbol_name[0],  # The symbol type
                    symbol_name[1:],  # The symbol name itself
                )
            )

```

`vmlinux_to_elf/core/vmlinuz_decompressor.py`:

```py
#!/usr/bin/env python3
# -*- encoding: Utf-8 -*-
import importlib
import logging
from gzip import _GzipReader
from io import SEEK_END, BytesIO
from struct import unpack

"""
    How to detect a vmlinuz file?
    
    A "standard" script for it does not
    attempt to interprete architecture-specific
    details, but just scans for a file compression
    signature:
    https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux
    
    This script uses supports the following compression formats, which are all
    the standard compression formats for the kernel, some of which have been
    added quite recently (including LZO, LZ4 and Facebook's ZSTD):
    
    try_decompress b'\x1f\x8b\x08'  xy    gunzip          1f8b08
    try_decompress b'\xfd7zXZ\x00'  abcde unxz            fd377a585a00   (AND NOT "fd377a585a00000000".decode('hex')+"XZ decompressor")
    try_decompress b'BZh'           xy    bunzip2
    try_decompress b']\x00\x00\x00' xxx   unlzma
    try_decompress b'\x89LZ'        xy    'lzop -d'
    try_decompress b'\x02!L\x18'    xxx   'lz4 -d'
    try_decompress b'(\xb5/\xfd'    xxx   unzstd
    
    On x86:
    Sample assembly is here https://github.com/torvalds/linux/blob/master/arch/x86/boot/header.S#L300
    => How does libmagic detect it?
    ==> https://github.com/threatstack/libmagic/blob/master/magic/Magdir/linux#L99
    
    On ARM:
    Sample assembly is here https://github.com/torvalds/linux/blob/master/arch/arm/boot/compressed/head.S#L180
    => Magics defined here: https://github.com/torvalds/linux/blob/master/arch/arm/boot/compressed/vmlinux.lds.S#L111
    ==> Magic numbers are: 0x04030201 and 0x016f2818
    ==> The data put after allows to know the offset of the end of the compressed vmlinuz executable (the total file size normally), and jump from the end of the size to the offset of the integer containing the offset to the compressed XZ data (located at -0x28 from the end (is this an appended dtb?))
    ==> Additional information with magics numbers 0x45454545 and 0x5a534c4b has been added as of September 2017 (kernel 4.15)
    => How does binwalk detect it?
    => How does libmagic detect it?
    ==> https://github.com/threatstack/libmagic/blob/master/magic/Magdir/linux#L194
"""

"""
    This class contains well-known vmlinux signatures
"""


class Signature:
    Compressed_GZIP = b'\x1f\x8b\x08'
    Compressed_XZ = b'\xfd7zXZ\x00'
    Compressed_LZMA = b']\x00\x00'
    Compressed_BZ2 = b'BZh'
    Compressed_LZ4 = b'\x04"M\x18'  # https://github.com/lz4/lz4/blob/dev/doc/lz4_Frame_format.md
    Compressed_LZ4_Legacy = b'\x02!L\x18'
    Compressed_ZSTD = b'(\xb5/\xfd'
    Compressed_LZO = b'\x89LZ'
    DTB_Appended_Qualcomm = b'UNCOMPRESSED_IMG'  # https://www.google.com/search?q="PATCHED_KERNEL_MAGIC"
    Android_Bootimg = b'ANDROID!'  # https://source.android.com/devices/bootloader/boot-image-header

    Compressed = [
        Compressed_GZIP,
        Compressed_XZ,
        Compressed_LZMA,
        Compressed_BZ2,
        Compressed_LZ4,
        Compressed_LZ4_Legacy,
        Compressed_ZSTD,
        Compressed_LZO,
    ]

    @staticmethod
    def check(data, offset, sign):
        return sign == data[offset : offset + len(sign)]

    @staticmethod
    def is_compressed(data, offset):
        for sign in Signature.Compressed:
            if Signature.check(data, offset, sign):
                return True
        return False


"""
    This class will try to read a single GZip file
    out of a given input buffer, rather than an unlimited
    number of succeeding GZip files.
    
    The constructor takes a single BytesIO instance as an
    argument.
"""


class SingleGzipReader(_GzipReader):
    read_one_gzip_header: bool = False
    __new_member: bool = None

    @property
    def _new_member(self):
        return self.__new_member

    @_new_member.setter
    def _new_member(
        self, new_value
    ):  # Property normally set to True once per GZip header to be read
        if new_value:
            if self.read_one_gzip_header:
                self._fp.file.seek(
                    0, SEEK_END
                )  # Simulate EOF when called for the second time
                self._fp._read = None
            self.read_one_gzip_header = True
        self.__new_member = new_value


"""
    Try to decompress a file at a given offset, without
    knowing the compression algorithm
"""


def try_decompress_at(input_file: bytes, offset: int) -> bytes:
    decoded = None
    try:
        if Signature.check(
            input_file, offset, Signature.DTB_Appended_Qualcomm
        ):  # Merely unpack a Qualcomm kernel file containing a magic and DTB offset at the start (so that offsets aren't wrong)
            dtb_offset_le = int.from_bytes(
                input_file[offset + 16 : offset + 20], 'little'
            )
            dtb_offset_be = int.from_bytes(
                input_file[offset + 16 : offset + 20], 'big'
            )

            decoded = input_file[
                offset + 20 : offset + 20 + min(dtb_offset_le, dtb_offset_be)
            ]

        elif Signature.check(
            input_file, offset, Signature.Android_Bootimg
        ):  # Unpack an uncompressed Android Bootimg file, version 0, 1, 2, 3, or 4
            # See, for reference:
            # - https://github.com/osm0sis/mkbootimg/blob/master/unpackbootimg.c
            # - https://github.com/osm0sis/mkbootimg/blob/master/bootimg.h

            assert len(input_file) > 4096

            header_version_raw = input_file[offset + 10 * 4 : offset + 11 * 4]
            assert header_version_raw in (
                b'\0\0\0\0',
                b'\0\0\0\1',
                b'\1\0\0\0',
                b'\0\0\0\2',
                b'\2\0\0\0',
                b'\0\0\0\3',
                b'\3\0\0\0',
                b'\0\0\0\4',
                b'\4\0\0\0',
            ), f'Unsupported Android bootimg version {header_version_raw}'

            endianness = 'little'

            if header_version_raw in (
                b'\0\0\0\3',
                b'\3\0\0\0',
                b'\0\0\0\4',
                b'\4\0\0\0',
            ):
                page_size = 4096

                if header_version_raw in (b'\0\0\0\3', b'\0\0\0\4'):
                    endianness = 'big'

            else:
                page_size_raw = input_file[offset + 9 * 4 : offset + 10 * 4]

                page_size_le = int.from_bytes(page_size_raw, 'little')
                page_size_be = int.from_bytes(page_size_raw, 'big')

                if page_size_le < page_size_be:
                    page_size = page_size_le
                else:
                    endianness = 'big'
                    page_size = page_size_be

            kernel_size = int.from_bytes(
                input_file[offset + 2 * 4 : offset + 3 * 4], endianness
            )

            assert len(input_file) > kernel_size > 0x1000
            assert len(input_file) > page_size > 0x200

            decoded = input_file[
                offset + page_size : offset + page_size + kernel_size
            ]

            # Also try to re-unpack the output image in the case where the nested
            # kernel would start with a "UNCOMPRESSED_IMG" Qualcomm magic, for example

            decoded = try_decompress_at(decoded, 0) or decoded

        elif Signature.check(input_file, offset, Signature.Compressed_GZIP):
            decoded = SingleGzipReader(
                BytesIO(input_file[offset:])
            ).read(
                -1
            )  # GZIP - Will stop reading after the GZip footer thanks to our modification above.

        elif Signature.check(
            input_file, offset, Signature.Compressed_XZ
        ) or Signature.check(input_file, offset, Signature.Compressed_LZMA):
            from lzma import LZMADecompressor

            try:
                decoded = LZMADecompressor().decompress(
                    input_file[offset:]
                )  # LZMA - Will discard the extra bytes and put it an attribute.

            except Exception:
                decoded = LZMADecompressor().decompress(
                    input_file[offset : offset + 5]
                    + b'\xff' * 8
                    + input_file[offset + 5 :]
                )  # pylzma format compatibility

        elif Signature.check(input_file, offset, Signature.Compressed_BZ2):
            from bz2 import BZ2Decompressor

            decoded = BZ2Decompressor().decompress(
                input_file[offset:]
            )  # BZ2 - Will discard the extra bytes and put it an attribute.

        elif Signature.check(
            input_file, offset, Signature.Compressed_LZ4
        ):  # LZ4 support
            LZ4Decompressor = importlib.import_module('lz4.frame')

            context = LZ4Decompressor.create_decompression_context()
            decoded, bytes_read, end_of_frame = (
                LZ4Decompressor.decompress_chunk(context, input_file[offset:])
            )

        elif Signature.check(
            input_file, offset, Signature.Compressed_LZ4_Legacy
        ):  # LZ4 support (legacy format)
            from vmlinux_to_elf.utils.lz4_legacy import decompress_lz4_buffer

            decoded = decompress_lz4_buffer(BytesIO(input_file[offset:]))

        elif Signature.check(input_file, offset, Signature.Compressed_ZSTD):
            import zstandard as zstd

            buf = BytesIO()
            context = zstd.ZstdDecompressor()
            for chunk in context.read_to_iter(BytesIO(input_file[offset:])):
                buf.write(chunk)
            buf.seek(0)
            decoded = buf.read()

        elif Signature.check(input_file, offset, Signature.Compressed_LZO):
            import minilzo

            buf = BytesIO(input_file[offset:])
            decoded = minilzo.LzoFile(fileobj=buf, mode='rb').read()
    except Exception:
        pass

    if decoded and 0 in decoded[:32] and len(decoded) > 0x1000:
        logging.info(
            (
                '[+] Kernel successfully decompressed in-memory (the offsets that '
                + 'follow will be given relative to the decompressed binary)'
            )
        )

        return decoded


def obtain_raw_kernel_from_file(input_file: bytes) -> bytes:
    # Check for known signatures at fixed offsets.
    #
    # Note that mangled semi-correct kernel version strings may be present
    # in the compressed output at this point, so don't check for a kernel
    # version string for now.

    file_size = len(input_file)

    # Try offsets that may be stored in the
    # last words of the file, as well for
    # the start of the file

    possible_offsets: set[int] = set([0])

    for possible_endianness in '<>':
        possible_offsets |= set(
            unpack(
                possible_endianness + '20I', input_file[file_size - 4 * 20 :]
            )
        )

    for possible_offset in sorted(possible_offsets):
        decompressed_data = try_decompress_at(input_file, possible_offset)
        if decompressed_data:
            return decompressed_data

    if not input_file.startswith(b'\x7fELF'):
        # If not successful, scan for compression signatures in the whole document
        for possible_signature in Signature.Compressed:
            possible_offset = input_file.find(possible_signature)

            while possible_offset > -1:
                decompressed_data = try_decompress_at(
                    input_file, possible_offset
                )
                if decompressed_data:
                    return decompressed_data
                possible_offset = input_file.find(
                    possible_signature, possible_offset + 1
                )

    return input_file

```

`vmlinux_to_elf/kernel_db/README.md`:

```md
# Kernel version info database folder

The data contained in this folder was generated from the scripts available at https://github.com/marin-m/vte-samplelib
```

`vmlinux_to_elf/kernel_db/database.py`:

```py
#!/usr/bin/env python3
# -*- encoding: Utf-8 -*-

from os.path import dirname, realpath, exists
from enum import Enum

from peewee import (
    SqliteDatabase,
    Model,
    CompositeKey,
    Check,
    TextField,
    IntegerField,
    DateField,
    DateTimeField,
    BooleanField,
    ForeignKeyField,
)

DB_FOLDER = dirname(realpath(__file__))
DB_PATH = realpath(DB_FOLDER + '/database.sqlite3')

db = SqliteDatabase(DB_PATH)


class Base(Model):
    class Meta:
        database = db
        legacy_table_names = False


class KernelVersion(Base):
    version_string = TextField(primary_key=True)  # Git tag
    kernel_source = TextField(
        constraints=[Check("kernel_source in ('git', 'tarball')")]
    )

    browse_url = TextField(null=True)
    download_url = TextField()
    git_commit = TextField(null=True)

    release_date = DateTimeField()


class EMachineValue(Base):
    elf_machine_int = IntegerField(index=True)
    elf_machine_str = TextField(primary_key=True)


class KnownArchitecture(Base):
    architecture_code = TextField(primary_key=True)
    has_32bit_class = BooleanField(default=False)
    has_64bit_class = BooleanField(default=False)
    has_msb_class = BooleanField(default=False)
    has_lsb_class = BooleanField(default=False)


class ArchitectureEMachineLink(Base):
    architecture = ForeignKeyField(
        KnownArchitecture, backref='e_machine_links'
    )
    e_machine = ForeignKeyField(EMachineValue, backref='arch_code_links')

    class Meta:
        primary_key = CompositeKey('architecture', 'e_machine')


class KernelSupportedArch(Base):
    release = ForeignKeyField(KernelVersion, backref='supported_archs')
    architecture = ForeignKeyField(KnownArchitecture)

    class Meta:
        primary_key = CompositeKey('release', 'architecture')


class KernelRelevantFile(Base):
    release = ForeignKeyField(KernelVersion, backref='relevant_files')

    file_name = TextField()
    # data = TextField()
    architecture_code = TextField(index=True, null=True)
    vcs_browser_url = TextField(null=True)


class KernelVersionDependency(Base):
    # Parsed from the `Documentation/Changes` kernel files:

    kernel_release = ForeignKeyField(KernelVersion, backref='dependencies')
    source_file = ForeignKeyField(KernelRelevantFile, backref='extracted_info')

    dependency_name = TextField()
    minimal_version = TextField()
    base_command = TextField(index=True)
    version_command = TextField()
    dependency_is_optional = BooleanField()

    class Meta:
        primary_key = CompositeKey('kernel_release', 'base_command')


class DebianRelease(Base):
    docker_archive_name = TextField(primary_key=True)
    debian_version_name = TextField(index=True)
    debian_version_number = TextField(index=True)
    debian_release_date = DateField(index=True)


db.connect()

```

`vmlinux_to_elf/scripts/kallsyms_finder.py`:

```py
#!/usr/bin/env python3
# -*- encoding: Utf-8 -*-
import logging
from argparse import ArgumentParser
from sys import stdout

from vmlinux_to_elf.core.architecture_detecter import ArchitectureGuessError
from vmlinux_to_elf.core.kallsyms import KallsymsFinder
from vmlinux_to_elf.core.vmlinuz_decompressor import (
    obtain_raw_kernel_from_file,
)


def main():
    logging.basicConfig(
        stream=stdout, level=logging.INFO, format='%(message)s'
    )

    args = ArgumentParser(
        description="Find the kernel's embedded symbol table from a raw "
        + 'or stripped ELF kernel file, and print these to the standard output with their '
        + 'addresses or optionally save them to a file'
    )

    args.add_argument(
        'input_file', help='Path to the kernel file to extract symbols from'
    )
    args.add_argument(
        '--output', help='Path to the analyzable .kallsyms output'
    )
    args.add_argument(
        '--use-absolute',
        help='Assume kallsyms offsets are absolute addresses',
        action='store_true',
    )
    args.add_argument(
        '--bit-size',
        help='Force overriding the input kernel '
        + 'bit size, providing 32 or 64 bit (rather than auto-detect)',
        type=int,
    )
    args.add_argument(
        '--base-address',
        help='Force overriding the base address used for converting '
        + 'relocations to relative relocations with this integer value (rather than auto-detect)',
        type=lambda st: int(st, 16),
        metavar='HEX_NUMBER',
    )
    # args.add_argument(
    #     '-e',
    #     '--extra-info',
    #     help='Print extra information useful to rebuild the kernel, including links to '
    #     + 'source code',
    #     action='store_true',
    # )

    args = args.parse_args()

    with open(args.input_file, 'rb') as kernel_bin:
        try:
            kallsyms = KallsymsFinder(
                obtain_raw_kernel_from_file(kernel_bin.read()),
                args.bit_size,
                args.use_absolute,
                args.base_address,
                # args.extra_info,
            )

        except ArchitectureGuessError:
            exit(
                '[!] The architecture of your kernel could not be guessed '
                + 'successfully. Please specify the --bit-size argument manually '
                + '(use --help for its precise specification).'
            )

        kallsyms.print_symbols_debug()

        if args.output:
            output_file = (
                args.output
                if args.output.endswith('.kallsyms')
                else args.output + '.kallsyms'
            )
            with open(output_file, 'w') as f:
                for symbol_address, symbol_name in zip(
                    kallsyms.kernel_addresses, kallsyms.symbol_names
                ):
                    address_str = (
                        f'{symbol_address:016x}'
                        if kallsyms.is_64_bits
                        else f'{symbol_address:08x}'
                    )
                    line = (
                        f'{address_str} {symbol_name[0]} {symbol_name[1:]}\n'
                    )
                    f.write(line)


if __name__ == '__main__':
    main()

```

`vmlinux_to_elf/scripts/run_tests.py`:

```py
#!/usr/bin/env python3
# -*- encoding: Utf-8 -*-

"""
Check the program's ability to decompress
the files files whose the absolute path
is referenced by the "test_kernels.txt"
present in the current directory (one kernel
path per line, separated with LF)

As this file is local to your own machine,
it is ignored by the ".gitignore"

It will also write successfully reconstructed
ELF files to an automatically created "tests_output/" folder.
"""

import logging
from os import makedirs
from os.path import dirname, exists, realpath
from re import sub
from sys import stdout
from traceback import print_exc

from vmlinux_to_elf.core.elf_symbolizer import ElfSymbolizer
from vmlinux_to_elf.core.vmlinuz_decompressor import (
    obtain_raw_kernel_from_file,
)

SCRIPT_DIR = dirname(realpath(__file__))

TEST_KERNELS_PATH = realpath(SCRIPT_DIR + '/test_kernels.txt')
ELF_KERNELS_OUTPUT_PATH = realpath(SCRIPT_DIR + '/tests_output')


def slugify(file_path):
    return sub(r'[^a-z0-9]+', '-', file_path.lower()).strip('-')


if __name__ == '__main__':
    logging.basicConfig(
        stream=stdout, level=logging.INFO, format='%(message)s'
    )

    if not exists(TEST_KERNELS_PATH):
        exit(
            (
                '[!] In order to use this script, please '
                + 'create a file at %s, containing to path '
                + 'to one kernel to extract per line. Quitting.'
            )
            % (TEST_KERNELS_PATH)
        )

    makedirs(ELF_KERNELS_OUTPUT_PATH, exist_ok=True)

    for file_name in filter(
        None, map(str.strip, open(TEST_KERNELS_PATH, 'r'))
    ):
        logging.info('Testing ' + file_name)

        with open(file_name, 'rb') as fd:
            contents = fd.read()

        raw_data = obtain_raw_kernel_from_file(contents)
        try:
            ElfSymbolizer(
                raw_data,
                ELF_KERNELS_OUTPUT_PATH + '/' + slugify(file_name) + '.elf',
            )
        except Exception:
            logging.error('=> No symbols!')
            print_exc()

```

`vmlinux_to_elf/scripts/vmlinux_to_elf.py`:

```py
#!/usr/bin/env python3
# -*- encoding: Utf-8 -*-
import logging
from argparse import ArgumentParser
from sys import stdout

from vmlinux_to_elf.core.architecture_detecter import ArchitectureGuessError
from vmlinux_to_elf.core.elf_symbolizer import ElfSymbolizer
from vmlinux_to_elf.core.vmlinuz_decompressor import (
    obtain_raw_kernel_from_file,
)


def main():
    logging.basicConfig(
        stream=stdout, level=logging.INFO, format='%(message)s'
    )

    args = ArgumentParser(
        description='Turn a raw or compressed kernel binary, '
        + 'or a kernel ELF without symbols, into a fully analyzable ELF whose '
        + 'symbols were extracted from the kernel symbol table'
    )

    args.add_argument(
        'input_file',
        help='Path to the vmlinux/vmlinuz/zImage/'
        + 'bzImage/kernel.bin/kernel.elf file to make into an analyzable .ELF',
    )

    args.add_argument(
        'output_file', help='Path to the analyzable .ELF to output'
    )

    args.add_argument(
        '--e-machine',
        help='Force overriding the output ELF '
        + '"e_machine" field with this integer value (rather than auto-detect)',
        type=lambda string: int(string, 0),
        metavar='DECIMAL_NUMBER',
    )

    args.add_argument(
        '--bit-size',
        help='Force overriding the input kernel '
        + 'bit size, providing 32 or 64 bit (rather than auto-detect)',
        type=int,
    )

    args.add_argument(
        '--file-offset',
        help='Consider that the raw kernel starts '
        + 'at this offset of the provided raw file or compressed stream (rather than '
        + '0, or the beginning of the ELF sections if an ELF header was present in the '
        + 'input)',
        type=lambda st: int(st, 16),
        metavar='HEX_NUMBER',
    )

    args.add_argument(
        '--base-address',
        help='Force overriding the output ELF '
        + 'base address field with this integer value (rather than auto-detect)',
        type=lambda st: int(st, 16),
        metavar='HEX_NUMBER',
    )

    args.add_argument(
        '--bss-size',
        help='Size in megabytes of the .bss section in the binary',
        type=int,
        default=16,
    )

    args.add_argument(
        '--use-absolute',
        help='Assume kallsyms offsets are absolute addresses',
        action='store_true',
    )

    # args.add_argument(
    #     '-e',
    #     '--extra-info',
    #     help='Print extra information useful to rebuild the kernel, including links to '
    #     + 'source code',
    #     action='store_true',
    # )

    args = args.parse_args()

    if (args.e_machine is not None and args.bit_size is None) or (
        args.e_machine is None and args.bit_size is not None
    ):
        logging.error(
            '[!] Please specify both an addressing bit size '
            + 'and the ELF "e_machine" field, or neither for '
            + 'auto-detection'
        )

        exit()

    with open(args.input_file, 'rb') as kernel_bin:
        try:
            ElfSymbolizer(
                obtain_raw_kernel_from_file(kernel_bin.read()),
                args.output_file,
                args.e_machine,
                args.bit_size,
                args.base_address,
                args.bss_size,
                args.file_offset,
                args.use_absolute,
                # args.extra_info,
            )

        except ArchitectureGuessError:
            exit(
                '[!] The architecture of your kernel could not be guessed '
                + 'successfully. Please specify the --e-machine and --bit-size '
                + 'arguments manually (use --help for their precise specification).'
            )


if __name__ == '__main__':
    main()

```

`vmlinux_to_elf/utils/elf.py`:

```py
#!/usr/bin/env python3
# -*- encoding: Utf-8 -*-
from ctypes import (
    BigEndianStructure,
    LittleEndianStructure,
    c_char,
    c_int32,
    c_int64,
    c_uint8,
    c_uint16,
    c_uint32,
    c_uint64,
)
from enum import IntEnum
from io import SEEK_END, BytesIO

from vmlinux_to_elf.utils.pretty_print import pretty_print_structure

"""
    This file contains a wrapper for parsing and writing ELF files.
    
    o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o
    o                                                                         o 
    o The ELF specification is here => https://uclibc.org/docs/elf-64-gen.pdf o
    o                                                                         o
    o ftp://www.linux-mips.org/pub/linux/mips/doc/ABI/elf64-2.4.pdf           o
    o                                                                         o
    o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o
    
    Each exposed object may have the following methods, which are called in
        this order when all present:
    
    - from_bytes (classmethod, taking at least a BytesIO): return an instance of
        a subclass of the concerned object while automatically inferring parameters
        such as endianness, bit size or section type
        
    
    - __init__ (taking two booleans): initialize the structure with the knowledge
        of whether the structure should be 64-bit or 32-bit, and whether it should
        be big- or little-endian
    
    - unserialize (taking a BytesIO): unserialize the structure at the current offset
    - _unserialize_contents (taking a BytesIO): unserialize the contents of a section
        (if the concerned object is a section) at the current offset, while unserialize()
        will unserialize the section header
    - post_unserialize (taking no arguments): called once all sections have been unserialized,
        complete fields of the concerned object based on the contents of other sections
        (interlink a relocation entry with symbol table entry, a symbol table entry with
        string table entry...)
    
    - pre_serialize (taking no arguments): counterpart of post_unserialize, updating the
        internal state of objects holding string tables from other sections
    - serialize (taking a BytesIO): serialize the structure at the current offset
    - _serialize_contents (taking a BytesIO): serialize the contents of a section
        (if the concerned object is a section), while serialize() will serialize
        the section header
    
"""

Elf32_Addr = c_uint32
Elf32_Half = c_uint16
Elf32_Off = c_uint32
Elf32_Sword = c_int32
Elf32_Word = c_uint32

Elf64_Addr = c_uint64
Elf64_Half = c_uint16
Elf64_Off = c_uint64
Elf64_Sword = c_int32
Elf64_Sxword = c_int64
Elf64_Word = c_uint32
Elf64_Lword = c_uint64
Elf64_Xword = c_uint64


class VariableEndiannessAndWordsizeStructure:
    def __new__(cls, is_big_endian=False, is_64_bits=False):
        actual_class = type(
            cls.__name__,
            (
                BigEndianStructure if is_big_endian else LittleEndianStructure,
                VariableEndiannessAndWordsizeStructure,
            ),
            {
                **{
                    name: getattr(cls, name)
                    for name in dir(cls)
                    if '__' not in name or name == '__init__'
                },
                'is_big_endian': is_big_endian,
                'is_64_bits': is_64_bits,
                '_pack_': True,
                '_fields_': [
                    (
                        field[0],
                        field[1]
                        if is_64_bits
                        else {c_int64: c_int32, c_uint64: c_uint32}.get(
                            field[1], field[1]
                        ),
                        field[2] if len(field) > 2 else None,
                    )[: 3 if len(field) > 2 else 2]
                    for field in cls._fields_
                ],
            },
        )

        return actual_class()

    def unserialize(self, data: BytesIO):
        data.readinto(self)

    def serialize(self, data: BytesIO):
        data.write(self)

    def pretty_print(self):
        pretty_print_structure(self)


class ElfFile:
    def __init__(self, is_big_endian=False, is_64_bits=False):
        self.is_big_endian = is_big_endian
        self.is_64_bits = is_64_bits

        # Exposed to the user

        self.sections: list[ElfSection] = []

        self.section_string_table: ElfStrtab = None

        self.file_header = ElfFileHeader(is_big_endian, is_64_bits)

        # Not exposed to the user (inferred from sections)

        self.segments: list[Elf32ProgramHeaderEntry] = []

    @classmethod
    def from_bytes(cls, data: BytesIO):
        file_header = data.read(E_IDENT_INDEXES.EI_NIDENT)

        is_64_bits = {EI_CLASS.ELFCLASS32: False, EI_CLASS.ELFCLASS64: True}[
            file_header[E_IDENT_INDEXES.EI_CLASS]
        ]

        is_big_endian = {
            EI_DATA.ELFDATA2LSB: False,
            EI_DATA.ELFDATA2MSB: True,
        }[file_header[E_IDENT_INDEXES.EI_DATA]]

        obj = cls(is_big_endian, is_64_bits)

        data.seek(0)
        obj.unserialize(data)

        return obj

    def unserialize(self, data: BytesIO):
        self.file_header.unserialize(data)

        # Parse sections and data

        for num_section in range(self.file_header.e_shnum):
            data.seek(
                self.file_header.e_shoff
                + self.file_header.e_shentsize * num_section
            )

            self.sections.append(ElfSection.from_bytes(data, self))

        # Name sections and link relocations (now that string and symbol tables are parsed)

        for section in self.sections:
            section.post_unserialize()

        # Remember about the string symbol table section

        self.section_string_table = self.sections[self.file_header.e_shstrndx]

        # Parse the segment headers

        for num_segment in range(self.file_header.e_phnum):
            data.seek(
                self.file_header.e_phoff
                + self.file_header.e_phentsize * num_segment
            )

            segment_class = (
                Elf32ProgramHeaderEntry
                if not self.is_64_bits
                else Elf64ProgramHeaderEntry
            )

            segment = segment_class(self.is_big_endian, self.is_64_bits)

            segment.unserialize(data)

            self.segments.append(segment)

    def serialize(self, data: BytesIO):
        # Filter out .gnu.version not to confuse readelf for now TODO
        self.sections = list(
            filter(
                lambda section: '.gnu.version' not in section.section_name,
                self.sections,
            )
        )

        self.file_header.e_ehsize = memoryview(self.file_header).nbytes

        self.file_header.e_shstrndx = self.sections.index(
            self.section_string_table
        )

        self.file_header.e_shoff = self.file_header.e_ehsize

        self.file_header.e_shnum = len(self.sections)

        self.file_header.e_shentsize = memoryview(
            self.sections[0].section_header
        ).nbytes

        for section in self.sections:
            section.pre_serialize()

        # Write sections and data

        for num_section, section in enumerate(self.sections):
            data.seek(
                self.file_header.e_shoff
                + self.file_header.e_shentsize * num_section
            )

            section.serialize(data)

        # Calculate the address of segments

        section_type_to_segment_type = {
            SH_TYPE.SHT_DYNAMIC: P_TYPE.PT_DYNAMIC,
            SH_TYPE.SHT_NOTE: P_TYPE.PT_NOTE,
        }

        self.segments = []

        for section in self.sections:
            if section.section_header.sh_flags & SH_FLAGS.SHF_ALLOC:
                segment_class = (
                    Elf32ProgramHeaderEntry
                    if not self.is_64_bits
                    else Elf64ProgramHeaderEntry
                )

                segment = segment_class(self.is_big_endian, self.is_64_bits)

                segment.p_type = section_type_to_segment_type.get(
                    section.section_header.sh_type, P_TYPE.PT_LOAD
                )

                segment.p_flags = P_FLAGS.PF_R | P_FLAGS.PF_X | P_FLAGS.PF_W
                if section.section_header.sh_flags & SH_FLAGS.SHF_EXECINSTR:
                    segment.p_flags |= P_FLAGS.PF_X
                if section.section_header.sh_flags & SH_FLAGS.SHF_WRITE:
                    segment.p_flags |= P_FLAGS.PF_W

                segment.p_vaddr = section.section_header.sh_addr
                segment.p_paddr = section.section_header.sh_addr
                segment.p_memsz = section.section_header.sh_size
                segment.p_offset = section.section_header.sh_offset
                segment.p_filesz = (
                    section.section_header.sh_size
                    if not isinstance(section, ElfNoBits)
                    else 0
                )

                self.segments.append(segment)

        if not self.segments:
            raise ValueError(
                'This ELF object does not have a section with SH_ALLOC flag'
            )

        # Write the segment headers

        data.seek(0, SEEK_END)

        self.file_header.e_phoff = data.tell()

        self.file_header.e_phnum = len(self.segments)

        self.file_header.e_phentsize = memoryview(self.segments[0]).nbytes

        for num_segment, segment in enumerate(self.segments):
            data.seek(
                self.file_header.e_phoff
                + self.file_header.e_phentsize * num_segment
            )

            segment.serialize(data)

        # Write the program headers

        data.seek(0)

        self.file_header.serialize(data)


class SH_TYPE(IntEnum):
    SHT_NULL = 0  # Inactive section.
    SHT_PROGBITS = 1  # Information defined by the program
    SHT_SYMTAB = 2  # Symbol table (one per object file)
    SHT_STRTAB = 3  # String table (multiple sections OK)
    SHT_RELA = 4  # Relocation with explicit addends
    SHT_HASH = 5  # Symbol hash table (one per object)
    SHT_DYNAMIC = 6  # Dynamic linking information
    SHT_NOTE = 7  # Vendor-specific file information
    SHT_NOBITS = 8  # Section contains no bits in object file
    SHT_REL = 9  # Relocation without explicit addends
    SHT_SHLIB = 10  # Reserved — non-conforming
    SHT_DYNSYM = 11  # Dynamic linking symbol table (one)

    SHT_INIT_ARRAY = 14  # Array of constructors
    SHT_FINI_ARRAY = 15  # Array of destructors
    SHT_PREINIT_ARRAY = 16  # Array of pre-constructors
    SHT_GROUP = 17  # Section group
    SHT_SYMTAB_SHNDX = 18  # Extended section indeces
    SHT_NUM = 19  # Number of defined types.

    SHT_GNU_ATTRIBUTES = 0x6FFFFFF5
    SHT_GNU_HASH = 0x6FFFFFF6
    SHT_GNU_LIBLIST = 0x6FFFFFF7
    SHT_GNU_VERDEF = 0x6FFFFFFD
    SHT_GNU_VERNEED = 0x6FFFFFFE
    SHT_GNU_VERSYM = 0x6FFFFFFF
    SHT_MIPS_REGINFO = 0x70000006
    SHT_MIPS_ABIFLAGS = 0x7000002A

    # Android's experimental support for SHT_RELR sections.
    # https://android.googlesource.com/platform/bionic/+/b7feec74547f84559a1467aca02708ff61346d2a/libc/include/elf.h#512
    SHT_ANDROID_RELR = 0x6FFFFF00  # Relocation entries; only offsets.


class SH_FLAGS(IntEnum):
    SHF_WRITE = 0x1  # Section writable during execution
    SHF_ALLOC = 0x2  # Section occupies memory
    SHF_EXECINSTR = 0x4  # Section contains executable instruc-tions


class ElfSectionHeader(VariableEndiannessAndWordsizeStructure):
    _fields_ = [
        ('sh_name', Elf64_Word),  # Section name, index in string table
        ('sh_type', Elf64_Word),  # Type of section
        ('sh_flags', Elf64_Xword),  # Miscellaneous section attributes
        ('sh_addr', Elf64_Addr),  # Section virtual addr at execution
        ('sh_offset', Elf64_Off),  # Section file offset
        ('sh_size', Elf64_Xword),  # Size of section in bytes
        (
            'sh_link',
            Elf64_Word,
        ),  # Index of another section -> REL(A)|HASH->SYMTAB, SYMTAB->STRTAB, DYNAMIC|DYMSYM->DYNSTR
        ('sh_info', Elf64_Word),  # Additional section information
        ('sh_addralign', Elf64_Xword),  # Section alignment
        ('sh_entsize', Elf64_Xword),  # Entry size if section holds table
    ]

    # The library will set sh_name and sh_offset when serializing, as well
    # as sh_size except if the section is a NOBITS


class ElfSection:
    section_name: str = (
        None  # will be written to section_string_table when serializing
    )

    section_table: list = None  # reference to the ElfFile.sections list
    elf_file: ElfFile = None

    section_header: ElfSectionHeader = None
    section_contents: bytes = None

    def __init__(self, elf_file: ElfFile):
        self.elf_file = elf_file

        self.is_big_endian = elf_file.is_big_endian
        self.is_64_bits = elf_file.is_64_bits

        self.section_header = ElfSectionHeader(
            self.is_big_endian, self.is_64_bits
        )

        if self.__class__ in SECTION_CLASS_TO_TYPE:
            self.section_header.sh_type = SECTION_CLASS_TO_TYPE[self.__class__]

    @classmethod
    def from_bytes(cls, data: BytesIO, elf_file: ElfFile):
        section_header_offset = data.tell()

        # Guess the correct type for the class to create
        # based on the section header

        impersonal_section = cls(elf_file)
        impersonal_section.unserialize(data)

        section_class = SECTION_TYPE_TO_CLASS.get(
            SH_TYPE(impersonal_section.section_header.sh_type), ElfSection
        )

        data.seek(section_header_offset)

        obj = section_class(elf_file)
        obj.unserialize(data)

        return obj

    def unserialize(self, data: BytesIO):
        """
        Consider that:
        a) We are at the position of the section header corresponding
           to the current section
        """

        self.section_header.unserialize(data)

        data.seek(self.section_header.sh_offset)

        self._unserialize_contents(data)

    def _unserialize_contents(self, data: BytesIO):
        self.section_contents = data.read(self.section_header.sh_size)

    def post_unserialize(self):
        # Name sections (now that .shstrndx is parsed)

        section_string_table = self.elf_file.sections[
            self.elf_file.file_header.e_shstrndx
        ]

        self.section_name = section_string_table.return_string_from_offset(
            self.section_header.sh_name
        )

    def pre_serialize(self):
        # Write our entry in .shstrtab

        section_string_table = self.elf_file.sections[
            self.elf_file.file_header.e_shstrndx
        ]

        self.section_header.sh_name = (
            section_string_table.add_string_and_return_offset(
                self.section_name
            )
        )

    def serialize(self, data: BytesIO):
        """
        Consider that:
        a) Sections are serialized in order
        b) The file is laid out like this: [ File header | Section headers | Section contents | Segment headers ]
        c) We are located at our section header's offset when called
        """

        section_header_offset = data.tell()

        # a) Calculate where the contents will start

        start_of_contents = self.elf_file.file_header.e_shoff
        start_of_contents += (
            self.elf_file.file_header.e_shentsize
            * self.elf_file.file_header.e_shnum
        )

        data.seek(0, SEEK_END)
        start_of_contents = max(data.tell(), start_of_contents)

        if self.section_header.sh_addralign:
            start_of_contents += (
                -start_of_contents % self.section_header.sh_addralign
            )

        # b) Write our section contents

        data.seek(start_of_contents)

        self._serialize_contents(data)

        end_of_contents = data.tell()

        # c) Write the section header

        data.seek(section_header_offset)

        self.section_header.sh_offset = start_of_contents

        if not isinstance(self, ElfNoBits):
            self.section_header.sh_size = end_of_contents - start_of_contents

        self.section_header.serialize(data)

    def _serialize_contents(self, data: BytesIO):
        data.write(self.section_contents)


class ElfNullSection(ElfSection):
    def _unserialize_contents(self, data: BytesIO):
        pass

    def _serialize_contents(self, data: BytesIO):
        pass


class ElfProgbits(ElfSection):
    # Virtual address is stored in self.section_header.sh_addr

    # Only PROGBITS and NOBITS will have their virtual address specified
    # in their ElfSection structure. For sections like INTERP or DYNAMIC
    # which also have a segment, the serialization code will choose an
    # arbitrary address located right after.

    def unserialize(self, data: BytesIO):
        super().unserialize(data)

    def serialize(self, data: BytesIO):
        super().serialize(data)


class ElfNoBits(ElfProgbits):
    # Virtual address is stored in self.section_header.sh_addr

    def _unserialize_contents(self, data: BytesIO):
        pass

    def _serialize_contents(self, data: BytesIO):
        pass


class ST_INFO_TYPE(IntEnum):  # SYMBOL_TYPE
    STT_NOTYPE = 0  # Not specified
    STT_OBJECT = 1  # Data object: variable, array, etc.
    STT_FUNC = 2  # Function or other executable code
    STT_SECTION = 3  # Section. Exists primarily for relocation
    STT_FILE = 4  # Name (pathname?) of the source file associated with object. Binding is STT_LOCAL, section index is SHN_ABS, and it precedes other STB_LOCAL symbols if present


class ST_INFO_BINDING(IntEnum):  # SYMBOL_BINDING
    STB_LOCAL = 0  # Not visible outside object file where defined
    STB_GLOBAL = 1  # Visible to all object files. Multiple definitions cause errors. Force extraction of defining object from archive file.
    STB_WEAK = 2  # Visible to all object files. Ignored if STB_GLOBAL with same name found. Do not force extraction of defining object from archive file. Value is 0 if undefined.


class SPECIAL_SECTION_INDEX(IntEnum):
    SHN_UNDEF = 0
    SHN_LORESERVE = 0xFF00
    SHN_LOPROC = 0xFF00
    SHN_HIPROC = 0xFF1F
    SHN_LIVEPATCH = 0xFF20
    SHN_ABS = 0xFFF1
    SHN_COMMON = 0xFFF2
    SHN_HIRESERVE = 0xFFFF


class Elf32LittleEndianSymbolTableEntry(
    VariableEndiannessAndWordsizeStructure
):
    _fields_ = [
        ('st_name', Elf32_Word),  # Symbol name, index in string tbl
        ('st_value', Elf32_Addr),  # Value of the symbol
        ('st_size', Elf32_Word),  # Associated symbol size
        ('st_info_type', c_uint8, 4),  # Type and binding attributes
        ('st_info_binding', c_uint8, 4),
        ('st_other', c_uint8),  # No defined meaning, 0
        ('st_shndx', Elf32_Half),  # Associated section index
    ]

    symbol_name: str = None

    associated_section: ElfSection = None

    # The user should fill st_name, st_info_type, st_info_binding, st_value


class Elf32BigEndianSymbolTableEntry(Elf32LittleEndianSymbolTableEntry):
    _fields_ = [
        ('st_name', Elf32_Word),  # Symbol name, index in string tbl
        ('st_value', Elf32_Addr),  # Value of the symbol
        ('st_size', Elf32_Word),  # Associated symbol size
        ('st_info_binding', c_uint8, 4),  # Type and binding attributes
        ('st_info_type', c_uint8, 4),
        ('st_other', c_uint8),  # No defined meaning, 0
        ('st_shndx', Elf32_Half),  # Associated section index
    ]


class Elf64LittleEndianSymbolTableEntry(Elf32LittleEndianSymbolTableEntry):
    _fields_ = [
        ('st_name', Elf64_Word),  # Symbol name, index in string tbl
        ('st_info_type', c_uint8, 4),  # Type and binding attributes
        ('st_info_binding', c_uint8, 4),
        ('st_other', c_uint8),  # No defined meaning, 0
        ('st_shndx', Elf64_Half),  # Associated section index
        ('st_value', Elf64_Addr),  # Value of the symbol
        ('st_size', Elf64_Xword),  # Associated symbol size
    ]


class Elf64BigEndianSymbolTableEntry(Elf64LittleEndianSymbolTableEntry):
    _fields_ = [
        ('st_name', Elf64_Word),  # Symbol name, index in string tbl
        ('st_info_binding', c_uint8, 4),  # Type and binding attributes
        ('st_info_type', c_uint8, 4),
        ('st_other', c_uint8),  # No defined meaning, 0
        ('st_shndx', Elf64_Half),  # Associated section index
        ('st_value', Elf64_Addr),  # Value of the symbol
        ('st_size', Elf64_Xword),  # Associated symbol size
    ]


class ElfSymtab(ElfSection):
    string_table: ElfSection = None  # .dynstr or .strtab

    symbol_table: list[Elf32LittleEndianSymbolTableEntry] = None

    def __init__(self, elf_file: ElfFile):
        super().__init__(elf_file)

        self.symbol_table = []

    def _unserialize_contents(self, data: BytesIO):
        self.symbol_table = []

        for num_symbol in range(
            self.section_header.sh_size // self.section_header.sh_entsize
        ):
            data.seek(
                self.section_header.sh_offset
                + num_symbol * self.section_header.sh_entsize
            )

            symbol_class = {
                (False, False): Elf32LittleEndianSymbolTableEntry,
                (True, False): Elf32BigEndianSymbolTableEntry,
                (False, True): Elf64LittleEndianSymbolTableEntry,
                (True, True): Elf64BigEndianSymbolTableEntry,
            }[(self.is_big_endian, self.is_64_bits)]

            symbol = symbol_class(self.is_big_endian, self.is_64_bits)

            symbol.unserialize(data)

            self.symbol_table.append(symbol)

    def post_unserialize(self):
        super().post_unserialize()

        # Link strings to symbols

        self.string_table = self.elf_file.sections[self.section_header.sh_link]

        for symbol in self.symbol_table:
            # symbol.pretty_print()

            # print(self.string_table.offset_to_string)
            symbol.symbol_name = self.string_table.return_string_from_offset(
                symbol.st_name
            )

            # In addition to strings, add a reference to
            # the associated section

            if (
                symbol.st_shndx
                not in SPECIAL_SECTION_INDEX.__members__.values()
            ):
                symbol.associated_section = self.elf_file.sections[
                    symbol.st_shndx
                ]

            else:
                symbol.associated_section = SPECIAL_SECTION_INDEX(
                    symbol.st_shndx
                )

    def pre_serialize(self):
        super().pre_serialize()

        self.section_header.sh_link = self.elf_file.sections.index(
            self.string_table
        )

        for symbol in self.symbol_table:
            symbol.st_name = self.string_table.add_string_and_return_offset(
                symbol.symbol_name
            )

            if symbol.associated_section and not isinstance(
                symbol.associated_section, SPECIAL_SECTION_INDEX
            ):
                symbol.st_shndx = self.elf_file.sections.index(
                    symbol.associated_section
                )

        self.section_header.sh_entsize = memoryview(
            self.symbol_table[0]
        ).nbytes

    def _serialize_contents(self, data: BytesIO):
        local_symbols_first = lambda symbol: (
            symbol.st_info_binding != ST_INFO_BINDING.STB_LOCAL
        )

        found_a_non_local_symbol = False

        for num_symbol, symbol in enumerate(
            sorted(self.symbol_table, key=local_symbols_first)
        ):
            if (
                symbol.st_info_binding != ST_INFO_BINDING.STB_LOCAL
                and not found_a_non_local_symbol
            ):
                found_a_non_local_symbol = True

                self.section_header.sh_info = num_symbol

            symbol.serialize(data)


class ElfDynsym(ElfSymtab):
    pass


class ElfStrtab(ElfSection):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._cache = {}
        self._raw_string_table = b''
        self.add_string_and_return_offset('')

    def _unserialize_contents(self, data: BytesIO):
        self._raw_string_table = data.read(self.section_header.sh_size)

        # Generate cache
        self._cache = {}
        i = 0
        while i < len(self._raw_string_table):
            string = self.return_string_from_offset(i)
            self._cache[string] = i
            i += len(string) + 1

    def _serialize_contents(self, data: BytesIO):
        data.write(self._raw_string_table)

    def return_string_from_offset(self, offset):
        return self._raw_string_table[
            offset : self._raw_string_table.find(b'\x00', offset)
        ].decode('ascii')

    def add_string_and_return_offset(self, string):
        if string in self._cache:
            return self._cache[string]

        self._cache[string] = string_offset = len(self._raw_string_table)
        self._raw_string_table += string.encode('ascii') + b'\x00'
        return string_offset


class Elf32LittleEndianRelocationTableEntry(
    VariableEndiannessAndWordsizeStructure
):
    _fields_ = [
        ('r_offset', Elf32_Addr),  # Location at which to apply the relocaction
        ('r_info_type', Elf32_Word, 8),  # index and type of relocation
        ('r_info_sym', Elf32_Word, 24),
    ]

    # symbol_name : str = None

    associated_symbol: Elf32LittleEndianSymbolTableEntry = None


class Elf32BigEndianRelocationTableEntry(
    Elf32LittleEndianRelocationTableEntry
):
    _fields_ = [
        ('r_offset', Elf32_Addr),  # Location at which to apply the relocaction
        ('r_info_sym', Elf32_Word, 24),  # index and type of relocation
        ('r_info_type', Elf32_Word, 8),
    ]


class Elf64LittleEndianRelocationTableEntry(
    Elf32LittleEndianRelocationTableEntry
):
    _fields_ = [
        ('r_offset', Elf64_Addr),  # Location at which to apply the action
        ('r_info_type', Elf64_Xword, 32),  # index and type of relocation
        ('r_info_sym', Elf64_Xword, 32),
    ]


class Elf64BigEndianRelocationTableEntry(
    Elf64LittleEndianRelocationTableEntry
):
    _fields_ = [
        ('r_offset', Elf64_Addr),  # Location at which to apply the action
        ('r_info_sym', Elf64_Xword, 32),  # index and type of relocation
        ('r_info_type', Elf64_Xword, 32),
    ]


class Elf32LittleEndianRelocationWithAddendTableEntry(
    Elf32LittleEndianRelocationTableEntry
):
    _fields_ = [
        *Elf32LittleEndianRelocationTableEntry._fields_,
        ('r_addend', Elf32_Sword),  # Constant addend used to compute value
    ]


class Elf32BigEndianRelocationWithAddendTableEntry(
    Elf32LittleEndianRelocationTableEntry
):
    _fields_ = [
        *Elf32BigEndianRelocationTableEntry._fields_,
        ('r_addend', Elf32_Sword),  # Constant addend used to compute value
    ]


class Elf64LittleEndianRelocationWithAddendTableEntry(
    Elf32LittleEndianRelocationWithAddendTableEntry
):
    _fields_ = [
        *Elf64LittleEndianRelocationTableEntry._fields_,
        ('r_addend', Elf64_Sxword),  # Constant addend used to compute value
    ]


class Elf64BigEndianRelocationWithAddendTableEntry(
    Elf64LittleEndianRelocationWithAddendTableEntry
):
    _fields_ = [
        *Elf64BigEndianRelocationTableEntry._fields_,
        ('r_addend', Elf64_Sxword),  # Constant addend used to compute value
    ]


class ElfRel(ElfSection):
    relocation_table: list[Elf32LittleEndianRelocationTableEntry] = None

    def _unserialize_contents(self, data: BytesIO):
        self.relocation_table = []

        for num_symbol in range(
            self.section_header.sh_size // self.section_header.sh_entsize
        ):
            relocation_class = {
                (False, False): Elf32LittleEndianRelocationTableEntry,
                (True, False): Elf32BigEndianRelocationTableEntry,
                (False, True): Elf64LittleEndianRelocationTableEntry,
                (True, True): Elf64BigEndianRelocationTableEntry,
            }[(self.is_big_endian, self.is_64_bits)]

            relocation = relocation_class(self.is_big_endian, self.is_64_bits)

            relocation.unserialize(data)

            self.relocation_table.append(relocation)

    def post_unserialize(self):
        super().post_unserialize()

        self.symtab_section = self.elf_file.sections[
            self.section_header.sh_link
        ]

        for relocation in self.relocation_table:
            relocation.associated_symbol = self.symtab_section.symbol_table[
                relocation.r_info_sym
            ]

            # relocation.pretty_print()

            # print('le', relocation.associated_symbol.symbol_name)

            # relocation.symbol_name = relocation.associated_symbol.symbol_name

    def pre_serialize(self):
        super().pre_serialize()

        for relocation in self.relocation_table:
            relocation.r_info_sym = self.symtab_section.symbol_table.index(
                relocation.associated_symbol
            )

        self.section_header.sh_entsize = memoryview(
            self.relocation_table[0]
        ).nbytes

    def _serialize_contents(self, data: BytesIO):
        for relocation in self.relocation_table:
            relocation.serialize(data)


class ElfRela(ElfSection):
    relocation_table: list[Elf32LittleEndianRelocationWithAddendTableEntry] = (
        None
    )

    def unserialize(self, data: BytesIO):
        super().unserialize(data)

        data.seek(self.section_header.sh_offset)

        self.relocation_table = []

        for num_symbol in range(
            self.section_header.sh_size // self.section_header.sh_entsize
        ):
            relocation_class = {
                (
                    False,
                    False,
                ): Elf32LittleEndianRelocationWithAddendTableEntry,
                (True, False): Elf32BigEndianRelocationWithAddendTableEntry,
                (False, True): Elf64LittleEndianRelocationWithAddendTableEntry,
                (True, True): Elf64BigEndianRelocationWithAddendTableEntry,
            }[(self.is_big_endian, self.is_64_bits)]

            relocation = relocation_class(self.is_big_endian, self.is_64_bits)

            relocation.unserialize(data)

            self.relocation_table.append(relocation)

    def post_unserialize(self):
        super().post_unserialize()

        self.symtab_section = self.elf_file.sections[
            self.section_header.sh_link
        ]

    def pre_serialize(self):
        super().pre_serialize()

        self.section_header.sh_entsize = memoryview(
            self.relocation_table[0]
        ).nbytes

    def _serialize_contents(self, data: BytesIO):
        for relocation in self.relocation_table:
            relocation.serialize(data)


class ElfDynamic(ElfSection):
    pass


class ElfHash(ElfSection):
    symbol_table: ElfSection = None


SECTION_TYPE_TO_CLASS = {
    SH_TYPE.SHT_NULL: ElfNullSection,
    SH_TYPE.SHT_PROGBITS: ElfProgbits,
    SH_TYPE.SHT_NOBITS: ElfNoBits,
    SH_TYPE.SHT_SYMTAB: ElfSymtab,
    SH_TYPE.SHT_STRTAB: ElfStrtab,
    SH_TYPE.SHT_RELA: ElfRela,
    SH_TYPE.SHT_HASH: ElfHash,
    SH_TYPE.SHT_DYNAMIC: ElfDynamic,
    SH_TYPE.SHT_REL: ElfRel,
    SH_TYPE.SHT_DYNSYM: ElfDynsym,
}

SECTION_CLASS_TO_TYPE = {v: k for k, v in SECTION_TYPE_TO_CLASS.items()}


class E_IDENT_INDEXES(IntEnum):
    EI_MAG0 = 0
    EI_MAG1 = 1
    EI_MAG2 = 2
    EI_MAG3 = 3
    EI_CLASS = 4
    EI_DATA = 5
    EI_VERSION = 6
    EI_OSABI = 7
    EI_ABIVERSION = 8
    EI_NIDENT = 16


class EI_VERSION(IntEnum):
    EV_CURRENT = 1


class EI_CLASS(IntEnum):
    ELFCLASS32 = 1

    ELFCLASS64 = 2


class EI_DATA(IntEnum):
    ELFDATA2LSB = 1  # 32-bit objects

    ELFDATA2MSB = 2  # 64-bit objects


class EI_OSABI(IntEnum):
    ELFOSABI_SYSV = 0  # System V ABI

    ELFOSABI_HPUX = 1  # HP-UX operating system

    ELFOSABI_STANDALONE = 255  # Standalone (embedded) application


class E_TYPE(IntEnum):
    ET_NONE = 0  # No file type

    ET_REL = 1  # Relocatable object file

    ET_EXEC = 2  # Executable file

    ET_DYN = 3  # Shared object file

    ET_CORE = 4  # Core file


class ElfFileHeader(VariableEndiannessAndWordsizeStructure):
    _fields_ = [
        ('EI_MAG', c_char * 4),  # ELF "magic number"
        ('EI_CLASS', c_uint8),  # File class
        ('EI_DATA', c_uint8),  # Data encoding
        ('EI_VERSION', c_uint8),  # File version
        ('EI_OSABI', c_uint8),  # OS/ABI identification
        ('EI_ABIVERSION', c_uint8),  # ABI version
        ('EI_PAD', c_uint8 * 7),
        ('e_type', Elf64_Half),
        ('e_machine', Elf64_Half),
        ('e_version', Elf64_Word),
        ('e_entry', Elf64_Addr),  # Entry point virtual address
        ('e_phoff', Elf64_Off),  # Program header table file offset
        ('e_shoff', Elf64_Off),  # Section header table file offset
        ('e_flags', Elf64_Word),
        ('e_ehsize', Elf64_Half),
        ('e_phentsize', Elf64_Half),
        ('e_phnum', Elf64_Half),
        ('e_shentsize', Elf64_Half),
        ('e_shnum', Elf64_Half),
        ('e_shstrndx', Elf64_Half),
    ]

    def __init__(self):
        self.EI_MAG = b'\x7fELF'

        self.EI_CLASS = {
            False: EI_CLASS.ELFCLASS32,
            True: EI_CLASS.ELFCLASS64,
        }[self.is_64_bits]

        self.EI_DATA = {False: EI_DATA.ELFDATA2LSB, True: EI_DATA.ELFDATA2MSB}[
            self.is_big_endian
        ]

        self.EI_OSABI = EI_OSABI.ELFOSABI_SYSV

        self.e_version = self.EI_VERSION = EI_VERSION.EV_CURRENT

        # Let the user set e_flags, e_machine, e_entry


class P_TYPE:  # PROGRAM_HEADER_TYPE
    PT_NULL = 0  # Null descriptor — ignore
    PT_LOAD = 1  # Loadable segment
    PT_DYNAMIC = 2  # Dynamic segment
    PT_INTERP = 3  # Interpreter pathname
    PT_NOTE = 4  # Auxiliary information segment
    PT_SHLIB = 5  # Reserved
    PT_PHDR = 6  # Program header segment


class P_FLAGS:  # PROGRAM_HEADER_FLAGS
    PF_X = 0x1  # Executable
    PF_W = 0x2  # Writable
    PF_R = 0x4  # Readable


class Elf32ProgramHeaderEntry(VariableEndiannessAndWordsizeStructure):
    _fields_ = [
        ('p_type', Elf32_Word),
        ('p_offset', Elf32_Off),  # Segment file offset
        ('p_vaddr', Elf32_Addr),  # Segment virtual address
        ('p_paddr', Elf32_Addr),  # Segment physical address
        ('p_filesz', Elf32_Word),  # Segment size in file
        ('p_memsz', Elf32_Word),  # Segment size in memory
        ('p_flags', Elf32_Word),
        ('p_align', Elf32_Word),  # Segment alignment, file & memory
    ]


class Elf64ProgramHeaderEntry(Elf32ProgramHeaderEntry):
    _fields_ = [
        ('p_type', Elf64_Word),
        ('p_flags', Elf64_Word),
        ('p_offset', Elf64_Off),  # Segment file offset
        ('p_vaddr', Elf64_Addr),  # Segment virtual address
        ('p_paddr', Elf64_Addr),  # Segment physical address
        ('p_filesz', Elf64_Xword),  # Segment size in file
        ('p_memsz', Elf64_Xword),  # Segment size in memory
        ('p_align', Elf64_Xword),  # Segment alignment, file & memory
    ]

```

`vmlinux_to_elf/utils/lz4_legacy.py`:

```py
#!/usr/bin/python3
# -*- encoding: Utf-8 -*-
from lz4.block import decompress
from io import BytesIO

"""
    This file  contains a basic translator for turning compression
    streams using the legacy LZ4 format [1] (magic 0x184C2102),
    used by various old or less old Linux kernels, into the newer
    LZ4 format [2] (magic 0x184D2204).
    
    [1] 02 21 4C 18 - https://github.com/lz4/lz4/blob/dev/doc/lz4_Frame_format.md#legacy-frame
    [2] 04 22 4D 18 - https://github.com/lz4/lz4/blob/dev/doc/lz4_Frame_format.md#general-structure-of-lz4-frame-format
"""


def decompress_lz4_buffer(lz4_buffer: BytesIO):
    assert lz4_buffer.read(4) == (0x184C2102).to_bytes(
        4, 'little'
    )  # Check the legacy magic

    MAX_LEGACY_BLOCK_SIZE = 8 * 1024 * 1024  # 8 MB

    uncompressed_stream = b''

    while True:
        compressed_block_size_raw = lz4_buffer.read(4)
        if len(compressed_block_size_raw) < 4:
            break

        compressed_block_size = int.from_bytes(
            compressed_block_size_raw, 'little'
        )

        compressed_block = lz4_buffer.read(compressed_block_size)
        if (
            len(compressed_block) < compressed_block_size
            or not compressed_block_size
        ):
            break

        uncompressed_block = decompress(
            compressed_block, MAX_LEGACY_BLOCK_SIZE
        )
        uncompressed_stream += uncompressed_block
        if len(uncompressed_block) < MAX_LEGACY_BLOCK_SIZE:
            break

    return uncompressed_stream

```

`vmlinux_to_elf/utils/pretty_print.py`:

```py
#!/usr/bin/env python3
# -*- encoding: Utf-8 -*-

from collections import OrderedDict

from vmlinux_to_elf.utils import elf

"""
    Pretty print a file name in an ASCII rectangle.
    
    :param header_text: The file name.
"""


def pretty_print_header(header_text):
    max_text_length = max(len(header_text), 72)

    print()
    print()

    print('+-%s-+' % ('-' * max_text_length))

    print('| %s |' % header_text.ljust(max_text_length))

    print('+-%s-+' % ('-' * max_text_length))


"""
    Turn a parsed C structure in a dict of human-readable key-value
    pairs, for displayal in ASCII tables
    
    :param ctypes_structure: A parsed ctypes structures to consume.
    
    :returns An OrderedDict of strings/strings.
"""


def structure_to_key_values_strings(ctypes_structure):
    key_values = OrderedDict()

    for key, ctype in (field[:2] for field in ctypes_structure._fields_):
        value = getattr(ctypes_structure, key)

        # Turn "key_name" into "Key name"

        pretty_key = key[0].upper() + key[1:]
        pretty_key = pretty_key.replace('_', ' ')

        # Stringify the value

        if type(value) is bytes:  # Strings
            key_values[pretty_key] = value.decode('ascii')

        elif key in field_name_to_structure:  # Integer enums
            try:
                enum_field = field_name_to_structure[key](value)

                key_values[pretty_key] = enum_field.name

            except ValueError:
                key_values[pretty_key] = str(value) + ' ?'

        elif type(value) is int:  # Integer
            key_values[pretty_key] = '0x%08x' % value if value else 'N/A'

    return key_values


"""
    Return an ASCII table from a parsed C structure, with field names as
    column 1 and values as column 2.
"""


def pretty_print_structure(ctypes_structure):
    key_values = structure_to_key_values_strings(ctypes_structure)

    pretty_print_table(list(key_values.items()))


"""
    Return an ASCII table from an array of parsed C structures, with field names
    as row 1 and values as further rows.
"""


def pretty_print_array_of_structures(array_of_structures):
    if array_of_structures:
        key_values_pairs = [
            structure_to_key_values_strings(structure)
            for structure in array_of_structures
        ]

        pretty_print_table(
            [list(key_values_pairs[0].keys())]  # Row 1: field names
            + [
                list(key_values.values()) for key_values in key_values_pairs
            ]  # Rows 2+: field values
        )


"""
    Return an ascii table from a list (rows) of list (columns) of strings (cells)
"""


def pretty_print_table(rows):
    # Calculate columns length

    number_of_columns = len(rows[0])

    column_to_max_length = [
        max(len(row[column]) for row in rows)
        for column in range(number_of_columns)
    ]

    # Do a nice table

    print()

    print(
        '+-%s-+'
        % '---'.join('-' * max_len for max_len in column_to_max_length)
    )

    for row in rows:
        print(
            '| %s |'
            % ' | '.join(
                row[column].ljust(column_to_max_length[column])
                for column in range(number_of_columns)
            )
        )

        print(
            '+-%s-+'
            % '---'.join('-' * max_len for max_len in column_to_max_length)
        )


field_name_to_structure = {
    key.lower(): value
    for key, value in vars(elf).items()
    if 'FLAGS' not in key
}

```