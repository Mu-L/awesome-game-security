Project Path: arc_thetuh_anticheat-poc_8j_kbt3r

Source Tree:

```txt
arc_thetuh_anticheat-poc_8j_kbt3r
├── README.md
├── ac_external
│   ├── ac_external.vcxproj
│   ├── ac_external.vcxproj.filters
│   └── main.cpp
├── ac_module
│   ├── ac_module.vcxproj
│   ├── ac_module.vcxproj.filters
│   ├── hooks.cpp
│   ├── hooks.h
│   ├── integrity.cpp
│   ├── integrity.h
│   ├── lib
│   │   ├── minhook
│   │   │   ├── include
│   │   │   │   └── minhook.h
│   │   │   └── src
│   │   │       ├── buffer.c
│   │   │       ├── buffer.h
│   │   │       ├── hde
│   │   │       │   ├── hde32.c
│   │   │       │   ├── hde32.h
│   │   │       │   ├── hde64.c
│   │   │       │   ├── hde64.h
│   │   │       │   ├── pstdint.h
│   │   │       │   ├── table32.h
│   │   │       │   └── table64.h
│   │   │       ├── hook.c
│   │   │       ├── trampoline.c
│   │   │       └── trampoline.h
│   │   └── tinyformat.h
│   ├── main.cpp
│   ├── nt.h
│   ├── pe.h
│   └── util.h
└── anti-cheat.sln

```

`README.md`:

```md
# Anti-Cheat
An open-source user-mode anti-cheat supporting both x86 and x64 targets.
# Usage
Compile for the desired architecture and inject the binary into the process you want to monitor.
# Notes
* This is a foundational implementation and should be treated as such.
* All saved files/dumps would practically be sent back to a server for static analysis.
* This was tested with Process Hacker, Xenos, and Extreme Injector.
# Features
* Detects DLL Injection (LoadLibrary or Manual Map)
* Scans suspicious memory regions and dumps them to disk
* Copies unsigned modules to disk
* Checks .text section modifications through checksum comparisons
* Reports all activity to console
# Planned
* Showcase/Demo
* Self integrity checks
* Thread start address checks
* Syscall callbacks
* Proper callstack walks (see [unwinder](https://github.com/thetuh/unwinder) based on [SilentMoonWalk](https://github.com/klezVirus/SilentMoonwalk))
* Kernel driver and external process components
# Resources
https://github.com/TsudaKageyu/minhook
https://github.com/vmcall/MapDetection
https://github.com/mq1n/DLLThreadInjectionDetector

```

`ac_external/ac_external.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{03ed3a37-ec5e-4dde-8af1-e6acf3ac2cde}</ProjectGuid>
    <RootNamespace>acexternal</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>$(SolutionDir)build\$(PlatformShortName)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)build\$(PlatformShortName)\$(Configuration)\intermediates\$(ProjectName)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>$(SolutionDir)build\$(PlatformShortName)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)build\$(PlatformShortName)\$(Configuration)\intermediates\$(ProjectName)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <IntDir>$(SolutionDir)build\$(PlatformShortName)\$(Configuration)\intermediates\$(ProjectName)\</IntDir>
    <OutDir>$(SolutionDir)build\$(PlatformShortName)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <IntDir>$(SolutionDir)build\$(PlatformShortName)\$(Configuration)\intermediates\$(ProjectName)\</IntDir>
    <OutDir>$(SolutionDir)build\$(PlatformShortName)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`ac_external/ac_external.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`ac_external/main.cpp`:

```cpp
#include <Windows.h>
#include <iostream>

// idea: monitor protected process externally, walk the callstack of each running thread, perform self integrity checks
// pair in cojunction with driver for elevated security

int main()
{
	while ( true )
	{
		Sleep( 1 );
	}
}
```

`ac_module/ac_module.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{3c8ce0dd-3bec-4bd4-8127-6201ca699e74}</ProjectGuid>
    <RootNamespace>acmodule</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>ac_module</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>$(SolutionDir)build\$(PlatformShortName)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)build\$(PlatformShortName)\$(Configuration)\intermediates\$(ProjectName)\</IntDir>
    <IncludePath>$(ProjectDir)\lib;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>$(SolutionDir)build\$(PlatformShortName)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)build\$(PlatformShortName)\$(Configuration)\intermediates\$(ProjectName)\</IntDir>
    <IncludePath>$(ProjectDir)\lib;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(SolutionDir)build\$(PlatformShortName)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)build\$(PlatformShortName)\$(Configuration)\intermediates\$(ProjectName)\</IntDir>
    <IncludePath>$(ProjectDir)\lib;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>$(SolutionDir)build\$(PlatformShortName)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)build\$(PlatformShortName)\$(Configuration)\intermediates\$(ProjectName)\</IntDir>
    <IncludePath>$(ProjectDir)\lib;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="hooks.cpp" />
    <ClCompile Include="integrity.cpp" />
    <ClCompile Include="lib\minhook\src\buffer.c" />
    <ClCompile Include="lib\minhook\src\hde\hde32.c" />
    <ClCompile Include="lib\minhook\src\hde\hde64.c" />
    <ClCompile Include="lib\minhook\src\hook.c" />
    <ClCompile Include="lib\minhook\src\trampoline.c" />
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="hooks.h" />
    <ClInclude Include="integrity.h" />
    <ClInclude Include="lib\minhook\include\minhook.h" />
    <ClInclude Include="lib\minhook\src\buffer.h" />
    <ClInclude Include="lib\minhook\src\hde\hde32.h" />
    <ClInclude Include="lib\minhook\src\hde\hde64.h" />
    <ClInclude Include="lib\minhook\src\hde\pstdint.h" />
    <ClInclude Include="lib\minhook\src\hde\table32.h" />
    <ClInclude Include="lib\minhook\src\hde\table64.h" />
    <ClInclude Include="lib\minhook\src\trampoline.h" />
    <ClInclude Include="minhook\MinHook.h" />
    <ClInclude Include="nt.h" />
    <ClInclude Include="pe.h" />
    <ClInclude Include="lib\tinyformat.h" />
    <ClInclude Include="util.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`ac_module/ac_module.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="hooks.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="integrity.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="lib\minhook\src\hde\hde32.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="lib\minhook\src\hde\hde64.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="lib\minhook\src\buffer.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="lib\minhook\src\hook.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="lib\minhook\src\trampoline.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="minhook\MinHook.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="hooks.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="integrity.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="pe.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="lib\tinyformat.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="util.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="nt.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="lib\minhook\include\minhook.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="lib\minhook\src\hde\hde32.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="lib\minhook\src\hde\hde64.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="lib\minhook\src\hde\pstdint.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="lib\minhook\src\hde\table32.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="lib\minhook\src\hde\table64.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="lib\minhook\src\buffer.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="lib\minhook\src\trampoline.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`ac_module/hooks.cpp`:

```cpp
#include "hooks.h"
#include "integrity.h"

#include "util.h"
#include "tinyformat.h"
#include "minhook/include/minhook.h"

#include <intrin.h>
#include <unordered_map>
#include <shlwapi.h>

#pragma comment(lib, "Shlwapi.lib")

namespace integrity::hooks
{
	bool install()
	{
		auto log_error = []( const char* msg )
			{
				MessageBox( NULL, msg, "ac_module", MB_OK | MB_ICONERROR );
				return false;
			};

		std::unordered_map<std::string, HMODULE> libraries =
		{
			{"kernel32.dll", nullptr},
			{"user32.dll", nullptr},
			{"ntdll.dll", nullptr}
		};

		for ( auto& [name, handle] : libraries )
		{
			handle = LoadLibrary( name.c_str() );
			if ( !handle )
				return log_error( tfm::format( "%s not found", name ).c_str() );
		}

		if ( const auto status = MH_Initialize(); status != MH_OK )
			return log_error( tfm::format( "could not initialize minhook - MH_STATUS: %d", status ).c_str() );

		struct hook_t
		{
			const char* module;
			const char* function;
			LPVOID hook;
			LPVOID* original;
		};

		const std::vector<hook_t> hooks =
		{
			{"kernel32.dll", "GetCurrentProcess", &impl::GetCurrentProcess, reinterpret_cast< LPVOID* >( &originals::GetCurrentProcess )},
			{"kernel32.dll", "CloseHandle", &impl::CloseHandle, reinterpret_cast< LPVOID* >( &originals::CloseHandle )},
			{"kernel32.dll", "LoadLibraryA", &impl::LoadLibraryA, reinterpret_cast< LPVOID* >( &originals::LoadLibraryA )},
			{"kernel32.dll", "LoadLibraryW", &impl::LoadLibraryW, reinterpret_cast< LPVOID* >( &originals::LoadLibraryW )},
			{"kernel32.dll", "LoadLibraryExA", &impl::LoadLibraryExA, reinterpret_cast< LPVOID* >( &originals::LoadLibraryExA )},
			{"kernel32.dll", "LoadLibraryExW", &impl::LoadLibraryExW, reinterpret_cast< LPVOID* >( &originals::LoadLibraryExW )},
			{"kernel32.dll", "VirtualAllocEx", &impl::VirtualAllocEx, reinterpret_cast< LPVOID* >( &originals::VirtualAllocEx )},
			{"kernel32.dll", "VirtualQueryEx", &impl::VirtualQueryEx, reinterpret_cast< LPVOID* >( &originals::VirtualQueryEx )},
			{"user32.dll", "MessageBoxW", &impl::MessageBoxW, reinterpret_cast< LPVOID* >( &originals::MessageBoxW )},
			{"ntdll.dll", "NtAllocateVirtualMemory", &impl::NtAllocateVirtualMemory, reinterpret_cast< LPVOID* >( &originals::NtAllocateVirtualMemory )},
			{"ntdll.dll", "LdrLoadDll", &impl::LdrLoadDll, reinterpret_cast< LPVOID* >( &originals::LdrLoadDll )},
			//{"ntdll.dll", "NtMapViewOfSection", &impl::NtMapViewOfSection, reinterpret_cast< LPVOID* >( &originals::NtMapViewOfSection )},
			{"ntdll.dll", "RtlGetFullPathName_U", &impl::RtlGetFullPathName_U, reinterpret_cast< LPVOID* >( &originals::RtlGetFullPathName_U )}
		};

		for ( const auto& hook : hooks )
		{
			const auto module = libraries[ hook.module ];

			const auto proc = util::resolve_export( ( PBYTE ) module, hook.function );
			if ( !proc )
				return log_error( tfm::format( "failed to get address of %s", hook.function ).c_str() );

			if ( const auto status = MH_CreateHook( proc, hook.hook, hook.original ); status != MH_OK )
				return log_error( tfm::format( "could not hook %s - MH_STATUS: %d", hook.function, status ).c_str() );
		}

		if ( const auto status = MH_EnableHook( MH_ALL_HOOKS ); status != MH_OK )
			return log_error( tfm::format( "could not enable hooks - MH_STATUS: %d", status ).c_str() );

		return true;
	}

	namespace impl
	{
		BOOL WINAPI CloseHandle( HANDLE handle )
		{
			validate_return_address( ( uintptr_t ) _ReturnAddress(), "CloseHandle" );
			return originals::CloseHandle( handle );
		}

		HANDLE WINAPI GetCurrentProcess()
		{
			validate_return_address( ( uintptr_t ) _ReturnAddress(), "GetCurrentProcess" );
			return originals::GetCurrentProcess();
		}

		HMODULE WINAPI LoadLibraryA( LPCSTR filename )
		{
			validate_return_address( ( uintptr_t ) _ReturnAddress(), "LoadLibraryA" );
			return originals::LoadLibraryA( filename );;
		}

		HMODULE WINAPI LoadLibraryW( LPCWSTR filename )
		{
			validate_return_address( ( uintptr_t ) _ReturnAddress(), "LoadLibraryW" );
			return originals::LoadLibraryW( filename );
		}

		HMODULE WINAPI LoadLibraryExA( LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags )
		{
			validate_return_address( ( uintptr_t ) _ReturnAddress(), "LoadLibraryExA" );
			return originals::LoadLibraryExA( lpLibFileName, hFile, dwFlags );
		}

		HMODULE WINAPI LoadLibraryExW( LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags )
		{
			validate_return_address( ( uintptr_t ) _ReturnAddress(), "LoadLibraryExW" );
			return originals::LoadLibraryExW( lpLibFileName, hFile, dwFlags );
		}

		LPVOID WINAPI VirtualAllocEx(
			_In_ HANDLE hProcess,
			_In_opt_ LPVOID lpAddress,
			_In_ SIZE_T dwSize,
			_In_ DWORD flAllocationType,
			_In_ DWORD flProtect
		) {
			validate_return_address( ( uintptr_t ) _ReturnAddress(), "VirtualAllocEx" );
			return originals::VirtualAllocEx( hProcess, lpAddress, dwSize, flAllocationType, flProtect );
		}

		SIZE_T WINAPI VirtualQueryEx(
			HANDLE hProcess,
			LPCVOID lpAddress,
			PMEMORY_BASIC_INFORMATION lpBuffer,
			SIZE_T dwLength
		) {
			validate_return_address( ( uintptr_t ) _ReturnAddress(), "VirtualQueryEx" );
			return originals::VirtualQueryEx( hProcess, lpAddress, lpBuffer, dwLength );
		}

		int WINAPI MessageBoxW(
			HWND hWnd,
			LPCWSTR lpText,
			LPCWSTR lpCaption,
			UINT uType
		) {
			validate_return_address( ( uintptr_t ) _ReturnAddress(), "MessageBoxW" );
			return originals::MessageBoxW( hWnd, lpText, lpCaption, uType );
		}

		NTSTATUS NTAPI NtAllocateVirtualMemory(
			HANDLE processhandle,
			PVOID* baseaddress,
			ULONG zerobits,
			PSIZE_T regionsize,
			ULONG allocationtype,
			ULONG protect
		) {

			validate_return_address( ( uintptr_t ) _ReturnAddress(), "NtAllocateVirtualMemory" );
			return originals::NtAllocateVirtualMemory( processhandle, baseaddress, zerobits, regionsize, allocationtype, protect );
		}

		NTSTATUS NTAPI LdrLoadDll(
			PWSTR SearchPath OPTIONAL,
			PULONG DllCharacteristics OPTIONAL,
			UNICODE_STRING* DllName,
			PVOID* BaseAddress
		)
		{
			validate_return_address( ( uintptr_t ) _ReturnAddress(), "LdrLoadDll" );
			return originals::LdrLoadDll( SearchPath, DllCharacteristics, DllName, BaseAddress );
		}

		NTSTATUS NTAPI NtMapViewOfSection( _In_ HANDLE SectionHandle, _In_ HANDLE ProcessHandle,
			_Outptr_result_bytebuffer_( *ViewSize ) PVOID* BaseAddress, _In_ ULONG_PTR ZeroBits,
			_In_ SIZE_T CommitSize, _Inout_opt_ PLARGE_INTEGER SectionOffset, _Inout_ PSIZE_T ViewSize,
			_In_ SECTION_INHERIT InheritDisposition, _In_ ULONG AllocationType, _In_ ULONG Win32Protect )
		{
			validate_return_address( ( uintptr_t ) _ReturnAddress(), "NtMapViewOfSection" );
			return originals::NtMapViewOfSection( SectionHandle, ProcessHandle, BaseAddress, ZeroBits, CommitSize, SectionOffset, ViewSize, InheritDisposition, AllocationType, Win32Protect );
		}

		ULONG NTAPI RtlGetFullPathName_U( PCWSTR FileName, ULONG Size, PWSTR Buffer, PWSTR* ShortName )
		{
			if ( !validate_module_signature( FileName ) )
			{
				printf( "[-] attempting to copy file\n" );

				WCHAR process_directory[ MAX_PATH ] = { 0 };
				if ( GetModuleFileNameW( NULL, process_directory, MAX_PATH ) == 0 )
					printf( "\tfailed to get process directory\n" );

				PathRemoveFileSpecW( process_directory );

				WCHAR dst[ MAX_PATH ] = { 0 };
				swprintf( dst, MAX_PATH, L"%s\\%s", process_directory, PathFindFileNameW( FileName ) );

				if ( CopyFileW( FileName, dst, FALSE ) )
				{
					printf( "\tsuccessfully copied %ls to %ls\n", FileName, dst );
				}
				else
				{
					printf( "\tfailed to copy file: %ls\n", FileName );
				}
			}

			return originals::RtlGetFullPathName_U( FileName, Size, Buffer, ShortName );
		}
	}
}
```

`ac_module/hooks.h`:

```h
#pragma once

#include <wtypes.h>
#include <cstdint>

#include "pe.h"
#include "nt.h"

namespace integrity::hooks
{
	bool install();

	namespace originals
	{
		inline decltype( &LoadLibraryA ) LoadLibraryA = nullptr;
		inline decltype( &LoadLibraryW ) LoadLibraryW = nullptr;
		inline decltype( &LoadLibraryExA ) LoadLibraryExA = nullptr;
		inline decltype( &LoadLibraryExW ) LoadLibraryExW = nullptr;

		inline decltype( &MessageBoxA ) MessageBoxA = nullptr;
		inline decltype( &MessageBoxW ) MessageBoxW = nullptr;
		inline decltype( &MessageBoxExA ) MessageBoxExA = nullptr;
		inline decltype( &MessageBoxExW ) MessageBoxExW = nullptr;

		inline decltype( &VirtualAlloc ) VirtualAlloc = nullptr;
		inline decltype( &VirtualProtect ) VirtualProtect = nullptr;
		inline decltype( &VirtualQuery ) VirtualQuery = nullptr;
		inline decltype( &VirtualAllocEx ) VirtualAllocEx = nullptr;
		inline decltype( &VirtualProtectEx ) VirtualProtectEx = nullptr;
		inline decltype( &VirtualQueryEx ) VirtualQueryEx = nullptr;

		inline decltype( &GetCurrentProcess ) GetCurrentProcess = nullptr;
		inline decltype( &CloseHandle ) CloseHandle = nullptr;

		using fnNtAllocateVirtualMemory = NTSTATUS( NTAPI* ) (
			HANDLE processhandle,
			PVOID* baseaddress,
			ULONG zerobits,
			PSIZE_T regionsize,
			ULONG allocationtype,
			ULONG protect );
		inline fnNtAllocateVirtualMemory NtAllocateVirtualMemory = nullptr;

		using fnNtMapViewOfSection = NTSTATUS( NTAPI* ) (
			HANDLE SectionHandle,
			HANDLE ProcessHandle,
			PVOID* BaseAddress,
			ULONG_PTR ZeroBits,
			SIZE_T CommitSize,
			PLARGE_INTEGER SectionOffset,
			PSIZE_T ViewSize,
			SECTION_INHERIT InheritDisposition,
			ULONG AllocationType,
			ULONG Protect );
		inline fnNtMapViewOfSection NtMapViewOfSection = nullptr;

		using fnLdrLoadDll = NTSTATUS( NTAPI* )(
			PWSTR SearchPath OPTIONAL,
			PULONG DllCharacteristics OPTIONAL,
			UNICODE_STRING* DllName,
			PVOID* BaseAddress );
		inline fnLdrLoadDll LdrLoadDll = nullptr;

		typedef ULONG( NTAPI* fnRtlGetFullPathName_U )( PCWSTR FileName, ULONG Size, PWSTR Buffer, PWSTR* ShortName );
		inline fnRtlGetFullPathName_U RtlGetFullPathName_U = nullptr;
	}

	namespace impl
	{
		BOOL WINAPI CloseHandle( HANDLE handle );
		HANDLE WINAPI GetCurrentProcess();
		HMODULE WINAPI LoadLibraryA( LPCSTR filename );
		HMODULE WINAPI LoadLibraryW( LPCWSTR filename );
		HMODULE WINAPI LoadLibraryExA( LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags );
		HMODULE WINAPI LoadLibraryExW( LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags );
		LPVOID WINAPI VirtualAllocEx(
			_In_ HANDLE hProcess,
			_In_opt_ LPVOID lpAddress,
			_In_ SIZE_T dwSize,
			_In_ DWORD flAllocationType,
			_In_ DWORD flProtect
		);
		SIZE_T WINAPI VirtualQueryEx(
			HANDLE hProcess,
			LPCVOID lpAddress,
			PMEMORY_BASIC_INFORMATION lpBuffer,
			SIZE_T dwLength
		);
		int WINAPI MessageBoxW(
			HWND hWnd,
			LPCWSTR lpText,
			LPCWSTR lpCaption,
			UINT uType
		);
		NTSTATUS NTAPI NtAllocateVirtualMemory(
			HANDLE processhandle,
			PVOID* baseaddress,
			ULONG zerobits,
			PSIZE_T regionsize,
			ULONG allocationtype,
			ULONG protect
		);
		NTSTATUS NTAPI LdrLoadDll(
			PWSTR SearchPath OPTIONAL,
			PULONG DllCharacteristics OPTIONAL,
			UNICODE_STRING* DllName,
			PVOID* BaseAddress
		);
		NTSTATUS NTAPI NtMapViewOfSection( _In_ HANDLE SectionHandle, _In_ HANDLE ProcessHandle,
			_Outptr_result_bytebuffer_( *ViewSize ) PVOID* BaseAddress, _In_ ULONG_PTR ZeroBits,
			_In_ SIZE_T CommitSize, _Inout_opt_ PLARGE_INTEGER SectionOffset, _Inout_ PSIZE_T ViewSize,
			_In_ SECTION_INHERIT InheritDisposition, _In_ ULONG AllocationType, _In_ ULONG Win32Protect );
		ULONG NTAPI RtlGetFullPathName_U( PCWSTR FileName, ULONG Size, PWSTR Buffer, PWSTR* ShortName );
	}
}
```

`ac_module/integrity.cpp`:

```cpp
#include "integrity.h"
#include "hooks.h"
#include "util.h"

#include <thread>
#include <wintrust.h>
#include <softpub.h>
#include <unordered_map>
#include <fstream>
#include <sstream>

#pragma comment(lib, "wintrust.lib")

namespace integrity
{
	bool init( HINSTANCE dll )
	{
		init_console();

		printf( "[+] ac_module injected\n" );

		ctx::image_base = ( uintptr_t ) dll;

		printf( "\timage base: 0x%p\n", dll );

		ctx::image_size = ( ( IMAGE_NT_HEADERS* ) ( ( uintptr_t ) dll + ( ( IMAGE_DOS_HEADER* ) dll )->e_lfanew ) )->OptionalHeader.SizeOfImage;

		printf( "\timage size: %lu\n", ctx::image_size );

		const auto nt_headers = ( IMAGE_NT_HEADERS* ) ( ctx::image_base + ( ( IMAGE_DOS_HEADER* ) ctx::image_base )->e_lfanew );

		DWORD old_protect;
		if ( VirtualProtect( ( void* ) ctx::image_base, nt_headers->OptionalHeader.SizeOfHeaders, PAGE_READWRITE, &old_protect ) )
		{
			memset( ( void* ) ctx::image_base, 0, nt_headers->OptionalHeader.SizeOfHeaders );
			VirtualProtect( ( void* ) ctx::image_base, nt_headers->OptionalHeader.SizeOfHeaders, old_protect, &old_protect );
			printf( "[+] wiped PE header\n" );
		}

		std::thread( validate_memory_regions ).detach();

		std::thread( validate_checksums ).detach();

		printf( "[+] started watchdog threads\n" );

		if ( !hooks::install() )
			return false;

		printf( "[+] installed hooks\n" );

		return true;
	}

	void validate_memory_regions()
	{
		std::unordered_map<uintptr_t, bool> suspicious_regions;

		// todo: check for unlinked modules

		while ( true )
		{
			MEMORY_BASIC_INFORMATION mbi = { 0 };
			uintptr_t current_address = 0;

			while ( VirtualQuery( ( LPCVOID ) current_address, &mbi, sizeof( mbi ) ) )
			{
				current_address += mbi.RegionSize;

				if ( ( uintptr_t ) mbi.AllocationBase == ctx::image_base )
					continue;

				if ( mbi.Type != MEM_PRIVATE )
					continue;

				/*
					will potentially catch more suspicious regions but also incur false positives

					if ( mbi.AllocationProtect == PAGE_EXECUTE_READWRITE && mbi.Protect == PAGE_READONLY ||
						mbi.AllocationProtect == PAGE_EXECUTE_READWRITE && mbi.Protect == PAGE_EXECUTE_READWRITE )
				*/

				if ( mbi.Protect == PAGE_EXECUTE_READ )
				{
					suspicious_regions.emplace( ( uintptr_t ) mbi.AllocationBase, false );
				}
			}

			for ( auto& [address, reported] : suspicious_regions )
			{
				if ( !reported )
				{
					printf( "[!] suspicious memory region: 0x%p\n\tattempting to dump\n", address );

					util::dump_to_file( address, "\t" );

					reported = true;
				}
			}

			std::this_thread::sleep_for( std::chrono::milliseconds( 500 ) );
		}
	}

	void validate_checksums()
	{
		std::unordered_map<std::wstring, std::vector<checksum_region>> checksum_cache;

		while ( true )
		{
			util::walk_ldr_list( [ & ]( LDR_DATA_TABLE_ENTRY* ldr_entry )
				{
					if ( checksum_cache.find( ldr_entry->FullDllName.Buffer ) == checksum_cache.end() )
					{
						checksum_cache.emplace( ldr_entry->FullDllName.Buffer, util::compute_file_checksums( ldr_entry->FullDllName.Buffer, ( uintptr_t ) ldr_entry->DllBase ) );
					}

					if ( auto& cached_checksum = checksum_cache[ ldr_entry->FullDllName.Buffer ]; cached_checksum.size() )
					{
						for ( auto& checksum_region : cached_checksum )
						{
							uintptr_t checksum = 0;

							const auto checksum_start = ( std::byte* ) ( checksum_region.start );
							for ( DWORD i = 0; i < checksum_region.size; i++ )
								checksum += ( uintptr_t ) checksum_start[ i ];

							if ( checksum != checksum_region.checksum && !checksum_region.reported )
							{
								printf( "[!] %s checksum mismatch: %ls\n", checksum_region.name, ldr_entry->FullDllName.Buffer );
								checksum_region.reported = true;
							}
						}
					}
				} );

			std::this_thread::sleep_for( std::chrono::milliseconds( 500 ) );
		}
	}

	// https://learn.microsoft.com/en-us/windows/win32/seccrypto/example-c-program--verifying-the-signature-of-a-pe-file
	bool validate_module_signature( LPCWSTR pwszSourceFile )
	{
		LONG lStatus;
		DWORD dwLastError;

		// Initialize the WINTRUST_FILE_INFO structure.

		WINTRUST_FILE_INFO FileData;
		memset( &FileData, 0, sizeof( FileData ) );
		FileData.cbStruct = sizeof( WINTRUST_FILE_INFO );
		FileData.pcwszFilePath = pwszSourceFile;
		FileData.hFile = NULL;
		FileData.pgKnownSubject = NULL;

		/*
		WVTPolicyGUID specifies the policy to apply on the file
		WINTRUST_ACTION_GENERIC_VERIFY_V2 policy checks:

		1) The certificate used to sign the file chains up to a root
		certificate located in the trusted root certificate store. This
		implies that the identity of the publisher has been verified by
		a certification authority.

		2) In cases where user interface is displayed (which this example
		does not do), WinVerifyTrust will check for whether the
		end entity certificate is stored in the trusted publisher store,
		implying that the user trusts content from this publisher.

		3) The end entity certificate has sufficient permission to sign
		code, as indicated by the presence of a code signing EKU or no
		EKU.
		*/

		GUID WVTPolicyGUID = WINTRUST_ACTION_GENERIC_VERIFY_V2;
		WINTRUST_DATA WinTrustData;

		// Initialize the WinVerifyTrust input data structure.

		// Default all fields to 0.
		memset( &WinTrustData, 0, sizeof( WinTrustData ) );

		WinTrustData.cbStruct = sizeof( WinTrustData );

		// Use default code signing EKU.
		WinTrustData.pPolicyCallbackData = NULL;

		// No data to pass to SIP.
		WinTrustData.pSIPClientData = NULL;

		// Disable WVT UI.
		WinTrustData.dwUIChoice = WTD_UI_NONE;

		// No revocation checking.
		WinTrustData.fdwRevocationChecks = WTD_REVOKE_NONE;

		// Verify an embedded signature on a file.
		WinTrustData.dwUnionChoice = WTD_CHOICE_FILE;

		// Verify action.
		WinTrustData.dwStateAction = WTD_STATEACTION_VERIFY;

		// Verification sets this value.
		WinTrustData.hWVTStateData = NULL;

		// Not used.
		WinTrustData.pwszURLReference = NULL;

		// This is not applicable if there is no UI because it changes 
		// the UI to accommodate running applications instead of 
		// installing applications.
		WinTrustData.dwUIContext = 0;

		// Set pFile.
		WinTrustData.pFile = &FileData;

		// WinVerifyTrust verifies signatures as specified by the GUID 
		// and Wintrust_Data.
		lStatus = WinVerifyTrust(
			NULL,
			&WVTPolicyGUID,
			&WinTrustData );

		bool trusted = false;

		switch ( lStatus )
		{
			case ERROR_SUCCESS:
				/*
				Signed file:
					- Hash that represents the subject is trusted.

					- Trusted publisher without any verification errors.

					- UI was disabled in dwUIChoice. No publisher or
						time stamp chain errors.

					- UI was enabled in dwUIChoice and the user clicked
						"Yes" when asked to install and run the signed
						subject.
				*/
				wprintf_s( L"[+] The file \"%s\" is signed and the signature "
					L"was verified.\n",
					pwszSourceFile );

				trusted = true;

				break;

			case TRUST_E_NOSIGNATURE:
				// The file was not signed or had a signature 
				// that was not valid.

				// Get the reason for no signature.
				dwLastError = GetLastError();
				if ( TRUST_E_NOSIGNATURE == dwLastError ||
					TRUST_E_SUBJECT_FORM_UNKNOWN == dwLastError ||
					TRUST_E_PROVIDER_UNKNOWN == dwLastError )
				{
					// The file was not signed.
					wprintf_s( L"[!] The file \"%s\" is not signed.\n",
						pwszSourceFile );
				}
				else
				{
					// The signature was not valid or there was an error 
					// opening the file.
					wprintf_s( L"[!] An unknown error occurred trying to "
						L"verify the signature of the \"%s\" file.\n",
						pwszSourceFile );
				}

				break;

			case TRUST_E_EXPLICIT_DISTRUST:
				// The hash that represents the subject or the publisher 
				// is not allowed by the admin or user.
				wprintf_s( L"[!] The signature is present, but specifically "
					L"disallowed.\n" );
				break;

			case TRUST_E_SUBJECT_NOT_TRUSTED:
				// The user clicked "No" when asked to install and run.
				wprintf_s( L"[!] The signature is present, but not "
					L"trusted.\n" );
				break;

			case CRYPT_E_SECURITY_SETTINGS:
				/*
				The hash that represents the subject or the publisher
				was not explicitly trusted by the admin and the
				admin policy has disabled user trust. No signature,
				publisher or time stamp errors.
				*/
				wprintf_s( L"[!] CRYPT_E_SECURITY_SETTINGS - The hash "
					L"representing the subject or the publisher wasn't "
					L"explicitly trusted by the admin and admin policy "
					L"has disabled user trust. No signature, publisher "
					L"or timestamp errors.\n" );
				break;

			default:
				// The UI was disabled in dwUIChoice or the admin policy 
				// has disabled user trust. lStatus contains the 
				// publisher or time stamp chain error.
				wprintf_s( L"[!] Error is: 0x%x.\n",
					lStatus );
				break;
		}

		// Any hWVTStateData must be released by a call with close.
		WinTrustData.dwStateAction = WTD_STATEACTION_CLOSE;

		lStatus = WinVerifyTrust(
			NULL,
			&WVTPolicyGUID,
			&WinTrustData );

		return trusted;
	}

	bool validate_return_address( uintptr_t address, const char* function_name )
	{
#ifdef _WIN64
		const auto peb = ( _PEB* ) __readgsqword( 0x60 );
#else
		const auto peb = ( _PEB* ) __readfsdword( 0x30 );
#endif

		const auto list_head = &peb->Ldr->InMemoryOrderModuleList;

		for ( auto it = list_head->Flink; it != list_head; it = it->Flink )
		{
			const auto ldr_entry = CONTAINING_RECORD( it, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks );
			if ( !ldr_entry )
				continue;

			const auto dos = ( IMAGE_DOS_HEADER* ) ldr_entry->DllBase;
			if ( !dos || dos->e_magic != IMAGE_DOS_SIGNATURE )
				continue;

			const auto nt = ( IMAGE_NT_HEADERS* ) ( ( uintptr_t ) dos + dos->e_lfanew );
			if ( !nt || nt->Signature != IMAGE_NT_SIGNATURE )
				continue;

			if ( ( address >= ( uintptr_t ) dos && address < ( ( uintptr_t ) dos + nt->OptionalHeader.SizeOfImage ) ) || ( address >= ctx::image_base && address < ( ctx::image_base + ctx::image_size ) ) )
				return true;
		}

		printf( "[!] %s failed integrity check\n\treturn address: 0x%p\n", function_name, address );

		MEMORY_BASIC_INFORMATION mbi;
		if ( VirtualQuery( ( LPCVOID ) address, &mbi, sizeof( mbi ) ) )
		{
			printf( "\tattempting to dump memory region 0x%p\n", mbi.AllocationBase );

			if ( mbi.AllocationBase )
			{
				util::dump_to_file( ( uintptr_t ) mbi.AllocationBase, "\t" );
			}
			else
			{
				printf( "\tfailed to dump memory region due to invalid allocation base\n" );
			}
		}
		else
		{
			printf( "\tfailed to query memory region" );
		}

		return false;
	}
}
```

`ac_module/integrity.h`:

```h
#pragma once

#include <wtypes.h>
#include <iostream>

namespace ctx
{
	inline uintptr_t image_base;
	inline size_t image_size;
}

namespace integrity
{
	inline void init_console()
	{
		AllocConsole();

		HWND                con_hwndw{ GetConsoleWindow() };
		RECT                  con_bound{ 904 + 219, 420 };
		RECT                  wndw_rect{};

		SetConsoleTitle( "ac_module" );

		GetWindowRect( con_hwndw, &wndw_rect );
		MoveWindow( con_hwndw, wndw_rect.left, wndw_rect.top, con_bound.left, con_bound.top, true );

		SetWindowLong( con_hwndw, GWL_STYLE, GetWindowLong( con_hwndw, GWL_STYLE ) | WS_BORDER );
		SetWindowLong( con_hwndw, GWL_EXSTYLE, GetWindowLong( con_hwndw, GWL_EXSTYLE ) | WS_EX_LAYERED );

		SetLayeredWindowAttributes( con_hwndw, 0, 230, 2 );
		SetConsoleTextAttribute( GetStdHandle( STD_OUTPUT_HANDLE ), FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_INTENSITY );

		freopen( ( "CONOUT$" ), ( "w" ), stdout );
	}

	bool init( HINSTANCE dll );

	void validate_memory_regions();
	void validate_checksums();

	bool validate_module_signature( LPCWSTR pwszSourceFile );
	bool validate_return_address( uintptr_t address, const char* function_name );
}
```

`ac_module/lib/minhook/include/minhook.h`:

```h
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#pragma once

#if !(defined _M_IX86) && !(defined _M_X64) && !(defined __i386__) && !(defined __x86_64__)
    #error MinHook supports only x86 and x64 systems.
#endif

#include <windows.h>

// MinHook Error Codes.
typedef enum MH_STATUS
{
    // Unknown error. Should not be returned.
    MH_UNKNOWN = -1,

    // Successful.
    MH_OK = 0,

    // MinHook is already initialized.
    MH_ERROR_ALREADY_INITIALIZED,

    // MinHook is not initialized yet, or already uninitialized.
    MH_ERROR_NOT_INITIALIZED,

    // The hook for the specified target function is already created.
    MH_ERROR_ALREADY_CREATED,

    // The hook for the specified target function is not created yet.
    MH_ERROR_NOT_CREATED,

    // The hook for the specified target function is already enabled.
    MH_ERROR_ENABLED,

    // The hook for the specified target function is not enabled yet, or already
    // disabled.
    MH_ERROR_DISABLED,

    // The specified pointer is invalid. It points the address of non-allocated
    // and/or non-executable region.
    MH_ERROR_NOT_EXECUTABLE,

    // The specified target function cannot be hooked.
    MH_ERROR_UNSUPPORTED_FUNCTION,

    // Failed to allocate memory.
    MH_ERROR_MEMORY_ALLOC,

    // Failed to change the memory protection.
    MH_ERROR_MEMORY_PROTECT,

    // The specified module is not loaded.
    MH_ERROR_MODULE_NOT_FOUND,

    // The specified function is not found.
    MH_ERROR_FUNCTION_NOT_FOUND
}
MH_STATUS;

// Can be passed as a parameter to MH_EnableHook, MH_DisableHook,
// MH_QueueEnableHook or MH_QueueDisableHook.
#define MH_ALL_HOOKS NULL

#ifdef __cplusplus
extern "C" {
#endif

    // Initialize the MinHook library. You must call this function EXACTLY ONCE
    // at the beginning of your program.
    MH_STATUS WINAPI MH_Initialize(VOID);

    // Uninitialize the MinHook library. You must call this function EXACTLY
    // ONCE at the end of your program.
    MH_STATUS WINAPI MH_Uninitialize(VOID);

    // Creates a hook for the specified target function, in disabled state.
    // Parameters:
    //   pTarget     [in]  A pointer to the target function, which will be
    //                     overridden by the detour function.
    //   pDetour     [in]  A pointer to the detour function, which will override
    //                     the target function.
    //   ppOriginal  [out] A pointer to the trampoline function, which will be
    //                     used to call the original target function.
    //                     This parameter can be NULL.
    MH_STATUS WINAPI MH_CreateHook(LPVOID pTarget, LPVOID pDetour, LPVOID *ppOriginal);

    // Creates a hook for the specified API function, in disabled state.
    // Parameters:
    //   pszModule   [in]  A pointer to the loaded module name which contains the
    //                     target function.
    //   pszProcName [in]  A pointer to the target function name, which will be
    //                     overridden by the detour function.
    //   pDetour     [in]  A pointer to the detour function, which will override
    //                     the target function.
    //   ppOriginal  [out] A pointer to the trampoline function, which will be
    //                     used to call the original target function.
    //                     This parameter can be NULL.
    MH_STATUS WINAPI MH_CreateHookApi(
        LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, LPVOID *ppOriginal);

    // Creates a hook for the specified API function, in disabled state.
    // Parameters:
    //   pszModule   [in]  A pointer to the loaded module name which contains the
    //                     target function.
    //   pszProcName [in]  A pointer to the target function name, which will be
    //                     overridden by the detour function.
    //   pDetour     [in]  A pointer to the detour function, which will override
    //                     the target function.
    //   ppOriginal  [out] A pointer to the trampoline function, which will be
    //                     used to call the original target function.
    //                     This parameter can be NULL.
    //   ppTarget    [out] A pointer to the target function, which will be used
    //                     with other functions.
    //                     This parameter can be NULL.
    MH_STATUS WINAPI MH_CreateHookApiEx(
        LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, LPVOID *ppOriginal, LPVOID *ppTarget);

    // Removes an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    MH_STATUS WINAPI MH_RemoveHook(LPVOID pTarget);

    // Enables an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                enabled in one go.
    MH_STATUS WINAPI MH_EnableHook(LPVOID pTarget);

    // Disables an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                disabled in one go.
    MH_STATUS WINAPI MH_DisableHook(LPVOID pTarget);

    // Queues to enable an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                queued to be enabled.
    MH_STATUS WINAPI MH_QueueEnableHook(LPVOID pTarget);

    // Queues to disable an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                queued to be disabled.
    MH_STATUS WINAPI MH_QueueDisableHook(LPVOID pTarget);

    // Applies all queued changes in one go.
    MH_STATUS WINAPI MH_ApplyQueued(VOID);

    // Translates the MH_STATUS to its name as a string.
    const char * WINAPI MH_StatusToString(MH_STATUS status);

#ifdef __cplusplus
}
#endif
```

`ac_module/lib/minhook/src/buffer.c`:

```c
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <windows.h>
#include "buffer.h"

// Size of each memory block. (= page size of VirtualAlloc)
#define MEMORY_BLOCK_SIZE 0x1000

// Max range for seeking a memory block. (= 1024MB)
#define MAX_MEMORY_RANGE 0x40000000

// Memory protection flags to check the executable address.
#define PAGE_EXECUTE_FLAGS \
    (PAGE_EXECUTE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY)

// Memory slot.
typedef struct _MEMORY_SLOT
{
    union
    {
        struct _MEMORY_SLOT *pNext;
        UINT8 buffer[MEMORY_SLOT_SIZE];
    };
} MEMORY_SLOT, *PMEMORY_SLOT;

// Memory block info. Placed at the head of each block.
typedef struct _MEMORY_BLOCK
{
    struct _MEMORY_BLOCK *pNext;
    PMEMORY_SLOT pFree;         // First element of the free slot list.
    UINT usedCount;
} MEMORY_BLOCK, *PMEMORY_BLOCK;

//-------------------------------------------------------------------------
// Global Variables:
//-------------------------------------------------------------------------

// First element of the memory block list.
PMEMORY_BLOCK g_pMemoryBlocks;

//-------------------------------------------------------------------------
VOID InitializeBuffer(VOID)
{
    // Nothing to do for now.
}

//-------------------------------------------------------------------------
VOID UninitializeBuffer(VOID)
{
    PMEMORY_BLOCK pBlock = g_pMemoryBlocks;
    g_pMemoryBlocks = NULL;

    while (pBlock)
    {
        PMEMORY_BLOCK pNext = pBlock->pNext;
        VirtualFree(pBlock, 0, MEM_RELEASE);
        pBlock = pNext;
    }
}

//-------------------------------------------------------------------------
#if defined(_M_X64) || defined(__x86_64__)
static LPVOID FindPrevFreeRegion(LPVOID pAddress, LPVOID pMinAddr, DWORD dwAllocationGranularity)
{
    ULONG_PTR tryAddr = (ULONG_PTR)pAddress;

    // Round down to the allocation granularity.
    tryAddr -= tryAddr % dwAllocationGranularity;

    // Start from the previous allocation granularity multiply.
    tryAddr -= dwAllocationGranularity;

    while (tryAddr >= (ULONG_PTR)pMinAddr)
    {
        MEMORY_BASIC_INFORMATION mbi;
        if (VirtualQuery((LPVOID)tryAddr, &mbi, sizeof(mbi)) == 0)
            break;

        if (mbi.State == MEM_FREE)
            return (LPVOID)tryAddr;

        if ((ULONG_PTR)mbi.AllocationBase < dwAllocationGranularity)
            break;

        tryAddr = (ULONG_PTR)mbi.AllocationBase - dwAllocationGranularity;
    }

    return NULL;
}
#endif

//-------------------------------------------------------------------------
#if defined(_M_X64) || defined(__x86_64__)
static LPVOID FindNextFreeRegion(LPVOID pAddress, LPVOID pMaxAddr, DWORD dwAllocationGranularity)
{
    ULONG_PTR tryAddr = (ULONG_PTR)pAddress;

    // Round down to the allocation granularity.
    tryAddr -= tryAddr % dwAllocationGranularity;

    // Start from the next allocation granularity multiply.
    tryAddr += dwAllocationGranularity;

    while (tryAddr <= (ULONG_PTR)pMaxAddr)
    {
        MEMORY_BASIC_INFORMATION mbi;
        if (VirtualQuery((LPVOID)tryAddr, &mbi, sizeof(mbi)) == 0)
            break;

        if (mbi.State == MEM_FREE)
            return (LPVOID)tryAddr;

        tryAddr = (ULONG_PTR)mbi.BaseAddress + mbi.RegionSize;

        // Round up to the next allocation granularity.
        tryAddr += dwAllocationGranularity - 1;
        tryAddr -= tryAddr % dwAllocationGranularity;
    }

    return NULL;
}
#endif

//-------------------------------------------------------------------------
static PMEMORY_BLOCK GetMemoryBlock(LPVOID pOrigin)
{
    PMEMORY_BLOCK pBlock;
#if defined(_M_X64) || defined(__x86_64__)
    ULONG_PTR minAddr;
    ULONG_PTR maxAddr;

    SYSTEM_INFO si;
    GetSystemInfo(&si);
    minAddr = (ULONG_PTR)si.lpMinimumApplicationAddress;
    maxAddr = (ULONG_PTR)si.lpMaximumApplicationAddress;

    // pOrigin ± 512MB
    if ((ULONG_PTR)pOrigin > MAX_MEMORY_RANGE && minAddr < (ULONG_PTR)pOrigin - MAX_MEMORY_RANGE)
        minAddr = (ULONG_PTR)pOrigin - MAX_MEMORY_RANGE;

    if (maxAddr > (ULONG_PTR)pOrigin + MAX_MEMORY_RANGE)
        maxAddr = (ULONG_PTR)pOrigin + MAX_MEMORY_RANGE;

    // Make room for MEMORY_BLOCK_SIZE bytes.
    maxAddr -= MEMORY_BLOCK_SIZE - 1;
#endif

    // Look the registered blocks for a reachable one.
    for (pBlock = g_pMemoryBlocks; pBlock != NULL; pBlock = pBlock->pNext)
    {
#if defined(_M_X64) || defined(__x86_64__)
        // Ignore the blocks too far.
        if ((ULONG_PTR)pBlock < minAddr || (ULONG_PTR)pBlock >= maxAddr)
            continue;
#endif
        // The block has at least one unused slot.
        if (pBlock->pFree != NULL)
            return pBlock;
    }

#if defined(_M_X64) || defined(__x86_64__)
    // Alloc a new block above if not found.
    {
        LPVOID pAlloc = pOrigin;
        while ((ULONG_PTR)pAlloc >= minAddr)
        {
            pAlloc = FindPrevFreeRegion(pAlloc, (LPVOID)minAddr, si.dwAllocationGranularity);
            if (pAlloc == NULL)
                break;

            pBlock = (PMEMORY_BLOCK)VirtualAlloc(
                pAlloc, MEMORY_BLOCK_SIZE, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
            if (pBlock != NULL)
                break;
        }
    }

    // Alloc a new block below if not found.
    if (pBlock == NULL)
    {
        LPVOID pAlloc = pOrigin;
        while ((ULONG_PTR)pAlloc <= maxAddr)
        {
            pAlloc = FindNextFreeRegion(pAlloc, (LPVOID)maxAddr, si.dwAllocationGranularity);
            if (pAlloc == NULL)
                break;

            pBlock = (PMEMORY_BLOCK)VirtualAlloc(
                pAlloc, MEMORY_BLOCK_SIZE, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
            if (pBlock != NULL)
                break;
        }
    }
#else
    // In x86 mode, a memory block can be placed anywhere.
    pBlock = (PMEMORY_BLOCK)VirtualAlloc(
        NULL, MEMORY_BLOCK_SIZE, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
#endif

    if (pBlock != NULL)
    {
        // Build a linked list of all the slots.
        PMEMORY_SLOT pSlot = (PMEMORY_SLOT)pBlock + 1;
        pBlock->pFree = NULL;
        pBlock->usedCount = 0;
        do
        {
            pSlot->pNext = pBlock->pFree;
            pBlock->pFree = pSlot;
            pSlot++;
        } while ((ULONG_PTR)pSlot - (ULONG_PTR)pBlock <= MEMORY_BLOCK_SIZE - MEMORY_SLOT_SIZE);

        pBlock->pNext = g_pMemoryBlocks;
        g_pMemoryBlocks = pBlock;
    }

    return pBlock;
}

//-------------------------------------------------------------------------
LPVOID AllocateBuffer(LPVOID pOrigin)
{
    PMEMORY_SLOT  pSlot;
    PMEMORY_BLOCK pBlock = GetMemoryBlock(pOrigin);
    if (pBlock == NULL)
        return NULL;

    // Remove an unused slot from the list.
    pSlot = pBlock->pFree;
    pBlock->pFree = pSlot->pNext;
    pBlock->usedCount++;
#ifdef _DEBUG
    // Fill the slot with INT3 for debugging.
    memset(pSlot, 0xCC, sizeof(MEMORY_SLOT));
#endif
    return pSlot;
}

//-------------------------------------------------------------------------
VOID FreeBuffer(LPVOID pBuffer)
{
    PMEMORY_BLOCK pBlock = g_pMemoryBlocks;
    PMEMORY_BLOCK pPrev = NULL;
    ULONG_PTR pTargetBlock = ((ULONG_PTR)pBuffer / MEMORY_BLOCK_SIZE) * MEMORY_BLOCK_SIZE;

    while (pBlock != NULL)
    {
        if ((ULONG_PTR)pBlock == pTargetBlock)
        {
            PMEMORY_SLOT pSlot = (PMEMORY_SLOT)pBuffer;
#ifdef _DEBUG
            // Clear the released slot for debugging.
            memset(pSlot, 0x00, sizeof(MEMORY_SLOT));
#endif
            // Restore the released slot to the list.
            pSlot->pNext = pBlock->pFree;
            pBlock->pFree = pSlot;
            pBlock->usedCount--;

            // Free if unused.
            if (pBlock->usedCount == 0)
            {
                if (pPrev)
                    pPrev->pNext = pBlock->pNext;
                else
                    g_pMemoryBlocks = pBlock->pNext;

                VirtualFree(pBlock, 0, MEM_RELEASE);
            }

            break;
        }

        pPrev = pBlock;
        pBlock = pBlock->pNext;
    }
}

//-------------------------------------------------------------------------
BOOL IsExecutableAddress(LPVOID pAddress)
{
    MEMORY_BASIC_INFORMATION mi;
    VirtualQuery(pAddress, &mi, sizeof(mi));

    return (mi.State == MEM_COMMIT && (mi.Protect & PAGE_EXECUTE_FLAGS));
}

```

`ac_module/lib/minhook/src/buffer.h`:

```h
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#pragma once

// Size of each memory slot.
#if defined(_M_X64) || defined(__x86_64__)
    #define MEMORY_SLOT_SIZE 64
#else
    #define MEMORY_SLOT_SIZE 32
#endif

VOID   InitializeBuffer(VOID);
VOID   UninitializeBuffer(VOID);
LPVOID AllocateBuffer(LPVOID pOrigin);
VOID   FreeBuffer(LPVOID pBuffer);
BOOL   IsExecutableAddress(LPVOID pAddress);

```

`ac_module/lib/minhook/src/hde/hde32.c`:

```c
/*
 * Hacker Disassembler Engine 32 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#if defined(_M_IX86) || defined(__i386__)

#include <string.h>
#include "hde32.h"
#include "table32.h"

unsigned int hde32_disasm(const void *code, hde32s *hs)
{
    uint8_t x, c, *p = (uint8_t *)code, cflags, opcode, pref = 0;
    uint8_t *ht = hde32_table, m_mod, m_reg, m_rm, disp_size = 0;

    memset(hs, 0, sizeof(hde32s));

    for (x = 16; x; x--)
        switch (c = *p++) {
            case 0xf3:
                hs->p_rep = c;
                pref |= PRE_F3;
                break;
            case 0xf2:
                hs->p_rep = c;
                pref |= PRE_F2;
                break;
            case 0xf0:
                hs->p_lock = c;
                pref |= PRE_LOCK;
                break;
            case 0x26: case 0x2e: case 0x36:
            case 0x3e: case 0x64: case 0x65:
                hs->p_seg = c;
                pref |= PRE_SEG;
                break;
            case 0x66:
                hs->p_66 = c;
                pref |= PRE_66;
                break;
            case 0x67:
                hs->p_67 = c;
                pref |= PRE_67;
                break;
            default:
                goto pref_done;
        }
  pref_done:

    hs->flags = (uint32_t)pref << 23;

    if (!pref)
        pref |= PRE_NONE;

    if ((hs->opcode = c) == 0x0f) {
        hs->opcode2 = c = *p++;
        ht += DELTA_OPCODES;
    } else if (c >= 0xa0 && c <= 0xa3) {
        if (pref & PRE_67)
            pref |= PRE_66;
        else
            pref &= ~PRE_66;
    }

    opcode = c;
    cflags = ht[ht[opcode / 4] + (opcode % 4)];

    if (cflags == C_ERROR) {
        hs->flags |= F_ERROR | F_ERROR_OPCODE;
        cflags = 0;
        if ((opcode & -3) == 0x24)
            cflags++;
    }

    x = 0;
    if (cflags & C_GROUP) {
        uint16_t t;
        t = *(uint16_t *)(ht + (cflags & 0x7f));
        cflags = (uint8_t)t;
        x = (uint8_t)(t >> 8);
    }

    if (hs->opcode2) {
        ht = hde32_table + DELTA_PREFIXES;
        if (ht[ht[opcode / 4] + (opcode % 4)] & pref)
            hs->flags |= F_ERROR | F_ERROR_OPCODE;
    }

    if (cflags & C_MODRM) {
        hs->flags |= F_MODRM;
        hs->modrm = c = *p++;
        hs->modrm_mod = m_mod = c >> 6;
        hs->modrm_rm = m_rm = c & 7;
        hs->modrm_reg = m_reg = (c & 0x3f) >> 3;

        if (x && ((x << m_reg) & 0x80))
            hs->flags |= F_ERROR | F_ERROR_OPCODE;

        if (!hs->opcode2 && opcode >= 0xd9 && opcode <= 0xdf) {
            uint8_t t = opcode - 0xd9;
            if (m_mod == 3) {
                ht = hde32_table + DELTA_FPU_MODRM + t*8;
                t = ht[m_reg] << m_rm;
            } else {
                ht = hde32_table + DELTA_FPU_REG;
                t = ht[t] << m_reg;
            }
            if (t & 0x80)
                hs->flags |= F_ERROR | F_ERROR_OPCODE;
        }

        if (pref & PRE_LOCK) {
            if (m_mod == 3) {
                hs->flags |= F_ERROR | F_ERROR_LOCK;
            } else {
                uint8_t *table_end, op = opcode;
                if (hs->opcode2) {
                    ht = hde32_table + DELTA_OP2_LOCK_OK;
                    table_end = ht + DELTA_OP_ONLY_MEM - DELTA_OP2_LOCK_OK;
                } else {
                    ht = hde32_table + DELTA_OP_LOCK_OK;
                    table_end = ht + DELTA_OP2_LOCK_OK - DELTA_OP_LOCK_OK;
                    op &= -2;
                }
                for (; ht != table_end; ht++)
                    if (*ht++ == op) {
                        if (!((*ht << m_reg) & 0x80))
                            goto no_lock_error;
                        else
                            break;
                    }
                hs->flags |= F_ERROR | F_ERROR_LOCK;
              no_lock_error:
                ;
            }
        }

        if (hs->opcode2) {
            switch (opcode) {
                case 0x20: case 0x22:
                    m_mod = 3;
                    if (m_reg > 4 || m_reg == 1)
                        goto error_operand;
                    else
                        goto no_error_operand;
                case 0x21: case 0x23:
                    m_mod = 3;
                    if (m_reg == 4 || m_reg == 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
            }
        } else {
            switch (opcode) {
                case 0x8c:
                    if (m_reg > 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
                case 0x8e:
                    if (m_reg == 1 || m_reg > 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
            }
        }

        if (m_mod == 3) {
            uint8_t *table_end;
            if (hs->opcode2) {
                ht = hde32_table + DELTA_OP2_ONLY_MEM;
                table_end = ht + sizeof(hde32_table) - DELTA_OP2_ONLY_MEM;
            } else {
                ht = hde32_table + DELTA_OP_ONLY_MEM;
                table_end = ht + DELTA_OP2_ONLY_MEM - DELTA_OP_ONLY_MEM;
            }
            for (; ht != table_end; ht += 2)
                if (*ht++ == opcode) {
                    if ((*ht++ & pref) && !((*ht << m_reg) & 0x80))
                        goto error_operand;
                    else
                        break;
                }
            goto no_error_operand;
        } else if (hs->opcode2) {
            switch (opcode) {
                case 0x50: case 0xd7: case 0xf7:
                    if (pref & (PRE_NONE | PRE_66))
                        goto error_operand;
                    break;
                case 0xd6:
                    if (pref & (PRE_F2 | PRE_F3))
                        goto error_operand;
                    break;
                case 0xc5:
                    goto error_operand;
            }
            goto no_error_operand;
        } else
            goto no_error_operand;

      error_operand:
        hs->flags |= F_ERROR | F_ERROR_OPERAND;
      no_error_operand:

        c = *p++;
        if (m_reg <= 1) {
            if (opcode == 0xf6)
                cflags |= C_IMM8;
            else if (opcode == 0xf7)
                cflags |= C_IMM_P66;
        }

        switch (m_mod) {
            case 0:
                if (pref & PRE_67) {
                    if (m_rm == 6)
                        disp_size = 2;
                } else
                    if (m_rm == 5)
                        disp_size = 4;
                break;
            case 1:
                disp_size = 1;
                break;
            case 2:
                disp_size = 2;
                if (!(pref & PRE_67))
                    disp_size <<= 1;
                break;
        }

        if (m_mod != 3 && m_rm == 4 && !(pref & PRE_67)) {
            hs->flags |= F_SIB;
            p++;
            hs->sib = c;
            hs->sib_scale = c >> 6;
            hs->sib_index = (c & 0x3f) >> 3;
            if ((hs->sib_base = c & 7) == 5 && !(m_mod & 1))
                disp_size = 4;
        }

        p--;
        switch (disp_size) {
            case 1:
                hs->flags |= F_DISP8;
                hs->disp.disp8 = *p;
                break;
            case 2:
                hs->flags |= F_DISP16;
                hs->disp.disp16 = *(uint16_t *)p;
                break;
            case 4:
                hs->flags |= F_DISP32;
                hs->disp.disp32 = *(uint32_t *)p;
                break;
        }
        p += disp_size;
    } else if (pref & PRE_LOCK)
        hs->flags |= F_ERROR | F_ERROR_LOCK;

    if (cflags & C_IMM_P66) {
        if (cflags & C_REL32) {
            if (pref & PRE_66) {
                hs->flags |= F_IMM16 | F_RELATIVE;
                hs->imm.imm16 = *(uint16_t *)p;
                p += 2;
                goto disasm_done;
            }
            goto rel32_ok;
        }
        if (pref & PRE_66) {
            hs->flags |= F_IMM16;
            hs->imm.imm16 = *(uint16_t *)p;
            p += 2;
        } else {
            hs->flags |= F_IMM32;
            hs->imm.imm32 = *(uint32_t *)p;
            p += 4;
        }
    }

    if (cflags & C_IMM16) {
        if (hs->flags & F_IMM32) {
            hs->flags |= F_IMM16;
            hs->disp.disp16 = *(uint16_t *)p;
        } else if (hs->flags & F_IMM16) {
            hs->flags |= F_2IMM16;
            hs->disp.disp16 = *(uint16_t *)p;
        } else {
            hs->flags |= F_IMM16;
            hs->imm.imm16 = *(uint16_t *)p;
        }
        p += 2;
    }
    if (cflags & C_IMM8) {
        hs->flags |= F_IMM8;
        hs->imm.imm8 = *p++;
    }

    if (cflags & C_REL32) {
      rel32_ok:
        hs->flags |= F_IMM32 | F_RELATIVE;
        hs->imm.imm32 = *(uint32_t *)p;
        p += 4;
    } else if (cflags & C_REL8) {
        hs->flags |= F_IMM8 | F_RELATIVE;
        hs->imm.imm8 = *p++;
    }

  disasm_done:

    if ((hs->len = (uint8_t)(p-(uint8_t *)code)) > 15) {
        hs->flags |= F_ERROR | F_ERROR_LENGTH;
        hs->len = 15;
    }

    return (unsigned int)hs->len;
}

#endif // defined(_M_IX86) || defined(__i386__)

```

`ac_module/lib/minhook/src/hde/hde32.h`:

```h
/*
 * Hacker Disassembler Engine 32
 * Copyright (c) 2006-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 * hde32.h: C/C++ header file
 *
 */

#ifndef _HDE32_H_
#define _HDE32_H_

/* stdint.h - C99 standard header
 * http://en.wikipedia.org/wiki/stdint.h
 *
 * if your compiler doesn't contain "stdint.h" header (for
 * example, Microsoft Visual C++), you can download file:
 *   http://www.azillionmonkeys.com/qed/pstdint.h
 * and change next line to:
 *   #include "pstdint.h"
 */
#include "pstdint.h"

#define F_MODRM         0x00000001
#define F_SIB           0x00000002
#define F_IMM8          0x00000004
#define F_IMM16         0x00000008
#define F_IMM32         0x00000010
#define F_DISP8         0x00000020
#define F_DISP16        0x00000040
#define F_DISP32        0x00000080
#define F_RELATIVE      0x00000100
#define F_2IMM16        0x00000800
#define F_ERROR         0x00001000
#define F_ERROR_OPCODE  0x00002000
#define F_ERROR_LENGTH  0x00004000
#define F_ERROR_LOCK    0x00008000
#define F_ERROR_OPERAND 0x00010000
#define F_PREFIX_REPNZ  0x01000000
#define F_PREFIX_REPX   0x02000000
#define F_PREFIX_REP    0x03000000
#define F_PREFIX_66     0x04000000
#define F_PREFIX_67     0x08000000
#define F_PREFIX_LOCK   0x10000000
#define F_PREFIX_SEG    0x20000000
#define F_PREFIX_ANY    0x3f000000

#define PREFIX_SEGMENT_CS   0x2e
#define PREFIX_SEGMENT_SS   0x36
#define PREFIX_SEGMENT_DS   0x3e
#define PREFIX_SEGMENT_ES   0x26
#define PREFIX_SEGMENT_FS   0x64
#define PREFIX_SEGMENT_GS   0x65
#define PREFIX_LOCK         0xf0
#define PREFIX_REPNZ        0xf2
#define PREFIX_REPX         0xf3
#define PREFIX_OPERAND_SIZE 0x66
#define PREFIX_ADDRESS_SIZE 0x67

#pragma pack(push,1)

typedef struct {
    uint8_t len;
    uint8_t p_rep;
    uint8_t p_lock;
    uint8_t p_seg;
    uint8_t p_66;
    uint8_t p_67;
    uint8_t opcode;
    uint8_t opcode2;
    uint8_t modrm;
    uint8_t modrm_mod;
    uint8_t modrm_reg;
    uint8_t modrm_rm;
    uint8_t sib;
    uint8_t sib_scale;
    uint8_t sib_index;
    uint8_t sib_base;
    union {
        uint8_t imm8;
        uint16_t imm16;
        uint32_t imm32;
    } imm;
    union {
        uint8_t disp8;
        uint16_t disp16;
        uint32_t disp32;
    } disp;
    uint32_t flags;
} hde32s;

#pragma pack(pop)

#ifdef __cplusplus
extern "C" {
#endif

/* __cdecl */
unsigned int hde32_disasm(const void *code, hde32s *hs);

#ifdef __cplusplus
}
#endif

#endif /* _HDE32_H_ */

```

`ac_module/lib/minhook/src/hde/hde64.c`:

```c
/*
 * Hacker Disassembler Engine 64 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#if defined(_M_X64) || defined(__x86_64__)

#include <string.h>
#include "hde64.h"
#include "table64.h"

unsigned int hde64_disasm(const void *code, hde64s *hs)
{
    uint8_t x, c, *p = (uint8_t *)code, cflags, opcode, pref = 0;
    uint8_t *ht = hde64_table, m_mod, m_reg, m_rm, disp_size = 0;
    uint8_t op64 = 0;

    memset(hs, 0, sizeof(hde64s));

    for (x = 16; x; x--)
        switch (c = *p++) {
            case 0xf3:
                hs->p_rep = c;
                pref |= PRE_F3;
                break;
            case 0xf2:
                hs->p_rep = c;
                pref |= PRE_F2;
                break;
            case 0xf0:
                hs->p_lock = c;
                pref |= PRE_LOCK;
                break;
            case 0x26: case 0x2e: case 0x36:
            case 0x3e: case 0x64: case 0x65:
                hs->p_seg = c;
                pref |= PRE_SEG;
                break;
            case 0x66:
                hs->p_66 = c;
                pref |= PRE_66;
                break;
            case 0x67:
                hs->p_67 = c;
                pref |= PRE_67;
                break;
            default:
                goto pref_done;
        }
  pref_done:

    hs->flags = (uint32_t)pref << 23;

    if (!pref)
        pref |= PRE_NONE;

    if ((c & 0xf0) == 0x40) {
        hs->flags |= F_PREFIX_REX;
        if ((hs->rex_w = (c & 0xf) >> 3) && (*p & 0xf8) == 0xb8)
            op64++;
        hs->rex_r = (c & 7) >> 2;
        hs->rex_x = (c & 3) >> 1;
        hs->rex_b = c & 1;
        if (((c = *p++) & 0xf0) == 0x40) {
            opcode = c;
            goto error_opcode;
        }
    }

    if ((hs->opcode = c) == 0x0f) {
        hs->opcode2 = c = *p++;
        ht += DELTA_OPCODES;
    } else if (c >= 0xa0 && c <= 0xa3) {
        op64++;
        if (pref & PRE_67)
            pref |= PRE_66;
        else
            pref &= ~PRE_66;
    }

    opcode = c;
    cflags = ht[ht[opcode / 4] + (opcode % 4)];

    if (cflags == C_ERROR) {
      error_opcode:
        hs->flags |= F_ERROR | F_ERROR_OPCODE;
        cflags = 0;
        if ((opcode & -3) == 0x24)
            cflags++;
    }

    x = 0;
    if (cflags & C_GROUP) {
        uint16_t t;
        t = *(uint16_t *)(ht + (cflags & 0x7f));
        cflags = (uint8_t)t;
        x = (uint8_t)(t >> 8);
    }

    if (hs->opcode2) {
        ht = hde64_table + DELTA_PREFIXES;
        if (ht[ht[opcode / 4] + (opcode % 4)] & pref)
            hs->flags |= F_ERROR | F_ERROR_OPCODE;
    }

    if (cflags & C_MODRM) {
        hs->flags |= F_MODRM;
        hs->modrm = c = *p++;
        hs->modrm_mod = m_mod = c >> 6;
        hs->modrm_rm = m_rm = c & 7;
        hs->modrm_reg = m_reg = (c & 0x3f) >> 3;

        if (x && ((x << m_reg) & 0x80))
            hs->flags |= F_ERROR | F_ERROR_OPCODE;

        if (!hs->opcode2 && opcode >= 0xd9 && opcode <= 0xdf) {
            uint8_t t = opcode - 0xd9;
            if (m_mod == 3) {
                ht = hde64_table + DELTA_FPU_MODRM + t*8;
                t = ht[m_reg] << m_rm;
            } else {
                ht = hde64_table + DELTA_FPU_REG;
                t = ht[t] << m_reg;
            }
            if (t & 0x80)
                hs->flags |= F_ERROR | F_ERROR_OPCODE;
        }

        if (pref & PRE_LOCK) {
            if (m_mod == 3) {
                hs->flags |= F_ERROR | F_ERROR_LOCK;
            } else {
                uint8_t *table_end, op = opcode;
                if (hs->opcode2) {
                    ht = hde64_table + DELTA_OP2_LOCK_OK;
                    table_end = ht + DELTA_OP_ONLY_MEM - DELTA_OP2_LOCK_OK;
                } else {
                    ht = hde64_table + DELTA_OP_LOCK_OK;
                    table_end = ht + DELTA_OP2_LOCK_OK - DELTA_OP_LOCK_OK;
                    op &= -2;
                }
                for (; ht != table_end; ht++)
                    if (*ht++ == op) {
                        if (!((*ht << m_reg) & 0x80))
                            goto no_lock_error;
                        else
                            break;
                    }
                hs->flags |= F_ERROR | F_ERROR_LOCK;
              no_lock_error:
                ;
            }
        }

        if (hs->opcode2) {
            switch (opcode) {
                case 0x20: case 0x22:
                    m_mod = 3;
                    if (m_reg > 4 || m_reg == 1)
                        goto error_operand;
                    else
                        goto no_error_operand;
                case 0x21: case 0x23:
                    m_mod = 3;
                    if (m_reg == 4 || m_reg == 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
            }
        } else {
            switch (opcode) {
                case 0x8c:
                    if (m_reg > 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
                case 0x8e:
                    if (m_reg == 1 || m_reg > 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
            }
        }

        if (m_mod == 3) {
            uint8_t *table_end;
            if (hs->opcode2) {
                ht = hde64_table + DELTA_OP2_ONLY_MEM;
                table_end = ht + sizeof(hde64_table) - DELTA_OP2_ONLY_MEM;
            } else {
                ht = hde64_table + DELTA_OP_ONLY_MEM;
                table_end = ht + DELTA_OP2_ONLY_MEM - DELTA_OP_ONLY_MEM;
            }
            for (; ht != table_end; ht += 2)
                if (*ht++ == opcode) {
                    if ((*ht++ & pref) && !((*ht << m_reg) & 0x80))
                        goto error_operand;
                    else
                        break;
                }
            goto no_error_operand;
        } else if (hs->opcode2) {
            switch (opcode) {
                case 0x50: case 0xd7: case 0xf7:
                    if (pref & (PRE_NONE | PRE_66))
                        goto error_operand;
                    break;
                case 0xd6:
                    if (pref & (PRE_F2 | PRE_F3))
                        goto error_operand;
                    break;
                case 0xc5:
                    goto error_operand;
            }
            goto no_error_operand;
        } else
            goto no_error_operand;

      error_operand:
        hs->flags |= F_ERROR | F_ERROR_OPERAND;
      no_error_operand:

        c = *p++;
        if (m_reg <= 1) {
            if (opcode == 0xf6)
                cflags |= C_IMM8;
            else if (opcode == 0xf7)
                cflags |= C_IMM_P66;
        }

        switch (m_mod) {
            case 0:
                if (pref & PRE_67) {
                    if (m_rm == 6)
                        disp_size = 2;
                } else
                    if (m_rm == 5)
                        disp_size = 4;
                break;
            case 1:
                disp_size = 1;
                break;
            case 2:
                disp_size = 2;
                if (!(pref & PRE_67))
                    disp_size <<= 1;
                break;
        }

        if (m_mod != 3 && m_rm == 4) {
            hs->flags |= F_SIB;
            p++;
            hs->sib = c;
            hs->sib_scale = c >> 6;
            hs->sib_index = (c & 0x3f) >> 3;
            if ((hs->sib_base = c & 7) == 5 && !(m_mod & 1))
                disp_size = 4;
        }

        p--;
        switch (disp_size) {
            case 1:
                hs->flags |= F_DISP8;
                hs->disp.disp8 = *p;
                break;
            case 2:
                hs->flags |= F_DISP16;
                hs->disp.disp16 = *(uint16_t *)p;
                break;
            case 4:
                hs->flags |= F_DISP32;
                hs->disp.disp32 = *(uint32_t *)p;
                break;
        }
        p += disp_size;
    } else if (pref & PRE_LOCK)
        hs->flags |= F_ERROR | F_ERROR_LOCK;

    if (cflags & C_IMM_P66) {
        if (cflags & C_REL32) {
            if (pref & PRE_66) {
                hs->flags |= F_IMM16 | F_RELATIVE;
                hs->imm.imm16 = *(uint16_t *)p;
                p += 2;
                goto disasm_done;
            }
            goto rel32_ok;
        }
        if (op64) {
            hs->flags |= F_IMM64;
            hs->imm.imm64 = *(uint64_t *)p;
            p += 8;
        } else if (!(pref & PRE_66)) {
            hs->flags |= F_IMM32;
            hs->imm.imm32 = *(uint32_t *)p;
            p += 4;
        } else
            goto imm16_ok;
    }


    if (cflags & C_IMM16) {
      imm16_ok:
        hs->flags |= F_IMM16;
        hs->imm.imm16 = *(uint16_t *)p;
        p += 2;
    }
    if (cflags & C_IMM8) {
        hs->flags |= F_IMM8;
        hs->imm.imm8 = *p++;
    }

    if (cflags & C_REL32) {
      rel32_ok:
        hs->flags |= F_IMM32 | F_RELATIVE;
        hs->imm.imm32 = *(uint32_t *)p;
        p += 4;
    } else if (cflags & C_REL8) {
        hs->flags |= F_IMM8 | F_RELATIVE;
        hs->imm.imm8 = *p++;
    }

  disasm_done:

    if ((hs->len = (uint8_t)(p-(uint8_t *)code)) > 15) {
        hs->flags |= F_ERROR | F_ERROR_LENGTH;
        hs->len = 15;
    }

    return (unsigned int)hs->len;
}

#endif // defined(_M_X64) || defined(__x86_64__)

```

`ac_module/lib/minhook/src/hde/hde64.h`:

```h
/*
 * Hacker Disassembler Engine 64
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 * hde64.h: C/C++ header file
 *
 */

#ifndef _HDE64_H_
#define _HDE64_H_

/* stdint.h - C99 standard header
 * http://en.wikipedia.org/wiki/stdint.h
 *
 * if your compiler doesn't contain "stdint.h" header (for
 * example, Microsoft Visual C++), you can download file:
 *   http://www.azillionmonkeys.com/qed/pstdint.h
 * and change next line to:
 *   #include "pstdint.h"
 */
#include "pstdint.h"

#define F_MODRM         0x00000001
#define F_SIB           0x00000002
#define F_IMM8          0x00000004
#define F_IMM16         0x00000008
#define F_IMM32         0x00000010
#define F_IMM64         0x00000020
#define F_DISP8         0x00000040
#define F_DISP16        0x00000080
#define F_DISP32        0x00000100
#define F_RELATIVE      0x00000200
#define F_ERROR         0x00001000
#define F_ERROR_OPCODE  0x00002000
#define F_ERROR_LENGTH  0x00004000
#define F_ERROR_LOCK    0x00008000
#define F_ERROR_OPERAND 0x00010000
#define F_PREFIX_REPNZ  0x01000000
#define F_PREFIX_REPX   0x02000000
#define F_PREFIX_REP    0x03000000
#define F_PREFIX_66     0x04000000
#define F_PREFIX_67     0x08000000
#define F_PREFIX_LOCK   0x10000000
#define F_PREFIX_SEG    0x20000000
#define F_PREFIX_REX    0x40000000
#define F_PREFIX_ANY    0x7f000000

#define PREFIX_SEGMENT_CS   0x2e
#define PREFIX_SEGMENT_SS   0x36
#define PREFIX_SEGMENT_DS   0x3e
#define PREFIX_SEGMENT_ES   0x26
#define PREFIX_SEGMENT_FS   0x64
#define PREFIX_SEGMENT_GS   0x65
#define PREFIX_LOCK         0xf0
#define PREFIX_REPNZ        0xf2
#define PREFIX_REPX         0xf3
#define PREFIX_OPERAND_SIZE 0x66
#define PREFIX_ADDRESS_SIZE 0x67

#pragma pack(push,1)

typedef struct {
    uint8_t len;
    uint8_t p_rep;
    uint8_t p_lock;
    uint8_t p_seg;
    uint8_t p_66;
    uint8_t p_67;
    uint8_t rex;
    uint8_t rex_w;
    uint8_t rex_r;
    uint8_t rex_x;
    uint8_t rex_b;
    uint8_t opcode;
    uint8_t opcode2;
    uint8_t modrm;
    uint8_t modrm_mod;
    uint8_t modrm_reg;
    uint8_t modrm_rm;
    uint8_t sib;
    uint8_t sib_scale;
    uint8_t sib_index;
    uint8_t sib_base;
    union {
        uint8_t imm8;
        uint16_t imm16;
        uint32_t imm32;
        uint64_t imm64;
    } imm;
    union {
        uint8_t disp8;
        uint16_t disp16;
        uint32_t disp32;
    } disp;
    uint32_t flags;
} hde64s;

#pragma pack(pop)

#ifdef __cplusplus
extern "C" {
#endif

/* __cdecl */
unsigned int hde64_disasm(const void *code, hde64s *hs);

#ifdef __cplusplus
}
#endif

#endif /* _HDE64_H_ */

```

`ac_module/lib/minhook/src/hde/pstdint.h`:

```h
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu. All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#pragma once

#include <windows.h>

// Integer types for HDE.
typedef INT8   int8_t;
typedef INT16  int16_t;
typedef INT32  int32_t;
typedef INT64  int64_t;
typedef UINT8  uint8_t;
typedef UINT16 uint16_t;
typedef UINT32 uint32_t;
typedef UINT64 uint64_t;

```

`ac_module/lib/minhook/src/hde/table32.h`:

```h
/*
 * Hacker Disassembler Engine 32 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#define C_NONE    0x00
#define C_MODRM   0x01
#define C_IMM8    0x02
#define C_IMM16   0x04
#define C_IMM_P66 0x10
#define C_REL8    0x20
#define C_REL32   0x40
#define C_GROUP   0x80
#define C_ERROR   0xff

#define PRE_ANY  0x00
#define PRE_NONE 0x01
#define PRE_F2   0x02
#define PRE_F3   0x04
#define PRE_66   0x08
#define PRE_67   0x10
#define PRE_LOCK 0x20
#define PRE_SEG  0x40
#define PRE_ALL  0xff

#define DELTA_OPCODES      0x4a
#define DELTA_FPU_REG      0xf1
#define DELTA_FPU_MODRM    0xf8
#define DELTA_PREFIXES     0x130
#define DELTA_OP_LOCK_OK   0x1a1
#define DELTA_OP2_LOCK_OK  0x1b9
#define DELTA_OP_ONLY_MEM  0x1cb
#define DELTA_OP2_ONLY_MEM 0x1da

unsigned char hde32_table[] = {
  0xa3,0xa8,0xa3,0xa8,0xa3,0xa8,0xa3,0xa8,0xa3,0xa8,0xa3,0xa8,0xa3,0xa8,0xa3,
  0xa8,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xac,0xaa,0xb2,0xaa,0x9f,0x9f,
  0x9f,0x9f,0xb5,0xa3,0xa3,0xa4,0xaa,0xaa,0xba,0xaa,0x96,0xaa,0xa8,0xaa,0xc3,
  0xc3,0x96,0x96,0xb7,0xae,0xd6,0xbd,0xa3,0xc5,0xa3,0xa3,0x9f,0xc3,0x9c,0xaa,
  0xaa,0xac,0xaa,0xbf,0x03,0x7f,0x11,0x7f,0x01,0x7f,0x01,0x3f,0x01,0x01,0x90,
  0x82,0x7d,0x97,0x59,0x59,0x59,0x59,0x59,0x7f,0x59,0x59,0x60,0x7d,0x7f,0x7f,
  0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x9a,0x88,0x7d,
  0x59,0x50,0x50,0x50,0x50,0x59,0x59,0x59,0x59,0x61,0x94,0x61,0x9e,0x59,0x59,
  0x85,0x59,0x92,0xa3,0x60,0x60,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,
  0x59,0x59,0x9f,0x01,0x03,0x01,0x04,0x03,0xd5,0x03,0xcc,0x01,0xbc,0x03,0xf0,
  0x10,0x10,0x10,0x10,0x50,0x50,0x50,0x50,0x14,0x20,0x20,0x20,0x20,0x01,0x01,
  0x01,0x01,0xc4,0x02,0x10,0x00,0x00,0x00,0x00,0x01,0x01,0xc0,0xc2,0x10,0x11,
  0x02,0x03,0x11,0x03,0x03,0x04,0x00,0x00,0x14,0x00,0x02,0x00,0x00,0xc6,0xc8,
  0x02,0x02,0x02,0x02,0x00,0x00,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0xff,0xca,
  0x01,0x01,0x01,0x00,0x06,0x00,0x04,0x00,0xc0,0xc2,0x01,0x01,0x03,0x01,0xff,
  0xff,0x01,0x00,0x03,0xc4,0xc4,0xc6,0x03,0x01,0x01,0x01,0xff,0x03,0x03,0x03,
  0xc8,0x40,0x00,0x0a,0x00,0x04,0x00,0x00,0x00,0x00,0x7f,0x00,0x33,0x01,0x00,
  0x00,0x00,0x00,0x00,0x00,0xff,0xbf,0xff,0xff,0x00,0x00,0x00,0x00,0x07,0x00,
  0x00,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0xff,0xff,0x00,0x00,0x00,0xbf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x7f,0x00,0x00,0xff,0x4a,0x4a,0x4a,0x4a,0x4b,0x52,0x4a,0x4a,0x4a,0x4a,0x4f,
  0x4c,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x55,0x45,0x40,0x4a,0x4a,0x4a,
  0x45,0x59,0x4d,0x46,0x4a,0x5d,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,
  0x4a,0x4a,0x4a,0x4a,0x4a,0x61,0x63,0x67,0x4e,0x4a,0x4a,0x6b,0x6d,0x4a,0x4a,
  0x45,0x6d,0x4a,0x4a,0x44,0x45,0x4a,0x4a,0x00,0x00,0x00,0x02,0x0d,0x06,0x06,
  0x06,0x06,0x0e,0x00,0x00,0x00,0x00,0x06,0x06,0x06,0x00,0x06,0x06,0x02,0x06,
  0x00,0x0a,0x0a,0x07,0x07,0x06,0x02,0x05,0x05,0x02,0x02,0x00,0x00,0x04,0x04,
  0x04,0x04,0x00,0x00,0x00,0x0e,0x05,0x06,0x06,0x06,0x01,0x06,0x00,0x00,0x08,
  0x00,0x10,0x00,0x18,0x00,0x20,0x00,0x28,0x00,0x30,0x00,0x80,0x01,0x82,0x01,
  0x86,0x00,0xf6,0xcf,0xfe,0x3f,0xab,0x00,0xb0,0x00,0xb1,0x00,0xb3,0x00,0xba,
  0xf8,0xbb,0x00,0xc0,0x00,0xc1,0x00,0xc7,0xbf,0x62,0xff,0x00,0x8d,0xff,0x00,
  0xc4,0xff,0x00,0xc5,0xff,0x00,0xff,0xff,0xeb,0x01,0xff,0x0e,0x12,0x08,0x00,
  0x13,0x09,0x00,0x16,0x08,0x00,0x17,0x09,0x00,0x2b,0x09,0x00,0xae,0xff,0x07,
  0xb2,0xff,0x00,0xb4,0xff,0x00,0xb5,0xff,0x00,0xc3,0x01,0x00,0xc7,0xff,0xbf,
  0xe7,0x08,0x00,0xf0,0x02,0x00
};

```

`ac_module/lib/minhook/src/hde/table64.h`:

```h
/*
 * Hacker Disassembler Engine 64 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#define C_NONE    0x00
#define C_MODRM   0x01
#define C_IMM8    0x02
#define C_IMM16   0x04
#define C_IMM_P66 0x10
#define C_REL8    0x20
#define C_REL32   0x40
#define C_GROUP   0x80
#define C_ERROR   0xff

#define PRE_ANY  0x00
#define PRE_NONE 0x01
#define PRE_F2   0x02
#define PRE_F3   0x04
#define PRE_66   0x08
#define PRE_67   0x10
#define PRE_LOCK 0x20
#define PRE_SEG  0x40
#define PRE_ALL  0xff

#define DELTA_OPCODES      0x4a
#define DELTA_FPU_REG      0xfd
#define DELTA_FPU_MODRM    0x104
#define DELTA_PREFIXES     0x13c
#define DELTA_OP_LOCK_OK   0x1ae
#define DELTA_OP2_LOCK_OK  0x1c6
#define DELTA_OP_ONLY_MEM  0x1d8
#define DELTA_OP2_ONLY_MEM 0x1e7

unsigned char hde64_table[] = {
  0xa5,0xaa,0xa5,0xb8,0xa5,0xaa,0xa5,0xaa,0xa5,0xb8,0xa5,0xb8,0xa5,0xb8,0xa5,
  0xb8,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xac,0xc0,0xcc,0xc0,0xa1,0xa1,
  0xa1,0xa1,0xb1,0xa5,0xa5,0xa6,0xc0,0xc0,0xd7,0xda,0xe0,0xc0,0xe4,0xc0,0xea,
  0xea,0xe0,0xe0,0x98,0xc8,0xee,0xf1,0xa5,0xd3,0xa5,0xa5,0xa1,0xea,0x9e,0xc0,
  0xc0,0xc2,0xc0,0xe6,0x03,0x7f,0x11,0x7f,0x01,0x7f,0x01,0x3f,0x01,0x01,0xab,
  0x8b,0x90,0x64,0x5b,0x5b,0x5b,0x5b,0x5b,0x92,0x5b,0x5b,0x76,0x90,0x92,0x92,
  0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x6a,0x73,0x90,
  0x5b,0x52,0x52,0x52,0x52,0x5b,0x5b,0x5b,0x5b,0x77,0x7c,0x77,0x85,0x5b,0x5b,
  0x70,0x5b,0x7a,0xaf,0x76,0x76,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,
  0x5b,0x5b,0x86,0x01,0x03,0x01,0x04,0x03,0xd5,0x03,0xd5,0x03,0xcc,0x01,0xbc,
  0x03,0xf0,0x03,0x03,0x04,0x00,0x50,0x50,0x50,0x50,0xff,0x20,0x20,0x20,0x20,
  0x01,0x01,0x01,0x01,0xc4,0x02,0x10,0xff,0xff,0xff,0x01,0x00,0x03,0x11,0xff,
  0x03,0xc4,0xc6,0xc8,0x02,0x10,0x00,0xff,0xcc,0x01,0x01,0x01,0x00,0x00,0x00,
  0x00,0x01,0x01,0x03,0x01,0xff,0xff,0xc0,0xc2,0x10,0x11,0x02,0x03,0x01,0x01,
  0x01,0xff,0xff,0xff,0x00,0x00,0x00,0xff,0x00,0x00,0xff,0xff,0xff,0xff,0x10,
  0x10,0x10,0x10,0x02,0x10,0x00,0x00,0xc6,0xc8,0x02,0x02,0x02,0x02,0x06,0x00,
  0x04,0x00,0x02,0xff,0x00,0xc0,0xc2,0x01,0x01,0x03,0x03,0x03,0xca,0x40,0x00,
  0x0a,0x00,0x04,0x00,0x00,0x00,0x00,0x7f,0x00,0x33,0x01,0x00,0x00,0x00,0x00,
  0x00,0x00,0xff,0xbf,0xff,0xff,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0xff,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,
  0x00,0x00,0x00,0xbf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7f,0x00,0x00,
  0xff,0x40,0x40,0x40,0x40,0x41,0x49,0x40,0x40,0x40,0x40,0x4c,0x42,0x40,0x40,
  0x40,0x40,0x40,0x40,0x40,0x40,0x4f,0x44,0x53,0x40,0x40,0x40,0x44,0x57,0x43,
  0x5c,0x40,0x60,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,
  0x40,0x40,0x64,0x66,0x6e,0x6b,0x40,0x40,0x6a,0x46,0x40,0x40,0x44,0x46,0x40,
  0x40,0x5b,0x44,0x40,0x40,0x00,0x00,0x00,0x00,0x06,0x06,0x06,0x06,0x01,0x06,
  0x06,0x02,0x06,0x06,0x00,0x06,0x00,0x0a,0x0a,0x00,0x00,0x00,0x02,0x07,0x07,
  0x06,0x02,0x0d,0x06,0x06,0x06,0x0e,0x05,0x05,0x02,0x02,0x00,0x00,0x04,0x04,
  0x04,0x04,0x05,0x06,0x06,0x06,0x00,0x00,0x00,0x0e,0x00,0x00,0x08,0x00,0x10,
  0x00,0x18,0x00,0x20,0x00,0x28,0x00,0x30,0x00,0x80,0x01,0x82,0x01,0x86,0x00,
  0xf6,0xcf,0xfe,0x3f,0xab,0x00,0xb0,0x00,0xb1,0x00,0xb3,0x00,0xba,0xf8,0xbb,
  0x00,0xc0,0x00,0xc1,0x00,0xc7,0xbf,0x62,0xff,0x00,0x8d,0xff,0x00,0xc4,0xff,
  0x00,0xc5,0xff,0x00,0xff,0xff,0xeb,0x01,0xff,0x0e,0x12,0x08,0x00,0x13,0x09,
  0x00,0x16,0x08,0x00,0x17,0x09,0x00,0x2b,0x09,0x00,0xae,0xff,0x07,0xb2,0xff,
  0x00,0xb4,0xff,0x00,0xb5,0xff,0x00,0xc3,0x01,0x00,0xc7,0xff,0xbf,0xe7,0x08,
  0x00,0xf0,0x02,0x00
};

```

`ac_module/lib/minhook/src/hook.c`:

```c
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <windows.h>
#include <tlhelp32.h>
#include <limits.h>

#include "../include/MinHook.h"
#include "buffer.h"
#include "trampoline.h"

#ifndef ARRAYSIZE
    #define ARRAYSIZE(A) (sizeof(A)/sizeof((A)[0]))
#endif

// Initial capacity of the HOOK_ENTRY buffer.
#define INITIAL_HOOK_CAPACITY   32

// Initial capacity of the thread IDs buffer.
#define INITIAL_THREAD_CAPACITY 128

// Special hook position values.
#define INVALID_HOOK_POS UINT_MAX
#define ALL_HOOKS_POS    UINT_MAX

// Freeze() action argument defines.
#define ACTION_DISABLE      0
#define ACTION_ENABLE       1
#define ACTION_APPLY_QUEUED 2

// Thread access rights for suspending/resuming threads.
#define THREAD_ACCESS \
    (THREAD_SUSPEND_RESUME | THREAD_GET_CONTEXT | THREAD_QUERY_INFORMATION | THREAD_SET_CONTEXT)

// Hook information.
typedef struct _HOOK_ENTRY
{
    LPVOID pTarget;             // Address of the target function.
    LPVOID pDetour;             // Address of the detour or relay function.
    LPVOID pTrampoline;         // Address of the trampoline function.
    UINT8  backup[8];           // Original prologue of the target function.

    UINT8  patchAbove  : 1;     // Uses the hot patch area.
    UINT8  isEnabled   : 1;     // Enabled.
    UINT8  queueEnable : 1;     // Queued for enabling/disabling when != isEnabled.

    UINT   nIP : 4;             // Count of the instruction boundaries.
    UINT8  oldIPs[8];           // Instruction boundaries of the target function.
    UINT8  newIPs[8];           // Instruction boundaries of the trampoline function.
} HOOK_ENTRY, *PHOOK_ENTRY;

// Suspended threads for Freeze()/Unfreeze().
typedef struct _FROZEN_THREADS
{
    LPDWORD pItems;         // Data heap
    UINT    capacity;       // Size of allocated data heap, items
    UINT    size;           // Actual number of data items
} FROZEN_THREADS, *PFROZEN_THREADS;

//-------------------------------------------------------------------------
// Global Variables:
//-------------------------------------------------------------------------

// Spin lock flag for EnterSpinLock()/LeaveSpinLock().
volatile LONG g_isLocked = FALSE;

// Private heap handle. If not NULL, this library is initialized.
HANDLE g_hHeap = NULL;

// Hook entries.
struct
{
    PHOOK_ENTRY pItems;     // Data heap
    UINT        capacity;   // Size of allocated data heap, items
    UINT        size;       // Actual number of data items
} g_hooks;

//-------------------------------------------------------------------------
// Returns INVALID_HOOK_POS if not found.
static UINT FindHookEntry(LPVOID pTarget)
{
    UINT i;
    for (i = 0; i < g_hooks.size; ++i)
    {
        if ((ULONG_PTR)pTarget == (ULONG_PTR)g_hooks.pItems[i].pTarget)
            return i;
    }

    return INVALID_HOOK_POS;
}

//-------------------------------------------------------------------------
static PHOOK_ENTRY AddHookEntry()
{
    if (g_hooks.pItems == NULL)
    {
        g_hooks.capacity = INITIAL_HOOK_CAPACITY;
        g_hooks.pItems = (PHOOK_ENTRY)HeapAlloc(
            g_hHeap, 0, g_hooks.capacity * sizeof(HOOK_ENTRY));
        if (g_hooks.pItems == NULL)
            return NULL;
    }
    else if (g_hooks.size >= g_hooks.capacity)
    {
        PHOOK_ENTRY p = (PHOOK_ENTRY)HeapReAlloc(
            g_hHeap, 0, g_hooks.pItems, (g_hooks.capacity * 2) * sizeof(HOOK_ENTRY));
        if (p == NULL)
            return NULL;

        g_hooks.capacity *= 2;
        g_hooks.pItems = p;
    }

    return &g_hooks.pItems[g_hooks.size++];
}

//-------------------------------------------------------------------------
static VOID DeleteHookEntry(UINT pos)
{
    if (pos < g_hooks.size - 1)
        g_hooks.pItems[pos] = g_hooks.pItems[g_hooks.size - 1];

    g_hooks.size--;

    if (g_hooks.capacity / 2 >= INITIAL_HOOK_CAPACITY && g_hooks.capacity / 2 >= g_hooks.size)
    {
        PHOOK_ENTRY p = (PHOOK_ENTRY)HeapReAlloc(
            g_hHeap, 0, g_hooks.pItems, (g_hooks.capacity / 2) * sizeof(HOOK_ENTRY));
        if (p == NULL)
            return;

        g_hooks.capacity /= 2;
        g_hooks.pItems = p;
    }
}

//-------------------------------------------------------------------------
static DWORD_PTR FindOldIP(PHOOK_ENTRY pHook, DWORD_PTR ip)
{
    UINT i;

    if (pHook->patchAbove && ip == ((DWORD_PTR)pHook->pTarget - sizeof(JMP_REL)))
        return (DWORD_PTR)pHook->pTarget;

    for (i = 0; i < pHook->nIP; ++i)
    {
        if (ip == ((DWORD_PTR)pHook->pTrampoline + pHook->newIPs[i]))
            return (DWORD_PTR)pHook->pTarget + pHook->oldIPs[i];
    }

#if defined(_M_X64) || defined(__x86_64__)
    // Check relay function.
    if (ip == (DWORD_PTR)pHook->pDetour)
        return (DWORD_PTR)pHook->pTarget;
#endif

    return 0;
}

//-------------------------------------------------------------------------
static DWORD_PTR FindNewIP(PHOOK_ENTRY pHook, DWORD_PTR ip)
{
    UINT i;
    for (i = 0; i < pHook->nIP; ++i)
    {
        if (ip == ((DWORD_PTR)pHook->pTarget + pHook->oldIPs[i]))
            return (DWORD_PTR)pHook->pTrampoline + pHook->newIPs[i];
    }

    return 0;
}

//-------------------------------------------------------------------------
static VOID ProcessThreadIPs(HANDLE hThread, UINT pos, UINT action)
{
    // If the thread suspended in the overwritten area,
    // move IP to the proper address.

    CONTEXT c;
#if defined(_M_X64) || defined(__x86_64__)
    DWORD64 *pIP = &c.Rip;
#else
    DWORD   *pIP = &c.Eip;
#endif
    UINT count;

    c.ContextFlags = CONTEXT_CONTROL;
    if (!GetThreadContext(hThread, &c))
        return;

    if (pos == ALL_HOOKS_POS)
    {
        pos = 0;
        count = g_hooks.size;
    }
    else
    {
        count = pos + 1;
    }

    for (; pos < count; ++pos)
    {
        PHOOK_ENTRY pHook = &g_hooks.pItems[pos];
        BOOL        enable;
        DWORD_PTR   ip;

        switch (action)
        {
        case ACTION_DISABLE:
            enable = FALSE;
            break;

        case ACTION_ENABLE:
            enable = TRUE;
            break;

        default: // ACTION_APPLY_QUEUED
            enable = pHook->queueEnable;
            break;
        }
        if (pHook->isEnabled == enable)
            continue;

        if (enable)
            ip = FindNewIP(pHook, *pIP);
        else
            ip = FindOldIP(pHook, *pIP);

        if (ip != 0)
        {
            *pIP = ip;
            SetThreadContext(hThread, &c);
        }
    }
}

//-------------------------------------------------------------------------
static BOOL EnumerateThreads(PFROZEN_THREADS pThreads)
{
    BOOL succeeded = FALSE;

    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
    if (hSnapshot != INVALID_HANDLE_VALUE)
    {
        THREADENTRY32 te;
        te.dwSize = sizeof(THREADENTRY32);
        if (Thread32First(hSnapshot, &te))
        {
            succeeded = TRUE;
            do
            {
                if (te.dwSize >= (FIELD_OFFSET(THREADENTRY32, th32OwnerProcessID) + sizeof(DWORD))
                    && te.th32OwnerProcessID == GetCurrentProcessId()
                    && te.th32ThreadID != GetCurrentThreadId())
                {
                    if (pThreads->pItems == NULL)
                    {
                        pThreads->capacity = INITIAL_THREAD_CAPACITY;
                        pThreads->pItems
                            = (LPDWORD)HeapAlloc(g_hHeap, 0, pThreads->capacity * sizeof(DWORD));
                        if (pThreads->pItems == NULL)
                        {
                            succeeded = FALSE;
                            break;
                        }
                    }
                    else if (pThreads->size >= pThreads->capacity)
                    {
                        pThreads->capacity *= 2;
                        LPDWORD p = (LPDWORD)HeapReAlloc(
                            g_hHeap, 0, pThreads->pItems, pThreads->capacity * sizeof(DWORD));
                        if (p == NULL)
                        {
                            succeeded = FALSE;
                            break;
                        }

                        pThreads->pItems = p;
                    }
                    pThreads->pItems[pThreads->size++] = te.th32ThreadID;
                }

                te.dwSize = sizeof(THREADENTRY32);
            } while (Thread32Next(hSnapshot, &te));

            if (succeeded && GetLastError() != ERROR_NO_MORE_FILES)
                succeeded = FALSE;

            if (!succeeded && pThreads->pItems != NULL)
            {
                HeapFree(g_hHeap, 0, pThreads->pItems);
                pThreads->pItems = NULL;
            }
        }
        CloseHandle(hSnapshot);
    }

    return succeeded;
}

//-------------------------------------------------------------------------
static MH_STATUS Freeze(PFROZEN_THREADS pThreads, UINT pos, UINT action)
{
    MH_STATUS status = MH_OK;

    pThreads->pItems   = NULL;
    pThreads->capacity = 0;
    pThreads->size     = 0;
    if (!EnumerateThreads(pThreads))
    {
        status = MH_ERROR_MEMORY_ALLOC;
    }
    else if (pThreads->pItems != NULL)
    {
        UINT i;
        for (i = 0; i < pThreads->size; ++i)
        {
            HANDLE hThread = OpenThread(THREAD_ACCESS, FALSE, pThreads->pItems[i]);
            if (hThread != NULL)
            {
                SuspendThread(hThread);
                ProcessThreadIPs(hThread, pos, action);
                CloseHandle(hThread);
            }
        }
    }

    return status;
}

//-------------------------------------------------------------------------
static VOID Unfreeze(PFROZEN_THREADS pThreads)
{
    if (pThreads->pItems != NULL)
    {
        UINT i;
        for (i = 0; i < pThreads->size; ++i)
        {
            HANDLE hThread = OpenThread(THREAD_ACCESS, FALSE, pThreads->pItems[i]);
            if (hThread != NULL)
            {
                ResumeThread(hThread);
                CloseHandle(hThread);
            }
        }

        HeapFree(g_hHeap, 0, pThreads->pItems);
    }
}

//-------------------------------------------------------------------------
static MH_STATUS EnableHookLL(UINT pos, BOOL enable)
{
    PHOOK_ENTRY pHook = &g_hooks.pItems[pos];
    DWORD  oldProtect;
    SIZE_T patchSize    = sizeof(JMP_REL);
    LPBYTE pPatchTarget = (LPBYTE)pHook->pTarget;

    if (pHook->patchAbove)
    {
        pPatchTarget -= sizeof(JMP_REL);
        patchSize    += sizeof(JMP_REL_SHORT);
    }

    if (!VirtualProtect(pPatchTarget, patchSize, PAGE_EXECUTE_READWRITE, &oldProtect))
        return MH_ERROR_MEMORY_PROTECT;

    if (enable)
    {
        PJMP_REL pJmp = (PJMP_REL)pPatchTarget;
        pJmp->opcode = 0xE9;
        pJmp->operand = (UINT32)((LPBYTE)pHook->pDetour - (pPatchTarget + sizeof(JMP_REL)));

        if (pHook->patchAbove)
        {
            PJMP_REL_SHORT pShortJmp = (PJMP_REL_SHORT)pHook->pTarget;
            pShortJmp->opcode = 0xEB;
            pShortJmp->operand = (UINT8)(0 - (sizeof(JMP_REL_SHORT) + sizeof(JMP_REL)));
        }
    }
    else
    {
        if (pHook->patchAbove)
            memcpy(pPatchTarget, pHook->backup, sizeof(JMP_REL) + sizeof(JMP_REL_SHORT));
        else
            memcpy(pPatchTarget, pHook->backup, sizeof(JMP_REL));
    }

    VirtualProtect(pPatchTarget, patchSize, oldProtect, &oldProtect);

    // Just-in-case measure.
    FlushInstructionCache(GetCurrentProcess(), pPatchTarget, patchSize);

    pHook->isEnabled   = enable;
    pHook->queueEnable = enable;

    return MH_OK;
}

//-------------------------------------------------------------------------
static MH_STATUS EnableAllHooksLL(BOOL enable)
{
    MH_STATUS status = MH_OK;
    UINT i, first = INVALID_HOOK_POS;

    for (i = 0; i < g_hooks.size; ++i)
    {
        if (g_hooks.pItems[i].isEnabled != enable)
        {
            first = i;
            break;
        }
    }

    if (first != INVALID_HOOK_POS)
    {
        FROZEN_THREADS threads;
        status = Freeze(&threads, ALL_HOOKS_POS, enable ? ACTION_ENABLE : ACTION_DISABLE);
        if (status == MH_OK)
        {
            for (i = first; i < g_hooks.size; ++i)
            {
                if (g_hooks.pItems[i].isEnabled != enable)
                {
                    status = EnableHookLL(i, enable);
                    if (status != MH_OK)
                        break;
                }
            }

            Unfreeze(&threads);
        }
    }

    return status;
}

//-------------------------------------------------------------------------
static VOID EnterSpinLock(VOID)
{
    SIZE_T spinCount = 0;

    // Wait until the flag is FALSE.
    while (InterlockedCompareExchange(&g_isLocked, TRUE, FALSE) != FALSE)
    {
        // No need to generate a memory barrier here, since InterlockedCompareExchange()
        // generates a full memory barrier itself.

        // Prevent the loop from being too busy.
        if (spinCount < 32)
            Sleep(0);
        else
            Sleep(1);

        spinCount++;
    }
}

//-------------------------------------------------------------------------
static VOID LeaveSpinLock(VOID)
{
    // No need to generate a memory barrier here, since InterlockedExchange()
    // generates a full memory barrier itself.

    InterlockedExchange(&g_isLocked, FALSE);
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_Initialize(VOID)
{
    MH_STATUS status = MH_OK;

    EnterSpinLock();

    if (g_hHeap == NULL)
    {
        g_hHeap = HeapCreate(0, 0, 0);
        if (g_hHeap != NULL)
        {
            // Initialize the internal function buffer.
            InitializeBuffer();
        }
        else
        {
            status = MH_ERROR_MEMORY_ALLOC;
        }
    }
    else
    {
        status = MH_ERROR_ALREADY_INITIALIZED;
    }

    LeaveSpinLock();

    return status;
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_Uninitialize(VOID)
{
    MH_STATUS status = MH_OK;

    EnterSpinLock();

    if (g_hHeap != NULL)
    {
        status = EnableAllHooksLL(FALSE);
        if (status == MH_OK)
        {
            // Free the internal function buffer.

            // HeapFree is actually not required, but some tools detect a false
            // memory leak without HeapFree.

            UninitializeBuffer();

            HeapFree(g_hHeap, 0, g_hooks.pItems);
            HeapDestroy(g_hHeap);

            g_hHeap = NULL;

            g_hooks.pItems   = NULL;
            g_hooks.capacity = 0;
            g_hooks.size     = 0;
        }
    }
    else
    {
        status = MH_ERROR_NOT_INITIALIZED;
    }

    LeaveSpinLock();

    return status;
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_CreateHook(LPVOID pTarget, LPVOID pDetour, LPVOID *ppOriginal)
{
    MH_STATUS status = MH_OK;

    EnterSpinLock();

    if (g_hHeap != NULL)
    {
        if (IsExecutableAddress(pTarget) && IsExecutableAddress(pDetour))
        {
            UINT pos = FindHookEntry(pTarget);
            if (pos == INVALID_HOOK_POS)
            {
                LPVOID pBuffer = AllocateBuffer(pTarget);
                if (pBuffer != NULL)
                {
                    TRAMPOLINE ct;

                    ct.pTarget     = pTarget;
                    ct.pDetour     = pDetour;
                    ct.pTrampoline = pBuffer;
                    if (CreateTrampolineFunction(&ct))
                    {
                        PHOOK_ENTRY pHook = AddHookEntry();
                        if (pHook != NULL)
                        {
                            pHook->pTarget     = ct.pTarget;
#if defined(_M_X64) || defined(__x86_64__)
                            pHook->pDetour     = ct.pRelay;
#else
                            pHook->pDetour     = ct.pDetour;
#endif
                            pHook->pTrampoline = ct.pTrampoline;
                            pHook->patchAbove  = ct.patchAbove;
                            pHook->isEnabled   = FALSE;
                            pHook->queueEnable = FALSE;
                            pHook->nIP         = ct.nIP;
                            memcpy(pHook->oldIPs, ct.oldIPs, ARRAYSIZE(ct.oldIPs));
                            memcpy(pHook->newIPs, ct.newIPs, ARRAYSIZE(ct.newIPs));

                            // Back up the target function.

                            if (ct.patchAbove)
                            {
                                memcpy(
                                    pHook->backup,
                                    (LPBYTE)pTarget - sizeof(JMP_REL),
                                    sizeof(JMP_REL) + sizeof(JMP_REL_SHORT));
                            }
                            else
                            {
                                memcpy(pHook->backup, pTarget, sizeof(JMP_REL));
                            }

                            if (ppOriginal != NULL)
                                *ppOriginal = pHook->pTrampoline;
                        }
                        else
                        {
                            status = MH_ERROR_MEMORY_ALLOC;
                        }
                    }
                    else
                    {
                        status = MH_ERROR_UNSUPPORTED_FUNCTION;
                    }

                    if (status != MH_OK)
                    {
                        FreeBuffer(pBuffer);
                    }
                }
                else
                {
                    status = MH_ERROR_MEMORY_ALLOC;
                }
            }
            else
            {
                status = MH_ERROR_ALREADY_CREATED;
            }
        }
        else
        {
            status = MH_ERROR_NOT_EXECUTABLE;
        }
    }
    else
    {
        status = MH_ERROR_NOT_INITIALIZED;
    }

    LeaveSpinLock();

    return status;
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_RemoveHook(LPVOID pTarget)
{
    MH_STATUS status = MH_OK;

    EnterSpinLock();

    if (g_hHeap != NULL)
    {
        UINT pos = FindHookEntry(pTarget);
        if (pos != INVALID_HOOK_POS)
        {
            if (g_hooks.pItems[pos].isEnabled)
            {
                FROZEN_THREADS threads;
                status = Freeze(&threads, pos, ACTION_DISABLE);
                if (status == MH_OK)
                {
                    status = EnableHookLL(pos, FALSE);

                    Unfreeze(&threads);
                }
            }

            if (status == MH_OK)
            {
                FreeBuffer(g_hooks.pItems[pos].pTrampoline);
                DeleteHookEntry(pos);
            }
        }
        else
        {
            status = MH_ERROR_NOT_CREATED;
        }
    }
    else
    {
        status = MH_ERROR_NOT_INITIALIZED;
    }

    LeaveSpinLock();

    return status;
}

//-------------------------------------------------------------------------
static MH_STATUS EnableHook(LPVOID pTarget, BOOL enable)
{
    MH_STATUS status = MH_OK;

    EnterSpinLock();

    if (g_hHeap != NULL)
    {
        if (pTarget == MH_ALL_HOOKS)
        {
            status = EnableAllHooksLL(enable);
        }
        else
        {
            UINT pos = FindHookEntry(pTarget);
            if (pos != INVALID_HOOK_POS)
            {
                if (g_hooks.pItems[pos].isEnabled != enable)
                {
                    FROZEN_THREADS threads;
                    status = Freeze(&threads, pos, ACTION_ENABLE);
                    if (status == MH_OK)
                    {
                        status = EnableHookLL(pos, enable);

                        Unfreeze(&threads);
                    }
                }
                else
                {
                    status = enable ? MH_ERROR_ENABLED : MH_ERROR_DISABLED;
                }
            }
            else
            {
                status = MH_ERROR_NOT_CREATED;
            }
        }
    }
    else
    {
        status = MH_ERROR_NOT_INITIALIZED;
    }

    LeaveSpinLock();

    return status;
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_EnableHook(LPVOID pTarget)
{
    return EnableHook(pTarget, TRUE);
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_DisableHook(LPVOID pTarget)
{
    return EnableHook(pTarget, FALSE);
}

//-------------------------------------------------------------------------
static MH_STATUS QueueHook(LPVOID pTarget, BOOL queueEnable)
{
    MH_STATUS status = MH_OK;

    EnterSpinLock();

    if (g_hHeap != NULL)
    {
        if (pTarget == MH_ALL_HOOKS)
        {
            UINT i;
            for (i = 0; i < g_hooks.size; ++i)
                g_hooks.pItems[i].queueEnable = queueEnable;
        }
        else
        {
            UINT pos = FindHookEntry(pTarget);
            if (pos != INVALID_HOOK_POS)
            {
                g_hooks.pItems[pos].queueEnable = queueEnable;
            }
            else
            {
                status = MH_ERROR_NOT_CREATED;
            }
        }
    }
    else
    {
        status = MH_ERROR_NOT_INITIALIZED;
    }

    LeaveSpinLock();

    return status;
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_QueueEnableHook(LPVOID pTarget)
{
    return QueueHook(pTarget, TRUE);
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_QueueDisableHook(LPVOID pTarget)
{
    return QueueHook(pTarget, FALSE);
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_ApplyQueued(VOID)
{
    MH_STATUS status = MH_OK;
    UINT i, first = INVALID_HOOK_POS;

    EnterSpinLock();

    if (g_hHeap != NULL)
    {
        for (i = 0; i < g_hooks.size; ++i)
        {
            if (g_hooks.pItems[i].isEnabled != g_hooks.pItems[i].queueEnable)
            {
                first = i;
                break;
            }
        }

        if (first != INVALID_HOOK_POS)
        {
            FROZEN_THREADS threads;
            status = Freeze(&threads, ALL_HOOKS_POS, ACTION_APPLY_QUEUED);
            if (status == MH_OK)
            {
                for (i = first; i < g_hooks.size; ++i)
                {
                    PHOOK_ENTRY pHook = &g_hooks.pItems[i];
                    if (pHook->isEnabled != pHook->queueEnable)
                    {
                        status = EnableHookLL(i, pHook->queueEnable);
                        if (status != MH_OK)
                            break;
                    }
                }

                Unfreeze(&threads);
            }
        }
    }
    else
    {
        status = MH_ERROR_NOT_INITIALIZED;
    }

    LeaveSpinLock();

    return status;
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_CreateHookApiEx(
    LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour,
    LPVOID *ppOriginal, LPVOID *ppTarget)
{
    HMODULE hModule;
    LPVOID  pTarget;

    hModule = GetModuleHandleW(pszModule);
    if (hModule == NULL)
        return MH_ERROR_MODULE_NOT_FOUND;

    pTarget = (LPVOID)GetProcAddress(hModule, pszProcName);
    if (pTarget == NULL)
        return MH_ERROR_FUNCTION_NOT_FOUND;

    if(ppTarget != NULL)
        *ppTarget = pTarget;

    return MH_CreateHook(pTarget, pDetour, ppOriginal);
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_CreateHookApi(
    LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, LPVOID *ppOriginal)
{
   return MH_CreateHookApiEx(pszModule, pszProcName, pDetour, ppOriginal, NULL);
}

//-------------------------------------------------------------------------
const char * WINAPI MH_StatusToString(MH_STATUS status)
{
#define MH_ST2STR(x)    \
    case x:             \
        return #x;

    switch (status) {
        MH_ST2STR(MH_UNKNOWN)
        MH_ST2STR(MH_OK)
        MH_ST2STR(MH_ERROR_ALREADY_INITIALIZED)
        MH_ST2STR(MH_ERROR_NOT_INITIALIZED)
        MH_ST2STR(MH_ERROR_ALREADY_CREATED)
        MH_ST2STR(MH_ERROR_NOT_CREATED)
        MH_ST2STR(MH_ERROR_ENABLED)
        MH_ST2STR(MH_ERROR_DISABLED)
        MH_ST2STR(MH_ERROR_NOT_EXECUTABLE)
        MH_ST2STR(MH_ERROR_UNSUPPORTED_FUNCTION)
        MH_ST2STR(MH_ERROR_MEMORY_ALLOC)
        MH_ST2STR(MH_ERROR_MEMORY_PROTECT)
        MH_ST2STR(MH_ERROR_MODULE_NOT_FOUND)
        MH_ST2STR(MH_ERROR_FUNCTION_NOT_FOUND)
    }

#undef MH_ST2STR

    return "(unknown)";
}

```

`ac_module/lib/minhook/src/trampoline.c`:

```c
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <windows.h>

#ifdef _MSC_VER
    #include <intrin.h>
#endif

#ifndef ARRAYSIZE
    #define ARRAYSIZE(A) (sizeof(A)/sizeof((A)[0]))
#endif

#if defined(_M_X64) || defined(__x86_64__)
    #include "./hde/hde64.h"
    typedef hde64s HDE;
    #define HDE_DISASM(code, hs) hde64_disasm(code, hs)
#else
    #include "./hde/hde32.h"
    typedef hde32s HDE;
    #define HDE_DISASM(code, hs) hde32_disasm(code, hs)
#endif

#include "trampoline.h"
#include "buffer.h"

// Maximum size of a trampoline function.
#if defined(_M_X64) || defined(__x86_64__)
    #define TRAMPOLINE_MAX_SIZE (MEMORY_SLOT_SIZE - sizeof(JMP_ABS))
#else
    #define TRAMPOLINE_MAX_SIZE MEMORY_SLOT_SIZE
#endif

//-------------------------------------------------------------------------
static BOOL IsCodePadding(LPBYTE pInst, UINT size)
{
    UINT i;

    if (pInst[0] != 0x00 && pInst[0] != 0x90 && pInst[0] != 0xCC)
        return FALSE;

    for (i = 1; i < size; ++i)
    {
        if (pInst[i] != pInst[0])
            return FALSE;
    }
    return TRUE;
}

//-------------------------------------------------------------------------
BOOL CreateTrampolineFunction(PTRAMPOLINE ct)
{
#if defined(_M_X64) || defined(__x86_64__)
    CALL_ABS call = {
        0xFF, 0x15, 0x00000002, // FF15 00000002: CALL [RIP+8]
        0xEB, 0x08,             // EB 08:         JMP +10
        0x0000000000000000ULL   // Absolute destination address
    };
    JMP_ABS jmp = {
        0xFF, 0x25, 0x00000000, // FF25 00000000: JMP [RIP+6]
        0x0000000000000000ULL   // Absolute destination address
    };
    JCC_ABS jcc = {
        0x70, 0x0E,             // 7* 0E:         J** +16
        0xFF, 0x25, 0x00000000, // FF25 00000000: JMP [RIP+6]
        0x0000000000000000ULL   // Absolute destination address
    };
#else
    CALL_REL call = {
        0xE8,                   // E8 xxxxxxxx: CALL +5+xxxxxxxx
        0x00000000              // Relative destination address
    };
    JMP_REL jmp = {
        0xE9,                   // E9 xxxxxxxx: JMP +5+xxxxxxxx
        0x00000000              // Relative destination address
    };
    JCC_REL jcc = {
        0x0F, 0x80,             // 0F8* xxxxxxxx: J** +6+xxxxxxxx
        0x00000000              // Relative destination address
    };
#endif

    UINT8     oldPos   = 0;
    UINT8     newPos   = 0;
    ULONG_PTR jmpDest  = 0;     // Destination address of an internal jump.
    BOOL      finished = FALSE; // Is the function completed?
#if defined(_M_X64) || defined(__x86_64__)
    UINT8     instBuf[16];
#endif

    ct->patchAbove = FALSE;
    ct->nIP        = 0;

    do
    {
        HDE       hs;
        UINT      copySize;
        LPVOID    pCopySrc;
        ULONG_PTR pOldInst = (ULONG_PTR)ct->pTarget     + oldPos;
        ULONG_PTR pNewInst = (ULONG_PTR)ct->pTrampoline + newPos;

        copySize = HDE_DISASM((LPVOID)pOldInst, &hs);
        if (hs.flags & F_ERROR)
            return FALSE;

        pCopySrc = (LPVOID)pOldInst;
        if (oldPos >= sizeof(JMP_REL))
        {
            // The trampoline function is long enough.
            // Complete the function with the jump to the target function.
#if defined(_M_X64) || defined(__x86_64__)
            jmp.address = pOldInst;
#else
            jmp.operand = (UINT32)(pOldInst - (pNewInst + sizeof(jmp)));
#endif
            pCopySrc = &jmp;
            copySize = sizeof(jmp);

            finished = TRUE;
        }
#if defined(_M_X64) || defined(__x86_64__)
        else if ((hs.modrm & 0xC7) == 0x05)
        {
            // Instructions using RIP relative addressing. (ModR/M = 00???101B)

            // Modify the RIP relative address.
            PUINT32 pRelAddr;

            // Avoid using memcpy to reduce the footprint.
#ifndef _MSC_VER
            memcpy(instBuf, (LPBYTE)pOldInst, copySize);
#else
            __movsb(instBuf, (LPBYTE)pOldInst, copySize);
#endif
            pCopySrc = instBuf;

            // Relative address is stored at (instruction length - immediate value length - 4).
            pRelAddr = (PUINT32)(instBuf + hs.len - ((hs.flags & 0x3C) >> 2) - 4);
            *pRelAddr
                = (UINT32)((pOldInst + hs.len + (INT32)hs.disp.disp32) - (pNewInst + hs.len));

            // Complete the function if JMP (FF /4).
            if (hs.opcode == 0xFF && hs.modrm_reg == 4)
                finished = TRUE;
        }
#endif
        else if (hs.opcode == 0xE8)
        {
            // Direct relative CALL
            ULONG_PTR dest = pOldInst + hs.len + (INT32)hs.imm.imm32;
#if defined(_M_X64) || defined(__x86_64__)
            call.address = dest;
#else
            call.operand = (UINT32)(dest - (pNewInst + sizeof(call)));
#endif
            pCopySrc = &call;
            copySize = sizeof(call);
        }
        else if ((hs.opcode & 0xFD) == 0xE9)
        {
            // Direct relative JMP (EB or E9)
            ULONG_PTR dest = pOldInst + hs.len;

            if (hs.opcode == 0xEB) // isShort jmp
                dest += (INT8)hs.imm.imm8;
            else
                dest += (INT32)hs.imm.imm32;

            // Simply copy an internal jump.
            if ((ULONG_PTR)ct->pTarget <= dest
                && dest < ((ULONG_PTR)ct->pTarget + sizeof(JMP_REL)))
            {
                if (jmpDest < dest)
                    jmpDest = dest;
            }
            else
            {
#if defined(_M_X64) || defined(__x86_64__)
                jmp.address = dest;
#else
                jmp.operand = (UINT32)(dest - (pNewInst + sizeof(jmp)));
#endif
                pCopySrc = &jmp;
                copySize = sizeof(jmp);

                // Exit the function if it is not in the branch.
                finished = (pOldInst >= jmpDest);
            }
        }
        else if ((hs.opcode & 0xF0) == 0x70
            || (hs.opcode & 0xFC) == 0xE0
            || (hs.opcode2 & 0xF0) == 0x80)
        {
            // Direct relative Jcc
            ULONG_PTR dest = pOldInst + hs.len;

            if ((hs.opcode & 0xF0) == 0x70      // Jcc
                || (hs.opcode & 0xFC) == 0xE0)  // LOOPNZ/LOOPZ/LOOP/JECXZ
                dest += (INT8)hs.imm.imm8;
            else
                dest += (INT32)hs.imm.imm32;

            // Simply copy an internal jump.
            if ((ULONG_PTR)ct->pTarget <= dest
                && dest < ((ULONG_PTR)ct->pTarget + sizeof(JMP_REL)))
            {
                if (jmpDest < dest)
                    jmpDest = dest;
            }
            else if ((hs.opcode & 0xFC) == 0xE0)
            {
                // LOOPNZ/LOOPZ/LOOP/JCXZ/JECXZ to the outside are not supported.
                return FALSE;
            }
            else
            {
                UINT8 cond = ((hs.opcode != 0x0F ? hs.opcode : hs.opcode2) & 0x0F);
#if defined(_M_X64) || defined(__x86_64__)
                // Invert the condition in x64 mode to simplify the conditional jump logic.
                jcc.opcode  = 0x71 ^ cond;
                jcc.address = dest;
#else
                jcc.opcode1 = 0x80 | cond;
                jcc.operand = (UINT32)(dest - (pNewInst + sizeof(jcc)));
#endif
                pCopySrc = &jcc;
                copySize = sizeof(jcc);
            }
        }
        else if ((hs.opcode & 0xFE) == 0xC2)
        {
            // RET (C2 or C3)

            // Complete the function if not in a branch.
            finished = (pOldInst >= jmpDest);
        }

        // Can't alter the instruction length in a branch.
        if (pOldInst < jmpDest && copySize != hs.len)
            return FALSE;

        // Trampoline function is too large.
        if ((newPos + copySize) > TRAMPOLINE_MAX_SIZE)
            return FALSE;

        // Trampoline function has too many instructions.
        if (ct->nIP >= ARRAYSIZE(ct->oldIPs))
            return FALSE;

        ct->oldIPs[ct->nIP] = oldPos;
        ct->newIPs[ct->nIP] = newPos;
        ct->nIP++;

        // Avoid using memcpy to reduce the footprint.
#ifndef _MSC_VER
        memcpy((LPBYTE)ct->pTrampoline + newPos, pCopySrc, copySize);
#else
        __movsb((LPBYTE)ct->pTrampoline + newPos, (LPBYTE)pCopySrc, copySize);
#endif
        newPos += copySize;
        oldPos += hs.len;
    }
    while (!finished);

    // Is there enough place for a long jump?
    if (oldPos < sizeof(JMP_REL)
        && !IsCodePadding((LPBYTE)ct->pTarget + oldPos, sizeof(JMP_REL) - oldPos))
    {
        // Is there enough place for a short jump?
        if (oldPos < sizeof(JMP_REL_SHORT)
            && !IsCodePadding((LPBYTE)ct->pTarget + oldPos, sizeof(JMP_REL_SHORT) - oldPos))
        {
            return FALSE;
        }

        // Can we place the long jump above the function?
        if (!IsExecutableAddress((LPBYTE)ct->pTarget - sizeof(JMP_REL)))
            return FALSE;

        if (!IsCodePadding((LPBYTE)ct->pTarget - sizeof(JMP_REL), sizeof(JMP_REL)))
            return FALSE;

        ct->patchAbove = TRUE;
    }

#if defined(_M_X64) || defined(__x86_64__)
    // Create a relay function.
    jmp.address = (ULONG_PTR)ct->pDetour;

    ct->pRelay = (LPBYTE)ct->pTrampoline + newPos;
    memcpy(ct->pRelay, &jmp, sizeof(jmp));
#endif

    return TRUE;
}

```

`ac_module/lib/minhook/src/trampoline.h`:

```h
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#pragma once

#pragma pack(push, 1)

// Structs for writing x86/x64 instructions.

// 8-bit relative jump.
typedef struct _JMP_REL_SHORT
{
    UINT8  opcode;      // EB xx: JMP +2+xx
    UINT8  operand;
} JMP_REL_SHORT, *PJMP_REL_SHORT;

// 32-bit direct relative jump/call.
typedef struct _JMP_REL
{
    UINT8  opcode;      // E9/E8 xxxxxxxx: JMP/CALL +5+xxxxxxxx
    UINT32 operand;     // Relative destination address
} JMP_REL, *PJMP_REL, CALL_REL;

// 64-bit indirect absolute jump.
typedef struct _JMP_ABS
{
    UINT8  opcode0;     // FF25 00000000: JMP [+6]
    UINT8  opcode1;
    UINT32 dummy;
    UINT64 address;     // Absolute destination address
} JMP_ABS, *PJMP_ABS;

// 64-bit indirect absolute call.
typedef struct _CALL_ABS
{
    UINT8  opcode0;     // FF15 00000002: CALL [+6]
    UINT8  opcode1;
    UINT32 dummy0;
    UINT8  dummy1;      // EB 08:         JMP +10
    UINT8  dummy2;
    UINT64 address;     // Absolute destination address
} CALL_ABS;

// 32-bit direct relative conditional jumps.
typedef struct _JCC_REL
{
    UINT8  opcode0;     // 0F8* xxxxxxxx: J** +6+xxxxxxxx
    UINT8  opcode1;
    UINT32 operand;     // Relative destination address
} JCC_REL;

// 64bit indirect absolute conditional jumps that x64 lacks.
typedef struct _JCC_ABS
{
    UINT8  opcode;      // 7* 0E:         J** +16
    UINT8  dummy0;
    UINT8  dummy1;      // FF25 00000000: JMP [+6]
    UINT8  dummy2;
    UINT32 dummy3;
    UINT64 address;     // Absolute destination address
} JCC_ABS;

#pragma pack(pop)

typedef struct _TRAMPOLINE
{
    LPVOID pTarget;         // [In] Address of the target function.
    LPVOID pDetour;         // [In] Address of the detour function.
    LPVOID pTrampoline;     // [In] Buffer address for the trampoline and relay function.

#if defined(_M_X64) || defined(__x86_64__)
    LPVOID pRelay;          // [Out] Address of the relay function.
#endif
    BOOL   patchAbove;      // [Out] Should use the hot patch area?
    UINT   nIP;             // [Out] Number of the instruction boundaries.
    UINT8  oldIPs[8];       // [Out] Instruction boundaries of the target function.
    UINT8  newIPs[8];       // [Out] Instruction boundaries of the trampoline function.
} TRAMPOLINE, *PTRAMPOLINE;

BOOL CreateTrampolineFunction(PTRAMPOLINE ct);

```

`ac_module/lib/tinyformat.h`:

```h
// tinyformat.h
// Copyright (C) 2011, Chris Foster [chris42f (at) gmail (d0t) com]
//
// Boost Software License - Version 1.0
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//------------------------------------------------------------------------------
// Tinyformat: A minimal type safe printf replacement
//
// tinyformat.h is a type safe printf replacement library in a single C++
// header file.  Design goals include:
//
// * Type safety and extensibility for user defined types.
// * C99 printf() compatibility, to the extent possible using std::ostream
// * POSIX extension for positional arguments
// * Simplicity and minimalism.  A single header file to include and distribute
//   with your projects.
// * Augment rather than replace the standard stream formatting mechanism
// * C++98 support, with optional C++11 niceties
//
//
// Main interface example usage
// ----------------------------
//
// To print a date to std::cout for American usage:
//
//   std::string weekday = "Wednesday";
//   const char* month = "July";
//   size_t day = 27;
//   long hour = 14;
//   int min = 44;
//
//   tfm::printf("%s, %s %d, %.2d:%.2d\n", weekday, month, day, hour, min);
//
// POSIX extension for positional arguments is available.
// The ability to rearrange formatting arguments is an important feature
// for localization because the word order may vary in different languages.
//
// Previous example for German usage. Arguments are reordered:
//
//   tfm::printf("%1$s, %3$d. %2$s, %4$d:%5$.2d\n", weekday, month, day, hour, min);
//
// The strange types here emphasize the type safety of the interface; it is
// possible to print a std::string using the "%s" conversion, and a
// size_t using the "%d" conversion.  A similar result could be achieved
// using either of the tfm::format() functions.  One prints on a user provided
// stream:
//
//   tfm::format(std::cerr, "%s, %s %d, %.2d:%.2d\n",
//               weekday, month, day, hour, min);
//
// The other returns a std::string:
//
//   std::string date = tfm::format("%s, %s %d, %.2d:%.2d\n",
//                                  weekday, month, day, hour, min);
//   std::cout << date;
//
// These are the three primary interface functions.  There is also a
// convenience function printfln() which appends a newline to the usual result
// of printf() for super simple logging.
//
//
// User defined format functions
// -----------------------------
//
// Simulating variadic templates in C++98 is pretty painful since it requires
// writing out the same function for each desired number of arguments.  To make
// this bearable tinyformat comes with a set of macros which are used
// internally to generate the API, but which may also be used in user code.
//
// The three macros TINYFORMAT_ARGTYPES(n), TINYFORMAT_VARARGS(n) and
// TINYFORMAT_PASSARGS(n) will generate a list of n argument types,
// type/name pairs and argument names respectively when called with an integer
// n between 1 and 16.  We can use these to define a macro which generates the
// desired user defined function with n arguments.  To generate all 16 user
// defined function bodies, use the macro TINYFORMAT_FOREACH_ARGNUM.  For an
// example, see the implementation of printf() at the end of the source file.
//
// Sometimes it's useful to be able to pass a list of format arguments through
// to a non-template function.  The FormatList class is provided as a way to do
// this by storing the argument list in a type-opaque way.  Continuing the
// example from above, we construct a FormatList using makeFormatList():
//
//   FormatListRef formatList = tfm::makeFormatList(weekday, month, day, hour, min);
//
// The format list can now be passed into any non-template function and used
// via a call to the vformat() function:
//
//   tfm::vformat(std::cout, "%s, %s %d, %.2d:%.2d\n", formatList);
//
//
// Additional API information
// --------------------------
//
// Error handling: Define TINYFORMAT_ERROR to customize the error handling for
// format strings which are unsupported or have the wrong number of format
// specifiers (calls assert() by default).
//
// User defined types: Uses operator<< for user defined types by default.
// Overload formatValue() for more control.


#ifndef TINYFORMAT_H_INCLUDED
#define TINYFORMAT_H_INCLUDED

namespace tinyformat { }
//------------------------------------------------------------------------------
// Config section.  Customize to your liking!

// Namespace alias to encourage brevity
namespace tfm = tinyformat;

// Error handling; calls assert() by default.
// #define TINYFORMAT_ERROR(reasonString) your_error_handler(reasonString)

// Define for C++11 variadic templates which make the code shorter & more
// general.  If you don't define this, C++11 support is autodetected below.
// #define TINYFORMAT_USE_VARIADIC_TEMPLATES


//------------------------------------------------------------------------------
// Implementation details.
#include <algorithm>
#include <iostream>
#include <sstream>

#ifndef TINYFORMAT_ASSERT
#   include <cassert>
#   define TINYFORMAT_ASSERT(cond) assert(cond)
#endif

#ifndef TINYFORMAT_ERROR
#   include <cassert>
#   define TINYFORMAT_ERROR(reason) assert(0 && reason)
#endif

#if !defined(TINYFORMAT_USE_VARIADIC_TEMPLATES) && !defined(TINYFORMAT_NO_VARIADIC_TEMPLATES)
#   ifdef __GXX_EXPERIMENTAL_CXX0X__
#       define TINYFORMAT_USE_VARIADIC_TEMPLATES
#   endif
#endif

#if defined(__GLIBCXX__) && __GLIBCXX__ < 20080201
//  std::showpos is broken on old libstdc++ as provided with macOS.  See
//  http://gcc.gnu.org/ml/libstdc++/2007-11/msg00075.html
#   define TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND
#endif

#ifdef __APPLE__
// Workaround macOS linker warning: Xcode uses different default symbol
// visibilities for static libs vs executables (see issue #25)
#   define TINYFORMAT_HIDDEN __attribute__((visibility("hidden")))
#else
#   define TINYFORMAT_HIDDEN
#endif

namespace tinyformat {

    //------------------------------------------------------------------------------
    namespace detail {

        // Test whether type T1 is convertible to type T2
        template <typename T1, typename T2>
        struct is_convertible
        {
        private:
            // two types of different size
            struct fail { char dummy[ 2 ]; };
            struct succeed { char dummy; };
            // Try to convert a T1 to a T2 by plugging into tryConvert
            static fail tryConvert( ... );
            static succeed tryConvert( const T2 & );
            static const T1 &makeT1( );
        public:
#       ifdef _MSC_VER
            // Disable spurious loss of precision warnings in tryConvert(makeT1())
#       pragma warning(push)
#       pragma warning(disable:4244)
#       pragma warning(disable:4267)
#       endif
        // Standard trick: the (...) version of tryConvert will be chosen from
        // the overload set only if the version taking a T2 doesn't match.
        // Then we compare the sizes of the return types to check which
        // function matched.  Very neat, in a disgusting kind of way :)
            static const bool value =
                sizeof( tryConvert( makeT1( ) ) ) == sizeof( succeed );
#       ifdef _MSC_VER
#       pragma warning(pop)
#       endif
        };


        // Detect when a type is not a wchar_t string
        template<typename T> struct is_wchar { typedef int tinyformat_wchar_is_not_supported; };
        template<> struct is_wchar<wchar_t *> {};
        template<> struct is_wchar<const wchar_t *> {};
        template<int n> struct is_wchar<const wchar_t[ n ]> {};
        template<int n> struct is_wchar<wchar_t[ n ]> {};


        // Format the value by casting to type fmtT.  This default implementation
        // should never be called.
        template<typename T, typename fmtT, bool convertible = is_convertible<T, fmtT>::value>
        struct formatValueAsType
        {
            static void invoke( std::ostream & /*out*/, const T & /*value*/ ) { TINYFORMAT_ASSERT( 0 ); }
        };
        // Specialized version for types that can actually be converted to fmtT, as
        // indicated by the "convertible" template parameter.
        template<typename T, typename fmtT>
        struct formatValueAsType<T, fmtT, true>
        {
            static void invoke( std::ostream &out, const T &value )
            {
                out << static_cast< fmtT >( value );
            }
        };

#ifdef TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND
        template<typename T, bool convertible = is_convertible<T, int>::value>
        struct formatZeroIntegerWorkaround
        {
            static bool invoke( std::ostream & /**/, const T & /**/ ) { return false; }
        };
        template<typename T>
        struct formatZeroIntegerWorkaround<T, true>
        {
            static bool invoke( std::ostream &out, const T &value )
            {
                if ( static_cast< int >( value ) == 0 && out.flags( ) & std::ios::showpos ) {
                    out << "+0";
                    return true;
                }
                return false;
            }
        };
#endif // TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND

        // Convert an arbitrary type to integer.  The version with convertible=false
        // throws an error.
        template<typename T, bool convertible = is_convertible<T, int>::value>
        struct convertToInt
        {
            static int invoke( const T & /*value*/ )
            {
                TINYFORMAT_ERROR( "tinyformat: Cannot convert from argument type to "
                    "integer for use as variable width or precision" );
                return 0;
            }
        };
        // Specialization for convertToInt when conversion is possible
        template<typename T>
        struct convertToInt<T, true>
        {
            static int invoke( const T &value ) { return static_cast< int >( value ); }
        };

        // Format at most ntrunc characters to the given stream.
        template<typename T>
        inline void formatTruncated( std::ostream &out, const T &value, int ntrunc )
        {
            std::ostringstream tmp;
            tmp << value;
            std::string result = tmp.str( );
            out.write( result.c_str( ), ( std::min )( ntrunc, static_cast< int >( result.size( ) ) ) );
        }
#define TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR(type)       \
inline void formatTruncated(std::ostream& out, type* value, int ntrunc) \
{                                                           \
    std::streamsize len = 0;                                \
    while (len < ntrunc && value[len] != 0)                 \
        ++len;                                              \
    out.write(value, len);                                  \
}
        // Overload for const char* and char*.  Could overload for signed & unsigned
        // char too, but these are technically unneeded for printf compatibility.
        TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR( const char )
            TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR( char )
#undef TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR

    } // namespace detail


    //------------------------------------------------------------------------------
    // Variable formatting functions.  May be overridden for user-defined types if
    // desired.


    /// Format a value into a stream, delegating to operator<< by default.
    ///
    /// Users may override this for their own types.  When this function is called,
    /// the stream flags will have been modified according to the format string.
    /// The format specification is provided in the range [fmtBegin, fmtEnd).  For
    /// truncating conversions, ntrunc is set to the desired maximum number of
    /// characters, for example "%.7s" calls formatValue with ntrunc = 7.
    ///
    /// By default, formatValue() uses the usual stream insertion operator
    /// operator<< to format the type T, with special cases for the %c and %p
    /// conversions.
    template<typename T>
    inline void formatValue( std::ostream &out, const char * /*fmtBegin*/,
        const char *fmtEnd, int ntrunc, const T &value )
    {
#ifndef TINYFORMAT_ALLOW_WCHAR_STRINGS
        // Since we don't support printing of wchar_t using "%ls", make it fail at
        // compile time in preference to printing as a void* at runtime.
        typedef typename detail::is_wchar<T>::tinyformat_wchar_is_not_supported DummyType;
        ( void )DummyType( ); // avoid unused type warning with gcc-4.8
#endif
    // The mess here is to support the %c and %p conversions: if these
    // conversions are active we try to convert the type to a char or const
    // void* respectively and format that instead of the value itself.  For the
    // %p conversion it's important to avoid dereferencing the pointer, which
    // could otherwise lead to a crash when printing a dangling (const char*).
        const bool canConvertToChar = detail::is_convertible<T, char>::value;
        const bool canConvertToVoidPtr = detail::is_convertible<T, const void *>::value;
        if ( canConvertToChar && *( fmtEnd - 1 ) == 'c' )
            detail::formatValueAsType<T, char>::invoke( out, value );
        else if ( canConvertToVoidPtr && *( fmtEnd - 1 ) == 'p' )
            detail::formatValueAsType<T, const void *>::invoke( out, value );
#ifdef TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND
        else if ( detail::formatZeroIntegerWorkaround<T>::invoke( out, value ) ) /**/;
#endif
        else if ( ntrunc >= 0 ) {
            // Take care not to overread C strings in truncating conversions like
            // "%.4s" where at most 4 characters may be read.
            detail::formatTruncated( out, value, ntrunc );
        }
        else
            out << value;
    }


    // Overloaded version for char types to support printing as an integer
#define TINYFORMAT_DEFINE_FORMATVALUE_CHAR(charType)                  \
inline void formatValue(std::ostream& out, const char* /*fmtBegin*/,  \
                        const char* fmtEnd, int /**/, charType value) \
{                                                                     \
    switch (*(fmtEnd-1)) {                                            \
        case 'u': case 'd': case 'i': case 'o': case 'X': case 'x':   \
            out << static_cast<int>(value); break;                    \
        default:                                                      \
            out << value;                   break;                    \
    }                                                                 \
}
// per 3.9.1: char, signed char and unsigned char are all distinct types
    TINYFORMAT_DEFINE_FORMATVALUE_CHAR( char )
        TINYFORMAT_DEFINE_FORMATVALUE_CHAR( signed char )
        TINYFORMAT_DEFINE_FORMATVALUE_CHAR( unsigned char )
#undef TINYFORMAT_DEFINE_FORMATVALUE_CHAR


        //------------------------------------------------------------------------------
        // Tools for emulating variadic templates in C++98.  The basic idea here is
        // stolen from the boost preprocessor metaprogramming library and cut down to
        // be just general enough for what we need.

#define TINYFORMAT_ARGTYPES(n) TINYFORMAT_ARGTYPES_ ## n
#define TINYFORMAT_VARARGS(n) TINYFORMAT_VARARGS_ ## n
#define TINYFORMAT_PASSARGS(n) TINYFORMAT_PASSARGS_ ## n
#define TINYFORMAT_PASSARGS_TAIL(n) TINYFORMAT_PASSARGS_TAIL_ ## n

// To keep it as transparent as possible, the macros below have been generated
// using python via the excellent cog code generation script.  This avoids
// the need for a bunch of complex (but more general) preprocessor tricks as
// used in boost.preprocessor.
//
// To rerun the code generation in place, use `cog -r tinyformat.h`
// (see http://nedbatchelder.com/code/cog).  Alternatively you can just create
// extra versions by hand.

/*[[[cog
maxParams = 16

def makeCommaSepLists(lineTemplate, elemTemplate, startInd=1):
    for j in range(startInd,maxParams+1):
        list = ', '.join([elemTemplate % {'i':i} for i in range(startInd,j+1)])
        cog.outl(lineTemplate % {'j':j, 'list':list})

makeCommaSepLists('#define TINYFORMAT_ARGTYPES_%(j)d %(list)s',
                  'class T%(i)d')

cog.outl()
makeCommaSepLists('#define TINYFORMAT_VARARGS_%(j)d %(list)s',
                  'const T%(i)d& v%(i)d')

cog.outl()
makeCommaSepLists('#define TINYFORMAT_PASSARGS_%(j)d %(list)s', 'v%(i)d')

cog.outl()
cog.outl('#define TINYFORMAT_PASSARGS_TAIL_1')
makeCommaSepLists('#define TINYFORMAT_PASSARGS_TAIL_%(j)d , %(list)s',
                  'v%(i)d', startInd = 2)

cog.outl()
cog.outl('#define TINYFORMAT_FOREACH_ARGNUM(m) \\\n    ' +
         ' '.join(['m(%d)' % (j,) for j in range(1,maxParams+1)]))
]]]*/
#define TINYFORMAT_ARGTYPES_1 class T1
#define TINYFORMAT_ARGTYPES_2 class T1, class T2
#define TINYFORMAT_ARGTYPES_3 class T1, class T2, class T3
#define TINYFORMAT_ARGTYPES_4 class T1, class T2, class T3, class T4
#define TINYFORMAT_ARGTYPES_5 class T1, class T2, class T3, class T4, class T5
#define TINYFORMAT_ARGTYPES_6 class T1, class T2, class T3, class T4, class T5, class T6
#define TINYFORMAT_ARGTYPES_7 class T1, class T2, class T3, class T4, class T5, class T6, class T7
#define TINYFORMAT_ARGTYPES_8 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8
#define TINYFORMAT_ARGTYPES_9 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9
#define TINYFORMAT_ARGTYPES_10 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10
#define TINYFORMAT_ARGTYPES_11 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11
#define TINYFORMAT_ARGTYPES_12 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12
#define TINYFORMAT_ARGTYPES_13 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13
#define TINYFORMAT_ARGTYPES_14 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14
#define TINYFORMAT_ARGTYPES_15 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15
#define TINYFORMAT_ARGTYPES_16 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16

#define TINYFORMAT_VARARGS_1 const T1& v1
#define TINYFORMAT_VARARGS_2 const T1& v1, const T2& v2
#define TINYFORMAT_VARARGS_3 const T1& v1, const T2& v2, const T3& v3
#define TINYFORMAT_VARARGS_4 const T1& v1, const T2& v2, const T3& v3, const T4& v4
#define TINYFORMAT_VARARGS_5 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5
#define TINYFORMAT_VARARGS_6 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6
#define TINYFORMAT_VARARGS_7 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7
#define TINYFORMAT_VARARGS_8 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8
#define TINYFORMAT_VARARGS_9 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9
#define TINYFORMAT_VARARGS_10 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10
#define TINYFORMAT_VARARGS_11 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11
#define TINYFORMAT_VARARGS_12 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11, const T12& v12
#define TINYFORMAT_VARARGS_13 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11, const T12& v12, const T13& v13
#define TINYFORMAT_VARARGS_14 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11, const T12& v12, const T13& v13, const T14& v14
#define TINYFORMAT_VARARGS_15 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11, const T12& v12, const T13& v13, const T14& v14, const T15& v15
#define TINYFORMAT_VARARGS_16 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11, const T12& v12, const T13& v13, const T14& v14, const T15& v15, const T16& v16

#define TINYFORMAT_PASSARGS_1 v1
#define TINYFORMAT_PASSARGS_2 v1, v2
#define TINYFORMAT_PASSARGS_3 v1, v2, v3
#define TINYFORMAT_PASSARGS_4 v1, v2, v3, v4
#define TINYFORMAT_PASSARGS_5 v1, v2, v3, v4, v5
#define TINYFORMAT_PASSARGS_6 v1, v2, v3, v4, v5, v6
#define TINYFORMAT_PASSARGS_7 v1, v2, v3, v4, v5, v6, v7
#define TINYFORMAT_PASSARGS_8 v1, v2, v3, v4, v5, v6, v7, v8
#define TINYFORMAT_PASSARGS_9 v1, v2, v3, v4, v5, v6, v7, v8, v9
#define TINYFORMAT_PASSARGS_10 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10
#define TINYFORMAT_PASSARGS_11 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11
#define TINYFORMAT_PASSARGS_12 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12
#define TINYFORMAT_PASSARGS_13 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13
#define TINYFORMAT_PASSARGS_14 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14
#define TINYFORMAT_PASSARGS_15 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15
#define TINYFORMAT_PASSARGS_16 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16

#define TINYFORMAT_PASSARGS_TAIL_1
#define TINYFORMAT_PASSARGS_TAIL_2 , v2
#define TINYFORMAT_PASSARGS_TAIL_3 , v2, v3
#define TINYFORMAT_PASSARGS_TAIL_4 , v2, v3, v4
#define TINYFORMAT_PASSARGS_TAIL_5 , v2, v3, v4, v5
#define TINYFORMAT_PASSARGS_TAIL_6 , v2, v3, v4, v5, v6
#define TINYFORMAT_PASSARGS_TAIL_7 , v2, v3, v4, v5, v6, v7
#define TINYFORMAT_PASSARGS_TAIL_8 , v2, v3, v4, v5, v6, v7, v8
#define TINYFORMAT_PASSARGS_TAIL_9 , v2, v3, v4, v5, v6, v7, v8, v9
#define TINYFORMAT_PASSARGS_TAIL_10 , v2, v3, v4, v5, v6, v7, v8, v9, v10
#define TINYFORMAT_PASSARGS_TAIL_11 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11
#define TINYFORMAT_PASSARGS_TAIL_12 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12
#define TINYFORMAT_PASSARGS_TAIL_13 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13
#define TINYFORMAT_PASSARGS_TAIL_14 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14
#define TINYFORMAT_PASSARGS_TAIL_15 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15
#define TINYFORMAT_PASSARGS_TAIL_16 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16

#define TINYFORMAT_FOREACH_ARGNUM(m) \
    m(1) m(2) m(3) m(4) m(5) m(6) m(7) m(8) m(9) m(10) m(11) m(12) m(13) m(14) m(15) m(16)
//[[[end]]]



namespace detail {

        // Type-opaque holder for an argument to format(), with associated actions on
        // the type held as explicit function pointers.  This allows FormatArg's for
        // each argument to be allocated as a homogeneous array inside FormatList
        // whereas a naive implementation based on inheritance does not.
        class FormatArg
        {
        public:
            FormatArg( )
                : m_value( NULL ),
                m_formatImpl( NULL ),
                m_toIntImpl( NULL )
            { }

            template<typename T>
            FormatArg( const T &value )
                // C-style cast here allows us to also remove volatile; we put it
                // back in the *Impl functions before dereferencing to avoid UB.
                : m_value( ( const void * )( &value ) ),
                m_formatImpl( &formatImpl<T> ),
                m_toIntImpl( &toIntImpl<T> )
            { }

            void format( std::ostream &out, const char *fmtBegin,
                const char *fmtEnd, int ntrunc ) const
            {
                TINYFORMAT_ASSERT( m_value );
                TINYFORMAT_ASSERT( m_formatImpl );
                m_formatImpl( out, fmtBegin, fmtEnd, ntrunc, m_value );
            }

            int toInt( ) const
            {
                TINYFORMAT_ASSERT( m_value );
                TINYFORMAT_ASSERT( m_toIntImpl );
                return m_toIntImpl( m_value );
            }

        private:
            template<typename T>
            TINYFORMAT_HIDDEN static void formatImpl( std::ostream &out, const char *fmtBegin,
                const char *fmtEnd, int ntrunc, const void *value )
            {
                formatValue( out, fmtBegin, fmtEnd, ntrunc, *static_cast< const T * >( value ) );
            }

            template<typename T>
            TINYFORMAT_HIDDEN static int toIntImpl( const void *value )
            {
                return convertToInt<T>::invoke( *static_cast< const T * >( value ) );
            }

            const void *m_value;
            void ( *m_formatImpl )( std::ostream &out, const char *fmtBegin,
                const char *fmtEnd, int ntrunc, const void *value );
            int ( *m_toIntImpl )( const void *value );
        };


        // Parse and return an integer from the string c, as atoi()
        // On return, c is set to one past the end of the integer.
        inline int parseIntAndAdvance( const char *&c )
        {
            int i = 0;
            for ( ; *c >= '0' && *c <= '9'; ++c )
                i = 10 * i + ( *c - '0' );
            return i;
        }

        // Parse width or precision `n` from format string pointer `c`, and advance it
        // to the next character. If an indirection is requested with `*`, the argument
        // is read from `args[argIndex]` and `argIndex` is incremented (or read
        // from `args[n]` in positional mode). Returns true if one or more
        // characters were read.
        inline bool parseWidthOrPrecision( int &n, const char *&c, bool positionalMode,
            const detail::FormatArg *args,
            int &argIndex, int numArgs )
        {
            if ( *c >= '0' && *c <= '9' ) {
                n = parseIntAndAdvance( c );
            }
            else if ( *c == '*' ) {
                ++c;
                n = 0;
                if ( positionalMode ) {
                    int pos = parseIntAndAdvance( c ) - 1;
                    if ( *c != '$' )
                        TINYFORMAT_ERROR( "tinyformat: Non-positional argument used after a positional one" );
                    if ( pos >= 0 && pos < numArgs )
                        n = args[ pos ].toInt( );
                    else
                        TINYFORMAT_ERROR( "tinyformat: Positional argument out of range" );
                    ++c;
                }
                else {
                    if ( argIndex < numArgs )
                        n = args[ argIndex++ ].toInt( );
                    else
                        TINYFORMAT_ERROR( "tinyformat: Not enough arguments to read variable width or precision" );
                }
            }
            else {
                return false;
            }
            return true;
        }

        // Print literal part of format string and return next format spec position.
        //
        // Skips over any occurrences of '%%', printing a literal '%' to the output.
        // The position of the first % character of the next nontrivial format spec is
        // returned, or the end of string.
        inline const char *printFormatStringLiteral( std::ostream &out, const char *fmt )
        {
            const char *c = fmt;
            for ( ;; ++c ) {
                if ( *c == '\0' ) {
                    out.write( fmt, c - fmt );
                    return c;
                }
                else if ( *c == '%' ) {
                    out.write( fmt, c - fmt );
                    if ( *( c + 1 ) != '%' )
                        return c;
                    // for "%%", tack trailing % onto next literal section.
                    fmt = ++c;
                }
            }
        }


        // Parse a format string and set the stream state accordingly.
        //
        // The format mini-language recognized here is meant to be the one from C99,
        // with the form "%[flags][width][.precision][length]type" with POSIX
        // positional arguments extension.
        //
        // POSIX positional arguments extension:
        // Conversions can be applied to the nth argument after the format in
        // the argument list, rather than to the next unused argument. In this case,
        // the conversion specifier character % (see below) is replaced by the sequence
        // "%n$", where n is a decimal integer in the range [1,{NL_ARGMAX}],
        // giving the position of the argument in the argument list. This feature
        // provides for the definition of format strings that select arguments
        // in an order appropriate to specific languages.
        //
        // The format can contain either numbered argument conversion specifications
        // (that is, "%n$" and "*m$"), or unnumbered argument conversion specifications
        // (that is, % and * ), but not both. The only exception to this is that %%
        // can be mixed with the "%n$" form. The results of mixing numbered and
        // unnumbered argument specifications in a format string are undefined.
        // When numbered argument specifications are used, specifying the Nth argument
        // requires that all the leading arguments, from the first to the (N-1)th,
        // are specified in the format string.
        //
        // In format strings containing the "%n$" form of conversion specification,
        // numbered arguments in the argument list can be referenced from the format
        // string as many times as required.
        //
        // Formatting options which can't be natively represented using the ostream
        // state are returned in spacePadPositive (for space padded positive numbers)
        // and ntrunc (for truncating conversions).  argIndex is incremented if
        // necessary to pull out variable width and precision.  The function returns a
        // pointer to the character after the end of the current format spec.
        inline const char *streamStateFromFormat( std::ostream &out, bool &positionalMode,
            bool &spacePadPositive,
            int &ntrunc, const char *fmtStart,
            const detail::FormatArg *args,
            int &argIndex, int numArgs )
        {
            TINYFORMAT_ASSERT( *fmtStart == '%' );
            // Reset stream state to defaults.
            out.width( 0 );
            out.precision( 6 );
            out.fill( ' ' );
            // Reset most flags; ignore irrelevant unitbuf & skipws.
            out.unsetf( std::ios::adjustfield | std::ios::basefield |
                std::ios::floatfield | std::ios::showbase | std::ios::boolalpha |
                std::ios::showpoint | std::ios::showpos | std::ios::uppercase );
            bool precisionSet = false;
            bool widthSet = false;
            int widthExtra = 0;
            const char *c = fmtStart + 1;

            // 1) Parse an argument index (if followed by '$') or a width possibly
            // preceded with '0' flag.
            if ( *c >= '0' && *c <= '9' ) {
                const char tmpc = *c;
                int value = parseIntAndAdvance( c );
                if ( *c == '$' ) {
                    // value is an argument index
                    if ( value > 0 && value <= numArgs )
                        argIndex = value - 1;
                    else
                        TINYFORMAT_ERROR( "tinyformat: Positional argument out of range" );
                    ++c;
                    positionalMode = true;
                }
                else if ( positionalMode ) {
                    TINYFORMAT_ERROR( "tinyformat: Non-positional argument used after a positional one" );
                }
                else {
                    if ( tmpc == '0' ) {
                        // Use internal padding so that numeric values are
                        // formatted correctly, eg -00010 rather than 000-10
                        out.fill( '0' );
                        out.setf( std::ios::internal, std::ios::adjustfield );
                    }
                    if ( value != 0 ) {
                        // Nonzero value means that we parsed width.
                        widthSet = true;
                        out.width( value );
                    }
                }
            }
            else if ( positionalMode ) {
                TINYFORMAT_ERROR( "tinyformat: Non-positional argument used after a positional one" );
            }
            // 2) Parse flags and width if we did not do it in previous step.
            if ( !widthSet ) {
                // Parse flags
                for ( ;; ++c ) {
                    switch ( *c ) {
                    case '#':
                        out.setf( std::ios::showpoint | std::ios::showbase );
                        continue;
                    case '0':
                        // overridden by left alignment ('-' flag)
                        if ( !( out.flags( ) & std::ios::left ) ) {
                            // Use internal padding so that numeric values are
                            // formatted correctly, eg -00010 rather than 000-10
                            out.fill( '0' );
                            out.setf( std::ios::internal, std::ios::adjustfield );
                        }
                        continue;
                    case '-':
                        out.fill( ' ' );
                        out.setf( std::ios::left, std::ios::adjustfield );
                        continue;
                    case ' ':
                        // overridden by show positive sign, '+' flag.
                        if ( !( out.flags( ) & std::ios::showpos ) )
                            spacePadPositive = true;
                        continue;
                    case '+':
                        out.setf( std::ios::showpos );
                        spacePadPositive = false;
                        widthExtra = 1;
                        continue;
                    default:
                        break;
                    }
                    break;
                }
                // Parse width
                int width = 0;
                widthSet = parseWidthOrPrecision( width, c, positionalMode,
                    args, argIndex, numArgs );
                if ( widthSet ) {
                    if ( width < 0 ) {
                        // negative widths correspond to '-' flag set
                        out.fill( ' ' );
                        out.setf( std::ios::left, std::ios::adjustfield );
                        width = -width;
                    }
                    out.width( width );
                }
            }
            // 3) Parse precision
            if ( *c == '.' ) {
                ++c;
                int precision = 0;
                parseWidthOrPrecision( precision, c, positionalMode,
                    args, argIndex, numArgs );
                // Presence of `.` indicates precision set, unless the inferred value
                // was negative in which case the default is used.
                precisionSet = precision >= 0;
                if ( precisionSet )
                    out.precision( precision );
            }
            // 4) Ignore any C99 length modifier
            while ( *c == 'l' || *c == 'h' || *c == 'L' ||
                *c == 'j' || *c == 'z' || *c == 't' ) {
                ++c;
            }
            // 5) We're up to the conversion specifier character.
            // Set stream flags based on conversion specifier (thanks to the
            // boost::format class for forging the way here).
            bool intConversion = false;
            switch ( *c ) {
            case 'u': case 'd': case 'i':
                out.setf( std::ios::dec, std::ios::basefield );
                intConversion = true;
                break;
            case 'o':
                out.setf( std::ios::oct, std::ios::basefield );
                intConversion = true;
                break;
            case 'X':
                out.setf( std::ios::uppercase );
                // Falls through
            case 'x': case 'p':
                out.setf( std::ios::hex, std::ios::basefield );
                intConversion = true;
                break;
            case 'E':
                out.setf( std::ios::uppercase );
                // Falls through
            case 'e':
                out.setf( std::ios::scientific, std::ios::floatfield );
                out.setf( std::ios::dec, std::ios::basefield );
                break;
            case 'F':
                out.setf( std::ios::uppercase );
                // Falls through
            case 'f':
                out.setf( std::ios::fixed, std::ios::floatfield );
                break;
            case 'A':
                out.setf( std::ios::uppercase );
                // Falls through
            case 'a':
#           ifdef _MSC_VER
                // Workaround https://developercommunity.visualstudio.com/content/problem/520472/hexfloat-stream-output-does-not-ignore-precision-a.html
                // by always setting maximum precision on MSVC to avoid precision
                // loss for doubles.
                out.precision( 13 );
#           endif
                out.setf( std::ios::fixed | std::ios::scientific, std::ios::floatfield );
                break;
            case 'G':
                out.setf( std::ios::uppercase );
                // Falls through
            case 'g':
                out.setf( std::ios::dec, std::ios::basefield );
                // As in boost::format, let stream decide float format.
                out.flags( out.flags( ) & ~std::ios::floatfield );
                break;
            case 'c':
                // Handled as special case inside formatValue()
                break;
            case 's':
                if ( precisionSet )
                    ntrunc = static_cast< int >( out.precision( ) );
                // Make %s print Booleans as "true" and "false"
                out.setf( std::ios::boolalpha );
                break;
            case 'n':
                // Not supported - will cause problems!
                TINYFORMAT_ERROR( "tinyformat: %n conversion spec not supported" );
                break;
            case '\0':
                TINYFORMAT_ERROR( "tinyformat: Conversion spec incorrectly "
                    "terminated by end of string" );
                return c;
            default:
                break;
            }
            if ( intConversion && precisionSet && !widthSet ) {
                // "precision" for integers gives the minimum number of digits (to be
                // padded with zeros on the left).  This isn't really supported by the
                // iostreams, but we can approximately simulate it with the width if
                // the width isn't otherwise used.
                out.width( out.precision( ) + widthExtra );
                out.setf( std::ios::internal, std::ios::adjustfield );
                out.fill( '0' );
            }
            return c + 1;
        }


        //------------------------------------------------------------------------------
        inline void formatImpl( std::ostream &out, const char *fmt,
            const detail::FormatArg *args,
            int numArgs )
        {
            // Saved stream state
            std::streamsize origWidth = out.width( );
            std::streamsize origPrecision = out.precision( );
            std::ios::fmtflags origFlags = out.flags( );
            char origFill = out.fill( );

            // "Positional mode" means all format specs should be of the form "%n$..."
            // with `n` an integer. We detect this in `streamStateFromFormat`.
            bool positionalMode = false;
            int argIndex = 0;
            while ( true ) {
                fmt = printFormatStringLiteral( out, fmt );
                if ( *fmt == '\0' ) {
                    if ( !positionalMode && argIndex < numArgs ) {
                        TINYFORMAT_ERROR( "tinyformat: Not enough conversion specifiers in format string" );
                    }
                    break;
                }
                bool spacePadPositive = false;
                int ntrunc = -1;
                const char *fmtEnd = streamStateFromFormat( out, positionalMode, spacePadPositive, ntrunc, fmt,
                    args, argIndex, numArgs );
                // NB: argIndex may be incremented by reading variable width/precision
                // in `streamStateFromFormat`, so do the bounds check here.
                if ( argIndex >= numArgs ) {
                    TINYFORMAT_ERROR( "tinyformat: Too many conversion specifiers in format string" );
                    return;
                }
                const FormatArg &arg = args[ argIndex ];
                // Format the arg into the stream.
                if ( !spacePadPositive ) {
                    arg.format( out, fmt, fmtEnd, ntrunc );
                }
                else {
                    // The following is a special case with no direct correspondence
                    // between stream formatting and the printf() behaviour.  Simulate
                    // it crudely by formatting into a temporary string stream and
                    // munging the resulting string.
                    std::ostringstream tmpStream;
                    tmpStream.copyfmt( out );
                    tmpStream.setf( std::ios::showpos );
                    arg.format( tmpStream, fmt, fmtEnd, ntrunc );
                    std::string result = tmpStream.str( ); // allocates... yuck.
                    for ( size_t i = 0, iend = result.size( ); i < iend; ++i ) {
                        if ( result[ i ] == '+' )
                            result[ i ] = ' ';
                    }
                    out << result;
                }
                if ( !positionalMode )
                    ++argIndex;
                fmt = fmtEnd;
            }

            // Restore stream state
            out.width( origWidth );
            out.precision( origPrecision );
            out.flags( origFlags );
            out.fill( origFill );
        }

    } // namespace detail


    /// List of template arguments format(), held in a type-opaque way.
    ///
    /// A const reference to FormatList (typedef'd as FormatListRef) may be
    /// conveniently used to pass arguments to non-template functions: All type
    /// information has been stripped from the arguments, leaving just enough of a
    /// common interface to perform formatting as required.
    class FormatList
    {
    public:
        FormatList( detail::FormatArg *args, int N )
            : m_args( args ), m_N( N ) { }

        friend void vformat( std::ostream &out, const char *fmt,
            const FormatList &list );

    private:
        const detail::FormatArg *m_args;
        int m_N;
    };

    /// Reference to type-opaque format list for passing to vformat()
    typedef const FormatList &FormatListRef;


    namespace detail {

        // Format list subclass with fixed storage to avoid dynamic allocation
        template<int N>
        class FormatListN : public FormatList
        {
        public:
#ifdef TINYFORMAT_USE_VARIADIC_TEMPLATES
            template<typename... Args>
            FormatListN( const Args &... args )
                : FormatList( &m_formatterStore[ 0 ], N ),
                m_formatterStore{ FormatArg( args )... }
            { static_assert( sizeof...( args ) == N, "Number of args must be N" ); }
#else // C++98 version
            void init( int ) {}
#       define TINYFORMAT_MAKE_FORMATLIST_CONSTRUCTOR(n)                \
                                                                        \
        template<TINYFORMAT_ARGTYPES(n)>                                \
        FormatListN(TINYFORMAT_VARARGS(n))                              \
            : FormatList(&m_formatterStore[0], n)                       \
        { TINYFORMAT_ASSERT(n == N); init(0, TINYFORMAT_PASSARGS(n)); } \
                                                                        \
        template<TINYFORMAT_ARGTYPES(n)>                                \
        void init(int i, TINYFORMAT_VARARGS(n))                         \
        {                                                               \
            m_formatterStore[i] = FormatArg(v1);                        \
            init(i+1 TINYFORMAT_PASSARGS_TAIL(n));                      \
        }

            TINYFORMAT_FOREACH_ARGNUM( TINYFORMAT_MAKE_FORMATLIST_CONSTRUCTOR )
#       undef TINYFORMAT_MAKE_FORMATLIST_CONSTRUCTOR
#endif
                FormatListN( const FormatListN &other )
                : FormatList( &m_formatterStore[ 0 ], N )
            {
                std::copy( &other.m_formatterStore[ 0 ], &other.m_formatterStore[ N ],
                    &m_formatterStore[ 0 ] );
            }

        private:
            FormatArg m_formatterStore[ N ];
        };

        // Special 0-arg version - MSVC says zero-sized C array in struct is nonstandard
        template<> class FormatListN<0> : public FormatList
        {
        public: FormatListN( ) : FormatList( 0, 0 ) {}
        };

    } // namespace detail


    //------------------------------------------------------------------------------
    // Primary API functions

#ifdef TINYFORMAT_USE_VARIADIC_TEMPLATES

/// Make type-agnostic format list from list of template arguments.
///
/// The exact return type of this function is an implementation detail and
/// shouldn't be relied upon.  Instead it should be stored as a FormatListRef:
///
///   FormatListRef formatList = makeFormatList( /*...*/ );
    template<typename... Args>
    detail::FormatListN<sizeof...( Args )> makeFormatList( const Args &... args )
    {
        return detail::FormatListN<sizeof...( args )>( args... );
    }

#else // C++98 version

    inline detail::FormatListN<0> makeFormatList( )
    {
        return detail::FormatListN<0>( );
    }
#define TINYFORMAT_MAKE_MAKEFORMATLIST(n)                     \
template<TINYFORMAT_ARGTYPES(n)>                              \
detail::FormatListN<n> makeFormatList(TINYFORMAT_VARARGS(n))  \
{                                                             \
    return detail::FormatListN<n>(TINYFORMAT_PASSARGS(n));    \
}
    TINYFORMAT_FOREACH_ARGNUM( TINYFORMAT_MAKE_MAKEFORMATLIST )
#undef TINYFORMAT_MAKE_MAKEFORMATLIST

#endif

        /// Format list of arguments to the stream according to the given format string.
        ///
        /// The name vformat() is chosen for the semantic similarity to vprintf(): the
        /// list of format arguments is held in a single function argument.
        inline void vformat( std::ostream &out, const char *fmt, FormatListRef list )
    {
        detail::formatImpl( out, fmt, list.m_args, list.m_N );
    }


#ifdef TINYFORMAT_USE_VARIADIC_TEMPLATES

    /// Format list of arguments to the stream according to given format string.
    template<typename... Args>
    void format( std::ostream &out, const char *fmt, const Args &... args )
    {
        vformat( out, fmt, makeFormatList( args... ) );
    }

    /// Format list of arguments according to the given format string and return
    /// the result as a string.
    template<typename... Args>
    std::string format( const char *fmt, const Args &... args )
    {
        std::ostringstream oss;
        format( oss, fmt, args... );
        return oss.str( );
    }

    /// Format list of arguments to std::cout, according to the given format string
    template<typename... Args>
    void printf( const char *fmt, const Args &... args )
    {
        format( std::cout, fmt, args... );
    }

    template<typename... Args>
    void printfln( const char *fmt, const Args &... args )
    {
        format( std::cout, fmt, args... );
        std::cout << '\n';
    }


#else // C++98 version

    inline void format( std::ostream &out, const char *fmt )
    {
        vformat( out, fmt, makeFormatList( ) );
    }

    inline std::string format( const char *fmt )
    {
        std::ostringstream oss;
        format( oss, fmt );
        return oss.str( );
    }

    inline void printf( const char *fmt )
    {
        format( std::cout, fmt );
    }

    inline void printfln( const char *fmt )
    {
        format( std::cout, fmt );
        std::cout << '\n';
    }

#define TINYFORMAT_MAKE_FORMAT_FUNCS(n)                                   \
                                                                          \
template<TINYFORMAT_ARGTYPES(n)>                                          \
void format(std::ostream& out, const char* fmt, TINYFORMAT_VARARGS(n))    \
{                                                                         \
    vformat(out, fmt, makeFormatList(TINYFORMAT_PASSARGS(n)));            \
}                                                                         \
                                                                          \
template<TINYFORMAT_ARGTYPES(n)>                                          \
std::string format(const char* fmt, TINYFORMAT_VARARGS(n))                \
{                                                                         \
    std::ostringstream oss;                                               \
    format(oss, fmt, TINYFORMAT_PASSARGS(n));                             \
    return oss.str();                                                     \
}                                                                         \
                                                                          \
template<TINYFORMAT_ARGTYPES(n)>                                          \
void printf(const char* fmt, TINYFORMAT_VARARGS(n))                       \
{                                                                         \
    format(std::cout, fmt, TINYFORMAT_PASSARGS(n));                       \
}                                                                         \
                                                                          \
template<TINYFORMAT_ARGTYPES(n)>                                          \
void printfln(const char* fmt, TINYFORMAT_VARARGS(n))                     \
{                                                                         \
    format(std::cout, fmt, TINYFORMAT_PASSARGS(n));                       \
    std::cout << '\n';                                                    \
}

    TINYFORMAT_FOREACH_ARGNUM( TINYFORMAT_MAKE_FORMAT_FUNCS )
#undef TINYFORMAT_MAKE_FORMAT_FUNCS

#endif


} // namespace tinyformat

#endif // TINYFORMAT_H_INCLUDED
```

`ac_module/main.cpp`:

```cpp
#include "integrity.h"
#include <iostream>

bool WINAPI DllMain( HINSTANCE dll, DWORD reason, LPVOID reserved )
{
	if ( reason == DLL_PROCESS_ATTACH )
		return integrity::init( dll );
}
```

`ac_module/nt.h`:

```h
#pragma once

typedef enum _SECTION_INHERIT {
	ViewShare = 1,
	ViewUnmap = 2
} SECTION_INHERIT, * PSECTION_INHERIT;

```

`ac_module/pe.h`:

```h
#pragma once

#include <cstdint>

struct reloc_entry
{
	std::uint16_t offset : 12;
	std::uint16_t type : 4;
};

#ifdef _WIN64
struct PEB_LDR_DATA
{
	ULONG Length;                                                           //0x0
	UCHAR Initialized;                                                      //0x4
	VOID* SsHandle;                                                         //0x8
	struct _LIST_ENTRY InLoadOrderModuleList;                               //0xc
	struct _LIST_ENTRY InMemoryOrderModuleList;                             //0x14
	struct _LIST_ENTRY InInitializationOrderModuleList;                     //0x1c
	VOID* EntryInProgress;                                                  //0x24
	UCHAR ShutdownInProgress;                                               //0x28
	VOID* ShutdownThreadId;                                                 //0x2c
}; static_assert( sizeof( PEB_LDR_DATA ) == 0x58 );

struct UNICODE_STRING
{
	USHORT Length;                                                          //0x0
	USHORT MaximumLength;                                                   //0x2
	WCHAR* Buffer;                                                          //0x4
}; static_assert ( sizeof( UNICODE_STRING ) == 0x10 );

struct STRING
{
	USHORT Length;                                                          //0x0
	USHORT MaximumLength;                                                   //0x2
	CHAR* Buffer;                                                           //0x4
}; static_assert ( sizeof( STRING ) == 0x10 );

struct CURDIR
{
	struct UNICODE_STRING DosPath;                                         //0x0
	VOID* Handle;                                                           //0x8
}; static_assert ( sizeof( CURDIR ) == 0x18 );

struct RTL_DRIVE_LETTER_CURDIR
{
	USHORT Flags;                                                           //0x0
	USHORT Length;                                                          //0x2
	ULONG TimeStamp;                                                        //0x4
	struct STRING DosPath;                                                 //0x8
}; static_assert ( sizeof( RTL_DRIVE_LETTER_CURDIR ) == 0x18 );

struct RTL_USER_PROCESS_PARAMETERS
{
	ULONG MaximumLength;                                                    //0x0
	ULONG Length;                                                           //0x4
	ULONG Flags;                                                            //0x8
	ULONG DebugFlags;                                                       //0xc
	VOID* ConsoleHandle;                                                    //0x10
	ULONG ConsoleFlags;                                                     //0x14
	VOID* StandardInput;                                                    //0x18
	VOID* StandardOutput;                                                   //0x1c
	VOID* StandardError;                                                    //0x20
	struct CURDIR CurrentDirectory;                                        //0x24
	struct UNICODE_STRING DllPath;                                         //0x30
	struct UNICODE_STRING ImagePathName;                                   //0x38
	struct UNICODE_STRING CommandLine;                                     //0x40
	VOID* Environment;                                                      //0x48
	ULONG StartingX;                                                        //0x4c
	ULONG StartingY;                                                        //0x50
	ULONG CountX;                                                           //0x54
	ULONG CountY;                                                           //0x58
	ULONG CountCharsX;                                                      //0x5c
	ULONG CountCharsY;                                                      //0x60
	ULONG FillAttribute;                                                    //0x64
	ULONG WindowFlags;                                                      //0x68
	ULONG ShowWindowFlags;                                                  //0x6c
	struct UNICODE_STRING WindowTitle;                                     //0x70
	struct UNICODE_STRING DesktopInfo;                                     //0x78
	struct UNICODE_STRING ShellInfo;                                       //0x80
	struct UNICODE_STRING RuntimeData;                                     //0x88
	struct RTL_DRIVE_LETTER_CURDIR CurrentDirectores[ 32 ];                  //0x90
	ULONGLONG EnvironmentSize;                                              //0x290
	ULONGLONG EnvironmentVersion;                                           //0x294
	VOID* PackageDependencyData;                                            //0x298
	ULONG ProcessGroupId;                                                   //0x29c
	ULONG LoaderThreads;                                                    //0x2a0
	struct UNICODE_STRING RedirectionDllName;                              //0x2a4
	struct UNICODE_STRING HeapPartitionName;                               //0x2ac
	ULONGLONG* DefaultThreadpoolCpuSetMasks;                                //0x2b4
	ULONG DefaultThreadpoolCpuSetMaskCount;                                 //0x2b8
	ULONG DefaultThreadpoolThreadMaximum;                                   //0x2bc
}; static_assert ( sizeof( RTL_USER_PROCESS_PARAMETERS ) == 0x440 );

struct RTL_BALANCED_NODE
{
	union
	{
		struct RTL_BALANCED_NODE* Children[ 2 ];                             //0x0
		struct
		{
			struct RTL_BALANCED_NODE* Left;                                //0x0
			struct RTL_BALANCED_NODE* Right;                               //0x8
		};
	};
	union
	{
		struct
		{
			UCHAR Red : 1;                                                    //0x10
			UCHAR Balance : 2;                                                //0x10
		};
		ULONGLONG ParentValue;                                              //0x10
	};
}; static_assert ( sizeof( RTL_BALANCED_NODE ) == 0x18 );

struct _PEB
{
	UCHAR InheritedAddressSpace;                                            //0x0
	UCHAR ReadImageFileExecOptions;                                         //0x1
	UCHAR BeingDebugged;                                                    //0x2
	union
	{
		UCHAR BitField;                                                     //0x3
		struct
		{
			UCHAR ImageUsesLargePages : 1;                                    //0x3
			UCHAR IsProtectedProcess : 1;                                     //0x3
			UCHAR IsImageDynamicallyRelocated : 1;                            //0x3
			UCHAR SkipPatchingUser32Forwarders : 1;                           //0x3
			UCHAR IsPackagedProcess : 1;                                      //0x3
			UCHAR IsAppContainer : 1;                                         //0x3
			UCHAR IsProtectedProcessLight : 1;                                //0x3
			UCHAR IsLongPathAwareProcess : 1;                                 //0x3
		};
	};
	UCHAR Padding0[ 4 ];                                                      //0x4
	VOID* Mutant;                                                           //0x8
	VOID* ImageBaseAddress;                                                 //0x10
	struct PEB_LDR_DATA* Ldr;                                              //0x18
	struct _RTL_USER_PROCESS_PARAMETERS* ProcessParameters;                 //0x20
	VOID* SubSystemData;                                                    //0x28
	VOID* ProcessHeap;                                                      //0x30
	struct _RTL_CRITICAL_SECTION* FastPebLock;                              //0x38
	union _SLIST_HEADER* volatile AtlThunkSListPtr;                         //0x40
	VOID* IFEOKey;                                                          //0x48
	union
	{
		ULONG CrossProcessFlags;                                            //0x50
		struct
		{
			ULONG ProcessInJob : 1;                                           //0x50
			ULONG ProcessInitializing : 1;                                    //0x50
			ULONG ProcessUsingVEH : 1;                                        //0x50
			ULONG ProcessUsingVCH : 1;                                        //0x50
			ULONG ProcessUsingFTH : 1;                                        //0x50
			ULONG ProcessPreviouslyThrottled : 1;                             //0x50
			ULONG ProcessCurrentlyThrottled : 1;                              //0x50
			ULONG ProcessImagesHotPatched : 1;                                //0x50
			ULONG ReservedBits0 : 24;                                         //0x50
		};
	};
	UCHAR Padding1[ 4 ];                                                      //0x54
	union
	{
		VOID* KernelCallbackTable;                                          //0x58
		VOID* UserSharedInfoPtr;                                            //0x58
	};
	ULONG SystemReserved;                                                   //0x60
	ULONG AtlThunkSListPtr32;                                               //0x64
	VOID* ApiSetMap;                                                        //0x68
	ULONG TlsExpansionCounter;                                              //0x70
	UCHAR Padding2[ 4 ];                                                      //0x74
	VOID* TlsBitmap;                                                        //0x78
	ULONG TlsBitmapBits[ 2 ];                                                 //0x80
	VOID* ReadOnlySharedMemoryBase;                                         //0x88
	VOID* SharedData;                                                       //0x90
	VOID** ReadOnlyStaticServerData;                                        //0x98
	VOID* AnsiCodePageData;                                                 //0xa0
	VOID* OemCodePageData;                                                  //0xa8
	VOID* UnicodeCaseTableData;                                             //0xb0
	ULONG NumberOfProcessors;                                               //0xb8
	ULONG NtGlobalFlag;                                                     //0xbc
	union _LARGE_INTEGER CriticalSectionTimeout;                            //0xc0
	ULONGLONG HeapSegmentReserve;                                           //0xc8
	ULONGLONG HeapSegmentCommit;                                            //0xd0
	ULONGLONG HeapDeCommitTotalFreeThreshold;                               //0xd8
	ULONGLONG HeapDeCommitFreeBlockThreshold;                               //0xe0
	ULONG NumberOfHeaps;                                                    //0xe8
	ULONG MaximumNumberOfHeaps;                                             //0xec
	VOID** ProcessHeaps;                                                    //0xf0
	VOID* GdiSharedHandleTable;                                             //0xf8
	VOID* ProcessStarterHelper;                                             //0x100
	ULONG GdiDCAttributeList;                                               //0x108
	UCHAR Padding3[ 4 ];                                                      //0x10c
	struct _RTL_CRITICAL_SECTION* LoaderLock;                               //0x110
	ULONG OSMajorVersion;                                                   //0x118
	ULONG OSMinorVersion;                                                   //0x11c
	USHORT OSBuildNumber;                                                   //0x120
	USHORT OSCSDVersion;                                                    //0x122
	ULONG OSPlatformId;                                                     //0x124
	ULONG ImageSubsystem;                                                   //0x128
	ULONG ImageSubsystemMajorVersion;                                       //0x12c
	ULONG ImageSubsystemMinorVersion;                                       //0x130
	UCHAR Padding4[ 4 ];                                                      //0x134
	ULONGLONG ActiveProcessAffinityMask;                                    //0x138
	ULONG GdiHandleBuffer[ 60 ];                                              //0x140
	VOID( *PostProcessInitRoutine )( );                                       //0x230
	VOID* TlsExpansionBitmap;                                               //0x238
	ULONG TlsExpansionBitmapBits[ 32 ];                                       //0x240
	ULONG SessionId;                                                        //0x2c0
	UCHAR Padding5[ 4 ];                                                      //0x2c4
	union _ULARGE_INTEGER AppCompatFlags;                                   //0x2c8
	union _ULARGE_INTEGER AppCompatFlagsUser;                               //0x2d0
	VOID* pShimData;                                                        //0x2d8
	VOID* AppCompatInfo;                                                    //0x2e0
	struct UNICODE_STRING CSDVersion;                                      //0x2e8
	struct _ACTIVATION_CONTEXT_DATA* ActivationContextData;                 //0x2f8
	struct _ASSEMBLY_STORAGE_MAP* ProcessAssemblyStorageMap;                //0x300
	struct _ACTIVATION_CONTEXT_DATA* SystemDefaultActivationContextData;    //0x308
	struct _ASSEMBLY_STORAGE_MAP* SystemAssemblyStorageMap;                 //0x310
	ULONGLONG MinimumStackCommit;                                           //0x318
	VOID* SparePointers[ 4 ];                                                 //0x320
	ULONG SpareUlongs[ 5 ];                                                   //0x340
	VOID* WerRegistrationData;                                              //0x358
	VOID* WerShipAssertPtr;                                                 //0x360
	VOID* pUnused;                                                          //0x368
	VOID* pImageHeaderHash;                                                 //0x370
	union
	{
		ULONG TracingFlags;                                                 //0x378
		struct
		{
			ULONG HeapTracingEnabled : 1;                                     //0x378
			ULONG CritSecTracingEnabled : 1;                                  //0x378
			ULONG LibLoaderTracingEnabled : 1;                                //0x378
			ULONG SpareTracingBits : 29;                                      //0x378
		};
	};
	UCHAR Padding6[ 4 ];                                                      //0x37c
	ULONGLONG CsrServerReadOnlySharedMemoryBase;                            //0x380
	ULONGLONG TppWorkerpListLock;                                           //0x388
	struct _LIST_ENTRY TppWorkerpList;                                      //0x390
	VOID* WaitOnAddressHashTable[ 128 ];                                      //0x3a0
	VOID* TelemetryCoverageHeader;                                          //0x7a0
	ULONG CloudFileFlags;                                                   //0x7a8
	ULONG CloudFileDiagFlags;                                               //0x7ac
	CHAR PlaceholderCompatibilityMode;                                      //0x7b0
	CHAR PlaceholderCompatibilityModeReserved[ 7 ];                           //0x7b1
	struct _LEAP_SECOND_DATA* LeapSecondData;                               //0x7b8
	union
	{
		ULONG LeapSecondFlags;                                              //0x7c0
		struct
		{
			ULONG SixtySecondEnabled : 1;                                     //0x7c0
			ULONG Reserved : 31;                                              //0x7c0
		};
	};
	ULONG NtGlobalFlag2;                                                    //0x7c4
}; static_assert ( sizeof( _PEB ) == 0x7c8 );

struct LDR_DATA_TABLE_ENTRY
{
	struct _LIST_ENTRY InLoadOrderLinks;                                    //0x0
	struct _LIST_ENTRY InMemoryOrderLinks;                                  //0x10
	struct _LIST_ENTRY InInitializationOrderLinks;                          //0x20
	VOID* DllBase;                                                          //0x30
	VOID* EntryPoint;                                                       //0x38
	ULONG SizeOfImage;                                                      //0x40
	struct UNICODE_STRING FullDllName;                                     //0x48
	struct UNICODE_STRING BaseDllName;                                     //0x58
	union
	{
		UCHAR FlagGroup[ 4 ];                                                 //0x68
		ULONG Flags;                                                        //0x68
		struct
		{
			ULONG PackagedBinary : 1;                                         //0x68
			ULONG MarkedForRemoval : 1;                                       //0x68
			ULONG ImageDll : 1;                                               //0x68
			ULONG LoadNotificationsSent : 1;                                  //0x68
			ULONG TelemetryEntryProcessed : 1;                                //0x68
			ULONG ProcessStaticImport : 1;                                    //0x68
			ULONG InLegacyLists : 1;                                          //0x68
			ULONG InIndexes : 1;                                              //0x68
			ULONG ShimDll : 1;                                                //0x68
			ULONG InExceptionTable : 1;                                       //0x68
			ULONG ReservedFlags1 : 2;                                         //0x68
			ULONG LoadInProgress : 1;                                         //0x68
			ULONG LoadConfigProcessed : 1;                                    //0x68
			ULONG EntryProcessed : 1;                                         //0x68
			ULONG ProtectDelayLoad : 1;                                       //0x68
			ULONG ReservedFlags3 : 2;                                         //0x68
			ULONG DontCallForThreads : 1;                                     //0x68
			ULONG ProcessAttachCalled : 1;                                    //0x68
			ULONG ProcessAttachFailed : 1;                                    //0x68
			ULONG CorDeferredValidate : 1;                                    //0x68
			ULONG CorImage : 1;                                               //0x68
			ULONG DontRelocate : 1;                                           //0x68
			ULONG CorILOnly : 1;                                              //0x68
			ULONG ChpeImage : 1;                                              //0x68
			ULONG ReservedFlags5 : 2;                                         //0x68
			ULONG Redirected : 1;                                             //0x68
			ULONG ReservedFlags6 : 2;                                         //0x68
			ULONG CompatDatabaseProcessed : 1;                                //0x68
		};
	};
	USHORT ObsoleteLoadCount;                                               //0x6c
	USHORT TlsIndex;                                                        //0x6e
	struct _LIST_ENTRY HashLinks;                                           //0x70
	ULONG TimeDateStamp;                                                    //0x80
	struct _ACTIVATION_CONTEXT* EntryPointActivationContext;                //0x88
	VOID* Lock;                                                             //0x90
	struct _LDR_DDAG_NODE* DdagNode;                                        //0x98
	struct _LIST_ENTRY NodeModuleLink;                                      //0xa0
	struct _LDRP_LOAD_CONTEXT* LoadContext;                                 //0xb0
	VOID* ParentDllBase;                                                    //0xb8
	VOID* SwitchBackContext;                                                //0xc0
	struct RTL_BALANCED_NODE BaseAddressIndexNode;                         //0xc8
	struct RTL_BALANCED_NODE MappingInfoIndexNode;                         //0xe0
	ULONGLONG OriginalBase;                                                 //0xf8
	union _LARGE_INTEGER LoadTime;                                          //0x100
	ULONG BaseNameHashValue;                                                //0x108
	enum _LDR_DLL_LOAD_REASON LoadReason;                                   //0x10c
	ULONG ImplicitPathOptions;                                              //0x110
	ULONG ReferenceCount;                                                   //0x114
	ULONG DependentLoadFlags;                                               //0x118
	UCHAR SigningLevel;                                                     //0x11c
}; static_assert( sizeof( LDR_DATA_TABLE_ENTRY ) == 0x120 );
#else
struct PEB_LDR_DATA
{
	ULONG Length;                                                           //0x0
	UCHAR Initialized;                                                      //0x4
	VOID* SsHandle;                                                         //0x8
	struct _LIST_ENTRY InLoadOrderModuleList;                               //0xc
	struct _LIST_ENTRY InMemoryOrderModuleList;                             //0x14
	struct _LIST_ENTRY InInitializationOrderModuleList;                     //0x1c
	VOID* EntryInProgress;                                                  //0x24
	UCHAR ShutdownInProgress;                                               //0x28
	VOID* ShutdownThreadId;                                                 //0x2c
}; static_assert( sizeof( PEB_LDR_DATA ) == 0x30 );

struct UNICODE_STRING
{
	USHORT Length;                                                          //0x0
	USHORT MaximumLength;                                                   //0x2
	WCHAR* Buffer;                                                          //0x4
}; static_assert ( sizeof( UNICODE_STRING ) == 0x8 );

struct STRING
{
	USHORT Length;                                                          //0x0
	USHORT MaximumLength;                                                   //0x2
	CHAR* Buffer;                                                           //0x4
}; static_assert ( sizeof( STRING ) == 0x8 );

struct CURDIR
{
	struct UNICODE_STRING DosPath;                                         //0x0
	VOID* Handle;                                                           //0x8
}; static_assert ( sizeof( CURDIR ) == 0xc );

struct RTL_DRIVE_LETTER_CURDIR
{
	USHORT Flags;                                                           //0x0
	USHORT Length;                                                          //0x2
	ULONG TimeStamp;                                                        //0x4
	struct STRING DosPath;                                                 //0x8
}; static_assert ( sizeof( RTL_DRIVE_LETTER_CURDIR ) == 0x10 );

struct RTL_USER_PROCESS_PARAMETERS
{
	ULONG MaximumLength;                                                    //0x0
	ULONG Length;                                                           //0x4
	ULONG Flags;                                                            //0x8
	ULONG DebugFlags;                                                       //0xc
	VOID* ConsoleHandle;                                                    //0x10
	ULONG ConsoleFlags;                                                     //0x14
	VOID* StandardInput;                                                    //0x18
	VOID* StandardOutput;                                                   //0x1c
	VOID* StandardError;                                                    //0x20
	struct CURDIR CurrentDirectory;                                        //0x24
	struct UNICODE_STRING DllPath;                                         //0x30
	struct UNICODE_STRING ImagePathName;                                   //0x38
	struct UNICODE_STRING CommandLine;                                     //0x40
	VOID* Environment;                                                      //0x48
	ULONG StartingX;                                                        //0x4c
	ULONG StartingY;                                                        //0x50
	ULONG CountX;                                                           //0x54
	ULONG CountY;                                                           //0x58
	ULONG CountCharsX;                                                      //0x5c
	ULONG CountCharsY;                                                      //0x60
	ULONG FillAttribute;                                                    //0x64
	ULONG WindowFlags;                                                      //0x68
	ULONG ShowWindowFlags;                                                  //0x6c
	struct UNICODE_STRING WindowTitle;                                     //0x70
	struct UNICODE_STRING DesktopInfo;                                     //0x78
	struct UNICODE_STRING ShellInfo;                                       //0x80
	struct UNICODE_STRING RuntimeData;                                     //0x88
	struct RTL_DRIVE_LETTER_CURDIR CurrentDirectores[ 32 ];                  //0x90
	ULONG EnvironmentSize;                                                  //0x290
	ULONG EnvironmentVersion;                                               //0x294
	VOID* PackageDependencyData;                                            //0x298
	ULONG ProcessGroupId;                                                   //0x29c
	ULONG LoaderThreads;                                                    //0x2a0
	struct UNICODE_STRING RedirectionDllName;                              //0x2a4
	struct UNICODE_STRING HeapPartitionName;                               //0x2ac
	ULONGLONG* DefaultThreadpoolCpuSetMasks;                                //0x2b4
	ULONG DefaultThreadpoolCpuSetMaskCount;                                 //0x2b8
	ULONG DefaultThreadpoolThreadMaximum;                                   //0x2bc
}; static_assert ( sizeof( RTL_USER_PROCESS_PARAMETERS ) == 0x2c0 );

struct RTL_BALANCED_NODE
{
	union
	{
		struct RTL_BALANCED_NODE* Children[ 2 ];                             //0x0
		struct
		{
			struct RTL_BALANCED_NODE* Left;                                //0x0
			struct RTL_BALANCED_NODE* Right;                               //0x4
		};
	};
	union
	{
		struct
		{
			UCHAR Red : 1;                                                    //0x8
			UCHAR Balance : 2;                                                //0x8
		};
		ULONG ParentValue;                                                  //0x8
	};
}; static_assert ( sizeof( RTL_BALANCED_NODE ) == 0xc );

struct _PEB
{
	UCHAR InheritedAddressSpace;                                            //0x0
	UCHAR ReadImageFileExecOptions;                                         //0x1
	UCHAR BeingDebugged;                                                    //0x2
	union
	{
		UCHAR BitField;                                                     //0x3
		struct
		{
			UCHAR ImageUsesLargePages : 1;                                    //0x3
			UCHAR IsProtectedProcess : 1;                                     //0x3
			UCHAR IsImageDynamicallyRelocated : 1;                            //0x3
			UCHAR SkipPatchingUser32Forwarders : 1;                           //0x3
			UCHAR IsPackagedProcess : 1;                                      //0x3
			UCHAR IsAppContainer : 1;                                         //0x3
			UCHAR IsProtectedProcessLight : 1;                                //0x3
			UCHAR IsLongPathAwareProcess : 1;                                 //0x3
		};
	};
	VOID* Mutant;                                                           //0x4
	VOID* ImageBaseAddress;                                                 //0x8
	struct PEB_LDR_DATA* Ldr;                                              //0xc
	struct _RTL_USER_PROCESS_PARAMETERS* ProcessParameters;                 //0x10
	VOID* SubSystemData;                                                    //0x14
	VOID* ProcessHeap;                                                      //0x18
	struct _RTL_CRITICAL_SECTION* FastPebLock;                              //0x1c
	union _SLIST_HEADER* volatile AtlThunkSListPtr;                         //0x20
	VOID* IFEOKey;                                                          //0x24
	union
	{
		ULONG CrossProcessFlags;                                            //0x28
		struct
		{
			ULONG ProcessInJob : 1;                                           //0x28
			ULONG ProcessInitializing : 1;                                    //0x28
			ULONG ProcessUsingVEH : 1;                                        //0x28
			ULONG ProcessUsingVCH : 1;                                        //0x28
			ULONG ProcessUsingFTH : 1;                                        //0x28
			ULONG ProcessPreviouslyThrottled : 1;                             //0x28
			ULONG ProcessCurrentlyThrottled : 1;                              //0x28
			ULONG ProcessImagesHotPatched : 1;                                //0x28
			ULONG ReservedBits0 : 24;                                         //0x28
		};
	};
	union
	{
		VOID* KernelCallbackTable;                                          //0x2c
		VOID* UserSharedInfoPtr;                                            //0x2c
	};
	ULONG SystemReserved;                                                   //0x30
	union _SLIST_HEADER* volatile AtlThunkSListPtr32;                       //0x34
	VOID* ApiSetMap;                                                        //0x38
	ULONG TlsExpansionCounter;                                              //0x3c
	VOID* TlsBitmap;                                                        //0x40
	ULONG TlsBitmapBits[ 2 ];                                                 //0x44
	VOID* ReadOnlySharedMemoryBase;                                         //0x4c
	VOID* SharedData;                                                       //0x50
	VOID** ReadOnlyStaticServerData;                                        //0x54
	VOID* AnsiCodePageData;                                                 //0x58
	VOID* OemCodePageData;                                                  //0x5c
	VOID* UnicodeCaseTableData;                                             //0x60
	ULONG NumberOfProcessors;                                               //0x64
	ULONG NtGlobalFlag;                                                     //0x68
	union _LARGE_INTEGER CriticalSectionTimeout;                            //0x70
	ULONG HeapSegmentReserve;                                               //0x78
	ULONG HeapSegmentCommit;                                                //0x7c
	ULONG HeapDeCommitTotalFreeThreshold;                                   //0x80
	ULONG HeapDeCommitFreeBlockThreshold;                                   //0x84
	ULONG NumberOfHeaps;                                                    //0x88
	ULONG MaximumNumberOfHeaps;                                             //0x8c
	VOID** ProcessHeaps;                                                    //0x90
	VOID* GdiSharedHandleTable;                                             //0x94
	VOID* ProcessStarterHelper;                                             //0x98
	ULONG GdiDCAttributeList;                                               //0x9c
	struct _RTL_CRITICAL_SECTION* LoaderLock;                               //0xa0
	ULONG OSMajorVersion;                                                   //0xa4
	ULONG OSMinorVersion;                                                   //0xa8
	USHORT OSBuildNumber;                                                   //0xac
	USHORT OSCSDVersion;                                                    //0xae
	ULONG OSPlatformId;                                                     //0xb0
	ULONG ImageSubsystem;                                                   //0xb4
	ULONG ImageSubsystemMajorVersion;                                       //0xb8
	ULONG ImageSubsystemMinorVersion;                                       //0xbc
	ULONG ActiveProcessAffinityMask;                                        //0xc0
	ULONG GdiHandleBuffer[ 34 ];                                              //0xc4
	VOID( *PostProcessInitRoutine )( );                                       //0x14c
	VOID* TlsExpansionBitmap;                                               //0x150
	ULONG TlsExpansionBitmapBits[ 32 ];                                       //0x154
	ULONG SessionId;                                                        //0x1d4
	union _ULARGE_INTEGER AppCompatFlags;                                   //0x1d8
	union _ULARGE_INTEGER AppCompatFlagsUser;                               //0x1e0
	VOID* pShimData;                                                        //0x1e8
	VOID* AppCompatInfo;                                                    //0x1ec
	struct UNICODE_STRING CSDVersion;                                      //0x1f0
	struct _ACTIVATION_CONTEXT_DATA* ActivationContextData;                 //0x1f8
	struct _ASSEMBLY_STORAGE_MAP* ProcessAssemblyStorageMap;                //0x1fc
	struct _ACTIVATION_CONTEXT_DATA* SystemDefaultActivationContextData;    //0x200
	struct _ASSEMBLY_STORAGE_MAP* SystemAssemblyStorageMap;                 //0x204
	ULONG MinimumStackCommit;                                               //0x208
	VOID* SparePointers[ 4 ];                                                 //0x20c
	ULONG SpareUlongs[ 5 ];                                                   //0x21c
	VOID* WerRegistrationData;                                              //0x230
	VOID* WerShipAssertPtr;                                                 //0x234
	VOID* pUnused;                                                          //0x238
	VOID* pImageHeaderHash;                                                 //0x23c
	union
	{
		ULONG TracingFlags;                                                 //0x240
		struct
		{
			ULONG HeapTracingEnabled : 1;                                     //0x240
			ULONG CritSecTracingEnabled : 1;                                  //0x240
			ULONG LibLoaderTracingEnabled : 1;                                //0x240
			ULONG SpareTracingBits : 29;                                      //0x240
		};
	};
	ULONGLONG CsrServerReadOnlySharedMemoryBase;                            //0x248
	ULONG TppWorkerpListLock;                                               //0x250
	struct _LIST_ENTRY TppWorkerpList;                                      //0x254
	VOID* WaitOnAddressHashTable[ 128 ];                                      //0x25c
	VOID* TelemetryCoverageHeader;                                          //0x45c
	ULONG CloudFileFlags;                                                   //0x460
	ULONG CloudFileDiagFlags;                                               //0x464
	CHAR PlaceholderCompatibilityMode;                                      //0x468
	CHAR PlaceholderCompatibilityModeReserved[ 7 ];                           //0x469
	struct _LEAP_SECOND_DATA* LeapSecondData;                               //0x470
	union
	{
		ULONG LeapSecondFlags;                                              //0x474
		struct
		{
			ULONG SixtySecondEnabled : 1;                                     //0x474
			ULONG Reserved : 31;                                              //0x474
		};
	};
	ULONG NtGlobalFlag2;                                                    //0x478
}; static_assert ( sizeof( _PEB ) == 0x480 );

union __LARGE_INTEGER
{
	struct
	{
		ULONG LowPart;                                                      //0x0
		LONG HighPart;                                                      //0x4
	};
	struct
	{
		ULONG LowPart;                                                      //0x0
		LONG HighPart;                                                      //0x4
	} u;                                                                    //0x0
	LONGLONG QuadPart;                                                      //0x0
}; static_assert( sizeof( __LARGE_INTEGER ) == 0x8 );

struct LDR_DATA_TABLE_ENTRY
{
	struct _LIST_ENTRY InLoadOrderLinks;                                    //0x0
	struct _LIST_ENTRY InMemoryOrderLinks;                                  //0x8
	struct _LIST_ENTRY InInitializationOrderLinks;                          //0x10
	VOID* DllBase;                                                          //0x18
	VOID* EntryPoint;                                                       //0x1c
	ULONG SizeOfImage;                                                      //0x20
	struct UNICODE_STRING FullDllName;                                     //0x24
	struct UNICODE_STRING BaseDllName;                                     //0x2c
	union
	{
		UCHAR FlagGroup[ 4 ];                                                 //0x34
		ULONG Flags;                                                        //0x34
		struct
		{
			ULONG PackagedBinary : 1;                                         //0x34
			ULONG MarkedForRemoval : 1;                                       //0x34
			ULONG ImageDll : 1;                                               //0x34
			ULONG LoadNotificationsSent : 1;                                  //0x34
			ULONG TelemetryEntryProcessed : 1;                                //0x34
			ULONG ProcessStaticImport : 1;                                    //0x34
			ULONG InLegacyLists : 1;                                          //0x34
			ULONG InIndexes : 1;                                              //0x34
			ULONG ShimDll : 1;                                                //0x34
			ULONG InExceptionTable : 1;                                       //0x34
			ULONG ReservedFlags1 : 2;                                         //0x34
			ULONG LoadInProgress : 1;                                         //0x34
			ULONG LoadConfigProcessed : 1;                                    //0x34
			ULONG EntryProcessed : 1;                                         //0x34
			ULONG ProtectDelayLoad : 1;                                       //0x34
			ULONG ReservedFlags3 : 2;                                         //0x34
			ULONG DontCallForThreads : 1;                                     //0x34
			ULONG ProcessAttachCalled : 1;                                    //0x34
			ULONG ProcessAttachFailed : 1;                                    //0x34
			ULONG CorDeferredValidate : 1;                                    //0x34
			ULONG CorImage : 1;                                               //0x34
			ULONG DontRelocate : 1;                                           //0x34
			ULONG CorILOnly : 1;                                              //0x34
			ULONG ChpeImage : 1;                                              //0x34
			ULONG ReservedFlags5 : 2;                                         //0x34
			ULONG Redirected : 1;                                             //0x34
			ULONG ReservedFlags6 : 2;                                         //0x34
			ULONG CompatDatabaseProcessed : 1;                                //0x34
		};
	};
	USHORT ObsoleteLoadCount;                                               //0x38
	USHORT TlsIndex;                                                        //0x3a
	struct _LIST_ENTRY HashLinks;                                           //0x3c
	ULONG TimeDateStamp;                                                    //0x44
	struct _ACTIVATION_CONTEXT* EntryPointActivationContext;                //0x48
	VOID* Lock;                                                             //0x4c
	struct _LDR_DDAG_NODE* DdagNode;                                        //0x50
	struct _LIST_ENTRY NodeModuleLink;                                      //0x54
	struct _LDRP_LOAD_CONTEXT* LoadContext;                                 //0x5c
	VOID* ParentDllBase;                                                    //0x60
	VOID* SwitchBackContext;                                                //0x64
	struct RTL_BALANCED_NODE BaseAddressIndexNode;                         //0x68
	struct RTL_BALANCED_NODE MappingInfoIndexNode;                         //0x74
	ULONG OriginalBase;                                                     //0x80
	union __LARGE_INTEGER LoadTime;                                          //0x88
	ULONG BaseNameHashValue;                                                //0x90
	enum _LDR_DLL_LOAD_REASON LoadReason;                                   //0x94
	ULONG ImplicitPathOptions;                                              //0x98
	ULONG ReferenceCount;                                                   //0x9c
	ULONG DependentLoadFlags;                                               //0xa0
	UCHAR SigningLevel;                                                     //0xa4
}; static_assert ( sizeof( LDR_DATA_TABLE_ENTRY ) == 0xa8 );
#endif
```

`ac_module/util.h`:

```h
#pragma once

#include <vector>
#include <cstdint>
#include <sstream>
#include <fstream>
#include <memoryapi.h>
#include <functional>

#include <filesystem>
#include <fstream>

struct checksum_region
{
	uintptr_t start, checksum;
	size_t size;
	char name[ 16 ];
	bool reported;
};

namespace util
{
	inline void walk_ldr_list( const std::function<void( LDR_DATA_TABLE_ENTRY* )>& callback )
	{
#ifdef _WIN64
		const auto peb = reinterpret_cast< _PEB* >( __readgsqword( 0x60 ) );
#else
		const auto peb = reinterpret_cast< _PEB* >( __readfsdword( 0x30 ) );
#endif

		const auto list_head = &peb->Ldr->InMemoryOrderModuleList;
		for ( auto it = list_head->Flink; it != list_head; it = it->Flink )
		{
			const auto ldr_entry = CONTAINING_RECORD( it, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks );
			if ( !ldr_entry )
				continue;

			callback( ldr_entry );
		}
	}

	inline void dump_to_file( const uintptr_t address, const char* prefix )
	{
		std::stringstream file_name;
		file_name << "memory_dump_" << std::hex << address << ".bin";

		std::ofstream dump_file( file_name.str(), std::ios::binary );
		if ( !dump_file )
		{
			printf( "%sfailed to open dump file\n", prefix ? prefix : "" );
			return;
		}

		MEMORY_BASIC_INFORMATION mbi = { 0 };
		uintptr_t current = address;

		while ( VirtualQuery( ( LPCVOID ) current, &mbi, sizeof( mbi ) ) )
		{
			if ( mbi.AllocationBase != ( PVOID ) address || mbi.State == MEM_RESERVE )
				break;

			std::vector<std::byte> buffer( mbi.RegionSize );
			memcpy( buffer.data(), ( const void* ) current, mbi.RegionSize );

			dump_file.write( reinterpret_cast< const char* >( buffer.data() ), mbi.RegionSize );

			current += mbi.RegionSize;
		}

		printf( "%ssuccessfully dumped to file: %s\n", prefix ? prefix : "", file_name.str().c_str() );

		dump_file.close();
	}

	inline std::vector<checksum_region> compute_file_checksums( LPCWSTR filepath, uintptr_t image_base )
	{
		std::vector<checksum_region> checksum_regions{};

		std::basic_ifstream<std::byte> file_stream( filepath, std::ios::binary );
		if ( !file_stream )
		{
			printf( "[!] failed to open file stream to %ls\n", filepath );
			return checksum_regions;
		}

		const std::vector<std::byte> disk_image = { std::istreambuf_iterator<std::byte>( file_stream ), std::istreambuf_iterator<std::byte>() };

		const auto dos = ( IMAGE_DOS_HEADER* ) disk_image.data();
		if ( !dos || dos->e_magic != IMAGE_DOS_SIGNATURE )
		{
			printf( "[!] invalid dos header for disk_image image %ls\n", filepath );
			return checksum_regions;
		}

		const auto nt = ( IMAGE_NT_HEADERS* ) ( ( uintptr_t ) dos + dos->e_lfanew );
		if ( !nt || nt->Signature != IMAGE_NT_SIGNATURE )
		{
			printf( "[!] invalid nt headers for disk_image image %ls\n", filepath );
			return checksum_regions;
		}

		std::vector<std::byte> virtual_image( nt->OptionalHeader.SizeOfImage );

		memcpy( virtual_image.data(), disk_image.data(), nt->OptionalHeader.SizeOfHeaders );

		const auto section_header = IMAGE_FIRST_SECTION( nt );
		for ( WORD i = 0; i < nt->FileHeader.NumberOfSections; i++ )
		{
			memcpy( virtual_image.data() + section_header[ i ].VirtualAddress,
				disk_image.data() + section_header[ i ].PointerToRawData,
				section_header[ i ].SizeOfRawData );
		}

		auto virtual_nt = ( IMAGE_NT_HEADERS* ) ( virtual_image.data() + dos->e_lfanew );

		virtual_nt->OptionalHeader.ImageBase = image_base;

		checksum_region header_checksum{};

		header_checksum.start = image_base;
		header_checksum.size = nt->OptionalHeader.SizeOfHeaders;
		strcpy( header_checksum.name, "header" );

		for ( DWORD i = 0; i < nt->OptionalHeader.SizeOfHeaders; i++ )
			header_checksum.checksum += ( uintptr_t ) virtual_image.data()[ i ];

		checksum_regions.emplace_back( header_checksum );

		const auto delta = image_base - nt->OptionalHeader.ImageBase;

		auto relocation_block = ( IMAGE_BASE_RELOCATION* ) ( virtual_image.data() + nt->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_BASERELOC ].VirtualAddress );
		const auto relocation_end = ( uintptr_t ) ( ( uintptr_t ) relocation_block + nt->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_BASERELOC ].Size );
		while ( ( uintptr_t ) relocation_block < relocation_end )
		{
			const auto block_entries = ( relocation_block->SizeOfBlock - sizeof( IMAGE_BASE_RELOCATION ) ) >> 1;

			for ( size_t i = 0; i < block_entries; i++ )
			{
				const auto block_entry = ( ( reloc_entry* ) ( relocation_block + 1 ) )[ i ];

				if ( block_entry.type == IMAGE_REL_BASED_HIGHLOW || block_entry.type == IMAGE_REL_BASED_DIR64 )
				{
					uintptr_t* absolute_address = ( uintptr_t* ) ( virtual_image.data() + relocation_block->VirtualAddress + block_entry.offset );
					*absolute_address += delta;
				}
			}

			relocation_block = ( IMAGE_BASE_RELOCATION* ) ( ( uintptr_t ) relocation_block + relocation_block->SizeOfBlock );
		}

		for ( WORD i = 0; i < nt->FileHeader.NumberOfSections; i++ )
		{
			if ( !memcmp( section_header[ i ].Name, ".text", 5 )/* || !memcmp( section_header[ i ].Name, ".rdata", 6 )*/ )
			{
				checksum_region section_checksum{};

				section_checksum.start = image_base + section_header[ i ].VirtualAddress;
				section_checksum.size = section_header[ i ].SizeOfRawData;
				strcpy( section_checksum.name, ( const char* ) section_header[ i ].Name );

				for ( DWORD j = 0; j < section_header[ i ].SizeOfRawData; j++ )
					section_checksum.checksum += ( uintptr_t ) virtual_image.data()[ section_header[ i ].VirtualAddress + j ];

				checksum_regions.emplace_back( section_checksum );
			}
		}

		return checksum_regions;
	}

	inline void* resolve_export( PBYTE base, const char* target_name )
	{
		if ( !base || !target_name )
			return nullptr;

		auto dos = ( PIMAGE_DOS_HEADER ) base;
		if ( dos->e_magic != IMAGE_DOS_SIGNATURE )
			return nullptr;

		auto nt = ( PIMAGE_NT_HEADERS ) ( base + dos->e_lfanew );
		if ( nt->Signature != IMAGE_NT_SIGNATURE )
			return nullptr;

		auto& export_data = nt->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_EXPORT ];
		if ( !export_data.VirtualAddress || !export_data.Size )
			return nullptr;

		auto export_dir = ( PIMAGE_EXPORT_DIRECTORY ) ( base + export_data.VirtualAddress );

		auto func_table = ( uint32_t* ) ( base + export_dir->AddressOfFunctions );
		auto name_table = ( uint32_t* ) ( base + export_dir->AddressOfNames );
		auto ord_table = ( uint16_t* ) ( base + export_dir->AddressOfNameOrdinals );

		for ( DWORD i = 0; i < export_dir->NumberOfNames; ++i )
		{
			const char* export_name = ( char* ) base + name_table[ i ];

			if ( _stricmp( export_name, target_name ) == 0 )
			{
				PBYTE func_addr = base + func_table[ ord_table[ i ] ];

				if ( func_addr >= ( PBYTE ) export_dir &&
					func_addr < ( PBYTE ) export_dir + export_data.Size )
				{
					// forwarded export
					return nullptr;
				}

				return func_addr;
			}
		}

		return nullptr;
	}

}
```

`anti-cheat.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.2.32526.322
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ac_module", "ac_module\ac_module.vcxproj", "{3C8CE0DD-3BEC-4BD4-8127-6201CA699E74}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ac_external", "ac_external\ac_external.vcxproj", "{03ED3A37-EC5E-4DDE-8AF1-E6ACF3AC2CDE}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{3C8CE0DD-3BEC-4BD4-8127-6201CA699E74}.Debug|x64.ActiveCfg = Debug|x64
		{3C8CE0DD-3BEC-4BD4-8127-6201CA699E74}.Debug|x64.Build.0 = Debug|x64
		{3C8CE0DD-3BEC-4BD4-8127-6201CA699E74}.Debug|x86.ActiveCfg = Debug|Win32
		{3C8CE0DD-3BEC-4BD4-8127-6201CA699E74}.Debug|x86.Build.0 = Debug|Win32
		{3C8CE0DD-3BEC-4BD4-8127-6201CA699E74}.Release|x64.ActiveCfg = Release|x64
		{3C8CE0DD-3BEC-4BD4-8127-6201CA699E74}.Release|x64.Build.0 = Release|x64
		{3C8CE0DD-3BEC-4BD4-8127-6201CA699E74}.Release|x86.ActiveCfg = Release|Win32
		{3C8CE0DD-3BEC-4BD4-8127-6201CA699E74}.Release|x86.Build.0 = Release|Win32
		{03ED3A37-EC5E-4DDE-8AF1-E6ACF3AC2CDE}.Debug|x64.ActiveCfg = Debug|x64
		{03ED3A37-EC5E-4DDE-8AF1-E6ACF3AC2CDE}.Debug|x64.Build.0 = Debug|x64
		{03ED3A37-EC5E-4DDE-8AF1-E6ACF3AC2CDE}.Debug|x86.ActiveCfg = Debug|Win32
		{03ED3A37-EC5E-4DDE-8AF1-E6ACF3AC2CDE}.Debug|x86.Build.0 = Debug|Win32
		{03ED3A37-EC5E-4DDE-8AF1-E6ACF3AC2CDE}.Release|x64.ActiveCfg = Release|x64
		{03ED3A37-EC5E-4DDE-8AF1-E6ACF3AC2CDE}.Release|x64.Build.0 = Release|x64
		{03ED3A37-EC5E-4DDE-8AF1-E6ACF3AC2CDE}.Release|x86.ActiveCfg = Release|Win32
		{03ED3A37-EC5E-4DDE-8AF1-E6ACF3AC2CDE}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {E14AC698-8E6B-422D-B86E-797F487EBF64}
	EndGlobalSection
EndGlobal

```