Project Path: arc_FourCoreLabs_LolDriverScan_2dl4jxxk

Source Tree:

```txt
arc_FourCoreLabs_LolDriverScan_2dl4jxxk
├── LICENSE
├── README.md
├── go.mod
├── go.sum
├── internal
│   ├── api.go
│   ├── drivers.go
│   └── helpers.go
└── loldriverscan.go

```

`LICENSE`:

```
MIT License

Copyright (c) 2023 FourCore Labs Private Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# LolDriverScan

LolDriverScan is a golang tool that allows users to discover vulnerable drivers on their system.
This tool fetches the [loldrivers.io](https://www.loldrivers.io/) list from their APIs and scans the system for any vulnerable drivers
This project is implemented in Go and does not require elevated privileges to run.

## Features

- Scans the system for vulnerable drivers
- Provides verbose output for detailed information
- Supports JSON output for easy integration with other tools
- No elevated privileges are required

## Installation

### Release

Download the latest auto-generated release binary from [GitHub Releases](https://github.com/FourCoreLabs/LolDriverScan/releases). 

### Build

1. Make sure you have Go installed on your system. If not, you can download and install it from the official [Go website](https://golang.org/dl/)

2. Clone the [LolDriverScan](https://github.com/FourCoreLabs/LolDriverScan) project repository:

   ```shell
   git clone https://github.com/FourCoreLabs/LolDriverScan.git
   ```

3. Change into the project directory:

   ```shell
   cd LolDriverScan
   ```

4. Build the project
   ```shell
   go build
   ```

## Usage
Run the loldriverscan binary with the following command-line arguments:

   ```shell
   .\loldriverscan.exe [-v] [--json <filepath>]
   ```

-v or --verbose: Enable verbose mode for detailed output.  
--json <filepath>: Specify a filepath to save the output in JSON format. Use - to output to stdout.

## Examples

* Run the tool with verbose mode enabled:
   ```shell
   .\loldriverscan.exe -v
   ```

* Run the tool and save the output in a JSON file:
   ```shell
   .\loldriverscan.exe -json .\drivers.json
   ```

* Run the tool and output the JSON result to stdout:
   ```shell
   .\loldriverscan.exe -json -
   ```

## Contributing
Contributions are welcome! If you find any issues or have suggestions for improvements, please open an issue or submit a pull request.

```

`go.mod`:

```mod
module loldriverscan

go 1.20

require (
	github.com/Binject/debug v0.0.0-20230508195519-26db73212a7a
	golang.org/x/sys v0.10.0
)

require (
	github.com/edsrzf/mmap-go v1.1.0 // indirect
	github.com/saferwall/pe v1.4.4 // indirect
	go.mozilla.org/pkcs7 v0.0.0-20210826202110-33d05740a352 // indirect
	golang.org/x/text v0.11.0 // indirect
)

```

`go.sum`:

```sum
github.com/Binject/debug v0.0.0-20230508195519-26db73212a7a h1:4c0nc0krv8eh7gD809n+swLaCuFyHpxdrxwx0ZmHvBw=
github.com/Binject/debug v0.0.0-20230508195519-26db73212a7a/go.mod h1:QzgxDLY/qdKlvnbnb65eqTedhvQPbaSP2NqIbcuKvsQ=
github.com/edsrzf/mmap-go v1.1.0 h1:6EUwBLQ/Mcr1EYLE4Tn1VdW1A4ckqCQWZBw8Hr0kjpQ=
github.com/edsrzf/mmap-go v1.1.0/go.mod h1:19H/e8pUPLicwkyNgOykDXkJ9F0MHE+Z52B8EIth78Q=
github.com/saferwall/pe v1.4.4 h1:Ml++7/2/Z1iKwV4zCsd1nIqTEAdUQKAetwbbcCarhOg=
github.com/saferwall/pe v1.4.4/go.mod h1:SNzv3cdgk8SBI0UwHfyTcdjawfdnN+nbydnEL7GZ25s=
github.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=
go.mozilla.org/pkcs7 v0.0.0-20210826202110-33d05740a352 h1:CCriYyAfq1Br1aIYettdHZTy8mBTIPo7We18TuO/bak=
go.mozilla.org/pkcs7 v0.0.0-20210826202110-33d05740a352/go.mod h1:SNgMg+EgDFwmvSmLRTNKC5fegJjB7v23qTQ0XLGUNHk=
golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
golang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=
golang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=
golang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=
golang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=
golang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20211216021012-1d35b9e2eb4e/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.10.0 h1:SqMFp9UcQJZa+pmYuAKjd9xq1f0j5rLcDIk0mj4qAsA=
golang.org/x/sys v0.10.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=
golang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=
golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
golang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=
golang.org/x/text v0.7.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=
golang.org/x/text v0.11.0 h1:LAntKIrcmeSKERyiOh0XMV39LXS8IE9UL2yP7+f5ij4=
golang.org/x/text v0.11.0/go.mod h1:TvPlkZtksWOMsz7fbANvkp4WM8x/WCo/om8BMLbz+aE=
golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=
golang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=

```

`internal/api.go`:

```go
package pkg

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strings"
)

const (
	lolDriversApiUrl = `https://www.loldrivers.io/api/drivers.json`
)

type Authentihash struct {
	MD5    string `json:"SHA1"`
	Sha1   string `json:"MD5"`
	Sha256 string `json:"SHA256"`
}

type lolDriversApiResponse []struct {
	ID       string `json:"Id"`
	Category string `json:"Category"`
	Samples  []struct {
		Filename         string       `json:"Filename"`
		MD5              string       `json:"SHA1"`
		Sha1             string       `json:"MD5"`
		Sha256           string       `json:"SHA256"`
		OriginalFilename string       `json:"OriginalFilename"`
		Authentihash     Authentihash `json:"Authentihash"`
	} `json:"KnownVulnerableSamples"`
	Cve  []string `json:"CVE,omitempty"`
	CVEs []string `json:"CVEs,omitempty"`
}

type LolDriver struct {
	Filename     string       `json:"filename,omitempty"`
	Path         string       `json:"path,omitempty"`
	Status       string       `json:"status,omitempty"`
	Malicious    bool         `json:"malicious"`
	MD5          string       `json:"md5,omitempty"`
	Sha1         string       `json:"sha1,omitempty"`
	Sha256       string       `json:"sha256,omitempty"`
	ID           string       `json:"id,omitempty"`
	CVEs         []string     `json:"cves,omitempty"`
	Authentihash Authentihash `json:"authentihash"`
}

type lolDrivers struct {
	md5Map    map[string]string
	sha1Map   map[string]string
	sha256Map map[string]string

	authentihashMd5Map    map[string]string
	authentihashSha1Map   map[string]string
	authentihashSha256Map map[string]string

	lolDriverMap map[string]LolDriver
}

func (ld *lolDrivers) FindDriver(h Hashes, authentihashes Hashes) (LolDriver, error) {
	var id string
	var ok bool

	if id, ok = ld.authentihashMd5Map[authentihashes.Md5]; !ok {
		if id, ok = ld.authentihashSha1Map[authentihashes.Sha1]; !ok {
			if id, ok = ld.authentihashSha256Map[authentihashes.Sha256]; !ok {

				// iderify Direct Hashes
				if id, ok = ld.sha256Map[h.Sha256]; !ok {
					if id, ok = ld.sha1Map[h.Sha1]; !ok {
						if id, ok = ld.md5Map[h.Md5]; !ok {
							return LolDriver{}, fmt.Errorf("no matching driver")
						}
					}
				}

			}
		}
	}

	lolDriver := ld.lolDriverMap[id]

	lolDriver.MD5 = h.Md5
	lolDriver.Sha1 = h.Sha1
	lolDriver.Sha256 = h.Sha256

	lolDriver.Authentihash.MD5 = authentihashes.Md5
	lolDriver.Authentihash.Sha1 = authentihashes.Sha1
	lolDriver.Authentihash.Sha256 = authentihashes.Sha256

	return lolDriver, nil
}

func fetchApiNormaliseData() ([]LolDriver, error) {
	resp, err := http.Get(lolDriversApiUrl)
	if err != nil {
		return nil, fmt.Errorf("error downloading drivers list from %v: %v", lolDriversApiUrl, err)
	}

	data, err := io.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, fmt.Errorf("error reading json drivers data from response: %v", err)
	}

	apiResponse := lolDriversApiResponse{}
	if err := json.Unmarshal(data, &apiResponse); err != nil {
		return nil, fmt.Errorf("error unmarshaling api json data: %v", err)
	}

	driversList := []LolDriver{}

	for _, ld := range apiResponse {
		for _, s := range ld.Samples {
			data := LolDriver{
				ID:           ld.ID,
				MD5:          strings.ToLower(s.MD5),
				Sha1:         strings.ToLower(s.Sha1),
				Sha256:       strings.ToLower(s.Sha256),
				CVEs:         append(ld.CVEs, ld.Cve...),
				Filename:     s.Filename,
				Malicious:    ld.Category == "malicious",
				Authentihash: s.Authentihash,
			}

			if s.OriginalFilename != "" {
				data.Filename = s.OriginalFilename
			}

			driversList = append(driversList, data)
		}
	}
	return driversList, nil
}

func CreateVulnerableDriverFinder() (*lolDrivers, error) {
	driverData, err := fetchApiNormaliseData()
	if err != nil {
		return nil, err
	}

	drivers := &lolDrivers{
		md5Map:                make(map[string]string),
		sha1Map:               make(map[string]string),
		sha256Map:             make(map[string]string),
		authentihashMd5Map:    make(map[string]string),
		authentihashSha1Map:   make(map[string]string),
		authentihashSha256Map: make(map[string]string),
		lolDriverMap:          make(map[string]LolDriver),
	}

	for _, dd := range driverData {
		drivers.lolDriverMap[dd.ID] = dd

		if dd.Sha256 != "" {
			drivers.sha256Map[dd.Sha256] = dd.ID
		} else if dd.Sha1 != "" {
			drivers.sha1Map[dd.Sha1] = dd.ID
		} else if dd.MD5 != "" {
			drivers.md5Map[dd.MD5] = dd.ID
		}

		if dd.Authentihash.MD5 != "" {
			drivers.authentihashMd5Map[dd.Authentihash.MD5] = dd.ID
		} else if dd.Authentihash.Sha1 != "" {
			drivers.authentihashSha1Map[dd.Authentihash.Sha1] = dd.ID
		} else if dd.Authentihash.Sha256 != "" {
			drivers.authentihashSha256Map[dd.Authentihash.Sha256] = dd.ID
		}
	}

	return drivers, nil
}

```

`internal/drivers.go`:

```go
package pkg

import (
	"unsafe"

	"golang.org/x/sys/windows"
	"golang.org/x/sys/windows/svc/mgr"
)

func ConnectToServiceManager() (*mgr.Mgr, error) {

	host := windows.StringToUTF16Ptr("")
	h, err := windows.OpenSCManager(host, nil, windows.SC_MANAGER_ENUMERATE_SERVICE)
	if err != nil {
		return nil, err
	}
	return &mgr.Mgr{Handle: h}, nil
}

func ListDriverServices(m *mgr.Mgr) ([]string, error) {
	var err error
	var bytesNeeded, servicesReturned uint32
	var buf []byte
	for {
		var p *byte
		if len(buf) > 0 {
			p = &buf[0]
		}
		err = windows.EnumServicesStatusEx(m.Handle, windows.SC_ENUM_PROCESS_INFO,
			windows.SERVICE_DRIVER, windows.SERVICE_STATE_ALL,
			p, uint32(len(buf)), &bytesNeeded, &servicesReturned, nil, nil)
		if err == nil {
			break
		}
		if err != windows.ERROR_MORE_DATA {
			return nil, err
		}
		if bytesNeeded <= uint32(len(buf)) {
			return nil, err
		}
		buf = make([]byte, bytesNeeded)
	}
	if servicesReturned == 0 {
		return nil, nil
	}

	services := unsafe.Slice((*windows.ENUM_SERVICE_STATUS_PROCESS)(unsafe.Pointer(&buf[0])), servicesReturned)

	var names []string
	for _, s := range services {
		name := windows.UTF16PtrToString(s.ServiceName)
		names = append(names, name)
	}
	return names, nil
}

func OpenService(m *mgr.Mgr, name string) (*mgr.Service, error) {
	h, err := windows.OpenService(m.Handle, windows.StringToUTF16Ptr(name), windows.SERVICE_QUERY_CONFIG|windows.SERVICE_QUERY_STATUS)
	if err != nil {
		return nil, err
	}
	return &mgr.Service{Name: name, Handle: h}, nil
}

```

`internal/helpers.go`:

```go
package pkg

import (
	"crypto"
	"crypto/md5"
	"crypto/sha1"
	"crypto/sha256"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	peparser "github.com/saferwall/pe"

	"golang.org/x/sys/windows"
)

func HeuristicNormalisePath(path string) (string, error) {
	path = strings.Trim(path, `\`)

	splitted := strings.SplitN(path, `\`, 2)
	if len(splitted) != 2 {
		return "", fmt.Errorf("cannot determine path %v", path)
	}

	var normalisedPath string

	switch prefix := strings.ToLower(splitted[0]); prefix {
	case "system32":
		kf, err := windows.KnownFolderPath(windows.FOLDERID_System, windows.KF_FLAG_NO_ALIAS)
		if err != nil {
			return "", fmt.Errorf("cannot determine known folder %v: %v", prefix, err)
		}
		normalisedPath = filepath.Join(kf, splitted[1])
	case "systemroot":
		kf, err := windows.KnownFolderPath(windows.FOLDERID_Windows, windows.KF_FLAG_NO_ALIAS)
		if err != nil {
			return "", fmt.Errorf("cannot determine known folder %v: %v", prefix, err)
		}
		normalisedPath = filepath.Join(kf, splitted[1])
	case "??":
		normalisedPath = splitted[1]
	}

	if _, err := os.Stat(normalisedPath); err != nil {
		return "", fmt.Errorf("normalised path %v does not exist: %v", normalisedPath, err)
	}

	return normalisedPath, nil
}

type Hashes struct {
	Md5    string
	Sha1   string
	Sha256 string
}

func HashFile(path string) (Hashes, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return Hashes{}, err
	}

	return Hashes{
		Md5:    fmt.Sprintf("%x", md5.Sum(data)),
		Sha1:   fmt.Sprintf("%x", sha1.Sum(data)),
		Sha256: fmt.Sprintf("%x", sha256.Sum256(data)),
	}, nil
}

func GetAuthentihash(driverFilePath string) (Hashes, error) {
	var result Hashes

	peFile, err := peparser.New(driverFilePath, &peparser.Options{})
	if err != nil {
		return result, err
	}

	if err := peFile.Parse(); err != nil {
		return result, nil
	}

	hashes := Hashes{
		// Md5: fmt.Sprintf("%x", peFile.AuthentihashExt(crypto.MD5.New())[0]),
		// Sha1:   fmt.Sprintf("%x", peFile.AuthentihashExt(crypto.SHA1.New())[0]),
		Sha256: fmt.Sprintf("%x", peFile.AuthentihashExt(crypto.SHA256.New())[0]),
	}

	return hashes, nil
}

func PrintLolDrivers(drivers []LolDriver) {
	maxFilenameLen := len("Filename")
	maxPathLen := len("Path")
	maxStatusLen := len("Status")
	maxMaliciousLen := len("Malicious")
	maxMD5Len := len("MD5")
	maxIDLen := len("ID")
	maxCVEsLen := len("CVEs")

	for _, driver := range drivers {
		if len(driver.Filename) > maxFilenameLen {
			maxFilenameLen = len(driver.Filename)
		}
		if len(driver.Path) > maxPathLen {
			maxPathLen = len(driver.Path)
		}
		if len(driver.Status) > maxStatusLen {
			maxStatusLen = len(driver.Status)
		}
		maliciousStr := fmt.Sprintf("%v", driver.Malicious)
		if len(maliciousStr) > maxMaliciousLen {
			maxMaliciousLen = len(maliciousStr)
		}
		if len(driver.MD5) > maxMD5Len {
			maxMD5Len = len(driver.MD5)
		}
		if len(driver.ID) > maxIDLen {
			maxIDLen = len(driver.ID)
		}
		cves := strings.Join(driver.CVEs, ", ")
		if len(cves) > maxCVEsLen {
			maxCVEsLen = len(cves)
		}
	}

	// Format and print each driver
	fmt.Printf("%-*s  %-*s  %-*s  %-*s  %-*s  %-*s  %-*s\n",
		maxFilenameLen, "Filename",
		maxPathLen, "Path",
		maxStatusLen, "Status",
		maxMaliciousLen, "Malicious",
		maxMD5Len, "MD5",
		maxIDLen, "ID",
		maxCVEsLen, "CVEs",
	)
	fmt.Printf("%s  %s  %s  %s  %s  %s  %s\n",
		strings.Repeat("-", maxFilenameLen),
		strings.Repeat("-", maxPathLen),
		strings.Repeat("-", maxStatusLen),
		strings.Repeat("-", maxMaliciousLen),
		strings.Repeat("-", maxMD5Len),
		strings.Repeat("-", maxIDLen),
		strings.Repeat("-", maxCVEsLen),
	)

	for _, driver := range drivers {
		maliciousStr := fmt.Sprintf("%v", driver.Malicious)
		cves := strings.Join(driver.CVEs, ", ")
		fmt.Printf("%-*s  %-*s  %-*s  %-*s  %-*s  %-*s  %-*s\n",
			maxFilenameLen, driver.Filename,
			maxPathLen, driver.Path,
			maxStatusLen, driver.Status,
			maxMaliciousLen, maliciousStr,
			maxMD5Len, driver.MD5,
			maxIDLen, driver.ID,
			maxCVEsLen, cves,
		)
	}
}

```

`loldriverscan.go`:

```go
package main

import (
	"encoding/json"
	"flag"
	"fmt"
	pkg "loldriverscan/internal"
	"os"

	"golang.org/x/sys/windows/svc"
)

const (
	lolDriversIoDetailUrl = `https://www.loldrivers.io/drivers/`
	headerArt             = `
	 _           _ _____       _                _____                 
	| |         | |  __ \     (_)              / ____|                
	| |     ___ | | |  | |_ __ ___   _____ _ _| (___   ___ __ _ _ __  
	| |    / _ \| | |  | | '__| \ \ / / _ \ '__\___ \ / __/ _' | '_ \ 
	| |___| (_) | | |__| | |  | |\ V /  __/ |  ____) | (_| (_| | | | |
	|______\___/|_|_____/|_|  |_| \_/ \___|_| |_____/ \___\__,_|_| |_|

                                                           FourCore.io
 `
)

var (
	Version string = "v1.0"
)

func main() {
	verbosePtr := flag.Bool("v", false, "Enable verbose mode")
	jsonOutputPtr := flag.String("json", "", "Use - for stdout or a filepath to save to the file")
	versionPtr := flag.Bool("version", false, "version details")
	flag.Parse()

	verbose := *verbosePtr
	jsonOutput := *jsonOutputPtr
	printVersion := *versionPtr

	if printVersion {
		fmt.Println(Version)
		return
	}

	if jsonOutput == "" {
		fmt.Println(headerArt)
	}

	svcMgr, err := pkg.ConnectToServiceManager()
	if err != nil {
		panic(err)
	}

	driverServices, err := pkg.ListDriverServices(svcMgr)
	if err != nil {
		panic(err)
	}

	lolDriversList, err := pkg.CreateVulnerableDriverFinder()
	if err != nil {
		panic(err)
	}

	loldrivers := []pkg.LolDriver{}

	for _, svcName := range driverServices {
		dSvc, err := pkg.OpenService(svcMgr, svcName)
		if err != nil {
			if verbose {
				fmt.Printf("[-] Cannot open service %v: %v\n", svcName, err)
			}
			continue
		}

		svcConf, err := dSvc.Config()
		if err != nil {
			if verbose {
				fmt.Printf("[-] Cannot fetch service config for %v: %v\n", svcName, err)
			}
			continue
		}

		if svcConf.BinaryPathName == "" {
			if verbose {
				fmt.Printf("[-] No service binary present for %v\n", svcName)
			}
			continue
		}

		normalisedDriverPath, err := pkg.HeuristicNormalisePath(svcConf.BinaryPathName)
		if err != nil {
			if verbose {
				fmt.Printf("[-] Cannot normalize driver path for %v (Path: %v): %v\n", svcName, svcConf.BinaryPathName, err)
			}
			continue
		}

		authentihashes, err := pkg.GetAuthentihash(normalisedDriverPath)
		if err != nil {
			if verbose {
				fmt.Printf("[-] Cannot compute sha256 hash for %v: %v\n", normalisedDriverPath, err)
			}
			continue
		}

		hashes, err := pkg.HashFile(normalisedDriverPath)
		if err != nil {
			if verbose {
				fmt.Printf("[-] Cannot compute sha256 hash for %v: %v\n", normalisedDriverPath, err)
			}
			continue
		}

		driver, err := lolDriversList.FindDriver(hashes, authentihashes)
		if err != nil {
			continue
		}
		driver.Path = normalisedDriverPath
		driver.ID = lolDriversIoDetailUrl + driver.ID

		if status, err := dSvc.Query(); err != nil {
			driver.Status = "Unknown"
		} else {
			switch status.State {
			case svc.Running:
				driver.Status = "Running"
			case svc.Stopped:
				driver.Status = "Stopped"
			case svc.Paused:
				driver.Status = "Paused"
			case svc.StartPending:
				driver.Status = "Start Pending"
			case svc.StopPending:
				driver.Status = "Stop Pending"
			default:
				driver.Status = "Unknown"
			}
		}

		loldrivers = append(loldrivers, driver)
	}

	if len(loldrivers) == 0 {
		fmt.Println("[+]No vulnerable drivers found")
	} else {
		if jsonOutput == "" {
			pkg.PrintLolDrivers(loldrivers)
		} else {
			jsonData, err := json.MarshalIndent(loldrivers, "", "    ")
			if err != nil {
				panic(fmt.Sprintf("cannot marshal json data: %v", err))
			}
			if jsonOutput == "-" {
				fmt.Println(string(jsonData))
			} else {
				if err := os.WriteFile(jsonOutput, jsonData, 0644); err != nil {
					panic(fmt.Sprintf("error writing to json file %v: %v", jsonOutput, err))
				}
			}
		}
	}

}

```