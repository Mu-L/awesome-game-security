Project Path: arc_DejavuSecure_DetectNtoskrnlIntegrity_bp9cteo3

Source Tree:

```txt
arc_DejavuSecure_DetectNtoskrnlIntegrity_bp9cteo3
├── DetectNtoskrnlIntegrity
│   ├── DetectNtoskrnlIntegrity.vcxproj
│   ├── DetectNtoskrnlIntegrity.vcxproj.filters
│   ├── DetectNtoskrnlIntegrity.vcxproj.user
│   ├── Structs.h
│   ├── Utils.hpp
│   ├── hde64
│   │   ├── hde64.cpp
│   │   ├── hde64.h
│   │   ├── stdint.h
│   │   └── table64.h
│   └── main.cpp
├── DetectNtoskrnlIntegrity.sln
├── LICENSE
└── README.md

```

`DetectNtoskrnlIntegrity.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.11.35327.3
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DetectNtoskrnlIntegrity", "DetectNtoskrnlIntegrity\DetectNtoskrnlIntegrity.vcxproj", "{C6BCF8A6-919B-4465-B178-1009FB3E15B3}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{C6BCF8A6-919B-4465-B178-1009FB3E15B3}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{C6BCF8A6-919B-4465-B178-1009FB3E15B3}.Debug|ARM64.Build.0 = Debug|ARM64
		{C6BCF8A6-919B-4465-B178-1009FB3E15B3}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{C6BCF8A6-919B-4465-B178-1009FB3E15B3}.Debug|x64.ActiveCfg = Debug|x64
		{C6BCF8A6-919B-4465-B178-1009FB3E15B3}.Debug|x64.Build.0 = Debug|x64
		{C6BCF8A6-919B-4465-B178-1009FB3E15B3}.Debug|x64.Deploy.0 = Debug|x64
		{C6BCF8A6-919B-4465-B178-1009FB3E15B3}.Release|ARM64.ActiveCfg = Release|ARM64
		{C6BCF8A6-919B-4465-B178-1009FB3E15B3}.Release|ARM64.Build.0 = Release|ARM64
		{C6BCF8A6-919B-4465-B178-1009FB3E15B3}.Release|ARM64.Deploy.0 = Release|ARM64
		{C6BCF8A6-919B-4465-B178-1009FB3E15B3}.Release|x64.ActiveCfg = Release|x64
		{C6BCF8A6-919B-4465-B178-1009FB3E15B3}.Release|x64.Build.0 = Release|x64
		{C6BCF8A6-919B-4465-B178-1009FB3E15B3}.Release|x64.Deploy.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {3389A398-DAC8-48AD-986D-D3C3FD3F2E0D}
	EndGlobalSection
EndGlobal

```

`DetectNtoskrnlIntegrity/DetectNtoskrnlIntegrity.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{C6BCF8A6-919B-4465-B178-1009FB3E15B3}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">x64</Platform>
    <RootNamespace>DetectNtoskrnlIntegrity</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
    </ClCompile>
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="hde64\hde64.cpp" />
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="hde64\hde64.h" />
    <ClInclude Include="hde64\stdint.h" />
    <ClInclude Include="hde64\table64.h" />
    <ClInclude Include="Structs.h" />
    <ClInclude Include="Utils.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`DetectNtoskrnlIntegrity/DetectNtoskrnlIntegrity.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="main.cpp" />
    <ClCompile Include="hde64\hde64.cpp">
      <Filter>Includes\hde64</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Structs.h">
      <Filter>Includes</Filter>
    </ClInclude>
    <ClInclude Include="Utils.hpp">
      <Filter>Includes</Filter>
    </ClInclude>
    <ClInclude Include="hde64\hde64.h">
      <Filter>Includes\hde64</Filter>
    </ClInclude>
    <ClInclude Include="hde64\stdint.h">
      <Filter>Includes\hde64</Filter>
    </ClInclude>
    <ClInclude Include="hde64\table64.h">
      <Filter>Includes\hde64</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="Includes">
      <UniqueIdentifier>{4c1eaf90-7948-4d13-8a06-e0052cfb45e6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Includes\hde64">
      <UniqueIdentifier>{eca083f6-4a4c-4e00-b5ab-b539bb23033b}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
</Project>
```

`DetectNtoskrnlIntegrity/DetectNtoskrnlIntegrity.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>false</ShowAllFiles>
  </PropertyGroup>
</Project>
```

`DetectNtoskrnlIntegrity/Structs.h`:

```h
typedef struct _SYSTEM_SERVICE_TABLE {
    PVOID ServiceTableBase;
    PVOID ServiceCounterTableBase;
    ULONG64 NumberOfServices;
    PVOID ParamTableBase;
} SYSTEM_SERVICE_TABLE, * PSYSTEM_SERVICE_TABLE;

typedef struct _SSDT_INFO {
    ULONG64 ServiceTableBaseRva;
    ULONG64 ParamTableBase;
    ULONG ParamTableBaseRva;
    ULONG TableSize;
} SSDT_INFO, * PSSDT_INFO;

typedef struct _FILE_INFO {
    PVOID Buffer;
    ULONG64 Length;
} FILE_INFO, * PFILE_INFO;

typedef struct _SYSTEM_MODULE_INFORMATION_ENTRY {
    ULONG Reserved[4];
    ULONG64 Base;
    ULONG Size;
    ULONG Flags;
    USHORT Index;
    USHORT Unknown;
    USHORT LoadCount;
    USHORT ModuleNameOffset;
    CHAR ImageName[256];
} SYSTEM_MODULE_INFORMATION_ENTRY, * PSYSTEM_MODULE_INFORMATION_ENTRY;

typedef struct _SYSTEM_MODULE_INFORMATION
{
    ULONG Count;
    SYSTEM_MODULE_INFORMATION_ENTRY Module[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;
```

`DetectNtoskrnlIntegrity/Utils.hpp`:

```hpp
#define MiGetPteAddress(_PteBase, _VirtualAddress) (UINT64*)(((_VirtualAddress >> 9) & 0x7FFFFFFFF8) + _PteBase);

#define IN_RANGE(x, a, b) (x >= a && x <= b)
#define GET_BITS(x) (IN_RANGE((x&(~0x20)),'A','F')?((x&(~0x20))-'A'+0xA):(IN_RANGE(x,'0','9')?x-'0':0))
#define GET_BYTE(a, b) (GET_BITS(a) << 4 | GET_BITS(b))

extern "C" NTKERNELAPI NTSTATUS NTAPI NtQuerySystemInformation(
    _In_ ULONG SystemInformationClass,
    _Out_writes_bytes_opt_(SystemInformationLength) PVOID SystemInformation,
    _In_ ULONG SystemInformationLength,
    _Out_opt_ PULONG ReturnLength
);

namespace Utils {
    ULONG Replace64(PUCHAR Buffer, ULONG BufferLength, ULONG64 Pattern, ULONG64 ReplaceWith) {
        if (!Buffer || !BufferLength || !Pattern || !ReplaceWith) return 0;

        ULONG ReplacementCount = 0;

        for (ULONG i = 0; i <= BufferLength - 8; i++) {
            if (*(ULONG64*)(Buffer + i) == Pattern) {
                *(ULONG64*)(Buffer + i) = ReplaceWith;
                ReplacementCount++;
            }
        }

        return ReplacementCount;
    }

    bool GetPageTableBases(ULONG64 PageTableBases[4]) {
        ULONG64 PteBase = *(ULONG64*)((ULONG64)MmGetVirtualForPhysical + 0x22);
        ULONG64 PdeBase = (ULONG64)MiGetPteAddress(PteBase, PteBase);
        ULONG64 PdptBase = (ULONG64)MiGetPteAddress(PteBase, PdeBase);
        ULONG64 Pml4Base = (ULONG64)MiGetPteAddress(PteBase, PdptBase);

        PageTableBases[0] = Pml4Base;
        PageTableBases[1] = PdptBase;
        PageTableBases[2] = PdeBase;
        PageTableBases[3] = PteBase;

        return true;
    }

    ULONG64 GetSystemPteAddress(ULONG64 PteBase) {
        ULONG64 SystemCr3 = __readcr3();

        PHYSICAL_ADDRESS PhysicalCr3{};
        PhysicalCr3.QuadPart = SystemCr3;
        ULONG64 VirtualCr3 = (ULONG64)MmGetVirtualForPhysical(PhysicalCr3);

        return (ULONG64)MiGetPteAddress(PteBase, VirtualCr3);
    }

    UINT64 FindPattern(PVOID baseAddress, UINT64 size, const char* pattern)
    {
        UINT8* firstMatch = nullptr;
        const char* currentPattern = pattern;

        UINT8* start = static_cast<UINT8*>(baseAddress);
        UINT8* end = start + size;

        for (UINT8* current = start; current < end; current++)
        {
            UINT8 byte = currentPattern[0]; if (!byte) return reinterpret_cast<UINT64>(firstMatch);
            if (byte == '\?' || *static_cast<UINT8*>(current) == GET_BYTE(byte, currentPattern[1]))
            {
                if (!firstMatch) firstMatch = current;
                if (!currentPattern[2]) return reinterpret_cast<UINT64>(firstMatch);
                ((byte == '\?') ? (currentPattern += 2) : (currentPattern += 3));
            }
            else
            {
                currentPattern = pattern;
                firstMatch = nullptr;
            }
        }

        return 0;
    }

    UINT64 FindPatternImage(PVOID base, const char* pattern, const char* segment)
    {
        UINT64 match = 0;

        PIMAGE_NT_HEADERS64 headers = reinterpret_cast<PIMAGE_NT_HEADERS64>(reinterpret_cast<UINT64>(base) + static_cast<PIMAGE_DOS_HEADER>(base)->e_lfanew);
        PIMAGE_SECTION_HEADER sections = IMAGE_FIRST_SECTION(headers);
        for (ULONG64 i = 0; i < headers->FileHeader.NumberOfSections; ++i)
        {
            PIMAGE_SECTION_HEADER section = &sections[i];
            if (memcmp(section->Name, segment, strlen(segment)) == 0)
            {
                match = FindPattern(reinterpret_cast<void*>(reinterpret_cast<UINT64>(base) + section->VirtualAddress), section->Misc.VirtualSize, pattern);
                if (match) break;
            }
        }

        return match;
    }

    PSYSTEM_SERVICE_TABLE FindKeServiceDescriptorTable64(ULONG64 pKernelBase)
    {
        // .text: KiSystemCall64	
        // 4C 8D 15 ? ? ? ? | lea r10, KeServiceDescriptorTable
        // 4C 8D 1D ? ? ? ? | lea r11, KeServiceDescriptorTableShadow
        // F7 43 ?  ? ? ? ? | test dword ptr [rbx+?], ?

        UINT64 p_lea_r10_r11 = FindPatternImage((PVOID)pKernelBase, "4C 8D 15 ? ? ? ? 4C 8D 1D ? ? ? ? F7 43", ".text");
        if (!p_lea_r10_r11) return 0;

        PSYSTEM_SERVICE_TABLE pCandidateTable = (PSYSTEM_SERVICE_TABLE)(p_lea_r10_r11 + 7 + *(INT32*)(p_lea_r10_r11 + 3));

        if (!MmIsAddressValid(pCandidateTable->ServiceTableBase)) return 0;

        return pCandidateTable;
    }

    bool GetSsdtInfo(ULONG64 pKernelBase, PSSDT_INFO pSsdtInfo) {
        // Find KeServiceDescriptorTable in memory
        PSYSTEM_SERVICE_TABLE pKeServiceDescriptorTable = Utils::FindKeServiceDescriptorTable64(pKernelBase);
        if (!pKeServiceDescriptorTable) {
            DbgPrint("Unable to find KeServiceDescriptorTable\n");
            return false;
        }

        ULONG64 ServiceTableBase = (ULONG64)pKeServiceDescriptorTable->ServiceTableBase;
        if (!ServiceTableBase) {
            DbgPrint("Unable to get ServiceTableBase\n");
            return false;
        }

        // Calculate ServiceTableBase RVA relative to kernel base
        pSsdtInfo->ServiceTableBaseRva = ServiceTableBase - pKernelBase;
        DbgPrint("ServiceTableBase RVA: 0x%llX\n", pSsdtInfo->ServiceTableBaseRva);

        // Get ParamTableBase and NumberOfServices from KeServiceDescriptorTable
        pSsdtInfo->ParamTableBase = (ULONG64)pKeServiceDescriptorTable->ParamTableBase;
        pSsdtInfo->ParamTableBaseRva = (ULONG)(pSsdtInfo->ParamTableBase - pKernelBase);
        pSsdtInfo->TableSize = (ULONG)pKeServiceDescriptorTable->NumberOfServices;

        DbgPrint("ParamTableBase RVA: 0x%X, NumberOfServices: %u\n", pSsdtInfo->ParamTableBaseRva, pSsdtInfo->TableSize);

        return true;
    }

    FILE_INFO ReadFile(wchar_t* WideFilePath) {
        FILE_INFO FileInfo{};

        UNICODE_STRING FilePath;
        RtlInitUnicodeString(&FilePath, WideFilePath);

        OBJECT_ATTRIBUTES ObjectAttributes;
        InitializeObjectAttributes(&ObjectAttributes, &FilePath, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, 0, 0);

        HANDLE FileHandle; IO_STATUS_BLOCK IoStatusBlock;
        NTSTATUS Status = ZwCreateFile(
            &FileHandle, GENERIC_READ, &ObjectAttributes, &IoStatusBlock, 0,
            FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT, 0, 0
        );

        if (!NT_SUCCESS(Status)) return FileInfo;

        FILE_STANDARD_INFORMATION FileStandardInfo;
        Status = ZwQueryInformationFile(FileHandle, &IoStatusBlock, &FileStandardInfo, sizeof(FILE_STANDARD_INFORMATION), FileStandardInformation);

        if (!NT_SUCCESS(Status)) return FileInfo;

        PVOID FileBuffer = ExAllocatePoolWithTag(PagedPool, FileStandardInfo.EndOfFile.QuadPart, 1);
        if (!FileBuffer)
        {
            ZwClose(FileHandle);
            return FileInfo;
        }

        __stosb((PUCHAR)FileBuffer, 0, FileStandardInfo.EndOfFile.QuadPart);

        LARGE_INTEGER ByteOffset = { 0 };
        ByteOffset.QuadPart = 0;
        Status = ZwReadFile(FileHandle, 0, 0, 0, &IoStatusBlock, FileBuffer, FileStandardInfo.EndOfFile.QuadPart, &ByteOffset, 0);

        if (!NT_SUCCESS(Status))
        {
            ExFreePoolWithTag(FileBuffer, 1);
            ZwClose(FileHandle);
            return FileInfo;
        }

        ZwClose(FileHandle);

        FileInfo.Buffer = FileBuffer;
        FileInfo.Length = FileStandardInfo.EndOfFile.QuadPart;

        return FileInfo;
    }

    void PerformDynamicReplacements(FILE_INFO NtoskrnlInfo, ULONG64 PteBase, ULONG64 MmPfnDataBase,
        ULONG64 Pml4Base, ULONG64 PdptBase, ULONG64 PdeBase, ULONG64 SystemPteAddress) {
        // Define replacement pairs structure
        struct ReplacementPair {
            ULONG64 Original;
            ULONG64 Replacement;
        };

        // Create replacement array
        ReplacementPair Replacements[] = {
            { 0x0FFFFF6FB7DBEDF68, SystemPteAddress },

            { 0x0FFFFF68000000000, PteBase },
            { 0x0FFFFF6FFFFFFFFFF, PteBase | 0xFFFFFFFFFF },

            { 0x0FFFFDE0000000000, MmPfnDataBase },
            { 0x0FFFFDE0000000008, MmPfnDataBase + 0x08 },
            { 0x0FFFFDE0000000010, MmPfnDataBase + 0x10 },
            { 0x0FFFFDE0000000018, MmPfnDataBase + 0x18 },
            { 0x0FFFFDE0000000022, MmPfnDataBase + 0x22 },
            { 0x0FFFFDE0000000020, MmPfnDataBase + 0x20 },
            { 0x0FFFFDE0000000023, MmPfnDataBase + 0x23 },
            { 0x0FFFFDE0000000028, MmPfnDataBase + 0x28 },
            { 0x0FFFFDE0000000030, MmPfnDataBase + 0x30 },
            { 0x0FFFFDE0000000FFF, MmPfnDataBase + 0xFFF},

            { 0x0FFFFF6FB7DBED000, Pml4Base },
            { 0x0FFFFF6FB7DBED7F8, Pml4Base + 0x7F8 },
            { 0x0FFFFF6FB7DBED800, Pml4Base + 0x800 },
            { 0x0FFFFF6FB7DBEDFFF, Pml4Base + 0xFFF },

            { 0x0FFFFF6FB7DA00000, PdptBase },

            { 0x0FFFFF6FB40000000, PdeBase },
            { 0x0FFFFF6FB5FFFFFF8, PdeBase + 0x1FFFFFF8 },
            { 0x0FFFFF6FB7FFFFFFF, PdeBase + 0x3FFFFFFF },

            { 0x0FFFFF68000000008, PteBase + 0x08 },
            { 0x0FFFFF68000000FFF, PteBase + 0xFFF },
            { 0x0FFFFF70000000000, PteBase + 0x8000000000 },
        };

        // Iterate through all replacement values and perform replacements
        for (size_t i = 0; i < sizeof(Replacements) / sizeof(Replacements[0]); i++) {
            ULONG ReplacementCount = Utils::Replace64(
                (PUCHAR)NtoskrnlInfo.Buffer,
                NtoskrnlInfo.Length,
                Replacements[i].Original,
                Replacements[i].Replacement
            );
            DbgPrint("Replaced %u occurrences of 0x%llX with 0x%llX\n",
                ReplacementCount,
                Replacements[i].Original,
                Replacements[i].Replacement);
        }
    }

    ULONG RvaToFileOffset(PIMAGE_NT_HEADERS64 pNtHeader, PIMAGE_SECTION_HEADER pSectionHeader, ULONG Rva) {
        for (USHORT i = 0; i < pNtHeader->FileHeader.NumberOfSections; i++) {
            if (Rva >= pSectionHeader[i].VirtualAddress &&
                Rva < (pSectionHeader[i].VirtualAddress + pSectionHeader[i].SizeOfRawData)) {
                return pSectionHeader[i].PointerToRawData + (Rva - pSectionHeader[i].VirtualAddress);
            }
        }
        return 0;
    }

    bool ProcessRelocationBlocks(PIMAGE_DOS_HEADER pDosHeader, ULONG RelocationFileOffset, ULONG RelocationSize,
        PIMAGE_NT_HEADERS64 pNtHeader, PIMAGE_SECTION_HEADER pSectionHeader,
        ULONG64 RelocationDelta, ULONG FileLength) {
        PIMAGE_BASE_RELOCATION pRelocationBlock = (PIMAGE_BASE_RELOCATION)((PUCHAR)pDosHeader + RelocationFileOffset);
        ULONG ProcessedSize = 0;

        while (ProcessedSize < RelocationSize) {
            ULONG EntriesCount = (pRelocationBlock->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(USHORT);
            PUSHORT pEntries = (PUSHORT)((PUCHAR)pRelocationBlock + sizeof(IMAGE_BASE_RELOCATION));

            // Process all entries in the relocation block
            for (ULONG i = 0; i < EntriesCount; i++) {
                USHORT Entry = pEntries[i];
                USHORT Type = (Entry >> 12); // Type is high 4 bits
                USHORT Offset = Entry & 0xFFF; // Offset is low 12 bits

                // Process only 64-bit relocations (IMAGE_REL_BASED_DIR64, value 10)
                if (Type == 10) {
                    ULONG EntryRva = pRelocationBlock->VirtualAddress + Offset;
                    ULONG EntryFileOffset = RvaToFileOffset(pNtHeader, pSectionHeader, EntryRva);

                    if (EntryFileOffset != 0 && EntryFileOffset + sizeof(ULONG64) <= FileLength) {
                        PULONG64 pFileAddress = (PULONG64)((PUCHAR)pDosHeader + EntryFileOffset);
                        ULONG64 OriginalValue = *pFileAddress;
                        ULONG64 RelocatedValue = OriginalValue + RelocationDelta;
                        *pFileAddress = RelocatedValue;
                    }
                }
            }

            // Move to next relocation block
            ProcessedSize += pRelocationBlock->SizeOfBlock;
            pRelocationBlock = (PIMAGE_BASE_RELOCATION)((PUCHAR)pRelocationBlock + pRelocationBlock->SizeOfBlock);
        }

        return true;
    }

    bool ProcessRelocations(FILE_INFO NtoskrnlInfo, ULONG64 pKernelBase) {
        PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)NtoskrnlInfo.Buffer;
        PIMAGE_NT_HEADERS64 pNtHeader = (PIMAGE_NT_HEADERS64)((PUCHAR)pDosHeader + pDosHeader->e_lfanew);
        PIMAGE_SECTION_HEADER pSectionHeader = IMAGE_FIRST_SECTION(pNtHeader);

        // Calculate relocation delta (memory base - expected base)
        ULONG64 RelocationDelta = pKernelBase - pNtHeader->OptionalHeader.ImageBase;
        DbgPrint("Relocation delta: 0x%llX\n", RelocationDelta);

        // Process relocation table
        ULONG RelocationRva = pNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;
        ULONG RelocationSize = pNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;

        if (RelocationRva && RelocationSize) {
            // Convert RVA to file offset
            ULONG RelocationFileOffset = RvaToFileOffset(pNtHeader, pSectionHeader, RelocationRva);
            if (RelocationFileOffset == 0) {
                DbgPrint("Cannot find relocation table file offset\n");
                return false;
            }

            // Process all relocation blocks
            return ProcessRelocationBlocks(pDosHeader, RelocationFileOffset, RelocationSize,
                pNtHeader, pSectionHeader, RelocationDelta, NtoskrnlInfo.Length);
        }

        return true;
    }

    bool ProcessSsdt(FILE_INFO NtoskrnlInfo, ULONG64 pKernelBase, SSDT_INFO SsdtInfo) {
        PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)NtoskrnlInfo.Buffer;
        PIMAGE_NT_HEADERS64 pNtHeader = (PIMAGE_NT_HEADERS64)((PUCHAR)pDosHeader + pDosHeader->e_lfanew);
        PIMAGE_SECTION_HEADER pSectionHeader = IMAGE_FIRST_SECTION(pNtHeader);

        // Find ServiceTableBase in file
        ULONG FileServiceTableOffset = RvaToFileOffset(pNtHeader, pSectionHeader, SsdtInfo.ServiceTableBaseRva);
        if (FileServiceTableOffset == 0) {
            DbgPrint("Cannot locate KiServiceTable in file\n");
            return false;
        }
        ULONG64 FileServiceTableBase = (ULONG64)pDosHeader + FileServiceTableOffset;

        // Find ParamTableBase in file
        ULONG FileParamTableOffset = RvaToFileOffset(pNtHeader, pSectionHeader, SsdtInfo.ParamTableBaseRva);
        if (FileParamTableOffset == 0) {
            DbgPrint("Cannot locate ParamTableBase in file\n");
            return false;
        }
        PUCHAR FileParamTable = (PUCHAR)pDosHeader + FileParamTableOffset;

        DbgPrint("KiServiceTable in file: 0x%llX, offset: 0x%X\n", FileServiceTableBase, FileServiceTableOffset);
        DbgPrint("ParamTableBase in file: 0x%p, offset: 0x%X\n", FileParamTable, FileParamTableOffset);

        // Process SSDT entries (Windows 10+ style)
        for (ULONG i = 0; i < SsdtInfo.TableSize; i++) {
            // Windows 10+ format (4 bytes per entry)
            ULONG FileEntryValue = *((PULONG)((PUCHAR)FileServiceTableBase + i * 4));
            UCHAR ParamCookie = FileParamTable[i];

            // Calculate FunctionCookie based on Windows 10+ rules
            ULONG_PTR FunctionCookie = FileEntryValue - (ULONG)(FileServiceTableBase - (ULONG64)pDosHeader);

            // Calculate compacted value
            ULONG CompactedValue = (16 * FunctionCookie) | (ParamCookie >> 2);

            // Replace value in file
            *((PULONG)((PUCHAR)FileServiceTableBase + i * 4)) = CompactedValue;
        }

        return true;
    }

    enum class SpectreMitigationMode {
        None = 0,
        Mode1 = 1,
        Mode2 = 2
    };

    SpectreMitigationMode CheckForSpectreMitigation(PUCHAR MemoryData, PUCHAR FileData, ULONG Offset, ULONG64 DataBaseAddr, ULONG Size, bool IsExecutableSection) {
        if (!IsExecutableSection) return SpectreMitigationMode::None;

        // First check pattern 1: starting with "4c 8b" (mov r10) - prioritize checking this pattern
        if (Offset + 1 < Size && MemoryData[Offset] == 0x4c && MemoryData[Offset + 1] == 0x8b) {
            // Use hde64 to disassemble instructions in both file and memory starting from the difference point
            hde64s FileInstr1, FileInstr2;
            hde64s MemInstr1, MemInstr2;

            // Disassemble two instructions from the file
            ULONG FileInstr1Len = hde64_disasm(FileData + Offset, &FileInstr1);
            ULONG FileInstr2Len = 0;

            ULONG MemInstr1Len = 0;
            ULONG MemInstr2Len = 0;

            if (FileInstr1Len > 0) {
                FileInstr2Len = hde64_disasm(FileData + Offset + FileInstr1Len, &FileInstr2);

                // Disassemble two instructions from memory
                MemInstr1Len = hde64_disasm(MemoryData + Offset, &MemInstr1);
                if (MemInstr1Len > 0) {
                    MemInstr2Len = hde64_disasm(MemoryData + Offset + MemInstr1Len, &MemInstr2);

                    // Check if it matches the Spectre Mitigation pattern
                    if (FileInstr1Len > 0 && FileInstr2Len > 0 &&
                        MemInstr1Len > 0 && MemInstr2Len > 0) {

                        // Check if the total instruction length is consistent
                        if (FileInstr1Len + FileInstr2Len == MemInstr1Len + MemInstr2Len) {

                            // Directly check if the file contains a call qword ptr [] pattern (0xFF 0x15)
                            bool FileIsCallIndirect = (FileInstr1.opcode == 0xFF && FileInstr1.modrm == 0x15);

                            // Check if the second instruction in the file is a nop instruction
                            bool FileSecondIsNop = (FileInstr2.opcode == 0x90 || // Single-byte nop
                                (FileInstr2.opcode == 0x0F && FileInstr2.opcode2 == 0x1F)); // Multi-byte nop

                            // Check if the memory contains a mov r10, [] pattern
                            bool MemIsMoveR10 = (MemoryData[Offset] == 0x4c && MemoryData[Offset + 1] == 0x8b && MemoryData[Offset + 2] == 0x15);

                            // Check if the second instruction in memory is a call instruction (0xE8)
                            bool MemSecondIsCall = (MemInstr2.opcode == 0xE8);

                            // If the above conditions are met, identify as Spectre Mitigation Mode 1
                            if (FileIsCallIndirect && FileSecondIsNop &&
                                MemIsMoveR10 && MemSecondIsCall) {

                                // Successfully detected Mode 1
                                return SpectreMitigationMode::Mode1;
                            }
                        }
                    }
                }
            }
        }

        // If pattern 1 doesn't match, check pattern 2: starting with "48 FF 25" (rex.w jmp qword ptr [rip+?])
        if (Offset + 2 < Size && FileData[Offset] == 0x48 && FileData[Offset + 1] == 0xFF && FileData[Offset + 2] == 0x25) {
            // Check if there are consecutive CC (int3) padding in the file
            bool HasNopPadding = false;
            if (Offset + 14 < Size) {  // 6 bytes indirect jump + at least 5 bytes of CC padding
                bool AllCC = true;
                for (int k = 0; k < 5; k++) {
                    if (FileData[Offset + 7 + k] != 0xCC) {
                        AllCC = false;
                        break;
                    }
                }
                HasNopPadding = AllCC;
            }

            // Check if the memory contains the pattern "4c 8b 15 ? ? ? ? e9 ? ? ? ?"
            bool HasSpectreMitigation = false;
            if (Offset + 11 < Size &&
                MemoryData[Offset] == 0x4C && MemoryData[Offset + 1] == 0x8B && MemoryData[Offset + 2] == 0x15 &&
                MemoryData[Offset + 7] == 0xE9) {  // Check if the second instruction is a direct jmp
                HasSpectreMitigation = true;
            }

            if (HasNopPadding && HasSpectreMitigation) {
                // Successfully detected Mode 2
                return SpectreMitigationMode::Mode2;
            }
        }

        return SpectreMitigationMode::None;
    }

    bool ShouldSkipSection(const char* SectionName) {
        return strncmp(SectionName, ".idata", 7) == 0 ||
            strncmp(SectionName, ".edata", 7) == 0 ||
            strncmp(SectionName, "GFIDS", 6) == 0 ||
            strncmp(SectionName, "MINIEX", 7) == 0 ||
            strncmp(SectionName, "INIT", 5) == 0 ||
            strncmp(SectionName, ".rsrc", 5) == 0 ||
            strncmp(SectionName, ".reloc", 7) == 0;
    }

    bool ValidateReadOnlySections(ULONG64 pKernelBase, FILE_INFO NtoskrnlInfo) {
        PIMAGE_DOS_HEADER pDosHeader1 = (PIMAGE_DOS_HEADER)pKernelBase;
        PIMAGE_DOS_HEADER pDosHeader2 = (PIMAGE_DOS_HEADER)NtoskrnlInfo.Buffer;

        PIMAGE_NT_HEADERS64 pNtHeader1 = (PIMAGE_NT_HEADERS64)((PUCHAR)pDosHeader1 + pDosHeader1->e_lfanew);
        PIMAGE_NT_HEADERS64 pNtHeader2 = (PIMAGE_NT_HEADERS64)((PUCHAR)pDosHeader2 + pDosHeader2->e_lfanew);

        PIMAGE_SECTION_HEADER pSectionHeader1 = IMAGE_FIRST_SECTION(pNtHeader1);
        PIMAGE_SECTION_HEADER pSectionHeader2 = IMAGE_FIRST_SECTION(pNtHeader2);

        // Iterate through read-only sections in file and compare with memory
        for (USHORT i = 0; i < pNtHeader2->FileHeader.NumberOfSections; i++) {
            if (!(pSectionHeader2[i].Characteristics & IMAGE_SCN_MEM_WRITE)) {
                // Skip specific sections
                if (ShouldSkipSection((const char*)pSectionHeader2[i].Name)) {
                    DbgPrint("Skipping section validation: %s\n", pSectionHeader2[i].Name);
                    continue;
                }

                if (memcmp(pSectionHeader1[i].Name, pSectionHeader2[i].Name, IMAGE_SIZEOF_SHORT_NAME)) {
                    DbgPrint("Ntoskrnl integrity check failed: read-only section name %s\n", pSectionHeader1[i].Name);
                    return false;
                }

                PUCHAR SectionData1 = (PUCHAR)pDosHeader1 + pSectionHeader1[i].VirtualAddress;
                PUCHAR SectionData2 = (PUCHAR)pDosHeader2 + pSectionHeader2[i].PointerToRawData;

                // Compare byte by byte
                ULONG MinSize = min(pSectionHeader1[i].SizeOfRawData, pSectionHeader2[i].SizeOfRawData);
                bool DifferenceFound = false;
                bool IsExecutableSection = (pSectionHeader2[i].Characteristics & IMAGE_SCN_MEM_EXECUTE) != 0;

                // In ValidateReadOnlySections function:
                for (ULONG j = 0; j < MinSize; j++) {
                    if (SectionData1[j] != SectionData2[j]) {
                        // Check for Spectre Mitigation pattern
                        SpectreMitigationMode MitigationMode = CheckForSpectreMitigation(
                            SectionData1,             // Memory data
                            SectionData2,             // File data
                            j,                        // Current offset
                            (ULONG64)(SectionData1 + j) - (ULONG64)pDosHeader1,  // Base address for correct reporting
                            MinSize,                  // Min size
                            IsExecutableSection       // Is executable section
                        );

                        if (MitigationMode != SpectreMitigationMode::None) {
                            // Handle based on specific mode detected
                            if (MitigationMode == SpectreMitigationMode::Mode1) {
                                // Mode 1: Use actual instruction length
                                hde64s FileInstr1, FileInstr2;
                                ULONG FileInstr1Len = hde64_disasm(SectionData2 + j, &FileInstr1);
                                ULONG FileInstr2Len = 0;
                                if (FileInstr1Len > 0) {
                                    FileInstr2Len = hde64_disasm(SectionData2 + j + FileInstr1Len, &FileInstr2);

                                    // Skip using actual instruction length
                                    ULONG TotalSkip = FileInstr1Len + FileInstr2Len;
                                    if (j + TotalSkip < MinSize) {
                                        j += (TotalSkip - 1);  // -1 because loop will increment j
                                    }
                                    else {
                                        j = MinSize - 1;
                                    }
                                }
                            }
                            else if (MitigationMode == SpectreMitigationMode::Mode2) {
                                // Mode 2: Use fixed 11 bytes skip
                                if (j + 11 < MinSize) {
                                    j += 11;  // Loop will increment j
                                }
                                else {
                                    j = MinSize - 1;
                                }
                            }
                            continue;  // Skip to next iteration
                        }

                        // Not a Spectre Mitigation pattern, handle as difference
                        DifferenceFound = true;

                        // Calculate relative addresses
                        ULONG64 RelativeAddr1 = (ULONG64)(SectionData1 + j) - (ULONG64)pDosHeader1;
                        ULONG64 RelativeAddr2 = (ULONG64)(SectionData2 + j) - (ULONG64)pDosHeader2;

                        DbgPrint("Section %s data mismatch: memory relative addr 0x%llX, file relative addr 0x%llX, values: 0x%02X vs 0x%02X\n",
                            pSectionHeader1[i].Name,
                            RelativeAddr1,
                            RelativeAddr2,
                            SectionData1[j],
                            SectionData2[j]);

                        break;
                    }
                }

                if (DifferenceFound) {
                    DbgPrint("Ntoskrnl integrity check failed: section %s\n", pSectionHeader1[i].Name);
                    return false;
                }

                DbgPrint("Section validation passed: %s\n", pSectionHeader1[i].Name);
            }
        }

        return true;
    }

    PVOID GetModuleBase(const char* ImageName) {
        ULONG BufferSize = 0;
        NTSTATUS Status = 0;

        Status = NtQuerySystemInformation(11, 0, 0, &BufferSize);
        if (!NT_SUCCESS(Status) && Status != 0xC0000004) return 0;

        PSYSTEM_MODULE_INFORMATION pModuleInfo = (PSYSTEM_MODULE_INFORMATION)ExAllocatePoolWithTag(PagedPool, BufferSize, 1);
        if (!pModuleInfo) return 0;

        Status = NtQuerySystemInformation(11, pModuleInfo, BufferSize, &BufferSize);
        if (!NT_SUCCESS(Status)) return 0;

        ULONG64 Base = 0;
        for (int i = 0; i < pModuleInfo->Count; i++) {
            if (strstr(pModuleInfo->Module[i].ImageName, ImageName))
                Base = (ULONG64)pModuleInfo->Module[i].Base;
            if (Base) break;
        }

        ExFreePoolWithTag(pModuleInfo, 1);

        return (PVOID)Base;
    }
}
```

`DetectNtoskrnlIntegrity/hde64/hde64.cpp`:

```cpp
//hde64.c
#pragma warning(push)
#pragma warning(disable:4701)
#pragma warning(disable:4706)
#pragma warning(disable:26451)
#include "hde64.h"
#include "table64.h"

typedef unsigned char* LPBYTE;

extern "C" unsigned int hde64_disasm(const void* code, hde64s* hs)
{
	uint8_t x, c = 0, *p = (uint8_t*)code, cflags, opcode, pref = 0;
	uint8_t *ht = hde64_table, m_mod, m_reg, m_rm, disp_size = 0;
	uint8_t op64 = 0;

	// Avoid using memset to reduce the footprint.
#ifndef _MSC_VER
    memset((LPBYTE)hs, 0, sizeof(hde64s));
#else
	__stosb((LPBYTE)hs, 0, sizeof(hde64s));
#endif

	for (x = 16; x; x--)
	{
		
		
		switch (c=*p++ )
		{
		case 0xf3:
			hs->p_rep = c;
			pref |= PRE_F3;
			break;
		case 0xf2:
			hs->p_rep = c;
			pref |= PRE_F2;
			break;
		case 0xf0:
			hs->p_lock = c;
			pref |= PRE_LOCK;
			break;
		case 0x26:
		case 0x2e:
		case 0x36:
		case 0x3e:
		case 0x64:
		case 0x65:
			hs->p_seg = c;
			pref |= PRE_SEG;
			break;
		case 0x66:
			hs->p_66 = c;
			pref |= PRE_66;
			break;
		case 0x67:
			hs->p_67 = c;
			pref |= PRE_67;
			break;
		default:
			goto pref_done;
		}
	}
pref_done:

	hs->flags = (uint32_t)pref << 23;

	if (!pref)
		pref |= PRE_NONE;

	if ((c & 0xf0) == 0x40)
	{
		hs->flags |= F_PREFIX_REX;
		if ((hs->rex_w = (c & 0xf) >> 3) && (*p & 0xf8) == 0xb8)
			op64++;
		hs->rex_r = (c & 7) >> 2;
		hs->rex_x = (c & 3) >> 1;
		hs->rex_b = c & 1;
		if (((c = *p++) & 0xf0) == 0x40)
		{
			opcode = c;
			goto error_opcode;
		}
	}

	if ((hs->opcode = c) == 0x0f)
	{
		hs->opcode2 = c = *p++;
		ht += DELTA_OPCODES;
	}
	else if (c >= 0xa0 && c <= 0xa3)
	{
		op64++;
		if (pref & PRE_67)
			pref |= PRE_66;
		else
			pref &= ~PRE_66;
	}

	opcode = c;
	cflags = ht[ht[opcode / 4] + (opcode % 4)];

	if (cflags == C_ERROR)
	{
	error_opcode:
		hs->flags |= F_ERROR | F_ERROR_OPCODE;
		cflags = 0;
		if ((opcode & -3) == 0x24)
			cflags++;
	}

	x = 0;
	if (cflags & C_GROUP)
	{
		uint16_t t;
		t = *(uint16_t*)(ht + (cflags & 0x7f));
		cflags = (uint8_t)t;
		x = (uint8_t)(t >> 8);
	}

	if (hs->opcode2)
	{
		ht = hde64_table + DELTA_PREFIXES;
		if (ht[ht[opcode / 4] + (opcode % 4)] & pref)
			hs->flags |= F_ERROR | F_ERROR_OPCODE;
	}

	if (cflags & C_MODRM)
	{
		hs->flags |= F_MODRM;
		hs->modrm = c = *p++;
		hs->modrm_mod = m_mod = c >> 6;
		hs->modrm_rm = m_rm = c & 7;
		hs->modrm_reg = m_reg = (c & 0x3f) >> 3;

		if (x && ((x << m_reg) & 0x80))
			hs->flags |= F_ERROR | F_ERROR_OPCODE;

		if (!hs->opcode2 && opcode >= 0xd9 && opcode <= 0xdf)
		{
			uint8_t t = opcode - 0xd9;
			if (m_mod == 3)
			{
				ht = hde64_table + DELTA_FPU_MODRM + t * 8;
				t = ht[m_reg] << m_rm;
			}
			else
			{
				ht = hde64_table + DELTA_FPU_REG;
				t = ht[t] << m_reg;
			}
			if (t & 0x80)
				hs->flags |= F_ERROR | F_ERROR_OPCODE;
		}

		if (pref & PRE_LOCK)
		{
			if (m_mod == 3)
			{
				hs->flags |= F_ERROR | F_ERROR_LOCK;
			}
			else
			{
				uint8_t *table_end, op = opcode;
				if (hs->opcode2)
				{
					ht = hde64_table + DELTA_OP2_LOCK_OK;
					table_end = ht + DELTA_OP_ONLY_MEM - DELTA_OP2_LOCK_OK;
				}
				else
				{
					ht = hde64_table + DELTA_OP_LOCK_OK;
					table_end = ht + DELTA_OP2_LOCK_OK - DELTA_OP_LOCK_OK;
					op &= -2;
				}
				for (; ht != table_end; ht++)
					if (*ht++ == op)
					{
						if (!((*ht << m_reg) & 0x80))
							goto no_lock_error;
						else
							break;
					}
				hs->flags |= F_ERROR | F_ERROR_LOCK;
			no_lock_error:
				;
			}
		}

		if (hs->opcode2)
		{
			switch (opcode)
			{
			case 0x20:
			case 0x22:
				m_mod = 3;
				if (m_reg > 4 || m_reg == 1)
					goto error_operand;
				else
					goto no_error_operand;
			case 0x21:
			case 0x23:
				m_mod = 3;
				if (m_reg == 4 || m_reg == 5)
					goto error_operand;
				else
					goto no_error_operand;
			}
		}
		else
		{
			switch (opcode)
			{
			case 0x8c:
				if (m_reg > 5)
					goto error_operand;
				else
					goto no_error_operand;
			case 0x8e:
				if (m_reg == 1 || m_reg > 5)
					goto error_operand;
				else
					goto no_error_operand;
			}
		}

		if (m_mod == 3)
		{
			uint8_t* table_end;
			if (hs->opcode2)
			{
				ht = hde64_table + DELTA_OP2_ONLY_MEM;
				table_end = ht + sizeof(hde64_table) - DELTA_OP2_ONLY_MEM;
			}
			else
			{
				ht = hde64_table + DELTA_OP_ONLY_MEM;
				table_end = ht + DELTA_OP2_ONLY_MEM - DELTA_OP_ONLY_MEM;
			}
			for (; ht != table_end; ht += 2)
				if (*ht++ == opcode)
				{
					if (*ht++ & pref && !((*ht << m_reg) & 0x80))
						goto error_operand;
					else
						break;
				}
			goto no_error_operand;
		}
		else if (hs->opcode2)
		{
			switch (opcode)
			{
			case 0x50:
			case 0xd7:
			case 0xf7:
				if (pref & (PRE_NONE | PRE_66))
					goto error_operand;
				break;
			case 0xd6:
				if (pref & (PRE_F2 | PRE_F3))
					goto error_operand;
				break;
			case 0xc5:
				goto error_operand;
			}
			goto no_error_operand;
		}
		else
			goto no_error_operand;

	error_operand:
		hs->flags |= F_ERROR | F_ERROR_OPERAND;
	no_error_operand:

		c = *p++;
		if (m_reg <= 1)
		{
			if (opcode == 0xf6)
				cflags |= C_IMM8;
			else if (opcode == 0xf7)
				cflags |= C_IMM_P66;
		}

		switch (m_mod)
		{
		case 0:
			if (pref & PRE_67)
			{
				if (m_rm == 6)
					disp_size = 2;
			}
			else if (m_rm == 5)
				disp_size = 4;
			break;
		case 1:
			disp_size = 1;
			break;
		case 2:
			disp_size = 2;
			if (!(pref & PRE_67))
				disp_size <<= 1;
		}

		if (m_mod != 3 && m_rm == 4)
		{
			hs->flags |= F_SIB;
			p++;
			hs->sib = c;
			hs->sib_scale = c >> 6;
			hs->sib_index = (c & 0x3f) >> 3;
			if ((hs->sib_base = c & 7) == 5 && !(m_mod & 1))
				disp_size = 4;
		}

		p--;
		switch (disp_size)
		{
		case 1:
			hs->flags |= F_DISP8;
			hs->disp.disp8 = *p;
			break;
		case 2:
			hs->flags |= F_DISP16;
			hs->disp.disp16 = *(uint16_t*)p;
			break;
		case 4:
			hs->flags |= F_DISP32;
			hs->disp.disp32 = *(uint32_t*)p;
		}
		p += disp_size;
	}
	else if (pref & PRE_LOCK)
		hs->flags |= F_ERROR | F_ERROR_LOCK;

	if (cflags & C_IMM_P66)
	{
		if (cflags & C_REL32)
		{
			if (pref & PRE_66)
			{
				hs->flags |= F_IMM16 | F_RELATIVE;
				hs->imm.imm16 = *(uint16_t*)p;
				p += 2;
				goto disasm_done;
			}
			goto rel32_ok;
		}
		if (op64)
		{
			hs->flags |= F_IMM64;
			hs->imm.imm64 = *(uint64_t*)p;
			p += 8;
		}
		else if (!(pref & PRE_66))
		{
			hs->flags |= F_IMM32;
			hs->imm.imm32 = *(uint32_t*)p;
			p += 4;
		}
		else
			goto imm16_ok;
	}


	if (cflags & C_IMM16)
	{
	imm16_ok:
		hs->flags |= F_IMM16;
		hs->imm.imm16 = *(uint16_t*)p;
		p += 2;
	}
	if (cflags & C_IMM8)
	{
		hs->flags |= F_IMM8;
		hs->imm.imm8 = *p++;
	}

	if (cflags & C_REL32)
	{
	rel32_ok:
		hs->flags |= F_IMM32 | F_RELATIVE;
		hs->imm.imm32 = *(uint32_t*)p;
		p += 4;
	}
	else if (cflags & C_REL8)
	{
		hs->flags |= F_IMM8 | F_RELATIVE;
		hs->imm.imm8 = *p++;
	}

disasm_done:

	if ((hs->len = (uint8_t)(p - (uint8_t*)code)) > 15)
	{
		hs->flags |= F_ERROR | F_ERROR_LENGTH;
		hs->len = 15;
	}

	return (unsigned int)hs->len;
}
#pragma warning(pop)

```

`DetectNtoskrnlIntegrity/hde64/hde64.h`:

```h
#pragma once

/*
 * Hacker Disassembler Engine 64
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 * hde64.h: C/C++ header file
 *
 */

#ifndef _HDE64_H_
#define _HDE64_H_

#include "stdint.h"
#include <intrin.h>

#define F_MODRM         0x00000001
#define F_SIB           0x00000002
#define F_IMM8          0x00000004
#define F_IMM16         0x00000008
#define F_IMM32         0x00000010
#define F_IMM64         0x00000020
#define F_DISP8         0x00000040
#define F_DISP16        0x00000080
#define F_DISP32        0x00000100
#define F_RELATIVE      0x00000200
#define F_ERROR         0x00001000
#define F_ERROR_OPCODE  0x00002000
#define F_ERROR_LENGTH  0x00004000
#define F_ERROR_LOCK    0x00008000
#define F_ERROR_OPERAND 0x00010000
#define F_PREFIX_REPNZ  0x01000000
#define F_PREFIX_REPX   0x02000000
#define F_PREFIX_REP    0x03000000
#define F_PREFIX_66     0x04000000
#define F_PREFIX_67     0x08000000
#define F_PREFIX_LOCK   0x10000000
#define F_PREFIX_SEG    0x20000000
#define F_PREFIX_REX    0x40000000
#define F_PREFIX_ANY    0x7f000000

#define PREFIX_SEGMENT_CS   0x2e
#define PREFIX_SEGMENT_SS   0x36
#define PREFIX_SEGMENT_DS   0x3e
#define PREFIX_SEGMENT_ES   0x26
#define PREFIX_SEGMENT_FS   0x64
#define PREFIX_SEGMENT_GS   0x65
#define PREFIX_LOCK         0xf0
#define PREFIX_REPNZ        0xf2
#define PREFIX_REPX         0xf3
#define PREFIX_OPERAND_SIZE 0x66
#define PREFIX_ADDRESS_SIZE 0x67

#pragma pack(push,1)

typedef struct {
    uint8_t len;
    uint8_t p_rep;
    uint8_t p_lock;
    uint8_t p_seg;
    uint8_t p_66;
    uint8_t p_67;
    uint8_t rex;
    uint8_t rex_w;
    uint8_t rex_r;
    uint8_t rex_x;
    uint8_t rex_b;
    uint8_t opcode;
    uint8_t opcode2;
    uint8_t modrm;
    uint8_t modrm_mod;
    uint8_t modrm_reg;
    uint8_t modrm_rm;
    uint8_t sib;
    uint8_t sib_scale;
    uint8_t sib_index;
    uint8_t sib_base;
    union {
        uint8_t imm8;
        uint16_t imm16;
        uint32_t imm32;
        uint64_t imm64;
    } imm;
    union {
        uint8_t disp8;
        uint16_t disp16;
        uint32_t disp32;
    } disp;
    uint32_t flags;
} hde64s;

#pragma pack(pop)

#ifdef __cplusplus
extern "C" {
#endif
    /* __cdecl */
    unsigned int hde64_disasm(const void* code, hde64s* hs);

#ifdef __cplusplus
}
#endif

#endif /* _HDE64_H_ */


```

`DetectNtoskrnlIntegrity/hde64/stdint.h`:

```h
#pragma once
#include <basetsd.h>
// Integer types for HDE. stdint.h
typedef INT8   int8_t;
typedef INT16  int16_t;
typedef INT32  int32_t;
typedef INT64  int64_t;
typedef UINT8  uint8_t;
typedef UINT16 uint16_t;
typedef UINT32 uint32_t;
typedef UINT64 uint64_t;
```

`DetectNtoskrnlIntegrity/hde64/table64.h`:

```h
#pragma once
// table64.h
#define C_NONE    0x00
#define C_MODRM   0x01
#define C_IMM8    0x02
#define C_IMM16   0x04
#define C_IMM_P66 0x10
#define C_REL8    0x20
#define C_REL32   0x40
#define C_GROUP   0x80
#define C_ERROR   0xff

#define PRE_ANY  0x00
#define PRE_NONE 0x01
#define PRE_F2   0x02
#define PRE_F3   0x04
#define PRE_66   0x08
#define PRE_67   0x10
#define PRE_LOCK 0x20
#define PRE_SEG  0x40
#define PRE_ALL  0xff

#define DELTA_OPCODES      0x4a
#define DELTA_FPU_REG      0xfd
#define DELTA_FPU_MODRM    0x104
#define DELTA_PREFIXES     0x13c
#define DELTA_OP_LOCK_OK   0x1ae
#define DELTA_OP2_LOCK_OK  0x1c6
#define DELTA_OP_ONLY_MEM  0x1d8
#define DELTA_OP2_ONLY_MEM 0x1e7

 extern unsigned char hde64_table[] = {
 0xa5,0xaa,0xa5,0xb8,0xa5,0xaa,0xa5,0xaa,0xa5,0xb8,0xa5,0xb8,0xa5,0xb8,0xa5,
 0xb8,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xac,0xc0,0xcc,0xc0,0xa1,0xa1,
 0xa1,0xa1,0xb1,0xa5,0xa5,0xa6,0xc0,0xc0,0xd7,0xda,0xe0,0xc0,0xe4,0xc0,0xea,
 0xea,0xe0,0xe0,0x98,0xc8,0xee,0xf1,0xa5,0xd3,0xa5,0xa5,0xa1,0xea,0x9e,0xc0,
 0xc0,0xc2,0xc0,0xe6,0x03,0x7f,0x11,0x7f,0x01,0x7f,0x01,0x3f,0x01,0x01,0xab,
 0x8b,0x90,0x64,0x5b,0x5b,0x5b,0x5b,0x5b,0x92,0x5b,0x5b,0x76,0x90,0x92,0x92,
 0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x6a,0x73,0x90,
 0x5b,0x52,0x52,0x52,0x52,0x5b,0x5b,0x5b,0x5b,0x77,0x7c,0x77,0x85,0x5b,0x5b,
 0x70,0x5b,0x7a,0xaf,0x76,0x76,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,
 0x5b,0x5b,0x86,0x01,0x03,0x01,0x04,0x03,0xd5,0x03,0xd5,0x03,0xcc,0x01,0xbc,
 0x03,0xf0,0x03,0x03,0x04,0x00,0x50,0x50,0x50,0x50,0xff,0x20,0x20,0x20,0x20,
 0x01,0x01,0x01,0x01,0xc4,0x02,0x10,0xff,0xff,0xff,0x01,0x00,0x03,0x11,0xff,
 0x03,0xc4,0xc6,0xc8,0x02,0x10,0x00,0xff,0xcc,0x01,0x01,0x01,0x00,0x00,0x00,
 0x00,0x01,0x01,0x03,0x01,0xff,0xff,0xc0,0xc2,0x10,0x11,0x02,0x03,0x01,0x01,
 0x01,0xff,0xff,0xff,0x00,0x00,0x00,0xff,0x00,0x00,0xff,0xff,0xff,0xff,0x10,
 0x10,0x10,0x10,0x02,0x10,0x00,0x00,0xc6,0xc8,0x02,0x02,0x02,0x02,0x06,0x00,
 0x04,0x00,0x02,0xff,0x00,0xc0,0xc2,0x01,0x01,0x03,0x03,0x03,0xca,0x40,0x00,
 0x0a,0x00,0x04,0x00,0x00,0x00,0x00,0x7f,0x00,0x33,0x01,0x00,0x00,0x00,0x00,
 0x00,0x00,0xff,0xbf,0xff,0xff,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0xff,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,
 0x00,0x00,0x00,0xbf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7f,0x00,0x00,
 0xff,0x40,0x40,0x40,0x40,0x41,0x49,0x40,0x40,0x40,0x40,0x4c,0x42,0x40,0x40,
 0x40,0x40,0x40,0x40,0x40,0x40,0x4f,0x44,0x53,0x40,0x40,0x40,0x44,0x57,0x43,
 0x5c,0x40,0x60,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,
 0x40,0x40,0x64,0x66,0x6e,0x6b,0x40,0x40,0x6a,0x46,0x40,0x40,0x44,0x46,0x40,
 0x40,0x5b,0x44,0x40,0x40,0x00,0x00,0x00,0x00,0x06,0x06,0x06,0x06,0x01,0x06,
 0x06,0x02,0x06,0x06,0x00,0x06,0x00,0x0a,0x0a,0x00,0x00,0x00,0x02,0x07,0x07,
 0x06,0x02,0x0d,0x06,0x06,0x06,0x0e,0x05,0x05,0x02,0x02,0x00,0x00,0x04,0x04,
 0x04,0x04,0x05,0x06,0x06,0x06,0x00,0x00,0x00,0x0e,0x00,0x00,0x08,0x00,0x10,
 0x00,0x18,0x00,0x20,0x00,0x28,0x00,0x30,0x00,0x80,0x01,0x82,0x01,0x86,0x00,
 0xf6,0xcf,0xfe,0x3f,0xab,0x00,0xb0,0x00,0xb1,0x00,0xb3,0x00,0xba,0xf8,0xbb,
 0x00,0xc0,0x00,0xc1,0x00,0xc7,0xbf,0x62,0xff,0x00,0x8d,0xff,0x00,0xc4,0xff,
 0x00,0xc5,0xff,0x00,0xff,0xff,0xeb,0x01,0xff,0x0e,0x12,0x08,0x00,0x13,0x09,
 0x00,0x16,0x08,0x00,0x17,0x09,0x00,0x2b,0x09,0x00,0xae,0xff,0x07,0xb2,0xff,
 0x00,0xb4,0xff,0x00,0xb5,0xff,0x00,0xc3,0x01,0x00,0xc7,0xff,0xbf,0xe7,0x08,
 0x00,0xf0,0x02,0x00
};
//end
```

`DetectNtoskrnlIntegrity/main.cpp`:

```cpp
#include <ntifs.h>
#include <intrin.h>
#include <ntimage.h>

#include "hde64/hde64.h"

#include "Structs.h"
#include "Utils.hpp"

bool DetectNtoskrnlIntegrity(ULONG64 pKernelBase) {
    // Get page table bases
    ULONG64 PageTableBases[4];
    Utils::GetPageTableBases(PageTableBases);

    ULONG64 Pml4Base = PageTableBases[0];
    ULONG64 PdptBase = PageTableBases[1];
    ULONG64 PdeBase = PageTableBases[2];
    ULONG64 PteBase = PageTableBases[3];

    // Print page table bases
    DbgPrint("Pml4Base %p\n", PageTableBases[0]);
    DbgPrint("PdptBase %p\n", PageTableBases[1]);
    DbgPrint("PdeBase %p\n", PageTableBases[2]);
    DbgPrint("PteBase %p\n", PageTableBases[3]);

    // Get CR3 information
    ULONG64 SystemPteAddress = Utils::GetSystemPteAddress(PteBase);
    ULONG64 MmPfnDataBase = *(ULONG64*)((ULONG64)&MmGetVirtualForPhysical + 0x10) - 8;

    // Get SSDT information
    SSDT_INFO SsdtInfo;
    if (!Utils::GetSsdtInfo(pKernelBase, &SsdtInfo)) return false;

    // Read the ntoskrnl.exe file
    FILE_INFO NtoskrnlInfo = Utils::ReadFile(L"\\??\\C:\\Windows\\System32\\ntoskrnl.exe");
    if (!NtoskrnlInfo.Length) return false;

    // Perform dynamic address replacements
    Utils::PerformDynamicReplacements(NtoskrnlInfo, PteBase, MmPfnDataBase, Pml4Base, PdptBase, PdeBase, SystemPteAddress);

    // Process relocations
    if (!Utils::ProcessRelocations(NtoskrnlInfo, pKernelBase)) return false;

    // Process SSDT
    if (!Utils::ProcessSsdt(NtoskrnlInfo, pKernelBase, SsdtInfo)) return false;

    // Validate read-only sections
    if (!Utils::ValidateReadOnlySections(pKernelBase, NtoskrnlInfo)) return false;

    return true;
}

VOID DriverUnload(PDRIVER_OBJECT pDriverObject)
{
    DbgPrint("ntoskrnl.exe integrity check example unloaded!\n");
    // https://www.dejavu-secure.com/
    // https://github.com/DejavuSecure
}

EXTERN_C NTSTATUS DriverEntry(PDRIVER_OBJECT pDriverObject, PUNICODE_STRING pRegistryPath) {
    pDriverObject->DriverUnload = DriverUnload;

    DbgPrint("ntoskrnl.exe integrity check example from dejavu-secure.com!\n");
    // https://www.dejavu-secure.com/
    // https://github.com/DejavuSecure

    PVOID NtoskrnlBase = Utils::GetModuleBase("ntoskrnl.exe");
    if (!NtoskrnlBase) return STATUS_UNSUCCESSFUL;

    if (DetectNtoskrnlIntegrity((ULONG64)NtoskrnlBase)) {
        DbgPrint("ntoskrnl.exe integrity check passed.\n");
    }
    else {
        DbgPrint("ntoskrnl.exe integrity check failed!\n");
    }

    return STATUS_SUCCESS;
}
```

`LICENSE`:

```
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`README.md`:

```md
# DetectNtoskrnlIntegrity

**Author**: [Dejavu Secure](https://www.dejavu-secure.com/) (既视感安全实验室)  
**Published on**: [看雪安全社区](https://bbs.kanxue.com/thread-286152.htm)  
**Test Environment**: Windows 11 23H2 (Microsoft Windows Version 10.0.22631.5039)

## Windows Kernel Security: Memory Integrity Verification with Disk Verification of ntoskrnl.exe
## Windows内核安全: 与磁盘校验 ntoskrnl.exe 的内存完整性

This article analyzes memory integrity verification methods for ntoskrnl.exe in the Windows kernel by comparing memory and disk versions to detect malicious tampering. The article examines technical details that need attention during integrity verification processes and proposes a complete verification workflow. It deeply explores solutions to challenges posed by SSDT data compression, page table randomization, and Retpoline technology on verification, providing effective safeguards for kernel program security.

本文解析了对Windows内核中ntoskrnl.exe的内存完整性校验方法，通过对比内存与磁盘版本来检测恶意篡改。文章分析在检测完整性过程中需要注意的技术细节，提出了完整的校验流程，深入探讨了如何解决SSDT数据压缩，页表随机化和Retpoline技术对校验的影响和解决方案，为内核程序运行的安全提供了有效保障。

```